
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[08:26:32.864] plan(): Setting new future strategy stack:
[08:26:32.864] List of future strategies:
[08:26:32.864] 1. sequential:
[08:26:32.864]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:32.864]    - tweaked: FALSE
[08:26:32.864]    - call: future::plan("sequential")
[08:26:32.878] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[08:26:32.918] plan(): Setting new future strategy stack:
[08:26:32.918] List of future strategies:
[08:26:32.918] 1. sequential:
[08:26:32.918]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:32.918]    - tweaked: FALSE
[08:26:32.918]    - call: plan(strategy)
[08:26:32.929] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[08:26:32.930] future_lapply() ...
[08:26:32.934] Number of chunks: 1
[08:26:32.934] getGlobalsAndPackagesXApply() ...
[08:26:32.934]  - future.globals: TRUE
[08:26:32.935] getGlobalsAndPackages() ...
[08:26:32.935] Searching for globals...
[08:26:32.937] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:32.937] Searching for globals ... DONE
[08:26:32.937] Resolving globals: FALSE
[08:26:32.938] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:32.939] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:32.939] - globals: [1] ‘FUN’
[08:26:32.939] 
[08:26:32.939] getGlobalsAndPackages() ... DONE
[08:26:32.939]  - globals found/used: [n=1] ‘FUN’
[08:26:32.939]  - needed namespaces: [n=0] 
[08:26:32.939] Finding globals ... DONE
[08:26:32.939]  - use_args: TRUE
[08:26:32.939]  - Getting '...' globals ...
[08:26:32.940] resolve() on list ...
[08:26:32.940]  recursive: 0
[08:26:32.941]  length: 1
[08:26:32.941]  elements: ‘...’
[08:26:32.941]  length: 0 (resolved future 1)
[08:26:32.941] resolve() on list ... DONE
[08:26:32.941]    - '...' content: [n=0] 
[08:26:32.941] List of 1
[08:26:32.941]  $ ...: list()
[08:26:32.941]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:32.941]  - attr(*, "where")=List of 1
[08:26:32.941]   ..$ ...:<environment: 0x55e10ea3c3c8> 
[08:26:32.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:32.941]  - attr(*, "resolved")= logi TRUE
[08:26:32.941]  - attr(*, "total_size")= num NA
[08:26:32.948]  - Getting '...' globals ... DONE
[08:26:32.948] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:32.948] List of 2
[08:26:32.948]  $ ...future.FUN:function (x)  
[08:26:32.948]  $ ...          : list()
[08:26:32.948]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:32.948]  - attr(*, "where")=List of 2
[08:26:32.948]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:32.948]   ..$ ...          :<environment: 0x55e10ea3c3c8> 
[08:26:32.948]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:32.948]  - attr(*, "resolved")= logi FALSE
[08:26:32.948]  - attr(*, "total_size")= num 5632
[08:26:32.951] Packages to be attached in all futures: [n=0] 
[08:26:32.951] getGlobalsAndPackagesXApply() ... DONE
[08:26:32.951] Number of futures (= number of chunks): 1
[08:26:32.951] Launching 1 futures (chunks) ...
[08:26:32.951] Chunk #1 of 1 ...
[08:26:32.952]  - Finding globals in 'X' for chunk #1 ...
[08:26:32.952] getGlobalsAndPackages() ...
[08:26:32.952] Searching for globals...
[08:26:32.952] 
[08:26:32.952] Searching for globals ... DONE
[08:26:32.952] - globals: [0] <none>
[08:26:32.952] getGlobalsAndPackages() ... DONE
[08:26:32.952]    + additional globals found: [n=0] 
[08:26:32.953]    + additional namespaces needed: [n=0] 
[08:26:32.953]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:32.953]  - seeds: <none>
[08:26:32.953]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:32.953] getGlobalsAndPackages() ...
[08:26:32.953] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:32.953] Resolving globals: FALSE
[08:26:32.953] Tweak future expression to call with '...' arguments ...
[08:26:32.953] {
[08:26:32.953]     do.call(function(...) {
[08:26:32.953]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:32.953]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:32.953]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:32.953]             on.exit(options(oopts), add = TRUE)
[08:26:32.953]         }
[08:26:32.953]         {
[08:26:32.953]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:32.953]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:32.953]                 ...future.FUN(...future.X_jj, ...)
[08:26:32.953]             })
[08:26:32.953]         }
[08:26:32.953]     }, args = future.call.arguments)
[08:26:32.953] }
[08:26:32.954] Tweak future expression to call with '...' arguments ... DONE
[08:26:32.954] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:32.954] 
[08:26:32.954] getGlobalsAndPackages() ... DONE
[08:26:32.955] run() for ‘Future’ ...
[08:26:32.955] - state: ‘created’
[08:26:32.955] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:32.956] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:32.956] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:32.956]   - Field: ‘label’
[08:26:32.956]   - Field: ‘local’
[08:26:32.956]   - Field: ‘owner’
[08:26:32.956]   - Field: ‘envir’
[08:26:32.956]   - Field: ‘packages’
[08:26:32.956]   - Field: ‘gc’
[08:26:32.956]   - Field: ‘conditions’
[08:26:32.956]   - Field: ‘expr’
[08:26:32.956]   - Field: ‘uuid’
[08:26:32.957]   - Field: ‘seed’
[08:26:32.957]   - Field: ‘version’
[08:26:32.957]   - Field: ‘result’
[08:26:32.957]   - Field: ‘asynchronous’
[08:26:32.957]   - Field: ‘calls’
[08:26:32.957]   - Field: ‘globals’
[08:26:32.957]   - Field: ‘stdout’
[08:26:32.957]   - Field: ‘earlySignal’
[08:26:32.957]   - Field: ‘lazy’
[08:26:32.957]   - Field: ‘state’
[08:26:32.957] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:32.957] - Launch lazy future ...
[08:26:32.958] Packages needed by the future expression (n = 0): <none>
[08:26:32.958] Packages needed by future strategies (n = 0): <none>
[08:26:32.959] {
[08:26:32.959]     {
[08:26:32.959]         {
[08:26:32.959]             ...future.startTime <- base::Sys.time()
[08:26:32.959]             {
[08:26:32.959]                 {
[08:26:32.959]                   {
[08:26:32.959]                     base::local({
[08:26:32.959]                       has_future <- base::requireNamespace("future", 
[08:26:32.959]                         quietly = TRUE)
[08:26:32.959]                       if (has_future) {
[08:26:32.959]                         ns <- base::getNamespace("future")
[08:26:32.959]                         version <- ns[[".package"]][["version"]]
[08:26:32.959]                         if (is.null(version)) 
[08:26:32.959]                           version <- utils::packageVersion("future")
[08:26:32.959]                       }
[08:26:32.959]                       else {
[08:26:32.959]                         version <- NULL
[08:26:32.959]                       }
[08:26:32.959]                       if (!has_future || version < "1.8.0") {
[08:26:32.959]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:32.959]                           "", base::R.version$version.string), 
[08:26:32.959]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:32.959]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:32.959]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:32.959]                             "release", "version")], collapse = " "), 
[08:26:32.959]                           hostname = base::Sys.info()[["nodename"]])
[08:26:32.959]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:32.959]                           info)
[08:26:32.959]                         info <- base::paste(info, collapse = "; ")
[08:26:32.959]                         if (!has_future) {
[08:26:32.959]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:32.959]                             info)
[08:26:32.959]                         }
[08:26:32.959]                         else {
[08:26:32.959]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:32.959]                             info, version)
[08:26:32.959]                         }
[08:26:32.959]                         base::stop(msg)
[08:26:32.959]                       }
[08:26:32.959]                     })
[08:26:32.959]                   }
[08:26:32.959]                   ...future.strategy.old <- future::plan("list")
[08:26:32.959]                   options(future.plan = NULL)
[08:26:32.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:32.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:32.959]                 }
[08:26:32.959]                 ...future.workdir <- getwd()
[08:26:32.959]             }
[08:26:32.959]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:32.959]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:32.959]         }
[08:26:32.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:32.959]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:32.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:32.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:32.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:32.959]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:32.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:32.959]             base::names(...future.oldOptions))
[08:26:32.959]     }
[08:26:32.959]     if (FALSE) {
[08:26:32.959]     }
[08:26:32.959]     else {
[08:26:32.959]         if (FALSE) {
[08:26:32.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:32.959]                 open = "w")
[08:26:32.959]         }
[08:26:32.959]         else {
[08:26:32.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:32.959]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:32.959]         }
[08:26:32.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:32.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:32.959]             base::sink(type = "output", split = FALSE)
[08:26:32.959]             base::close(...future.stdout)
[08:26:32.959]         }, add = TRUE)
[08:26:32.959]     }
[08:26:32.959]     ...future.frame <- base::sys.nframe()
[08:26:32.959]     ...future.conditions <- base::list()
[08:26:32.959]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:32.959]     if (FALSE) {
[08:26:32.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:32.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:32.959]     }
[08:26:32.959]     ...future.result <- base::tryCatch({
[08:26:32.959]         base::withCallingHandlers({
[08:26:32.959]             ...future.value <- base::withVisible(base::local({
[08:26:32.959]                 do.call(function(...) {
[08:26:32.959]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:32.959]                   if (!identical(...future.globals.maxSize.org, 
[08:26:32.959]                     ...future.globals.maxSize)) {
[08:26:32.959]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:32.959]                     on.exit(options(oopts), add = TRUE)
[08:26:32.959]                   }
[08:26:32.959]                   {
[08:26:32.959]                     lapply(seq_along(...future.elements_ii), 
[08:26:32.959]                       FUN = function(jj) {
[08:26:32.959]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:32.959]                         ...future.FUN(...future.X_jj, ...)
[08:26:32.959]                       })
[08:26:32.959]                   }
[08:26:32.959]                 }, args = future.call.arguments)
[08:26:32.959]             }))
[08:26:32.959]             future::FutureResult(value = ...future.value$value, 
[08:26:32.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:32.959]                   ...future.rng), globalenv = if (FALSE) 
[08:26:32.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:32.959]                     ...future.globalenv.names))
[08:26:32.959]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:32.959]         }, condition = base::local({
[08:26:32.959]             c <- base::c
[08:26:32.959]             inherits <- base::inherits
[08:26:32.959]             invokeRestart <- base::invokeRestart
[08:26:32.959]             length <- base::length
[08:26:32.959]             list <- base::list
[08:26:32.959]             seq.int <- base::seq.int
[08:26:32.959]             signalCondition <- base::signalCondition
[08:26:32.959]             sys.calls <- base::sys.calls
[08:26:32.959]             `[[` <- base::`[[`
[08:26:32.959]             `+` <- base::`+`
[08:26:32.959]             `<<-` <- base::`<<-`
[08:26:32.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:32.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:32.959]                   3L)]
[08:26:32.959]             }
[08:26:32.959]             function(cond) {
[08:26:32.959]                 is_error <- inherits(cond, "error")
[08:26:32.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:32.959]                   NULL)
[08:26:32.959]                 if (is_error) {
[08:26:32.959]                   sessionInformation <- function() {
[08:26:32.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:32.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:32.959]                       search = base::search(), system = base::Sys.info())
[08:26:32.959]                   }
[08:26:32.959]                   ...future.conditions[[length(...future.conditions) + 
[08:26:32.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:32.959]                     cond$call), session = sessionInformation(), 
[08:26:32.959]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:32.959]                   signalCondition(cond)
[08:26:32.959]                 }
[08:26:32.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:32.959]                 "immediateCondition"))) {
[08:26:32.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:32.959]                   ...future.conditions[[length(...future.conditions) + 
[08:26:32.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:32.959]                   if (TRUE && !signal) {
[08:26:32.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:32.959]                     {
[08:26:32.959]                       inherits <- base::inherits
[08:26:32.959]                       invokeRestart <- base::invokeRestart
[08:26:32.959]                       is.null <- base::is.null
[08:26:32.959]                       muffled <- FALSE
[08:26:32.959]                       if (inherits(cond, "message")) {
[08:26:32.959]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:32.959]                         if (muffled) 
[08:26:32.959]                           invokeRestart("muffleMessage")
[08:26:32.959]                       }
[08:26:32.959]                       else if (inherits(cond, "warning")) {
[08:26:32.959]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:32.959]                         if (muffled) 
[08:26:32.959]                           invokeRestart("muffleWarning")
[08:26:32.959]                       }
[08:26:32.959]                       else if (inherits(cond, "condition")) {
[08:26:32.959]                         if (!is.null(pattern)) {
[08:26:32.959]                           computeRestarts <- base::computeRestarts
[08:26:32.959]                           grepl <- base::grepl
[08:26:32.959]                           restarts <- computeRestarts(cond)
[08:26:32.959]                           for (restart in restarts) {
[08:26:32.959]                             name <- restart$name
[08:26:32.959]                             if (is.null(name)) 
[08:26:32.959]                               next
[08:26:32.959]                             if (!grepl(pattern, name)) 
[08:26:32.959]                               next
[08:26:32.959]                             invokeRestart(restart)
[08:26:32.959]                             muffled <- TRUE
[08:26:32.959]                             break
[08:26:32.959]                           }
[08:26:32.959]                         }
[08:26:32.959]                       }
[08:26:32.959]                       invisible(muffled)
[08:26:32.959]                     }
[08:26:32.959]                     muffleCondition(cond, pattern = "^muffle")
[08:26:32.959]                   }
[08:26:32.959]                 }
[08:26:32.959]                 else {
[08:26:32.959]                   if (TRUE) {
[08:26:32.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:32.959]                     {
[08:26:32.959]                       inherits <- base::inherits
[08:26:32.959]                       invokeRestart <- base::invokeRestart
[08:26:32.959]                       is.null <- base::is.null
[08:26:32.959]                       muffled <- FALSE
[08:26:32.959]                       if (inherits(cond, "message")) {
[08:26:32.959]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:32.959]                         if (muffled) 
[08:26:32.959]                           invokeRestart("muffleMessage")
[08:26:32.959]                       }
[08:26:32.959]                       else if (inherits(cond, "warning")) {
[08:26:32.959]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:32.959]                         if (muffled) 
[08:26:32.959]                           invokeRestart("muffleWarning")
[08:26:32.959]                       }
[08:26:32.959]                       else if (inherits(cond, "condition")) {
[08:26:32.959]                         if (!is.null(pattern)) {
[08:26:32.959]                           computeRestarts <- base::computeRestarts
[08:26:32.959]                           grepl <- base::grepl
[08:26:32.959]                           restarts <- computeRestarts(cond)
[08:26:32.959]                           for (restart in restarts) {
[08:26:32.959]                             name <- restart$name
[08:26:32.959]                             if (is.null(name)) 
[08:26:32.959]                               next
[08:26:32.959]                             if (!grepl(pattern, name)) 
[08:26:32.959]                               next
[08:26:32.959]                             invokeRestart(restart)
[08:26:32.959]                             muffled <- TRUE
[08:26:32.959]                             break
[08:26:32.959]                           }
[08:26:32.959]                         }
[08:26:32.959]                       }
[08:26:32.959]                       invisible(muffled)
[08:26:32.959]                     }
[08:26:32.959]                     muffleCondition(cond, pattern = "^muffle")
[08:26:32.959]                   }
[08:26:32.959]                 }
[08:26:32.959]             }
[08:26:32.959]         }))
[08:26:32.959]     }, error = function(ex) {
[08:26:32.959]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:32.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:32.959]                 ...future.rng), started = ...future.startTime, 
[08:26:32.959]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:32.959]             version = "1.8"), class = "FutureResult")
[08:26:32.959]     }, finally = {
[08:26:32.959]         if (!identical(...future.workdir, getwd())) 
[08:26:32.959]             setwd(...future.workdir)
[08:26:32.959]         {
[08:26:32.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:32.959]                 ...future.oldOptions$nwarnings <- NULL
[08:26:32.959]             }
[08:26:32.959]             base::options(...future.oldOptions)
[08:26:32.959]             if (.Platform$OS.type == "windows") {
[08:26:32.959]                 old_names <- names(...future.oldEnvVars)
[08:26:32.959]                 envs <- base::Sys.getenv()
[08:26:32.959]                 names <- names(envs)
[08:26:32.959]                 common <- intersect(names, old_names)
[08:26:32.959]                 added <- setdiff(names, old_names)
[08:26:32.959]                 removed <- setdiff(old_names, names)
[08:26:32.959]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:32.959]                   envs[common]]
[08:26:32.959]                 NAMES <- toupper(changed)
[08:26:32.959]                 args <- list()
[08:26:32.959]                 for (kk in seq_along(NAMES)) {
[08:26:32.959]                   name <- changed[[kk]]
[08:26:32.959]                   NAME <- NAMES[[kk]]
[08:26:32.959]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:32.959]                     next
[08:26:32.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:32.959]                 }
[08:26:32.959]                 NAMES <- toupper(added)
[08:26:32.959]                 for (kk in seq_along(NAMES)) {
[08:26:32.959]                   name <- added[[kk]]
[08:26:32.959]                   NAME <- NAMES[[kk]]
[08:26:32.959]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:32.959]                     next
[08:26:32.959]                   args[[name]] <- ""
[08:26:32.959]                 }
[08:26:32.959]                 NAMES <- toupper(removed)
[08:26:32.959]                 for (kk in seq_along(NAMES)) {
[08:26:32.959]                   name <- removed[[kk]]
[08:26:32.959]                   NAME <- NAMES[[kk]]
[08:26:32.959]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:32.959]                     next
[08:26:32.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:32.959]                 }
[08:26:32.959]                 if (length(args) > 0) 
[08:26:32.959]                   base::do.call(base::Sys.setenv, args = args)
[08:26:32.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:32.959]             }
[08:26:32.959]             else {
[08:26:32.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:32.959]             }
[08:26:32.959]             {
[08:26:32.959]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:32.959]                   0L) {
[08:26:32.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:32.959]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:32.959]                   base::options(opts)
[08:26:32.959]                 }
[08:26:32.959]                 {
[08:26:32.959]                   {
[08:26:32.959]                     NULL
[08:26:32.959]                     RNGkind("Mersenne-Twister")
[08:26:32.959]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:32.959]                       inherits = FALSE)
[08:26:32.959]                   }
[08:26:32.959]                   options(future.plan = NULL)
[08:26:32.959]                   if (is.na(NA_character_)) 
[08:26:32.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:32.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:32.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:32.959]                     .init = FALSE)
[08:26:32.959]                 }
[08:26:32.959]             }
[08:26:32.959]         }
[08:26:32.959]     })
[08:26:32.959]     if (TRUE) {
[08:26:32.959]         base::sink(type = "output", split = FALSE)
[08:26:32.959]         if (FALSE) {
[08:26:32.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:32.959]         }
[08:26:32.959]         else {
[08:26:32.959]             ...future.result["stdout"] <- base::list(NULL)
[08:26:32.959]         }
[08:26:32.959]         base::close(...future.stdout)
[08:26:32.959]         ...future.stdout <- NULL
[08:26:32.959]     }
[08:26:32.959]     ...future.result$conditions <- ...future.conditions
[08:26:32.959]     ...future.result$finished <- base::Sys.time()
[08:26:32.959]     ...future.result
[08:26:32.959] }
[08:26:32.961] assign_globals() ...
[08:26:32.961] List of 5
[08:26:32.961]  $ ...future.FUN            :function (x)  
[08:26:32.961]  $ future.call.arguments    : list()
[08:26:32.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:32.961]  $ ...future.elements_ii    :List of 2
[08:26:32.961]   ..$ : int 1
[08:26:32.961]   ..$ : int 0
[08:26:32.961]  $ ...future.seeds_ii       : NULL
[08:26:32.961]  $ ...future.globals.maxSize: NULL
[08:26:32.961]  - attr(*, "where")=List of 5
[08:26:32.961]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:32.961]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:32.961]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:32.961]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:32.961]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:32.961]  - attr(*, "resolved")= logi FALSE
[08:26:32.961]  - attr(*, "total_size")= num 5632
[08:26:32.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:32.961]  - attr(*, "already-done")= logi TRUE
[08:26:32.966] - reassign environment for ‘...future.FUN’
[08:26:32.966] - copied ‘...future.FUN’ to environment
[08:26:32.966] - copied ‘future.call.arguments’ to environment
[08:26:32.966] - copied ‘...future.elements_ii’ to environment
[08:26:32.966] - copied ‘...future.seeds_ii’ to environment
[08:26:32.966] - copied ‘...future.globals.maxSize’ to environment
[08:26:32.967] assign_globals() ... done
[08:26:32.967] plan(): Setting new future strategy stack:
[08:26:32.967] List of future strategies:
[08:26:32.967] 1. sequential:
[08:26:32.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:32.967]    - tweaked: FALSE
[08:26:32.967]    - call: NULL
[08:26:32.967] plan(): nbrOfWorkers() = 1
[08:26:33.470] plan(): Setting new future strategy stack:
[08:26:33.470] List of future strategies:
[08:26:33.470] 1. sequential:
[08:26:33.470]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:33.470]    - tweaked: FALSE
[08:26:33.470]    - call: plan(strategy)
[08:26:33.470] plan(): nbrOfWorkers() = 1
[08:26:33.471] SequentialFuture started (and completed)
[08:26:33.471] - Launch lazy future ... done
[08:26:33.471] run() for ‘SequentialFuture’ ... done
[08:26:33.471] Created future:
[08:26:33.471] SequentialFuture:
[08:26:33.471] Label: ‘future_lapply-1’
[08:26:33.471] Expression:
[08:26:33.471] {
[08:26:33.471]     do.call(function(...) {
[08:26:33.471]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:33.471]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:33.471]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:33.471]             on.exit(options(oopts), add = TRUE)
[08:26:33.471]         }
[08:26:33.471]         {
[08:26:33.471]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:33.471]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:33.471]                 ...future.FUN(...future.X_jj, ...)
[08:26:33.471]             })
[08:26:33.471]         }
[08:26:33.471]     }, args = future.call.arguments)
[08:26:33.471] }
[08:26:33.471] Lazy evaluation: FALSE
[08:26:33.471] Asynchronous evaluation: FALSE
[08:26:33.471] Local evaluation: TRUE
[08:26:33.471] Environment: R_GlobalEnv
[08:26:33.471] Capture standard output: FALSE
[08:26:33.471] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:33.471] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:33.471] Packages: <none>
[08:26:33.471] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:33.471] Resolved: TRUE
[08:26:33.471] Value: 55 bytes of class ‘list’
[08:26:33.471] Early signaling: FALSE
[08:26:33.471] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:33.471] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:33.473] Chunk #1 of 1 ... DONE
[08:26:33.473] Launching 1 futures (chunks) ... DONE
[08:26:33.473] Resolving 1 futures (chunks) ...
[08:26:33.473] resolve() on list ...
[08:26:33.473]  recursive: 0
[08:26:33.473]  length: 1
[08:26:33.473] 
[08:26:33.473] resolved() for ‘SequentialFuture’ ...
[08:26:33.474] - state: ‘finished’
[08:26:33.474] - run: TRUE
[08:26:33.474] - result: ‘FutureResult’
[08:26:33.474] resolved() for ‘SequentialFuture’ ... done
[08:26:33.474] Future #1
[08:26:33.474] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:33.474] - nx: 1
[08:26:33.474] - relay: TRUE
[08:26:33.474] - stdout: TRUE
[08:26:33.475] - signal: TRUE
[08:26:33.475] - resignal: FALSE
[08:26:33.475] - force: TRUE
[08:26:33.475] - relayed: [n=1] FALSE
[08:26:33.475] - queued futures: [n=1] FALSE
[08:26:33.475]  - until=1
[08:26:33.475]  - relaying element #1
[08:26:33.475] - relayed: [n=1] TRUE
[08:26:33.475] - queued futures: [n=1] TRUE
[08:26:33.475] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:33.478]  length: 0 (resolved future 1)
[08:26:33.478] Relaying remaining futures
[08:26:33.478] signalConditionsASAP(NULL, pos=0) ...
[08:26:33.478] - nx: 1
[08:26:33.478] - relay: TRUE
[08:26:33.478] - stdout: TRUE
[08:26:33.478] - signal: TRUE
[08:26:33.478] - resignal: FALSE
[08:26:33.478] - force: TRUE
[08:26:33.478] - relayed: [n=1] TRUE
[08:26:33.478] - queued futures: [n=1] TRUE
 - flush all
[08:26:33.479] - relayed: [n=1] TRUE
[08:26:33.479] - queued futures: [n=1] TRUE
[08:26:33.479] signalConditionsASAP(NULL, pos=0) ... done
[08:26:33.479] resolve() on list ... DONE
[08:26:33.479]  - Number of value chunks collected: 1
[08:26:33.479] Resolving 1 futures (chunks) ... DONE
[08:26:33.479] Reducing values from 1 chunks ...
[08:26:33.479]  - Number of values collected after concatenation: 2
[08:26:33.479]  - Number of values expected: 2
[08:26:33.479] Reducing values from 1 chunks ... DONE
[08:26:33.480] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[08:26:33.480] future_lapply() ...
[08:26:33.481] Number of chunks: 1
[08:26:33.481] getGlobalsAndPackagesXApply() ...
[08:26:33.481]  - future.globals: TRUE
[08:26:33.481] getGlobalsAndPackages() ...
[08:26:33.481] Searching for globals...
[08:26:33.482] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:33.482] Searching for globals ... DONE
[08:26:33.483] Resolving globals: FALSE
[08:26:33.483] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:33.483] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:33.483] - globals: [1] ‘FUN’
[08:26:33.483] 
[08:26:33.484] getGlobalsAndPackages() ... DONE
[08:26:33.484]  - globals found/used: [n=1] ‘FUN’
[08:26:33.484]  - needed namespaces: [n=0] 
[08:26:33.484] Finding globals ... DONE
[08:26:33.484]  - use_args: TRUE
[08:26:33.484]  - Getting '...' globals ...
[08:26:33.484] resolve() on list ...
[08:26:33.484]  recursive: 0
[08:26:33.484]  length: 1
[08:26:33.485]  elements: ‘...’
[08:26:33.485]  length: 0 (resolved future 1)
[08:26:33.485] resolve() on list ... DONE
[08:26:33.485]    - '...' content: [n=0] 
[08:26:33.485] List of 1
[08:26:33.485]  $ ...: list()
[08:26:33.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:33.485]  - attr(*, "where")=List of 1
[08:26:33.485]   ..$ ...:<environment: 0x55e10d223798> 
[08:26:33.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:33.485]  - attr(*, "resolved")= logi TRUE
[08:26:33.485]  - attr(*, "total_size")= num NA
[08:26:33.487]  - Getting '...' globals ... DONE
[08:26:33.487] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:33.488] List of 2
[08:26:33.488]  $ ...future.FUN:function (x)  
[08:26:33.488]  $ ...          : list()
[08:26:33.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:33.488]  - attr(*, "where")=List of 2
[08:26:33.488]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:33.488]   ..$ ...          :<environment: 0x55e10d223798> 
[08:26:33.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:33.488]  - attr(*, "resolved")= logi FALSE
[08:26:33.488]  - attr(*, "total_size")= num 5632
[08:26:33.490] Packages to be attached in all futures: [n=0] 
[08:26:33.490] getGlobalsAndPackagesXApply() ... DONE
[08:26:33.490] Number of futures (= number of chunks): 1
[08:26:33.491] Launching 1 futures (chunks) ...
[08:26:33.491] Chunk #1 of 1 ...
[08:26:33.491]  - Finding globals in 'X' for chunk #1 ...
[08:26:33.491] getGlobalsAndPackages() ...
[08:26:33.491] Searching for globals...
[08:26:33.491] 
[08:26:33.491] Searching for globals ... DONE
[08:26:33.491] - globals: [0] <none>
[08:26:33.491] getGlobalsAndPackages() ... DONE
[08:26:33.492]    + additional globals found: [n=0] 
[08:26:33.492]    + additional namespaces needed: [n=0] 
[08:26:33.492]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:33.492]  - seeds: <none>
[08:26:33.492]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:33.492] getGlobalsAndPackages() ...
[08:26:33.492] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:33.492] Resolving globals: FALSE
[08:26:33.492] Tweak future expression to call with '...' arguments ...
[08:26:33.492] {
[08:26:33.492]     do.call(function(...) {
[08:26:33.492]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:33.492]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:33.492]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:33.492]             on.exit(options(oopts), add = TRUE)
[08:26:33.492]         }
[08:26:33.492]         {
[08:26:33.492]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:33.492]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:33.492]                 ...future.FUN(...future.X_jj, ...)
[08:26:33.492]             })
[08:26:33.492]         }
[08:26:33.492]     }, args = future.call.arguments)
[08:26:33.492] }
[08:26:33.493] Tweak future expression to call with '...' arguments ... DONE
[08:26:33.493] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:33.493] 
[08:26:33.493] getGlobalsAndPackages() ... DONE
[08:26:33.494] run() for ‘Future’ ...
[08:26:33.494] - state: ‘created’
[08:26:33.494] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:33.494] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:33.494] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:33.494]   - Field: ‘label’
[08:26:33.494]   - Field: ‘local’
[08:26:33.494]   - Field: ‘owner’
[08:26:33.494]   - Field: ‘envir’
[08:26:33.495]   - Field: ‘packages’
[08:26:33.495]   - Field: ‘gc’
[08:26:33.495]   - Field: ‘conditions’
[08:26:33.495]   - Field: ‘expr’
[08:26:33.495]   - Field: ‘uuid’
[08:26:33.495]   - Field: ‘seed’
[08:26:33.495]   - Field: ‘version’
[08:26:33.495]   - Field: ‘result’
[08:26:33.495]   - Field: ‘asynchronous’
[08:26:33.495]   - Field: ‘calls’
[08:26:33.495]   - Field: ‘globals’
[08:26:33.496]   - Field: ‘stdout’
[08:26:33.496]   - Field: ‘earlySignal’
[08:26:33.496]   - Field: ‘lazy’
[08:26:33.496]   - Field: ‘state’
[08:26:33.496] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:33.496] - Launch lazy future ...
[08:26:33.496] Packages needed by the future expression (n = 0): <none>
[08:26:33.496] Packages needed by future strategies (n = 0): <none>
[08:26:33.497] {
[08:26:33.497]     {
[08:26:33.497]         {
[08:26:33.497]             ...future.startTime <- base::Sys.time()
[08:26:33.497]             {
[08:26:33.497]                 {
[08:26:33.497]                   {
[08:26:33.497]                     base::local({
[08:26:33.497]                       has_future <- base::requireNamespace("future", 
[08:26:33.497]                         quietly = TRUE)
[08:26:33.497]                       if (has_future) {
[08:26:33.497]                         ns <- base::getNamespace("future")
[08:26:33.497]                         version <- ns[[".package"]][["version"]]
[08:26:33.497]                         if (is.null(version)) 
[08:26:33.497]                           version <- utils::packageVersion("future")
[08:26:33.497]                       }
[08:26:33.497]                       else {
[08:26:33.497]                         version <- NULL
[08:26:33.497]                       }
[08:26:33.497]                       if (!has_future || version < "1.8.0") {
[08:26:33.497]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:33.497]                           "", base::R.version$version.string), 
[08:26:33.497]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:33.497]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:33.497]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:33.497]                             "release", "version")], collapse = " "), 
[08:26:33.497]                           hostname = base::Sys.info()[["nodename"]])
[08:26:33.497]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:33.497]                           info)
[08:26:33.497]                         info <- base::paste(info, collapse = "; ")
[08:26:33.497]                         if (!has_future) {
[08:26:33.497]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:33.497]                             info)
[08:26:33.497]                         }
[08:26:33.497]                         else {
[08:26:33.497]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:33.497]                             info, version)
[08:26:33.497]                         }
[08:26:33.497]                         base::stop(msg)
[08:26:33.497]                       }
[08:26:33.497]                     })
[08:26:33.497]                   }
[08:26:33.497]                   ...future.strategy.old <- future::plan("list")
[08:26:33.497]                   options(future.plan = NULL)
[08:26:33.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:33.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:33.497]                 }
[08:26:33.497]                 ...future.workdir <- getwd()
[08:26:33.497]             }
[08:26:33.497]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:33.497]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:33.497]         }
[08:26:33.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:33.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:33.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:33.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:33.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:33.497]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:33.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:33.497]             base::names(...future.oldOptions))
[08:26:33.497]     }
[08:26:33.497]     if (FALSE) {
[08:26:33.497]     }
[08:26:33.497]     else {
[08:26:33.497]         if (TRUE) {
[08:26:33.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:33.497]                 open = "w")
[08:26:33.497]         }
[08:26:33.497]         else {
[08:26:33.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:33.497]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:33.497]         }
[08:26:33.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:33.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:33.497]             base::sink(type = "output", split = FALSE)
[08:26:33.497]             base::close(...future.stdout)
[08:26:33.497]         }, add = TRUE)
[08:26:33.497]     }
[08:26:33.497]     ...future.frame <- base::sys.nframe()
[08:26:33.497]     ...future.conditions <- base::list()
[08:26:33.497]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:33.497]     if (FALSE) {
[08:26:33.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:33.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:33.497]     }
[08:26:33.497]     ...future.result <- base::tryCatch({
[08:26:33.497]         base::withCallingHandlers({
[08:26:33.497]             ...future.value <- base::withVisible(base::local({
[08:26:33.497]                 do.call(function(...) {
[08:26:33.497]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:33.497]                   if (!identical(...future.globals.maxSize.org, 
[08:26:33.497]                     ...future.globals.maxSize)) {
[08:26:33.497]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:33.497]                     on.exit(options(oopts), add = TRUE)
[08:26:33.497]                   }
[08:26:33.497]                   {
[08:26:33.497]                     lapply(seq_along(...future.elements_ii), 
[08:26:33.497]                       FUN = function(jj) {
[08:26:33.497]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:33.497]                         ...future.FUN(...future.X_jj, ...)
[08:26:33.497]                       })
[08:26:33.497]                   }
[08:26:33.497]                 }, args = future.call.arguments)
[08:26:33.497]             }))
[08:26:33.497]             future::FutureResult(value = ...future.value$value, 
[08:26:33.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:33.497]                   ...future.rng), globalenv = if (FALSE) 
[08:26:33.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:33.497]                     ...future.globalenv.names))
[08:26:33.497]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:33.497]         }, condition = base::local({
[08:26:33.497]             c <- base::c
[08:26:33.497]             inherits <- base::inherits
[08:26:33.497]             invokeRestart <- base::invokeRestart
[08:26:33.497]             length <- base::length
[08:26:33.497]             list <- base::list
[08:26:33.497]             seq.int <- base::seq.int
[08:26:33.497]             signalCondition <- base::signalCondition
[08:26:33.497]             sys.calls <- base::sys.calls
[08:26:33.497]             `[[` <- base::`[[`
[08:26:33.497]             `+` <- base::`+`
[08:26:33.497]             `<<-` <- base::`<<-`
[08:26:33.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:33.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:33.497]                   3L)]
[08:26:33.497]             }
[08:26:33.497]             function(cond) {
[08:26:33.497]                 is_error <- inherits(cond, "error")
[08:26:33.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:33.497]                   NULL)
[08:26:33.497]                 if (is_error) {
[08:26:33.497]                   sessionInformation <- function() {
[08:26:33.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:33.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:33.497]                       search = base::search(), system = base::Sys.info())
[08:26:33.497]                   }
[08:26:33.497]                   ...future.conditions[[length(...future.conditions) + 
[08:26:33.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:33.497]                     cond$call), session = sessionInformation(), 
[08:26:33.497]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:33.497]                   signalCondition(cond)
[08:26:33.497]                 }
[08:26:33.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:33.497]                 "immediateCondition"))) {
[08:26:33.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:33.497]                   ...future.conditions[[length(...future.conditions) + 
[08:26:33.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:33.497]                   if (TRUE && !signal) {
[08:26:33.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:33.497]                     {
[08:26:33.497]                       inherits <- base::inherits
[08:26:33.497]                       invokeRestart <- base::invokeRestart
[08:26:33.497]                       is.null <- base::is.null
[08:26:33.497]                       muffled <- FALSE
[08:26:33.497]                       if (inherits(cond, "message")) {
[08:26:33.497]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:33.497]                         if (muffled) 
[08:26:33.497]                           invokeRestart("muffleMessage")
[08:26:33.497]                       }
[08:26:33.497]                       else if (inherits(cond, "warning")) {
[08:26:33.497]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:33.497]                         if (muffled) 
[08:26:33.497]                           invokeRestart("muffleWarning")
[08:26:33.497]                       }
[08:26:33.497]                       else if (inherits(cond, "condition")) {
[08:26:33.497]                         if (!is.null(pattern)) {
[08:26:33.497]                           computeRestarts <- base::computeRestarts
[08:26:33.497]                           grepl <- base::grepl
[08:26:33.497]                           restarts <- computeRestarts(cond)
[08:26:33.497]                           for (restart in restarts) {
[08:26:33.497]                             name <- restart$name
[08:26:33.497]                             if (is.null(name)) 
[08:26:33.497]                               next
[08:26:33.497]                             if (!grepl(pattern, name)) 
[08:26:33.497]                               next
[08:26:33.497]                             invokeRestart(restart)
[08:26:33.497]                             muffled <- TRUE
[08:26:33.497]                             break
[08:26:33.497]                           }
[08:26:33.497]                         }
[08:26:33.497]                       }
[08:26:33.497]                       invisible(muffled)
[08:26:33.497]                     }
[08:26:33.497]                     muffleCondition(cond, pattern = "^muffle")
[08:26:33.497]                   }
[08:26:33.497]                 }
[08:26:33.497]                 else {
[08:26:33.497]                   if (TRUE) {
[08:26:33.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:33.497]                     {
[08:26:33.497]                       inherits <- base::inherits
[08:26:33.497]                       invokeRestart <- base::invokeRestart
[08:26:33.497]                       is.null <- base::is.null
[08:26:33.497]                       muffled <- FALSE
[08:26:33.497]                       if (inherits(cond, "message")) {
[08:26:33.497]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:33.497]                         if (muffled) 
[08:26:33.497]                           invokeRestart("muffleMessage")
[08:26:33.497]                       }
[08:26:33.497]                       else if (inherits(cond, "warning")) {
[08:26:33.497]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:33.497]                         if (muffled) 
[08:26:33.497]                           invokeRestart("muffleWarning")
[08:26:33.497]                       }
[08:26:33.497]                       else if (inherits(cond, "condition")) {
[08:26:33.497]                         if (!is.null(pattern)) {
[08:26:33.497]                           computeRestarts <- base::computeRestarts
[08:26:33.497]                           grepl <- base::grepl
[08:26:33.497]                           restarts <- computeRestarts(cond)
[08:26:33.497]                           for (restart in restarts) {
[08:26:33.497]                             name <- restart$name
[08:26:33.497]                             if (is.null(name)) 
[08:26:33.497]                               next
[08:26:33.497]                             if (!grepl(pattern, name)) 
[08:26:33.497]                               next
[08:26:33.497]                             invokeRestart(restart)
[08:26:33.497]                             muffled <- TRUE
[08:26:33.497]                             break
[08:26:33.497]                           }
[08:26:33.497]                         }
[08:26:33.497]                       }
[08:26:33.497]                       invisible(muffled)
[08:26:33.497]                     }
[08:26:33.497]                     muffleCondition(cond, pattern = "^muffle")
[08:26:33.497]                   }
[08:26:33.497]                 }
[08:26:33.497]             }
[08:26:33.497]         }))
[08:26:33.497]     }, error = function(ex) {
[08:26:33.497]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:33.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:33.497]                 ...future.rng), started = ...future.startTime, 
[08:26:33.497]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:33.497]             version = "1.8"), class = "FutureResult")
[08:26:33.497]     }, finally = {
[08:26:33.497]         if (!identical(...future.workdir, getwd())) 
[08:26:33.497]             setwd(...future.workdir)
[08:26:33.497]         {
[08:26:33.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:33.497]                 ...future.oldOptions$nwarnings <- NULL
[08:26:33.497]             }
[08:26:33.497]             base::options(...future.oldOptions)
[08:26:33.497]             if (.Platform$OS.type == "windows") {
[08:26:33.497]                 old_names <- names(...future.oldEnvVars)
[08:26:33.497]                 envs <- base::Sys.getenv()
[08:26:33.497]                 names <- names(envs)
[08:26:33.497]                 common <- intersect(names, old_names)
[08:26:33.497]                 added <- setdiff(names, old_names)
[08:26:33.497]                 removed <- setdiff(old_names, names)
[08:26:33.497]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:33.497]                   envs[common]]
[08:26:33.497]                 NAMES <- toupper(changed)
[08:26:33.497]                 args <- list()
[08:26:33.497]                 for (kk in seq_along(NAMES)) {
[08:26:33.497]                   name <- changed[[kk]]
[08:26:33.497]                   NAME <- NAMES[[kk]]
[08:26:33.497]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:33.497]                     next
[08:26:33.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:33.497]                 }
[08:26:33.497]                 NAMES <- toupper(added)
[08:26:33.497]                 for (kk in seq_along(NAMES)) {
[08:26:33.497]                   name <- added[[kk]]
[08:26:33.497]                   NAME <- NAMES[[kk]]
[08:26:33.497]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:33.497]                     next
[08:26:33.497]                   args[[name]] <- ""
[08:26:33.497]                 }
[08:26:33.497]                 NAMES <- toupper(removed)
[08:26:33.497]                 for (kk in seq_along(NAMES)) {
[08:26:33.497]                   name <- removed[[kk]]
[08:26:33.497]                   NAME <- NAMES[[kk]]
[08:26:33.497]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:33.497]                     next
[08:26:33.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:33.497]                 }
[08:26:33.497]                 if (length(args) > 0) 
[08:26:33.497]                   base::do.call(base::Sys.setenv, args = args)
[08:26:33.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:33.497]             }
[08:26:33.497]             else {
[08:26:33.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:33.497]             }
[08:26:33.497]             {
[08:26:33.497]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:33.497]                   0L) {
[08:26:33.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:33.497]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:33.497]                   base::options(opts)
[08:26:33.497]                 }
[08:26:33.497]                 {
[08:26:33.497]                   {
[08:26:33.497]                     NULL
[08:26:33.497]                     RNGkind("Mersenne-Twister")
[08:26:33.497]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:33.497]                       inherits = FALSE)
[08:26:33.497]                   }
[08:26:33.497]                   options(future.plan = NULL)
[08:26:33.497]                   if (is.na(NA_character_)) 
[08:26:33.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:33.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:33.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:33.497]                     .init = FALSE)
[08:26:33.497]                 }
[08:26:33.497]             }
[08:26:33.497]         }
[08:26:33.497]     })
[08:26:33.497]     if (TRUE) {
[08:26:33.497]         base::sink(type = "output", split = FALSE)
[08:26:33.497]         if (TRUE) {
[08:26:33.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:33.497]         }
[08:26:33.497]         else {
[08:26:33.497]             ...future.result["stdout"] <- base::list(NULL)
[08:26:33.497]         }
[08:26:33.497]         base::close(...future.stdout)
[08:26:33.497]         ...future.stdout <- NULL
[08:26:33.497]     }
[08:26:33.497]     ...future.result$conditions <- ...future.conditions
[08:26:33.497]     ...future.result$finished <- base::Sys.time()
[08:26:33.497]     ...future.result
[08:26:33.497] }
[08:26:33.499] assign_globals() ...
[08:26:33.499] List of 5
[08:26:33.499]  $ ...future.FUN            :function (x)  
[08:26:33.499]  $ future.call.arguments    : list()
[08:26:33.499]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:33.499]  $ ...future.elements_ii    :List of 2
[08:26:33.499]   ..$ : int 1
[08:26:33.499]   ..$ : int 0
[08:26:33.499]  $ ...future.seeds_ii       : NULL
[08:26:33.499]  $ ...future.globals.maxSize: NULL
[08:26:33.499]  - attr(*, "where")=List of 5
[08:26:33.499]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:33.499]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:33.499]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:33.499]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:33.499]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:33.499]  - attr(*, "resolved")= logi FALSE
[08:26:33.499]  - attr(*, "total_size")= num 5632
[08:26:33.499]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:33.499]  - attr(*, "already-done")= logi TRUE
[08:26:33.505] - reassign environment for ‘...future.FUN’
[08:26:33.505] - copied ‘...future.FUN’ to environment
[08:26:33.505] - copied ‘future.call.arguments’ to environment
[08:26:33.505] - copied ‘...future.elements_ii’ to environment
[08:26:33.505] - copied ‘...future.seeds_ii’ to environment
[08:26:33.505] - copied ‘...future.globals.maxSize’ to environment
[08:26:33.506] assign_globals() ... done
[08:26:33.506] plan(): Setting new future strategy stack:
[08:26:33.506] List of future strategies:
[08:26:33.506] 1. sequential:
[08:26:33.506]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:33.506]    - tweaked: FALSE
[08:26:33.506]    - call: NULL
[08:26:33.506] plan(): nbrOfWorkers() = 1
[08:26:34.008] plan(): Setting new future strategy stack:
[08:26:34.008] List of future strategies:
[08:26:34.008] 1. sequential:
[08:26:34.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:34.008]    - tweaked: FALSE
[08:26:34.008]    - call: plan(strategy)
[08:26:34.009] plan(): nbrOfWorkers() = 1
[08:26:34.009] SequentialFuture started (and completed)
[08:26:34.009] - Launch lazy future ... done
[08:26:34.009] run() for ‘SequentialFuture’ ... done
[08:26:34.010] Created future:
[08:26:34.010] SequentialFuture:
[08:26:34.010] Label: ‘future_lapply-1’
[08:26:34.010] Expression:
[08:26:34.010] {
[08:26:34.010]     do.call(function(...) {
[08:26:34.010]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:34.010]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:34.010]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:34.010]             on.exit(options(oopts), add = TRUE)
[08:26:34.010]         }
[08:26:34.010]         {
[08:26:34.010]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:34.010]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:34.010]                 ...future.FUN(...future.X_jj, ...)
[08:26:34.010]             })
[08:26:34.010]         }
[08:26:34.010]     }, args = future.call.arguments)
[08:26:34.010] }
[08:26:34.010] Lazy evaluation: FALSE
[08:26:34.010] Asynchronous evaluation: FALSE
[08:26:34.010] Local evaluation: TRUE
[08:26:34.010] Environment: R_GlobalEnv
[08:26:34.010] Capture standard output: TRUE
[08:26:34.010] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:34.010] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:34.010] Packages: <none>
[08:26:34.010] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:34.010] Resolved: TRUE
[08:26:34.010] Value: 55 bytes of class ‘list’
[08:26:34.010] Early signaling: FALSE
[08:26:34.010] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:34.010] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:34.011] Chunk #1 of 1 ... DONE
[08:26:34.011] Launching 1 futures (chunks) ... DONE
[08:26:34.011] Resolving 1 futures (chunks) ...
[08:26:34.011] resolve() on list ...
[08:26:34.011]  recursive: 0
[08:26:34.011]  length: 1
[08:26:34.011] 
[08:26:34.011] resolved() for ‘SequentialFuture’ ...
[08:26:34.011] - state: ‘finished’
[08:26:34.011] - run: TRUE
[08:26:34.011] - result: ‘FutureResult’
[08:26:34.012] resolved() for ‘SequentialFuture’ ... done
[08:26:34.012] Future #1
[08:26:34.012] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:34.012] - nx: 1
[08:26:34.012] - relay: TRUE
[08:26:34.012] - stdout: TRUE
[08:26:34.012] - signal: TRUE
[08:26:34.012] - resignal: FALSE
[08:26:34.012] - force: TRUE
[08:26:34.012] - relayed: [n=1] FALSE
[08:26:34.012] - queued futures: [n=1] FALSE
[08:26:34.013]  - until=1
[08:26:34.013]  - relaying element #1
[08:26:34.013] - relayed: [n=1] TRUE
[08:26:34.013] - queued futures: [n=1] TRUE
[08:26:34.013] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:34.013]  length: 0 (resolved future 1)
[08:26:34.013] Relaying remaining futures
[08:26:34.013] signalConditionsASAP(NULL, pos=0) ...
[08:26:34.013] - nx: 1
[08:26:34.013] - relay: TRUE
[08:26:34.014] - stdout: TRUE
[08:26:34.014] - signal: TRUE
[08:26:34.014] - resignal: FALSE
[08:26:34.014] - force: TRUE
[08:26:34.014] - relayed: [n=1] TRUE
[08:26:34.014] - queued futures: [n=1] TRUE
 - flush all
[08:26:34.014] - relayed: [n=1] TRUE
[08:26:34.014] - queued futures: [n=1] TRUE
[08:26:34.014] signalConditionsASAP(NULL, pos=0) ... done
[08:26:34.014] resolve() on list ... DONE
[08:26:34.014]  - Number of value chunks collected: 1
[08:26:34.014] Resolving 1 futures (chunks) ... DONE
[08:26:34.015] Reducing values from 1 chunks ...
[08:26:34.015]  - Number of values collected after concatenation: 2
[08:26:34.015]  - Number of values expected: 2
[08:26:34.015] Reducing values from 1 chunks ... DONE
[08:26:34.015] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[08:26:34.015] future_lapply() ...
[08:26:34.016] Number of chunks: 1
[08:26:34.016] getGlobalsAndPackagesXApply() ...
[08:26:34.016]  - future.globals: TRUE
[08:26:34.016] getGlobalsAndPackages() ...
[08:26:34.016] Searching for globals...
[08:26:34.018] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:34.018] Searching for globals ... DONE
[08:26:34.018] Resolving globals: FALSE
[08:26:34.018] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:34.019] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:34.019] - globals: [1] ‘FUN’
[08:26:34.019] 
[08:26:34.019] getGlobalsAndPackages() ... DONE
[08:26:34.019]  - globals found/used: [n=1] ‘FUN’
[08:26:34.019]  - needed namespaces: [n=0] 
[08:26:34.019] Finding globals ... DONE
[08:26:34.019]  - use_args: TRUE
[08:26:34.019]  - Getting '...' globals ...
[08:26:34.020] resolve() on list ...
[08:26:34.020]  recursive: 0
[08:26:34.020]  length: 1
[08:26:34.020]  elements: ‘...’
[08:26:34.020]  length: 0 (resolved future 1)
[08:26:34.020] resolve() on list ... DONE
[08:26:34.020]    - '...' content: [n=0] 
[08:26:34.020] List of 1
[08:26:34.020]  $ ...: list()
[08:26:34.020]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:34.020]  - attr(*, "where")=List of 1
[08:26:34.020]   ..$ ...:<environment: 0x55e10e08d9e0> 
[08:26:34.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:34.020]  - attr(*, "resolved")= logi TRUE
[08:26:34.020]  - attr(*, "total_size")= num NA
[08:26:34.023]  - Getting '...' globals ... DONE
[08:26:34.023] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:34.023] List of 2
[08:26:34.023]  $ ...future.FUN:function (x)  
[08:26:34.023]  $ ...          : list()
[08:26:34.023]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:34.023]  - attr(*, "where")=List of 2
[08:26:34.023]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:34.023]   ..$ ...          :<environment: 0x55e10e08d9e0> 
[08:26:34.023]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:34.023]  - attr(*, "resolved")= logi FALSE
[08:26:34.023]  - attr(*, "total_size")= num 5632
[08:26:34.026] Packages to be attached in all futures: [n=0] 
[08:26:34.026] getGlobalsAndPackagesXApply() ... DONE
[08:26:34.026] Number of futures (= number of chunks): 1
[08:26:34.026] Launching 1 futures (chunks) ...
[08:26:34.026] Chunk #1 of 1 ...
[08:26:34.026]  - Finding globals in 'X' for chunk #1 ...
[08:26:34.026] getGlobalsAndPackages() ...
[08:26:34.027] Searching for globals...
[08:26:34.027] 
[08:26:34.027] Searching for globals ... DONE
[08:26:34.027] - globals: [0] <none>
[08:26:34.027] getGlobalsAndPackages() ... DONE
[08:26:34.027]    + additional globals found: [n=0] 
[08:26:34.027]    + additional namespaces needed: [n=0] 
[08:26:34.027]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:34.027]  - seeds: <none>
[08:26:34.027]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:34.028] getGlobalsAndPackages() ...
[08:26:34.028] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:34.028] Resolving globals: FALSE
[08:26:34.028] Tweak future expression to call with '...' arguments ...
[08:26:34.028] {
[08:26:34.028]     do.call(function(...) {
[08:26:34.028]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:34.028]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:34.028]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:34.028]             on.exit(options(oopts), add = TRUE)
[08:26:34.028]         }
[08:26:34.028]         {
[08:26:34.028]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:34.028]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:34.028]                 ...future.FUN(...future.X_jj, ...)
[08:26:34.028]             })
[08:26:34.028]         }
[08:26:34.028]     }, args = future.call.arguments)
[08:26:34.028] }
[08:26:34.030] Tweak future expression to call with '...' arguments ... DONE
[08:26:34.030] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:34.030] 
[08:26:34.030] getGlobalsAndPackages() ... DONE
[08:26:34.031] run() for ‘Future’ ...
[08:26:34.031] - state: ‘created’
[08:26:34.031] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:34.031] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:34.031] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:34.031]   - Field: ‘label’
[08:26:34.032]   - Field: ‘local’
[08:26:34.032]   - Field: ‘owner’
[08:26:34.032]   - Field: ‘envir’
[08:26:34.032]   - Field: ‘packages’
[08:26:34.032]   - Field: ‘gc’
[08:26:34.032]   - Field: ‘conditions’
[08:26:34.032]   - Field: ‘expr’
[08:26:34.032]   - Field: ‘uuid’
[08:26:34.032]   - Field: ‘seed’
[08:26:34.032]   - Field: ‘version’
[08:26:34.032]   - Field: ‘result’
[08:26:34.032]   - Field: ‘asynchronous’
[08:26:34.033]   - Field: ‘calls’
[08:26:34.033]   - Field: ‘globals’
[08:26:34.033]   - Field: ‘stdout’
[08:26:34.033]   - Field: ‘earlySignal’
[08:26:34.033]   - Field: ‘lazy’
[08:26:34.033]   - Field: ‘state’
[08:26:34.033] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:34.033] - Launch lazy future ...
[08:26:34.033] Packages needed by the future expression (n = 0): <none>
[08:26:34.033] Packages needed by future strategies (n = 0): <none>
[08:26:34.034] {
[08:26:34.034]     {
[08:26:34.034]         {
[08:26:34.034]             ...future.startTime <- base::Sys.time()
[08:26:34.034]             {
[08:26:34.034]                 {
[08:26:34.034]                   {
[08:26:34.034]                     base::local({
[08:26:34.034]                       has_future <- base::requireNamespace("future", 
[08:26:34.034]                         quietly = TRUE)
[08:26:34.034]                       if (has_future) {
[08:26:34.034]                         ns <- base::getNamespace("future")
[08:26:34.034]                         version <- ns[[".package"]][["version"]]
[08:26:34.034]                         if (is.null(version)) 
[08:26:34.034]                           version <- utils::packageVersion("future")
[08:26:34.034]                       }
[08:26:34.034]                       else {
[08:26:34.034]                         version <- NULL
[08:26:34.034]                       }
[08:26:34.034]                       if (!has_future || version < "1.8.0") {
[08:26:34.034]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:34.034]                           "", base::R.version$version.string), 
[08:26:34.034]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:34.034]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:34.034]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:34.034]                             "release", "version")], collapse = " "), 
[08:26:34.034]                           hostname = base::Sys.info()[["nodename"]])
[08:26:34.034]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:34.034]                           info)
[08:26:34.034]                         info <- base::paste(info, collapse = "; ")
[08:26:34.034]                         if (!has_future) {
[08:26:34.034]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:34.034]                             info)
[08:26:34.034]                         }
[08:26:34.034]                         else {
[08:26:34.034]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:34.034]                             info, version)
[08:26:34.034]                         }
[08:26:34.034]                         base::stop(msg)
[08:26:34.034]                       }
[08:26:34.034]                     })
[08:26:34.034]                   }
[08:26:34.034]                   ...future.strategy.old <- future::plan("list")
[08:26:34.034]                   options(future.plan = NULL)
[08:26:34.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:34.034]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:34.034]                 }
[08:26:34.034]                 ...future.workdir <- getwd()
[08:26:34.034]             }
[08:26:34.034]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:34.034]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:34.034]         }
[08:26:34.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:34.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:34.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:34.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:34.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:34.034]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:34.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:34.034]             base::names(...future.oldOptions))
[08:26:34.034]     }
[08:26:34.034]     if (TRUE) {
[08:26:34.034]     }
[08:26:34.034]     else {
[08:26:34.034]         if (NA) {
[08:26:34.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:34.034]                 open = "w")
[08:26:34.034]         }
[08:26:34.034]         else {
[08:26:34.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:34.034]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:34.034]         }
[08:26:34.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:34.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:34.034]             base::sink(type = "output", split = FALSE)
[08:26:34.034]             base::close(...future.stdout)
[08:26:34.034]         }, add = TRUE)
[08:26:34.034]     }
[08:26:34.034]     ...future.frame <- base::sys.nframe()
[08:26:34.034]     ...future.conditions <- base::list()
[08:26:34.034]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:34.034]     if (FALSE) {
[08:26:34.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:34.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:34.034]     }
[08:26:34.034]     ...future.result <- base::tryCatch({
[08:26:34.034]         base::withCallingHandlers({
[08:26:34.034]             ...future.value <- base::withVisible(base::local({
[08:26:34.034]                 do.call(function(...) {
[08:26:34.034]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:34.034]                   if (!identical(...future.globals.maxSize.org, 
[08:26:34.034]                     ...future.globals.maxSize)) {
[08:26:34.034]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:34.034]                     on.exit(options(oopts), add = TRUE)
[08:26:34.034]                   }
[08:26:34.034]                   {
[08:26:34.034]                     lapply(seq_along(...future.elements_ii), 
[08:26:34.034]                       FUN = function(jj) {
[08:26:34.034]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:34.034]                         ...future.FUN(...future.X_jj, ...)
[08:26:34.034]                       })
[08:26:34.034]                   }
[08:26:34.034]                 }, args = future.call.arguments)
[08:26:34.034]             }))
[08:26:34.034]             future::FutureResult(value = ...future.value$value, 
[08:26:34.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:34.034]                   ...future.rng), globalenv = if (FALSE) 
[08:26:34.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:34.034]                     ...future.globalenv.names))
[08:26:34.034]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:34.034]         }, condition = base::local({
[08:26:34.034]             c <- base::c
[08:26:34.034]             inherits <- base::inherits
[08:26:34.034]             invokeRestart <- base::invokeRestart
[08:26:34.034]             length <- base::length
[08:26:34.034]             list <- base::list
[08:26:34.034]             seq.int <- base::seq.int
[08:26:34.034]             signalCondition <- base::signalCondition
[08:26:34.034]             sys.calls <- base::sys.calls
[08:26:34.034]             `[[` <- base::`[[`
[08:26:34.034]             `+` <- base::`+`
[08:26:34.034]             `<<-` <- base::`<<-`
[08:26:34.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:34.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:34.034]                   3L)]
[08:26:34.034]             }
[08:26:34.034]             function(cond) {
[08:26:34.034]                 is_error <- inherits(cond, "error")
[08:26:34.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:34.034]                   NULL)
[08:26:34.034]                 if (is_error) {
[08:26:34.034]                   sessionInformation <- function() {
[08:26:34.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:34.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:34.034]                       search = base::search(), system = base::Sys.info())
[08:26:34.034]                   }
[08:26:34.034]                   ...future.conditions[[length(...future.conditions) + 
[08:26:34.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:34.034]                     cond$call), session = sessionInformation(), 
[08:26:34.034]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:34.034]                   signalCondition(cond)
[08:26:34.034]                 }
[08:26:34.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:34.034]                 "immediateCondition"))) {
[08:26:34.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:34.034]                   ...future.conditions[[length(...future.conditions) + 
[08:26:34.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:34.034]                   if (TRUE && !signal) {
[08:26:34.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:34.034]                     {
[08:26:34.034]                       inherits <- base::inherits
[08:26:34.034]                       invokeRestart <- base::invokeRestart
[08:26:34.034]                       is.null <- base::is.null
[08:26:34.034]                       muffled <- FALSE
[08:26:34.034]                       if (inherits(cond, "message")) {
[08:26:34.034]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:34.034]                         if (muffled) 
[08:26:34.034]                           invokeRestart("muffleMessage")
[08:26:34.034]                       }
[08:26:34.034]                       else if (inherits(cond, "warning")) {
[08:26:34.034]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:34.034]                         if (muffled) 
[08:26:34.034]                           invokeRestart("muffleWarning")
[08:26:34.034]                       }
[08:26:34.034]                       else if (inherits(cond, "condition")) {
[08:26:34.034]                         if (!is.null(pattern)) {
[08:26:34.034]                           computeRestarts <- base::computeRestarts
[08:26:34.034]                           grepl <- base::grepl
[08:26:34.034]                           restarts <- computeRestarts(cond)
[08:26:34.034]                           for (restart in restarts) {
[08:26:34.034]                             name <- restart$name
[08:26:34.034]                             if (is.null(name)) 
[08:26:34.034]                               next
[08:26:34.034]                             if (!grepl(pattern, name)) 
[08:26:34.034]                               next
[08:26:34.034]                             invokeRestart(restart)
[08:26:34.034]                             muffled <- TRUE
[08:26:34.034]                             break
[08:26:34.034]                           }
[08:26:34.034]                         }
[08:26:34.034]                       }
[08:26:34.034]                       invisible(muffled)
[08:26:34.034]                     }
[08:26:34.034]                     muffleCondition(cond, pattern = "^muffle")
[08:26:34.034]                   }
[08:26:34.034]                 }
[08:26:34.034]                 else {
[08:26:34.034]                   if (TRUE) {
[08:26:34.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:34.034]                     {
[08:26:34.034]                       inherits <- base::inherits
[08:26:34.034]                       invokeRestart <- base::invokeRestart
[08:26:34.034]                       is.null <- base::is.null
[08:26:34.034]                       muffled <- FALSE
[08:26:34.034]                       if (inherits(cond, "message")) {
[08:26:34.034]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:34.034]                         if (muffled) 
[08:26:34.034]                           invokeRestart("muffleMessage")
[08:26:34.034]                       }
[08:26:34.034]                       else if (inherits(cond, "warning")) {
[08:26:34.034]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:34.034]                         if (muffled) 
[08:26:34.034]                           invokeRestart("muffleWarning")
[08:26:34.034]                       }
[08:26:34.034]                       else if (inherits(cond, "condition")) {
[08:26:34.034]                         if (!is.null(pattern)) {
[08:26:34.034]                           computeRestarts <- base::computeRestarts
[08:26:34.034]                           grepl <- base::grepl
[08:26:34.034]                           restarts <- computeRestarts(cond)
[08:26:34.034]                           for (restart in restarts) {
[08:26:34.034]                             name <- restart$name
[08:26:34.034]                             if (is.null(name)) 
[08:26:34.034]                               next
[08:26:34.034]                             if (!grepl(pattern, name)) 
[08:26:34.034]                               next
[08:26:34.034]                             invokeRestart(restart)
[08:26:34.034]                             muffled <- TRUE
[08:26:34.034]                             break
[08:26:34.034]                           }
[08:26:34.034]                         }
[08:26:34.034]                       }
[08:26:34.034]                       invisible(muffled)
[08:26:34.034]                     }
[08:26:34.034]                     muffleCondition(cond, pattern = "^muffle")
[08:26:34.034]                   }
[08:26:34.034]                 }
[08:26:34.034]             }
[08:26:34.034]         }))
[08:26:34.034]     }, error = function(ex) {
[08:26:34.034]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:34.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:34.034]                 ...future.rng), started = ...future.startTime, 
[08:26:34.034]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:34.034]             version = "1.8"), class = "FutureResult")
[08:26:34.034]     }, finally = {
[08:26:34.034]         if (!identical(...future.workdir, getwd())) 
[08:26:34.034]             setwd(...future.workdir)
[08:26:34.034]         {
[08:26:34.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:34.034]                 ...future.oldOptions$nwarnings <- NULL
[08:26:34.034]             }
[08:26:34.034]             base::options(...future.oldOptions)
[08:26:34.034]             if (.Platform$OS.type == "windows") {
[08:26:34.034]                 old_names <- names(...future.oldEnvVars)
[08:26:34.034]                 envs <- base::Sys.getenv()
[08:26:34.034]                 names <- names(envs)
[08:26:34.034]                 common <- intersect(names, old_names)
[08:26:34.034]                 added <- setdiff(names, old_names)
[08:26:34.034]                 removed <- setdiff(old_names, names)
[08:26:34.034]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:34.034]                   envs[common]]
[08:26:34.034]                 NAMES <- toupper(changed)
[08:26:34.034]                 args <- list()
[08:26:34.034]                 for (kk in seq_along(NAMES)) {
[08:26:34.034]                   name <- changed[[kk]]
[08:26:34.034]                   NAME <- NAMES[[kk]]
[08:26:34.034]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:34.034]                     next
[08:26:34.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:34.034]                 }
[08:26:34.034]                 NAMES <- toupper(added)
[08:26:34.034]                 for (kk in seq_along(NAMES)) {
[08:26:34.034]                   name <- added[[kk]]
[08:26:34.034]                   NAME <- NAMES[[kk]]
[08:26:34.034]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:34.034]                     next
[08:26:34.034]                   args[[name]] <- ""
[08:26:34.034]                 }
[08:26:34.034]                 NAMES <- toupper(removed)
[08:26:34.034]                 for (kk in seq_along(NAMES)) {
[08:26:34.034]                   name <- removed[[kk]]
[08:26:34.034]                   NAME <- NAMES[[kk]]
[08:26:34.034]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:34.034]                     next
[08:26:34.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:34.034]                 }
[08:26:34.034]                 if (length(args) > 0) 
[08:26:34.034]                   base::do.call(base::Sys.setenv, args = args)
[08:26:34.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:34.034]             }
[08:26:34.034]             else {
[08:26:34.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:34.034]             }
[08:26:34.034]             {
[08:26:34.034]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:34.034]                   0L) {
[08:26:34.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:34.034]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:34.034]                   base::options(opts)
[08:26:34.034]                 }
[08:26:34.034]                 {
[08:26:34.034]                   {
[08:26:34.034]                     NULL
[08:26:34.034]                     RNGkind("Mersenne-Twister")
[08:26:34.034]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:34.034]                       inherits = FALSE)
[08:26:34.034]                   }
[08:26:34.034]                   options(future.plan = NULL)
[08:26:34.034]                   if (is.na(NA_character_)) 
[08:26:34.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:34.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:34.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:34.034]                     .init = FALSE)
[08:26:34.034]                 }
[08:26:34.034]             }
[08:26:34.034]         }
[08:26:34.034]     })
[08:26:34.034]     if (FALSE) {
[08:26:34.034]         base::sink(type = "output", split = FALSE)
[08:26:34.034]         if (NA) {
[08:26:34.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:34.034]         }
[08:26:34.034]         else {
[08:26:34.034]             ...future.result["stdout"] <- base::list(NULL)
[08:26:34.034]         }
[08:26:34.034]         base::close(...future.stdout)
[08:26:34.034]         ...future.stdout <- NULL
[08:26:34.034]     }
[08:26:34.034]     ...future.result$conditions <- ...future.conditions
[08:26:34.034]     ...future.result$finished <- base::Sys.time()
[08:26:34.034]     ...future.result
[08:26:34.034] }
[08:26:34.036] assign_globals() ...
[08:26:34.036] List of 5
[08:26:34.036]  $ ...future.FUN            :function (x)  
[08:26:34.036]  $ future.call.arguments    : list()
[08:26:34.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:34.036]  $ ...future.elements_ii    :List of 2
[08:26:34.036]   ..$ : int 1
[08:26:34.036]   ..$ : int 0
[08:26:34.036]  $ ...future.seeds_ii       : NULL
[08:26:34.036]  $ ...future.globals.maxSize: NULL
[08:26:34.036]  - attr(*, "where")=List of 5
[08:26:34.036]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:34.036]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:34.036]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:34.036]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:34.036]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:34.036]  - attr(*, "resolved")= logi FALSE
[08:26:34.036]  - attr(*, "total_size")= num 5632
[08:26:34.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:34.036]  - attr(*, "already-done")= logi TRUE
[08:26:34.041] - reassign environment for ‘...future.FUN’
[08:26:34.041] - copied ‘...future.FUN’ to environment
[08:26:34.041] - copied ‘future.call.arguments’ to environment
[08:26:34.041] - copied ‘...future.elements_ii’ to environment
[08:26:34.041] - copied ‘...future.seeds_ii’ to environment
[08:26:34.041] - copied ‘...future.globals.maxSize’ to environment
[08:26:34.041] assign_globals() ... done
[08:26:34.041] plan(): Setting new future strategy stack:
[08:26:34.042] List of future strategies:
[08:26:34.042] 1. sequential:
[08:26:34.042]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:34.042]    - tweaked: FALSE
[08:26:34.042]    - call: NULL
[08:26:34.042] plan(): nbrOfWorkers() = 1
[08:26:34.544] plan(): Setting new future strategy stack:
[08:26:34.544] List of future strategies:
[08:26:34.544] 1. sequential:
[08:26:34.544]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:34.544]    - tweaked: FALSE
[08:26:34.544]    - call: plan(strategy)
[08:26:34.545] plan(): nbrOfWorkers() = 1
[08:26:34.545] SequentialFuture started (and completed)
[08:26:34.545] - Launch lazy future ... done
[08:26:34.545] run() for ‘SequentialFuture’ ... done
[08:26:34.545] Created future:
[08:26:34.545] SequentialFuture:
[08:26:34.545] Label: ‘future_lapply-1’
[08:26:34.545] Expression:
[08:26:34.545] {
[08:26:34.545]     do.call(function(...) {
[08:26:34.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:34.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:34.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:34.545]             on.exit(options(oopts), add = TRUE)
[08:26:34.545]         }
[08:26:34.545]         {
[08:26:34.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:34.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:34.545]                 ...future.FUN(...future.X_jj, ...)
[08:26:34.545]             })
[08:26:34.545]         }
[08:26:34.545]     }, args = future.call.arguments)
[08:26:34.545] }
[08:26:34.545] Lazy evaluation: FALSE
[08:26:34.545] Asynchronous evaluation: FALSE
[08:26:34.545] Local evaluation: TRUE
[08:26:34.545] Environment: R_GlobalEnv
[08:26:34.545] Capture standard output: NA
[08:26:34.545] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:34.545] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:34.545] Packages: <none>
[08:26:34.545] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:34.545] Resolved: TRUE
[08:26:34.545] Value: 55 bytes of class ‘list’
[08:26:34.545] Early signaling: FALSE
[08:26:34.545] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:34.545] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:34.546] Chunk #1 of 1 ... DONE
[08:26:34.546] Launching 1 futures (chunks) ... DONE
[08:26:34.546] Resolving 1 futures (chunks) ...
[08:26:34.546] resolve() on list ...
[08:26:34.546]  recursive: 0
[08:26:34.546]  length: 1
[08:26:34.547] 
[08:26:34.547] resolved() for ‘SequentialFuture’ ...
[08:26:34.547] - state: ‘finished’
[08:26:34.547] - run: TRUE
[08:26:34.547] - result: ‘FutureResult’
[08:26:34.547] resolved() for ‘SequentialFuture’ ... done
[08:26:34.547] Future #1
[08:26:34.547] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:34.547] - nx: 1
[08:26:34.547] - relay: TRUE
[08:26:34.548] - stdout: TRUE
[08:26:34.548] - signal: TRUE
[08:26:34.548] - resignal: FALSE
[08:26:34.548] - force: TRUE
[08:26:34.548] - relayed: [n=1] FALSE
[08:26:34.548] - queued futures: [n=1] FALSE
[08:26:34.548]  - until=1
[08:26:34.548]  - relaying element #1
[08:26:34.548] - relayed: [n=1] TRUE
[08:26:34.548] - queued futures: [n=1] TRUE
[08:26:34.548] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:34.549]  length: 0 (resolved future 1)
[08:26:34.549] Relaying remaining futures
[08:26:34.549] signalConditionsASAP(NULL, pos=0) ...
[08:26:34.549] - nx: 1
[08:26:34.549] - relay: TRUE
[08:26:34.549] - stdout: TRUE
[08:26:34.549] - signal: TRUE
[08:26:34.549] - resignal: FALSE
[08:26:34.549] - force: TRUE
[08:26:34.549] - relayed: [n=1] TRUE
[08:26:34.549] - queued futures: [n=1] TRUE
 - flush all
[08:26:34.549] - relayed: [n=1] TRUE
[08:26:34.550] - queued futures: [n=1] TRUE
[08:26:34.550] signalConditionsASAP(NULL, pos=0) ... done
[08:26:34.550] resolve() on list ... DONE
[08:26:34.550]  - Number of value chunks collected: 1
[08:26:34.550] Resolving 1 futures (chunks) ... DONE
[08:26:34.550] Reducing values from 1 chunks ...
[08:26:34.550]  - Number of values collected after concatenation: 2
[08:26:34.550]  - Number of values expected: 2
[08:26:34.550] Reducing values from 1 chunks ... DONE
[08:26:34.550] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[08:26:34.551] future_mapply() ...
[08:26:34.551] Number of chunks: 1
[08:26:34.551] getGlobalsAndPackagesXApply() ...
[08:26:34.551]  - future.globals: TRUE
[08:26:34.551] getGlobalsAndPackages() ...
[08:26:34.551] Searching for globals...
[08:26:34.553] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:34.553] Searching for globals ... DONE
[08:26:34.553] Resolving globals: FALSE
[08:26:34.554] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:34.554] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:34.554] - globals: [1] ‘FUN’
[08:26:34.554] 
[08:26:34.554] getGlobalsAndPackages() ... DONE
[08:26:34.554]  - globals found/used: [n=1] ‘FUN’
[08:26:34.554]  - needed namespaces: [n=0] 
[08:26:34.554] Finding globals ... DONE
[08:26:34.555] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:34.555] List of 2
[08:26:34.555]  $ ...future.FUN:function (x, y)  
[08:26:34.555]  $ MoreArgs     : NULL
[08:26:34.555]  - attr(*, "where")=List of 2
[08:26:34.555]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:34.555]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:34.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:34.555]  - attr(*, "resolved")= logi FALSE
[08:26:34.555]  - attr(*, "total_size")= num NA
[08:26:34.559] Packages to be attached in all futures: [n=0] 
[08:26:34.559] getGlobalsAndPackagesXApply() ... DONE
[08:26:34.559] Number of futures (= number of chunks): 1
[08:26:34.559] Launching 1 futures (chunks) ...
[08:26:34.560] Chunk #1 of 1 ...
[08:26:34.560]  - Finding globals in '...' for chunk #1 ...
[08:26:34.560] getGlobalsAndPackages() ...
[08:26:34.560] Searching for globals...
[08:26:34.560] 
[08:26:34.560] Searching for globals ... DONE
[08:26:34.560] - globals: [0] <none>
[08:26:34.560] getGlobalsAndPackages() ... DONE
[08:26:34.561]    + additional globals found: [n=0] 
[08:26:34.561]    + additional namespaces needed: [n=0] 
[08:26:34.561]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:34.561]  - seeds: <none>
[08:26:34.561]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:34.561] getGlobalsAndPackages() ...
[08:26:34.561] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:34.561] Resolving globals: FALSE
[08:26:34.562] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[08:26:34.562] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:34.562] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:34.562] 
[08:26:34.562] getGlobalsAndPackages() ... DONE
[08:26:34.563] run() for ‘Future’ ...
[08:26:34.563] - state: ‘created’
[08:26:34.563] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:34.563] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:34.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:34.563]   - Field: ‘label’
[08:26:34.564]   - Field: ‘local’
[08:26:34.564]   - Field: ‘owner’
[08:26:34.564]   - Field: ‘envir’
[08:26:34.564]   - Field: ‘packages’
[08:26:34.564]   - Field: ‘gc’
[08:26:34.564]   - Field: ‘conditions’
[08:26:34.564]   - Field: ‘expr’
[08:26:34.564]   - Field: ‘uuid’
[08:26:34.564]   - Field: ‘seed’
[08:26:34.564]   - Field: ‘version’
[08:26:34.564]   - Field: ‘result’
[08:26:34.565]   - Field: ‘asynchronous’
[08:26:34.565]   - Field: ‘calls’
[08:26:34.565]   - Field: ‘globals’
[08:26:34.565]   - Field: ‘stdout’
[08:26:34.565]   - Field: ‘earlySignal’
[08:26:34.565]   - Field: ‘lazy’
[08:26:34.565]   - Field: ‘state’
[08:26:34.565] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:34.565] - Launch lazy future ...
[08:26:34.565] Packages needed by the future expression (n = 0): <none>
[08:26:34.566] Packages needed by future strategies (n = 0): <none>
[08:26:34.566] {
[08:26:34.566]     {
[08:26:34.566]         {
[08:26:34.566]             ...future.startTime <- base::Sys.time()
[08:26:34.566]             {
[08:26:34.566]                 {
[08:26:34.566]                   {
[08:26:34.566]                     base::local({
[08:26:34.566]                       has_future <- base::requireNamespace("future", 
[08:26:34.566]                         quietly = TRUE)
[08:26:34.566]                       if (has_future) {
[08:26:34.566]                         ns <- base::getNamespace("future")
[08:26:34.566]                         version <- ns[[".package"]][["version"]]
[08:26:34.566]                         if (is.null(version)) 
[08:26:34.566]                           version <- utils::packageVersion("future")
[08:26:34.566]                       }
[08:26:34.566]                       else {
[08:26:34.566]                         version <- NULL
[08:26:34.566]                       }
[08:26:34.566]                       if (!has_future || version < "1.8.0") {
[08:26:34.566]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:34.566]                           "", base::R.version$version.string), 
[08:26:34.566]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:34.566]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:34.566]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:34.566]                             "release", "version")], collapse = " "), 
[08:26:34.566]                           hostname = base::Sys.info()[["nodename"]])
[08:26:34.566]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:34.566]                           info)
[08:26:34.566]                         info <- base::paste(info, collapse = "; ")
[08:26:34.566]                         if (!has_future) {
[08:26:34.566]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:34.566]                             info)
[08:26:34.566]                         }
[08:26:34.566]                         else {
[08:26:34.566]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:34.566]                             info, version)
[08:26:34.566]                         }
[08:26:34.566]                         base::stop(msg)
[08:26:34.566]                       }
[08:26:34.566]                     })
[08:26:34.566]                   }
[08:26:34.566]                   ...future.strategy.old <- future::plan("list")
[08:26:34.566]                   options(future.plan = NULL)
[08:26:34.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:34.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:34.566]                 }
[08:26:34.566]                 ...future.workdir <- getwd()
[08:26:34.566]             }
[08:26:34.566]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:34.566]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:34.566]         }
[08:26:34.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:34.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:34.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:34.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:34.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:34.566]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:34.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:34.566]             base::names(...future.oldOptions))
[08:26:34.566]     }
[08:26:34.566]     if (FALSE) {
[08:26:34.566]     }
[08:26:34.566]     else {
[08:26:34.566]         if (FALSE) {
[08:26:34.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:34.566]                 open = "w")
[08:26:34.566]         }
[08:26:34.566]         else {
[08:26:34.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:34.566]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:34.566]         }
[08:26:34.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:34.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:34.566]             base::sink(type = "output", split = FALSE)
[08:26:34.566]             base::close(...future.stdout)
[08:26:34.566]         }, add = TRUE)
[08:26:34.566]     }
[08:26:34.566]     ...future.frame <- base::sys.nframe()
[08:26:34.566]     ...future.conditions <- base::list()
[08:26:34.566]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:34.566]     if (FALSE) {
[08:26:34.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:34.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:34.566]     }
[08:26:34.566]     ...future.result <- base::tryCatch({
[08:26:34.566]         base::withCallingHandlers({
[08:26:34.566]             ...future.value <- base::withVisible(base::local({
[08:26:34.566]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:34.566]                 if (!identical(...future.globals.maxSize.org, 
[08:26:34.566]                   ...future.globals.maxSize)) {
[08:26:34.566]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:34.566]                   on.exit(options(oopts), add = TRUE)
[08:26:34.566]                 }
[08:26:34.566]                 {
[08:26:34.566]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:34.566]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:34.566]                     USE.NAMES = FALSE)
[08:26:34.566]                   do.call(mapply, args = args)
[08:26:34.566]                 }
[08:26:34.566]             }))
[08:26:34.566]             future::FutureResult(value = ...future.value$value, 
[08:26:34.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:34.566]                   ...future.rng), globalenv = if (FALSE) 
[08:26:34.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:34.566]                     ...future.globalenv.names))
[08:26:34.566]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:34.566]         }, condition = base::local({
[08:26:34.566]             c <- base::c
[08:26:34.566]             inherits <- base::inherits
[08:26:34.566]             invokeRestart <- base::invokeRestart
[08:26:34.566]             length <- base::length
[08:26:34.566]             list <- base::list
[08:26:34.566]             seq.int <- base::seq.int
[08:26:34.566]             signalCondition <- base::signalCondition
[08:26:34.566]             sys.calls <- base::sys.calls
[08:26:34.566]             `[[` <- base::`[[`
[08:26:34.566]             `+` <- base::`+`
[08:26:34.566]             `<<-` <- base::`<<-`
[08:26:34.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:34.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:34.566]                   3L)]
[08:26:34.566]             }
[08:26:34.566]             function(cond) {
[08:26:34.566]                 is_error <- inherits(cond, "error")
[08:26:34.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:34.566]                   NULL)
[08:26:34.566]                 if (is_error) {
[08:26:34.566]                   sessionInformation <- function() {
[08:26:34.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:34.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:34.566]                       search = base::search(), system = base::Sys.info())
[08:26:34.566]                   }
[08:26:34.566]                   ...future.conditions[[length(...future.conditions) + 
[08:26:34.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:34.566]                     cond$call), session = sessionInformation(), 
[08:26:34.566]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:34.566]                   signalCondition(cond)
[08:26:34.566]                 }
[08:26:34.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:34.566]                 "immediateCondition"))) {
[08:26:34.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:34.566]                   ...future.conditions[[length(...future.conditions) + 
[08:26:34.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:34.566]                   if (TRUE && !signal) {
[08:26:34.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:34.566]                     {
[08:26:34.566]                       inherits <- base::inherits
[08:26:34.566]                       invokeRestart <- base::invokeRestart
[08:26:34.566]                       is.null <- base::is.null
[08:26:34.566]                       muffled <- FALSE
[08:26:34.566]                       if (inherits(cond, "message")) {
[08:26:34.566]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:34.566]                         if (muffled) 
[08:26:34.566]                           invokeRestart("muffleMessage")
[08:26:34.566]                       }
[08:26:34.566]                       else if (inherits(cond, "warning")) {
[08:26:34.566]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:34.566]                         if (muffled) 
[08:26:34.566]                           invokeRestart("muffleWarning")
[08:26:34.566]                       }
[08:26:34.566]                       else if (inherits(cond, "condition")) {
[08:26:34.566]                         if (!is.null(pattern)) {
[08:26:34.566]                           computeRestarts <- base::computeRestarts
[08:26:34.566]                           grepl <- base::grepl
[08:26:34.566]                           restarts <- computeRestarts(cond)
[08:26:34.566]                           for (restart in restarts) {
[08:26:34.566]                             name <- restart$name
[08:26:34.566]                             if (is.null(name)) 
[08:26:34.566]                               next
[08:26:34.566]                             if (!grepl(pattern, name)) 
[08:26:34.566]                               next
[08:26:34.566]                             invokeRestart(restart)
[08:26:34.566]                             muffled <- TRUE
[08:26:34.566]                             break
[08:26:34.566]                           }
[08:26:34.566]                         }
[08:26:34.566]                       }
[08:26:34.566]                       invisible(muffled)
[08:26:34.566]                     }
[08:26:34.566]                     muffleCondition(cond, pattern = "^muffle")
[08:26:34.566]                   }
[08:26:34.566]                 }
[08:26:34.566]                 else {
[08:26:34.566]                   if (TRUE) {
[08:26:34.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:34.566]                     {
[08:26:34.566]                       inherits <- base::inherits
[08:26:34.566]                       invokeRestart <- base::invokeRestart
[08:26:34.566]                       is.null <- base::is.null
[08:26:34.566]                       muffled <- FALSE
[08:26:34.566]                       if (inherits(cond, "message")) {
[08:26:34.566]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:34.566]                         if (muffled) 
[08:26:34.566]                           invokeRestart("muffleMessage")
[08:26:34.566]                       }
[08:26:34.566]                       else if (inherits(cond, "warning")) {
[08:26:34.566]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:34.566]                         if (muffled) 
[08:26:34.566]                           invokeRestart("muffleWarning")
[08:26:34.566]                       }
[08:26:34.566]                       else if (inherits(cond, "condition")) {
[08:26:34.566]                         if (!is.null(pattern)) {
[08:26:34.566]                           computeRestarts <- base::computeRestarts
[08:26:34.566]                           grepl <- base::grepl
[08:26:34.566]                           restarts <- computeRestarts(cond)
[08:26:34.566]                           for (restart in restarts) {
[08:26:34.566]                             name <- restart$name
[08:26:34.566]                             if (is.null(name)) 
[08:26:34.566]                               next
[08:26:34.566]                             if (!grepl(pattern, name)) 
[08:26:34.566]                               next
[08:26:34.566]                             invokeRestart(restart)
[08:26:34.566]                             muffled <- TRUE
[08:26:34.566]                             break
[08:26:34.566]                           }
[08:26:34.566]                         }
[08:26:34.566]                       }
[08:26:34.566]                       invisible(muffled)
[08:26:34.566]                     }
[08:26:34.566]                     muffleCondition(cond, pattern = "^muffle")
[08:26:34.566]                   }
[08:26:34.566]                 }
[08:26:34.566]             }
[08:26:34.566]         }))
[08:26:34.566]     }, error = function(ex) {
[08:26:34.566]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:34.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:34.566]                 ...future.rng), started = ...future.startTime, 
[08:26:34.566]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:34.566]             version = "1.8"), class = "FutureResult")
[08:26:34.566]     }, finally = {
[08:26:34.566]         if (!identical(...future.workdir, getwd())) 
[08:26:34.566]             setwd(...future.workdir)
[08:26:34.566]         {
[08:26:34.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:34.566]                 ...future.oldOptions$nwarnings <- NULL
[08:26:34.566]             }
[08:26:34.566]             base::options(...future.oldOptions)
[08:26:34.566]             if (.Platform$OS.type == "windows") {
[08:26:34.566]                 old_names <- names(...future.oldEnvVars)
[08:26:34.566]                 envs <- base::Sys.getenv()
[08:26:34.566]                 names <- names(envs)
[08:26:34.566]                 common <- intersect(names, old_names)
[08:26:34.566]                 added <- setdiff(names, old_names)
[08:26:34.566]                 removed <- setdiff(old_names, names)
[08:26:34.566]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:34.566]                   envs[common]]
[08:26:34.566]                 NAMES <- toupper(changed)
[08:26:34.566]                 args <- list()
[08:26:34.566]                 for (kk in seq_along(NAMES)) {
[08:26:34.566]                   name <- changed[[kk]]
[08:26:34.566]                   NAME <- NAMES[[kk]]
[08:26:34.566]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:34.566]                     next
[08:26:34.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:34.566]                 }
[08:26:34.566]                 NAMES <- toupper(added)
[08:26:34.566]                 for (kk in seq_along(NAMES)) {
[08:26:34.566]                   name <- added[[kk]]
[08:26:34.566]                   NAME <- NAMES[[kk]]
[08:26:34.566]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:34.566]                     next
[08:26:34.566]                   args[[name]] <- ""
[08:26:34.566]                 }
[08:26:34.566]                 NAMES <- toupper(removed)
[08:26:34.566]                 for (kk in seq_along(NAMES)) {
[08:26:34.566]                   name <- removed[[kk]]
[08:26:34.566]                   NAME <- NAMES[[kk]]
[08:26:34.566]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:34.566]                     next
[08:26:34.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:34.566]                 }
[08:26:34.566]                 if (length(args) > 0) 
[08:26:34.566]                   base::do.call(base::Sys.setenv, args = args)
[08:26:34.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:34.566]             }
[08:26:34.566]             else {
[08:26:34.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:34.566]             }
[08:26:34.566]             {
[08:26:34.566]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:34.566]                   0L) {
[08:26:34.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:34.566]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:34.566]                   base::options(opts)
[08:26:34.566]                 }
[08:26:34.566]                 {
[08:26:34.566]                   {
[08:26:34.566]                     NULL
[08:26:34.566]                     RNGkind("Mersenne-Twister")
[08:26:34.566]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:34.566]                       inherits = FALSE)
[08:26:34.566]                   }
[08:26:34.566]                   options(future.plan = NULL)
[08:26:34.566]                   if (is.na(NA_character_)) 
[08:26:34.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:34.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:34.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:34.566]                     .init = FALSE)
[08:26:34.566]                 }
[08:26:34.566]             }
[08:26:34.566]         }
[08:26:34.566]     })
[08:26:34.566]     if (TRUE) {
[08:26:34.566]         base::sink(type = "output", split = FALSE)
[08:26:34.566]         if (FALSE) {
[08:26:34.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:34.566]         }
[08:26:34.566]         else {
[08:26:34.566]             ...future.result["stdout"] <- base::list(NULL)
[08:26:34.566]         }
[08:26:34.566]         base::close(...future.stdout)
[08:26:34.566]         ...future.stdout <- NULL
[08:26:34.566]     }
[08:26:34.566]     ...future.result$conditions <- ...future.conditions
[08:26:34.566]     ...future.result$finished <- base::Sys.time()
[08:26:34.566]     ...future.result
[08:26:34.566] }
[08:26:34.568] assign_globals() ...
[08:26:34.568] List of 5
[08:26:34.568]  $ ...future.FUN            :function (x, y)  
[08:26:34.568]  $ MoreArgs                 : NULL
[08:26:34.568]  $ ...future.elements_ii    :List of 2
[08:26:34.568]   ..$ :List of 2
[08:26:34.568]   .. ..$ : int 1
[08:26:34.568]   .. ..$ : int 0
[08:26:34.568]   ..$ :List of 2
[08:26:34.568]   .. ..$ : int 0
[08:26:34.568]   .. ..$ : int 1
[08:26:34.568]  $ ...future.seeds_ii       : NULL
[08:26:34.568]  $ ...future.globals.maxSize: NULL
[08:26:34.568]  - attr(*, "where")=List of 5
[08:26:34.568]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:34.568]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:34.568]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:34.568]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:34.568]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:34.568]  - attr(*, "resolved")= logi FALSE
[08:26:34.568]  - attr(*, "total_size")= num 1242
[08:26:34.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:34.568]  - attr(*, "already-done")= logi TRUE
[08:26:34.573] - reassign environment for ‘...future.FUN’
[08:26:34.574] - copied ‘...future.FUN’ to environment
[08:26:34.574] - copied ‘MoreArgs’ to environment
[08:26:34.574] - copied ‘...future.elements_ii’ to environment
[08:26:34.574] - copied ‘...future.seeds_ii’ to environment
[08:26:34.574] - copied ‘...future.globals.maxSize’ to environment
[08:26:34.574] assign_globals() ... done
[08:26:34.574] plan(): Setting new future strategy stack:
[08:26:34.574] List of future strategies:
[08:26:34.574] 1. sequential:
[08:26:34.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:34.574]    - tweaked: FALSE
[08:26:34.574]    - call: NULL
[08:26:34.575] plan(): nbrOfWorkers() = 1
[08:26:35.077] plan(): Setting new future strategy stack:
[08:26:35.077] List of future strategies:
[08:26:35.077] 1. sequential:
[08:26:35.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:35.077]    - tweaked: FALSE
[08:26:35.077]    - call: plan(strategy)
[08:26:35.078] plan(): nbrOfWorkers() = 1
[08:26:35.078] SequentialFuture started (and completed)
[08:26:35.078] - Launch lazy future ... done
[08:26:35.078] run() for ‘SequentialFuture’ ... done
[08:26:35.078] Created future:
[08:26:35.078] SequentialFuture:
[08:26:35.078] Label: ‘future_mapply-1’
[08:26:35.078] Expression:
[08:26:35.078] {
[08:26:35.078]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:35.078]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:35.078]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:35.078]         on.exit(options(oopts), add = TRUE)
[08:26:35.078]     }
[08:26:35.078]     {
[08:26:35.078]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:35.078]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:35.078]         do.call(mapply, args = args)
[08:26:35.078]     }
[08:26:35.078] }
[08:26:35.078] Lazy evaluation: FALSE
[08:26:35.078] Asynchronous evaluation: FALSE
[08:26:35.078] Local evaluation: TRUE
[08:26:35.078] Environment: R_GlobalEnv
[08:26:35.078] Capture standard output: FALSE
[08:26:35.078] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:35.078] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:35.078] Packages: <none>
[08:26:35.078] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:35.078] Resolved: TRUE
[08:26:35.078] Value: 184 bytes of class ‘list’
[08:26:35.078] Early signaling: FALSE
[08:26:35.078] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:35.078] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:35.079] Chunk #1 of 1 ... DONE
[08:26:35.079] Launching 1 futures (chunks) ... DONE
[08:26:35.079] Resolving 1 futures (chunks) ...
[08:26:35.079] resolve() on list ...
[08:26:35.080]  recursive: 0
[08:26:35.080]  length: 1
[08:26:35.080] 
[08:26:35.080] resolved() for ‘SequentialFuture’ ...
[08:26:35.080] - state: ‘finished’
[08:26:35.080] - run: TRUE
[08:26:35.080] - result: ‘FutureResult’
[08:26:35.080] resolved() for ‘SequentialFuture’ ... done
[08:26:35.080] Future #1
[08:26:35.080] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:35.081] - nx: 1
[08:26:35.081] - relay: TRUE
[08:26:35.081] - stdout: TRUE
[08:26:35.081] - signal: TRUE
[08:26:35.081] - resignal: FALSE
[08:26:35.081] - force: TRUE
[08:26:35.081] - relayed: [n=1] FALSE
[08:26:35.081] - queued futures: [n=1] FALSE
[08:26:35.081]  - until=1
[08:26:35.081]  - relaying element #1
[08:26:35.081] - relayed: [n=1] TRUE
[08:26:35.082] - queued futures: [n=1] TRUE
[08:26:35.082] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:35.082]  length: 0 (resolved future 1)
[08:26:35.082] Relaying remaining futures
[08:26:35.082] signalConditionsASAP(NULL, pos=0) ...
[08:26:35.082] - nx: 1
[08:26:35.082] - relay: TRUE
[08:26:35.082] - stdout: TRUE
[08:26:35.082] - signal: TRUE
[08:26:35.082] - resignal: FALSE
[08:26:35.082] - force: TRUE
[08:26:35.082] - relayed: [n=1] TRUE
[08:26:35.083] - queued futures: [n=1] TRUE
 - flush all
[08:26:35.083] - relayed: [n=1] TRUE
[08:26:35.083] - queued futures: [n=1] TRUE
[08:26:35.083] signalConditionsASAP(NULL, pos=0) ... done
[08:26:35.083] resolve() on list ... DONE
[08:26:35.083]  - Number of value chunks collected: 1
[08:26:35.083] Resolving 1 futures (chunks) ... DONE
[08:26:35.083] Reducing values from 1 chunks ...
[08:26:35.083]  - Number of values collected after concatenation: 2
[08:26:35.083]  - Number of values expected: 2
[08:26:35.083] Reducing values from 1 chunks ... DONE
[08:26:35.084] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[08:26:35.086] future_mapply() ...
[08:26:35.086] Number of chunks: 1
[08:26:35.086] getGlobalsAndPackagesXApply() ...
[08:26:35.086]  - future.globals: TRUE
[08:26:35.086] getGlobalsAndPackages() ...
[08:26:35.086] Searching for globals...
[08:26:35.088] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:35.088] Searching for globals ... DONE
[08:26:35.088] Resolving globals: FALSE
[08:26:35.089] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:35.089] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:35.089] - globals: [1] ‘FUN’
[08:26:35.089] 
[08:26:35.089] getGlobalsAndPackages() ... DONE
[08:26:35.089]  - globals found/used: [n=1] ‘FUN’
[08:26:35.090]  - needed namespaces: [n=0] 
[08:26:35.090] Finding globals ... DONE
[08:26:35.090] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:35.090] List of 2
[08:26:35.090]  $ ...future.FUN:function (x, y)  
[08:26:35.090]  $ MoreArgs     : NULL
[08:26:35.090]  - attr(*, "where")=List of 2
[08:26:35.090]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:35.090]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:35.090]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:35.090]  - attr(*, "resolved")= logi FALSE
[08:26:35.090]  - attr(*, "total_size")= num NA
[08:26:35.093] Packages to be attached in all futures: [n=0] 
[08:26:35.093] getGlobalsAndPackagesXApply() ... DONE
[08:26:35.093] Number of futures (= number of chunks): 1
[08:26:35.093] Launching 1 futures (chunks) ...
[08:26:35.093] Chunk #1 of 1 ...
[08:26:35.093]  - Finding globals in '...' for chunk #1 ...
[08:26:35.093] getGlobalsAndPackages() ...
[08:26:35.093] Searching for globals...
[08:26:35.094] 
[08:26:35.094] Searching for globals ... DONE
[08:26:35.094] - globals: [0] <none>
[08:26:35.094] getGlobalsAndPackages() ... DONE
[08:26:35.094]    + additional globals found: [n=0] 
[08:26:35.094]    + additional namespaces needed: [n=0] 
[08:26:35.094]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:35.094]  - seeds: <none>
[08:26:35.094]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:35.095] getGlobalsAndPackages() ...
[08:26:35.095] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:35.095] Resolving globals: FALSE
[08:26:35.095] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[08:26:35.096] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:35.096] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:35.096] 
[08:26:35.096] getGlobalsAndPackages() ... DONE
[08:26:35.096] run() for ‘Future’ ...
[08:26:35.096] - state: ‘created’
[08:26:35.096] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:35.097] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:35.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:35.097]   - Field: ‘label’
[08:26:35.097]   - Field: ‘local’
[08:26:35.097]   - Field: ‘owner’
[08:26:35.097]   - Field: ‘envir’
[08:26:35.097]   - Field: ‘packages’
[08:26:35.097]   - Field: ‘gc’
[08:26:35.097]   - Field: ‘conditions’
[08:26:35.098]   - Field: ‘expr’
[08:26:35.098]   - Field: ‘uuid’
[08:26:35.098]   - Field: ‘seed’
[08:26:35.098]   - Field: ‘version’
[08:26:35.098]   - Field: ‘result’
[08:26:35.098]   - Field: ‘asynchronous’
[08:26:35.098]   - Field: ‘calls’
[08:26:35.098]   - Field: ‘globals’
[08:26:35.098]   - Field: ‘stdout’
[08:26:35.098]   - Field: ‘earlySignal’
[08:26:35.098]   - Field: ‘lazy’
[08:26:35.099]   - Field: ‘state’
[08:26:35.099] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:35.099] - Launch lazy future ...
[08:26:35.099] Packages needed by the future expression (n = 0): <none>
[08:26:35.099] Packages needed by future strategies (n = 0): <none>
[08:26:35.099] {
[08:26:35.099]     {
[08:26:35.099]         {
[08:26:35.099]             ...future.startTime <- base::Sys.time()
[08:26:35.099]             {
[08:26:35.099]                 {
[08:26:35.099]                   {
[08:26:35.099]                     base::local({
[08:26:35.099]                       has_future <- base::requireNamespace("future", 
[08:26:35.099]                         quietly = TRUE)
[08:26:35.099]                       if (has_future) {
[08:26:35.099]                         ns <- base::getNamespace("future")
[08:26:35.099]                         version <- ns[[".package"]][["version"]]
[08:26:35.099]                         if (is.null(version)) 
[08:26:35.099]                           version <- utils::packageVersion("future")
[08:26:35.099]                       }
[08:26:35.099]                       else {
[08:26:35.099]                         version <- NULL
[08:26:35.099]                       }
[08:26:35.099]                       if (!has_future || version < "1.8.0") {
[08:26:35.099]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:35.099]                           "", base::R.version$version.string), 
[08:26:35.099]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:35.099]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:35.099]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:35.099]                             "release", "version")], collapse = " "), 
[08:26:35.099]                           hostname = base::Sys.info()[["nodename"]])
[08:26:35.099]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:35.099]                           info)
[08:26:35.099]                         info <- base::paste(info, collapse = "; ")
[08:26:35.099]                         if (!has_future) {
[08:26:35.099]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:35.099]                             info)
[08:26:35.099]                         }
[08:26:35.099]                         else {
[08:26:35.099]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:35.099]                             info, version)
[08:26:35.099]                         }
[08:26:35.099]                         base::stop(msg)
[08:26:35.099]                       }
[08:26:35.099]                     })
[08:26:35.099]                   }
[08:26:35.099]                   ...future.strategy.old <- future::plan("list")
[08:26:35.099]                   options(future.plan = NULL)
[08:26:35.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:35.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:35.099]                 }
[08:26:35.099]                 ...future.workdir <- getwd()
[08:26:35.099]             }
[08:26:35.099]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:35.099]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:35.099]         }
[08:26:35.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:35.099]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:35.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:35.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:35.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:35.099]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:35.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:35.099]             base::names(...future.oldOptions))
[08:26:35.099]     }
[08:26:35.099]     if (FALSE) {
[08:26:35.099]     }
[08:26:35.099]     else {
[08:26:35.099]         if (TRUE) {
[08:26:35.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:35.099]                 open = "w")
[08:26:35.099]         }
[08:26:35.099]         else {
[08:26:35.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:35.099]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:35.099]         }
[08:26:35.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:35.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:35.099]             base::sink(type = "output", split = FALSE)
[08:26:35.099]             base::close(...future.stdout)
[08:26:35.099]         }, add = TRUE)
[08:26:35.099]     }
[08:26:35.099]     ...future.frame <- base::sys.nframe()
[08:26:35.099]     ...future.conditions <- base::list()
[08:26:35.099]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:35.099]     if (FALSE) {
[08:26:35.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:35.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:35.099]     }
[08:26:35.099]     ...future.result <- base::tryCatch({
[08:26:35.099]         base::withCallingHandlers({
[08:26:35.099]             ...future.value <- base::withVisible(base::local({
[08:26:35.099]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:35.099]                 if (!identical(...future.globals.maxSize.org, 
[08:26:35.099]                   ...future.globals.maxSize)) {
[08:26:35.099]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:35.099]                   on.exit(options(oopts), add = TRUE)
[08:26:35.099]                 }
[08:26:35.099]                 {
[08:26:35.099]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:35.099]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:35.099]                     USE.NAMES = FALSE)
[08:26:35.099]                   do.call(mapply, args = args)
[08:26:35.099]                 }
[08:26:35.099]             }))
[08:26:35.099]             future::FutureResult(value = ...future.value$value, 
[08:26:35.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:35.099]                   ...future.rng), globalenv = if (FALSE) 
[08:26:35.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:35.099]                     ...future.globalenv.names))
[08:26:35.099]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:35.099]         }, condition = base::local({
[08:26:35.099]             c <- base::c
[08:26:35.099]             inherits <- base::inherits
[08:26:35.099]             invokeRestart <- base::invokeRestart
[08:26:35.099]             length <- base::length
[08:26:35.099]             list <- base::list
[08:26:35.099]             seq.int <- base::seq.int
[08:26:35.099]             signalCondition <- base::signalCondition
[08:26:35.099]             sys.calls <- base::sys.calls
[08:26:35.099]             `[[` <- base::`[[`
[08:26:35.099]             `+` <- base::`+`
[08:26:35.099]             `<<-` <- base::`<<-`
[08:26:35.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:35.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:35.099]                   3L)]
[08:26:35.099]             }
[08:26:35.099]             function(cond) {
[08:26:35.099]                 is_error <- inherits(cond, "error")
[08:26:35.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:35.099]                   NULL)
[08:26:35.099]                 if (is_error) {
[08:26:35.099]                   sessionInformation <- function() {
[08:26:35.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:35.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:35.099]                       search = base::search(), system = base::Sys.info())
[08:26:35.099]                   }
[08:26:35.099]                   ...future.conditions[[length(...future.conditions) + 
[08:26:35.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:35.099]                     cond$call), session = sessionInformation(), 
[08:26:35.099]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:35.099]                   signalCondition(cond)
[08:26:35.099]                 }
[08:26:35.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:35.099]                 "immediateCondition"))) {
[08:26:35.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:35.099]                   ...future.conditions[[length(...future.conditions) + 
[08:26:35.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:35.099]                   if (TRUE && !signal) {
[08:26:35.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:35.099]                     {
[08:26:35.099]                       inherits <- base::inherits
[08:26:35.099]                       invokeRestart <- base::invokeRestart
[08:26:35.099]                       is.null <- base::is.null
[08:26:35.099]                       muffled <- FALSE
[08:26:35.099]                       if (inherits(cond, "message")) {
[08:26:35.099]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:35.099]                         if (muffled) 
[08:26:35.099]                           invokeRestart("muffleMessage")
[08:26:35.099]                       }
[08:26:35.099]                       else if (inherits(cond, "warning")) {
[08:26:35.099]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:35.099]                         if (muffled) 
[08:26:35.099]                           invokeRestart("muffleWarning")
[08:26:35.099]                       }
[08:26:35.099]                       else if (inherits(cond, "condition")) {
[08:26:35.099]                         if (!is.null(pattern)) {
[08:26:35.099]                           computeRestarts <- base::computeRestarts
[08:26:35.099]                           grepl <- base::grepl
[08:26:35.099]                           restarts <- computeRestarts(cond)
[08:26:35.099]                           for (restart in restarts) {
[08:26:35.099]                             name <- restart$name
[08:26:35.099]                             if (is.null(name)) 
[08:26:35.099]                               next
[08:26:35.099]                             if (!grepl(pattern, name)) 
[08:26:35.099]                               next
[08:26:35.099]                             invokeRestart(restart)
[08:26:35.099]                             muffled <- TRUE
[08:26:35.099]                             break
[08:26:35.099]                           }
[08:26:35.099]                         }
[08:26:35.099]                       }
[08:26:35.099]                       invisible(muffled)
[08:26:35.099]                     }
[08:26:35.099]                     muffleCondition(cond, pattern = "^muffle")
[08:26:35.099]                   }
[08:26:35.099]                 }
[08:26:35.099]                 else {
[08:26:35.099]                   if (TRUE) {
[08:26:35.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:35.099]                     {
[08:26:35.099]                       inherits <- base::inherits
[08:26:35.099]                       invokeRestart <- base::invokeRestart
[08:26:35.099]                       is.null <- base::is.null
[08:26:35.099]                       muffled <- FALSE
[08:26:35.099]                       if (inherits(cond, "message")) {
[08:26:35.099]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:35.099]                         if (muffled) 
[08:26:35.099]                           invokeRestart("muffleMessage")
[08:26:35.099]                       }
[08:26:35.099]                       else if (inherits(cond, "warning")) {
[08:26:35.099]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:35.099]                         if (muffled) 
[08:26:35.099]                           invokeRestart("muffleWarning")
[08:26:35.099]                       }
[08:26:35.099]                       else if (inherits(cond, "condition")) {
[08:26:35.099]                         if (!is.null(pattern)) {
[08:26:35.099]                           computeRestarts <- base::computeRestarts
[08:26:35.099]                           grepl <- base::grepl
[08:26:35.099]                           restarts <- computeRestarts(cond)
[08:26:35.099]                           for (restart in restarts) {
[08:26:35.099]                             name <- restart$name
[08:26:35.099]                             if (is.null(name)) 
[08:26:35.099]                               next
[08:26:35.099]                             if (!grepl(pattern, name)) 
[08:26:35.099]                               next
[08:26:35.099]                             invokeRestart(restart)
[08:26:35.099]                             muffled <- TRUE
[08:26:35.099]                             break
[08:26:35.099]                           }
[08:26:35.099]                         }
[08:26:35.099]                       }
[08:26:35.099]                       invisible(muffled)
[08:26:35.099]                     }
[08:26:35.099]                     muffleCondition(cond, pattern = "^muffle")
[08:26:35.099]                   }
[08:26:35.099]                 }
[08:26:35.099]             }
[08:26:35.099]         }))
[08:26:35.099]     }, error = function(ex) {
[08:26:35.099]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:35.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:35.099]                 ...future.rng), started = ...future.startTime, 
[08:26:35.099]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:35.099]             version = "1.8"), class = "FutureResult")
[08:26:35.099]     }, finally = {
[08:26:35.099]         if (!identical(...future.workdir, getwd())) 
[08:26:35.099]             setwd(...future.workdir)
[08:26:35.099]         {
[08:26:35.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:35.099]                 ...future.oldOptions$nwarnings <- NULL
[08:26:35.099]             }
[08:26:35.099]             base::options(...future.oldOptions)
[08:26:35.099]             if (.Platform$OS.type == "windows") {
[08:26:35.099]                 old_names <- names(...future.oldEnvVars)
[08:26:35.099]                 envs <- base::Sys.getenv()
[08:26:35.099]                 names <- names(envs)
[08:26:35.099]                 common <- intersect(names, old_names)
[08:26:35.099]                 added <- setdiff(names, old_names)
[08:26:35.099]                 removed <- setdiff(old_names, names)
[08:26:35.099]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:35.099]                   envs[common]]
[08:26:35.099]                 NAMES <- toupper(changed)
[08:26:35.099]                 args <- list()
[08:26:35.099]                 for (kk in seq_along(NAMES)) {
[08:26:35.099]                   name <- changed[[kk]]
[08:26:35.099]                   NAME <- NAMES[[kk]]
[08:26:35.099]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:35.099]                     next
[08:26:35.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:35.099]                 }
[08:26:35.099]                 NAMES <- toupper(added)
[08:26:35.099]                 for (kk in seq_along(NAMES)) {
[08:26:35.099]                   name <- added[[kk]]
[08:26:35.099]                   NAME <- NAMES[[kk]]
[08:26:35.099]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:35.099]                     next
[08:26:35.099]                   args[[name]] <- ""
[08:26:35.099]                 }
[08:26:35.099]                 NAMES <- toupper(removed)
[08:26:35.099]                 for (kk in seq_along(NAMES)) {
[08:26:35.099]                   name <- removed[[kk]]
[08:26:35.099]                   NAME <- NAMES[[kk]]
[08:26:35.099]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:35.099]                     next
[08:26:35.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:35.099]                 }
[08:26:35.099]                 if (length(args) > 0) 
[08:26:35.099]                   base::do.call(base::Sys.setenv, args = args)
[08:26:35.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:35.099]             }
[08:26:35.099]             else {
[08:26:35.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:35.099]             }
[08:26:35.099]             {
[08:26:35.099]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:35.099]                   0L) {
[08:26:35.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:35.099]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:35.099]                   base::options(opts)
[08:26:35.099]                 }
[08:26:35.099]                 {
[08:26:35.099]                   {
[08:26:35.099]                     NULL
[08:26:35.099]                     RNGkind("Mersenne-Twister")
[08:26:35.099]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:35.099]                       inherits = FALSE)
[08:26:35.099]                   }
[08:26:35.099]                   options(future.plan = NULL)
[08:26:35.099]                   if (is.na(NA_character_)) 
[08:26:35.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:35.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:35.099]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:35.099]                     .init = FALSE)
[08:26:35.099]                 }
[08:26:35.099]             }
[08:26:35.099]         }
[08:26:35.099]     })
[08:26:35.099]     if (TRUE) {
[08:26:35.099]         base::sink(type = "output", split = FALSE)
[08:26:35.099]         if (TRUE) {
[08:26:35.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:35.099]         }
[08:26:35.099]         else {
[08:26:35.099]             ...future.result["stdout"] <- base::list(NULL)
[08:26:35.099]         }
[08:26:35.099]         base::close(...future.stdout)
[08:26:35.099]         ...future.stdout <- NULL
[08:26:35.099]     }
[08:26:35.099]     ...future.result$conditions <- ...future.conditions
[08:26:35.099]     ...future.result$finished <- base::Sys.time()
[08:26:35.099]     ...future.result
[08:26:35.099] }
[08:26:35.101] assign_globals() ...
[08:26:35.101] List of 5
[08:26:35.101]  $ ...future.FUN            :function (x, y)  
[08:26:35.101]  $ MoreArgs                 : NULL
[08:26:35.101]  $ ...future.elements_ii    :List of 2
[08:26:35.101]   ..$ :List of 2
[08:26:35.101]   .. ..$ : int 1
[08:26:35.101]   .. ..$ : int 0
[08:26:35.101]   ..$ :List of 2
[08:26:35.101]   .. ..$ : int 0
[08:26:35.101]   .. ..$ : int 1
[08:26:35.101]  $ ...future.seeds_ii       : NULL
[08:26:35.101]  $ ...future.globals.maxSize: NULL
[08:26:35.101]  - attr(*, "where")=List of 5
[08:26:35.101]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:35.101]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:35.101]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:35.101]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:35.101]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:35.101]  - attr(*, "resolved")= logi FALSE
[08:26:35.101]  - attr(*, "total_size")= num 1242
[08:26:35.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:35.101]  - attr(*, "already-done")= logi TRUE
[08:26:35.107] - reassign environment for ‘...future.FUN’
[08:26:35.107] - copied ‘...future.FUN’ to environment
[08:26:35.107] - copied ‘MoreArgs’ to environment
[08:26:35.108] - copied ‘...future.elements_ii’ to environment
[08:26:35.108] - copied ‘...future.seeds_ii’ to environment
[08:26:35.108] - copied ‘...future.globals.maxSize’ to environment
[08:26:35.108] assign_globals() ... done
[08:26:35.108] plan(): Setting new future strategy stack:
[08:26:35.108] List of future strategies:
[08:26:35.108] 1. sequential:
[08:26:35.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:35.108]    - tweaked: FALSE
[08:26:35.108]    - call: NULL
[08:26:35.109] plan(): nbrOfWorkers() = 1
[08:26:35.611] plan(): Setting new future strategy stack:
[08:26:35.611] List of future strategies:
[08:26:35.611] 1. sequential:
[08:26:35.611]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:35.611]    - tweaked: FALSE
[08:26:35.611]    - call: plan(strategy)
[08:26:35.612] plan(): nbrOfWorkers() = 1
[08:26:35.612] SequentialFuture started (and completed)
[08:26:35.612] - Launch lazy future ... done
[08:26:35.612] run() for ‘SequentialFuture’ ... done
[08:26:35.612] Created future:
[08:26:35.614] SequentialFuture:
[08:26:35.614] Label: ‘future_mapply-1’
[08:26:35.614] Expression:
[08:26:35.614] {
[08:26:35.614]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:35.614]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:35.614]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:35.614]         on.exit(options(oopts), add = TRUE)
[08:26:35.614]     }
[08:26:35.614]     {
[08:26:35.614]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:35.614]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:35.614]         do.call(mapply, args = args)
[08:26:35.614]     }
[08:26:35.614] }
[08:26:35.614] Lazy evaluation: FALSE
[08:26:35.614] Asynchronous evaluation: FALSE
[08:26:35.614] Local evaluation: TRUE
[08:26:35.614] Environment: R_GlobalEnv
[08:26:35.614] Capture standard output: TRUE
[08:26:35.614] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:35.614] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:35.614] Packages: <none>
[08:26:35.614] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:35.614] Resolved: TRUE
[08:26:35.614] Value: 184 bytes of class ‘list’
[08:26:35.614] Early signaling: FALSE
[08:26:35.614] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:35.614] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:35.615] Chunk #1 of 1 ... DONE
[08:26:35.615] Launching 1 futures (chunks) ... DONE
[08:26:35.615] Resolving 1 futures (chunks) ...
[08:26:35.615] resolve() on list ...
[08:26:35.615]  recursive: 0
[08:26:35.616]  length: 1
[08:26:35.616] 
[08:26:35.616] resolved() for ‘SequentialFuture’ ...
[08:26:35.616] - state: ‘finished’
[08:26:35.616] - run: TRUE
[08:26:35.616] - result: ‘FutureResult’
[08:26:35.616] resolved() for ‘SequentialFuture’ ... done
[08:26:35.616] Future #1
[08:26:35.616] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:35.616] - nx: 1
[08:26:35.617] - relay: TRUE
[08:26:35.617] - stdout: TRUE
[08:26:35.617] - signal: TRUE
[08:26:35.617] - resignal: FALSE
[08:26:35.617] - force: TRUE
[08:26:35.617] - relayed: [n=1] FALSE
[08:26:35.617] - queued futures: [n=1] FALSE
[08:26:35.617]  - until=1
[08:26:35.617]  - relaying element #1
[08:26:35.617] - relayed: [n=1] TRUE
[08:26:35.617] - queued futures: [n=1] TRUE
[08:26:35.618] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:35.618]  length: 0 (resolved future 1)
[08:26:35.618] Relaying remaining futures
[08:26:35.618] signalConditionsASAP(NULL, pos=0) ...
[08:26:35.618] - nx: 1
[08:26:35.618] - relay: TRUE
[08:26:35.618] - stdout: TRUE
[08:26:35.618] - signal: TRUE
[08:26:35.618] - resignal: FALSE
[08:26:35.618] - force: TRUE
[08:26:35.618] - relayed: [n=1] TRUE
[08:26:35.619] - queued futures: [n=1] TRUE
 - flush all
[08:26:35.619] - relayed: [n=1] TRUE
[08:26:35.619] - queued futures: [n=1] TRUE
[08:26:35.619] signalConditionsASAP(NULL, pos=0) ... done
[08:26:35.619] resolve() on list ... DONE
[08:26:35.619]  - Number of value chunks collected: 1
[08:26:35.619] Resolving 1 futures (chunks) ... DONE
[08:26:35.619] Reducing values from 1 chunks ...
[08:26:35.619]  - Number of values collected after concatenation: 2
[08:26:35.619]  - Number of values expected: 2
[08:26:35.620] Reducing values from 1 chunks ... DONE
[08:26:35.620] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[08:26:35.620] future_mapply() ...
[08:26:35.620] Number of chunks: 1
[08:26:35.620] getGlobalsAndPackagesXApply() ...
[08:26:35.620]  - future.globals: TRUE
[08:26:35.620] getGlobalsAndPackages() ...
[08:26:35.621] Searching for globals...
[08:26:35.622] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:35.622] Searching for globals ... DONE
[08:26:35.622] Resolving globals: FALSE
[08:26:35.623] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:35.623] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:35.623] - globals: [1] ‘FUN’
[08:26:35.623] 
[08:26:35.623] getGlobalsAndPackages() ... DONE
[08:26:35.623]  - globals found/used: [n=1] ‘FUN’
[08:26:35.624]  - needed namespaces: [n=0] 
[08:26:35.624] Finding globals ... DONE
[08:26:35.624] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:35.624] List of 2
[08:26:35.624]  $ ...future.FUN:function (x, y)  
[08:26:35.624]  $ MoreArgs     : NULL
[08:26:35.624]  - attr(*, "where")=List of 2
[08:26:35.624]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:35.624]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:35.624]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:35.624]  - attr(*, "resolved")= logi FALSE
[08:26:35.624]  - attr(*, "total_size")= num NA
[08:26:35.626] Packages to be attached in all futures: [n=0] 
[08:26:35.627] getGlobalsAndPackagesXApply() ... DONE
[08:26:35.627] Number of futures (= number of chunks): 1
[08:26:35.627] Launching 1 futures (chunks) ...
[08:26:35.627] Chunk #1 of 1 ...
[08:26:35.627]  - Finding globals in '...' for chunk #1 ...
[08:26:35.627] getGlobalsAndPackages() ...
[08:26:35.627] Searching for globals...
[08:26:35.628] 
[08:26:35.628] Searching for globals ... DONE
[08:26:35.628] - globals: [0] <none>
[08:26:35.628] getGlobalsAndPackages() ... DONE
[08:26:35.628]    + additional globals found: [n=0] 
[08:26:35.628]    + additional namespaces needed: [n=0] 
[08:26:35.628]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:35.628]  - seeds: <none>
[08:26:35.628]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:35.628] getGlobalsAndPackages() ...
[08:26:35.628] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:35.629] Resolving globals: FALSE
[08:26:35.629] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[08:26:35.629] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:35.629] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:35.630] 
[08:26:35.630] getGlobalsAndPackages() ... DONE
[08:26:35.630] run() for ‘Future’ ...
[08:26:35.630] - state: ‘created’
[08:26:35.630] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:26:35.630] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:35.631] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:35.631]   - Field: ‘label’
[08:26:35.631]   - Field: ‘local’
[08:26:35.631]   - Field: ‘owner’
[08:26:35.631]   - Field: ‘envir’
[08:26:35.631]   - Field: ‘packages’
[08:26:35.631]   - Field: ‘gc’
[08:26:35.631]   - Field: ‘conditions’
[08:26:35.631]   - Field: ‘expr’
[08:26:35.631]   - Field: ‘uuid’
[08:26:35.632]   - Field: ‘seed’
[08:26:35.632]   - Field: ‘version’
[08:26:35.632]   - Field: ‘result’
[08:26:35.632]   - Field: ‘asynchronous’
[08:26:35.632]   - Field: ‘calls’
[08:26:35.632]   - Field: ‘globals’
[08:26:35.632]   - Field: ‘stdout’
[08:26:35.632]   - Field: ‘earlySignal’
[08:26:35.632]   - Field: ‘lazy’
[08:26:35.632]   - Field: ‘state’
[08:26:35.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:35.633] - Launch lazy future ...
[08:26:35.633] Packages needed by the future expression (n = 0): <none>
[08:26:35.633] Packages needed by future strategies (n = 0): <none>
[08:26:35.633] {
[08:26:35.633]     {
[08:26:35.633]         {
[08:26:35.633]             ...future.startTime <- base::Sys.time()
[08:26:35.633]             {
[08:26:35.633]                 {
[08:26:35.633]                   {
[08:26:35.633]                     base::local({
[08:26:35.633]                       has_future <- base::requireNamespace("future", 
[08:26:35.633]                         quietly = TRUE)
[08:26:35.633]                       if (has_future) {
[08:26:35.633]                         ns <- base::getNamespace("future")
[08:26:35.633]                         version <- ns[[".package"]][["version"]]
[08:26:35.633]                         if (is.null(version)) 
[08:26:35.633]                           version <- utils::packageVersion("future")
[08:26:35.633]                       }
[08:26:35.633]                       else {
[08:26:35.633]                         version <- NULL
[08:26:35.633]                       }
[08:26:35.633]                       if (!has_future || version < "1.8.0") {
[08:26:35.633]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:35.633]                           "", base::R.version$version.string), 
[08:26:35.633]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:35.633]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:35.633]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:35.633]                             "release", "version")], collapse = " "), 
[08:26:35.633]                           hostname = base::Sys.info()[["nodename"]])
[08:26:35.633]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:35.633]                           info)
[08:26:35.633]                         info <- base::paste(info, collapse = "; ")
[08:26:35.633]                         if (!has_future) {
[08:26:35.633]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:35.633]                             info)
[08:26:35.633]                         }
[08:26:35.633]                         else {
[08:26:35.633]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:35.633]                             info, version)
[08:26:35.633]                         }
[08:26:35.633]                         base::stop(msg)
[08:26:35.633]                       }
[08:26:35.633]                     })
[08:26:35.633]                   }
[08:26:35.633]                   ...future.strategy.old <- future::plan("list")
[08:26:35.633]                   options(future.plan = NULL)
[08:26:35.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:35.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:35.633]                 }
[08:26:35.633]                 ...future.workdir <- getwd()
[08:26:35.633]             }
[08:26:35.633]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:35.633]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:35.633]         }
[08:26:35.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:35.633]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:35.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:35.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:35.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:35.633]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:35.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:35.633]             base::names(...future.oldOptions))
[08:26:35.633]     }
[08:26:35.633]     if (TRUE) {
[08:26:35.633]     }
[08:26:35.633]     else {
[08:26:35.633]         if (NA) {
[08:26:35.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:35.633]                 open = "w")
[08:26:35.633]         }
[08:26:35.633]         else {
[08:26:35.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:35.633]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:35.633]         }
[08:26:35.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:35.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:35.633]             base::sink(type = "output", split = FALSE)
[08:26:35.633]             base::close(...future.stdout)
[08:26:35.633]         }, add = TRUE)
[08:26:35.633]     }
[08:26:35.633]     ...future.frame <- base::sys.nframe()
[08:26:35.633]     ...future.conditions <- base::list()
[08:26:35.633]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:35.633]     if (FALSE) {
[08:26:35.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:35.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:35.633]     }
[08:26:35.633]     ...future.result <- base::tryCatch({
[08:26:35.633]         base::withCallingHandlers({
[08:26:35.633]             ...future.value <- base::withVisible(base::local({
[08:26:35.633]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:35.633]                 if (!identical(...future.globals.maxSize.org, 
[08:26:35.633]                   ...future.globals.maxSize)) {
[08:26:35.633]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:35.633]                   on.exit(options(oopts), add = TRUE)
[08:26:35.633]                 }
[08:26:35.633]                 {
[08:26:35.633]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:35.633]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:35.633]                     USE.NAMES = FALSE)
[08:26:35.633]                   do.call(mapply, args = args)
[08:26:35.633]                 }
[08:26:35.633]             }))
[08:26:35.633]             future::FutureResult(value = ...future.value$value, 
[08:26:35.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:35.633]                   ...future.rng), globalenv = if (FALSE) 
[08:26:35.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:35.633]                     ...future.globalenv.names))
[08:26:35.633]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:35.633]         }, condition = base::local({
[08:26:35.633]             c <- base::c
[08:26:35.633]             inherits <- base::inherits
[08:26:35.633]             invokeRestart <- base::invokeRestart
[08:26:35.633]             length <- base::length
[08:26:35.633]             list <- base::list
[08:26:35.633]             seq.int <- base::seq.int
[08:26:35.633]             signalCondition <- base::signalCondition
[08:26:35.633]             sys.calls <- base::sys.calls
[08:26:35.633]             `[[` <- base::`[[`
[08:26:35.633]             `+` <- base::`+`
[08:26:35.633]             `<<-` <- base::`<<-`
[08:26:35.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:35.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:35.633]                   3L)]
[08:26:35.633]             }
[08:26:35.633]             function(cond) {
[08:26:35.633]                 is_error <- inherits(cond, "error")
[08:26:35.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:35.633]                   NULL)
[08:26:35.633]                 if (is_error) {
[08:26:35.633]                   sessionInformation <- function() {
[08:26:35.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:35.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:35.633]                       search = base::search(), system = base::Sys.info())
[08:26:35.633]                   }
[08:26:35.633]                   ...future.conditions[[length(...future.conditions) + 
[08:26:35.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:35.633]                     cond$call), session = sessionInformation(), 
[08:26:35.633]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:35.633]                   signalCondition(cond)
[08:26:35.633]                 }
[08:26:35.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:35.633]                 "immediateCondition"))) {
[08:26:35.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:35.633]                   ...future.conditions[[length(...future.conditions) + 
[08:26:35.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:35.633]                   if (TRUE && !signal) {
[08:26:35.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:35.633]                     {
[08:26:35.633]                       inherits <- base::inherits
[08:26:35.633]                       invokeRestart <- base::invokeRestart
[08:26:35.633]                       is.null <- base::is.null
[08:26:35.633]                       muffled <- FALSE
[08:26:35.633]                       if (inherits(cond, "message")) {
[08:26:35.633]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:35.633]                         if (muffled) 
[08:26:35.633]                           invokeRestart("muffleMessage")
[08:26:35.633]                       }
[08:26:35.633]                       else if (inherits(cond, "warning")) {
[08:26:35.633]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:35.633]                         if (muffled) 
[08:26:35.633]                           invokeRestart("muffleWarning")
[08:26:35.633]                       }
[08:26:35.633]                       else if (inherits(cond, "condition")) {
[08:26:35.633]                         if (!is.null(pattern)) {
[08:26:35.633]                           computeRestarts <- base::computeRestarts
[08:26:35.633]                           grepl <- base::grepl
[08:26:35.633]                           restarts <- computeRestarts(cond)
[08:26:35.633]                           for (restart in restarts) {
[08:26:35.633]                             name <- restart$name
[08:26:35.633]                             if (is.null(name)) 
[08:26:35.633]                               next
[08:26:35.633]                             if (!grepl(pattern, name)) 
[08:26:35.633]                               next
[08:26:35.633]                             invokeRestart(restart)
[08:26:35.633]                             muffled <- TRUE
[08:26:35.633]                             break
[08:26:35.633]                           }
[08:26:35.633]                         }
[08:26:35.633]                       }
[08:26:35.633]                       invisible(muffled)
[08:26:35.633]                     }
[08:26:35.633]                     muffleCondition(cond, pattern = "^muffle")
[08:26:35.633]                   }
[08:26:35.633]                 }
[08:26:35.633]                 else {
[08:26:35.633]                   if (TRUE) {
[08:26:35.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:35.633]                     {
[08:26:35.633]                       inherits <- base::inherits
[08:26:35.633]                       invokeRestart <- base::invokeRestart
[08:26:35.633]                       is.null <- base::is.null
[08:26:35.633]                       muffled <- FALSE
[08:26:35.633]                       if (inherits(cond, "message")) {
[08:26:35.633]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:35.633]                         if (muffled) 
[08:26:35.633]                           invokeRestart("muffleMessage")
[08:26:35.633]                       }
[08:26:35.633]                       else if (inherits(cond, "warning")) {
[08:26:35.633]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:35.633]                         if (muffled) 
[08:26:35.633]                           invokeRestart("muffleWarning")
[08:26:35.633]                       }
[08:26:35.633]                       else if (inherits(cond, "condition")) {
[08:26:35.633]                         if (!is.null(pattern)) {
[08:26:35.633]                           computeRestarts <- base::computeRestarts
[08:26:35.633]                           grepl <- base::grepl
[08:26:35.633]                           restarts <- computeRestarts(cond)
[08:26:35.633]                           for (restart in restarts) {
[08:26:35.633]                             name <- restart$name
[08:26:35.633]                             if (is.null(name)) 
[08:26:35.633]                               next
[08:26:35.633]                             if (!grepl(pattern, name)) 
[08:26:35.633]                               next
[08:26:35.633]                             invokeRestart(restart)
[08:26:35.633]                             muffled <- TRUE
[08:26:35.633]                             break
[08:26:35.633]                           }
[08:26:35.633]                         }
[08:26:35.633]                       }
[08:26:35.633]                       invisible(muffled)
[08:26:35.633]                     }
[08:26:35.633]                     muffleCondition(cond, pattern = "^muffle")
[08:26:35.633]                   }
[08:26:35.633]                 }
[08:26:35.633]             }
[08:26:35.633]         }))
[08:26:35.633]     }, error = function(ex) {
[08:26:35.633]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:35.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:35.633]                 ...future.rng), started = ...future.startTime, 
[08:26:35.633]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:35.633]             version = "1.8"), class = "FutureResult")
[08:26:35.633]     }, finally = {
[08:26:35.633]         if (!identical(...future.workdir, getwd())) 
[08:26:35.633]             setwd(...future.workdir)
[08:26:35.633]         {
[08:26:35.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:35.633]                 ...future.oldOptions$nwarnings <- NULL
[08:26:35.633]             }
[08:26:35.633]             base::options(...future.oldOptions)
[08:26:35.633]             if (.Platform$OS.type == "windows") {
[08:26:35.633]                 old_names <- names(...future.oldEnvVars)
[08:26:35.633]                 envs <- base::Sys.getenv()
[08:26:35.633]                 names <- names(envs)
[08:26:35.633]                 common <- intersect(names, old_names)
[08:26:35.633]                 added <- setdiff(names, old_names)
[08:26:35.633]                 removed <- setdiff(old_names, names)
[08:26:35.633]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:35.633]                   envs[common]]
[08:26:35.633]                 NAMES <- toupper(changed)
[08:26:35.633]                 args <- list()
[08:26:35.633]                 for (kk in seq_along(NAMES)) {
[08:26:35.633]                   name <- changed[[kk]]
[08:26:35.633]                   NAME <- NAMES[[kk]]
[08:26:35.633]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:35.633]                     next
[08:26:35.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:35.633]                 }
[08:26:35.633]                 NAMES <- toupper(added)
[08:26:35.633]                 for (kk in seq_along(NAMES)) {
[08:26:35.633]                   name <- added[[kk]]
[08:26:35.633]                   NAME <- NAMES[[kk]]
[08:26:35.633]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:35.633]                     next
[08:26:35.633]                   args[[name]] <- ""
[08:26:35.633]                 }
[08:26:35.633]                 NAMES <- toupper(removed)
[08:26:35.633]                 for (kk in seq_along(NAMES)) {
[08:26:35.633]                   name <- removed[[kk]]
[08:26:35.633]                   NAME <- NAMES[[kk]]
[08:26:35.633]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:35.633]                     next
[08:26:35.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:35.633]                 }
[08:26:35.633]                 if (length(args) > 0) 
[08:26:35.633]                   base::do.call(base::Sys.setenv, args = args)
[08:26:35.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:35.633]             }
[08:26:35.633]             else {
[08:26:35.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:35.633]             }
[08:26:35.633]             {
[08:26:35.633]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:35.633]                   0L) {
[08:26:35.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:35.633]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:35.633]                   base::options(opts)
[08:26:35.633]                 }
[08:26:35.633]                 {
[08:26:35.633]                   {
[08:26:35.633]                     NULL
[08:26:35.633]                     RNGkind("Mersenne-Twister")
[08:26:35.633]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:35.633]                       inherits = FALSE)
[08:26:35.633]                   }
[08:26:35.633]                   options(future.plan = NULL)
[08:26:35.633]                   if (is.na(NA_character_)) 
[08:26:35.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:35.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:35.633]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:35.633]                     .init = FALSE)
[08:26:35.633]                 }
[08:26:35.633]             }
[08:26:35.633]         }
[08:26:35.633]     })
[08:26:35.633]     if (FALSE) {
[08:26:35.633]         base::sink(type = "output", split = FALSE)
[08:26:35.633]         if (NA) {
[08:26:35.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:35.633]         }
[08:26:35.633]         else {
[08:26:35.633]             ...future.result["stdout"] <- base::list(NULL)
[08:26:35.633]         }
[08:26:35.633]         base::close(...future.stdout)
[08:26:35.633]         ...future.stdout <- NULL
[08:26:35.633]     }
[08:26:35.633]     ...future.result$conditions <- ...future.conditions
[08:26:35.633]     ...future.result$finished <- base::Sys.time()
[08:26:35.633]     ...future.result
[08:26:35.633] }
[08:26:35.635] assign_globals() ...
[08:26:35.635] List of 5
[08:26:35.635]  $ ...future.FUN            :function (x, y)  
[08:26:35.635]  $ MoreArgs                 : NULL
[08:26:35.635]  $ ...future.elements_ii    :List of 2
[08:26:35.635]   ..$ :List of 2
[08:26:35.635]   .. ..$ : int 1
[08:26:35.635]   .. ..$ : int 0
[08:26:35.635]   ..$ :List of 2
[08:26:35.635]   .. ..$ : int 0
[08:26:35.635]   .. ..$ : int 1
[08:26:35.635]  $ ...future.seeds_ii       : NULL
[08:26:35.635]  $ ...future.globals.maxSize: NULL
[08:26:35.635]  - attr(*, "where")=List of 5
[08:26:35.635]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:35.635]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:35.635]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:35.635]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:35.635]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:35.635]  - attr(*, "resolved")= logi FALSE
[08:26:35.635]  - attr(*, "total_size")= num 1242
[08:26:35.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:35.635]  - attr(*, "already-done")= logi TRUE
[08:26:35.643] - reassign environment for ‘...future.FUN’
[08:26:35.643] - copied ‘...future.FUN’ to environment
[08:26:35.643] - copied ‘MoreArgs’ to environment
[08:26:35.643] - copied ‘...future.elements_ii’ to environment
[08:26:35.643] - copied ‘...future.seeds_ii’ to environment
[08:26:35.643] - copied ‘...future.globals.maxSize’ to environment
[08:26:35.643] assign_globals() ... done
[08:26:35.644] plan(): Setting new future strategy stack:
[08:26:35.644] List of future strategies:
[08:26:35.644] 1. sequential:
[08:26:35.644]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:35.644]    - tweaked: FALSE
[08:26:35.644]    - call: NULL
[08:26:35.644] plan(): nbrOfWorkers() = 1
[08:26:36.146] plan(): Setting new future strategy stack:
[08:26:36.146] List of future strategies:
[08:26:36.146] 1. sequential:
[08:26:36.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:36.146]    - tweaked: FALSE
[08:26:36.146]    - call: plan(strategy)
[08:26:36.147] plan(): nbrOfWorkers() = 1
[08:26:36.147] SequentialFuture started (and completed)
[08:26:36.147] - Launch lazy future ... done
[08:26:36.147] run() for ‘SequentialFuture’ ... done
[08:26:36.147] Created future:
[08:26:36.147] SequentialFuture:
[08:26:36.147] Label: ‘future_mapply-1’
[08:26:36.147] Expression:
[08:26:36.147] {
[08:26:36.147]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:36.147]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:36.147]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:36.147]         on.exit(options(oopts), add = TRUE)
[08:26:36.147]     }
[08:26:36.147]     {
[08:26:36.147]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:36.147]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:36.147]         do.call(mapply, args = args)
[08:26:36.147]     }
[08:26:36.147] }
[08:26:36.147] Lazy evaluation: FALSE
[08:26:36.147] Asynchronous evaluation: FALSE
[08:26:36.147] Local evaluation: TRUE
[08:26:36.147] Environment: R_GlobalEnv
[08:26:36.147] Capture standard output: NA
[08:26:36.147] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:36.147] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:36.147] Packages: <none>
[08:26:36.147] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:36.147] Resolved: TRUE
[08:26:36.147] Value: 184 bytes of class ‘list’
[08:26:36.147] Early signaling: FALSE
[08:26:36.147] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:36.147] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:36.148] Chunk #1 of 1 ... DONE
[08:26:36.148] Launching 1 futures (chunks) ... DONE
[08:26:36.148] Resolving 1 futures (chunks) ...
[08:26:36.149] resolve() on list ...
[08:26:36.149]  recursive: 0
[08:26:36.149]  length: 1
[08:26:36.149] 
[08:26:36.149] resolved() for ‘SequentialFuture’ ...
[08:26:36.149] - state: ‘finished’
[08:26:36.149] - run: TRUE
[08:26:36.149] - result: ‘FutureResult’
[08:26:36.149] resolved() for ‘SequentialFuture’ ... done
[08:26:36.149] Future #1
[08:26:36.150] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:36.150] - nx: 1
[08:26:36.150] - relay: TRUE
[08:26:36.150] - stdout: TRUE
[08:26:36.150] - signal: TRUE
[08:26:36.150] - resignal: FALSE
[08:26:36.150] - force: TRUE
[08:26:36.150] - relayed: [n=1] FALSE
[08:26:36.150] - queued futures: [n=1] FALSE
[08:26:36.150]  - until=1
[08:26:36.150]  - relaying element #1
[08:26:36.151] - relayed: [n=1] TRUE
[08:26:36.151] - queued futures: [n=1] TRUE
[08:26:36.151] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:36.151]  length: 0 (resolved future 1)
[08:26:36.151] Relaying remaining futures
[08:26:36.151] signalConditionsASAP(NULL, pos=0) ...
[08:26:36.151] - nx: 1
[08:26:36.151] - relay: TRUE
[08:26:36.151] - stdout: TRUE
[08:26:36.151] - signal: TRUE
[08:26:36.151] - resignal: FALSE
[08:26:36.151] - force: TRUE
[08:26:36.152] - relayed: [n=1] TRUE
[08:26:36.152] - queued futures: [n=1] TRUE
 - flush all
[08:26:36.152] - relayed: [n=1] TRUE
[08:26:36.152] - queued futures: [n=1] TRUE
[08:26:36.152] signalConditionsASAP(NULL, pos=0) ... done
[08:26:36.152] resolve() on list ... DONE
[08:26:36.152]  - Number of value chunks collected: 1
[08:26:36.152] Resolving 1 futures (chunks) ... DONE
[08:26:36.152] Reducing values from 1 chunks ...
[08:26:36.152]  - Number of values collected after concatenation: 2
[08:26:36.152]  - Number of values expected: 2
[08:26:36.153] Reducing values from 1 chunks ... DONE
[08:26:36.153] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[08:26:36.153] plan(): Setting new future strategy stack:
[08:26:36.153] List of future strategies:
[08:26:36.153] 1. multicore:
[08:26:36.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:36.153]    - tweaked: FALSE
[08:26:36.153]    - call: plan(strategy)
[08:26:36.155] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[08:26:36.155] future_lapply() ...
[08:26:36.157] Number of chunks: 1
[08:26:36.157] getGlobalsAndPackagesXApply() ...
[08:26:36.157]  - future.globals: TRUE
[08:26:36.158] getGlobalsAndPackages() ...
[08:26:36.158] Searching for globals...
[08:26:36.159] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:36.159] Searching for globals ... DONE
[08:26:36.159] Resolving globals: FALSE
[08:26:36.160] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:36.160] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:36.160] - globals: [1] ‘FUN’
[08:26:36.160] 
[08:26:36.160] getGlobalsAndPackages() ... DONE
[08:26:36.160]  - globals found/used: [n=1] ‘FUN’
[08:26:36.160]  - needed namespaces: [n=0] 
[08:26:36.161] Finding globals ... DONE
[08:26:36.161]  - use_args: TRUE
[08:26:36.161]  - Getting '...' globals ...
[08:26:36.161] resolve() on list ...
[08:26:36.161]  recursive: 0
[08:26:36.161]  length: 1
[08:26:36.161]  elements: ‘...’
[08:26:36.161]  length: 0 (resolved future 1)
[08:26:36.162] resolve() on list ... DONE
[08:26:36.162]    - '...' content: [n=0] 
[08:26:36.162] List of 1
[08:26:36.162]  $ ...: list()
[08:26:36.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:36.162]  - attr(*, "where")=List of 1
[08:26:36.162]   ..$ ...:<environment: 0x55e10e284180> 
[08:26:36.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:36.162]  - attr(*, "resolved")= logi TRUE
[08:26:36.162]  - attr(*, "total_size")= num NA
[08:26:36.164]  - Getting '...' globals ... DONE
[08:26:36.164] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:36.164] List of 2
[08:26:36.164]  $ ...future.FUN:function (x)  
[08:26:36.164]  $ ...          : list()
[08:26:36.164]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:36.164]  - attr(*, "where")=List of 2
[08:26:36.164]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:36.164]   ..$ ...          :<environment: 0x55e10e284180> 
[08:26:36.164]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:36.164]  - attr(*, "resolved")= logi FALSE
[08:26:36.164]  - attr(*, "total_size")= num 5632
[08:26:36.169] Packages to be attached in all futures: [n=0] 
[08:26:36.169] getGlobalsAndPackagesXApply() ... DONE
[08:26:36.169] Number of futures (= number of chunks): 1
[08:26:36.169] Launching 1 futures (chunks) ...
[08:26:36.169] Chunk #1 of 1 ...
[08:26:36.170]  - Finding globals in 'X' for chunk #1 ...
[08:26:36.170] getGlobalsAndPackages() ...
[08:26:36.170] Searching for globals...
[08:26:36.170] 
[08:26:36.170] Searching for globals ... DONE
[08:26:36.170] - globals: [0] <none>
[08:26:36.170] getGlobalsAndPackages() ... DONE
[08:26:36.170]    + additional globals found: [n=0] 
[08:26:36.171]    + additional namespaces needed: [n=0] 
[08:26:36.171]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:36.171]  - seeds: <none>
[08:26:36.171]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:36.171] getGlobalsAndPackages() ...
[08:26:36.171] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:36.171] Resolving globals: FALSE
[08:26:36.171] Tweak future expression to call with '...' arguments ...
[08:26:36.171] {
[08:26:36.171]     do.call(function(...) {
[08:26:36.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:36.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:36.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:36.171]             on.exit(options(oopts), add = TRUE)
[08:26:36.171]         }
[08:26:36.171]         {
[08:26:36.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:36.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:36.171]                 ...future.FUN(...future.X_jj, ...)
[08:26:36.171]             })
[08:26:36.171]         }
[08:26:36.171]     }, args = future.call.arguments)
[08:26:36.171] }
[08:26:36.172] Tweak future expression to call with '...' arguments ... DONE
[08:26:36.172] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:36.172] 
[08:26:36.172] getGlobalsAndPackages() ... DONE
[08:26:36.172] run() for ‘Future’ ...
[08:26:36.172] - state: ‘created’
[08:26:36.173] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:36.174] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:36.174] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:36.174]   - Field: ‘label’
[08:26:36.175]   - Field: ‘local’
[08:26:36.175]   - Field: ‘owner’
[08:26:36.175]   - Field: ‘envir’
[08:26:36.175]   - Field: ‘packages’
[08:26:36.175]   - Field: ‘gc’
[08:26:36.175]   - Field: ‘conditions’
[08:26:36.175]   - Field: ‘expr’
[08:26:36.175]   - Field: ‘uuid’
[08:26:36.175]   - Field: ‘seed’
[08:26:36.175]   - Field: ‘version’
[08:26:36.175]   - Field: ‘result’
[08:26:36.176]   - Field: ‘asynchronous’
[08:26:36.176]   - Field: ‘calls’
[08:26:36.176]   - Field: ‘globals’
[08:26:36.176]   - Field: ‘stdout’
[08:26:36.176]   - Field: ‘earlySignal’
[08:26:36.176]   - Field: ‘lazy’
[08:26:36.176]   - Field: ‘state’
[08:26:36.176] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:36.176] - Launch lazy future ...
[08:26:36.176] Packages needed by the future expression (n = 0): <none>
[08:26:36.177] Packages needed by future strategies (n = 0): <none>
[08:26:36.177] {
[08:26:36.177]     {
[08:26:36.177]         {
[08:26:36.177]             ...future.startTime <- base::Sys.time()
[08:26:36.177]             {
[08:26:36.177]                 {
[08:26:36.177]                   {
[08:26:36.177]                     base::local({
[08:26:36.177]                       has_future <- base::requireNamespace("future", 
[08:26:36.177]                         quietly = TRUE)
[08:26:36.177]                       if (has_future) {
[08:26:36.177]                         ns <- base::getNamespace("future")
[08:26:36.177]                         version <- ns[[".package"]][["version"]]
[08:26:36.177]                         if (is.null(version)) 
[08:26:36.177]                           version <- utils::packageVersion("future")
[08:26:36.177]                       }
[08:26:36.177]                       else {
[08:26:36.177]                         version <- NULL
[08:26:36.177]                       }
[08:26:36.177]                       if (!has_future || version < "1.8.0") {
[08:26:36.177]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:36.177]                           "", base::R.version$version.string), 
[08:26:36.177]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:36.177]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:36.177]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:36.177]                             "release", "version")], collapse = " "), 
[08:26:36.177]                           hostname = base::Sys.info()[["nodename"]])
[08:26:36.177]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:36.177]                           info)
[08:26:36.177]                         info <- base::paste(info, collapse = "; ")
[08:26:36.177]                         if (!has_future) {
[08:26:36.177]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:36.177]                             info)
[08:26:36.177]                         }
[08:26:36.177]                         else {
[08:26:36.177]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:36.177]                             info, version)
[08:26:36.177]                         }
[08:26:36.177]                         base::stop(msg)
[08:26:36.177]                       }
[08:26:36.177]                     })
[08:26:36.177]                   }
[08:26:36.177]                   ...future.strategy.old <- future::plan("list")
[08:26:36.177]                   options(future.plan = NULL)
[08:26:36.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:36.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:36.177]                 }
[08:26:36.177]                 ...future.workdir <- getwd()
[08:26:36.177]             }
[08:26:36.177]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:36.177]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:36.177]         }
[08:26:36.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:36.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:36.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:36.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:36.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:36.177]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:36.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:36.177]             base::names(...future.oldOptions))
[08:26:36.177]     }
[08:26:36.177]     if (FALSE) {
[08:26:36.177]     }
[08:26:36.177]     else {
[08:26:36.177]         if (FALSE) {
[08:26:36.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:36.177]                 open = "w")
[08:26:36.177]         }
[08:26:36.177]         else {
[08:26:36.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:36.177]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:36.177]         }
[08:26:36.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:36.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:36.177]             base::sink(type = "output", split = FALSE)
[08:26:36.177]             base::close(...future.stdout)
[08:26:36.177]         }, add = TRUE)
[08:26:36.177]     }
[08:26:36.177]     ...future.frame <- base::sys.nframe()
[08:26:36.177]     ...future.conditions <- base::list()
[08:26:36.177]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:36.177]     if (FALSE) {
[08:26:36.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:36.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:36.177]     }
[08:26:36.177]     ...future.result <- base::tryCatch({
[08:26:36.177]         base::withCallingHandlers({
[08:26:36.177]             ...future.value <- base::withVisible(base::local({
[08:26:36.177]                 do.call(function(...) {
[08:26:36.177]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:36.177]                   if (!identical(...future.globals.maxSize.org, 
[08:26:36.177]                     ...future.globals.maxSize)) {
[08:26:36.177]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:36.177]                     on.exit(options(oopts), add = TRUE)
[08:26:36.177]                   }
[08:26:36.177]                   {
[08:26:36.177]                     lapply(seq_along(...future.elements_ii), 
[08:26:36.177]                       FUN = function(jj) {
[08:26:36.177]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:36.177]                         ...future.FUN(...future.X_jj, ...)
[08:26:36.177]                       })
[08:26:36.177]                   }
[08:26:36.177]                 }, args = future.call.arguments)
[08:26:36.177]             }))
[08:26:36.177]             future::FutureResult(value = ...future.value$value, 
[08:26:36.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:36.177]                   ...future.rng), globalenv = if (FALSE) 
[08:26:36.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:36.177]                     ...future.globalenv.names))
[08:26:36.177]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:36.177]         }, condition = base::local({
[08:26:36.177]             c <- base::c
[08:26:36.177]             inherits <- base::inherits
[08:26:36.177]             invokeRestart <- base::invokeRestart
[08:26:36.177]             length <- base::length
[08:26:36.177]             list <- base::list
[08:26:36.177]             seq.int <- base::seq.int
[08:26:36.177]             signalCondition <- base::signalCondition
[08:26:36.177]             sys.calls <- base::sys.calls
[08:26:36.177]             `[[` <- base::`[[`
[08:26:36.177]             `+` <- base::`+`
[08:26:36.177]             `<<-` <- base::`<<-`
[08:26:36.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:36.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:36.177]                   3L)]
[08:26:36.177]             }
[08:26:36.177]             function(cond) {
[08:26:36.177]                 is_error <- inherits(cond, "error")
[08:26:36.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:36.177]                   NULL)
[08:26:36.177]                 if (is_error) {
[08:26:36.177]                   sessionInformation <- function() {
[08:26:36.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:36.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:36.177]                       search = base::search(), system = base::Sys.info())
[08:26:36.177]                   }
[08:26:36.177]                   ...future.conditions[[length(...future.conditions) + 
[08:26:36.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:36.177]                     cond$call), session = sessionInformation(), 
[08:26:36.177]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:36.177]                   signalCondition(cond)
[08:26:36.177]                 }
[08:26:36.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:36.177]                 "immediateCondition"))) {
[08:26:36.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:36.177]                   ...future.conditions[[length(...future.conditions) + 
[08:26:36.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:36.177]                   if (TRUE && !signal) {
[08:26:36.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:36.177]                     {
[08:26:36.177]                       inherits <- base::inherits
[08:26:36.177]                       invokeRestart <- base::invokeRestart
[08:26:36.177]                       is.null <- base::is.null
[08:26:36.177]                       muffled <- FALSE
[08:26:36.177]                       if (inherits(cond, "message")) {
[08:26:36.177]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:36.177]                         if (muffled) 
[08:26:36.177]                           invokeRestart("muffleMessage")
[08:26:36.177]                       }
[08:26:36.177]                       else if (inherits(cond, "warning")) {
[08:26:36.177]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:36.177]                         if (muffled) 
[08:26:36.177]                           invokeRestart("muffleWarning")
[08:26:36.177]                       }
[08:26:36.177]                       else if (inherits(cond, "condition")) {
[08:26:36.177]                         if (!is.null(pattern)) {
[08:26:36.177]                           computeRestarts <- base::computeRestarts
[08:26:36.177]                           grepl <- base::grepl
[08:26:36.177]                           restarts <- computeRestarts(cond)
[08:26:36.177]                           for (restart in restarts) {
[08:26:36.177]                             name <- restart$name
[08:26:36.177]                             if (is.null(name)) 
[08:26:36.177]                               next
[08:26:36.177]                             if (!grepl(pattern, name)) 
[08:26:36.177]                               next
[08:26:36.177]                             invokeRestart(restart)
[08:26:36.177]                             muffled <- TRUE
[08:26:36.177]                             break
[08:26:36.177]                           }
[08:26:36.177]                         }
[08:26:36.177]                       }
[08:26:36.177]                       invisible(muffled)
[08:26:36.177]                     }
[08:26:36.177]                     muffleCondition(cond, pattern = "^muffle")
[08:26:36.177]                   }
[08:26:36.177]                 }
[08:26:36.177]                 else {
[08:26:36.177]                   if (TRUE) {
[08:26:36.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:36.177]                     {
[08:26:36.177]                       inherits <- base::inherits
[08:26:36.177]                       invokeRestart <- base::invokeRestart
[08:26:36.177]                       is.null <- base::is.null
[08:26:36.177]                       muffled <- FALSE
[08:26:36.177]                       if (inherits(cond, "message")) {
[08:26:36.177]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:36.177]                         if (muffled) 
[08:26:36.177]                           invokeRestart("muffleMessage")
[08:26:36.177]                       }
[08:26:36.177]                       else if (inherits(cond, "warning")) {
[08:26:36.177]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:36.177]                         if (muffled) 
[08:26:36.177]                           invokeRestart("muffleWarning")
[08:26:36.177]                       }
[08:26:36.177]                       else if (inherits(cond, "condition")) {
[08:26:36.177]                         if (!is.null(pattern)) {
[08:26:36.177]                           computeRestarts <- base::computeRestarts
[08:26:36.177]                           grepl <- base::grepl
[08:26:36.177]                           restarts <- computeRestarts(cond)
[08:26:36.177]                           for (restart in restarts) {
[08:26:36.177]                             name <- restart$name
[08:26:36.177]                             if (is.null(name)) 
[08:26:36.177]                               next
[08:26:36.177]                             if (!grepl(pattern, name)) 
[08:26:36.177]                               next
[08:26:36.177]                             invokeRestart(restart)
[08:26:36.177]                             muffled <- TRUE
[08:26:36.177]                             break
[08:26:36.177]                           }
[08:26:36.177]                         }
[08:26:36.177]                       }
[08:26:36.177]                       invisible(muffled)
[08:26:36.177]                     }
[08:26:36.177]                     muffleCondition(cond, pattern = "^muffle")
[08:26:36.177]                   }
[08:26:36.177]                 }
[08:26:36.177]             }
[08:26:36.177]         }))
[08:26:36.177]     }, error = function(ex) {
[08:26:36.177]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:36.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:36.177]                 ...future.rng), started = ...future.startTime, 
[08:26:36.177]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:36.177]             version = "1.8"), class = "FutureResult")
[08:26:36.177]     }, finally = {
[08:26:36.177]         if (!identical(...future.workdir, getwd())) 
[08:26:36.177]             setwd(...future.workdir)
[08:26:36.177]         {
[08:26:36.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:36.177]                 ...future.oldOptions$nwarnings <- NULL
[08:26:36.177]             }
[08:26:36.177]             base::options(...future.oldOptions)
[08:26:36.177]             if (.Platform$OS.type == "windows") {
[08:26:36.177]                 old_names <- names(...future.oldEnvVars)
[08:26:36.177]                 envs <- base::Sys.getenv()
[08:26:36.177]                 names <- names(envs)
[08:26:36.177]                 common <- intersect(names, old_names)
[08:26:36.177]                 added <- setdiff(names, old_names)
[08:26:36.177]                 removed <- setdiff(old_names, names)
[08:26:36.177]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:36.177]                   envs[common]]
[08:26:36.177]                 NAMES <- toupper(changed)
[08:26:36.177]                 args <- list()
[08:26:36.177]                 for (kk in seq_along(NAMES)) {
[08:26:36.177]                   name <- changed[[kk]]
[08:26:36.177]                   NAME <- NAMES[[kk]]
[08:26:36.177]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:36.177]                     next
[08:26:36.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:36.177]                 }
[08:26:36.177]                 NAMES <- toupper(added)
[08:26:36.177]                 for (kk in seq_along(NAMES)) {
[08:26:36.177]                   name <- added[[kk]]
[08:26:36.177]                   NAME <- NAMES[[kk]]
[08:26:36.177]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:36.177]                     next
[08:26:36.177]                   args[[name]] <- ""
[08:26:36.177]                 }
[08:26:36.177]                 NAMES <- toupper(removed)
[08:26:36.177]                 for (kk in seq_along(NAMES)) {
[08:26:36.177]                   name <- removed[[kk]]
[08:26:36.177]                   NAME <- NAMES[[kk]]
[08:26:36.177]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:36.177]                     next
[08:26:36.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:36.177]                 }
[08:26:36.177]                 if (length(args) > 0) 
[08:26:36.177]                   base::do.call(base::Sys.setenv, args = args)
[08:26:36.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:36.177]             }
[08:26:36.177]             else {
[08:26:36.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:36.177]             }
[08:26:36.177]             {
[08:26:36.177]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:36.177]                   0L) {
[08:26:36.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:36.177]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:36.177]                   base::options(opts)
[08:26:36.177]                 }
[08:26:36.177]                 {
[08:26:36.177]                   {
[08:26:36.177]                     NULL
[08:26:36.177]                     RNGkind("Mersenne-Twister")
[08:26:36.177]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:36.177]                       inherits = FALSE)
[08:26:36.177]                   }
[08:26:36.177]                   options(future.plan = NULL)
[08:26:36.177]                   if (is.na(NA_character_)) 
[08:26:36.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:36.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:36.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:36.177]                     .init = FALSE)
[08:26:36.177]                 }
[08:26:36.177]             }
[08:26:36.177]         }
[08:26:36.177]     })
[08:26:36.177]     if (TRUE) {
[08:26:36.177]         base::sink(type = "output", split = FALSE)
[08:26:36.177]         if (FALSE) {
[08:26:36.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:36.177]         }
[08:26:36.177]         else {
[08:26:36.177]             ...future.result["stdout"] <- base::list(NULL)
[08:26:36.177]         }
[08:26:36.177]         base::close(...future.stdout)
[08:26:36.177]         ...future.stdout <- NULL
[08:26:36.177]     }
[08:26:36.177]     ...future.result$conditions <- ...future.conditions
[08:26:36.177]     ...future.result$finished <- base::Sys.time()
[08:26:36.177]     ...future.result
[08:26:36.177] }
[08:26:36.179] assign_globals() ...
[08:26:36.179] List of 5
[08:26:36.179]  $ ...future.FUN            :function (x)  
[08:26:36.179]  $ future.call.arguments    : list()
[08:26:36.179]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:36.179]  $ ...future.elements_ii    :List of 2
[08:26:36.179]   ..$ : int 1
[08:26:36.179]   ..$ : int 0
[08:26:36.179]  $ ...future.seeds_ii       : NULL
[08:26:36.179]  $ ...future.globals.maxSize: NULL
[08:26:36.179]  - attr(*, "where")=List of 5
[08:26:36.179]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:36.179]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:36.179]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:36.179]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:36.179]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:36.179]  - attr(*, "resolved")= logi FALSE
[08:26:36.179]  - attr(*, "total_size")= num 5632
[08:26:36.179]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:36.179]  - attr(*, "already-done")= logi TRUE
[08:26:36.184] - reassign environment for ‘...future.FUN’
[08:26:36.184] - copied ‘...future.FUN’ to environment
[08:26:36.184] - copied ‘future.call.arguments’ to environment
[08:26:36.184] - copied ‘...future.elements_ii’ to environment
[08:26:36.184] - copied ‘...future.seeds_ii’ to environment
[08:26:36.184] - copied ‘...future.globals.maxSize’ to environment
[08:26:36.184] assign_globals() ... done
[08:26:36.185] plan(): Setting new future strategy stack:
[08:26:36.185] List of future strategies:
[08:26:36.185] 1. sequential:
[08:26:36.185]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:36.185]    - tweaked: FALSE
[08:26:36.185]    - call: NULL
[08:26:36.185] plan(): nbrOfWorkers() = 1
[08:26:36.687] plan(): Setting new future strategy stack:
[08:26:36.687] List of future strategies:
[08:26:36.687] 1. multicore:
[08:26:36.687]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:36.687]    - tweaked: FALSE
[08:26:36.687]    - call: plan(strategy)
[08:26:36.689] plan(): nbrOfWorkers() = 1
[08:26:36.689] SequentialFuture started (and completed)
[08:26:36.690] - Launch lazy future ... done
[08:26:36.690] run() for ‘SequentialFuture’ ... done
[08:26:36.690] Created future:
[08:26:36.690] SequentialFuture:
[08:26:36.690] Label: ‘future_lapply-1’
[08:26:36.690] Expression:
[08:26:36.690] {
[08:26:36.690]     do.call(function(...) {
[08:26:36.690]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:36.690]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:36.690]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:36.690]             on.exit(options(oopts), add = TRUE)
[08:26:36.690]         }
[08:26:36.690]         {
[08:26:36.690]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:36.690]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:36.690]                 ...future.FUN(...future.X_jj, ...)
[08:26:36.690]             })
[08:26:36.690]         }
[08:26:36.690]     }, args = future.call.arguments)
[08:26:36.690] }
[08:26:36.690] Lazy evaluation: FALSE
[08:26:36.690] Asynchronous evaluation: FALSE
[08:26:36.690] Local evaluation: TRUE
[08:26:36.690] Environment: R_GlobalEnv
[08:26:36.690] Capture standard output: FALSE
[08:26:36.690] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:36.690] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:36.690] Packages: <none>
[08:26:36.690] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:36.690] Resolved: TRUE
[08:26:36.690] Value: 55 bytes of class ‘list’
[08:26:36.690] Early signaling: FALSE
[08:26:36.690] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:36.690] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:36.691] Chunk #1 of 1 ... DONE
[08:26:36.691] Launching 1 futures (chunks) ... DONE
[08:26:36.691] Resolving 1 futures (chunks) ...
[08:26:36.691] resolve() on list ...
[08:26:36.691]  recursive: 0
[08:26:36.691]  length: 1
[08:26:36.692] 
[08:26:36.692] resolved() for ‘SequentialFuture’ ...
[08:26:36.692] - state: ‘finished’
[08:26:36.692] - run: TRUE
[08:26:36.692] - result: ‘FutureResult’
[08:26:36.692] resolved() for ‘SequentialFuture’ ... done
[08:26:36.692] Future #1
[08:26:36.692] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:36.692] - nx: 1
[08:26:36.692] - relay: TRUE
[08:26:36.693] - stdout: TRUE
[08:26:36.693] - signal: TRUE
[08:26:36.693] - resignal: FALSE
[08:26:36.693] - force: TRUE
[08:26:36.693] - relayed: [n=1] FALSE
[08:26:36.693] - queued futures: [n=1] FALSE
[08:26:36.693]  - until=1
[08:26:36.693]  - relaying element #1
[08:26:36.693] - relayed: [n=1] TRUE
[08:26:36.693] - queued futures: [n=1] TRUE
[08:26:36.693] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:36.694]  length: 0 (resolved future 1)
[08:26:36.694] Relaying remaining futures
[08:26:36.694] signalConditionsASAP(NULL, pos=0) ...
[08:26:36.694] - nx: 1
[08:26:36.694] - relay: TRUE
[08:26:36.694] - stdout: TRUE
[08:26:36.694] - signal: TRUE
[08:26:36.694] - resignal: FALSE
[08:26:36.694] - force: TRUE
[08:26:36.694] - relayed: [n=1] TRUE
[08:26:36.696] - queued futures: [n=1] TRUE
 - flush all
[08:26:36.697] - relayed: [n=1] TRUE
[08:26:36.697] - queued futures: [n=1] TRUE
[08:26:36.697] signalConditionsASAP(NULL, pos=0) ... done
[08:26:36.697] resolve() on list ... DONE
[08:26:36.697]  - Number of value chunks collected: 1
[08:26:36.697] Resolving 1 futures (chunks) ... DONE
[08:26:36.697] Reducing values from 1 chunks ...
[08:26:36.697]  - Number of values collected after concatenation: 2
[08:26:36.697]  - Number of values expected: 2
[08:26:36.697] Reducing values from 1 chunks ... DONE
[08:26:36.698] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[08:26:36.698] future_lapply() ...
[08:26:36.700] Number of chunks: 1
[08:26:36.700] getGlobalsAndPackagesXApply() ...
[08:26:36.700]  - future.globals: TRUE
[08:26:36.700] getGlobalsAndPackages() ...
[08:26:36.701] Searching for globals...
[08:26:36.702] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:36.702] Searching for globals ... DONE
[08:26:36.702] Resolving globals: FALSE
[08:26:36.703] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:36.703] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:36.703] - globals: [1] ‘FUN’
[08:26:36.703] 
[08:26:36.703] getGlobalsAndPackages() ... DONE
[08:26:36.704]  - globals found/used: [n=1] ‘FUN’
[08:26:36.704]  - needed namespaces: [n=0] 
[08:26:36.704] Finding globals ... DONE
[08:26:36.704]  - use_args: TRUE
[08:26:36.704]  - Getting '...' globals ...
[08:26:36.704] resolve() on list ...
[08:26:36.704]  recursive: 0
[08:26:36.704]  length: 1
[08:26:36.704]  elements: ‘...’
[08:26:36.705]  length: 0 (resolved future 1)
[08:26:36.705] resolve() on list ... DONE
[08:26:36.705]    - '...' content: [n=0] 
[08:26:36.705] List of 1
[08:26:36.705]  $ ...: list()
[08:26:36.705]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:36.705]  - attr(*, "where")=List of 1
[08:26:36.705]   ..$ ...:<environment: 0x55e10db86ee0> 
[08:26:36.705]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:36.705]  - attr(*, "resolved")= logi TRUE
[08:26:36.705]  - attr(*, "total_size")= num NA
[08:26:36.707]  - Getting '...' globals ... DONE
[08:26:36.708] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:36.708] List of 2
[08:26:36.708]  $ ...future.FUN:function (x)  
[08:26:36.708]  $ ...          : list()
[08:26:36.708]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:36.708]  - attr(*, "where")=List of 2
[08:26:36.708]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:36.708]   ..$ ...          :<environment: 0x55e10db86ee0> 
[08:26:36.708]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:36.708]  - attr(*, "resolved")= logi FALSE
[08:26:36.708]  - attr(*, "total_size")= num 5632
[08:26:36.711] Packages to be attached in all futures: [n=0] 
[08:26:36.711] getGlobalsAndPackagesXApply() ... DONE
[08:26:36.711] Number of futures (= number of chunks): 1
[08:26:36.711] Launching 1 futures (chunks) ...
[08:26:36.711] Chunk #1 of 1 ...
[08:26:36.711]  - Finding globals in 'X' for chunk #1 ...
[08:26:36.712] getGlobalsAndPackages() ...
[08:26:36.712] Searching for globals...
[08:26:36.712] 
[08:26:36.712] Searching for globals ... DONE
[08:26:36.712] - globals: [0] <none>
[08:26:36.712] getGlobalsAndPackages() ... DONE
[08:26:36.712]    + additional globals found: [n=0] 
[08:26:36.712]    + additional namespaces needed: [n=0] 
[08:26:36.712]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:36.713]  - seeds: <none>
[08:26:36.713]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:36.713] getGlobalsAndPackages() ...
[08:26:36.713] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:36.713] Resolving globals: FALSE
[08:26:36.713] Tweak future expression to call with '...' arguments ...
[08:26:36.713] {
[08:26:36.713]     do.call(function(...) {
[08:26:36.713]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:36.713]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:36.713]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:36.713]             on.exit(options(oopts), add = TRUE)
[08:26:36.713]         }
[08:26:36.713]         {
[08:26:36.713]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:36.713]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:36.713]                 ...future.FUN(...future.X_jj, ...)
[08:26:36.713]             })
[08:26:36.713]         }
[08:26:36.713]     }, args = future.call.arguments)
[08:26:36.713] }
[08:26:36.713] Tweak future expression to call with '...' arguments ... DONE
[08:26:36.714] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:36.714] 
[08:26:36.714] getGlobalsAndPackages() ... DONE
[08:26:36.714] run() for ‘Future’ ...
[08:26:36.714] - state: ‘created’
[08:26:36.715] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:36.716] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:36.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:36.717]   - Field: ‘label’
[08:26:36.717]   - Field: ‘local’
[08:26:36.717]   - Field: ‘owner’
[08:26:36.717]   - Field: ‘envir’
[08:26:36.717]   - Field: ‘packages’
[08:26:36.717]   - Field: ‘gc’
[08:26:36.717]   - Field: ‘conditions’
[08:26:36.717]   - Field: ‘expr’
[08:26:36.717]   - Field: ‘uuid’
[08:26:36.718]   - Field: ‘seed’
[08:26:36.718]   - Field: ‘version’
[08:26:36.718]   - Field: ‘result’
[08:26:36.718]   - Field: ‘asynchronous’
[08:26:36.718]   - Field: ‘calls’
[08:26:36.718]   - Field: ‘globals’
[08:26:36.718]   - Field: ‘stdout’
[08:26:36.718]   - Field: ‘earlySignal’
[08:26:36.718]   - Field: ‘lazy’
[08:26:36.718]   - Field: ‘state’
[08:26:36.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:36.719] - Launch lazy future ...
[08:26:36.719] Packages needed by the future expression (n = 0): <none>
[08:26:36.719] Packages needed by future strategies (n = 0): <none>
[08:26:36.719] {
[08:26:36.719]     {
[08:26:36.719]         {
[08:26:36.719]             ...future.startTime <- base::Sys.time()
[08:26:36.719]             {
[08:26:36.719]                 {
[08:26:36.719]                   {
[08:26:36.719]                     base::local({
[08:26:36.719]                       has_future <- base::requireNamespace("future", 
[08:26:36.719]                         quietly = TRUE)
[08:26:36.719]                       if (has_future) {
[08:26:36.719]                         ns <- base::getNamespace("future")
[08:26:36.719]                         version <- ns[[".package"]][["version"]]
[08:26:36.719]                         if (is.null(version)) 
[08:26:36.719]                           version <- utils::packageVersion("future")
[08:26:36.719]                       }
[08:26:36.719]                       else {
[08:26:36.719]                         version <- NULL
[08:26:36.719]                       }
[08:26:36.719]                       if (!has_future || version < "1.8.0") {
[08:26:36.719]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:36.719]                           "", base::R.version$version.string), 
[08:26:36.719]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:36.719]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:36.719]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:36.719]                             "release", "version")], collapse = " "), 
[08:26:36.719]                           hostname = base::Sys.info()[["nodename"]])
[08:26:36.719]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:36.719]                           info)
[08:26:36.719]                         info <- base::paste(info, collapse = "; ")
[08:26:36.719]                         if (!has_future) {
[08:26:36.719]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:36.719]                             info)
[08:26:36.719]                         }
[08:26:36.719]                         else {
[08:26:36.719]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:36.719]                             info, version)
[08:26:36.719]                         }
[08:26:36.719]                         base::stop(msg)
[08:26:36.719]                       }
[08:26:36.719]                     })
[08:26:36.719]                   }
[08:26:36.719]                   ...future.strategy.old <- future::plan("list")
[08:26:36.719]                   options(future.plan = NULL)
[08:26:36.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:36.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:36.719]                 }
[08:26:36.719]                 ...future.workdir <- getwd()
[08:26:36.719]             }
[08:26:36.719]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:36.719]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:36.719]         }
[08:26:36.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:36.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:36.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:36.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:36.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:36.719]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:36.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:36.719]             base::names(...future.oldOptions))
[08:26:36.719]     }
[08:26:36.719]     if (FALSE) {
[08:26:36.719]     }
[08:26:36.719]     else {
[08:26:36.719]         if (TRUE) {
[08:26:36.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:36.719]                 open = "w")
[08:26:36.719]         }
[08:26:36.719]         else {
[08:26:36.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:36.719]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:36.719]         }
[08:26:36.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:36.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:36.719]             base::sink(type = "output", split = FALSE)
[08:26:36.719]             base::close(...future.stdout)
[08:26:36.719]         }, add = TRUE)
[08:26:36.719]     }
[08:26:36.719]     ...future.frame <- base::sys.nframe()
[08:26:36.719]     ...future.conditions <- base::list()
[08:26:36.719]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:36.719]     if (FALSE) {
[08:26:36.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:36.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:36.719]     }
[08:26:36.719]     ...future.result <- base::tryCatch({
[08:26:36.719]         base::withCallingHandlers({
[08:26:36.719]             ...future.value <- base::withVisible(base::local({
[08:26:36.719]                 do.call(function(...) {
[08:26:36.719]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:36.719]                   if (!identical(...future.globals.maxSize.org, 
[08:26:36.719]                     ...future.globals.maxSize)) {
[08:26:36.719]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:36.719]                     on.exit(options(oopts), add = TRUE)
[08:26:36.719]                   }
[08:26:36.719]                   {
[08:26:36.719]                     lapply(seq_along(...future.elements_ii), 
[08:26:36.719]                       FUN = function(jj) {
[08:26:36.719]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:36.719]                         ...future.FUN(...future.X_jj, ...)
[08:26:36.719]                       })
[08:26:36.719]                   }
[08:26:36.719]                 }, args = future.call.arguments)
[08:26:36.719]             }))
[08:26:36.719]             future::FutureResult(value = ...future.value$value, 
[08:26:36.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:36.719]                   ...future.rng), globalenv = if (FALSE) 
[08:26:36.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:36.719]                     ...future.globalenv.names))
[08:26:36.719]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:36.719]         }, condition = base::local({
[08:26:36.719]             c <- base::c
[08:26:36.719]             inherits <- base::inherits
[08:26:36.719]             invokeRestart <- base::invokeRestart
[08:26:36.719]             length <- base::length
[08:26:36.719]             list <- base::list
[08:26:36.719]             seq.int <- base::seq.int
[08:26:36.719]             signalCondition <- base::signalCondition
[08:26:36.719]             sys.calls <- base::sys.calls
[08:26:36.719]             `[[` <- base::`[[`
[08:26:36.719]             `+` <- base::`+`
[08:26:36.719]             `<<-` <- base::`<<-`
[08:26:36.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:36.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:36.719]                   3L)]
[08:26:36.719]             }
[08:26:36.719]             function(cond) {
[08:26:36.719]                 is_error <- inherits(cond, "error")
[08:26:36.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:36.719]                   NULL)
[08:26:36.719]                 if (is_error) {
[08:26:36.719]                   sessionInformation <- function() {
[08:26:36.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:36.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:36.719]                       search = base::search(), system = base::Sys.info())
[08:26:36.719]                   }
[08:26:36.719]                   ...future.conditions[[length(...future.conditions) + 
[08:26:36.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:36.719]                     cond$call), session = sessionInformation(), 
[08:26:36.719]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:36.719]                   signalCondition(cond)
[08:26:36.719]                 }
[08:26:36.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:36.719]                 "immediateCondition"))) {
[08:26:36.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:36.719]                   ...future.conditions[[length(...future.conditions) + 
[08:26:36.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:36.719]                   if (TRUE && !signal) {
[08:26:36.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:36.719]                     {
[08:26:36.719]                       inherits <- base::inherits
[08:26:36.719]                       invokeRestart <- base::invokeRestart
[08:26:36.719]                       is.null <- base::is.null
[08:26:36.719]                       muffled <- FALSE
[08:26:36.719]                       if (inherits(cond, "message")) {
[08:26:36.719]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:36.719]                         if (muffled) 
[08:26:36.719]                           invokeRestart("muffleMessage")
[08:26:36.719]                       }
[08:26:36.719]                       else if (inherits(cond, "warning")) {
[08:26:36.719]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:36.719]                         if (muffled) 
[08:26:36.719]                           invokeRestart("muffleWarning")
[08:26:36.719]                       }
[08:26:36.719]                       else if (inherits(cond, "condition")) {
[08:26:36.719]                         if (!is.null(pattern)) {
[08:26:36.719]                           computeRestarts <- base::computeRestarts
[08:26:36.719]                           grepl <- base::grepl
[08:26:36.719]                           restarts <- computeRestarts(cond)
[08:26:36.719]                           for (restart in restarts) {
[08:26:36.719]                             name <- restart$name
[08:26:36.719]                             if (is.null(name)) 
[08:26:36.719]                               next
[08:26:36.719]                             if (!grepl(pattern, name)) 
[08:26:36.719]                               next
[08:26:36.719]                             invokeRestart(restart)
[08:26:36.719]                             muffled <- TRUE
[08:26:36.719]                             break
[08:26:36.719]                           }
[08:26:36.719]                         }
[08:26:36.719]                       }
[08:26:36.719]                       invisible(muffled)
[08:26:36.719]                     }
[08:26:36.719]                     muffleCondition(cond, pattern = "^muffle")
[08:26:36.719]                   }
[08:26:36.719]                 }
[08:26:36.719]                 else {
[08:26:36.719]                   if (TRUE) {
[08:26:36.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:36.719]                     {
[08:26:36.719]                       inherits <- base::inherits
[08:26:36.719]                       invokeRestart <- base::invokeRestart
[08:26:36.719]                       is.null <- base::is.null
[08:26:36.719]                       muffled <- FALSE
[08:26:36.719]                       if (inherits(cond, "message")) {
[08:26:36.719]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:36.719]                         if (muffled) 
[08:26:36.719]                           invokeRestart("muffleMessage")
[08:26:36.719]                       }
[08:26:36.719]                       else if (inherits(cond, "warning")) {
[08:26:36.719]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:36.719]                         if (muffled) 
[08:26:36.719]                           invokeRestart("muffleWarning")
[08:26:36.719]                       }
[08:26:36.719]                       else if (inherits(cond, "condition")) {
[08:26:36.719]                         if (!is.null(pattern)) {
[08:26:36.719]                           computeRestarts <- base::computeRestarts
[08:26:36.719]                           grepl <- base::grepl
[08:26:36.719]                           restarts <- computeRestarts(cond)
[08:26:36.719]                           for (restart in restarts) {
[08:26:36.719]                             name <- restart$name
[08:26:36.719]                             if (is.null(name)) 
[08:26:36.719]                               next
[08:26:36.719]                             if (!grepl(pattern, name)) 
[08:26:36.719]                               next
[08:26:36.719]                             invokeRestart(restart)
[08:26:36.719]                             muffled <- TRUE
[08:26:36.719]                             break
[08:26:36.719]                           }
[08:26:36.719]                         }
[08:26:36.719]                       }
[08:26:36.719]                       invisible(muffled)
[08:26:36.719]                     }
[08:26:36.719]                     muffleCondition(cond, pattern = "^muffle")
[08:26:36.719]                   }
[08:26:36.719]                 }
[08:26:36.719]             }
[08:26:36.719]         }))
[08:26:36.719]     }, error = function(ex) {
[08:26:36.719]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:36.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:36.719]                 ...future.rng), started = ...future.startTime, 
[08:26:36.719]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:36.719]             version = "1.8"), class = "FutureResult")
[08:26:36.719]     }, finally = {
[08:26:36.719]         if (!identical(...future.workdir, getwd())) 
[08:26:36.719]             setwd(...future.workdir)
[08:26:36.719]         {
[08:26:36.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:36.719]                 ...future.oldOptions$nwarnings <- NULL
[08:26:36.719]             }
[08:26:36.719]             base::options(...future.oldOptions)
[08:26:36.719]             if (.Platform$OS.type == "windows") {
[08:26:36.719]                 old_names <- names(...future.oldEnvVars)
[08:26:36.719]                 envs <- base::Sys.getenv()
[08:26:36.719]                 names <- names(envs)
[08:26:36.719]                 common <- intersect(names, old_names)
[08:26:36.719]                 added <- setdiff(names, old_names)
[08:26:36.719]                 removed <- setdiff(old_names, names)
[08:26:36.719]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:36.719]                   envs[common]]
[08:26:36.719]                 NAMES <- toupper(changed)
[08:26:36.719]                 args <- list()
[08:26:36.719]                 for (kk in seq_along(NAMES)) {
[08:26:36.719]                   name <- changed[[kk]]
[08:26:36.719]                   NAME <- NAMES[[kk]]
[08:26:36.719]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:36.719]                     next
[08:26:36.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:36.719]                 }
[08:26:36.719]                 NAMES <- toupper(added)
[08:26:36.719]                 for (kk in seq_along(NAMES)) {
[08:26:36.719]                   name <- added[[kk]]
[08:26:36.719]                   NAME <- NAMES[[kk]]
[08:26:36.719]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:36.719]                     next
[08:26:36.719]                   args[[name]] <- ""
[08:26:36.719]                 }
[08:26:36.719]                 NAMES <- toupper(removed)
[08:26:36.719]                 for (kk in seq_along(NAMES)) {
[08:26:36.719]                   name <- removed[[kk]]
[08:26:36.719]                   NAME <- NAMES[[kk]]
[08:26:36.719]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:36.719]                     next
[08:26:36.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:36.719]                 }
[08:26:36.719]                 if (length(args) > 0) 
[08:26:36.719]                   base::do.call(base::Sys.setenv, args = args)
[08:26:36.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:36.719]             }
[08:26:36.719]             else {
[08:26:36.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:36.719]             }
[08:26:36.719]             {
[08:26:36.719]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:36.719]                   0L) {
[08:26:36.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:36.719]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:36.719]                   base::options(opts)
[08:26:36.719]                 }
[08:26:36.719]                 {
[08:26:36.719]                   {
[08:26:36.719]                     NULL
[08:26:36.719]                     RNGkind("Mersenne-Twister")
[08:26:36.719]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:36.719]                       inherits = FALSE)
[08:26:36.719]                   }
[08:26:36.719]                   options(future.plan = NULL)
[08:26:36.719]                   if (is.na(NA_character_)) 
[08:26:36.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:36.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:36.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:36.719]                     .init = FALSE)
[08:26:36.719]                 }
[08:26:36.719]             }
[08:26:36.719]         }
[08:26:36.719]     })
[08:26:36.719]     if (TRUE) {
[08:26:36.719]         base::sink(type = "output", split = FALSE)
[08:26:36.719]         if (TRUE) {
[08:26:36.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:36.719]         }
[08:26:36.719]         else {
[08:26:36.719]             ...future.result["stdout"] <- base::list(NULL)
[08:26:36.719]         }
[08:26:36.719]         base::close(...future.stdout)
[08:26:36.719]         ...future.stdout <- NULL
[08:26:36.719]     }
[08:26:36.719]     ...future.result$conditions <- ...future.conditions
[08:26:36.719]     ...future.result$finished <- base::Sys.time()
[08:26:36.719]     ...future.result
[08:26:36.719] }
[08:26:36.721] assign_globals() ...
[08:26:36.722] List of 5
[08:26:36.722]  $ ...future.FUN            :function (x)  
[08:26:36.722]  $ future.call.arguments    : list()
[08:26:36.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:36.722]  $ ...future.elements_ii    :List of 2
[08:26:36.722]   ..$ : int 1
[08:26:36.722]   ..$ : int 0
[08:26:36.722]  $ ...future.seeds_ii       : NULL
[08:26:36.722]  $ ...future.globals.maxSize: NULL
[08:26:36.722]  - attr(*, "where")=List of 5
[08:26:36.722]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:36.722]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:36.722]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:36.722]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:36.722]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:36.722]  - attr(*, "resolved")= logi FALSE
[08:26:36.722]  - attr(*, "total_size")= num 5632
[08:26:36.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:36.722]  - attr(*, "already-done")= logi TRUE
[08:26:36.729] - reassign environment for ‘...future.FUN’
[08:26:36.730] - copied ‘...future.FUN’ to environment
[08:26:36.730] - copied ‘future.call.arguments’ to environment
[08:26:36.730] - copied ‘...future.elements_ii’ to environment
[08:26:36.730] - copied ‘...future.seeds_ii’ to environment
[08:26:36.730] - copied ‘...future.globals.maxSize’ to environment
[08:26:36.730] assign_globals() ... done
[08:26:36.730] plan(): Setting new future strategy stack:
[08:26:36.731] List of future strategies:
[08:26:36.731] 1. sequential:
[08:26:36.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:36.731]    - tweaked: FALSE
[08:26:36.731]    - call: NULL
[08:26:36.731] plan(): nbrOfWorkers() = 1
[08:26:37.233] plan(): Setting new future strategy stack:
[08:26:37.233] List of future strategies:
[08:26:37.233] 1. multicore:
[08:26:37.233]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:37.233]    - tweaked: FALSE
[08:26:37.233]    - call: plan(strategy)
[08:26:37.235] plan(): nbrOfWorkers() = 1
[08:26:37.235] SequentialFuture started (and completed)
[08:26:37.235] - Launch lazy future ... done
[08:26:37.236] run() for ‘SequentialFuture’ ... done
[08:26:37.236] Created future:
[08:26:37.236] SequentialFuture:
[08:26:37.236] Label: ‘future_lapply-1’
[08:26:37.236] Expression:
[08:26:37.236] {
[08:26:37.236]     do.call(function(...) {
[08:26:37.236]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:37.236]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:37.236]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:37.236]             on.exit(options(oopts), add = TRUE)
[08:26:37.236]         }
[08:26:37.236]         {
[08:26:37.236]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:37.236]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:37.236]                 ...future.FUN(...future.X_jj, ...)
[08:26:37.236]             })
[08:26:37.236]         }
[08:26:37.236]     }, args = future.call.arguments)
[08:26:37.236] }
[08:26:37.236] Lazy evaluation: FALSE
[08:26:37.236] Asynchronous evaluation: FALSE
[08:26:37.236] Local evaluation: TRUE
[08:26:37.236] Environment: R_GlobalEnv
[08:26:37.236] Capture standard output: TRUE
[08:26:37.236] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:37.236] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:37.236] Packages: <none>
[08:26:37.236] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:37.236] Resolved: TRUE
[08:26:37.236] Value: 55 bytes of class ‘list’
[08:26:37.236] Early signaling: FALSE
[08:26:37.236] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:37.236] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:37.237] Chunk #1 of 1 ... DONE
[08:26:37.237] Launching 1 futures (chunks) ... DONE
[08:26:37.237] Resolving 1 futures (chunks) ...
[08:26:37.237] resolve() on list ...
[08:26:37.237]  recursive: 0
[08:26:37.237]  length: 1
[08:26:37.237] 
[08:26:37.237] resolved() for ‘SequentialFuture’ ...
[08:26:37.237] - state: ‘finished’
[08:26:37.238] - run: TRUE
[08:26:37.238] - result: ‘FutureResult’
[08:26:37.238] resolved() for ‘SequentialFuture’ ... done
[08:26:37.238] Future #1
[08:26:37.238] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:37.238] - nx: 1
[08:26:37.238] - relay: TRUE
[08:26:37.238] - stdout: TRUE
[08:26:37.238] - signal: TRUE
[08:26:37.238] - resignal: FALSE
[08:26:37.239] - force: TRUE
[08:26:37.239] - relayed: [n=1] FALSE
[08:26:37.239] - queued futures: [n=1] FALSE
[08:26:37.239]  - until=1
[08:26:37.239]  - relaying element #1
[08:26:37.239] - relayed: [n=1] TRUE
[08:26:37.239] - queued futures: [n=1] TRUE
[08:26:37.239] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:37.239]  length: 0 (resolved future 1)
[08:26:37.239] Relaying remaining futures
[08:26:37.240] signalConditionsASAP(NULL, pos=0) ...
[08:26:37.240] - nx: 1
[08:26:37.240] - relay: TRUE
[08:26:37.240] - stdout: TRUE
[08:26:37.240] - signal: TRUE
[08:26:37.240] - resignal: FALSE
[08:26:37.240] - force: TRUE
[08:26:37.240] - relayed: [n=1] TRUE
[08:26:37.240] - queued futures: [n=1] TRUE
 - flush all
[08:26:37.240] - relayed: [n=1] TRUE
[08:26:37.240] - queued futures: [n=1] TRUE
[08:26:37.241] signalConditionsASAP(NULL, pos=0) ... done
[08:26:37.241] resolve() on list ... DONE
[08:26:37.241]  - Number of value chunks collected: 1
[08:26:37.241] Resolving 1 futures (chunks) ... DONE
[08:26:37.241] Reducing values from 1 chunks ...
[08:26:37.241]  - Number of values collected after concatenation: 2
[08:26:37.241]  - Number of values expected: 2
[08:26:37.241] Reducing values from 1 chunks ... DONE
[08:26:37.241] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[08:26:37.242] future_lapply() ...
[08:26:37.244] Number of chunks: 1
[08:26:37.244] getGlobalsAndPackagesXApply() ...
[08:26:37.244]  - future.globals: TRUE
[08:26:37.244] getGlobalsAndPackages() ...
[08:26:37.244] Searching for globals...
[08:26:37.246] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:37.246] Searching for globals ... DONE
[08:26:37.246] Resolving globals: FALSE
[08:26:37.246] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:37.247] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:37.247] - globals: [1] ‘FUN’
[08:26:37.247] 
[08:26:37.247] getGlobalsAndPackages() ... DONE
[08:26:37.247]  - globals found/used: [n=1] ‘FUN’
[08:26:37.247]  - needed namespaces: [n=0] 
[08:26:37.247] Finding globals ... DONE
[08:26:37.248]  - use_args: TRUE
[08:26:37.248]  - Getting '...' globals ...
[08:26:37.248] resolve() on list ...
[08:26:37.248]  recursive: 0
[08:26:37.248]  length: 1
[08:26:37.248]  elements: ‘...’
[08:26:37.248]  length: 0 (resolved future 1)
[08:26:37.248] resolve() on list ... DONE
[08:26:37.249]    - '...' content: [n=0] 
[08:26:37.249] List of 1
[08:26:37.249]  $ ...: list()
[08:26:37.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:37.249]  - attr(*, "where")=List of 1
[08:26:37.249]   ..$ ...:<environment: 0x55e10e682bd8> 
[08:26:37.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:37.249]  - attr(*, "resolved")= logi TRUE
[08:26:37.249]  - attr(*, "total_size")= num NA
[08:26:37.251]  - Getting '...' globals ... DONE
[08:26:37.251] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:37.251] List of 2
[08:26:37.251]  $ ...future.FUN:function (x)  
[08:26:37.251]  $ ...          : list()
[08:26:37.251]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:37.251]  - attr(*, "where")=List of 2
[08:26:37.251]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:37.251]   ..$ ...          :<environment: 0x55e10e682bd8> 
[08:26:37.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:37.251]  - attr(*, "resolved")= logi FALSE
[08:26:37.251]  - attr(*, "total_size")= num 5632
[08:26:37.256] Packages to be attached in all futures: [n=0] 
[08:26:37.256] getGlobalsAndPackagesXApply() ... DONE
[08:26:37.257] Number of futures (= number of chunks): 1
[08:26:37.257] Launching 1 futures (chunks) ...
[08:26:37.257] Chunk #1 of 1 ...
[08:26:37.257]  - Finding globals in 'X' for chunk #1 ...
[08:26:37.257] getGlobalsAndPackages() ...
[08:26:37.257] Searching for globals...
[08:26:37.257] 
[08:26:37.258] Searching for globals ... DONE
[08:26:37.258] - globals: [0] <none>
[08:26:37.258] getGlobalsAndPackages() ... DONE
[08:26:37.258]    + additional globals found: [n=0] 
[08:26:37.258]    + additional namespaces needed: [n=0] 
[08:26:37.258]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:37.258]  - seeds: <none>
[08:26:37.258]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:37.258] getGlobalsAndPackages() ...
[08:26:37.258] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:37.259] Resolving globals: FALSE
[08:26:37.259] Tweak future expression to call with '...' arguments ...
[08:26:37.259] {
[08:26:37.259]     do.call(function(...) {
[08:26:37.259]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:37.259]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:37.259]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:37.259]             on.exit(options(oopts), add = TRUE)
[08:26:37.259]         }
[08:26:37.259]         {
[08:26:37.259]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:37.259]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:37.259]                 ...future.FUN(...future.X_jj, ...)
[08:26:37.259]             })
[08:26:37.259]         }
[08:26:37.259]     }, args = future.call.arguments)
[08:26:37.259] }
[08:26:37.259] Tweak future expression to call with '...' arguments ... DONE
[08:26:37.259] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:37.260] 
[08:26:37.260] getGlobalsAndPackages() ... DONE
[08:26:37.260] run() for ‘Future’ ...
[08:26:37.260] - state: ‘created’
[08:26:37.260] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:37.262] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:37.262] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:37.262]   - Field: ‘label’
[08:26:37.262]   - Field: ‘local’
[08:26:37.262]   - Field: ‘owner’
[08:26:37.262]   - Field: ‘envir’
[08:26:37.263]   - Field: ‘packages’
[08:26:37.263]   - Field: ‘gc’
[08:26:37.263]   - Field: ‘conditions’
[08:26:37.263]   - Field: ‘expr’
[08:26:37.263]   - Field: ‘uuid’
[08:26:37.263]   - Field: ‘seed’
[08:26:37.263]   - Field: ‘version’
[08:26:37.263]   - Field: ‘result’
[08:26:37.263]   - Field: ‘asynchronous’
[08:26:37.263]   - Field: ‘calls’
[08:26:37.263]   - Field: ‘globals’
[08:26:37.264]   - Field: ‘stdout’
[08:26:37.264]   - Field: ‘earlySignal’
[08:26:37.264]   - Field: ‘lazy’
[08:26:37.264]   - Field: ‘state’
[08:26:37.264] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:37.264] - Launch lazy future ...
[08:26:37.264] Packages needed by the future expression (n = 0): <none>
[08:26:37.264] Packages needed by future strategies (n = 0): <none>
[08:26:37.265] {
[08:26:37.265]     {
[08:26:37.265]         {
[08:26:37.265]             ...future.startTime <- base::Sys.time()
[08:26:37.265]             {
[08:26:37.265]                 {
[08:26:37.265]                   {
[08:26:37.265]                     base::local({
[08:26:37.265]                       has_future <- base::requireNamespace("future", 
[08:26:37.265]                         quietly = TRUE)
[08:26:37.265]                       if (has_future) {
[08:26:37.265]                         ns <- base::getNamespace("future")
[08:26:37.265]                         version <- ns[[".package"]][["version"]]
[08:26:37.265]                         if (is.null(version)) 
[08:26:37.265]                           version <- utils::packageVersion("future")
[08:26:37.265]                       }
[08:26:37.265]                       else {
[08:26:37.265]                         version <- NULL
[08:26:37.265]                       }
[08:26:37.265]                       if (!has_future || version < "1.8.0") {
[08:26:37.265]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:37.265]                           "", base::R.version$version.string), 
[08:26:37.265]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:37.265]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:37.265]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:37.265]                             "release", "version")], collapse = " "), 
[08:26:37.265]                           hostname = base::Sys.info()[["nodename"]])
[08:26:37.265]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:37.265]                           info)
[08:26:37.265]                         info <- base::paste(info, collapse = "; ")
[08:26:37.265]                         if (!has_future) {
[08:26:37.265]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:37.265]                             info)
[08:26:37.265]                         }
[08:26:37.265]                         else {
[08:26:37.265]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:37.265]                             info, version)
[08:26:37.265]                         }
[08:26:37.265]                         base::stop(msg)
[08:26:37.265]                       }
[08:26:37.265]                     })
[08:26:37.265]                   }
[08:26:37.265]                   ...future.strategy.old <- future::plan("list")
[08:26:37.265]                   options(future.plan = NULL)
[08:26:37.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:37.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:37.265]                 }
[08:26:37.265]                 ...future.workdir <- getwd()
[08:26:37.265]             }
[08:26:37.265]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:37.265]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:37.265]         }
[08:26:37.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:37.265]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:37.265]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:37.265]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:37.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:37.265]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:37.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:37.265]             base::names(...future.oldOptions))
[08:26:37.265]     }
[08:26:37.265]     if (TRUE) {
[08:26:37.265]     }
[08:26:37.265]     else {
[08:26:37.265]         if (NA) {
[08:26:37.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:37.265]                 open = "w")
[08:26:37.265]         }
[08:26:37.265]         else {
[08:26:37.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:37.265]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:37.265]         }
[08:26:37.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:37.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:37.265]             base::sink(type = "output", split = FALSE)
[08:26:37.265]             base::close(...future.stdout)
[08:26:37.265]         }, add = TRUE)
[08:26:37.265]     }
[08:26:37.265]     ...future.frame <- base::sys.nframe()
[08:26:37.265]     ...future.conditions <- base::list()
[08:26:37.265]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:37.265]     if (FALSE) {
[08:26:37.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:37.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:37.265]     }
[08:26:37.265]     ...future.result <- base::tryCatch({
[08:26:37.265]         base::withCallingHandlers({
[08:26:37.265]             ...future.value <- base::withVisible(base::local({
[08:26:37.265]                 do.call(function(...) {
[08:26:37.265]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:37.265]                   if (!identical(...future.globals.maxSize.org, 
[08:26:37.265]                     ...future.globals.maxSize)) {
[08:26:37.265]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:37.265]                     on.exit(options(oopts), add = TRUE)
[08:26:37.265]                   }
[08:26:37.265]                   {
[08:26:37.265]                     lapply(seq_along(...future.elements_ii), 
[08:26:37.265]                       FUN = function(jj) {
[08:26:37.265]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:37.265]                         ...future.FUN(...future.X_jj, ...)
[08:26:37.265]                       })
[08:26:37.265]                   }
[08:26:37.265]                 }, args = future.call.arguments)
[08:26:37.265]             }))
[08:26:37.265]             future::FutureResult(value = ...future.value$value, 
[08:26:37.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:37.265]                   ...future.rng), globalenv = if (FALSE) 
[08:26:37.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:37.265]                     ...future.globalenv.names))
[08:26:37.265]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:37.265]         }, condition = base::local({
[08:26:37.265]             c <- base::c
[08:26:37.265]             inherits <- base::inherits
[08:26:37.265]             invokeRestart <- base::invokeRestart
[08:26:37.265]             length <- base::length
[08:26:37.265]             list <- base::list
[08:26:37.265]             seq.int <- base::seq.int
[08:26:37.265]             signalCondition <- base::signalCondition
[08:26:37.265]             sys.calls <- base::sys.calls
[08:26:37.265]             `[[` <- base::`[[`
[08:26:37.265]             `+` <- base::`+`
[08:26:37.265]             `<<-` <- base::`<<-`
[08:26:37.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:37.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:37.265]                   3L)]
[08:26:37.265]             }
[08:26:37.265]             function(cond) {
[08:26:37.265]                 is_error <- inherits(cond, "error")
[08:26:37.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:37.265]                   NULL)
[08:26:37.265]                 if (is_error) {
[08:26:37.265]                   sessionInformation <- function() {
[08:26:37.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:37.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:37.265]                       search = base::search(), system = base::Sys.info())
[08:26:37.265]                   }
[08:26:37.265]                   ...future.conditions[[length(...future.conditions) + 
[08:26:37.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:37.265]                     cond$call), session = sessionInformation(), 
[08:26:37.265]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:37.265]                   signalCondition(cond)
[08:26:37.265]                 }
[08:26:37.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:37.265]                 "immediateCondition"))) {
[08:26:37.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:37.265]                   ...future.conditions[[length(...future.conditions) + 
[08:26:37.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:37.265]                   if (TRUE && !signal) {
[08:26:37.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:37.265]                     {
[08:26:37.265]                       inherits <- base::inherits
[08:26:37.265]                       invokeRestart <- base::invokeRestart
[08:26:37.265]                       is.null <- base::is.null
[08:26:37.265]                       muffled <- FALSE
[08:26:37.265]                       if (inherits(cond, "message")) {
[08:26:37.265]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:37.265]                         if (muffled) 
[08:26:37.265]                           invokeRestart("muffleMessage")
[08:26:37.265]                       }
[08:26:37.265]                       else if (inherits(cond, "warning")) {
[08:26:37.265]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:37.265]                         if (muffled) 
[08:26:37.265]                           invokeRestart("muffleWarning")
[08:26:37.265]                       }
[08:26:37.265]                       else if (inherits(cond, "condition")) {
[08:26:37.265]                         if (!is.null(pattern)) {
[08:26:37.265]                           computeRestarts <- base::computeRestarts
[08:26:37.265]                           grepl <- base::grepl
[08:26:37.265]                           restarts <- computeRestarts(cond)
[08:26:37.265]                           for (restart in restarts) {
[08:26:37.265]                             name <- restart$name
[08:26:37.265]                             if (is.null(name)) 
[08:26:37.265]                               next
[08:26:37.265]                             if (!grepl(pattern, name)) 
[08:26:37.265]                               next
[08:26:37.265]                             invokeRestart(restart)
[08:26:37.265]                             muffled <- TRUE
[08:26:37.265]                             break
[08:26:37.265]                           }
[08:26:37.265]                         }
[08:26:37.265]                       }
[08:26:37.265]                       invisible(muffled)
[08:26:37.265]                     }
[08:26:37.265]                     muffleCondition(cond, pattern = "^muffle")
[08:26:37.265]                   }
[08:26:37.265]                 }
[08:26:37.265]                 else {
[08:26:37.265]                   if (TRUE) {
[08:26:37.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:37.265]                     {
[08:26:37.265]                       inherits <- base::inherits
[08:26:37.265]                       invokeRestart <- base::invokeRestart
[08:26:37.265]                       is.null <- base::is.null
[08:26:37.265]                       muffled <- FALSE
[08:26:37.265]                       if (inherits(cond, "message")) {
[08:26:37.265]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:37.265]                         if (muffled) 
[08:26:37.265]                           invokeRestart("muffleMessage")
[08:26:37.265]                       }
[08:26:37.265]                       else if (inherits(cond, "warning")) {
[08:26:37.265]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:37.265]                         if (muffled) 
[08:26:37.265]                           invokeRestart("muffleWarning")
[08:26:37.265]                       }
[08:26:37.265]                       else if (inherits(cond, "condition")) {
[08:26:37.265]                         if (!is.null(pattern)) {
[08:26:37.265]                           computeRestarts <- base::computeRestarts
[08:26:37.265]                           grepl <- base::grepl
[08:26:37.265]                           restarts <- computeRestarts(cond)
[08:26:37.265]                           for (restart in restarts) {
[08:26:37.265]                             name <- restart$name
[08:26:37.265]                             if (is.null(name)) 
[08:26:37.265]                               next
[08:26:37.265]                             if (!grepl(pattern, name)) 
[08:26:37.265]                               next
[08:26:37.265]                             invokeRestart(restart)
[08:26:37.265]                             muffled <- TRUE
[08:26:37.265]                             break
[08:26:37.265]                           }
[08:26:37.265]                         }
[08:26:37.265]                       }
[08:26:37.265]                       invisible(muffled)
[08:26:37.265]                     }
[08:26:37.265]                     muffleCondition(cond, pattern = "^muffle")
[08:26:37.265]                   }
[08:26:37.265]                 }
[08:26:37.265]             }
[08:26:37.265]         }))
[08:26:37.265]     }, error = function(ex) {
[08:26:37.265]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:37.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:37.265]                 ...future.rng), started = ...future.startTime, 
[08:26:37.265]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:37.265]             version = "1.8"), class = "FutureResult")
[08:26:37.265]     }, finally = {
[08:26:37.265]         if (!identical(...future.workdir, getwd())) 
[08:26:37.265]             setwd(...future.workdir)
[08:26:37.265]         {
[08:26:37.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:37.265]                 ...future.oldOptions$nwarnings <- NULL
[08:26:37.265]             }
[08:26:37.265]             base::options(...future.oldOptions)
[08:26:37.265]             if (.Platform$OS.type == "windows") {
[08:26:37.265]                 old_names <- names(...future.oldEnvVars)
[08:26:37.265]                 envs <- base::Sys.getenv()
[08:26:37.265]                 names <- names(envs)
[08:26:37.265]                 common <- intersect(names, old_names)
[08:26:37.265]                 added <- setdiff(names, old_names)
[08:26:37.265]                 removed <- setdiff(old_names, names)
[08:26:37.265]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:37.265]                   envs[common]]
[08:26:37.265]                 NAMES <- toupper(changed)
[08:26:37.265]                 args <- list()
[08:26:37.265]                 for (kk in seq_along(NAMES)) {
[08:26:37.265]                   name <- changed[[kk]]
[08:26:37.265]                   NAME <- NAMES[[kk]]
[08:26:37.265]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:37.265]                     next
[08:26:37.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:37.265]                 }
[08:26:37.265]                 NAMES <- toupper(added)
[08:26:37.265]                 for (kk in seq_along(NAMES)) {
[08:26:37.265]                   name <- added[[kk]]
[08:26:37.265]                   NAME <- NAMES[[kk]]
[08:26:37.265]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:37.265]                     next
[08:26:37.265]                   args[[name]] <- ""
[08:26:37.265]                 }
[08:26:37.265]                 NAMES <- toupper(removed)
[08:26:37.265]                 for (kk in seq_along(NAMES)) {
[08:26:37.265]                   name <- removed[[kk]]
[08:26:37.265]                   NAME <- NAMES[[kk]]
[08:26:37.265]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:37.265]                     next
[08:26:37.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:37.265]                 }
[08:26:37.265]                 if (length(args) > 0) 
[08:26:37.265]                   base::do.call(base::Sys.setenv, args = args)
[08:26:37.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:37.265]             }
[08:26:37.265]             else {
[08:26:37.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:37.265]             }
[08:26:37.265]             {
[08:26:37.265]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:37.265]                   0L) {
[08:26:37.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:37.265]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:37.265]                   base::options(opts)
[08:26:37.265]                 }
[08:26:37.265]                 {
[08:26:37.265]                   {
[08:26:37.265]                     NULL
[08:26:37.265]                     RNGkind("Mersenne-Twister")
[08:26:37.265]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:37.265]                       inherits = FALSE)
[08:26:37.265]                   }
[08:26:37.265]                   options(future.plan = NULL)
[08:26:37.265]                   if (is.na(NA_character_)) 
[08:26:37.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:37.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:37.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:37.265]                     .init = FALSE)
[08:26:37.265]                 }
[08:26:37.265]             }
[08:26:37.265]         }
[08:26:37.265]     })
[08:26:37.265]     if (FALSE) {
[08:26:37.265]         base::sink(type = "output", split = FALSE)
[08:26:37.265]         if (NA) {
[08:26:37.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:37.265]         }
[08:26:37.265]         else {
[08:26:37.265]             ...future.result["stdout"] <- base::list(NULL)
[08:26:37.265]         }
[08:26:37.265]         base::close(...future.stdout)
[08:26:37.265]         ...future.stdout <- NULL
[08:26:37.265]     }
[08:26:37.265]     ...future.result$conditions <- ...future.conditions
[08:26:37.265]     ...future.result$finished <- base::Sys.time()
[08:26:37.265]     ...future.result
[08:26:37.265] }
[08:26:37.267] assign_globals() ...
[08:26:37.267] List of 5
[08:26:37.267]  $ ...future.FUN            :function (x)  
[08:26:37.267]  $ future.call.arguments    : list()
[08:26:37.267]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:37.267]  $ ...future.elements_ii    :List of 2
[08:26:37.267]   ..$ : int 1
[08:26:37.267]   ..$ : int 0
[08:26:37.267]  $ ...future.seeds_ii       : NULL
[08:26:37.267]  $ ...future.globals.maxSize: NULL
[08:26:37.267]  - attr(*, "where")=List of 5
[08:26:37.267]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:37.267]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:37.267]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:37.267]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:37.267]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:37.267]  - attr(*, "resolved")= logi FALSE
[08:26:37.267]  - attr(*, "total_size")= num 5632
[08:26:37.267]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:37.267]  - attr(*, "already-done")= logi TRUE
[08:26:37.272] - reassign environment for ‘...future.FUN’
[08:26:37.272] - copied ‘...future.FUN’ to environment
[08:26:37.272] - copied ‘future.call.arguments’ to environment
[08:26:37.272] - copied ‘...future.elements_ii’ to environment
[08:26:37.272] - copied ‘...future.seeds_ii’ to environment
[08:26:37.273] - copied ‘...future.globals.maxSize’ to environment
[08:26:37.273] assign_globals() ... done
[08:26:37.273] plan(): Setting new future strategy stack:
[08:26:37.273] List of future strategies:
[08:26:37.273] 1. sequential:
[08:26:37.273]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:37.273]    - tweaked: FALSE
[08:26:37.273]    - call: NULL
[08:26:37.274] plan(): nbrOfWorkers() = 1
[08:26:37.775] plan(): Setting new future strategy stack:
[08:26:37.776] List of future strategies:
[08:26:37.776] 1. multicore:
[08:26:37.776]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:37.776]    - tweaked: FALSE
[08:26:37.776]    - call: plan(strategy)
[08:26:37.778] plan(): nbrOfWorkers() = 1
[08:26:37.778] SequentialFuture started (and completed)
[08:26:37.778] - Launch lazy future ... done
[08:26:37.778] run() for ‘SequentialFuture’ ... done
[08:26:37.778] Created future:
[08:26:37.778] SequentialFuture:
[08:26:37.778] Label: ‘future_lapply-1’
[08:26:37.778] Expression:
[08:26:37.778] {
[08:26:37.778]     do.call(function(...) {
[08:26:37.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:37.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:37.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:37.778]             on.exit(options(oopts), add = TRUE)
[08:26:37.778]         }
[08:26:37.778]         {
[08:26:37.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:37.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:37.778]                 ...future.FUN(...future.X_jj, ...)
[08:26:37.778]             })
[08:26:37.778]         }
[08:26:37.778]     }, args = future.call.arguments)
[08:26:37.778] }
[08:26:37.778] Lazy evaluation: FALSE
[08:26:37.778] Asynchronous evaluation: FALSE
[08:26:37.778] Local evaluation: TRUE
[08:26:37.778] Environment: R_GlobalEnv
[08:26:37.778] Capture standard output: NA
[08:26:37.778] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:37.778] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:37.778] Packages: <none>
[08:26:37.778] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:37.778] Resolved: TRUE
[08:26:37.778] Value: 55 bytes of class ‘list’
[08:26:37.778] Early signaling: FALSE
[08:26:37.778] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:37.778] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:37.779] Chunk #1 of 1 ... DONE
[08:26:37.779] Launching 1 futures (chunks) ... DONE
[08:26:37.779] Resolving 1 futures (chunks) ...
[08:26:37.779] resolve() on list ...
[08:26:37.780]  recursive: 0
[08:26:37.780]  length: 1
[08:26:37.780] 
[08:26:37.780] resolved() for ‘SequentialFuture’ ...
[08:26:37.780] - state: ‘finished’
[08:26:37.780] - run: TRUE
[08:26:37.780] - result: ‘FutureResult’
[08:26:37.780] resolved() for ‘SequentialFuture’ ... done
[08:26:37.780] Future #1
[08:26:37.781] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:37.781] - nx: 1
[08:26:37.781] - relay: TRUE
[08:26:37.781] - stdout: TRUE
[08:26:37.781] - signal: TRUE
[08:26:37.781] - resignal: FALSE
[08:26:37.781] - force: TRUE
[08:26:37.781] - relayed: [n=1] FALSE
[08:26:37.781] - queued futures: [n=1] FALSE
[08:26:37.781]  - until=1
[08:26:37.781]  - relaying element #1
[08:26:37.784] - relayed: [n=1] TRUE
[08:26:37.784] - queued futures: [n=1] TRUE
[08:26:37.784] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:37.784]  length: 0 (resolved future 1)
[08:26:37.784] Relaying remaining futures
[08:26:37.785] signalConditionsASAP(NULL, pos=0) ...
[08:26:37.785] - nx: 1
[08:26:37.785] - relay: TRUE
[08:26:37.785] - stdout: TRUE
[08:26:37.785] - signal: TRUE
[08:26:37.785] - resignal: FALSE
[08:26:37.785] - force: TRUE
[08:26:37.785] - relayed: [n=1] TRUE
[08:26:37.785] - queued futures: [n=1] TRUE
 - flush all
[08:26:37.785] - relayed: [n=1] TRUE
[08:26:37.785] - queued futures: [n=1] TRUE
[08:26:37.785] signalConditionsASAP(NULL, pos=0) ... done
[08:26:37.786] resolve() on list ... DONE
[08:26:37.786]  - Number of value chunks collected: 1
[08:26:37.786] Resolving 1 futures (chunks) ... DONE
[08:26:37.786] Reducing values from 1 chunks ...
[08:26:37.786]  - Number of values collected after concatenation: 2
[08:26:37.786]  - Number of values expected: 2
[08:26:37.786] Reducing values from 1 chunks ... DONE
[08:26:37.786] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[08:26:37.787] future_mapply() ...
[08:26:37.788] Number of chunks: 1
[08:26:37.788] getGlobalsAndPackagesXApply() ...
[08:26:37.789]  - future.globals: TRUE
[08:26:37.789] getGlobalsAndPackages() ...
[08:26:37.789] Searching for globals...
[08:26:37.791] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:37.791] Searching for globals ... DONE
[08:26:37.791] Resolving globals: FALSE
[08:26:37.791] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:37.792] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:37.792] - globals: [1] ‘FUN’
[08:26:37.792] 
[08:26:37.792] getGlobalsAndPackages() ... DONE
[08:26:37.792]  - globals found/used: [n=1] ‘FUN’
[08:26:37.792]  - needed namespaces: [n=0] 
[08:26:37.792] Finding globals ... DONE
[08:26:37.792] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:37.793] List of 2
[08:26:37.793]  $ ...future.FUN:function (x, y)  
[08:26:37.793]  $ MoreArgs     : NULL
[08:26:37.793]  - attr(*, "where")=List of 2
[08:26:37.793]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:37.793]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:37.793]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:37.793]  - attr(*, "resolved")= logi FALSE
[08:26:37.793]  - attr(*, "total_size")= num NA
[08:26:37.795] Packages to be attached in all futures: [n=0] 
[08:26:37.795] getGlobalsAndPackagesXApply() ... DONE
[08:26:37.795] Number of futures (= number of chunks): 1
[08:26:37.796] Launching 1 futures (chunks) ...
[08:26:37.796] Chunk #1 of 1 ...
[08:26:37.796]  - Finding globals in '...' for chunk #1 ...
[08:26:37.796] getGlobalsAndPackages() ...
[08:26:37.796] Searching for globals...
[08:26:37.796] 
[08:26:37.796] Searching for globals ... DONE
[08:26:37.797] - globals: [0] <none>
[08:26:37.797] getGlobalsAndPackages() ... DONE
[08:26:37.797]    + additional globals found: [n=0] 
[08:26:37.797]    + additional namespaces needed: [n=0] 
[08:26:37.797]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:37.797]  - seeds: <none>
[08:26:37.797]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:37.797] getGlobalsAndPackages() ...
[08:26:37.797] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:37.797] Resolving globals: FALSE
[08:26:37.798] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[08:26:37.798] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:37.798] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:37.799] 
[08:26:37.799] getGlobalsAndPackages() ... DONE
[08:26:37.799] run() for ‘Future’ ...
[08:26:37.799] - state: ‘created’
[08:26:37.799] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:37.801] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:37.801] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:37.801]   - Field: ‘label’
[08:26:37.801]   - Field: ‘local’
[08:26:37.801]   - Field: ‘owner’
[08:26:37.802]   - Field: ‘envir’
[08:26:37.802]   - Field: ‘packages’
[08:26:37.802]   - Field: ‘gc’
[08:26:37.802]   - Field: ‘conditions’
[08:26:37.802]   - Field: ‘expr’
[08:26:37.802]   - Field: ‘uuid’
[08:26:37.802]   - Field: ‘seed’
[08:26:37.802]   - Field: ‘version’
[08:26:37.802]   - Field: ‘result’
[08:26:37.802]   - Field: ‘asynchronous’
[08:26:37.802]   - Field: ‘calls’
[08:26:37.803]   - Field: ‘globals’
[08:26:37.803]   - Field: ‘stdout’
[08:26:37.803]   - Field: ‘earlySignal’
[08:26:37.803]   - Field: ‘lazy’
[08:26:37.803]   - Field: ‘state’
[08:26:37.803] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:37.803] - Launch lazy future ...
[08:26:37.803] Packages needed by the future expression (n = 0): <none>
[08:26:37.803] Packages needed by future strategies (n = 0): <none>
[08:26:37.804] {
[08:26:37.804]     {
[08:26:37.804]         {
[08:26:37.804]             ...future.startTime <- base::Sys.time()
[08:26:37.804]             {
[08:26:37.804]                 {
[08:26:37.804]                   {
[08:26:37.804]                     base::local({
[08:26:37.804]                       has_future <- base::requireNamespace("future", 
[08:26:37.804]                         quietly = TRUE)
[08:26:37.804]                       if (has_future) {
[08:26:37.804]                         ns <- base::getNamespace("future")
[08:26:37.804]                         version <- ns[[".package"]][["version"]]
[08:26:37.804]                         if (is.null(version)) 
[08:26:37.804]                           version <- utils::packageVersion("future")
[08:26:37.804]                       }
[08:26:37.804]                       else {
[08:26:37.804]                         version <- NULL
[08:26:37.804]                       }
[08:26:37.804]                       if (!has_future || version < "1.8.0") {
[08:26:37.804]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:37.804]                           "", base::R.version$version.string), 
[08:26:37.804]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:37.804]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:37.804]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:37.804]                             "release", "version")], collapse = " "), 
[08:26:37.804]                           hostname = base::Sys.info()[["nodename"]])
[08:26:37.804]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:37.804]                           info)
[08:26:37.804]                         info <- base::paste(info, collapse = "; ")
[08:26:37.804]                         if (!has_future) {
[08:26:37.804]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:37.804]                             info)
[08:26:37.804]                         }
[08:26:37.804]                         else {
[08:26:37.804]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:37.804]                             info, version)
[08:26:37.804]                         }
[08:26:37.804]                         base::stop(msg)
[08:26:37.804]                       }
[08:26:37.804]                     })
[08:26:37.804]                   }
[08:26:37.804]                   ...future.strategy.old <- future::plan("list")
[08:26:37.804]                   options(future.plan = NULL)
[08:26:37.804]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:37.804]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:37.804]                 }
[08:26:37.804]                 ...future.workdir <- getwd()
[08:26:37.804]             }
[08:26:37.804]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:37.804]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:37.804]         }
[08:26:37.804]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:37.804]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:37.804]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:37.804]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:37.804]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:37.804]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:37.804]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:37.804]             base::names(...future.oldOptions))
[08:26:37.804]     }
[08:26:37.804]     if (FALSE) {
[08:26:37.804]     }
[08:26:37.804]     else {
[08:26:37.804]         if (FALSE) {
[08:26:37.804]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:37.804]                 open = "w")
[08:26:37.804]         }
[08:26:37.804]         else {
[08:26:37.804]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:37.804]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:37.804]         }
[08:26:37.804]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:37.804]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:37.804]             base::sink(type = "output", split = FALSE)
[08:26:37.804]             base::close(...future.stdout)
[08:26:37.804]         }, add = TRUE)
[08:26:37.804]     }
[08:26:37.804]     ...future.frame <- base::sys.nframe()
[08:26:37.804]     ...future.conditions <- base::list()
[08:26:37.804]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:37.804]     if (FALSE) {
[08:26:37.804]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:37.804]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:37.804]     }
[08:26:37.804]     ...future.result <- base::tryCatch({
[08:26:37.804]         base::withCallingHandlers({
[08:26:37.804]             ...future.value <- base::withVisible(base::local({
[08:26:37.804]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:37.804]                 if (!identical(...future.globals.maxSize.org, 
[08:26:37.804]                   ...future.globals.maxSize)) {
[08:26:37.804]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:37.804]                   on.exit(options(oopts), add = TRUE)
[08:26:37.804]                 }
[08:26:37.804]                 {
[08:26:37.804]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:37.804]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:37.804]                     USE.NAMES = FALSE)
[08:26:37.804]                   do.call(mapply, args = args)
[08:26:37.804]                 }
[08:26:37.804]             }))
[08:26:37.804]             future::FutureResult(value = ...future.value$value, 
[08:26:37.804]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:37.804]                   ...future.rng), globalenv = if (FALSE) 
[08:26:37.804]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:37.804]                     ...future.globalenv.names))
[08:26:37.804]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:37.804]         }, condition = base::local({
[08:26:37.804]             c <- base::c
[08:26:37.804]             inherits <- base::inherits
[08:26:37.804]             invokeRestart <- base::invokeRestart
[08:26:37.804]             length <- base::length
[08:26:37.804]             list <- base::list
[08:26:37.804]             seq.int <- base::seq.int
[08:26:37.804]             signalCondition <- base::signalCondition
[08:26:37.804]             sys.calls <- base::sys.calls
[08:26:37.804]             `[[` <- base::`[[`
[08:26:37.804]             `+` <- base::`+`
[08:26:37.804]             `<<-` <- base::`<<-`
[08:26:37.804]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:37.804]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:37.804]                   3L)]
[08:26:37.804]             }
[08:26:37.804]             function(cond) {
[08:26:37.804]                 is_error <- inherits(cond, "error")
[08:26:37.804]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:37.804]                   NULL)
[08:26:37.804]                 if (is_error) {
[08:26:37.804]                   sessionInformation <- function() {
[08:26:37.804]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:37.804]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:37.804]                       search = base::search(), system = base::Sys.info())
[08:26:37.804]                   }
[08:26:37.804]                   ...future.conditions[[length(...future.conditions) + 
[08:26:37.804]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:37.804]                     cond$call), session = sessionInformation(), 
[08:26:37.804]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:37.804]                   signalCondition(cond)
[08:26:37.804]                 }
[08:26:37.804]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:37.804]                 "immediateCondition"))) {
[08:26:37.804]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:37.804]                   ...future.conditions[[length(...future.conditions) + 
[08:26:37.804]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:37.804]                   if (TRUE && !signal) {
[08:26:37.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:37.804]                     {
[08:26:37.804]                       inherits <- base::inherits
[08:26:37.804]                       invokeRestart <- base::invokeRestart
[08:26:37.804]                       is.null <- base::is.null
[08:26:37.804]                       muffled <- FALSE
[08:26:37.804]                       if (inherits(cond, "message")) {
[08:26:37.804]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:37.804]                         if (muffled) 
[08:26:37.804]                           invokeRestart("muffleMessage")
[08:26:37.804]                       }
[08:26:37.804]                       else if (inherits(cond, "warning")) {
[08:26:37.804]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:37.804]                         if (muffled) 
[08:26:37.804]                           invokeRestart("muffleWarning")
[08:26:37.804]                       }
[08:26:37.804]                       else if (inherits(cond, "condition")) {
[08:26:37.804]                         if (!is.null(pattern)) {
[08:26:37.804]                           computeRestarts <- base::computeRestarts
[08:26:37.804]                           grepl <- base::grepl
[08:26:37.804]                           restarts <- computeRestarts(cond)
[08:26:37.804]                           for (restart in restarts) {
[08:26:37.804]                             name <- restart$name
[08:26:37.804]                             if (is.null(name)) 
[08:26:37.804]                               next
[08:26:37.804]                             if (!grepl(pattern, name)) 
[08:26:37.804]                               next
[08:26:37.804]                             invokeRestart(restart)
[08:26:37.804]                             muffled <- TRUE
[08:26:37.804]                             break
[08:26:37.804]                           }
[08:26:37.804]                         }
[08:26:37.804]                       }
[08:26:37.804]                       invisible(muffled)
[08:26:37.804]                     }
[08:26:37.804]                     muffleCondition(cond, pattern = "^muffle")
[08:26:37.804]                   }
[08:26:37.804]                 }
[08:26:37.804]                 else {
[08:26:37.804]                   if (TRUE) {
[08:26:37.804]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:37.804]                     {
[08:26:37.804]                       inherits <- base::inherits
[08:26:37.804]                       invokeRestart <- base::invokeRestart
[08:26:37.804]                       is.null <- base::is.null
[08:26:37.804]                       muffled <- FALSE
[08:26:37.804]                       if (inherits(cond, "message")) {
[08:26:37.804]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:37.804]                         if (muffled) 
[08:26:37.804]                           invokeRestart("muffleMessage")
[08:26:37.804]                       }
[08:26:37.804]                       else if (inherits(cond, "warning")) {
[08:26:37.804]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:37.804]                         if (muffled) 
[08:26:37.804]                           invokeRestart("muffleWarning")
[08:26:37.804]                       }
[08:26:37.804]                       else if (inherits(cond, "condition")) {
[08:26:37.804]                         if (!is.null(pattern)) {
[08:26:37.804]                           computeRestarts <- base::computeRestarts
[08:26:37.804]                           grepl <- base::grepl
[08:26:37.804]                           restarts <- computeRestarts(cond)
[08:26:37.804]                           for (restart in restarts) {
[08:26:37.804]                             name <- restart$name
[08:26:37.804]                             if (is.null(name)) 
[08:26:37.804]                               next
[08:26:37.804]                             if (!grepl(pattern, name)) 
[08:26:37.804]                               next
[08:26:37.804]                             invokeRestart(restart)
[08:26:37.804]                             muffled <- TRUE
[08:26:37.804]                             break
[08:26:37.804]                           }
[08:26:37.804]                         }
[08:26:37.804]                       }
[08:26:37.804]                       invisible(muffled)
[08:26:37.804]                     }
[08:26:37.804]                     muffleCondition(cond, pattern = "^muffle")
[08:26:37.804]                   }
[08:26:37.804]                 }
[08:26:37.804]             }
[08:26:37.804]         }))
[08:26:37.804]     }, error = function(ex) {
[08:26:37.804]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:37.804]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:37.804]                 ...future.rng), started = ...future.startTime, 
[08:26:37.804]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:37.804]             version = "1.8"), class = "FutureResult")
[08:26:37.804]     }, finally = {
[08:26:37.804]         if (!identical(...future.workdir, getwd())) 
[08:26:37.804]             setwd(...future.workdir)
[08:26:37.804]         {
[08:26:37.804]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:37.804]                 ...future.oldOptions$nwarnings <- NULL
[08:26:37.804]             }
[08:26:37.804]             base::options(...future.oldOptions)
[08:26:37.804]             if (.Platform$OS.type == "windows") {
[08:26:37.804]                 old_names <- names(...future.oldEnvVars)
[08:26:37.804]                 envs <- base::Sys.getenv()
[08:26:37.804]                 names <- names(envs)
[08:26:37.804]                 common <- intersect(names, old_names)
[08:26:37.804]                 added <- setdiff(names, old_names)
[08:26:37.804]                 removed <- setdiff(old_names, names)
[08:26:37.804]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:37.804]                   envs[common]]
[08:26:37.804]                 NAMES <- toupper(changed)
[08:26:37.804]                 args <- list()
[08:26:37.804]                 for (kk in seq_along(NAMES)) {
[08:26:37.804]                   name <- changed[[kk]]
[08:26:37.804]                   NAME <- NAMES[[kk]]
[08:26:37.804]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:37.804]                     next
[08:26:37.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:37.804]                 }
[08:26:37.804]                 NAMES <- toupper(added)
[08:26:37.804]                 for (kk in seq_along(NAMES)) {
[08:26:37.804]                   name <- added[[kk]]
[08:26:37.804]                   NAME <- NAMES[[kk]]
[08:26:37.804]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:37.804]                     next
[08:26:37.804]                   args[[name]] <- ""
[08:26:37.804]                 }
[08:26:37.804]                 NAMES <- toupper(removed)
[08:26:37.804]                 for (kk in seq_along(NAMES)) {
[08:26:37.804]                   name <- removed[[kk]]
[08:26:37.804]                   NAME <- NAMES[[kk]]
[08:26:37.804]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:37.804]                     next
[08:26:37.804]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:37.804]                 }
[08:26:37.804]                 if (length(args) > 0) 
[08:26:37.804]                   base::do.call(base::Sys.setenv, args = args)
[08:26:37.804]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:37.804]             }
[08:26:37.804]             else {
[08:26:37.804]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:37.804]             }
[08:26:37.804]             {
[08:26:37.804]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:37.804]                   0L) {
[08:26:37.804]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:37.804]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:37.804]                   base::options(opts)
[08:26:37.804]                 }
[08:26:37.804]                 {
[08:26:37.804]                   {
[08:26:37.804]                     NULL
[08:26:37.804]                     RNGkind("Mersenne-Twister")
[08:26:37.804]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:37.804]                       inherits = FALSE)
[08:26:37.804]                   }
[08:26:37.804]                   options(future.plan = NULL)
[08:26:37.804]                   if (is.na(NA_character_)) 
[08:26:37.804]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:37.804]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:37.804]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:37.804]                     .init = FALSE)
[08:26:37.804]                 }
[08:26:37.804]             }
[08:26:37.804]         }
[08:26:37.804]     })
[08:26:37.804]     if (TRUE) {
[08:26:37.804]         base::sink(type = "output", split = FALSE)
[08:26:37.804]         if (FALSE) {
[08:26:37.804]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:37.804]         }
[08:26:37.804]         else {
[08:26:37.804]             ...future.result["stdout"] <- base::list(NULL)
[08:26:37.804]         }
[08:26:37.804]         base::close(...future.stdout)
[08:26:37.804]         ...future.stdout <- NULL
[08:26:37.804]     }
[08:26:37.804]     ...future.result$conditions <- ...future.conditions
[08:26:37.804]     ...future.result$finished <- base::Sys.time()
[08:26:37.804]     ...future.result
[08:26:37.804] }
[08:26:37.806] assign_globals() ...
[08:26:37.806] List of 5
[08:26:37.806]  $ ...future.FUN            :function (x, y)  
[08:26:37.806]  $ MoreArgs                 : NULL
[08:26:37.806]  $ ...future.elements_ii    :List of 2
[08:26:37.806]   ..$ :List of 2
[08:26:37.806]   .. ..$ : int 1
[08:26:37.806]   .. ..$ : int 0
[08:26:37.806]   ..$ :List of 2
[08:26:37.806]   .. ..$ : int 0
[08:26:37.806]   .. ..$ : int 1
[08:26:37.806]  $ ...future.seeds_ii       : NULL
[08:26:37.806]  $ ...future.globals.maxSize: NULL
[08:26:37.806]  - attr(*, "where")=List of 5
[08:26:37.806]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:37.806]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:37.806]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:37.806]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:37.806]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:37.806]  - attr(*, "resolved")= logi FALSE
[08:26:37.806]  - attr(*, "total_size")= num 1242
[08:26:37.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:37.806]  - attr(*, "already-done")= logi TRUE
[08:26:37.815] - reassign environment for ‘...future.FUN’
[08:26:37.815] - copied ‘...future.FUN’ to environment
[08:26:37.815] - copied ‘MoreArgs’ to environment
[08:26:37.815] - copied ‘...future.elements_ii’ to environment
[08:26:37.815] - copied ‘...future.seeds_ii’ to environment
[08:26:37.815] - copied ‘...future.globals.maxSize’ to environment
[08:26:37.815] assign_globals() ... done
[08:26:37.816] plan(): Setting new future strategy stack:
[08:26:37.816] List of future strategies:
[08:26:37.816] 1. sequential:
[08:26:37.816]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:37.816]    - tweaked: FALSE
[08:26:37.816]    - call: NULL
[08:26:37.816] plan(): nbrOfWorkers() = 1
[08:26:38.318] plan(): Setting new future strategy stack:
[08:26:38.318] List of future strategies:
[08:26:38.318] 1. multicore:
[08:26:38.318]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:38.318]    - tweaked: FALSE
[08:26:38.318]    - call: plan(strategy)
[08:26:38.320] plan(): nbrOfWorkers() = 1
[08:26:38.320] SequentialFuture started (and completed)
[08:26:38.320] - Launch lazy future ... done
[08:26:38.321] run() for ‘SequentialFuture’ ... done
[08:26:38.321] Created future:
[08:26:38.321] SequentialFuture:
[08:26:38.321] Label: ‘future_mapply-1’
[08:26:38.321] Expression:
[08:26:38.321] {
[08:26:38.321]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:38.321]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:38.321]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:38.321]         on.exit(options(oopts), add = TRUE)
[08:26:38.321]     }
[08:26:38.321]     {
[08:26:38.321]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:38.321]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:38.321]         do.call(mapply, args = args)
[08:26:38.321]     }
[08:26:38.321] }
[08:26:38.321] Lazy evaluation: FALSE
[08:26:38.321] Asynchronous evaluation: FALSE
[08:26:38.321] Local evaluation: TRUE
[08:26:38.321] Environment: R_GlobalEnv
[08:26:38.321] Capture standard output: FALSE
[08:26:38.321] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:38.321] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:38.321] Packages: <none>
[08:26:38.321] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:38.321] Resolved: TRUE
[08:26:38.321] Value: 184 bytes of class ‘list’
[08:26:38.321] Early signaling: FALSE
[08:26:38.321] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:38.321] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:38.322] Chunk #1 of 1 ... DONE
[08:26:38.322] Launching 1 futures (chunks) ... DONE
[08:26:38.322] Resolving 1 futures (chunks) ...
[08:26:38.322] resolve() on list ...
[08:26:38.322]  recursive: 0
[08:26:38.322]  length: 1
[08:26:38.322] 
[08:26:38.323] resolved() for ‘SequentialFuture’ ...
[08:26:38.323] - state: ‘finished’
[08:26:38.323] - run: TRUE
[08:26:38.323] - result: ‘FutureResult’
[08:26:38.323] resolved() for ‘SequentialFuture’ ... done
[08:26:38.323] Future #1
[08:26:38.323] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:38.323] - nx: 1
[08:26:38.323] - relay: TRUE
[08:26:38.323] - stdout: TRUE
[08:26:38.324] - signal: TRUE
[08:26:38.324] - resignal: FALSE
[08:26:38.324] - force: TRUE
[08:26:38.324] - relayed: [n=1] FALSE
[08:26:38.324] - queued futures: [n=1] FALSE
[08:26:38.324]  - until=1
[08:26:38.324]  - relaying element #1
[08:26:38.324] - relayed: [n=1] TRUE
[08:26:38.324] - queued futures: [n=1] TRUE
[08:26:38.324] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:38.324]  length: 0 (resolved future 1)
[08:26:38.325] Relaying remaining futures
[08:26:38.325] signalConditionsASAP(NULL, pos=0) ...
[08:26:38.325] - nx: 1
[08:26:38.325] - relay: TRUE
[08:26:38.325] - stdout: TRUE
[08:26:38.325] - signal: TRUE
[08:26:38.325] - resignal: FALSE
[08:26:38.325] - force: TRUE
[08:26:38.325] - relayed: [n=1] TRUE
[08:26:38.325] - queued futures: [n=1] TRUE
 - flush all
[08:26:38.325] - relayed: [n=1] TRUE
[08:26:38.326] - queued futures: [n=1] TRUE
[08:26:38.326] signalConditionsASAP(NULL, pos=0) ... done
[08:26:38.326] resolve() on list ... DONE
[08:26:38.326]  - Number of value chunks collected: 1
[08:26:38.326] Resolving 1 futures (chunks) ... DONE
[08:26:38.326] Reducing values from 1 chunks ...
[08:26:38.326]  - Number of values collected after concatenation: 2
[08:26:38.326]  - Number of values expected: 2
[08:26:38.326] Reducing values from 1 chunks ... DONE
[08:26:38.326] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[08:26:38.327] future_mapply() ...
[08:26:38.329] Number of chunks: 1
[08:26:38.329] getGlobalsAndPackagesXApply() ...
[08:26:38.329]  - future.globals: TRUE
[08:26:38.329] getGlobalsAndPackages() ...
[08:26:38.329] Searching for globals...
[08:26:38.331] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:38.331] Searching for globals ... DONE
[08:26:38.331] Resolving globals: FALSE
[08:26:38.331] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:38.332] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:38.332] - globals: [1] ‘FUN’
[08:26:38.332] 
[08:26:38.332] getGlobalsAndPackages() ... DONE
[08:26:38.332]  - globals found/used: [n=1] ‘FUN’
[08:26:38.332]  - needed namespaces: [n=0] 
[08:26:38.332] Finding globals ... DONE
[08:26:38.332] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:38.333] List of 2
[08:26:38.333]  $ ...future.FUN:function (x, y)  
[08:26:38.333]  $ MoreArgs     : NULL
[08:26:38.333]  - attr(*, "where")=List of 2
[08:26:38.333]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:38.333]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:38.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:38.333]  - attr(*, "resolved")= logi FALSE
[08:26:38.333]  - attr(*, "total_size")= num NA
[08:26:38.335] Packages to be attached in all futures: [n=0] 
[08:26:38.335] getGlobalsAndPackagesXApply() ... DONE
[08:26:38.336] Number of futures (= number of chunks): 1
[08:26:38.336] Launching 1 futures (chunks) ...
[08:26:38.336] Chunk #1 of 1 ...
[08:26:38.336]  - Finding globals in '...' for chunk #1 ...
[08:26:38.336] getGlobalsAndPackages() ...
[08:26:38.336] Searching for globals...
[08:26:38.337] 
[08:26:38.337] Searching for globals ... DONE
[08:26:38.337] - globals: [0] <none>
[08:26:38.337] getGlobalsAndPackages() ... DONE
[08:26:38.337]    + additional globals found: [n=0] 
[08:26:38.337]    + additional namespaces needed: [n=0] 
[08:26:38.337]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:38.337]  - seeds: <none>
[08:26:38.337]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:38.337] getGlobalsAndPackages() ...
[08:26:38.338] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:38.338] Resolving globals: FALSE
[08:26:38.340] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[08:26:38.341] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:38.341] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:38.341] 
[08:26:38.341] getGlobalsAndPackages() ... DONE
[08:26:38.341] run() for ‘Future’ ...
[08:26:38.341] - state: ‘created’
[08:26:38.341] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:38.343] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:38.343] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:38.343]   - Field: ‘label’
[08:26:38.344]   - Field: ‘local’
[08:26:38.344]   - Field: ‘owner’
[08:26:38.344]   - Field: ‘envir’
[08:26:38.344]   - Field: ‘packages’
[08:26:38.344]   - Field: ‘gc’
[08:26:38.344]   - Field: ‘conditions’
[08:26:38.344]   - Field: ‘expr’
[08:26:38.344]   - Field: ‘uuid’
[08:26:38.344]   - Field: ‘seed’
[08:26:38.344]   - Field: ‘version’
[08:26:38.345]   - Field: ‘result’
[08:26:38.345]   - Field: ‘asynchronous’
[08:26:38.345]   - Field: ‘calls’
[08:26:38.345]   - Field: ‘globals’
[08:26:38.345]   - Field: ‘stdout’
[08:26:38.345]   - Field: ‘earlySignal’
[08:26:38.345]   - Field: ‘lazy’
[08:26:38.345]   - Field: ‘state’
[08:26:38.345] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:38.345] - Launch lazy future ...
[08:26:38.346] Packages needed by the future expression (n = 0): <none>
[08:26:38.346] Packages needed by future strategies (n = 0): <none>
[08:26:38.346] {
[08:26:38.346]     {
[08:26:38.346]         {
[08:26:38.346]             ...future.startTime <- base::Sys.time()
[08:26:38.346]             {
[08:26:38.346]                 {
[08:26:38.346]                   {
[08:26:38.346]                     base::local({
[08:26:38.346]                       has_future <- base::requireNamespace("future", 
[08:26:38.346]                         quietly = TRUE)
[08:26:38.346]                       if (has_future) {
[08:26:38.346]                         ns <- base::getNamespace("future")
[08:26:38.346]                         version <- ns[[".package"]][["version"]]
[08:26:38.346]                         if (is.null(version)) 
[08:26:38.346]                           version <- utils::packageVersion("future")
[08:26:38.346]                       }
[08:26:38.346]                       else {
[08:26:38.346]                         version <- NULL
[08:26:38.346]                       }
[08:26:38.346]                       if (!has_future || version < "1.8.0") {
[08:26:38.346]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:38.346]                           "", base::R.version$version.string), 
[08:26:38.346]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:38.346]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:38.346]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:38.346]                             "release", "version")], collapse = " "), 
[08:26:38.346]                           hostname = base::Sys.info()[["nodename"]])
[08:26:38.346]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:38.346]                           info)
[08:26:38.346]                         info <- base::paste(info, collapse = "; ")
[08:26:38.346]                         if (!has_future) {
[08:26:38.346]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:38.346]                             info)
[08:26:38.346]                         }
[08:26:38.346]                         else {
[08:26:38.346]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:38.346]                             info, version)
[08:26:38.346]                         }
[08:26:38.346]                         base::stop(msg)
[08:26:38.346]                       }
[08:26:38.346]                     })
[08:26:38.346]                   }
[08:26:38.346]                   ...future.strategy.old <- future::plan("list")
[08:26:38.346]                   options(future.plan = NULL)
[08:26:38.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:38.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:38.346]                 }
[08:26:38.346]                 ...future.workdir <- getwd()
[08:26:38.346]             }
[08:26:38.346]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:38.346]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:38.346]         }
[08:26:38.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:38.346]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:38.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:38.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:38.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:38.346]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:38.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:38.346]             base::names(...future.oldOptions))
[08:26:38.346]     }
[08:26:38.346]     if (FALSE) {
[08:26:38.346]     }
[08:26:38.346]     else {
[08:26:38.346]         if (TRUE) {
[08:26:38.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:38.346]                 open = "w")
[08:26:38.346]         }
[08:26:38.346]         else {
[08:26:38.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:38.346]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:38.346]         }
[08:26:38.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:38.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:38.346]             base::sink(type = "output", split = FALSE)
[08:26:38.346]             base::close(...future.stdout)
[08:26:38.346]         }, add = TRUE)
[08:26:38.346]     }
[08:26:38.346]     ...future.frame <- base::sys.nframe()
[08:26:38.346]     ...future.conditions <- base::list()
[08:26:38.346]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:38.346]     if (FALSE) {
[08:26:38.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:38.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:38.346]     }
[08:26:38.346]     ...future.result <- base::tryCatch({
[08:26:38.346]         base::withCallingHandlers({
[08:26:38.346]             ...future.value <- base::withVisible(base::local({
[08:26:38.346]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:38.346]                 if (!identical(...future.globals.maxSize.org, 
[08:26:38.346]                   ...future.globals.maxSize)) {
[08:26:38.346]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:38.346]                   on.exit(options(oopts), add = TRUE)
[08:26:38.346]                 }
[08:26:38.346]                 {
[08:26:38.346]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:38.346]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:38.346]                     USE.NAMES = FALSE)
[08:26:38.346]                   do.call(mapply, args = args)
[08:26:38.346]                 }
[08:26:38.346]             }))
[08:26:38.346]             future::FutureResult(value = ...future.value$value, 
[08:26:38.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:38.346]                   ...future.rng), globalenv = if (FALSE) 
[08:26:38.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:38.346]                     ...future.globalenv.names))
[08:26:38.346]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:38.346]         }, condition = base::local({
[08:26:38.346]             c <- base::c
[08:26:38.346]             inherits <- base::inherits
[08:26:38.346]             invokeRestart <- base::invokeRestart
[08:26:38.346]             length <- base::length
[08:26:38.346]             list <- base::list
[08:26:38.346]             seq.int <- base::seq.int
[08:26:38.346]             signalCondition <- base::signalCondition
[08:26:38.346]             sys.calls <- base::sys.calls
[08:26:38.346]             `[[` <- base::`[[`
[08:26:38.346]             `+` <- base::`+`
[08:26:38.346]             `<<-` <- base::`<<-`
[08:26:38.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:38.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:38.346]                   3L)]
[08:26:38.346]             }
[08:26:38.346]             function(cond) {
[08:26:38.346]                 is_error <- inherits(cond, "error")
[08:26:38.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:38.346]                   NULL)
[08:26:38.346]                 if (is_error) {
[08:26:38.346]                   sessionInformation <- function() {
[08:26:38.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:38.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:38.346]                       search = base::search(), system = base::Sys.info())
[08:26:38.346]                   }
[08:26:38.346]                   ...future.conditions[[length(...future.conditions) + 
[08:26:38.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:38.346]                     cond$call), session = sessionInformation(), 
[08:26:38.346]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:38.346]                   signalCondition(cond)
[08:26:38.346]                 }
[08:26:38.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:38.346]                 "immediateCondition"))) {
[08:26:38.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:38.346]                   ...future.conditions[[length(...future.conditions) + 
[08:26:38.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:38.346]                   if (TRUE && !signal) {
[08:26:38.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:38.346]                     {
[08:26:38.346]                       inherits <- base::inherits
[08:26:38.346]                       invokeRestart <- base::invokeRestart
[08:26:38.346]                       is.null <- base::is.null
[08:26:38.346]                       muffled <- FALSE
[08:26:38.346]                       if (inherits(cond, "message")) {
[08:26:38.346]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:38.346]                         if (muffled) 
[08:26:38.346]                           invokeRestart("muffleMessage")
[08:26:38.346]                       }
[08:26:38.346]                       else if (inherits(cond, "warning")) {
[08:26:38.346]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:38.346]                         if (muffled) 
[08:26:38.346]                           invokeRestart("muffleWarning")
[08:26:38.346]                       }
[08:26:38.346]                       else if (inherits(cond, "condition")) {
[08:26:38.346]                         if (!is.null(pattern)) {
[08:26:38.346]                           computeRestarts <- base::computeRestarts
[08:26:38.346]                           grepl <- base::grepl
[08:26:38.346]                           restarts <- computeRestarts(cond)
[08:26:38.346]                           for (restart in restarts) {
[08:26:38.346]                             name <- restart$name
[08:26:38.346]                             if (is.null(name)) 
[08:26:38.346]                               next
[08:26:38.346]                             if (!grepl(pattern, name)) 
[08:26:38.346]                               next
[08:26:38.346]                             invokeRestart(restart)
[08:26:38.346]                             muffled <- TRUE
[08:26:38.346]                             break
[08:26:38.346]                           }
[08:26:38.346]                         }
[08:26:38.346]                       }
[08:26:38.346]                       invisible(muffled)
[08:26:38.346]                     }
[08:26:38.346]                     muffleCondition(cond, pattern = "^muffle")
[08:26:38.346]                   }
[08:26:38.346]                 }
[08:26:38.346]                 else {
[08:26:38.346]                   if (TRUE) {
[08:26:38.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:38.346]                     {
[08:26:38.346]                       inherits <- base::inherits
[08:26:38.346]                       invokeRestart <- base::invokeRestart
[08:26:38.346]                       is.null <- base::is.null
[08:26:38.346]                       muffled <- FALSE
[08:26:38.346]                       if (inherits(cond, "message")) {
[08:26:38.346]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:38.346]                         if (muffled) 
[08:26:38.346]                           invokeRestart("muffleMessage")
[08:26:38.346]                       }
[08:26:38.346]                       else if (inherits(cond, "warning")) {
[08:26:38.346]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:38.346]                         if (muffled) 
[08:26:38.346]                           invokeRestart("muffleWarning")
[08:26:38.346]                       }
[08:26:38.346]                       else if (inherits(cond, "condition")) {
[08:26:38.346]                         if (!is.null(pattern)) {
[08:26:38.346]                           computeRestarts <- base::computeRestarts
[08:26:38.346]                           grepl <- base::grepl
[08:26:38.346]                           restarts <- computeRestarts(cond)
[08:26:38.346]                           for (restart in restarts) {
[08:26:38.346]                             name <- restart$name
[08:26:38.346]                             if (is.null(name)) 
[08:26:38.346]                               next
[08:26:38.346]                             if (!grepl(pattern, name)) 
[08:26:38.346]                               next
[08:26:38.346]                             invokeRestart(restart)
[08:26:38.346]                             muffled <- TRUE
[08:26:38.346]                             break
[08:26:38.346]                           }
[08:26:38.346]                         }
[08:26:38.346]                       }
[08:26:38.346]                       invisible(muffled)
[08:26:38.346]                     }
[08:26:38.346]                     muffleCondition(cond, pattern = "^muffle")
[08:26:38.346]                   }
[08:26:38.346]                 }
[08:26:38.346]             }
[08:26:38.346]         }))
[08:26:38.346]     }, error = function(ex) {
[08:26:38.346]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:38.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:38.346]                 ...future.rng), started = ...future.startTime, 
[08:26:38.346]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:38.346]             version = "1.8"), class = "FutureResult")
[08:26:38.346]     }, finally = {
[08:26:38.346]         if (!identical(...future.workdir, getwd())) 
[08:26:38.346]             setwd(...future.workdir)
[08:26:38.346]         {
[08:26:38.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:38.346]                 ...future.oldOptions$nwarnings <- NULL
[08:26:38.346]             }
[08:26:38.346]             base::options(...future.oldOptions)
[08:26:38.346]             if (.Platform$OS.type == "windows") {
[08:26:38.346]                 old_names <- names(...future.oldEnvVars)
[08:26:38.346]                 envs <- base::Sys.getenv()
[08:26:38.346]                 names <- names(envs)
[08:26:38.346]                 common <- intersect(names, old_names)
[08:26:38.346]                 added <- setdiff(names, old_names)
[08:26:38.346]                 removed <- setdiff(old_names, names)
[08:26:38.346]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:38.346]                   envs[common]]
[08:26:38.346]                 NAMES <- toupper(changed)
[08:26:38.346]                 args <- list()
[08:26:38.346]                 for (kk in seq_along(NAMES)) {
[08:26:38.346]                   name <- changed[[kk]]
[08:26:38.346]                   NAME <- NAMES[[kk]]
[08:26:38.346]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:38.346]                     next
[08:26:38.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:38.346]                 }
[08:26:38.346]                 NAMES <- toupper(added)
[08:26:38.346]                 for (kk in seq_along(NAMES)) {
[08:26:38.346]                   name <- added[[kk]]
[08:26:38.346]                   NAME <- NAMES[[kk]]
[08:26:38.346]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:38.346]                     next
[08:26:38.346]                   args[[name]] <- ""
[08:26:38.346]                 }
[08:26:38.346]                 NAMES <- toupper(removed)
[08:26:38.346]                 for (kk in seq_along(NAMES)) {
[08:26:38.346]                   name <- removed[[kk]]
[08:26:38.346]                   NAME <- NAMES[[kk]]
[08:26:38.346]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:38.346]                     next
[08:26:38.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:38.346]                 }
[08:26:38.346]                 if (length(args) > 0) 
[08:26:38.346]                   base::do.call(base::Sys.setenv, args = args)
[08:26:38.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:38.346]             }
[08:26:38.346]             else {
[08:26:38.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:38.346]             }
[08:26:38.346]             {
[08:26:38.346]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:38.346]                   0L) {
[08:26:38.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:38.346]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:38.346]                   base::options(opts)
[08:26:38.346]                 }
[08:26:38.346]                 {
[08:26:38.346]                   {
[08:26:38.346]                     NULL
[08:26:38.346]                     RNGkind("Mersenne-Twister")
[08:26:38.346]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:38.346]                       inherits = FALSE)
[08:26:38.346]                   }
[08:26:38.346]                   options(future.plan = NULL)
[08:26:38.346]                   if (is.na(NA_character_)) 
[08:26:38.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:38.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:38.346]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:38.346]                     .init = FALSE)
[08:26:38.346]                 }
[08:26:38.346]             }
[08:26:38.346]         }
[08:26:38.346]     })
[08:26:38.346]     if (TRUE) {
[08:26:38.346]         base::sink(type = "output", split = FALSE)
[08:26:38.346]         if (TRUE) {
[08:26:38.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:38.346]         }
[08:26:38.346]         else {
[08:26:38.346]             ...future.result["stdout"] <- base::list(NULL)
[08:26:38.346]         }
[08:26:38.346]         base::close(...future.stdout)
[08:26:38.346]         ...future.stdout <- NULL
[08:26:38.346]     }
[08:26:38.346]     ...future.result$conditions <- ...future.conditions
[08:26:38.346]     ...future.result$finished <- base::Sys.time()
[08:26:38.346]     ...future.result
[08:26:38.346] }
[08:26:38.348] assign_globals() ...
[08:26:38.348] List of 5
[08:26:38.348]  $ ...future.FUN            :function (x, y)  
[08:26:38.348]  $ MoreArgs                 : NULL
[08:26:38.348]  $ ...future.elements_ii    :List of 2
[08:26:38.348]   ..$ :List of 2
[08:26:38.348]   .. ..$ : int 1
[08:26:38.348]   .. ..$ : int 0
[08:26:38.348]   ..$ :List of 2
[08:26:38.348]   .. ..$ : int 0
[08:26:38.348]   .. ..$ : int 1
[08:26:38.348]  $ ...future.seeds_ii       : NULL
[08:26:38.348]  $ ...future.globals.maxSize: NULL
[08:26:38.348]  - attr(*, "where")=List of 5
[08:26:38.348]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:38.348]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:38.348]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:38.348]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:38.348]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:38.348]  - attr(*, "resolved")= logi FALSE
[08:26:38.348]  - attr(*, "total_size")= num 1242
[08:26:38.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:38.348]  - attr(*, "already-done")= logi TRUE
[08:26:38.354] - reassign environment for ‘...future.FUN’
[08:26:38.354] - copied ‘...future.FUN’ to environment
[08:26:38.354] - copied ‘MoreArgs’ to environment
[08:26:38.354] - copied ‘...future.elements_ii’ to environment
[08:26:38.354] - copied ‘...future.seeds_ii’ to environment
[08:26:38.355] - copied ‘...future.globals.maxSize’ to environment
[08:26:38.355] assign_globals() ... done
[08:26:38.355] plan(): Setting new future strategy stack:
[08:26:38.355] List of future strategies:
[08:26:38.355] 1. sequential:
[08:26:38.355]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:38.355]    - tweaked: FALSE
[08:26:38.355]    - call: NULL
[08:26:38.355] plan(): nbrOfWorkers() = 1
[08:26:38.857] plan(): Setting new future strategy stack:
[08:26:38.858] List of future strategies:
[08:26:38.858] 1. multicore:
[08:26:38.858]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:38.858]    - tweaked: FALSE
[08:26:38.858]    - call: plan(strategy)
[08:26:38.859] plan(): nbrOfWorkers() = 1
[08:26:38.860] SequentialFuture started (and completed)
[08:26:38.860] - Launch lazy future ... done
[08:26:38.860] run() for ‘SequentialFuture’ ... done
[08:26:38.860] Created future:
[08:26:38.860] SequentialFuture:
[08:26:38.860] Label: ‘future_mapply-1’
[08:26:38.860] Expression:
[08:26:38.860] {
[08:26:38.860]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:38.860]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:38.860]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:38.860]         on.exit(options(oopts), add = TRUE)
[08:26:38.860]     }
[08:26:38.860]     {
[08:26:38.860]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:38.860]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:38.860]         do.call(mapply, args = args)
[08:26:38.860]     }
[08:26:38.860] }
[08:26:38.860] Lazy evaluation: FALSE
[08:26:38.860] Asynchronous evaluation: FALSE
[08:26:38.860] Local evaluation: TRUE
[08:26:38.860] Environment: R_GlobalEnv
[08:26:38.860] Capture standard output: TRUE
[08:26:38.860] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:38.860] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:38.860] Packages: <none>
[08:26:38.860] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:38.860] Resolved: TRUE
[08:26:38.860] Value: 184 bytes of class ‘list’
[08:26:38.860] Early signaling: FALSE
[08:26:38.860] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:38.860] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:38.861] Chunk #1 of 1 ... DONE
[08:26:38.861] Launching 1 futures (chunks) ... DONE
[08:26:38.861] Resolving 1 futures (chunks) ...
[08:26:38.861] resolve() on list ...
[08:26:38.861]  recursive: 0
[08:26:38.862]  length: 1
[08:26:38.862] 
[08:26:38.862] resolved() for ‘SequentialFuture’ ...
[08:26:38.862] - state: ‘finished’
[08:26:38.862] - run: TRUE
[08:26:38.862] - result: ‘FutureResult’
[08:26:38.862] resolved() for ‘SequentialFuture’ ... done
[08:26:38.862] Future #1
[08:26:38.862] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:38.862] - nx: 1
[08:26:38.863] - relay: TRUE
[08:26:38.863] - stdout: TRUE
[08:26:38.863] - signal: TRUE
[08:26:38.863] - resignal: FALSE
[08:26:38.863] - force: TRUE
[08:26:38.863] - relayed: [n=1] FALSE
[08:26:38.863] - queued futures: [n=1] FALSE
[08:26:38.863]  - until=1
[08:26:38.863]  - relaying element #1
[08:26:38.863] - relayed: [n=1] TRUE
[08:26:38.864] - queued futures: [n=1] TRUE
[08:26:38.864] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:38.864]  length: 0 (resolved future 1)
[08:26:38.864] Relaying remaining futures
[08:26:38.864] signalConditionsASAP(NULL, pos=0) ...
[08:26:38.864] - nx: 1
[08:26:38.864] - relay: TRUE
[08:26:38.864] - stdout: TRUE
[08:26:38.864] - signal: TRUE
[08:26:38.864] - resignal: FALSE
[08:26:38.864] - force: TRUE
[08:26:38.864] - relayed: [n=1] TRUE
[08:26:38.865] - queued futures: [n=1] TRUE
 - flush all
[08:26:38.865] - relayed: [n=1] TRUE
[08:26:38.865] - queued futures: [n=1] TRUE
[08:26:38.865] signalConditionsASAP(NULL, pos=0) ... done
[08:26:38.865] resolve() on list ... DONE
[08:26:38.865]  - Number of value chunks collected: 1
[08:26:38.865] Resolving 1 futures (chunks) ... DONE
[08:26:38.865] Reducing values from 1 chunks ...
[08:26:38.865]  - Number of values collected after concatenation: 2
[08:26:38.865]  - Number of values expected: 2
[08:26:38.866] Reducing values from 1 chunks ... DONE
[08:26:38.866] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[08:26:38.866] future_mapply() ...
[08:26:38.870] Number of chunks: 1
[08:26:38.870] getGlobalsAndPackagesXApply() ...
[08:26:38.870]  - future.globals: TRUE
[08:26:38.870] getGlobalsAndPackages() ...
[08:26:38.870] Searching for globals...
[08:26:38.872] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:38.872] Searching for globals ... DONE
[08:26:38.872] Resolving globals: FALSE
[08:26:38.872] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:38.873] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:38.873] - globals: [1] ‘FUN’
[08:26:38.873] 
[08:26:38.873] getGlobalsAndPackages() ... DONE
[08:26:38.873]  - globals found/used: [n=1] ‘FUN’
[08:26:38.873]  - needed namespaces: [n=0] 
[08:26:38.873] Finding globals ... DONE
[08:26:38.874] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:38.874] List of 2
[08:26:38.874]  $ ...future.FUN:function (x, y)  
[08:26:38.874]  $ MoreArgs     : NULL
[08:26:38.874]  - attr(*, "where")=List of 2
[08:26:38.874]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:38.874]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:38.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:38.874]  - attr(*, "resolved")= logi FALSE
[08:26:38.874]  - attr(*, "total_size")= num NA
[08:26:38.876] Packages to be attached in all futures: [n=0] 
[08:26:38.876] getGlobalsAndPackagesXApply() ... DONE
[08:26:38.877] Number of futures (= number of chunks): 1
[08:26:38.877] Launching 1 futures (chunks) ...
[08:26:38.877] Chunk #1 of 1 ...
[08:26:38.877]  - Finding globals in '...' for chunk #1 ...
[08:26:38.877] getGlobalsAndPackages() ...
[08:26:38.877] Searching for globals...
[08:26:38.877] 
[08:26:38.878] Searching for globals ... DONE
[08:26:38.878] - globals: [0] <none>
[08:26:38.878] getGlobalsAndPackages() ... DONE
[08:26:38.878]    + additional globals found: [n=0] 
[08:26:38.878]    + additional namespaces needed: [n=0] 
[08:26:38.878]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:38.878]  - seeds: <none>
[08:26:38.878]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:38.878] getGlobalsAndPackages() ...
[08:26:38.878] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:38.879] Resolving globals: FALSE
[08:26:38.879] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[08:26:38.879] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:38.880] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:38.880] 
[08:26:38.880] getGlobalsAndPackages() ... DONE
[08:26:38.880] run() for ‘Future’ ...
[08:26:38.880] - state: ‘created’
[08:26:38.880] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:38.882] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:38.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:38.882]   - Field: ‘label’
[08:26:38.882]   - Field: ‘local’
[08:26:38.883]   - Field: ‘owner’
[08:26:38.883]   - Field: ‘envir’
[08:26:38.883]   - Field: ‘packages’
[08:26:38.883]   - Field: ‘gc’
[08:26:38.883]   - Field: ‘conditions’
[08:26:38.883]   - Field: ‘expr’
[08:26:38.883]   - Field: ‘uuid’
[08:26:38.883]   - Field: ‘seed’
[08:26:38.883]   - Field: ‘version’
[08:26:38.883]   - Field: ‘result’
[08:26:38.883]   - Field: ‘asynchronous’
[08:26:38.884]   - Field: ‘calls’
[08:26:38.884]   - Field: ‘globals’
[08:26:38.884]   - Field: ‘stdout’
[08:26:38.884]   - Field: ‘earlySignal’
[08:26:38.884]   - Field: ‘lazy’
[08:26:38.884]   - Field: ‘state’
[08:26:38.884] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:38.884] - Launch lazy future ...
[08:26:38.884] Packages needed by the future expression (n = 0): <none>
[08:26:38.884] Packages needed by future strategies (n = 0): <none>
[08:26:38.885] {
[08:26:38.885]     {
[08:26:38.885]         {
[08:26:38.885]             ...future.startTime <- base::Sys.time()
[08:26:38.885]             {
[08:26:38.885]                 {
[08:26:38.885]                   {
[08:26:38.885]                     base::local({
[08:26:38.885]                       has_future <- base::requireNamespace("future", 
[08:26:38.885]                         quietly = TRUE)
[08:26:38.885]                       if (has_future) {
[08:26:38.885]                         ns <- base::getNamespace("future")
[08:26:38.885]                         version <- ns[[".package"]][["version"]]
[08:26:38.885]                         if (is.null(version)) 
[08:26:38.885]                           version <- utils::packageVersion("future")
[08:26:38.885]                       }
[08:26:38.885]                       else {
[08:26:38.885]                         version <- NULL
[08:26:38.885]                       }
[08:26:38.885]                       if (!has_future || version < "1.8.0") {
[08:26:38.885]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:38.885]                           "", base::R.version$version.string), 
[08:26:38.885]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:38.885]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:38.885]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:38.885]                             "release", "version")], collapse = " "), 
[08:26:38.885]                           hostname = base::Sys.info()[["nodename"]])
[08:26:38.885]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:38.885]                           info)
[08:26:38.885]                         info <- base::paste(info, collapse = "; ")
[08:26:38.885]                         if (!has_future) {
[08:26:38.885]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:38.885]                             info)
[08:26:38.885]                         }
[08:26:38.885]                         else {
[08:26:38.885]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:38.885]                             info, version)
[08:26:38.885]                         }
[08:26:38.885]                         base::stop(msg)
[08:26:38.885]                       }
[08:26:38.885]                     })
[08:26:38.885]                   }
[08:26:38.885]                   ...future.strategy.old <- future::plan("list")
[08:26:38.885]                   options(future.plan = NULL)
[08:26:38.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:38.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:38.885]                 }
[08:26:38.885]                 ...future.workdir <- getwd()
[08:26:38.885]             }
[08:26:38.885]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:38.885]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:38.885]         }
[08:26:38.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:38.885]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:38.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:38.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:38.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:38.885]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:38.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:38.885]             base::names(...future.oldOptions))
[08:26:38.885]     }
[08:26:38.885]     if (TRUE) {
[08:26:38.885]     }
[08:26:38.885]     else {
[08:26:38.885]         if (NA) {
[08:26:38.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:38.885]                 open = "w")
[08:26:38.885]         }
[08:26:38.885]         else {
[08:26:38.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:38.885]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:38.885]         }
[08:26:38.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:38.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:38.885]             base::sink(type = "output", split = FALSE)
[08:26:38.885]             base::close(...future.stdout)
[08:26:38.885]         }, add = TRUE)
[08:26:38.885]     }
[08:26:38.885]     ...future.frame <- base::sys.nframe()
[08:26:38.885]     ...future.conditions <- base::list()
[08:26:38.885]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:38.885]     if (FALSE) {
[08:26:38.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:38.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:38.885]     }
[08:26:38.885]     ...future.result <- base::tryCatch({
[08:26:38.885]         base::withCallingHandlers({
[08:26:38.885]             ...future.value <- base::withVisible(base::local({
[08:26:38.885]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:38.885]                 if (!identical(...future.globals.maxSize.org, 
[08:26:38.885]                   ...future.globals.maxSize)) {
[08:26:38.885]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:38.885]                   on.exit(options(oopts), add = TRUE)
[08:26:38.885]                 }
[08:26:38.885]                 {
[08:26:38.885]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:38.885]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:38.885]                     USE.NAMES = FALSE)
[08:26:38.885]                   do.call(mapply, args = args)
[08:26:38.885]                 }
[08:26:38.885]             }))
[08:26:38.885]             future::FutureResult(value = ...future.value$value, 
[08:26:38.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:38.885]                   ...future.rng), globalenv = if (FALSE) 
[08:26:38.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:38.885]                     ...future.globalenv.names))
[08:26:38.885]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:38.885]         }, condition = base::local({
[08:26:38.885]             c <- base::c
[08:26:38.885]             inherits <- base::inherits
[08:26:38.885]             invokeRestart <- base::invokeRestart
[08:26:38.885]             length <- base::length
[08:26:38.885]             list <- base::list
[08:26:38.885]             seq.int <- base::seq.int
[08:26:38.885]             signalCondition <- base::signalCondition
[08:26:38.885]             sys.calls <- base::sys.calls
[08:26:38.885]             `[[` <- base::`[[`
[08:26:38.885]             `+` <- base::`+`
[08:26:38.885]             `<<-` <- base::`<<-`
[08:26:38.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:38.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:38.885]                   3L)]
[08:26:38.885]             }
[08:26:38.885]             function(cond) {
[08:26:38.885]                 is_error <- inherits(cond, "error")
[08:26:38.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:38.885]                   NULL)
[08:26:38.885]                 if (is_error) {
[08:26:38.885]                   sessionInformation <- function() {
[08:26:38.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:38.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:38.885]                       search = base::search(), system = base::Sys.info())
[08:26:38.885]                   }
[08:26:38.885]                   ...future.conditions[[length(...future.conditions) + 
[08:26:38.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:38.885]                     cond$call), session = sessionInformation(), 
[08:26:38.885]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:38.885]                   signalCondition(cond)
[08:26:38.885]                 }
[08:26:38.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:38.885]                 "immediateCondition"))) {
[08:26:38.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:38.885]                   ...future.conditions[[length(...future.conditions) + 
[08:26:38.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:38.885]                   if (TRUE && !signal) {
[08:26:38.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:38.885]                     {
[08:26:38.885]                       inherits <- base::inherits
[08:26:38.885]                       invokeRestart <- base::invokeRestart
[08:26:38.885]                       is.null <- base::is.null
[08:26:38.885]                       muffled <- FALSE
[08:26:38.885]                       if (inherits(cond, "message")) {
[08:26:38.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:38.885]                         if (muffled) 
[08:26:38.885]                           invokeRestart("muffleMessage")
[08:26:38.885]                       }
[08:26:38.885]                       else if (inherits(cond, "warning")) {
[08:26:38.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:38.885]                         if (muffled) 
[08:26:38.885]                           invokeRestart("muffleWarning")
[08:26:38.885]                       }
[08:26:38.885]                       else if (inherits(cond, "condition")) {
[08:26:38.885]                         if (!is.null(pattern)) {
[08:26:38.885]                           computeRestarts <- base::computeRestarts
[08:26:38.885]                           grepl <- base::grepl
[08:26:38.885]                           restarts <- computeRestarts(cond)
[08:26:38.885]                           for (restart in restarts) {
[08:26:38.885]                             name <- restart$name
[08:26:38.885]                             if (is.null(name)) 
[08:26:38.885]                               next
[08:26:38.885]                             if (!grepl(pattern, name)) 
[08:26:38.885]                               next
[08:26:38.885]                             invokeRestart(restart)
[08:26:38.885]                             muffled <- TRUE
[08:26:38.885]                             break
[08:26:38.885]                           }
[08:26:38.885]                         }
[08:26:38.885]                       }
[08:26:38.885]                       invisible(muffled)
[08:26:38.885]                     }
[08:26:38.885]                     muffleCondition(cond, pattern = "^muffle")
[08:26:38.885]                   }
[08:26:38.885]                 }
[08:26:38.885]                 else {
[08:26:38.885]                   if (TRUE) {
[08:26:38.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:38.885]                     {
[08:26:38.885]                       inherits <- base::inherits
[08:26:38.885]                       invokeRestart <- base::invokeRestart
[08:26:38.885]                       is.null <- base::is.null
[08:26:38.885]                       muffled <- FALSE
[08:26:38.885]                       if (inherits(cond, "message")) {
[08:26:38.885]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:38.885]                         if (muffled) 
[08:26:38.885]                           invokeRestart("muffleMessage")
[08:26:38.885]                       }
[08:26:38.885]                       else if (inherits(cond, "warning")) {
[08:26:38.885]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:38.885]                         if (muffled) 
[08:26:38.885]                           invokeRestart("muffleWarning")
[08:26:38.885]                       }
[08:26:38.885]                       else if (inherits(cond, "condition")) {
[08:26:38.885]                         if (!is.null(pattern)) {
[08:26:38.885]                           computeRestarts <- base::computeRestarts
[08:26:38.885]                           grepl <- base::grepl
[08:26:38.885]                           restarts <- computeRestarts(cond)
[08:26:38.885]                           for (restart in restarts) {
[08:26:38.885]                             name <- restart$name
[08:26:38.885]                             if (is.null(name)) 
[08:26:38.885]                               next
[08:26:38.885]                             if (!grepl(pattern, name)) 
[08:26:38.885]                               next
[08:26:38.885]                             invokeRestart(restart)
[08:26:38.885]                             muffled <- TRUE
[08:26:38.885]                             break
[08:26:38.885]                           }
[08:26:38.885]                         }
[08:26:38.885]                       }
[08:26:38.885]                       invisible(muffled)
[08:26:38.885]                     }
[08:26:38.885]                     muffleCondition(cond, pattern = "^muffle")
[08:26:38.885]                   }
[08:26:38.885]                 }
[08:26:38.885]             }
[08:26:38.885]         }))
[08:26:38.885]     }, error = function(ex) {
[08:26:38.885]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:38.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:38.885]                 ...future.rng), started = ...future.startTime, 
[08:26:38.885]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:38.885]             version = "1.8"), class = "FutureResult")
[08:26:38.885]     }, finally = {
[08:26:38.885]         if (!identical(...future.workdir, getwd())) 
[08:26:38.885]             setwd(...future.workdir)
[08:26:38.885]         {
[08:26:38.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:38.885]                 ...future.oldOptions$nwarnings <- NULL
[08:26:38.885]             }
[08:26:38.885]             base::options(...future.oldOptions)
[08:26:38.885]             if (.Platform$OS.type == "windows") {
[08:26:38.885]                 old_names <- names(...future.oldEnvVars)
[08:26:38.885]                 envs <- base::Sys.getenv()
[08:26:38.885]                 names <- names(envs)
[08:26:38.885]                 common <- intersect(names, old_names)
[08:26:38.885]                 added <- setdiff(names, old_names)
[08:26:38.885]                 removed <- setdiff(old_names, names)
[08:26:38.885]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:38.885]                   envs[common]]
[08:26:38.885]                 NAMES <- toupper(changed)
[08:26:38.885]                 args <- list()
[08:26:38.885]                 for (kk in seq_along(NAMES)) {
[08:26:38.885]                   name <- changed[[kk]]
[08:26:38.885]                   NAME <- NAMES[[kk]]
[08:26:38.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:38.885]                     next
[08:26:38.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:38.885]                 }
[08:26:38.885]                 NAMES <- toupper(added)
[08:26:38.885]                 for (kk in seq_along(NAMES)) {
[08:26:38.885]                   name <- added[[kk]]
[08:26:38.885]                   NAME <- NAMES[[kk]]
[08:26:38.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:38.885]                     next
[08:26:38.885]                   args[[name]] <- ""
[08:26:38.885]                 }
[08:26:38.885]                 NAMES <- toupper(removed)
[08:26:38.885]                 for (kk in seq_along(NAMES)) {
[08:26:38.885]                   name <- removed[[kk]]
[08:26:38.885]                   NAME <- NAMES[[kk]]
[08:26:38.885]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:38.885]                     next
[08:26:38.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:38.885]                 }
[08:26:38.885]                 if (length(args) > 0) 
[08:26:38.885]                   base::do.call(base::Sys.setenv, args = args)
[08:26:38.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:38.885]             }
[08:26:38.885]             else {
[08:26:38.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:38.885]             }
[08:26:38.885]             {
[08:26:38.885]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:38.885]                   0L) {
[08:26:38.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:38.885]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:38.885]                   base::options(opts)
[08:26:38.885]                 }
[08:26:38.885]                 {
[08:26:38.885]                   {
[08:26:38.885]                     NULL
[08:26:38.885]                     RNGkind("Mersenne-Twister")
[08:26:38.885]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:38.885]                       inherits = FALSE)
[08:26:38.885]                   }
[08:26:38.885]                   options(future.plan = NULL)
[08:26:38.885]                   if (is.na(NA_character_)) 
[08:26:38.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:38.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:38.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:38.885]                     .init = FALSE)
[08:26:38.885]                 }
[08:26:38.885]             }
[08:26:38.885]         }
[08:26:38.885]     })
[08:26:38.885]     if (FALSE) {
[08:26:38.885]         base::sink(type = "output", split = FALSE)
[08:26:38.885]         if (NA) {
[08:26:38.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:38.885]         }
[08:26:38.885]         else {
[08:26:38.885]             ...future.result["stdout"] <- base::list(NULL)
[08:26:38.885]         }
[08:26:38.885]         base::close(...future.stdout)
[08:26:38.885]         ...future.stdout <- NULL
[08:26:38.885]     }
[08:26:38.885]     ...future.result$conditions <- ...future.conditions
[08:26:38.885]     ...future.result$finished <- base::Sys.time()
[08:26:38.885]     ...future.result
[08:26:38.885] }
[08:26:38.887] assign_globals() ...
[08:26:38.887] List of 5
[08:26:38.887]  $ ...future.FUN            :function (x, y)  
[08:26:38.887]  $ MoreArgs                 : NULL
[08:26:38.887]  $ ...future.elements_ii    :List of 2
[08:26:38.887]   ..$ :List of 2
[08:26:38.887]   .. ..$ : int 1
[08:26:38.887]   .. ..$ : int 0
[08:26:38.887]   ..$ :List of 2
[08:26:38.887]   .. ..$ : int 0
[08:26:38.887]   .. ..$ : int 1
[08:26:38.887]  $ ...future.seeds_ii       : NULL
[08:26:38.887]  $ ...future.globals.maxSize: NULL
[08:26:38.887]  - attr(*, "where")=List of 5
[08:26:38.887]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:38.887]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:38.887]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:38.887]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:38.887]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:38.887]  - attr(*, "resolved")= logi FALSE
[08:26:38.887]  - attr(*, "total_size")= num 1242
[08:26:38.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:38.887]  - attr(*, "already-done")= logi TRUE
[08:26:38.893] - reassign environment for ‘...future.FUN’
[08:26:38.893] - copied ‘...future.FUN’ to environment
[08:26:38.893] - copied ‘MoreArgs’ to environment
[08:26:38.893] - copied ‘...future.elements_ii’ to environment
[08:26:38.895] - copied ‘...future.seeds_ii’ to environment
[08:26:38.895] - copied ‘...future.globals.maxSize’ to environment
[08:26:38.896] assign_globals() ... done
[08:26:38.896] plan(): Setting new future strategy stack:
[08:26:38.896] List of future strategies:
[08:26:38.896] 1. sequential:
[08:26:38.896]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:38.896]    - tweaked: FALSE
[08:26:38.896]    - call: NULL
[08:26:38.896] plan(): nbrOfWorkers() = 1
[08:26:39.398] plan(): Setting new future strategy stack:
[08:26:39.398] List of future strategies:
[08:26:39.398] 1. multicore:
[08:26:39.398]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:39.398]    - tweaked: FALSE
[08:26:39.398]    - call: plan(strategy)
[08:26:39.400] plan(): nbrOfWorkers() = 1
[08:26:39.400] SequentialFuture started (and completed)
[08:26:39.401] - Launch lazy future ... done
[08:26:39.401] run() for ‘SequentialFuture’ ... done
[08:26:39.401] Created future:
[08:26:39.401] SequentialFuture:
[08:26:39.401] Label: ‘future_mapply-1’
[08:26:39.401] Expression:
[08:26:39.401] {
[08:26:39.401]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:39.401]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:39.401]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:39.401]         on.exit(options(oopts), add = TRUE)
[08:26:39.401]     }
[08:26:39.401]     {
[08:26:39.401]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:39.401]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:39.401]         do.call(mapply, args = args)
[08:26:39.401]     }
[08:26:39.401] }
[08:26:39.401] Lazy evaluation: FALSE
[08:26:39.401] Asynchronous evaluation: FALSE
[08:26:39.401] Local evaluation: TRUE
[08:26:39.401] Environment: R_GlobalEnv
[08:26:39.401] Capture standard output: NA
[08:26:39.401] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:39.401] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:39.401] Packages: <none>
[08:26:39.401] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:39.401] Resolved: TRUE
[08:26:39.401] Value: 184 bytes of class ‘list’
[08:26:39.401] Early signaling: FALSE
[08:26:39.401] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:39.401] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:39.402] Chunk #1 of 1 ... DONE
[08:26:39.402] Launching 1 futures (chunks) ... DONE
[08:26:39.402] Resolving 1 futures (chunks) ...
[08:26:39.402] resolve() on list ...
[08:26:39.402]  recursive: 0
[08:26:39.402]  length: 1
[08:26:39.402] 
[08:26:39.402] resolved() for ‘SequentialFuture’ ...
[08:26:39.403] - state: ‘finished’
[08:26:39.403] - run: TRUE
[08:26:39.403] - result: ‘FutureResult’
[08:26:39.403] resolved() for ‘SequentialFuture’ ... done
[08:26:39.403] Future #1
[08:26:39.403] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:39.403] - nx: 1
[08:26:39.403] - relay: TRUE
[08:26:39.403] - stdout: TRUE
[08:26:39.403] - signal: TRUE
[08:26:39.403] - resignal: FALSE
[08:26:39.404] - force: TRUE
[08:26:39.404] - relayed: [n=1] FALSE
[08:26:39.404] - queued futures: [n=1] FALSE
[08:26:39.404]  - until=1
[08:26:39.404]  - relaying element #1
[08:26:39.404] - relayed: [n=1] TRUE
[08:26:39.404] - queued futures: [n=1] TRUE
[08:26:39.404] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:39.404]  length: 0 (resolved future 1)
[08:26:39.404] Relaying remaining futures
[08:26:39.405] signalConditionsASAP(NULL, pos=0) ...
[08:26:39.405] - nx: 1
[08:26:39.405] - relay: TRUE
[08:26:39.405] - stdout: TRUE
[08:26:39.405] - signal: TRUE
[08:26:39.405] - resignal: FALSE
[08:26:39.405] - force: TRUE
[08:26:39.405] - relayed: [n=1] TRUE
[08:26:39.405] - queued futures: [n=1] TRUE
 - flush all
[08:26:39.405] - relayed: [n=1] TRUE
[08:26:39.405] - queued futures: [n=1] TRUE
[08:26:39.405] signalConditionsASAP(NULL, pos=0) ... done
[08:26:39.406] resolve() on list ... DONE
[08:26:39.406]  - Number of value chunks collected: 1
[08:26:39.406] Resolving 1 futures (chunks) ... DONE
[08:26:39.406] Reducing values from 1 chunks ...
[08:26:39.406]  - Number of values collected after concatenation: 2
[08:26:39.406]  - Number of values expected: 2
[08:26:39.406] Reducing values from 1 chunks ... DONE
[08:26:39.406] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[08:26:39.407] plan(): Setting new future strategy stack:
[08:26:39.407] List of future strategies:
[08:26:39.407] 1. multisession:
[08:26:39.407]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:39.407]    - tweaked: FALSE
[08:26:39.407]    - call: plan(strategy)
[08:26:39.407] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:26:39.407] multisession:
[08:26:39.407] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:39.407] - tweaked: FALSE
[08:26:39.407] - call: plan(strategy)
[08:26:39.409] getGlobalsAndPackages() ...
[08:26:39.409] Not searching for globals
[08:26:39.409] - globals: [0] <none>
[08:26:39.409] getGlobalsAndPackages() ... DONE
[08:26:39.410] Packages needed by the future expression (n = 0): <none>
[08:26:39.410] Packages needed by future strategies (n = 0): <none>
[08:26:39.410] {
[08:26:39.410]     {
[08:26:39.410]         {
[08:26:39.410]             ...future.startTime <- base::Sys.time()
[08:26:39.410]             {
[08:26:39.410]                 {
[08:26:39.410]                   {
[08:26:39.410]                     base::local({
[08:26:39.410]                       has_future <- base::requireNamespace("future", 
[08:26:39.410]                         quietly = TRUE)
[08:26:39.410]                       if (has_future) {
[08:26:39.410]                         ns <- base::getNamespace("future")
[08:26:39.410]                         version <- ns[[".package"]][["version"]]
[08:26:39.410]                         if (is.null(version)) 
[08:26:39.410]                           version <- utils::packageVersion("future")
[08:26:39.410]                       }
[08:26:39.410]                       else {
[08:26:39.410]                         version <- NULL
[08:26:39.410]                       }
[08:26:39.410]                       if (!has_future || version < "1.8.0") {
[08:26:39.410]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:39.410]                           "", base::R.version$version.string), 
[08:26:39.410]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:39.410]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:39.410]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:39.410]                             "release", "version")], collapse = " "), 
[08:26:39.410]                           hostname = base::Sys.info()[["nodename"]])
[08:26:39.410]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:39.410]                           info)
[08:26:39.410]                         info <- base::paste(info, collapse = "; ")
[08:26:39.410]                         if (!has_future) {
[08:26:39.410]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:39.410]                             info)
[08:26:39.410]                         }
[08:26:39.410]                         else {
[08:26:39.410]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:39.410]                             info, version)
[08:26:39.410]                         }
[08:26:39.410]                         base::stop(msg)
[08:26:39.410]                       }
[08:26:39.410]                     })
[08:26:39.410]                   }
[08:26:39.410]                   ...future.strategy.old <- future::plan("list")
[08:26:39.410]                   options(future.plan = NULL)
[08:26:39.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:39.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:39.410]                 }
[08:26:39.410]                 ...future.workdir <- getwd()
[08:26:39.410]             }
[08:26:39.410]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:39.410]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:39.410]         }
[08:26:39.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:39.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:39.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:39.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:39.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:39.410]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:39.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:39.410]             base::names(...future.oldOptions))
[08:26:39.410]     }
[08:26:39.410]     if (FALSE) {
[08:26:39.410]     }
[08:26:39.410]     else {
[08:26:39.410]         if (TRUE) {
[08:26:39.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:39.410]                 open = "w")
[08:26:39.410]         }
[08:26:39.410]         else {
[08:26:39.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:39.410]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:39.410]         }
[08:26:39.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:39.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:39.410]             base::sink(type = "output", split = FALSE)
[08:26:39.410]             base::close(...future.stdout)
[08:26:39.410]         }, add = TRUE)
[08:26:39.410]     }
[08:26:39.410]     ...future.frame <- base::sys.nframe()
[08:26:39.410]     ...future.conditions <- base::list()
[08:26:39.410]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:39.410]     if (FALSE) {
[08:26:39.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:39.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:39.410]     }
[08:26:39.410]     ...future.result <- base::tryCatch({
[08:26:39.410]         base::withCallingHandlers({
[08:26:39.410]             ...future.value <- base::withVisible(base::local(NA))
[08:26:39.410]             future::FutureResult(value = ...future.value$value, 
[08:26:39.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:39.410]                   ...future.rng), globalenv = if (FALSE) 
[08:26:39.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:39.410]                     ...future.globalenv.names))
[08:26:39.410]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:39.410]         }, condition = base::local({
[08:26:39.410]             c <- base::c
[08:26:39.410]             inherits <- base::inherits
[08:26:39.410]             invokeRestart <- base::invokeRestart
[08:26:39.410]             length <- base::length
[08:26:39.410]             list <- base::list
[08:26:39.410]             seq.int <- base::seq.int
[08:26:39.410]             signalCondition <- base::signalCondition
[08:26:39.410]             sys.calls <- base::sys.calls
[08:26:39.410]             `[[` <- base::`[[`
[08:26:39.410]             `+` <- base::`+`
[08:26:39.410]             `<<-` <- base::`<<-`
[08:26:39.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:39.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:39.410]                   3L)]
[08:26:39.410]             }
[08:26:39.410]             function(cond) {
[08:26:39.410]                 is_error <- inherits(cond, "error")
[08:26:39.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:39.410]                   NULL)
[08:26:39.410]                 if (is_error) {
[08:26:39.410]                   sessionInformation <- function() {
[08:26:39.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:39.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:39.410]                       search = base::search(), system = base::Sys.info())
[08:26:39.410]                   }
[08:26:39.410]                   ...future.conditions[[length(...future.conditions) + 
[08:26:39.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:39.410]                     cond$call), session = sessionInformation(), 
[08:26:39.410]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:39.410]                   signalCondition(cond)
[08:26:39.410]                 }
[08:26:39.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:39.410]                 "immediateCondition"))) {
[08:26:39.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:39.410]                   ...future.conditions[[length(...future.conditions) + 
[08:26:39.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:39.410]                   if (TRUE && !signal) {
[08:26:39.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:39.410]                     {
[08:26:39.410]                       inherits <- base::inherits
[08:26:39.410]                       invokeRestart <- base::invokeRestart
[08:26:39.410]                       is.null <- base::is.null
[08:26:39.410]                       muffled <- FALSE
[08:26:39.410]                       if (inherits(cond, "message")) {
[08:26:39.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:39.410]                         if (muffled) 
[08:26:39.410]                           invokeRestart("muffleMessage")
[08:26:39.410]                       }
[08:26:39.410]                       else if (inherits(cond, "warning")) {
[08:26:39.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:39.410]                         if (muffled) 
[08:26:39.410]                           invokeRestart("muffleWarning")
[08:26:39.410]                       }
[08:26:39.410]                       else if (inherits(cond, "condition")) {
[08:26:39.410]                         if (!is.null(pattern)) {
[08:26:39.410]                           computeRestarts <- base::computeRestarts
[08:26:39.410]                           grepl <- base::grepl
[08:26:39.410]                           restarts <- computeRestarts(cond)
[08:26:39.410]                           for (restart in restarts) {
[08:26:39.410]                             name <- restart$name
[08:26:39.410]                             if (is.null(name)) 
[08:26:39.410]                               next
[08:26:39.410]                             if (!grepl(pattern, name)) 
[08:26:39.410]                               next
[08:26:39.410]                             invokeRestart(restart)
[08:26:39.410]                             muffled <- TRUE
[08:26:39.410]                             break
[08:26:39.410]                           }
[08:26:39.410]                         }
[08:26:39.410]                       }
[08:26:39.410]                       invisible(muffled)
[08:26:39.410]                     }
[08:26:39.410]                     muffleCondition(cond, pattern = "^muffle")
[08:26:39.410]                   }
[08:26:39.410]                 }
[08:26:39.410]                 else {
[08:26:39.410]                   if (TRUE) {
[08:26:39.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:39.410]                     {
[08:26:39.410]                       inherits <- base::inherits
[08:26:39.410]                       invokeRestart <- base::invokeRestart
[08:26:39.410]                       is.null <- base::is.null
[08:26:39.410]                       muffled <- FALSE
[08:26:39.410]                       if (inherits(cond, "message")) {
[08:26:39.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:39.410]                         if (muffled) 
[08:26:39.410]                           invokeRestart("muffleMessage")
[08:26:39.410]                       }
[08:26:39.410]                       else if (inherits(cond, "warning")) {
[08:26:39.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:39.410]                         if (muffled) 
[08:26:39.410]                           invokeRestart("muffleWarning")
[08:26:39.410]                       }
[08:26:39.410]                       else if (inherits(cond, "condition")) {
[08:26:39.410]                         if (!is.null(pattern)) {
[08:26:39.410]                           computeRestarts <- base::computeRestarts
[08:26:39.410]                           grepl <- base::grepl
[08:26:39.410]                           restarts <- computeRestarts(cond)
[08:26:39.410]                           for (restart in restarts) {
[08:26:39.410]                             name <- restart$name
[08:26:39.410]                             if (is.null(name)) 
[08:26:39.410]                               next
[08:26:39.410]                             if (!grepl(pattern, name)) 
[08:26:39.410]                               next
[08:26:39.410]                             invokeRestart(restart)
[08:26:39.410]                             muffled <- TRUE
[08:26:39.410]                             break
[08:26:39.410]                           }
[08:26:39.410]                         }
[08:26:39.410]                       }
[08:26:39.410]                       invisible(muffled)
[08:26:39.410]                     }
[08:26:39.410]                     muffleCondition(cond, pattern = "^muffle")
[08:26:39.410]                   }
[08:26:39.410]                 }
[08:26:39.410]             }
[08:26:39.410]         }))
[08:26:39.410]     }, error = function(ex) {
[08:26:39.410]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:39.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:39.410]                 ...future.rng), started = ...future.startTime, 
[08:26:39.410]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:39.410]             version = "1.8"), class = "FutureResult")
[08:26:39.410]     }, finally = {
[08:26:39.410]         if (!identical(...future.workdir, getwd())) 
[08:26:39.410]             setwd(...future.workdir)
[08:26:39.410]         {
[08:26:39.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:39.410]                 ...future.oldOptions$nwarnings <- NULL
[08:26:39.410]             }
[08:26:39.410]             base::options(...future.oldOptions)
[08:26:39.410]             if (.Platform$OS.type == "windows") {
[08:26:39.410]                 old_names <- names(...future.oldEnvVars)
[08:26:39.410]                 envs <- base::Sys.getenv()
[08:26:39.410]                 names <- names(envs)
[08:26:39.410]                 common <- intersect(names, old_names)
[08:26:39.410]                 added <- setdiff(names, old_names)
[08:26:39.410]                 removed <- setdiff(old_names, names)
[08:26:39.410]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:39.410]                   envs[common]]
[08:26:39.410]                 NAMES <- toupper(changed)
[08:26:39.410]                 args <- list()
[08:26:39.410]                 for (kk in seq_along(NAMES)) {
[08:26:39.410]                   name <- changed[[kk]]
[08:26:39.410]                   NAME <- NAMES[[kk]]
[08:26:39.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:39.410]                     next
[08:26:39.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:39.410]                 }
[08:26:39.410]                 NAMES <- toupper(added)
[08:26:39.410]                 for (kk in seq_along(NAMES)) {
[08:26:39.410]                   name <- added[[kk]]
[08:26:39.410]                   NAME <- NAMES[[kk]]
[08:26:39.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:39.410]                     next
[08:26:39.410]                   args[[name]] <- ""
[08:26:39.410]                 }
[08:26:39.410]                 NAMES <- toupper(removed)
[08:26:39.410]                 for (kk in seq_along(NAMES)) {
[08:26:39.410]                   name <- removed[[kk]]
[08:26:39.410]                   NAME <- NAMES[[kk]]
[08:26:39.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:39.410]                     next
[08:26:39.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:39.410]                 }
[08:26:39.410]                 if (length(args) > 0) 
[08:26:39.410]                   base::do.call(base::Sys.setenv, args = args)
[08:26:39.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:39.410]             }
[08:26:39.410]             else {
[08:26:39.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:39.410]             }
[08:26:39.410]             {
[08:26:39.410]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:39.410]                   0L) {
[08:26:39.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:39.410]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:39.410]                   base::options(opts)
[08:26:39.410]                 }
[08:26:39.410]                 {
[08:26:39.410]                   {
[08:26:39.410]                     NULL
[08:26:39.410]                     RNGkind("Mersenne-Twister")
[08:26:39.410]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:39.410]                       inherits = FALSE)
[08:26:39.410]                   }
[08:26:39.410]                   options(future.plan = NULL)
[08:26:39.410]                   if (is.na(NA_character_)) 
[08:26:39.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:39.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:39.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:39.410]                     .init = FALSE)
[08:26:39.410]                 }
[08:26:39.410]             }
[08:26:39.410]         }
[08:26:39.410]     })
[08:26:39.410]     if (TRUE) {
[08:26:39.410]         base::sink(type = "output", split = FALSE)
[08:26:39.410]         if (TRUE) {
[08:26:39.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:39.410]         }
[08:26:39.410]         else {
[08:26:39.410]             ...future.result["stdout"] <- base::list(NULL)
[08:26:39.410]         }
[08:26:39.410]         base::close(...future.stdout)
[08:26:39.410]         ...future.stdout <- NULL
[08:26:39.410]     }
[08:26:39.410]     ...future.result$conditions <- ...future.conditions
[08:26:39.410]     ...future.result$finished <- base::Sys.time()
[08:26:39.410]     ...future.result
[08:26:39.410] }
[08:26:39.412] plan(): Setting new future strategy stack:
[08:26:39.412] List of future strategies:
[08:26:39.412] 1. sequential:
[08:26:39.412]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:39.412]    - tweaked: FALSE
[08:26:39.412]    - call: NULL
[08:26:39.413] plan(): nbrOfWorkers() = 1
[08:26:39.414] plan(): Setting new future strategy stack:
[08:26:39.414] List of future strategies:
[08:26:39.414] 1. multisession:
[08:26:39.414]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:39.414]    - tweaked: FALSE
[08:26:39.414]    - call: plan(strategy)
[08:26:39.415] plan(): nbrOfWorkers() = 1
[08:26:39.416] SequentialFuture started (and completed)
[08:26:39.416] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:26:39.417] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[08:26:39.418] future_lapply() ...
[08:26:39.420] Number of chunks: 1
[08:26:39.420] getGlobalsAndPackagesXApply() ...
[08:26:39.420]  - future.globals: TRUE
[08:26:39.420] getGlobalsAndPackages() ...
[08:26:39.420] Searching for globals...
[08:26:39.422] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:39.422] Searching for globals ... DONE
[08:26:39.422] Resolving globals: FALSE
[08:26:39.422] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:39.423] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:39.423] - globals: [1] ‘FUN’
[08:26:39.423] 
[08:26:39.423] getGlobalsAndPackages() ... DONE
[08:26:39.423]  - globals found/used: [n=1] ‘FUN’
[08:26:39.423]  - needed namespaces: [n=0] 
[08:26:39.423] Finding globals ... DONE
[08:26:39.423]  - use_args: TRUE
[08:26:39.423]  - Getting '...' globals ...
[08:26:39.424] resolve() on list ...
[08:26:39.424]  recursive: 0
[08:26:39.424]  length: 1
[08:26:39.457]  elements: ‘...’
[08:26:39.457]  length: 0 (resolved future 1)
[08:26:39.458] resolve() on list ... DONE
[08:26:39.458]    - '...' content: [n=0] 
[08:26:39.458] List of 1
[08:26:39.458]  $ ...: list()
[08:26:39.458]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:39.458]  - attr(*, "where")=List of 1
[08:26:39.458]   ..$ ...:<environment: 0x55e10e86e040> 
[08:26:39.458]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:39.458]  - attr(*, "resolved")= logi TRUE
[08:26:39.458]  - attr(*, "total_size")= num NA
[08:26:39.461]  - Getting '...' globals ... DONE
[08:26:39.461] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:39.461] List of 2
[08:26:39.461]  $ ...future.FUN:function (x)  
[08:26:39.461]  $ ...          : list()
[08:26:39.461]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:39.461]  - attr(*, "where")=List of 2
[08:26:39.461]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:39.461]   ..$ ...          :<environment: 0x55e10e86e040> 
[08:26:39.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:39.461]  - attr(*, "resolved")= logi FALSE
[08:26:39.461]  - attr(*, "total_size")= num 5632
[08:26:39.464] Packages to be attached in all futures: [n=0] 
[08:26:39.464] getGlobalsAndPackagesXApply() ... DONE
[08:26:39.465] Number of futures (= number of chunks): 1
[08:26:39.465] Launching 1 futures (chunks) ...
[08:26:39.465] Chunk #1 of 1 ...
[08:26:39.465]  - Finding globals in 'X' for chunk #1 ...
[08:26:39.465] getGlobalsAndPackages() ...
[08:26:39.465] Searching for globals...
[08:26:39.466] 
[08:26:39.466] Searching for globals ... DONE
[08:26:39.466] - globals: [0] <none>
[08:26:39.466] getGlobalsAndPackages() ... DONE
[08:26:39.466]    + additional globals found: [n=0] 
[08:26:39.466]    + additional namespaces needed: [n=0] 
[08:26:39.466]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:39.466]  - seeds: <none>
[08:26:39.466]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:39.466] getGlobalsAndPackages() ...
[08:26:39.466] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:39.467] Resolving globals: FALSE
[08:26:39.467] Tweak future expression to call with '...' arguments ...
[08:26:39.467] {
[08:26:39.467]     do.call(function(...) {
[08:26:39.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:39.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:39.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:39.467]             on.exit(options(oopts), add = TRUE)
[08:26:39.467]         }
[08:26:39.467]         {
[08:26:39.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:39.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:39.467]                 ...future.FUN(...future.X_jj, ...)
[08:26:39.467]             })
[08:26:39.467]         }
[08:26:39.467]     }, args = future.call.arguments)
[08:26:39.467] }
[08:26:39.467] Tweak future expression to call with '...' arguments ... DONE
[08:26:39.467] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:39.468] 
[08:26:39.468] getGlobalsAndPackages() ... DONE
[08:26:39.468] run() for ‘Future’ ...
[08:26:39.468] - state: ‘created’
[08:26:39.468] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:39.470] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:39.470] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:39.470]   - Field: ‘label’
[08:26:39.470]   - Field: ‘local’
[08:26:39.470]   - Field: ‘owner’
[08:26:39.470]   - Field: ‘envir’
[08:26:39.470]   - Field: ‘packages’
[08:26:39.471]   - Field: ‘gc’
[08:26:39.471]   - Field: ‘conditions’
[08:26:39.471]   - Field: ‘expr’
[08:26:39.471]   - Field: ‘uuid’
[08:26:39.471]   - Field: ‘seed’
[08:26:39.471]   - Field: ‘version’
[08:26:39.471]   - Field: ‘result’
[08:26:39.471]   - Field: ‘asynchronous’
[08:26:39.471]   - Field: ‘calls’
[08:26:39.471]   - Field: ‘globals’
[08:26:39.471]   - Field: ‘stdout’
[08:26:39.471]   - Field: ‘earlySignal’
[08:26:39.472]   - Field: ‘lazy’
[08:26:39.472]   - Field: ‘state’
[08:26:39.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:39.472] - Launch lazy future ...
[08:26:39.472] Packages needed by the future expression (n = 0): <none>
[08:26:39.472] Packages needed by future strategies (n = 0): <none>
[08:26:39.473] {
[08:26:39.473]     {
[08:26:39.473]         {
[08:26:39.473]             ...future.startTime <- base::Sys.time()
[08:26:39.473]             {
[08:26:39.473]                 {
[08:26:39.473]                   {
[08:26:39.473]                     base::local({
[08:26:39.473]                       has_future <- base::requireNamespace("future", 
[08:26:39.473]                         quietly = TRUE)
[08:26:39.473]                       if (has_future) {
[08:26:39.473]                         ns <- base::getNamespace("future")
[08:26:39.473]                         version <- ns[[".package"]][["version"]]
[08:26:39.473]                         if (is.null(version)) 
[08:26:39.473]                           version <- utils::packageVersion("future")
[08:26:39.473]                       }
[08:26:39.473]                       else {
[08:26:39.473]                         version <- NULL
[08:26:39.473]                       }
[08:26:39.473]                       if (!has_future || version < "1.8.0") {
[08:26:39.473]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:39.473]                           "", base::R.version$version.string), 
[08:26:39.473]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:39.473]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:39.473]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:39.473]                             "release", "version")], collapse = " "), 
[08:26:39.473]                           hostname = base::Sys.info()[["nodename"]])
[08:26:39.473]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:39.473]                           info)
[08:26:39.473]                         info <- base::paste(info, collapse = "; ")
[08:26:39.473]                         if (!has_future) {
[08:26:39.473]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:39.473]                             info)
[08:26:39.473]                         }
[08:26:39.473]                         else {
[08:26:39.473]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:39.473]                             info, version)
[08:26:39.473]                         }
[08:26:39.473]                         base::stop(msg)
[08:26:39.473]                       }
[08:26:39.473]                     })
[08:26:39.473]                   }
[08:26:39.473]                   ...future.strategy.old <- future::plan("list")
[08:26:39.473]                   options(future.plan = NULL)
[08:26:39.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:39.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:39.473]                 }
[08:26:39.473]                 ...future.workdir <- getwd()
[08:26:39.473]             }
[08:26:39.473]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:39.473]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:39.473]         }
[08:26:39.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:39.473]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:39.473]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:39.473]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:39.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:39.473]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:39.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:39.473]             base::names(...future.oldOptions))
[08:26:39.473]     }
[08:26:39.473]     if (FALSE) {
[08:26:39.473]     }
[08:26:39.473]     else {
[08:26:39.473]         if (FALSE) {
[08:26:39.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:39.473]                 open = "w")
[08:26:39.473]         }
[08:26:39.473]         else {
[08:26:39.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:39.473]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:39.473]         }
[08:26:39.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:39.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:39.473]             base::sink(type = "output", split = FALSE)
[08:26:39.473]             base::close(...future.stdout)
[08:26:39.473]         }, add = TRUE)
[08:26:39.473]     }
[08:26:39.473]     ...future.frame <- base::sys.nframe()
[08:26:39.473]     ...future.conditions <- base::list()
[08:26:39.473]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:39.473]     if (FALSE) {
[08:26:39.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:39.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:39.473]     }
[08:26:39.473]     ...future.result <- base::tryCatch({
[08:26:39.473]         base::withCallingHandlers({
[08:26:39.473]             ...future.value <- base::withVisible(base::local({
[08:26:39.473]                 do.call(function(...) {
[08:26:39.473]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:39.473]                   if (!identical(...future.globals.maxSize.org, 
[08:26:39.473]                     ...future.globals.maxSize)) {
[08:26:39.473]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:39.473]                     on.exit(options(oopts), add = TRUE)
[08:26:39.473]                   }
[08:26:39.473]                   {
[08:26:39.473]                     lapply(seq_along(...future.elements_ii), 
[08:26:39.473]                       FUN = function(jj) {
[08:26:39.473]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:39.473]                         ...future.FUN(...future.X_jj, ...)
[08:26:39.473]                       })
[08:26:39.473]                   }
[08:26:39.473]                 }, args = future.call.arguments)
[08:26:39.473]             }))
[08:26:39.473]             future::FutureResult(value = ...future.value$value, 
[08:26:39.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:39.473]                   ...future.rng), globalenv = if (FALSE) 
[08:26:39.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:39.473]                     ...future.globalenv.names))
[08:26:39.473]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:39.473]         }, condition = base::local({
[08:26:39.473]             c <- base::c
[08:26:39.473]             inherits <- base::inherits
[08:26:39.473]             invokeRestart <- base::invokeRestart
[08:26:39.473]             length <- base::length
[08:26:39.473]             list <- base::list
[08:26:39.473]             seq.int <- base::seq.int
[08:26:39.473]             signalCondition <- base::signalCondition
[08:26:39.473]             sys.calls <- base::sys.calls
[08:26:39.473]             `[[` <- base::`[[`
[08:26:39.473]             `+` <- base::`+`
[08:26:39.473]             `<<-` <- base::`<<-`
[08:26:39.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:39.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:39.473]                   3L)]
[08:26:39.473]             }
[08:26:39.473]             function(cond) {
[08:26:39.473]                 is_error <- inherits(cond, "error")
[08:26:39.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:39.473]                   NULL)
[08:26:39.473]                 if (is_error) {
[08:26:39.473]                   sessionInformation <- function() {
[08:26:39.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:39.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:39.473]                       search = base::search(), system = base::Sys.info())
[08:26:39.473]                   }
[08:26:39.473]                   ...future.conditions[[length(...future.conditions) + 
[08:26:39.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:39.473]                     cond$call), session = sessionInformation(), 
[08:26:39.473]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:39.473]                   signalCondition(cond)
[08:26:39.473]                 }
[08:26:39.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:39.473]                 "immediateCondition"))) {
[08:26:39.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:39.473]                   ...future.conditions[[length(...future.conditions) + 
[08:26:39.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:39.473]                   if (TRUE && !signal) {
[08:26:39.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:39.473]                     {
[08:26:39.473]                       inherits <- base::inherits
[08:26:39.473]                       invokeRestart <- base::invokeRestart
[08:26:39.473]                       is.null <- base::is.null
[08:26:39.473]                       muffled <- FALSE
[08:26:39.473]                       if (inherits(cond, "message")) {
[08:26:39.473]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:39.473]                         if (muffled) 
[08:26:39.473]                           invokeRestart("muffleMessage")
[08:26:39.473]                       }
[08:26:39.473]                       else if (inherits(cond, "warning")) {
[08:26:39.473]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:39.473]                         if (muffled) 
[08:26:39.473]                           invokeRestart("muffleWarning")
[08:26:39.473]                       }
[08:26:39.473]                       else if (inherits(cond, "condition")) {
[08:26:39.473]                         if (!is.null(pattern)) {
[08:26:39.473]                           computeRestarts <- base::computeRestarts
[08:26:39.473]                           grepl <- base::grepl
[08:26:39.473]                           restarts <- computeRestarts(cond)
[08:26:39.473]                           for (restart in restarts) {
[08:26:39.473]                             name <- restart$name
[08:26:39.473]                             if (is.null(name)) 
[08:26:39.473]                               next
[08:26:39.473]                             if (!grepl(pattern, name)) 
[08:26:39.473]                               next
[08:26:39.473]                             invokeRestart(restart)
[08:26:39.473]                             muffled <- TRUE
[08:26:39.473]                             break
[08:26:39.473]                           }
[08:26:39.473]                         }
[08:26:39.473]                       }
[08:26:39.473]                       invisible(muffled)
[08:26:39.473]                     }
[08:26:39.473]                     muffleCondition(cond, pattern = "^muffle")
[08:26:39.473]                   }
[08:26:39.473]                 }
[08:26:39.473]                 else {
[08:26:39.473]                   if (TRUE) {
[08:26:39.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:39.473]                     {
[08:26:39.473]                       inherits <- base::inherits
[08:26:39.473]                       invokeRestart <- base::invokeRestart
[08:26:39.473]                       is.null <- base::is.null
[08:26:39.473]                       muffled <- FALSE
[08:26:39.473]                       if (inherits(cond, "message")) {
[08:26:39.473]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:39.473]                         if (muffled) 
[08:26:39.473]                           invokeRestart("muffleMessage")
[08:26:39.473]                       }
[08:26:39.473]                       else if (inherits(cond, "warning")) {
[08:26:39.473]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:39.473]                         if (muffled) 
[08:26:39.473]                           invokeRestart("muffleWarning")
[08:26:39.473]                       }
[08:26:39.473]                       else if (inherits(cond, "condition")) {
[08:26:39.473]                         if (!is.null(pattern)) {
[08:26:39.473]                           computeRestarts <- base::computeRestarts
[08:26:39.473]                           grepl <- base::grepl
[08:26:39.473]                           restarts <- computeRestarts(cond)
[08:26:39.473]                           for (restart in restarts) {
[08:26:39.473]                             name <- restart$name
[08:26:39.473]                             if (is.null(name)) 
[08:26:39.473]                               next
[08:26:39.473]                             if (!grepl(pattern, name)) 
[08:26:39.473]                               next
[08:26:39.473]                             invokeRestart(restart)
[08:26:39.473]                             muffled <- TRUE
[08:26:39.473]                             break
[08:26:39.473]                           }
[08:26:39.473]                         }
[08:26:39.473]                       }
[08:26:39.473]                       invisible(muffled)
[08:26:39.473]                     }
[08:26:39.473]                     muffleCondition(cond, pattern = "^muffle")
[08:26:39.473]                   }
[08:26:39.473]                 }
[08:26:39.473]             }
[08:26:39.473]         }))
[08:26:39.473]     }, error = function(ex) {
[08:26:39.473]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:39.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:39.473]                 ...future.rng), started = ...future.startTime, 
[08:26:39.473]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:39.473]             version = "1.8"), class = "FutureResult")
[08:26:39.473]     }, finally = {
[08:26:39.473]         if (!identical(...future.workdir, getwd())) 
[08:26:39.473]             setwd(...future.workdir)
[08:26:39.473]         {
[08:26:39.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:39.473]                 ...future.oldOptions$nwarnings <- NULL
[08:26:39.473]             }
[08:26:39.473]             base::options(...future.oldOptions)
[08:26:39.473]             if (.Platform$OS.type == "windows") {
[08:26:39.473]                 old_names <- names(...future.oldEnvVars)
[08:26:39.473]                 envs <- base::Sys.getenv()
[08:26:39.473]                 names <- names(envs)
[08:26:39.473]                 common <- intersect(names, old_names)
[08:26:39.473]                 added <- setdiff(names, old_names)
[08:26:39.473]                 removed <- setdiff(old_names, names)
[08:26:39.473]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:39.473]                   envs[common]]
[08:26:39.473]                 NAMES <- toupper(changed)
[08:26:39.473]                 args <- list()
[08:26:39.473]                 for (kk in seq_along(NAMES)) {
[08:26:39.473]                   name <- changed[[kk]]
[08:26:39.473]                   NAME <- NAMES[[kk]]
[08:26:39.473]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:39.473]                     next
[08:26:39.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:39.473]                 }
[08:26:39.473]                 NAMES <- toupper(added)
[08:26:39.473]                 for (kk in seq_along(NAMES)) {
[08:26:39.473]                   name <- added[[kk]]
[08:26:39.473]                   NAME <- NAMES[[kk]]
[08:26:39.473]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:39.473]                     next
[08:26:39.473]                   args[[name]] <- ""
[08:26:39.473]                 }
[08:26:39.473]                 NAMES <- toupper(removed)
[08:26:39.473]                 for (kk in seq_along(NAMES)) {
[08:26:39.473]                   name <- removed[[kk]]
[08:26:39.473]                   NAME <- NAMES[[kk]]
[08:26:39.473]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:39.473]                     next
[08:26:39.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:39.473]                 }
[08:26:39.473]                 if (length(args) > 0) 
[08:26:39.473]                   base::do.call(base::Sys.setenv, args = args)
[08:26:39.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:39.473]             }
[08:26:39.473]             else {
[08:26:39.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:39.473]             }
[08:26:39.473]             {
[08:26:39.473]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:39.473]                   0L) {
[08:26:39.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:39.473]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:39.473]                   base::options(opts)
[08:26:39.473]                 }
[08:26:39.473]                 {
[08:26:39.473]                   {
[08:26:39.473]                     NULL
[08:26:39.473]                     RNGkind("Mersenne-Twister")
[08:26:39.473]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:39.473]                       inherits = FALSE)
[08:26:39.473]                   }
[08:26:39.473]                   options(future.plan = NULL)
[08:26:39.473]                   if (is.na(NA_character_)) 
[08:26:39.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:39.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:39.473]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:39.473]                     .init = FALSE)
[08:26:39.473]                 }
[08:26:39.473]             }
[08:26:39.473]         }
[08:26:39.473]     })
[08:26:39.473]     if (TRUE) {
[08:26:39.473]         base::sink(type = "output", split = FALSE)
[08:26:39.473]         if (FALSE) {
[08:26:39.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:39.473]         }
[08:26:39.473]         else {
[08:26:39.473]             ...future.result["stdout"] <- base::list(NULL)
[08:26:39.473]         }
[08:26:39.473]         base::close(...future.stdout)
[08:26:39.473]         ...future.stdout <- NULL
[08:26:39.473]     }
[08:26:39.473]     ...future.result$conditions <- ...future.conditions
[08:26:39.473]     ...future.result$finished <- base::Sys.time()
[08:26:39.473]     ...future.result
[08:26:39.473] }
[08:26:39.474] assign_globals() ...
[08:26:39.475] List of 5
[08:26:39.475]  $ ...future.FUN            :function (x)  
[08:26:39.475]  $ future.call.arguments    : list()
[08:26:39.475]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:39.475]  $ ...future.elements_ii    :List of 2
[08:26:39.475]   ..$ : int 1
[08:26:39.475]   ..$ : int 0
[08:26:39.475]  $ ...future.seeds_ii       : NULL
[08:26:39.475]  $ ...future.globals.maxSize: NULL
[08:26:39.475]  - attr(*, "where")=List of 5
[08:26:39.475]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:39.475]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:39.475]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:39.475]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:39.475]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:39.475]  - attr(*, "resolved")= logi FALSE
[08:26:39.475]  - attr(*, "total_size")= num 5632
[08:26:39.475]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:39.475]  - attr(*, "already-done")= logi TRUE
[08:26:39.480] - reassign environment for ‘...future.FUN’
[08:26:39.480] - copied ‘...future.FUN’ to environment
[08:26:39.480] - copied ‘future.call.arguments’ to environment
[08:26:39.480] - copied ‘...future.elements_ii’ to environment
[08:26:39.480] - copied ‘...future.seeds_ii’ to environment
[08:26:39.480] - copied ‘...future.globals.maxSize’ to environment
[08:26:39.480] assign_globals() ... done
[08:26:39.480] plan(): Setting new future strategy stack:
[08:26:39.480] List of future strategies:
[08:26:39.480] 1. sequential:
[08:26:39.480]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:39.480]    - tweaked: FALSE
[08:26:39.480]    - call: NULL
[08:26:39.481] plan(): nbrOfWorkers() = 1
[08:26:39.983] plan(): Setting new future strategy stack:
[08:26:39.983] List of future strategies:
[08:26:39.983] 1. multisession:
[08:26:39.983]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:39.983]    - tweaked: FALSE
[08:26:39.983]    - call: plan(strategy)
[08:26:39.985] plan(): nbrOfWorkers() = 1
[08:26:39.985] SequentialFuture started (and completed)
[08:26:39.986] - Launch lazy future ... done
[08:26:39.986] run() for ‘SequentialFuture’ ... done
[08:26:39.986] Created future:
[08:26:39.986] SequentialFuture:
[08:26:39.986] Label: ‘future_lapply-1’
[08:26:39.986] Expression:
[08:26:39.986] {
[08:26:39.986]     do.call(function(...) {
[08:26:39.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:39.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:39.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:39.986]             on.exit(options(oopts), add = TRUE)
[08:26:39.986]         }
[08:26:39.986]         {
[08:26:39.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:39.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:39.986]                 ...future.FUN(...future.X_jj, ...)
[08:26:39.986]             })
[08:26:39.986]         }
[08:26:39.986]     }, args = future.call.arguments)
[08:26:39.986] }
[08:26:39.986] Lazy evaluation: FALSE
[08:26:39.986] Asynchronous evaluation: FALSE
[08:26:39.986] Local evaluation: TRUE
[08:26:39.986] Environment: R_GlobalEnv
[08:26:39.986] Capture standard output: FALSE
[08:26:39.986] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:39.986] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:39.986] Packages: <none>
[08:26:39.986] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:39.986] Resolved: TRUE
[08:26:39.986] Value: 55 bytes of class ‘list’
[08:26:39.986] Early signaling: FALSE
[08:26:39.986] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:39.986] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:39.987] Chunk #1 of 1 ... DONE
[08:26:39.987] Launching 1 futures (chunks) ... DONE
[08:26:39.987] Resolving 1 futures (chunks) ...
[08:26:39.987] resolve() on list ...
[08:26:39.987]  recursive: 0
[08:26:39.987]  length: 1
[08:26:39.987] 
[08:26:39.988] resolved() for ‘SequentialFuture’ ...
[08:26:39.988] - state: ‘finished’
[08:26:39.988] - run: TRUE
[08:26:39.988] - result: ‘FutureResult’
[08:26:39.988] resolved() for ‘SequentialFuture’ ... done
[08:26:39.988] Future #1
[08:26:39.988] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:39.990] - nx: 1
[08:26:39.990] - relay: TRUE
[08:26:39.990] - stdout: TRUE
[08:26:39.990] - signal: TRUE
[08:26:39.990] - resignal: FALSE
[08:26:39.990] - force: TRUE
[08:26:39.990] - relayed: [n=1] FALSE
[08:26:39.991] - queued futures: [n=1] FALSE
[08:26:39.991]  - until=1
[08:26:39.991]  - relaying element #1
[08:26:39.991] - relayed: [n=1] TRUE
[08:26:39.991] - queued futures: [n=1] TRUE
[08:26:39.991] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:39.991]  length: 0 (resolved future 1)
[08:26:39.992] Relaying remaining futures
[08:26:39.992] signalConditionsASAP(NULL, pos=0) ...
[08:26:39.992] - nx: 1
[08:26:39.992] - relay: TRUE
[08:26:39.992] - stdout: TRUE
[08:26:39.992] - signal: TRUE
[08:26:39.992] - resignal: FALSE
[08:26:39.992] - force: TRUE
[08:26:39.992] - relayed: [n=1] TRUE
[08:26:39.992] - queued futures: [n=1] TRUE
 - flush all
[08:26:39.993] - relayed: [n=1] TRUE
[08:26:39.993] - queued futures: [n=1] TRUE
[08:26:39.993] signalConditionsASAP(NULL, pos=0) ... done
[08:26:39.993] resolve() on list ... DONE
[08:26:39.993]  - Number of value chunks collected: 1
[08:26:39.993] Resolving 1 futures (chunks) ... DONE
[08:26:39.993] Reducing values from 1 chunks ...
[08:26:39.993]  - Number of values collected after concatenation: 2
[08:26:39.993]  - Number of values expected: 2
[08:26:39.994] Reducing values from 1 chunks ... DONE
[08:26:39.994] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[08:26:39.994] future_lapply() ...
[08:26:39.996] Number of chunks: 1
[08:26:39.996] getGlobalsAndPackagesXApply() ...
[08:26:39.996]  - future.globals: TRUE
[08:26:39.996] getGlobalsAndPackages() ...
[08:26:39.997] Searching for globals...
[08:26:39.998] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:39.998] Searching for globals ... DONE
[08:26:39.998] Resolving globals: FALSE
[08:26:39.999] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:39.999] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:39.999] - globals: [1] ‘FUN’
[08:26:39.999] 
[08:26:39.999] getGlobalsAndPackages() ... DONE
[08:26:39.999]  - globals found/used: [n=1] ‘FUN’
[08:26:40.000]  - needed namespaces: [n=0] 
[08:26:40.000] Finding globals ... DONE
[08:26:40.000]  - use_args: TRUE
[08:26:40.000]  - Getting '...' globals ...
[08:26:40.000] resolve() on list ...
[08:26:40.000]  recursive: 0
[08:26:40.000]  length: 1
[08:26:40.000]  elements: ‘...’
[08:26:40.001]  length: 0 (resolved future 1)
[08:26:40.001] resolve() on list ... DONE
[08:26:40.001]    - '...' content: [n=0] 
[08:26:40.001] List of 1
[08:26:40.001]  $ ...: list()
[08:26:40.001]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:40.001]  - attr(*, "where")=List of 1
[08:26:40.001]   ..$ ...:<environment: 0x55e10dcbfde0> 
[08:26:40.001]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:40.001]  - attr(*, "resolved")= logi TRUE
[08:26:40.001]  - attr(*, "total_size")= num NA
[08:26:40.003]  - Getting '...' globals ... DONE
[08:26:40.004] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:40.004] List of 2
[08:26:40.004]  $ ...future.FUN:function (x)  
[08:26:40.004]  $ ...          : list()
[08:26:40.004]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:40.004]  - attr(*, "where")=List of 2
[08:26:40.004]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:40.004]   ..$ ...          :<environment: 0x55e10dcbfde0> 
[08:26:40.004]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:40.004]  - attr(*, "resolved")= logi FALSE
[08:26:40.004]  - attr(*, "total_size")= num 5632
[08:26:40.006] Packages to be attached in all futures: [n=0] 
[08:26:40.007] getGlobalsAndPackagesXApply() ... DONE
[08:26:40.007] Number of futures (= number of chunks): 1
[08:26:40.007] Launching 1 futures (chunks) ...
[08:26:40.007] Chunk #1 of 1 ...
[08:26:40.007]  - Finding globals in 'X' for chunk #1 ...
[08:26:40.007] getGlobalsAndPackages() ...
[08:26:40.007] Searching for globals...
[08:26:40.008] 
[08:26:40.008] Searching for globals ... DONE
[08:26:40.008] - globals: [0] <none>
[08:26:40.008] getGlobalsAndPackages() ... DONE
[08:26:40.008]    + additional globals found: [n=0] 
[08:26:40.008]    + additional namespaces needed: [n=0] 
[08:26:40.008]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:40.008]  - seeds: <none>
[08:26:40.008]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:40.009] getGlobalsAndPackages() ...
[08:26:40.009] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:40.009] Resolving globals: FALSE
[08:26:40.009] Tweak future expression to call with '...' arguments ...
[08:26:40.009] {
[08:26:40.009]     do.call(function(...) {
[08:26:40.009]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:40.009]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:40.009]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:40.009]             on.exit(options(oopts), add = TRUE)
[08:26:40.009]         }
[08:26:40.009]         {
[08:26:40.009]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:40.009]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:40.009]                 ...future.FUN(...future.X_jj, ...)
[08:26:40.009]             })
[08:26:40.009]         }
[08:26:40.009]     }, args = future.call.arguments)
[08:26:40.009] }
[08:26:40.009] Tweak future expression to call with '...' arguments ... DONE
[08:26:40.010] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:40.010] 
[08:26:40.010] getGlobalsAndPackages() ... DONE
[08:26:40.010] run() for ‘Future’ ...
[08:26:40.010] - state: ‘created’
[08:26:40.010] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:40.012] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:40.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:40.012]   - Field: ‘label’
[08:26:40.012]   - Field: ‘local’
[08:26:40.012]   - Field: ‘owner’
[08:26:40.013]   - Field: ‘envir’
[08:26:40.013]   - Field: ‘packages’
[08:26:40.013]   - Field: ‘gc’
[08:26:40.013]   - Field: ‘conditions’
[08:26:40.013]   - Field: ‘expr’
[08:26:40.013]   - Field: ‘uuid’
[08:26:40.013]   - Field: ‘seed’
[08:26:40.013]   - Field: ‘version’
[08:26:40.013]   - Field: ‘result’
[08:26:40.013]   - Field: ‘asynchronous’
[08:26:40.014]   - Field: ‘calls’
[08:26:40.014]   - Field: ‘globals’
[08:26:40.014]   - Field: ‘stdout’
[08:26:40.014]   - Field: ‘earlySignal’
[08:26:40.014]   - Field: ‘lazy’
[08:26:40.014]   - Field: ‘state’
[08:26:40.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:40.014] - Launch lazy future ...
[08:26:40.014] Packages needed by the future expression (n = 0): <none>
[08:26:40.015] Packages needed by future strategies (n = 0): <none>
[08:26:40.015] {
[08:26:40.015]     {
[08:26:40.015]         {
[08:26:40.015]             ...future.startTime <- base::Sys.time()
[08:26:40.015]             {
[08:26:40.015]                 {
[08:26:40.015]                   {
[08:26:40.015]                     base::local({
[08:26:40.015]                       has_future <- base::requireNamespace("future", 
[08:26:40.015]                         quietly = TRUE)
[08:26:40.015]                       if (has_future) {
[08:26:40.015]                         ns <- base::getNamespace("future")
[08:26:40.015]                         version <- ns[[".package"]][["version"]]
[08:26:40.015]                         if (is.null(version)) 
[08:26:40.015]                           version <- utils::packageVersion("future")
[08:26:40.015]                       }
[08:26:40.015]                       else {
[08:26:40.015]                         version <- NULL
[08:26:40.015]                       }
[08:26:40.015]                       if (!has_future || version < "1.8.0") {
[08:26:40.015]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:40.015]                           "", base::R.version$version.string), 
[08:26:40.015]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:40.015]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:40.015]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:40.015]                             "release", "version")], collapse = " "), 
[08:26:40.015]                           hostname = base::Sys.info()[["nodename"]])
[08:26:40.015]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:40.015]                           info)
[08:26:40.015]                         info <- base::paste(info, collapse = "; ")
[08:26:40.015]                         if (!has_future) {
[08:26:40.015]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:40.015]                             info)
[08:26:40.015]                         }
[08:26:40.015]                         else {
[08:26:40.015]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:40.015]                             info, version)
[08:26:40.015]                         }
[08:26:40.015]                         base::stop(msg)
[08:26:40.015]                       }
[08:26:40.015]                     })
[08:26:40.015]                   }
[08:26:40.015]                   ...future.strategy.old <- future::plan("list")
[08:26:40.015]                   options(future.plan = NULL)
[08:26:40.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:40.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:40.015]                 }
[08:26:40.015]                 ...future.workdir <- getwd()
[08:26:40.015]             }
[08:26:40.015]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:40.015]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:40.015]         }
[08:26:40.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:40.015]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:40.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:40.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:40.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:40.015]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:40.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:40.015]             base::names(...future.oldOptions))
[08:26:40.015]     }
[08:26:40.015]     if (FALSE) {
[08:26:40.015]     }
[08:26:40.015]     else {
[08:26:40.015]         if (TRUE) {
[08:26:40.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:40.015]                 open = "w")
[08:26:40.015]         }
[08:26:40.015]         else {
[08:26:40.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:40.015]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:40.015]         }
[08:26:40.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:40.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:40.015]             base::sink(type = "output", split = FALSE)
[08:26:40.015]             base::close(...future.stdout)
[08:26:40.015]         }, add = TRUE)
[08:26:40.015]     }
[08:26:40.015]     ...future.frame <- base::sys.nframe()
[08:26:40.015]     ...future.conditions <- base::list()
[08:26:40.015]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:40.015]     if (FALSE) {
[08:26:40.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:40.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:40.015]     }
[08:26:40.015]     ...future.result <- base::tryCatch({
[08:26:40.015]         base::withCallingHandlers({
[08:26:40.015]             ...future.value <- base::withVisible(base::local({
[08:26:40.015]                 do.call(function(...) {
[08:26:40.015]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:40.015]                   if (!identical(...future.globals.maxSize.org, 
[08:26:40.015]                     ...future.globals.maxSize)) {
[08:26:40.015]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:40.015]                     on.exit(options(oopts), add = TRUE)
[08:26:40.015]                   }
[08:26:40.015]                   {
[08:26:40.015]                     lapply(seq_along(...future.elements_ii), 
[08:26:40.015]                       FUN = function(jj) {
[08:26:40.015]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:40.015]                         ...future.FUN(...future.X_jj, ...)
[08:26:40.015]                       })
[08:26:40.015]                   }
[08:26:40.015]                 }, args = future.call.arguments)
[08:26:40.015]             }))
[08:26:40.015]             future::FutureResult(value = ...future.value$value, 
[08:26:40.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:40.015]                   ...future.rng), globalenv = if (FALSE) 
[08:26:40.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:40.015]                     ...future.globalenv.names))
[08:26:40.015]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:40.015]         }, condition = base::local({
[08:26:40.015]             c <- base::c
[08:26:40.015]             inherits <- base::inherits
[08:26:40.015]             invokeRestart <- base::invokeRestart
[08:26:40.015]             length <- base::length
[08:26:40.015]             list <- base::list
[08:26:40.015]             seq.int <- base::seq.int
[08:26:40.015]             signalCondition <- base::signalCondition
[08:26:40.015]             sys.calls <- base::sys.calls
[08:26:40.015]             `[[` <- base::`[[`
[08:26:40.015]             `+` <- base::`+`
[08:26:40.015]             `<<-` <- base::`<<-`
[08:26:40.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:40.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:40.015]                   3L)]
[08:26:40.015]             }
[08:26:40.015]             function(cond) {
[08:26:40.015]                 is_error <- inherits(cond, "error")
[08:26:40.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:40.015]                   NULL)
[08:26:40.015]                 if (is_error) {
[08:26:40.015]                   sessionInformation <- function() {
[08:26:40.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:40.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:40.015]                       search = base::search(), system = base::Sys.info())
[08:26:40.015]                   }
[08:26:40.015]                   ...future.conditions[[length(...future.conditions) + 
[08:26:40.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:40.015]                     cond$call), session = sessionInformation(), 
[08:26:40.015]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:40.015]                   signalCondition(cond)
[08:26:40.015]                 }
[08:26:40.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:40.015]                 "immediateCondition"))) {
[08:26:40.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:40.015]                   ...future.conditions[[length(...future.conditions) + 
[08:26:40.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:40.015]                   if (TRUE && !signal) {
[08:26:40.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:40.015]                     {
[08:26:40.015]                       inherits <- base::inherits
[08:26:40.015]                       invokeRestart <- base::invokeRestart
[08:26:40.015]                       is.null <- base::is.null
[08:26:40.015]                       muffled <- FALSE
[08:26:40.015]                       if (inherits(cond, "message")) {
[08:26:40.015]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:40.015]                         if (muffled) 
[08:26:40.015]                           invokeRestart("muffleMessage")
[08:26:40.015]                       }
[08:26:40.015]                       else if (inherits(cond, "warning")) {
[08:26:40.015]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:40.015]                         if (muffled) 
[08:26:40.015]                           invokeRestart("muffleWarning")
[08:26:40.015]                       }
[08:26:40.015]                       else if (inherits(cond, "condition")) {
[08:26:40.015]                         if (!is.null(pattern)) {
[08:26:40.015]                           computeRestarts <- base::computeRestarts
[08:26:40.015]                           grepl <- base::grepl
[08:26:40.015]                           restarts <- computeRestarts(cond)
[08:26:40.015]                           for (restart in restarts) {
[08:26:40.015]                             name <- restart$name
[08:26:40.015]                             if (is.null(name)) 
[08:26:40.015]                               next
[08:26:40.015]                             if (!grepl(pattern, name)) 
[08:26:40.015]                               next
[08:26:40.015]                             invokeRestart(restart)
[08:26:40.015]                             muffled <- TRUE
[08:26:40.015]                             break
[08:26:40.015]                           }
[08:26:40.015]                         }
[08:26:40.015]                       }
[08:26:40.015]                       invisible(muffled)
[08:26:40.015]                     }
[08:26:40.015]                     muffleCondition(cond, pattern = "^muffle")
[08:26:40.015]                   }
[08:26:40.015]                 }
[08:26:40.015]                 else {
[08:26:40.015]                   if (TRUE) {
[08:26:40.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:40.015]                     {
[08:26:40.015]                       inherits <- base::inherits
[08:26:40.015]                       invokeRestart <- base::invokeRestart
[08:26:40.015]                       is.null <- base::is.null
[08:26:40.015]                       muffled <- FALSE
[08:26:40.015]                       if (inherits(cond, "message")) {
[08:26:40.015]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:40.015]                         if (muffled) 
[08:26:40.015]                           invokeRestart("muffleMessage")
[08:26:40.015]                       }
[08:26:40.015]                       else if (inherits(cond, "warning")) {
[08:26:40.015]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:40.015]                         if (muffled) 
[08:26:40.015]                           invokeRestart("muffleWarning")
[08:26:40.015]                       }
[08:26:40.015]                       else if (inherits(cond, "condition")) {
[08:26:40.015]                         if (!is.null(pattern)) {
[08:26:40.015]                           computeRestarts <- base::computeRestarts
[08:26:40.015]                           grepl <- base::grepl
[08:26:40.015]                           restarts <- computeRestarts(cond)
[08:26:40.015]                           for (restart in restarts) {
[08:26:40.015]                             name <- restart$name
[08:26:40.015]                             if (is.null(name)) 
[08:26:40.015]                               next
[08:26:40.015]                             if (!grepl(pattern, name)) 
[08:26:40.015]                               next
[08:26:40.015]                             invokeRestart(restart)
[08:26:40.015]                             muffled <- TRUE
[08:26:40.015]                             break
[08:26:40.015]                           }
[08:26:40.015]                         }
[08:26:40.015]                       }
[08:26:40.015]                       invisible(muffled)
[08:26:40.015]                     }
[08:26:40.015]                     muffleCondition(cond, pattern = "^muffle")
[08:26:40.015]                   }
[08:26:40.015]                 }
[08:26:40.015]             }
[08:26:40.015]         }))
[08:26:40.015]     }, error = function(ex) {
[08:26:40.015]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:40.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:40.015]                 ...future.rng), started = ...future.startTime, 
[08:26:40.015]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:40.015]             version = "1.8"), class = "FutureResult")
[08:26:40.015]     }, finally = {
[08:26:40.015]         if (!identical(...future.workdir, getwd())) 
[08:26:40.015]             setwd(...future.workdir)
[08:26:40.015]         {
[08:26:40.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:40.015]                 ...future.oldOptions$nwarnings <- NULL
[08:26:40.015]             }
[08:26:40.015]             base::options(...future.oldOptions)
[08:26:40.015]             if (.Platform$OS.type == "windows") {
[08:26:40.015]                 old_names <- names(...future.oldEnvVars)
[08:26:40.015]                 envs <- base::Sys.getenv()
[08:26:40.015]                 names <- names(envs)
[08:26:40.015]                 common <- intersect(names, old_names)
[08:26:40.015]                 added <- setdiff(names, old_names)
[08:26:40.015]                 removed <- setdiff(old_names, names)
[08:26:40.015]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:40.015]                   envs[common]]
[08:26:40.015]                 NAMES <- toupper(changed)
[08:26:40.015]                 args <- list()
[08:26:40.015]                 for (kk in seq_along(NAMES)) {
[08:26:40.015]                   name <- changed[[kk]]
[08:26:40.015]                   NAME <- NAMES[[kk]]
[08:26:40.015]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:40.015]                     next
[08:26:40.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:40.015]                 }
[08:26:40.015]                 NAMES <- toupper(added)
[08:26:40.015]                 for (kk in seq_along(NAMES)) {
[08:26:40.015]                   name <- added[[kk]]
[08:26:40.015]                   NAME <- NAMES[[kk]]
[08:26:40.015]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:40.015]                     next
[08:26:40.015]                   args[[name]] <- ""
[08:26:40.015]                 }
[08:26:40.015]                 NAMES <- toupper(removed)
[08:26:40.015]                 for (kk in seq_along(NAMES)) {
[08:26:40.015]                   name <- removed[[kk]]
[08:26:40.015]                   NAME <- NAMES[[kk]]
[08:26:40.015]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:40.015]                     next
[08:26:40.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:40.015]                 }
[08:26:40.015]                 if (length(args) > 0) 
[08:26:40.015]                   base::do.call(base::Sys.setenv, args = args)
[08:26:40.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:40.015]             }
[08:26:40.015]             else {
[08:26:40.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:40.015]             }
[08:26:40.015]             {
[08:26:40.015]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:40.015]                   0L) {
[08:26:40.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:40.015]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:40.015]                   base::options(opts)
[08:26:40.015]                 }
[08:26:40.015]                 {
[08:26:40.015]                   {
[08:26:40.015]                     NULL
[08:26:40.015]                     RNGkind("Mersenne-Twister")
[08:26:40.015]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:40.015]                       inherits = FALSE)
[08:26:40.015]                   }
[08:26:40.015]                   options(future.plan = NULL)
[08:26:40.015]                   if (is.na(NA_character_)) 
[08:26:40.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:40.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:40.015]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:40.015]                     .init = FALSE)
[08:26:40.015]                 }
[08:26:40.015]             }
[08:26:40.015]         }
[08:26:40.015]     })
[08:26:40.015]     if (TRUE) {
[08:26:40.015]         base::sink(type = "output", split = FALSE)
[08:26:40.015]         if (TRUE) {
[08:26:40.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:40.015]         }
[08:26:40.015]         else {
[08:26:40.015]             ...future.result["stdout"] <- base::list(NULL)
[08:26:40.015]         }
[08:26:40.015]         base::close(...future.stdout)
[08:26:40.015]         ...future.stdout <- NULL
[08:26:40.015]     }
[08:26:40.015]     ...future.result$conditions <- ...future.conditions
[08:26:40.015]     ...future.result$finished <- base::Sys.time()
[08:26:40.015]     ...future.result
[08:26:40.015] }
[08:26:40.017] assign_globals() ...
[08:26:40.017] List of 5
[08:26:40.017]  $ ...future.FUN            :function (x)  
[08:26:40.017]  $ future.call.arguments    : list()
[08:26:40.017]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:40.017]  $ ...future.elements_ii    :List of 2
[08:26:40.017]   ..$ : int 1
[08:26:40.017]   ..$ : int 0
[08:26:40.017]  $ ...future.seeds_ii       : NULL
[08:26:40.017]  $ ...future.globals.maxSize: NULL
[08:26:40.017]  - attr(*, "where")=List of 5
[08:26:40.017]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:40.017]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:40.017]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:40.017]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:40.017]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:40.017]  - attr(*, "resolved")= logi FALSE
[08:26:40.017]  - attr(*, "total_size")= num 5632
[08:26:40.017]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:40.017]  - attr(*, "already-done")= logi TRUE
[08:26:40.025] - reassign environment for ‘...future.FUN’
[08:26:40.026] - copied ‘...future.FUN’ to environment
[08:26:40.026] - copied ‘future.call.arguments’ to environment
[08:26:40.026] - copied ‘...future.elements_ii’ to environment
[08:26:40.026] - copied ‘...future.seeds_ii’ to environment
[08:26:40.026] - copied ‘...future.globals.maxSize’ to environment
[08:26:40.026] assign_globals() ... done
[08:26:40.026] plan(): Setting new future strategy stack:
[08:26:40.026] List of future strategies:
[08:26:40.026] 1. sequential:
[08:26:40.026]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:40.026]    - tweaked: FALSE
[08:26:40.026]    - call: NULL
[08:26:40.027] plan(): nbrOfWorkers() = 1
[08:26:40.529] plan(): Setting new future strategy stack:
[08:26:40.529] List of future strategies:
[08:26:40.529] 1. multisession:
[08:26:40.529]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:40.529]    - tweaked: FALSE
[08:26:40.529]    - call: plan(strategy)
[08:26:40.531] plan(): nbrOfWorkers() = 1
[08:26:40.531] SequentialFuture started (and completed)
[08:26:40.531] - Launch lazy future ... done
[08:26:40.531] run() for ‘SequentialFuture’ ... done
[08:26:40.532] Created future:
[08:26:40.532] SequentialFuture:
[08:26:40.532] Label: ‘future_lapply-1’
[08:26:40.532] Expression:
[08:26:40.532] {
[08:26:40.532]     do.call(function(...) {
[08:26:40.532]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:40.532]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:40.532]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:40.532]             on.exit(options(oopts), add = TRUE)
[08:26:40.532]         }
[08:26:40.532]         {
[08:26:40.532]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:40.532]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:40.532]                 ...future.FUN(...future.X_jj, ...)
[08:26:40.532]             })
[08:26:40.532]         }
[08:26:40.532]     }, args = future.call.arguments)
[08:26:40.532] }
[08:26:40.532] Lazy evaluation: FALSE
[08:26:40.532] Asynchronous evaluation: FALSE
[08:26:40.532] Local evaluation: TRUE
[08:26:40.532] Environment: R_GlobalEnv
[08:26:40.532] Capture standard output: TRUE
[08:26:40.532] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:40.532] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:40.532] Packages: <none>
[08:26:40.532] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:40.532] Resolved: TRUE
[08:26:40.532] Value: 55 bytes of class ‘list’
[08:26:40.532] Early signaling: FALSE
[08:26:40.532] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:40.532] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:40.533] Chunk #1 of 1 ... DONE
[08:26:40.533] Launching 1 futures (chunks) ... DONE
[08:26:40.533] Resolving 1 futures (chunks) ...
[08:26:40.533] resolve() on list ...
[08:26:40.533]  recursive: 0
[08:26:40.533]  length: 1
[08:26:40.533] 
[08:26:40.533] resolved() for ‘SequentialFuture’ ...
[08:26:40.533] - state: ‘finished’
[08:26:40.533] - run: TRUE
[08:26:40.534] - result: ‘FutureResult’
[08:26:40.534] resolved() for ‘SequentialFuture’ ... done
[08:26:40.534] Future #1
[08:26:40.534] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:40.534] - nx: 1
[08:26:40.534] - relay: TRUE
[08:26:40.534] - stdout: TRUE
[08:26:40.534] - signal: TRUE
[08:26:40.534] - resignal: FALSE
[08:26:40.534] - force: TRUE
[08:26:40.534] - relayed: [n=1] FALSE
[08:26:40.535] - queued futures: [n=1] FALSE
[08:26:40.535]  - until=1
[08:26:40.535]  - relaying element #1
[08:26:40.535] - relayed: [n=1] TRUE
[08:26:40.535] - queued futures: [n=1] TRUE
[08:26:40.535] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:40.535]  length: 0 (resolved future 1)
[08:26:40.535] Relaying remaining futures
[08:26:40.535] signalConditionsASAP(NULL, pos=0) ...
[08:26:40.535] - nx: 1
[08:26:40.536] - relay: TRUE
[08:26:40.536] - stdout: TRUE
[08:26:40.536] - signal: TRUE
[08:26:40.536] - resignal: FALSE
[08:26:40.536] - force: TRUE
[08:26:40.536] - relayed: [n=1] TRUE
[08:26:40.536] - queued futures: [n=1] TRUE
 - flush all
[08:26:40.536] - relayed: [n=1] TRUE
[08:26:40.536] - queued futures: [n=1] TRUE
[08:26:40.536] signalConditionsASAP(NULL, pos=0) ... done
[08:26:40.537] resolve() on list ... DONE
[08:26:40.537]  - Number of value chunks collected: 1
[08:26:40.537] Resolving 1 futures (chunks) ... DONE
[08:26:40.537] Reducing values from 1 chunks ...
[08:26:40.537]  - Number of values collected after concatenation: 2
[08:26:40.537]  - Number of values expected: 2
[08:26:40.537] Reducing values from 1 chunks ... DONE
[08:26:40.537] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[08:26:40.538] future_lapply() ...
[08:26:40.540] Number of chunks: 1
[08:26:40.540] getGlobalsAndPackagesXApply() ...
[08:26:40.540]  - future.globals: TRUE
[08:26:40.540] getGlobalsAndPackages() ...
[08:26:40.540] Searching for globals...
[08:26:40.542] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:40.542] Searching for globals ... DONE
[08:26:40.542] Resolving globals: FALSE
[08:26:40.543] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:40.543] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:40.543] - globals: [1] ‘FUN’
[08:26:40.543] 
[08:26:40.543] getGlobalsAndPackages() ... DONE
[08:26:40.543]  - globals found/used: [n=1] ‘FUN’
[08:26:40.543]  - needed namespaces: [n=0] 
[08:26:40.544] Finding globals ... DONE
[08:26:40.544]  - use_args: TRUE
[08:26:40.544]  - Getting '...' globals ...
[08:26:40.544] resolve() on list ...
[08:26:40.544]  recursive: 0
[08:26:40.544]  length: 1
[08:26:40.544]  elements: ‘...’
[08:26:40.545]  length: 0 (resolved future 1)
[08:26:40.545] resolve() on list ... DONE
[08:26:40.545]    - '...' content: [n=0] 
[08:26:40.545] List of 1
[08:26:40.545]  $ ...: list()
[08:26:40.545]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:40.545]  - attr(*, "where")=List of 1
[08:26:40.545]   ..$ ...:<environment: 0x55e10e17e220> 
[08:26:40.545]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:40.545]  - attr(*, "resolved")= logi TRUE
[08:26:40.545]  - attr(*, "total_size")= num NA
[08:26:40.548]  - Getting '...' globals ... DONE
[08:26:40.548] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:40.548] List of 2
[08:26:40.548]  $ ...future.FUN:function (x)  
[08:26:40.548]  $ ...          : list()
[08:26:40.548]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:40.548]  - attr(*, "where")=List of 2
[08:26:40.548]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:40.548]   ..$ ...          :<environment: 0x55e10e17e220> 
[08:26:40.548]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:40.548]  - attr(*, "resolved")= logi FALSE
[08:26:40.548]  - attr(*, "total_size")= num 5632
[08:26:40.552] Packages to be attached in all futures: [n=0] 
[08:26:40.553] getGlobalsAndPackagesXApply() ... DONE
[08:26:40.553] Number of futures (= number of chunks): 1
[08:26:40.553] Launching 1 futures (chunks) ...
[08:26:40.553] Chunk #1 of 1 ...
[08:26:40.553]  - Finding globals in 'X' for chunk #1 ...
[08:26:40.553] getGlobalsAndPackages() ...
[08:26:40.554] Searching for globals...
[08:26:40.554] 
[08:26:40.554] Searching for globals ... DONE
[08:26:40.554] - globals: [0] <none>
[08:26:40.554] getGlobalsAndPackages() ... DONE
[08:26:40.554]    + additional globals found: [n=0] 
[08:26:40.555]    + additional namespaces needed: [n=0] 
[08:26:40.555]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:40.555]  - seeds: <none>
[08:26:40.555]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:40.555] getGlobalsAndPackages() ...
[08:26:40.555] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:40.555] Resolving globals: FALSE
[08:26:40.555] Tweak future expression to call with '...' arguments ...
[08:26:40.555] {
[08:26:40.555]     do.call(function(...) {
[08:26:40.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:40.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:40.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:40.555]             on.exit(options(oopts), add = TRUE)
[08:26:40.555]         }
[08:26:40.555]         {
[08:26:40.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:40.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:40.555]                 ...future.FUN(...future.X_jj, ...)
[08:26:40.555]             })
[08:26:40.555]         }
[08:26:40.555]     }, args = future.call.arguments)
[08:26:40.555] }
[08:26:40.556] Tweak future expression to call with '...' arguments ... DONE
[08:26:40.556] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:40.556] 
[08:26:40.556] getGlobalsAndPackages() ... DONE
[08:26:40.557] run() for ‘Future’ ...
[08:26:40.557] - state: ‘created’
[08:26:40.557] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:40.559] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:40.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:40.559]   - Field: ‘label’
[08:26:40.559]   - Field: ‘local’
[08:26:40.559]   - Field: ‘owner’
[08:26:40.559]   - Field: ‘envir’
[08:26:40.559]   - Field: ‘packages’
[08:26:40.559]   - Field: ‘gc’
[08:26:40.559]   - Field: ‘conditions’
[08:26:40.559]   - Field: ‘expr’
[08:26:40.560]   - Field: ‘uuid’
[08:26:40.560]   - Field: ‘seed’
[08:26:40.560]   - Field: ‘version’
[08:26:40.560]   - Field: ‘result’
[08:26:40.560]   - Field: ‘asynchronous’
[08:26:40.560]   - Field: ‘calls’
[08:26:40.560]   - Field: ‘globals’
[08:26:40.560]   - Field: ‘stdout’
[08:26:40.560]   - Field: ‘earlySignal’
[08:26:40.560]   - Field: ‘lazy’
[08:26:40.560]   - Field: ‘state’
[08:26:40.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:40.561] - Launch lazy future ...
[08:26:40.561] Packages needed by the future expression (n = 0): <none>
[08:26:40.561] Packages needed by future strategies (n = 0): <none>
[08:26:40.561] {
[08:26:40.561]     {
[08:26:40.561]         {
[08:26:40.561]             ...future.startTime <- base::Sys.time()
[08:26:40.561]             {
[08:26:40.561]                 {
[08:26:40.561]                   {
[08:26:40.561]                     base::local({
[08:26:40.561]                       has_future <- base::requireNamespace("future", 
[08:26:40.561]                         quietly = TRUE)
[08:26:40.561]                       if (has_future) {
[08:26:40.561]                         ns <- base::getNamespace("future")
[08:26:40.561]                         version <- ns[[".package"]][["version"]]
[08:26:40.561]                         if (is.null(version)) 
[08:26:40.561]                           version <- utils::packageVersion("future")
[08:26:40.561]                       }
[08:26:40.561]                       else {
[08:26:40.561]                         version <- NULL
[08:26:40.561]                       }
[08:26:40.561]                       if (!has_future || version < "1.8.0") {
[08:26:40.561]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:40.561]                           "", base::R.version$version.string), 
[08:26:40.561]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:40.561]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:40.561]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:40.561]                             "release", "version")], collapse = " "), 
[08:26:40.561]                           hostname = base::Sys.info()[["nodename"]])
[08:26:40.561]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:40.561]                           info)
[08:26:40.561]                         info <- base::paste(info, collapse = "; ")
[08:26:40.561]                         if (!has_future) {
[08:26:40.561]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:40.561]                             info)
[08:26:40.561]                         }
[08:26:40.561]                         else {
[08:26:40.561]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:40.561]                             info, version)
[08:26:40.561]                         }
[08:26:40.561]                         base::stop(msg)
[08:26:40.561]                       }
[08:26:40.561]                     })
[08:26:40.561]                   }
[08:26:40.561]                   ...future.strategy.old <- future::plan("list")
[08:26:40.561]                   options(future.plan = NULL)
[08:26:40.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:40.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:40.561]                 }
[08:26:40.561]                 ...future.workdir <- getwd()
[08:26:40.561]             }
[08:26:40.561]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:40.561]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:40.561]         }
[08:26:40.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:40.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:40.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:40.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:40.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:40.561]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:40.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:40.561]             base::names(...future.oldOptions))
[08:26:40.561]     }
[08:26:40.561]     if (TRUE) {
[08:26:40.561]     }
[08:26:40.561]     else {
[08:26:40.561]         if (NA) {
[08:26:40.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:40.561]                 open = "w")
[08:26:40.561]         }
[08:26:40.561]         else {
[08:26:40.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:40.561]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:40.561]         }
[08:26:40.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:40.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:40.561]             base::sink(type = "output", split = FALSE)
[08:26:40.561]             base::close(...future.stdout)
[08:26:40.561]         }, add = TRUE)
[08:26:40.561]     }
[08:26:40.561]     ...future.frame <- base::sys.nframe()
[08:26:40.561]     ...future.conditions <- base::list()
[08:26:40.561]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:40.561]     if (FALSE) {
[08:26:40.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:40.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:40.561]     }
[08:26:40.561]     ...future.result <- base::tryCatch({
[08:26:40.561]         base::withCallingHandlers({
[08:26:40.561]             ...future.value <- base::withVisible(base::local({
[08:26:40.561]                 do.call(function(...) {
[08:26:40.561]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:40.561]                   if (!identical(...future.globals.maxSize.org, 
[08:26:40.561]                     ...future.globals.maxSize)) {
[08:26:40.561]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:40.561]                     on.exit(options(oopts), add = TRUE)
[08:26:40.561]                   }
[08:26:40.561]                   {
[08:26:40.561]                     lapply(seq_along(...future.elements_ii), 
[08:26:40.561]                       FUN = function(jj) {
[08:26:40.561]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:40.561]                         ...future.FUN(...future.X_jj, ...)
[08:26:40.561]                       })
[08:26:40.561]                   }
[08:26:40.561]                 }, args = future.call.arguments)
[08:26:40.561]             }))
[08:26:40.561]             future::FutureResult(value = ...future.value$value, 
[08:26:40.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:40.561]                   ...future.rng), globalenv = if (FALSE) 
[08:26:40.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:40.561]                     ...future.globalenv.names))
[08:26:40.561]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:40.561]         }, condition = base::local({
[08:26:40.561]             c <- base::c
[08:26:40.561]             inherits <- base::inherits
[08:26:40.561]             invokeRestart <- base::invokeRestart
[08:26:40.561]             length <- base::length
[08:26:40.561]             list <- base::list
[08:26:40.561]             seq.int <- base::seq.int
[08:26:40.561]             signalCondition <- base::signalCondition
[08:26:40.561]             sys.calls <- base::sys.calls
[08:26:40.561]             `[[` <- base::`[[`
[08:26:40.561]             `+` <- base::`+`
[08:26:40.561]             `<<-` <- base::`<<-`
[08:26:40.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:40.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:40.561]                   3L)]
[08:26:40.561]             }
[08:26:40.561]             function(cond) {
[08:26:40.561]                 is_error <- inherits(cond, "error")
[08:26:40.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:40.561]                   NULL)
[08:26:40.561]                 if (is_error) {
[08:26:40.561]                   sessionInformation <- function() {
[08:26:40.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:40.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:40.561]                       search = base::search(), system = base::Sys.info())
[08:26:40.561]                   }
[08:26:40.561]                   ...future.conditions[[length(...future.conditions) + 
[08:26:40.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:40.561]                     cond$call), session = sessionInformation(), 
[08:26:40.561]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:40.561]                   signalCondition(cond)
[08:26:40.561]                 }
[08:26:40.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:40.561]                 "immediateCondition"))) {
[08:26:40.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:40.561]                   ...future.conditions[[length(...future.conditions) + 
[08:26:40.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:40.561]                   if (TRUE && !signal) {
[08:26:40.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:40.561]                     {
[08:26:40.561]                       inherits <- base::inherits
[08:26:40.561]                       invokeRestart <- base::invokeRestart
[08:26:40.561]                       is.null <- base::is.null
[08:26:40.561]                       muffled <- FALSE
[08:26:40.561]                       if (inherits(cond, "message")) {
[08:26:40.561]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:40.561]                         if (muffled) 
[08:26:40.561]                           invokeRestart("muffleMessage")
[08:26:40.561]                       }
[08:26:40.561]                       else if (inherits(cond, "warning")) {
[08:26:40.561]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:40.561]                         if (muffled) 
[08:26:40.561]                           invokeRestart("muffleWarning")
[08:26:40.561]                       }
[08:26:40.561]                       else if (inherits(cond, "condition")) {
[08:26:40.561]                         if (!is.null(pattern)) {
[08:26:40.561]                           computeRestarts <- base::computeRestarts
[08:26:40.561]                           grepl <- base::grepl
[08:26:40.561]                           restarts <- computeRestarts(cond)
[08:26:40.561]                           for (restart in restarts) {
[08:26:40.561]                             name <- restart$name
[08:26:40.561]                             if (is.null(name)) 
[08:26:40.561]                               next
[08:26:40.561]                             if (!grepl(pattern, name)) 
[08:26:40.561]                               next
[08:26:40.561]                             invokeRestart(restart)
[08:26:40.561]                             muffled <- TRUE
[08:26:40.561]                             break
[08:26:40.561]                           }
[08:26:40.561]                         }
[08:26:40.561]                       }
[08:26:40.561]                       invisible(muffled)
[08:26:40.561]                     }
[08:26:40.561]                     muffleCondition(cond, pattern = "^muffle")
[08:26:40.561]                   }
[08:26:40.561]                 }
[08:26:40.561]                 else {
[08:26:40.561]                   if (TRUE) {
[08:26:40.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:40.561]                     {
[08:26:40.561]                       inherits <- base::inherits
[08:26:40.561]                       invokeRestart <- base::invokeRestart
[08:26:40.561]                       is.null <- base::is.null
[08:26:40.561]                       muffled <- FALSE
[08:26:40.561]                       if (inherits(cond, "message")) {
[08:26:40.561]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:40.561]                         if (muffled) 
[08:26:40.561]                           invokeRestart("muffleMessage")
[08:26:40.561]                       }
[08:26:40.561]                       else if (inherits(cond, "warning")) {
[08:26:40.561]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:40.561]                         if (muffled) 
[08:26:40.561]                           invokeRestart("muffleWarning")
[08:26:40.561]                       }
[08:26:40.561]                       else if (inherits(cond, "condition")) {
[08:26:40.561]                         if (!is.null(pattern)) {
[08:26:40.561]                           computeRestarts <- base::computeRestarts
[08:26:40.561]                           grepl <- base::grepl
[08:26:40.561]                           restarts <- computeRestarts(cond)
[08:26:40.561]                           for (restart in restarts) {
[08:26:40.561]                             name <- restart$name
[08:26:40.561]                             if (is.null(name)) 
[08:26:40.561]                               next
[08:26:40.561]                             if (!grepl(pattern, name)) 
[08:26:40.561]                               next
[08:26:40.561]                             invokeRestart(restart)
[08:26:40.561]                             muffled <- TRUE
[08:26:40.561]                             break
[08:26:40.561]                           }
[08:26:40.561]                         }
[08:26:40.561]                       }
[08:26:40.561]                       invisible(muffled)
[08:26:40.561]                     }
[08:26:40.561]                     muffleCondition(cond, pattern = "^muffle")
[08:26:40.561]                   }
[08:26:40.561]                 }
[08:26:40.561]             }
[08:26:40.561]         }))
[08:26:40.561]     }, error = function(ex) {
[08:26:40.561]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:40.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:40.561]                 ...future.rng), started = ...future.startTime, 
[08:26:40.561]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:40.561]             version = "1.8"), class = "FutureResult")
[08:26:40.561]     }, finally = {
[08:26:40.561]         if (!identical(...future.workdir, getwd())) 
[08:26:40.561]             setwd(...future.workdir)
[08:26:40.561]         {
[08:26:40.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:40.561]                 ...future.oldOptions$nwarnings <- NULL
[08:26:40.561]             }
[08:26:40.561]             base::options(...future.oldOptions)
[08:26:40.561]             if (.Platform$OS.type == "windows") {
[08:26:40.561]                 old_names <- names(...future.oldEnvVars)
[08:26:40.561]                 envs <- base::Sys.getenv()
[08:26:40.561]                 names <- names(envs)
[08:26:40.561]                 common <- intersect(names, old_names)
[08:26:40.561]                 added <- setdiff(names, old_names)
[08:26:40.561]                 removed <- setdiff(old_names, names)
[08:26:40.561]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:40.561]                   envs[common]]
[08:26:40.561]                 NAMES <- toupper(changed)
[08:26:40.561]                 args <- list()
[08:26:40.561]                 for (kk in seq_along(NAMES)) {
[08:26:40.561]                   name <- changed[[kk]]
[08:26:40.561]                   NAME <- NAMES[[kk]]
[08:26:40.561]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:40.561]                     next
[08:26:40.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:40.561]                 }
[08:26:40.561]                 NAMES <- toupper(added)
[08:26:40.561]                 for (kk in seq_along(NAMES)) {
[08:26:40.561]                   name <- added[[kk]]
[08:26:40.561]                   NAME <- NAMES[[kk]]
[08:26:40.561]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:40.561]                     next
[08:26:40.561]                   args[[name]] <- ""
[08:26:40.561]                 }
[08:26:40.561]                 NAMES <- toupper(removed)
[08:26:40.561]                 for (kk in seq_along(NAMES)) {
[08:26:40.561]                   name <- removed[[kk]]
[08:26:40.561]                   NAME <- NAMES[[kk]]
[08:26:40.561]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:40.561]                     next
[08:26:40.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:40.561]                 }
[08:26:40.561]                 if (length(args) > 0) 
[08:26:40.561]                   base::do.call(base::Sys.setenv, args = args)
[08:26:40.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:40.561]             }
[08:26:40.561]             else {
[08:26:40.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:40.561]             }
[08:26:40.561]             {
[08:26:40.561]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:40.561]                   0L) {
[08:26:40.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:40.561]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:40.561]                   base::options(opts)
[08:26:40.561]                 }
[08:26:40.561]                 {
[08:26:40.561]                   {
[08:26:40.561]                     NULL
[08:26:40.561]                     RNGkind("Mersenne-Twister")
[08:26:40.561]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:40.561]                       inherits = FALSE)
[08:26:40.561]                   }
[08:26:40.561]                   options(future.plan = NULL)
[08:26:40.561]                   if (is.na(NA_character_)) 
[08:26:40.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:40.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:40.561]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:40.561]                     .init = FALSE)
[08:26:40.561]                 }
[08:26:40.561]             }
[08:26:40.561]         }
[08:26:40.561]     })
[08:26:40.561]     if (FALSE) {
[08:26:40.561]         base::sink(type = "output", split = FALSE)
[08:26:40.561]         if (NA) {
[08:26:40.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:40.561]         }
[08:26:40.561]         else {
[08:26:40.561]             ...future.result["stdout"] <- base::list(NULL)
[08:26:40.561]         }
[08:26:40.561]         base::close(...future.stdout)
[08:26:40.561]         ...future.stdout <- NULL
[08:26:40.561]     }
[08:26:40.561]     ...future.result$conditions <- ...future.conditions
[08:26:40.561]     ...future.result$finished <- base::Sys.time()
[08:26:40.561]     ...future.result
[08:26:40.561] }
[08:26:40.563] assign_globals() ...
[08:26:40.563] List of 5
[08:26:40.563]  $ ...future.FUN            :function (x)  
[08:26:40.563]  $ future.call.arguments    : list()
[08:26:40.563]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:40.563]  $ ...future.elements_ii    :List of 2
[08:26:40.563]   ..$ : int 1
[08:26:40.563]   ..$ : int 0
[08:26:40.563]  $ ...future.seeds_ii       : NULL
[08:26:40.563]  $ ...future.globals.maxSize: NULL
[08:26:40.563]  - attr(*, "where")=List of 5
[08:26:40.563]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:40.563]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:40.563]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:40.563]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:40.563]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:40.563]  - attr(*, "resolved")= logi FALSE
[08:26:40.563]  - attr(*, "total_size")= num 5632
[08:26:40.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:40.563]  - attr(*, "already-done")= logi TRUE
[08:26:40.568] - reassign environment for ‘...future.FUN’
[08:26:40.569] - copied ‘...future.FUN’ to environment
[08:26:40.569] - copied ‘future.call.arguments’ to environment
[08:26:40.569] - copied ‘...future.elements_ii’ to environment
[08:26:40.569] - copied ‘...future.seeds_ii’ to environment
[08:26:40.569] - copied ‘...future.globals.maxSize’ to environment
[08:26:40.569] assign_globals() ... done
[08:26:40.569] plan(): Setting new future strategy stack:
[08:26:40.569] List of future strategies:
[08:26:40.569] 1. sequential:
[08:26:40.569]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:40.569]    - tweaked: FALSE
[08:26:40.569]    - call: NULL
[08:26:40.570] plan(): nbrOfWorkers() = 1
[08:26:41.072] plan(): Setting new future strategy stack:
[08:26:41.072] List of future strategies:
[08:26:41.072] 1. multisession:
[08:26:41.072]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:41.072]    - tweaked: FALSE
[08:26:41.072]    - call: plan(strategy)
[08:26:41.074] plan(): nbrOfWorkers() = 1
[08:26:41.074] SequentialFuture started (and completed)
[08:26:41.074] - Launch lazy future ... done
[08:26:41.074] run() for ‘SequentialFuture’ ... done
[08:26:41.074] Created future:
[08:26:41.074] SequentialFuture:
[08:26:41.074] Label: ‘future_lapply-1’
[08:26:41.074] Expression:
[08:26:41.074] {
[08:26:41.074]     do.call(function(...) {
[08:26:41.074]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:41.074]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:41.074]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:41.074]             on.exit(options(oopts), add = TRUE)
[08:26:41.074]         }
[08:26:41.074]         {
[08:26:41.074]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:41.074]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:41.074]                 ...future.FUN(...future.X_jj, ...)
[08:26:41.074]             })
[08:26:41.074]         }
[08:26:41.074]     }, args = future.call.arguments)
[08:26:41.074] }
[08:26:41.074] Lazy evaluation: FALSE
[08:26:41.074] Asynchronous evaluation: FALSE
[08:26:41.074] Local evaluation: TRUE
[08:26:41.074] Environment: R_GlobalEnv
[08:26:41.074] Capture standard output: NA
[08:26:41.074] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:41.074] Globals: 5 objects totaling 1.02 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:41.074] Packages: <none>
[08:26:41.074] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:41.074] Resolved: TRUE
[08:26:41.074] Value: 55 bytes of class ‘list’
[08:26:41.074] Early signaling: FALSE
[08:26:41.074] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:41.074] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:41.075] Chunk #1 of 1 ... DONE
[08:26:41.075] Launching 1 futures (chunks) ... DONE
[08:26:41.076] Resolving 1 futures (chunks) ...
[08:26:41.076] resolve() on list ...
[08:26:41.076]  recursive: 0
[08:26:41.076]  length: 1
[08:26:41.076] 
[08:26:41.076] resolved() for ‘SequentialFuture’ ...
[08:26:41.076] - state: ‘finished’
[08:26:41.076] - run: TRUE
[08:26:41.076] - result: ‘FutureResult’
[08:26:41.076] resolved() for ‘SequentialFuture’ ... done
[08:26:41.076] Future #1
[08:26:41.077] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:41.077] - nx: 1
[08:26:41.077] - relay: TRUE
[08:26:41.077] - stdout: TRUE
[08:26:41.077] - signal: TRUE
[08:26:41.077] - resignal: FALSE
[08:26:41.077] - force: TRUE
[08:26:41.077] - relayed: [n=1] FALSE
[08:26:41.077] - queued futures: [n=1] FALSE
[08:26:41.077]  - until=1
[08:26:41.077]  - relaying element #1
[08:26:41.078] - relayed: [n=1] TRUE
[08:26:41.078] - queued futures: [n=1] TRUE
[08:26:41.078] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:41.078]  length: 0 (resolved future 1)
[08:26:41.078] Relaying remaining futures
[08:26:41.078] signalConditionsASAP(NULL, pos=0) ...
[08:26:41.078] - nx: 1
[08:26:41.078] - relay: TRUE
[08:26:41.078] - stdout: TRUE
[08:26:41.079] - signal: TRUE
[08:26:41.079] - resignal: FALSE
[08:26:41.079] - force: TRUE
[08:26:41.079] - relayed: [n=1] TRUE
[08:26:41.079] - queued futures: [n=1] TRUE
 - flush all
[08:26:41.079] - relayed: [n=1] TRUE
[08:26:41.079] - queued futures: [n=1] TRUE
[08:26:41.079] signalConditionsASAP(NULL, pos=0) ... done
[08:26:41.079] resolve() on list ... DONE
[08:26:41.079]  - Number of value chunks collected: 1
[08:26:41.079] Resolving 1 futures (chunks) ... DONE
[08:26:41.080] Reducing values from 1 chunks ...
[08:26:41.080]  - Number of values collected after concatenation: 2
[08:26:41.080]  - Number of values expected: 2
[08:26:41.080] Reducing values from 1 chunks ... DONE
[08:26:41.080] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[08:26:41.080] future_mapply() ...
[08:26:41.082] Number of chunks: 1
[08:26:41.082] getGlobalsAndPackagesXApply() ...
[08:26:41.082]  - future.globals: TRUE
[08:26:41.082] getGlobalsAndPackages() ...
[08:26:41.084] Searching for globals...
[08:26:41.087] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:41.087] Searching for globals ... DONE
[08:26:41.087] Resolving globals: FALSE
[08:26:41.087] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:41.088] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:41.088] - globals: [1] ‘FUN’
[08:26:41.088] 
[08:26:41.088] getGlobalsAndPackages() ... DONE
[08:26:41.088]  - globals found/used: [n=1] ‘FUN’
[08:26:41.088]  - needed namespaces: [n=0] 
[08:26:41.088] Finding globals ... DONE
[08:26:41.089] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:41.089] List of 2
[08:26:41.089]  $ ...future.FUN:function (x, y)  
[08:26:41.089]  $ MoreArgs     : NULL
[08:26:41.089]  - attr(*, "where")=List of 2
[08:26:41.089]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:41.089]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:41.089]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:41.089]  - attr(*, "resolved")= logi FALSE
[08:26:41.089]  - attr(*, "total_size")= num NA
[08:26:41.091] Packages to be attached in all futures: [n=0] 
[08:26:41.092] getGlobalsAndPackagesXApply() ... DONE
[08:26:41.092] Number of futures (= number of chunks): 1
[08:26:41.092] Launching 1 futures (chunks) ...
[08:26:41.092] Chunk #1 of 1 ...
[08:26:41.092]  - Finding globals in '...' for chunk #1 ...
[08:26:41.092] getGlobalsAndPackages() ...
[08:26:41.092] Searching for globals...
[08:26:41.093] 
[08:26:41.093] Searching for globals ... DONE
[08:26:41.093] - globals: [0] <none>
[08:26:41.093] getGlobalsAndPackages() ... DONE
[08:26:41.093]    + additional globals found: [n=0] 
[08:26:41.093]    + additional namespaces needed: [n=0] 
[08:26:41.093]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:41.093]  - seeds: <none>
[08:26:41.093]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:41.093] getGlobalsAndPackages() ...
[08:26:41.094] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:41.094] Resolving globals: FALSE
[08:26:41.094] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[08:26:41.095] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:41.095] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:41.095] 
[08:26:41.095] getGlobalsAndPackages() ... DONE
[08:26:41.095] run() for ‘Future’ ...
[08:26:41.095] - state: ‘created’
[08:26:41.095] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:41.097] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:41.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:41.097]   - Field: ‘label’
[08:26:41.098]   - Field: ‘local’
[08:26:41.098]   - Field: ‘owner’
[08:26:41.098]   - Field: ‘envir’
[08:26:41.098]   - Field: ‘packages’
[08:26:41.098]   - Field: ‘gc’
[08:26:41.098]   - Field: ‘conditions’
[08:26:41.098]   - Field: ‘expr’
[08:26:41.098]   - Field: ‘uuid’
[08:26:41.098]   - Field: ‘seed’
[08:26:41.098]   - Field: ‘version’
[08:26:41.098]   - Field: ‘result’
[08:26:41.099]   - Field: ‘asynchronous’
[08:26:41.099]   - Field: ‘calls’
[08:26:41.099]   - Field: ‘globals’
[08:26:41.099]   - Field: ‘stdout’
[08:26:41.099]   - Field: ‘earlySignal’
[08:26:41.099]   - Field: ‘lazy’
[08:26:41.099]   - Field: ‘state’
[08:26:41.099] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:41.099] - Launch lazy future ...
[08:26:41.099] Packages needed by the future expression (n = 0): <none>
[08:26:41.100] Packages needed by future strategies (n = 0): <none>
[08:26:41.100] {
[08:26:41.100]     {
[08:26:41.100]         {
[08:26:41.100]             ...future.startTime <- base::Sys.time()
[08:26:41.100]             {
[08:26:41.100]                 {
[08:26:41.100]                   {
[08:26:41.100]                     base::local({
[08:26:41.100]                       has_future <- base::requireNamespace("future", 
[08:26:41.100]                         quietly = TRUE)
[08:26:41.100]                       if (has_future) {
[08:26:41.100]                         ns <- base::getNamespace("future")
[08:26:41.100]                         version <- ns[[".package"]][["version"]]
[08:26:41.100]                         if (is.null(version)) 
[08:26:41.100]                           version <- utils::packageVersion("future")
[08:26:41.100]                       }
[08:26:41.100]                       else {
[08:26:41.100]                         version <- NULL
[08:26:41.100]                       }
[08:26:41.100]                       if (!has_future || version < "1.8.0") {
[08:26:41.100]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:41.100]                           "", base::R.version$version.string), 
[08:26:41.100]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:41.100]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:41.100]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:41.100]                             "release", "version")], collapse = " "), 
[08:26:41.100]                           hostname = base::Sys.info()[["nodename"]])
[08:26:41.100]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:41.100]                           info)
[08:26:41.100]                         info <- base::paste(info, collapse = "; ")
[08:26:41.100]                         if (!has_future) {
[08:26:41.100]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:41.100]                             info)
[08:26:41.100]                         }
[08:26:41.100]                         else {
[08:26:41.100]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:41.100]                             info, version)
[08:26:41.100]                         }
[08:26:41.100]                         base::stop(msg)
[08:26:41.100]                       }
[08:26:41.100]                     })
[08:26:41.100]                   }
[08:26:41.100]                   ...future.strategy.old <- future::plan("list")
[08:26:41.100]                   options(future.plan = NULL)
[08:26:41.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:41.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:41.100]                 }
[08:26:41.100]                 ...future.workdir <- getwd()
[08:26:41.100]             }
[08:26:41.100]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:41.100]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:41.100]         }
[08:26:41.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:41.100]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:41.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:41.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:41.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:41.100]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:41.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:41.100]             base::names(...future.oldOptions))
[08:26:41.100]     }
[08:26:41.100]     if (FALSE) {
[08:26:41.100]     }
[08:26:41.100]     else {
[08:26:41.100]         if (FALSE) {
[08:26:41.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:41.100]                 open = "w")
[08:26:41.100]         }
[08:26:41.100]         else {
[08:26:41.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:41.100]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:41.100]         }
[08:26:41.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:41.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:41.100]             base::sink(type = "output", split = FALSE)
[08:26:41.100]             base::close(...future.stdout)
[08:26:41.100]         }, add = TRUE)
[08:26:41.100]     }
[08:26:41.100]     ...future.frame <- base::sys.nframe()
[08:26:41.100]     ...future.conditions <- base::list()
[08:26:41.100]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:41.100]     if (FALSE) {
[08:26:41.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:41.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:41.100]     }
[08:26:41.100]     ...future.result <- base::tryCatch({
[08:26:41.100]         base::withCallingHandlers({
[08:26:41.100]             ...future.value <- base::withVisible(base::local({
[08:26:41.100]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:41.100]                 if (!identical(...future.globals.maxSize.org, 
[08:26:41.100]                   ...future.globals.maxSize)) {
[08:26:41.100]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:41.100]                   on.exit(options(oopts), add = TRUE)
[08:26:41.100]                 }
[08:26:41.100]                 {
[08:26:41.100]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:41.100]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:41.100]                     USE.NAMES = FALSE)
[08:26:41.100]                   do.call(mapply, args = args)
[08:26:41.100]                 }
[08:26:41.100]             }))
[08:26:41.100]             future::FutureResult(value = ...future.value$value, 
[08:26:41.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:41.100]                   ...future.rng), globalenv = if (FALSE) 
[08:26:41.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:41.100]                     ...future.globalenv.names))
[08:26:41.100]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:41.100]         }, condition = base::local({
[08:26:41.100]             c <- base::c
[08:26:41.100]             inherits <- base::inherits
[08:26:41.100]             invokeRestart <- base::invokeRestart
[08:26:41.100]             length <- base::length
[08:26:41.100]             list <- base::list
[08:26:41.100]             seq.int <- base::seq.int
[08:26:41.100]             signalCondition <- base::signalCondition
[08:26:41.100]             sys.calls <- base::sys.calls
[08:26:41.100]             `[[` <- base::`[[`
[08:26:41.100]             `+` <- base::`+`
[08:26:41.100]             `<<-` <- base::`<<-`
[08:26:41.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:41.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:41.100]                   3L)]
[08:26:41.100]             }
[08:26:41.100]             function(cond) {
[08:26:41.100]                 is_error <- inherits(cond, "error")
[08:26:41.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:41.100]                   NULL)
[08:26:41.100]                 if (is_error) {
[08:26:41.100]                   sessionInformation <- function() {
[08:26:41.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:41.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:41.100]                       search = base::search(), system = base::Sys.info())
[08:26:41.100]                   }
[08:26:41.100]                   ...future.conditions[[length(...future.conditions) + 
[08:26:41.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:41.100]                     cond$call), session = sessionInformation(), 
[08:26:41.100]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:41.100]                   signalCondition(cond)
[08:26:41.100]                 }
[08:26:41.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:41.100]                 "immediateCondition"))) {
[08:26:41.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:41.100]                   ...future.conditions[[length(...future.conditions) + 
[08:26:41.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:41.100]                   if (TRUE && !signal) {
[08:26:41.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:41.100]                     {
[08:26:41.100]                       inherits <- base::inherits
[08:26:41.100]                       invokeRestart <- base::invokeRestart
[08:26:41.100]                       is.null <- base::is.null
[08:26:41.100]                       muffled <- FALSE
[08:26:41.100]                       if (inherits(cond, "message")) {
[08:26:41.100]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:41.100]                         if (muffled) 
[08:26:41.100]                           invokeRestart("muffleMessage")
[08:26:41.100]                       }
[08:26:41.100]                       else if (inherits(cond, "warning")) {
[08:26:41.100]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:41.100]                         if (muffled) 
[08:26:41.100]                           invokeRestart("muffleWarning")
[08:26:41.100]                       }
[08:26:41.100]                       else if (inherits(cond, "condition")) {
[08:26:41.100]                         if (!is.null(pattern)) {
[08:26:41.100]                           computeRestarts <- base::computeRestarts
[08:26:41.100]                           grepl <- base::grepl
[08:26:41.100]                           restarts <- computeRestarts(cond)
[08:26:41.100]                           for (restart in restarts) {
[08:26:41.100]                             name <- restart$name
[08:26:41.100]                             if (is.null(name)) 
[08:26:41.100]                               next
[08:26:41.100]                             if (!grepl(pattern, name)) 
[08:26:41.100]                               next
[08:26:41.100]                             invokeRestart(restart)
[08:26:41.100]                             muffled <- TRUE
[08:26:41.100]                             break
[08:26:41.100]                           }
[08:26:41.100]                         }
[08:26:41.100]                       }
[08:26:41.100]                       invisible(muffled)
[08:26:41.100]                     }
[08:26:41.100]                     muffleCondition(cond, pattern = "^muffle")
[08:26:41.100]                   }
[08:26:41.100]                 }
[08:26:41.100]                 else {
[08:26:41.100]                   if (TRUE) {
[08:26:41.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:41.100]                     {
[08:26:41.100]                       inherits <- base::inherits
[08:26:41.100]                       invokeRestart <- base::invokeRestart
[08:26:41.100]                       is.null <- base::is.null
[08:26:41.100]                       muffled <- FALSE
[08:26:41.100]                       if (inherits(cond, "message")) {
[08:26:41.100]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:41.100]                         if (muffled) 
[08:26:41.100]                           invokeRestart("muffleMessage")
[08:26:41.100]                       }
[08:26:41.100]                       else if (inherits(cond, "warning")) {
[08:26:41.100]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:41.100]                         if (muffled) 
[08:26:41.100]                           invokeRestart("muffleWarning")
[08:26:41.100]                       }
[08:26:41.100]                       else if (inherits(cond, "condition")) {
[08:26:41.100]                         if (!is.null(pattern)) {
[08:26:41.100]                           computeRestarts <- base::computeRestarts
[08:26:41.100]                           grepl <- base::grepl
[08:26:41.100]                           restarts <- computeRestarts(cond)
[08:26:41.100]                           for (restart in restarts) {
[08:26:41.100]                             name <- restart$name
[08:26:41.100]                             if (is.null(name)) 
[08:26:41.100]                               next
[08:26:41.100]                             if (!grepl(pattern, name)) 
[08:26:41.100]                               next
[08:26:41.100]                             invokeRestart(restart)
[08:26:41.100]                             muffled <- TRUE
[08:26:41.100]                             break
[08:26:41.100]                           }
[08:26:41.100]                         }
[08:26:41.100]                       }
[08:26:41.100]                       invisible(muffled)
[08:26:41.100]                     }
[08:26:41.100]                     muffleCondition(cond, pattern = "^muffle")
[08:26:41.100]                   }
[08:26:41.100]                 }
[08:26:41.100]             }
[08:26:41.100]         }))
[08:26:41.100]     }, error = function(ex) {
[08:26:41.100]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:41.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:41.100]                 ...future.rng), started = ...future.startTime, 
[08:26:41.100]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:41.100]             version = "1.8"), class = "FutureResult")
[08:26:41.100]     }, finally = {
[08:26:41.100]         if (!identical(...future.workdir, getwd())) 
[08:26:41.100]             setwd(...future.workdir)
[08:26:41.100]         {
[08:26:41.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:41.100]                 ...future.oldOptions$nwarnings <- NULL
[08:26:41.100]             }
[08:26:41.100]             base::options(...future.oldOptions)
[08:26:41.100]             if (.Platform$OS.type == "windows") {
[08:26:41.100]                 old_names <- names(...future.oldEnvVars)
[08:26:41.100]                 envs <- base::Sys.getenv()
[08:26:41.100]                 names <- names(envs)
[08:26:41.100]                 common <- intersect(names, old_names)
[08:26:41.100]                 added <- setdiff(names, old_names)
[08:26:41.100]                 removed <- setdiff(old_names, names)
[08:26:41.100]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:41.100]                   envs[common]]
[08:26:41.100]                 NAMES <- toupper(changed)
[08:26:41.100]                 args <- list()
[08:26:41.100]                 for (kk in seq_along(NAMES)) {
[08:26:41.100]                   name <- changed[[kk]]
[08:26:41.100]                   NAME <- NAMES[[kk]]
[08:26:41.100]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:41.100]                     next
[08:26:41.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:41.100]                 }
[08:26:41.100]                 NAMES <- toupper(added)
[08:26:41.100]                 for (kk in seq_along(NAMES)) {
[08:26:41.100]                   name <- added[[kk]]
[08:26:41.100]                   NAME <- NAMES[[kk]]
[08:26:41.100]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:41.100]                     next
[08:26:41.100]                   args[[name]] <- ""
[08:26:41.100]                 }
[08:26:41.100]                 NAMES <- toupper(removed)
[08:26:41.100]                 for (kk in seq_along(NAMES)) {
[08:26:41.100]                   name <- removed[[kk]]
[08:26:41.100]                   NAME <- NAMES[[kk]]
[08:26:41.100]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:41.100]                     next
[08:26:41.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:41.100]                 }
[08:26:41.100]                 if (length(args) > 0) 
[08:26:41.100]                   base::do.call(base::Sys.setenv, args = args)
[08:26:41.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:41.100]             }
[08:26:41.100]             else {
[08:26:41.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:41.100]             }
[08:26:41.100]             {
[08:26:41.100]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:41.100]                   0L) {
[08:26:41.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:41.100]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:41.100]                   base::options(opts)
[08:26:41.100]                 }
[08:26:41.100]                 {
[08:26:41.100]                   {
[08:26:41.100]                     NULL
[08:26:41.100]                     RNGkind("Mersenne-Twister")
[08:26:41.100]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:41.100]                       inherits = FALSE)
[08:26:41.100]                   }
[08:26:41.100]                   options(future.plan = NULL)
[08:26:41.100]                   if (is.na(NA_character_)) 
[08:26:41.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:41.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:41.100]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:41.100]                     .init = FALSE)
[08:26:41.100]                 }
[08:26:41.100]             }
[08:26:41.100]         }
[08:26:41.100]     })
[08:26:41.100]     if (TRUE) {
[08:26:41.100]         base::sink(type = "output", split = FALSE)
[08:26:41.100]         if (FALSE) {
[08:26:41.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:41.100]         }
[08:26:41.100]         else {
[08:26:41.100]             ...future.result["stdout"] <- base::list(NULL)
[08:26:41.100]         }
[08:26:41.100]         base::close(...future.stdout)
[08:26:41.100]         ...future.stdout <- NULL
[08:26:41.100]     }
[08:26:41.100]     ...future.result$conditions <- ...future.conditions
[08:26:41.100]     ...future.result$finished <- base::Sys.time()
[08:26:41.100]     ...future.result
[08:26:41.100] }
[08:26:41.102] assign_globals() ...
[08:26:41.102] List of 5
[08:26:41.102]  $ ...future.FUN            :function (x, y)  
[08:26:41.102]  $ MoreArgs                 : NULL
[08:26:41.102]  $ ...future.elements_ii    :List of 2
[08:26:41.102]   ..$ :List of 2
[08:26:41.102]   .. ..$ : int 1
[08:26:41.102]   .. ..$ : int 0
[08:26:41.102]   ..$ :List of 2
[08:26:41.102]   .. ..$ : int 0
[08:26:41.102]   .. ..$ : int 1
[08:26:41.102]  $ ...future.seeds_ii       : NULL
[08:26:41.102]  $ ...future.globals.maxSize: NULL
[08:26:41.102]  - attr(*, "where")=List of 5
[08:26:41.102]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:41.102]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:41.102]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:41.102]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:41.102]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:41.102]  - attr(*, "resolved")= logi FALSE
[08:26:41.102]  - attr(*, "total_size")= num 1242
[08:26:41.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:41.102]  - attr(*, "already-done")= logi TRUE
[08:26:41.108] - reassign environment for ‘...future.FUN’
[08:26:41.108] - copied ‘...future.FUN’ to environment
[08:26:41.108] - copied ‘MoreArgs’ to environment
[08:26:41.109] - copied ‘...future.elements_ii’ to environment
[08:26:41.109] - copied ‘...future.seeds_ii’ to environment
[08:26:41.109] - copied ‘...future.globals.maxSize’ to environment
[08:26:41.109] assign_globals() ... done
[08:26:41.109] plan(): Setting new future strategy stack:
[08:26:41.109] List of future strategies:
[08:26:41.109] 1. sequential:
[08:26:41.109]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:41.109]    - tweaked: FALSE
[08:26:41.109]    - call: NULL
[08:26:41.110] plan(): nbrOfWorkers() = 1
[08:26:41.612] plan(): Setting new future strategy stack:
[08:26:41.612] List of future strategies:
[08:26:41.612] 1. multisession:
[08:26:41.612]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:41.612]    - tweaked: FALSE
[08:26:41.612]    - call: plan(strategy)
[08:26:41.614] plan(): nbrOfWorkers() = 1
[08:26:41.614] SequentialFuture started (and completed)
[08:26:41.614] - Launch lazy future ... done
[08:26:41.614] run() for ‘SequentialFuture’ ... done
[08:26:41.614] Created future:
[08:26:41.614] SequentialFuture:
[08:26:41.614] Label: ‘future_mapply-1’
[08:26:41.614] Expression:
[08:26:41.614] {
[08:26:41.614]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:41.614]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:41.614]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:41.614]         on.exit(options(oopts), add = TRUE)
[08:26:41.614]     }
[08:26:41.614]     {
[08:26:41.614]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:41.614]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:41.614]         do.call(mapply, args = args)
[08:26:41.614]     }
[08:26:41.614] }
[08:26:41.614] Lazy evaluation: FALSE
[08:26:41.614] Asynchronous evaluation: FALSE
[08:26:41.614] Local evaluation: TRUE
[08:26:41.614] Environment: R_GlobalEnv
[08:26:41.614] Capture standard output: FALSE
[08:26:41.614] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:41.614] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:41.614] Packages: <none>
[08:26:41.614] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:41.614] Resolved: TRUE
[08:26:41.614] Value: 184 bytes of class ‘list’
[08:26:41.614] Early signaling: FALSE
[08:26:41.614] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:41.614] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:41.617] Chunk #1 of 1 ... DONE
[08:26:41.617] Launching 1 futures (chunks) ... DONE
[08:26:41.617] Resolving 1 futures (chunks) ...
[08:26:41.617] resolve() on list ...
[08:26:41.618]  recursive: 0
[08:26:41.618]  length: 1
[08:26:41.618] 
[08:26:41.618] resolved() for ‘SequentialFuture’ ...
[08:26:41.618] - state: ‘finished’
[08:26:41.618] - run: TRUE
[08:26:41.618] - result: ‘FutureResult’
[08:26:41.618] resolved() for ‘SequentialFuture’ ... done
[08:26:41.619] Future #1
[08:26:41.619] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:41.619] - nx: 1
[08:26:41.619] - relay: TRUE
[08:26:41.619] - stdout: TRUE
[08:26:41.619] - signal: TRUE
[08:26:41.619] - resignal: FALSE
[08:26:41.619] - force: TRUE
[08:26:41.620] - relayed: [n=1] FALSE
[08:26:41.620] - queued futures: [n=1] FALSE
[08:26:41.620]  - until=1
[08:26:41.620]  - relaying element #1
[08:26:41.620] - relayed: [n=1] TRUE
[08:26:41.620] - queued futures: [n=1] TRUE
[08:26:41.620] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:41.620]  length: 0 (resolved future 1)
[08:26:41.620] Relaying remaining futures
[08:26:41.621] signalConditionsASAP(NULL, pos=0) ...
[08:26:41.621] - nx: 1
[08:26:41.621] - relay: TRUE
[08:26:41.621] - stdout: TRUE
[08:26:41.621] - signal: TRUE
[08:26:41.621] - resignal: FALSE
[08:26:41.621] - force: TRUE
[08:26:41.621] - relayed: [n=1] TRUE
[08:26:41.621] - queued futures: [n=1] TRUE
 - flush all
[08:26:41.621] - relayed: [n=1] TRUE
[08:26:41.621] - queued futures: [n=1] TRUE
[08:26:41.621] signalConditionsASAP(NULL, pos=0) ... done
[08:26:41.622] resolve() on list ... DONE
[08:26:41.622]  - Number of value chunks collected: 1
[08:26:41.622] Resolving 1 futures (chunks) ... DONE
[08:26:41.622] Reducing values from 1 chunks ...
[08:26:41.622]  - Number of values collected after concatenation: 2
[08:26:41.622]  - Number of values expected: 2
[08:26:41.622] Reducing values from 1 chunks ... DONE
[08:26:41.622] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[08:26:41.623] future_mapply() ...
[08:26:41.624] Number of chunks: 1
[08:26:41.624] getGlobalsAndPackagesXApply() ...
[08:26:41.624]  - future.globals: TRUE
[08:26:41.624] getGlobalsAndPackages() ...
[08:26:41.624] Searching for globals...
[08:26:41.626] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:41.626] Searching for globals ... DONE
[08:26:41.626] Resolving globals: FALSE
[08:26:41.627] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:41.627] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:41.627] - globals: [1] ‘FUN’
[08:26:41.627] 
[08:26:41.627] getGlobalsAndPackages() ... DONE
[08:26:41.627]  - globals found/used: [n=1] ‘FUN’
[08:26:41.628]  - needed namespaces: [n=0] 
[08:26:41.628] Finding globals ... DONE
[08:26:41.628] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:41.628] List of 2
[08:26:41.628]  $ ...future.FUN:function (x, y)  
[08:26:41.628]  $ MoreArgs     : NULL
[08:26:41.628]  - attr(*, "where")=List of 2
[08:26:41.628]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:41.628]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:41.628]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:41.628]  - attr(*, "resolved")= logi FALSE
[08:26:41.628]  - attr(*, "total_size")= num NA
[08:26:41.631] Packages to be attached in all futures: [n=0] 
[08:26:41.631] getGlobalsAndPackagesXApply() ... DONE
[08:26:41.631] Number of futures (= number of chunks): 1
[08:26:41.631] Launching 1 futures (chunks) ...
[08:26:41.631] Chunk #1 of 1 ...
[08:26:41.631]  - Finding globals in '...' for chunk #1 ...
[08:26:41.631] getGlobalsAndPackages() ...
[08:26:41.631] Searching for globals...
[08:26:41.632] 
[08:26:41.632] Searching for globals ... DONE
[08:26:41.632] - globals: [0] <none>
[08:26:41.632] getGlobalsAndPackages() ... DONE
[08:26:41.632]    + additional globals found: [n=0] 
[08:26:41.632]    + additional namespaces needed: [n=0] 
[08:26:41.632]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:41.632]  - seeds: <none>
[08:26:41.632]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:41.632] getGlobalsAndPackages() ...
[08:26:41.633] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:41.633] Resolving globals: FALSE
[08:26:41.633] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[08:26:41.634] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:41.634] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:41.634] 
[08:26:41.634] getGlobalsAndPackages() ... DONE
[08:26:41.634] run() for ‘Future’ ...
[08:26:41.634] - state: ‘created’
[08:26:41.634] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:41.636] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:41.636] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:41.636]   - Field: ‘label’
[08:26:41.636]   - Field: ‘local’
[08:26:41.636]   - Field: ‘owner’
[08:26:41.636]   - Field: ‘envir’
[08:26:41.637]   - Field: ‘packages’
[08:26:41.637]   - Field: ‘gc’
[08:26:41.637]   - Field: ‘conditions’
[08:26:41.637]   - Field: ‘expr’
[08:26:41.637]   - Field: ‘uuid’
[08:26:41.637]   - Field: ‘seed’
[08:26:41.637]   - Field: ‘version’
[08:26:41.637]   - Field: ‘result’
[08:26:41.637]   - Field: ‘asynchronous’
[08:26:41.637]   - Field: ‘calls’
[08:26:41.637]   - Field: ‘globals’
[08:26:41.638]   - Field: ‘stdout’
[08:26:41.638]   - Field: ‘earlySignal’
[08:26:41.638]   - Field: ‘lazy’
[08:26:41.638]   - Field: ‘state’
[08:26:41.638] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:41.638] - Launch lazy future ...
[08:26:41.638] Packages needed by the future expression (n = 0): <none>
[08:26:41.638] Packages needed by future strategies (n = 0): <none>
[08:26:41.639] {
[08:26:41.639]     {
[08:26:41.639]         {
[08:26:41.639]             ...future.startTime <- base::Sys.time()
[08:26:41.639]             {
[08:26:41.639]                 {
[08:26:41.639]                   {
[08:26:41.639]                     base::local({
[08:26:41.639]                       has_future <- base::requireNamespace("future", 
[08:26:41.639]                         quietly = TRUE)
[08:26:41.639]                       if (has_future) {
[08:26:41.639]                         ns <- base::getNamespace("future")
[08:26:41.639]                         version <- ns[[".package"]][["version"]]
[08:26:41.639]                         if (is.null(version)) 
[08:26:41.639]                           version <- utils::packageVersion("future")
[08:26:41.639]                       }
[08:26:41.639]                       else {
[08:26:41.639]                         version <- NULL
[08:26:41.639]                       }
[08:26:41.639]                       if (!has_future || version < "1.8.0") {
[08:26:41.639]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:41.639]                           "", base::R.version$version.string), 
[08:26:41.639]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:41.639]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:41.639]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:41.639]                             "release", "version")], collapse = " "), 
[08:26:41.639]                           hostname = base::Sys.info()[["nodename"]])
[08:26:41.639]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:41.639]                           info)
[08:26:41.639]                         info <- base::paste(info, collapse = "; ")
[08:26:41.639]                         if (!has_future) {
[08:26:41.639]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:41.639]                             info)
[08:26:41.639]                         }
[08:26:41.639]                         else {
[08:26:41.639]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:41.639]                             info, version)
[08:26:41.639]                         }
[08:26:41.639]                         base::stop(msg)
[08:26:41.639]                       }
[08:26:41.639]                     })
[08:26:41.639]                   }
[08:26:41.639]                   ...future.strategy.old <- future::plan("list")
[08:26:41.639]                   options(future.plan = NULL)
[08:26:41.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:41.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:41.639]                 }
[08:26:41.639]                 ...future.workdir <- getwd()
[08:26:41.639]             }
[08:26:41.639]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:41.639]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:41.639]         }
[08:26:41.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:41.639]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:41.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:41.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:41.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:41.639]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:41.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:41.639]             base::names(...future.oldOptions))
[08:26:41.639]     }
[08:26:41.639]     if (FALSE) {
[08:26:41.639]     }
[08:26:41.639]     else {
[08:26:41.639]         if (TRUE) {
[08:26:41.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:41.639]                 open = "w")
[08:26:41.639]         }
[08:26:41.639]         else {
[08:26:41.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:41.639]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:41.639]         }
[08:26:41.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:41.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:41.639]             base::sink(type = "output", split = FALSE)
[08:26:41.639]             base::close(...future.stdout)
[08:26:41.639]         }, add = TRUE)
[08:26:41.639]     }
[08:26:41.639]     ...future.frame <- base::sys.nframe()
[08:26:41.639]     ...future.conditions <- base::list()
[08:26:41.639]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:41.639]     if (FALSE) {
[08:26:41.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:41.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:41.639]     }
[08:26:41.639]     ...future.result <- base::tryCatch({
[08:26:41.639]         base::withCallingHandlers({
[08:26:41.639]             ...future.value <- base::withVisible(base::local({
[08:26:41.639]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:41.639]                 if (!identical(...future.globals.maxSize.org, 
[08:26:41.639]                   ...future.globals.maxSize)) {
[08:26:41.639]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:41.639]                   on.exit(options(oopts), add = TRUE)
[08:26:41.639]                 }
[08:26:41.639]                 {
[08:26:41.639]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:41.639]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:41.639]                     USE.NAMES = FALSE)
[08:26:41.639]                   do.call(mapply, args = args)
[08:26:41.639]                 }
[08:26:41.639]             }))
[08:26:41.639]             future::FutureResult(value = ...future.value$value, 
[08:26:41.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:41.639]                   ...future.rng), globalenv = if (FALSE) 
[08:26:41.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:41.639]                     ...future.globalenv.names))
[08:26:41.639]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:41.639]         }, condition = base::local({
[08:26:41.639]             c <- base::c
[08:26:41.639]             inherits <- base::inherits
[08:26:41.639]             invokeRestart <- base::invokeRestart
[08:26:41.639]             length <- base::length
[08:26:41.639]             list <- base::list
[08:26:41.639]             seq.int <- base::seq.int
[08:26:41.639]             signalCondition <- base::signalCondition
[08:26:41.639]             sys.calls <- base::sys.calls
[08:26:41.639]             `[[` <- base::`[[`
[08:26:41.639]             `+` <- base::`+`
[08:26:41.639]             `<<-` <- base::`<<-`
[08:26:41.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:41.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:41.639]                   3L)]
[08:26:41.639]             }
[08:26:41.639]             function(cond) {
[08:26:41.639]                 is_error <- inherits(cond, "error")
[08:26:41.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:41.639]                   NULL)
[08:26:41.639]                 if (is_error) {
[08:26:41.639]                   sessionInformation <- function() {
[08:26:41.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:41.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:41.639]                       search = base::search(), system = base::Sys.info())
[08:26:41.639]                   }
[08:26:41.639]                   ...future.conditions[[length(...future.conditions) + 
[08:26:41.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:41.639]                     cond$call), session = sessionInformation(), 
[08:26:41.639]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:41.639]                   signalCondition(cond)
[08:26:41.639]                 }
[08:26:41.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:41.639]                 "immediateCondition"))) {
[08:26:41.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:41.639]                   ...future.conditions[[length(...future.conditions) + 
[08:26:41.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:41.639]                   if (TRUE && !signal) {
[08:26:41.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:41.639]                     {
[08:26:41.639]                       inherits <- base::inherits
[08:26:41.639]                       invokeRestart <- base::invokeRestart
[08:26:41.639]                       is.null <- base::is.null
[08:26:41.639]                       muffled <- FALSE
[08:26:41.639]                       if (inherits(cond, "message")) {
[08:26:41.639]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:41.639]                         if (muffled) 
[08:26:41.639]                           invokeRestart("muffleMessage")
[08:26:41.639]                       }
[08:26:41.639]                       else if (inherits(cond, "warning")) {
[08:26:41.639]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:41.639]                         if (muffled) 
[08:26:41.639]                           invokeRestart("muffleWarning")
[08:26:41.639]                       }
[08:26:41.639]                       else if (inherits(cond, "condition")) {
[08:26:41.639]                         if (!is.null(pattern)) {
[08:26:41.639]                           computeRestarts <- base::computeRestarts
[08:26:41.639]                           grepl <- base::grepl
[08:26:41.639]                           restarts <- computeRestarts(cond)
[08:26:41.639]                           for (restart in restarts) {
[08:26:41.639]                             name <- restart$name
[08:26:41.639]                             if (is.null(name)) 
[08:26:41.639]                               next
[08:26:41.639]                             if (!grepl(pattern, name)) 
[08:26:41.639]                               next
[08:26:41.639]                             invokeRestart(restart)
[08:26:41.639]                             muffled <- TRUE
[08:26:41.639]                             break
[08:26:41.639]                           }
[08:26:41.639]                         }
[08:26:41.639]                       }
[08:26:41.639]                       invisible(muffled)
[08:26:41.639]                     }
[08:26:41.639]                     muffleCondition(cond, pattern = "^muffle")
[08:26:41.639]                   }
[08:26:41.639]                 }
[08:26:41.639]                 else {
[08:26:41.639]                   if (TRUE) {
[08:26:41.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:41.639]                     {
[08:26:41.639]                       inherits <- base::inherits
[08:26:41.639]                       invokeRestart <- base::invokeRestart
[08:26:41.639]                       is.null <- base::is.null
[08:26:41.639]                       muffled <- FALSE
[08:26:41.639]                       if (inherits(cond, "message")) {
[08:26:41.639]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:41.639]                         if (muffled) 
[08:26:41.639]                           invokeRestart("muffleMessage")
[08:26:41.639]                       }
[08:26:41.639]                       else if (inherits(cond, "warning")) {
[08:26:41.639]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:41.639]                         if (muffled) 
[08:26:41.639]                           invokeRestart("muffleWarning")
[08:26:41.639]                       }
[08:26:41.639]                       else if (inherits(cond, "condition")) {
[08:26:41.639]                         if (!is.null(pattern)) {
[08:26:41.639]                           computeRestarts <- base::computeRestarts
[08:26:41.639]                           grepl <- base::grepl
[08:26:41.639]                           restarts <- computeRestarts(cond)
[08:26:41.639]                           for (restart in restarts) {
[08:26:41.639]                             name <- restart$name
[08:26:41.639]                             if (is.null(name)) 
[08:26:41.639]                               next
[08:26:41.639]                             if (!grepl(pattern, name)) 
[08:26:41.639]                               next
[08:26:41.639]                             invokeRestart(restart)
[08:26:41.639]                             muffled <- TRUE
[08:26:41.639]                             break
[08:26:41.639]                           }
[08:26:41.639]                         }
[08:26:41.639]                       }
[08:26:41.639]                       invisible(muffled)
[08:26:41.639]                     }
[08:26:41.639]                     muffleCondition(cond, pattern = "^muffle")
[08:26:41.639]                   }
[08:26:41.639]                 }
[08:26:41.639]             }
[08:26:41.639]         }))
[08:26:41.639]     }, error = function(ex) {
[08:26:41.639]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:41.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:41.639]                 ...future.rng), started = ...future.startTime, 
[08:26:41.639]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:41.639]             version = "1.8"), class = "FutureResult")
[08:26:41.639]     }, finally = {
[08:26:41.639]         if (!identical(...future.workdir, getwd())) 
[08:26:41.639]             setwd(...future.workdir)
[08:26:41.639]         {
[08:26:41.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:41.639]                 ...future.oldOptions$nwarnings <- NULL
[08:26:41.639]             }
[08:26:41.639]             base::options(...future.oldOptions)
[08:26:41.639]             if (.Platform$OS.type == "windows") {
[08:26:41.639]                 old_names <- names(...future.oldEnvVars)
[08:26:41.639]                 envs <- base::Sys.getenv()
[08:26:41.639]                 names <- names(envs)
[08:26:41.639]                 common <- intersect(names, old_names)
[08:26:41.639]                 added <- setdiff(names, old_names)
[08:26:41.639]                 removed <- setdiff(old_names, names)
[08:26:41.639]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:41.639]                   envs[common]]
[08:26:41.639]                 NAMES <- toupper(changed)
[08:26:41.639]                 args <- list()
[08:26:41.639]                 for (kk in seq_along(NAMES)) {
[08:26:41.639]                   name <- changed[[kk]]
[08:26:41.639]                   NAME <- NAMES[[kk]]
[08:26:41.639]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:41.639]                     next
[08:26:41.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:41.639]                 }
[08:26:41.639]                 NAMES <- toupper(added)
[08:26:41.639]                 for (kk in seq_along(NAMES)) {
[08:26:41.639]                   name <- added[[kk]]
[08:26:41.639]                   NAME <- NAMES[[kk]]
[08:26:41.639]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:41.639]                     next
[08:26:41.639]                   args[[name]] <- ""
[08:26:41.639]                 }
[08:26:41.639]                 NAMES <- toupper(removed)
[08:26:41.639]                 for (kk in seq_along(NAMES)) {
[08:26:41.639]                   name <- removed[[kk]]
[08:26:41.639]                   NAME <- NAMES[[kk]]
[08:26:41.639]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:41.639]                     next
[08:26:41.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:41.639]                 }
[08:26:41.639]                 if (length(args) > 0) 
[08:26:41.639]                   base::do.call(base::Sys.setenv, args = args)
[08:26:41.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:41.639]             }
[08:26:41.639]             else {
[08:26:41.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:41.639]             }
[08:26:41.639]             {
[08:26:41.639]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:41.639]                   0L) {
[08:26:41.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:41.639]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:41.639]                   base::options(opts)
[08:26:41.639]                 }
[08:26:41.639]                 {
[08:26:41.639]                   {
[08:26:41.639]                     NULL
[08:26:41.639]                     RNGkind("Mersenne-Twister")
[08:26:41.639]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:41.639]                       inherits = FALSE)
[08:26:41.639]                   }
[08:26:41.639]                   options(future.plan = NULL)
[08:26:41.639]                   if (is.na(NA_character_)) 
[08:26:41.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:41.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:41.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:41.639]                     .init = FALSE)
[08:26:41.639]                 }
[08:26:41.639]             }
[08:26:41.639]         }
[08:26:41.639]     })
[08:26:41.639]     if (TRUE) {
[08:26:41.639]         base::sink(type = "output", split = FALSE)
[08:26:41.639]         if (TRUE) {
[08:26:41.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:41.639]         }
[08:26:41.639]         else {
[08:26:41.639]             ...future.result["stdout"] <- base::list(NULL)
[08:26:41.639]         }
[08:26:41.639]         base::close(...future.stdout)
[08:26:41.639]         ...future.stdout <- NULL
[08:26:41.639]     }
[08:26:41.639]     ...future.result$conditions <- ...future.conditions
[08:26:41.639]     ...future.result$finished <- base::Sys.time()
[08:26:41.639]     ...future.result
[08:26:41.639] }
[08:26:41.641] assign_globals() ...
[08:26:41.641] List of 5
[08:26:41.641]  $ ...future.FUN            :function (x, y)  
[08:26:41.641]  $ MoreArgs                 : NULL
[08:26:41.641]  $ ...future.elements_ii    :List of 2
[08:26:41.641]   ..$ :List of 2
[08:26:41.641]   .. ..$ : int 1
[08:26:41.641]   .. ..$ : int 0
[08:26:41.641]   ..$ :List of 2
[08:26:41.641]   .. ..$ : int 0
[08:26:41.641]   .. ..$ : int 1
[08:26:41.641]  $ ...future.seeds_ii       : NULL
[08:26:41.641]  $ ...future.globals.maxSize: NULL
[08:26:41.641]  - attr(*, "where")=List of 5
[08:26:41.641]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:41.641]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:41.641]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:41.641]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:41.641]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:41.641]  - attr(*, "resolved")= logi FALSE
[08:26:41.641]  - attr(*, "total_size")= num 1242
[08:26:41.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:41.641]  - attr(*, "already-done")= logi TRUE
[08:26:41.649] - reassign environment for ‘...future.FUN’
[08:26:41.649] - copied ‘...future.FUN’ to environment
[08:26:41.649] - copied ‘MoreArgs’ to environment
[08:26:41.649] - copied ‘...future.elements_ii’ to environment
[08:26:41.649] - copied ‘...future.seeds_ii’ to environment
[08:26:41.649] - copied ‘...future.globals.maxSize’ to environment
[08:26:41.649] assign_globals() ... done
[08:26:41.650] plan(): Setting new future strategy stack:
[08:26:41.650] List of future strategies:
[08:26:41.650] 1. sequential:
[08:26:41.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:41.650]    - tweaked: FALSE
[08:26:41.650]    - call: NULL
[08:26:41.650] plan(): nbrOfWorkers() = 1
[08:26:42.152] plan(): Setting new future strategy stack:
[08:26:42.152] List of future strategies:
[08:26:42.152] 1. multisession:
[08:26:42.152]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:42.152]    - tweaked: FALSE
[08:26:42.152]    - call: plan(strategy)
[08:26:42.154] plan(): nbrOfWorkers() = 1
[08:26:42.154] SequentialFuture started (and completed)
[08:26:42.155] - Launch lazy future ... done
[08:26:42.155] run() for ‘SequentialFuture’ ... done
[08:26:42.155] Created future:
[08:26:42.155] SequentialFuture:
[08:26:42.155] Label: ‘future_mapply-1’
[08:26:42.155] Expression:
[08:26:42.155] {
[08:26:42.155]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:42.155]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:42.155]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:42.155]         on.exit(options(oopts), add = TRUE)
[08:26:42.155]     }
[08:26:42.155]     {
[08:26:42.155]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:42.155]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:42.155]         do.call(mapply, args = args)
[08:26:42.155]     }
[08:26:42.155] }
[08:26:42.155] Lazy evaluation: FALSE
[08:26:42.155] Asynchronous evaluation: FALSE
[08:26:42.155] Local evaluation: TRUE
[08:26:42.155] Environment: R_GlobalEnv
[08:26:42.155] Capture standard output: TRUE
[08:26:42.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:42.155] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:42.155] Packages: <none>
[08:26:42.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:42.155] Resolved: TRUE
[08:26:42.155] Value: 184 bytes of class ‘list’
[08:26:42.155] Early signaling: FALSE
[08:26:42.155] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:42.155] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:42.156] Chunk #1 of 1 ... DONE
[08:26:42.156] Launching 1 futures (chunks) ... DONE
[08:26:42.156] Resolving 1 futures (chunks) ...
[08:26:42.156] resolve() on list ...
[08:26:42.156]  recursive: 0
[08:26:42.156]  length: 1
[08:26:42.156] 
[08:26:42.157] resolved() for ‘SequentialFuture’ ...
[08:26:42.157] - state: ‘finished’
[08:26:42.157] - run: TRUE
[08:26:42.157] - result: ‘FutureResult’
[08:26:42.157] resolved() for ‘SequentialFuture’ ... done
[08:26:42.157] Future #1
[08:26:42.157] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:42.157] - nx: 1
[08:26:42.157] - relay: TRUE
[08:26:42.157] - stdout: TRUE
[08:26:42.158] - signal: TRUE
[08:26:42.158] - resignal: FALSE
[08:26:42.158] - force: TRUE
[08:26:42.158] - relayed: [n=1] FALSE
[08:26:42.158] - queued futures: [n=1] FALSE
[08:26:42.158]  - until=1
[08:26:42.158]  - relaying element #1
[08:26:42.158] - relayed: [n=1] TRUE
[08:26:42.158] - queued futures: [n=1] TRUE
[08:26:42.158] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:42.159]  length: 0 (resolved future 1)
[08:26:42.159] Relaying remaining futures
[08:26:42.159] signalConditionsASAP(NULL, pos=0) ...
[08:26:42.159] - nx: 1
[08:26:42.159] - relay: TRUE
[08:26:42.159] - stdout: TRUE
[08:26:42.159] - signal: TRUE
[08:26:42.159] - resignal: FALSE
[08:26:42.159] - force: TRUE
[08:26:42.159] - relayed: [n=1] TRUE
[08:26:42.159] - queued futures: [n=1] TRUE
 - flush all
[08:26:42.159] - relayed: [n=1] TRUE
[08:26:42.160] - queued futures: [n=1] TRUE
[08:26:42.160] signalConditionsASAP(NULL, pos=0) ... done
[08:26:42.160] resolve() on list ... DONE
[08:26:42.160]  - Number of value chunks collected: 1
[08:26:42.160] Resolving 1 futures (chunks) ... DONE
[08:26:42.160] Reducing values from 1 chunks ...
[08:26:42.160]  - Number of values collected after concatenation: 2
[08:26:42.160]  - Number of values expected: 2
[08:26:42.160] Reducing values from 1 chunks ... DONE
[08:26:42.160] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[08:26:42.161] future_mapply() ...
[08:26:42.162] Number of chunks: 1
[08:26:42.162] getGlobalsAndPackagesXApply() ...
[08:26:42.163]  - future.globals: TRUE
[08:26:42.163] getGlobalsAndPackages() ...
[08:26:42.163] Searching for globals...
[08:26:42.164] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:42.165] Searching for globals ... DONE
[08:26:42.165] Resolving globals: FALSE
[08:26:42.165] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:42.165] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:42.166] - globals: [1] ‘FUN’
[08:26:42.166] 
[08:26:42.166] getGlobalsAndPackages() ... DONE
[08:26:42.166]  - globals found/used: [n=1] ‘FUN’
[08:26:42.166]  - needed namespaces: [n=0] 
[08:26:42.166] Finding globals ... DONE
[08:26:42.166] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:42.166] List of 2
[08:26:42.166]  $ ...future.FUN:function (x, y)  
[08:26:42.166]  $ MoreArgs     : NULL
[08:26:42.166]  - attr(*, "where")=List of 2
[08:26:42.166]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:42.166]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:42.166]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:42.166]  - attr(*, "resolved")= logi FALSE
[08:26:42.166]  - attr(*, "total_size")= num NA
[08:26:42.169] Packages to be attached in all futures: [n=0] 
[08:26:42.169] getGlobalsAndPackagesXApply() ... DONE
[08:26:42.169] Number of futures (= number of chunks): 1
[08:26:42.169] Launching 1 futures (chunks) ...
[08:26:42.170] Chunk #1 of 1 ...
[08:26:42.170]  - Finding globals in '...' for chunk #1 ...
[08:26:42.170] getGlobalsAndPackages() ...
[08:26:42.170] Searching for globals...
[08:26:42.170] 
[08:26:42.170] Searching for globals ... DONE
[08:26:42.170] - globals: [0] <none>
[08:26:42.170] getGlobalsAndPackages() ... DONE
[08:26:42.171]    + additional globals found: [n=0] 
[08:26:42.171]    + additional namespaces needed: [n=0] 
[08:26:42.171]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:42.171]  - seeds: <none>
[08:26:42.171]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:42.171] getGlobalsAndPackages() ...
[08:26:42.171] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:42.171] Resolving globals: FALSE
[08:26:42.172] The total size of the 5 globals is 1.21 KiB (1242 bytes)
[08:26:42.172] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.21 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (95 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:42.172] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:42.172] 
[08:26:42.173] getGlobalsAndPackages() ... DONE
[08:26:42.173] run() for ‘Future’ ...
[08:26:42.173] - state: ‘created’
[08:26:42.173] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:42.177] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:42.177] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:26:42.177]   - Field: ‘label’
[08:26:42.178]   - Field: ‘local’
[08:26:42.178]   - Field: ‘owner’
[08:26:42.178]   - Field: ‘envir’
[08:26:42.178]   - Field: ‘packages’
[08:26:42.178]   - Field: ‘gc’
[08:26:42.178]   - Field: ‘conditions’
[08:26:42.178]   - Field: ‘expr’
[08:26:42.178]   - Field: ‘uuid’
[08:26:42.178]   - Field: ‘seed’
[08:26:42.179]   - Field: ‘version’
[08:26:42.179]   - Field: ‘result’
[08:26:42.179]   - Field: ‘asynchronous’
[08:26:42.179]   - Field: ‘calls’
[08:26:42.179]   - Field: ‘globals’
[08:26:42.179]   - Field: ‘stdout’
[08:26:42.179]   - Field: ‘earlySignal’
[08:26:42.179]   - Field: ‘lazy’
[08:26:42.179]   - Field: ‘state’
[08:26:42.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:26:42.180] - Launch lazy future ...
[08:26:42.180] Packages needed by the future expression (n = 0): <none>
[08:26:42.180] Packages needed by future strategies (n = 0): <none>
[08:26:42.180] {
[08:26:42.180]     {
[08:26:42.180]         {
[08:26:42.180]             ...future.startTime <- base::Sys.time()
[08:26:42.180]             {
[08:26:42.180]                 {
[08:26:42.180]                   {
[08:26:42.180]                     base::local({
[08:26:42.180]                       has_future <- base::requireNamespace("future", 
[08:26:42.180]                         quietly = TRUE)
[08:26:42.180]                       if (has_future) {
[08:26:42.180]                         ns <- base::getNamespace("future")
[08:26:42.180]                         version <- ns[[".package"]][["version"]]
[08:26:42.180]                         if (is.null(version)) 
[08:26:42.180]                           version <- utils::packageVersion("future")
[08:26:42.180]                       }
[08:26:42.180]                       else {
[08:26:42.180]                         version <- NULL
[08:26:42.180]                       }
[08:26:42.180]                       if (!has_future || version < "1.8.0") {
[08:26:42.180]                         info <- base::c(r_version = base::gsub("R version ", 
[08:26:42.180]                           "", base::R.version$version.string), 
[08:26:42.180]                           platform = base::sprintf("%s (%s-bit)", 
[08:26:42.180]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:42.180]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:42.180]                             "release", "version")], collapse = " "), 
[08:26:42.180]                           hostname = base::Sys.info()[["nodename"]])
[08:26:42.180]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:26:42.180]                           info)
[08:26:42.180]                         info <- base::paste(info, collapse = "; ")
[08:26:42.180]                         if (!has_future) {
[08:26:42.180]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:42.180]                             info)
[08:26:42.180]                         }
[08:26:42.180]                         else {
[08:26:42.180]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:42.180]                             info, version)
[08:26:42.180]                         }
[08:26:42.180]                         base::stop(msg)
[08:26:42.180]                       }
[08:26:42.180]                     })
[08:26:42.180]                   }
[08:26:42.180]                   ...future.strategy.old <- future::plan("list")
[08:26:42.180]                   options(future.plan = NULL)
[08:26:42.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:42.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:42.180]                 }
[08:26:42.180]                 ...future.workdir <- getwd()
[08:26:42.180]             }
[08:26:42.180]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:42.180]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:42.180]         }
[08:26:42.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:42.180]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:42.180]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:42.180]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:42.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:42.180]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:42.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:42.180]             base::names(...future.oldOptions))
[08:26:42.180]     }
[08:26:42.180]     if (TRUE) {
[08:26:42.180]     }
[08:26:42.180]     else {
[08:26:42.180]         if (NA) {
[08:26:42.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:42.180]                 open = "w")
[08:26:42.180]         }
[08:26:42.180]         else {
[08:26:42.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:42.180]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:42.180]         }
[08:26:42.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:42.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:42.180]             base::sink(type = "output", split = FALSE)
[08:26:42.180]             base::close(...future.stdout)
[08:26:42.180]         }, add = TRUE)
[08:26:42.180]     }
[08:26:42.180]     ...future.frame <- base::sys.nframe()
[08:26:42.180]     ...future.conditions <- base::list()
[08:26:42.180]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:42.180]     if (FALSE) {
[08:26:42.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:42.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:42.180]     }
[08:26:42.180]     ...future.result <- base::tryCatch({
[08:26:42.180]         base::withCallingHandlers({
[08:26:42.180]             ...future.value <- base::withVisible(base::local({
[08:26:42.180]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:42.180]                 if (!identical(...future.globals.maxSize.org, 
[08:26:42.180]                   ...future.globals.maxSize)) {
[08:26:42.180]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:42.180]                   on.exit(options(oopts), add = TRUE)
[08:26:42.180]                 }
[08:26:42.180]                 {
[08:26:42.180]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:42.180]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:42.180]                     USE.NAMES = FALSE)
[08:26:42.180]                   do.call(mapply, args = args)
[08:26:42.180]                 }
[08:26:42.180]             }))
[08:26:42.180]             future::FutureResult(value = ...future.value$value, 
[08:26:42.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:42.180]                   ...future.rng), globalenv = if (FALSE) 
[08:26:42.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:42.180]                     ...future.globalenv.names))
[08:26:42.180]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:42.180]         }, condition = base::local({
[08:26:42.180]             c <- base::c
[08:26:42.180]             inherits <- base::inherits
[08:26:42.180]             invokeRestart <- base::invokeRestart
[08:26:42.180]             length <- base::length
[08:26:42.180]             list <- base::list
[08:26:42.180]             seq.int <- base::seq.int
[08:26:42.180]             signalCondition <- base::signalCondition
[08:26:42.180]             sys.calls <- base::sys.calls
[08:26:42.180]             `[[` <- base::`[[`
[08:26:42.180]             `+` <- base::`+`
[08:26:42.180]             `<<-` <- base::`<<-`
[08:26:42.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:42.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:42.180]                   3L)]
[08:26:42.180]             }
[08:26:42.180]             function(cond) {
[08:26:42.180]                 is_error <- inherits(cond, "error")
[08:26:42.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:42.180]                   NULL)
[08:26:42.180]                 if (is_error) {
[08:26:42.180]                   sessionInformation <- function() {
[08:26:42.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:42.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:42.180]                       search = base::search(), system = base::Sys.info())
[08:26:42.180]                   }
[08:26:42.180]                   ...future.conditions[[length(...future.conditions) + 
[08:26:42.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:42.180]                     cond$call), session = sessionInformation(), 
[08:26:42.180]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:42.180]                   signalCondition(cond)
[08:26:42.180]                 }
[08:26:42.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:42.180]                 "immediateCondition"))) {
[08:26:42.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:42.180]                   ...future.conditions[[length(...future.conditions) + 
[08:26:42.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:42.180]                   if (TRUE && !signal) {
[08:26:42.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:42.180]                     {
[08:26:42.180]                       inherits <- base::inherits
[08:26:42.180]                       invokeRestart <- base::invokeRestart
[08:26:42.180]                       is.null <- base::is.null
[08:26:42.180]                       muffled <- FALSE
[08:26:42.180]                       if (inherits(cond, "message")) {
[08:26:42.180]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:42.180]                         if (muffled) 
[08:26:42.180]                           invokeRestart("muffleMessage")
[08:26:42.180]                       }
[08:26:42.180]                       else if (inherits(cond, "warning")) {
[08:26:42.180]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:42.180]                         if (muffled) 
[08:26:42.180]                           invokeRestart("muffleWarning")
[08:26:42.180]                       }
[08:26:42.180]                       else if (inherits(cond, "condition")) {
[08:26:42.180]                         if (!is.null(pattern)) {
[08:26:42.180]                           computeRestarts <- base::computeRestarts
[08:26:42.180]                           grepl <- base::grepl
[08:26:42.180]                           restarts <- computeRestarts(cond)
[08:26:42.180]                           for (restart in restarts) {
[08:26:42.180]                             name <- restart$name
[08:26:42.180]                             if (is.null(name)) 
[08:26:42.180]                               next
[08:26:42.180]                             if (!grepl(pattern, name)) 
[08:26:42.180]                               next
[08:26:42.180]                             invokeRestart(restart)
[08:26:42.180]                             muffled <- TRUE
[08:26:42.180]                             break
[08:26:42.180]                           }
[08:26:42.180]                         }
[08:26:42.180]                       }
[08:26:42.180]                       invisible(muffled)
[08:26:42.180]                     }
[08:26:42.180]                     muffleCondition(cond, pattern = "^muffle")
[08:26:42.180]                   }
[08:26:42.180]                 }
[08:26:42.180]                 else {
[08:26:42.180]                   if (TRUE) {
[08:26:42.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:42.180]                     {
[08:26:42.180]                       inherits <- base::inherits
[08:26:42.180]                       invokeRestart <- base::invokeRestart
[08:26:42.180]                       is.null <- base::is.null
[08:26:42.180]                       muffled <- FALSE
[08:26:42.180]                       if (inherits(cond, "message")) {
[08:26:42.180]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:42.180]                         if (muffled) 
[08:26:42.180]                           invokeRestart("muffleMessage")
[08:26:42.180]                       }
[08:26:42.180]                       else if (inherits(cond, "warning")) {
[08:26:42.180]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:42.180]                         if (muffled) 
[08:26:42.180]                           invokeRestart("muffleWarning")
[08:26:42.180]                       }
[08:26:42.180]                       else if (inherits(cond, "condition")) {
[08:26:42.180]                         if (!is.null(pattern)) {
[08:26:42.180]                           computeRestarts <- base::computeRestarts
[08:26:42.180]                           grepl <- base::grepl
[08:26:42.180]                           restarts <- computeRestarts(cond)
[08:26:42.180]                           for (restart in restarts) {
[08:26:42.180]                             name <- restart$name
[08:26:42.180]                             if (is.null(name)) 
[08:26:42.180]                               next
[08:26:42.180]                             if (!grepl(pattern, name)) 
[08:26:42.180]                               next
[08:26:42.180]                             invokeRestart(restart)
[08:26:42.180]                             muffled <- TRUE
[08:26:42.180]                             break
[08:26:42.180]                           }
[08:26:42.180]                         }
[08:26:42.180]                       }
[08:26:42.180]                       invisible(muffled)
[08:26:42.180]                     }
[08:26:42.180]                     muffleCondition(cond, pattern = "^muffle")
[08:26:42.180]                   }
[08:26:42.180]                 }
[08:26:42.180]             }
[08:26:42.180]         }))
[08:26:42.180]     }, error = function(ex) {
[08:26:42.180]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:42.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:42.180]                 ...future.rng), started = ...future.startTime, 
[08:26:42.180]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:42.180]             version = "1.8"), class = "FutureResult")
[08:26:42.180]     }, finally = {
[08:26:42.180]         if (!identical(...future.workdir, getwd())) 
[08:26:42.180]             setwd(...future.workdir)
[08:26:42.180]         {
[08:26:42.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:42.180]                 ...future.oldOptions$nwarnings <- NULL
[08:26:42.180]             }
[08:26:42.180]             base::options(...future.oldOptions)
[08:26:42.180]             if (.Platform$OS.type == "windows") {
[08:26:42.180]                 old_names <- names(...future.oldEnvVars)
[08:26:42.180]                 envs <- base::Sys.getenv()
[08:26:42.180]                 names <- names(envs)
[08:26:42.180]                 common <- intersect(names, old_names)
[08:26:42.180]                 added <- setdiff(names, old_names)
[08:26:42.180]                 removed <- setdiff(old_names, names)
[08:26:42.180]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:42.180]                   envs[common]]
[08:26:42.180]                 NAMES <- toupper(changed)
[08:26:42.180]                 args <- list()
[08:26:42.180]                 for (kk in seq_along(NAMES)) {
[08:26:42.180]                   name <- changed[[kk]]
[08:26:42.180]                   NAME <- NAMES[[kk]]
[08:26:42.180]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:42.180]                     next
[08:26:42.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:42.180]                 }
[08:26:42.180]                 NAMES <- toupper(added)
[08:26:42.180]                 for (kk in seq_along(NAMES)) {
[08:26:42.180]                   name <- added[[kk]]
[08:26:42.180]                   NAME <- NAMES[[kk]]
[08:26:42.180]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:42.180]                     next
[08:26:42.180]                   args[[name]] <- ""
[08:26:42.180]                 }
[08:26:42.180]                 NAMES <- toupper(removed)
[08:26:42.180]                 for (kk in seq_along(NAMES)) {
[08:26:42.180]                   name <- removed[[kk]]
[08:26:42.180]                   NAME <- NAMES[[kk]]
[08:26:42.180]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:42.180]                     next
[08:26:42.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:42.180]                 }
[08:26:42.180]                 if (length(args) > 0) 
[08:26:42.180]                   base::do.call(base::Sys.setenv, args = args)
[08:26:42.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:42.180]             }
[08:26:42.180]             else {
[08:26:42.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:42.180]             }
[08:26:42.180]             {
[08:26:42.180]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:42.180]                   0L) {
[08:26:42.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:42.180]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:42.180]                   base::options(opts)
[08:26:42.180]                 }
[08:26:42.180]                 {
[08:26:42.180]                   {
[08:26:42.180]                     NULL
[08:26:42.180]                     RNGkind("Mersenne-Twister")
[08:26:42.180]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:26:42.180]                       inherits = FALSE)
[08:26:42.180]                   }
[08:26:42.180]                   options(future.plan = NULL)
[08:26:42.180]                   if (is.na(NA_character_)) 
[08:26:42.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:42.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:42.180]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:42.180]                     .init = FALSE)
[08:26:42.180]                 }
[08:26:42.180]             }
[08:26:42.180]         }
[08:26:42.180]     })
[08:26:42.180]     if (FALSE) {
[08:26:42.180]         base::sink(type = "output", split = FALSE)
[08:26:42.180]         if (NA) {
[08:26:42.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:42.180]         }
[08:26:42.180]         else {
[08:26:42.180]             ...future.result["stdout"] <- base::list(NULL)
[08:26:42.180]         }
[08:26:42.180]         base::close(...future.stdout)
[08:26:42.180]         ...future.stdout <- NULL
[08:26:42.180]     }
[08:26:42.180]     ...future.result$conditions <- ...future.conditions
[08:26:42.180]     ...future.result$finished <- base::Sys.time()
[08:26:42.180]     ...future.result
[08:26:42.180] }
[08:26:42.182] assign_globals() ...
[08:26:42.182] List of 5
[08:26:42.182]  $ ...future.FUN            :function (x, y)  
[08:26:42.182]  $ MoreArgs                 : NULL
[08:26:42.182]  $ ...future.elements_ii    :List of 2
[08:26:42.182]   ..$ :List of 2
[08:26:42.182]   .. ..$ : int 1
[08:26:42.182]   .. ..$ : int 0
[08:26:42.182]   ..$ :List of 2
[08:26:42.182]   .. ..$ : int 0
[08:26:42.182]   .. ..$ : int 1
[08:26:42.182]  $ ...future.seeds_ii       : NULL
[08:26:42.182]  $ ...future.globals.maxSize: NULL
[08:26:42.182]  - attr(*, "where")=List of 5
[08:26:42.182]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:42.182]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:42.182]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:42.182]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:42.182]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:42.182]  - attr(*, "resolved")= logi FALSE
[08:26:42.182]  - attr(*, "total_size")= num 1242
[08:26:42.182]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:42.182]  - attr(*, "already-done")= logi TRUE
[08:26:42.188] - reassign environment for ‘...future.FUN’
[08:26:42.189] - copied ‘...future.FUN’ to environment
[08:26:42.189] - copied ‘MoreArgs’ to environment
[08:26:42.189] - copied ‘...future.elements_ii’ to environment
[08:26:42.189] - copied ‘...future.seeds_ii’ to environment
[08:26:42.189] - copied ‘...future.globals.maxSize’ to environment
[08:26:42.189] assign_globals() ... done
[08:26:42.189] plan(): Setting new future strategy stack:
[08:26:42.189] List of future strategies:
[08:26:42.189] 1. sequential:
[08:26:42.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:42.189]    - tweaked: FALSE
[08:26:42.189]    - call: NULL
[08:26:42.190] plan(): nbrOfWorkers() = 1
[08:26:42.692] plan(): Setting new future strategy stack:
[08:26:42.692] List of future strategies:
[08:26:42.692] 1. multisession:
[08:26:42.692]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:42.692]    - tweaked: FALSE
[08:26:42.692]    - call: plan(strategy)
[08:26:42.694] plan(): nbrOfWorkers() = 1
[08:26:42.694] SequentialFuture started (and completed)
[08:26:42.694] - Launch lazy future ... done
[08:26:42.694] run() for ‘SequentialFuture’ ... done
[08:26:42.695] Created future:
[08:26:42.695] SequentialFuture:
[08:26:42.695] Label: ‘future_mapply-1’
[08:26:42.695] Expression:
[08:26:42.695] {
[08:26:42.695]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:42.695]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:42.695]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:42.695]         on.exit(options(oopts), add = TRUE)
[08:26:42.695]     }
[08:26:42.695]     {
[08:26:42.695]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:42.695]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:42.695]         do.call(mapply, args = args)
[08:26:42.695]     }
[08:26:42.695] }
[08:26:42.695] Lazy evaluation: FALSE
[08:26:42.695] Asynchronous evaluation: FALSE
[08:26:42.695] Local evaluation: TRUE
[08:26:42.695] Environment: R_GlobalEnv
[08:26:42.695] Capture standard output: NA
[08:26:42.695] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:42.695] Globals: 5 objects totaling 1.21 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 95 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:42.695] Packages: <none>
[08:26:42.695] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:42.695] Resolved: TRUE
[08:26:42.695] Value: 184 bytes of class ‘list’
[08:26:42.695] Early signaling: FALSE
[08:26:42.695] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:42.695] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:26:42.696] Chunk #1 of 1 ... DONE
[08:26:42.696] Launching 1 futures (chunks) ... DONE
[08:26:42.696] Resolving 1 futures (chunks) ...
[08:26:42.696] resolve() on list ...
[08:26:42.696]  recursive: 0
[08:26:42.696]  length: 1
[08:26:42.696] 
[08:26:42.696] resolved() for ‘SequentialFuture’ ...
[08:26:42.696] - state: ‘finished’
[08:26:42.697] - run: TRUE
[08:26:42.697] - result: ‘FutureResult’
[08:26:42.697] resolved() for ‘SequentialFuture’ ... done
[08:26:42.697] Future #1
[08:26:42.697] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:26:42.697] - nx: 1
[08:26:42.697] - relay: TRUE
[08:26:42.697] - stdout: TRUE
[08:26:42.697] - signal: TRUE
[08:26:42.698] - resignal: FALSE
[08:26:42.698] - force: TRUE
[08:26:42.698] - relayed: [n=1] FALSE
[08:26:42.698] - queued futures: [n=1] FALSE
[08:26:42.698]  - until=1
[08:26:42.698]  - relaying element #1
[08:26:42.698] - relayed: [n=1] TRUE
[08:26:42.698] - queued futures: [n=1] TRUE
[08:26:42.698] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:26:42.698]  length: 0 (resolved future 1)
[08:26:42.699] Relaying remaining futures
[08:26:42.699] signalConditionsASAP(NULL, pos=0) ...
[08:26:42.699] - nx: 1
[08:26:42.699] - relay: TRUE
[08:26:42.699] - stdout: TRUE
[08:26:42.699] - signal: TRUE
[08:26:42.699] - resignal: FALSE
[08:26:42.699] - force: TRUE
[08:26:42.699] - relayed: [n=1] TRUE
[08:26:42.699] - queued futures: [n=1] TRUE
 - flush all
[08:26:42.699] - relayed: [n=1] TRUE
[08:26:42.699] - queued futures: [n=1] TRUE
[08:26:42.700] signalConditionsASAP(NULL, pos=0) ... done
[08:26:42.700] resolve() on list ... DONE
[08:26:42.700]  - Number of value chunks collected: 1
[08:26:42.700] Resolving 1 futures (chunks) ... DONE
[08:26:42.700] Reducing values from 1 chunks ...
[08:26:42.700]  - Number of values collected after concatenation: 2
[08:26:42.700]  - Number of values expected: 2
[08:26:42.700] Reducing values from 1 chunks ... DONE
[08:26:42.700] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[08:26:42.707] plan(): Setting new future strategy stack:
[08:26:42.707] List of future strategies:
[08:26:42.707] 1. multicore:
[08:26:42.707]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:42.707]    - tweaked: FALSE
[08:26:42.707]    - call: plan(strategy)
[08:26:42.709] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[08:26:42.709] future_lapply() ...
[08:26:42.713] Number of chunks: 2
[08:26:42.713] getGlobalsAndPackagesXApply() ...
[08:26:42.713]  - future.globals: TRUE
[08:26:42.713] getGlobalsAndPackages() ...
[08:26:42.713] Searching for globals...
[08:26:42.715] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:42.715] Searching for globals ... DONE
[08:26:42.715] Resolving globals: FALSE
[08:26:42.716] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:42.716] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:42.716] - globals: [1] ‘FUN’
[08:26:42.716] 
[08:26:42.716] getGlobalsAndPackages() ... DONE
[08:26:42.716]  - globals found/used: [n=1] ‘FUN’
[08:26:42.717]  - needed namespaces: [n=0] 
[08:26:42.717] Finding globals ... DONE
[08:26:42.717]  - use_args: TRUE
[08:26:42.717]  - Getting '...' globals ...
[08:26:42.717] resolve() on list ...
[08:26:42.717]  recursive: 0
[08:26:42.717]  length: 1
[08:26:42.717]  elements: ‘...’
[08:26:42.718]  length: 0 (resolved future 1)
[08:26:42.718] resolve() on list ... DONE
[08:26:42.718]    - '...' content: [n=0] 
[08:26:42.718] List of 1
[08:26:42.718]  $ ...: list()
[08:26:42.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:42.718]  - attr(*, "where")=List of 1
[08:26:42.718]   ..$ ...:<environment: 0x55e10ee3f530> 
[08:26:42.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:42.718]  - attr(*, "resolved")= logi TRUE
[08:26:42.718]  - attr(*, "total_size")= num NA
[08:26:42.721]  - Getting '...' globals ... DONE
[08:26:42.721] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:42.721] List of 2
[08:26:42.721]  $ ...future.FUN:function (x)  
[08:26:42.721]  $ ...          : list()
[08:26:42.721]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:42.721]  - attr(*, "where")=List of 2
[08:26:42.721]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:42.721]   ..$ ...          :<environment: 0x55e10ee3f530> 
[08:26:42.721]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:42.721]  - attr(*, "resolved")= logi FALSE
[08:26:42.721]  - attr(*, "total_size")= num 5632
[08:26:42.724] Packages to be attached in all futures: [n=0] 
[08:26:42.724] getGlobalsAndPackagesXApply() ... DONE
[08:26:42.724] Number of futures (= number of chunks): 2
[08:26:42.724] Launching 2 futures (chunks) ...
[08:26:42.724] Chunk #1 of 2 ...
[08:26:42.724]  - Finding globals in 'X' for chunk #1 ...
[08:26:42.724] getGlobalsAndPackages() ...
[08:26:42.725] Searching for globals...
[08:26:42.725] 
[08:26:42.725] Searching for globals ... DONE
[08:26:42.725] - globals: [0] <none>
[08:26:42.725] getGlobalsAndPackages() ... DONE
[08:26:42.725]    + additional globals found: [n=0] 
[08:26:42.725]    + additional namespaces needed: [n=0] 
[08:26:42.725]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:42.725]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:42.726]  - seeds: <none>
[08:26:42.726]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:42.726] getGlobalsAndPackages() ...
[08:26:42.726] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:42.726] Resolving globals: FALSE
[08:26:42.726] Tweak future expression to call with '...' arguments ...
[08:26:42.726] {
[08:26:42.726]     do.call(function(...) {
[08:26:42.726]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:42.726]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:42.726]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:42.726]             on.exit(options(oopts), add = TRUE)
[08:26:42.726]         }
[08:26:42.726]         {
[08:26:42.726]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:42.726]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:42.726]                 ...future.FUN(...future.X_jj, ...)
[08:26:42.726]             })
[08:26:42.726]         }
[08:26:42.726]     }, args = future.call.arguments)
[08:26:42.726] }
[08:26:42.726] Tweak future expression to call with '...' arguments ... DONE
[08:26:42.727] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:42.727] 
[08:26:42.727] getGlobalsAndPackages() ... DONE
[08:26:42.727] run() for ‘Future’ ...
[08:26:42.727] - state: ‘created’
[08:26:42.728] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:42.730] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:42.730] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:42.730]   - Field: ‘label’
[08:26:42.730]   - Field: ‘local’
[08:26:42.730]   - Field: ‘owner’
[08:26:42.730]   - Field: ‘envir’
[08:26:42.730]   - Field: ‘workers’
[08:26:42.730]   - Field: ‘packages’
[08:26:42.730]   - Field: ‘gc’
[08:26:42.731]   - Field: ‘job’
[08:26:42.731]   - Field: ‘conditions’
[08:26:42.731]   - Field: ‘expr’
[08:26:42.731]   - Field: ‘uuid’
[08:26:42.731]   - Field: ‘seed’
[08:26:42.731]   - Field: ‘version’
[08:26:42.731]   - Field: ‘result’
[08:26:42.731]   - Field: ‘asynchronous’
[08:26:42.731]   - Field: ‘calls’
[08:26:42.731]   - Field: ‘globals’
[08:26:42.731]   - Field: ‘stdout’
[08:26:42.732]   - Field: ‘earlySignal’
[08:26:42.732]   - Field: ‘lazy’
[08:26:42.732]   - Field: ‘state’
[08:26:42.732] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:42.732] - Launch lazy future ...
[08:26:42.733] Packages needed by the future expression (n = 0): <none>
[08:26:42.733] Packages needed by future strategies (n = 0): <none>
[08:26:42.734] {
[08:26:42.734]     {
[08:26:42.734]         {
[08:26:42.734]             ...future.startTime <- base::Sys.time()
[08:26:42.734]             {
[08:26:42.734]                 {
[08:26:42.734]                   {
[08:26:42.734]                     {
[08:26:42.734]                       base::local({
[08:26:42.734]                         has_future <- base::requireNamespace("future", 
[08:26:42.734]                           quietly = TRUE)
[08:26:42.734]                         if (has_future) {
[08:26:42.734]                           ns <- base::getNamespace("future")
[08:26:42.734]                           version <- ns[[".package"]][["version"]]
[08:26:42.734]                           if (is.null(version)) 
[08:26:42.734]                             version <- utils::packageVersion("future")
[08:26:42.734]                         }
[08:26:42.734]                         else {
[08:26:42.734]                           version <- NULL
[08:26:42.734]                         }
[08:26:42.734]                         if (!has_future || version < "1.8.0") {
[08:26:42.734]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:42.734]                             "", base::R.version$version.string), 
[08:26:42.734]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:42.734]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:42.734]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:42.734]                               "release", "version")], collapse = " "), 
[08:26:42.734]                             hostname = base::Sys.info()[["nodename"]])
[08:26:42.734]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:42.734]                             info)
[08:26:42.734]                           info <- base::paste(info, collapse = "; ")
[08:26:42.734]                           if (!has_future) {
[08:26:42.734]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:42.734]                               info)
[08:26:42.734]                           }
[08:26:42.734]                           else {
[08:26:42.734]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:42.734]                               info, version)
[08:26:42.734]                           }
[08:26:42.734]                           base::stop(msg)
[08:26:42.734]                         }
[08:26:42.734]                       })
[08:26:42.734]                     }
[08:26:42.734]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:42.734]                     base::options(mc.cores = 1L)
[08:26:42.734]                   }
[08:26:42.734]                   ...future.strategy.old <- future::plan("list")
[08:26:42.734]                   options(future.plan = NULL)
[08:26:42.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:42.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:42.734]                 }
[08:26:42.734]                 ...future.workdir <- getwd()
[08:26:42.734]             }
[08:26:42.734]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:42.734]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:42.734]         }
[08:26:42.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:42.734]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:42.734]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:42.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:42.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:42.734]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:42.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:42.734]             base::names(...future.oldOptions))
[08:26:42.734]     }
[08:26:42.734]     if (FALSE) {
[08:26:42.734]     }
[08:26:42.734]     else {
[08:26:42.734]         if (FALSE) {
[08:26:42.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:42.734]                 open = "w")
[08:26:42.734]         }
[08:26:42.734]         else {
[08:26:42.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:42.734]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:42.734]         }
[08:26:42.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:42.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:42.734]             base::sink(type = "output", split = FALSE)
[08:26:42.734]             base::close(...future.stdout)
[08:26:42.734]         }, add = TRUE)
[08:26:42.734]     }
[08:26:42.734]     ...future.frame <- base::sys.nframe()
[08:26:42.734]     ...future.conditions <- base::list()
[08:26:42.734]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:42.734]     if (FALSE) {
[08:26:42.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:42.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:42.734]     }
[08:26:42.734]     ...future.result <- base::tryCatch({
[08:26:42.734]         base::withCallingHandlers({
[08:26:42.734]             ...future.value <- base::withVisible(base::local({
[08:26:42.734]                 withCallingHandlers({
[08:26:42.734]                   {
[08:26:42.734]                     do.call(function(...) {
[08:26:42.734]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:42.734]                       if (!identical(...future.globals.maxSize.org, 
[08:26:42.734]                         ...future.globals.maxSize)) {
[08:26:42.734]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:42.734]                         on.exit(options(oopts), add = TRUE)
[08:26:42.734]                       }
[08:26:42.734]                       {
[08:26:42.734]                         lapply(seq_along(...future.elements_ii), 
[08:26:42.734]                           FUN = function(jj) {
[08:26:42.734]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:42.734]                             ...future.FUN(...future.X_jj, ...)
[08:26:42.734]                           })
[08:26:42.734]                       }
[08:26:42.734]                     }, args = future.call.arguments)
[08:26:42.734]                   }
[08:26:42.734]                 }, immediateCondition = function(cond) {
[08:26:42.734]                   save_rds <- function (object, pathname, ...) 
[08:26:42.734]                   {
[08:26:42.734]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:42.734]                     if (file_test("-f", pathname_tmp)) {
[08:26:42.734]                       fi_tmp <- file.info(pathname_tmp)
[08:26:42.734]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:42.734]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:42.734]                         fi_tmp[["mtime"]])
[08:26:42.734]                     }
[08:26:42.734]                     tryCatch({
[08:26:42.734]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:42.734]                     }, error = function(ex) {
[08:26:42.734]                       msg <- conditionMessage(ex)
[08:26:42.734]                       fi_tmp <- file.info(pathname_tmp)
[08:26:42.734]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:42.734]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:42.734]                         fi_tmp[["mtime"]], msg)
[08:26:42.734]                       ex$message <- msg
[08:26:42.734]                       stop(ex)
[08:26:42.734]                     })
[08:26:42.734]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:42.734]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:42.734]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:42.734]                       fi_tmp <- file.info(pathname_tmp)
[08:26:42.734]                       fi <- file.info(pathname)
[08:26:42.734]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:42.734]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:42.734]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:42.734]                         fi[["size"]], fi[["mtime"]])
[08:26:42.734]                       stop(msg)
[08:26:42.734]                     }
[08:26:42.734]                     invisible(pathname)
[08:26:42.734]                   }
[08:26:42.734]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:42.734]                     rootPath = tempdir()) 
[08:26:42.734]                   {
[08:26:42.734]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:42.734]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:42.734]                       tmpdir = path, fileext = ".rds")
[08:26:42.734]                     save_rds(obj, file)
[08:26:42.734]                   }
[08:26:42.734]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:42.734]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:42.734]                   {
[08:26:42.734]                     inherits <- base::inherits
[08:26:42.734]                     invokeRestart <- base::invokeRestart
[08:26:42.734]                     is.null <- base::is.null
[08:26:42.734]                     muffled <- FALSE
[08:26:42.734]                     if (inherits(cond, "message")) {
[08:26:42.734]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:42.734]                       if (muffled) 
[08:26:42.734]                         invokeRestart("muffleMessage")
[08:26:42.734]                     }
[08:26:42.734]                     else if (inherits(cond, "warning")) {
[08:26:42.734]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:42.734]                       if (muffled) 
[08:26:42.734]                         invokeRestart("muffleWarning")
[08:26:42.734]                     }
[08:26:42.734]                     else if (inherits(cond, "condition")) {
[08:26:42.734]                       if (!is.null(pattern)) {
[08:26:42.734]                         computeRestarts <- base::computeRestarts
[08:26:42.734]                         grepl <- base::grepl
[08:26:42.734]                         restarts <- computeRestarts(cond)
[08:26:42.734]                         for (restart in restarts) {
[08:26:42.734]                           name <- restart$name
[08:26:42.734]                           if (is.null(name)) 
[08:26:42.734]                             next
[08:26:42.734]                           if (!grepl(pattern, name)) 
[08:26:42.734]                             next
[08:26:42.734]                           invokeRestart(restart)
[08:26:42.734]                           muffled <- TRUE
[08:26:42.734]                           break
[08:26:42.734]                         }
[08:26:42.734]                       }
[08:26:42.734]                     }
[08:26:42.734]                     invisible(muffled)
[08:26:42.734]                   }
[08:26:42.734]                   muffleCondition(cond)
[08:26:42.734]                 })
[08:26:42.734]             }))
[08:26:42.734]             future::FutureResult(value = ...future.value$value, 
[08:26:42.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:42.734]                   ...future.rng), globalenv = if (FALSE) 
[08:26:42.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:42.734]                     ...future.globalenv.names))
[08:26:42.734]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:42.734]         }, condition = base::local({
[08:26:42.734]             c <- base::c
[08:26:42.734]             inherits <- base::inherits
[08:26:42.734]             invokeRestart <- base::invokeRestart
[08:26:42.734]             length <- base::length
[08:26:42.734]             list <- base::list
[08:26:42.734]             seq.int <- base::seq.int
[08:26:42.734]             signalCondition <- base::signalCondition
[08:26:42.734]             sys.calls <- base::sys.calls
[08:26:42.734]             `[[` <- base::`[[`
[08:26:42.734]             `+` <- base::`+`
[08:26:42.734]             `<<-` <- base::`<<-`
[08:26:42.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:42.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:42.734]                   3L)]
[08:26:42.734]             }
[08:26:42.734]             function(cond) {
[08:26:42.734]                 is_error <- inherits(cond, "error")
[08:26:42.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:42.734]                   NULL)
[08:26:42.734]                 if (is_error) {
[08:26:42.734]                   sessionInformation <- function() {
[08:26:42.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:42.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:42.734]                       search = base::search(), system = base::Sys.info())
[08:26:42.734]                   }
[08:26:42.734]                   ...future.conditions[[length(...future.conditions) + 
[08:26:42.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:42.734]                     cond$call), session = sessionInformation(), 
[08:26:42.734]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:42.734]                   signalCondition(cond)
[08:26:42.734]                 }
[08:26:42.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:42.734]                 "immediateCondition"))) {
[08:26:42.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:42.734]                   ...future.conditions[[length(...future.conditions) + 
[08:26:42.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:42.734]                   if (TRUE && !signal) {
[08:26:42.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:42.734]                     {
[08:26:42.734]                       inherits <- base::inherits
[08:26:42.734]                       invokeRestart <- base::invokeRestart
[08:26:42.734]                       is.null <- base::is.null
[08:26:42.734]                       muffled <- FALSE
[08:26:42.734]                       if (inherits(cond, "message")) {
[08:26:42.734]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:42.734]                         if (muffled) 
[08:26:42.734]                           invokeRestart("muffleMessage")
[08:26:42.734]                       }
[08:26:42.734]                       else if (inherits(cond, "warning")) {
[08:26:42.734]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:42.734]                         if (muffled) 
[08:26:42.734]                           invokeRestart("muffleWarning")
[08:26:42.734]                       }
[08:26:42.734]                       else if (inherits(cond, "condition")) {
[08:26:42.734]                         if (!is.null(pattern)) {
[08:26:42.734]                           computeRestarts <- base::computeRestarts
[08:26:42.734]                           grepl <- base::grepl
[08:26:42.734]                           restarts <- computeRestarts(cond)
[08:26:42.734]                           for (restart in restarts) {
[08:26:42.734]                             name <- restart$name
[08:26:42.734]                             if (is.null(name)) 
[08:26:42.734]                               next
[08:26:42.734]                             if (!grepl(pattern, name)) 
[08:26:42.734]                               next
[08:26:42.734]                             invokeRestart(restart)
[08:26:42.734]                             muffled <- TRUE
[08:26:42.734]                             break
[08:26:42.734]                           }
[08:26:42.734]                         }
[08:26:42.734]                       }
[08:26:42.734]                       invisible(muffled)
[08:26:42.734]                     }
[08:26:42.734]                     muffleCondition(cond, pattern = "^muffle")
[08:26:42.734]                   }
[08:26:42.734]                 }
[08:26:42.734]                 else {
[08:26:42.734]                   if (TRUE) {
[08:26:42.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:42.734]                     {
[08:26:42.734]                       inherits <- base::inherits
[08:26:42.734]                       invokeRestart <- base::invokeRestart
[08:26:42.734]                       is.null <- base::is.null
[08:26:42.734]                       muffled <- FALSE
[08:26:42.734]                       if (inherits(cond, "message")) {
[08:26:42.734]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:42.734]                         if (muffled) 
[08:26:42.734]                           invokeRestart("muffleMessage")
[08:26:42.734]                       }
[08:26:42.734]                       else if (inherits(cond, "warning")) {
[08:26:42.734]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:42.734]                         if (muffled) 
[08:26:42.734]                           invokeRestart("muffleWarning")
[08:26:42.734]                       }
[08:26:42.734]                       else if (inherits(cond, "condition")) {
[08:26:42.734]                         if (!is.null(pattern)) {
[08:26:42.734]                           computeRestarts <- base::computeRestarts
[08:26:42.734]                           grepl <- base::grepl
[08:26:42.734]                           restarts <- computeRestarts(cond)
[08:26:42.734]                           for (restart in restarts) {
[08:26:42.734]                             name <- restart$name
[08:26:42.734]                             if (is.null(name)) 
[08:26:42.734]                               next
[08:26:42.734]                             if (!grepl(pattern, name)) 
[08:26:42.734]                               next
[08:26:42.734]                             invokeRestart(restart)
[08:26:42.734]                             muffled <- TRUE
[08:26:42.734]                             break
[08:26:42.734]                           }
[08:26:42.734]                         }
[08:26:42.734]                       }
[08:26:42.734]                       invisible(muffled)
[08:26:42.734]                     }
[08:26:42.734]                     muffleCondition(cond, pattern = "^muffle")
[08:26:42.734]                   }
[08:26:42.734]                 }
[08:26:42.734]             }
[08:26:42.734]         }))
[08:26:42.734]     }, error = function(ex) {
[08:26:42.734]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:42.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:42.734]                 ...future.rng), started = ...future.startTime, 
[08:26:42.734]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:42.734]             version = "1.8"), class = "FutureResult")
[08:26:42.734]     }, finally = {
[08:26:42.734]         if (!identical(...future.workdir, getwd())) 
[08:26:42.734]             setwd(...future.workdir)
[08:26:42.734]         {
[08:26:42.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:42.734]                 ...future.oldOptions$nwarnings <- NULL
[08:26:42.734]             }
[08:26:42.734]             base::options(...future.oldOptions)
[08:26:42.734]             if (.Platform$OS.type == "windows") {
[08:26:42.734]                 old_names <- names(...future.oldEnvVars)
[08:26:42.734]                 envs <- base::Sys.getenv()
[08:26:42.734]                 names <- names(envs)
[08:26:42.734]                 common <- intersect(names, old_names)
[08:26:42.734]                 added <- setdiff(names, old_names)
[08:26:42.734]                 removed <- setdiff(old_names, names)
[08:26:42.734]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:42.734]                   envs[common]]
[08:26:42.734]                 NAMES <- toupper(changed)
[08:26:42.734]                 args <- list()
[08:26:42.734]                 for (kk in seq_along(NAMES)) {
[08:26:42.734]                   name <- changed[[kk]]
[08:26:42.734]                   NAME <- NAMES[[kk]]
[08:26:42.734]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:42.734]                     next
[08:26:42.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:42.734]                 }
[08:26:42.734]                 NAMES <- toupper(added)
[08:26:42.734]                 for (kk in seq_along(NAMES)) {
[08:26:42.734]                   name <- added[[kk]]
[08:26:42.734]                   NAME <- NAMES[[kk]]
[08:26:42.734]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:42.734]                     next
[08:26:42.734]                   args[[name]] <- ""
[08:26:42.734]                 }
[08:26:42.734]                 NAMES <- toupper(removed)
[08:26:42.734]                 for (kk in seq_along(NAMES)) {
[08:26:42.734]                   name <- removed[[kk]]
[08:26:42.734]                   NAME <- NAMES[[kk]]
[08:26:42.734]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:42.734]                     next
[08:26:42.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:42.734]                 }
[08:26:42.734]                 if (length(args) > 0) 
[08:26:42.734]                   base::do.call(base::Sys.setenv, args = args)
[08:26:42.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:42.734]             }
[08:26:42.734]             else {
[08:26:42.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:42.734]             }
[08:26:42.734]             {
[08:26:42.734]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:42.734]                   0L) {
[08:26:42.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:42.734]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:42.734]                   base::options(opts)
[08:26:42.734]                 }
[08:26:42.734]                 {
[08:26:42.734]                   {
[08:26:42.734]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:42.734]                     NULL
[08:26:42.734]                   }
[08:26:42.734]                   options(future.plan = NULL)
[08:26:42.734]                   if (is.na(NA_character_)) 
[08:26:42.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:42.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:42.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:42.734]                     .init = FALSE)
[08:26:42.734]                 }
[08:26:42.734]             }
[08:26:42.734]         }
[08:26:42.734]     })
[08:26:42.734]     if (TRUE) {
[08:26:42.734]         base::sink(type = "output", split = FALSE)
[08:26:42.734]         if (FALSE) {
[08:26:42.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:42.734]         }
[08:26:42.734]         else {
[08:26:42.734]             ...future.result["stdout"] <- base::list(NULL)
[08:26:42.734]         }
[08:26:42.734]         base::close(...future.stdout)
[08:26:42.734]         ...future.stdout <- NULL
[08:26:42.734]     }
[08:26:42.734]     ...future.result$conditions <- ...future.conditions
[08:26:42.734]     ...future.result$finished <- base::Sys.time()
[08:26:42.734]     ...future.result
[08:26:42.734] }
[08:26:42.736] assign_globals() ...
[08:26:42.736] List of 5
[08:26:42.736]  $ ...future.FUN            :function (x)  
[08:26:42.736]  $ future.call.arguments    : list()
[08:26:42.736]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:42.736]  $ ...future.elements_ii    :List of 1
[08:26:42.736]   ..$ : int 1
[08:26:42.736]  $ ...future.seeds_ii       : NULL
[08:26:42.736]  $ ...future.globals.maxSize: NULL
[08:26:42.736]  - attr(*, "where")=List of 5
[08:26:42.736]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:42.736]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:42.736]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:42.736]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:42.736]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:42.736]  - attr(*, "resolved")= logi FALSE
[08:26:42.736]  - attr(*, "total_size")= num 5632
[08:26:42.736]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:42.736]  - attr(*, "already-done")= logi TRUE
[08:26:42.745] - reassign environment for ‘...future.FUN’
[08:26:42.745] - copied ‘...future.FUN’ to environment
[08:26:42.745] - copied ‘future.call.arguments’ to environment
[08:26:42.745] - copied ‘...future.elements_ii’ to environment
[08:26:42.745] - copied ‘...future.seeds_ii’ to environment
[08:26:42.745] - copied ‘...future.globals.maxSize’ to environment
[08:26:42.746] assign_globals() ... done
[08:26:42.746] requestCore(): workers = 2
[08:26:42.749] MulticoreFuture started
[08:26:42.750] - Launch lazy future ... done
[08:26:42.750] plan(): Setting new future strategy stack:
[08:26:42.750] run() for ‘MulticoreFuture’ ... done
[08:26:42.751] Created future:
[08:26:42.750] List of future strategies:
[08:26:42.750] 1. sequential:
[08:26:42.750]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:42.750]    - tweaked: FALSE
[08:26:42.750]    - call: NULL
[08:26:42.752] plan(): nbrOfWorkers() = 1
[08:26:42.751] MulticoreFuture:
[08:26:42.751] Label: ‘future_lapply-1’
[08:26:42.751] Expression:
[08:26:42.751] {
[08:26:42.751]     do.call(function(...) {
[08:26:42.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:42.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:42.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:42.751]             on.exit(options(oopts), add = TRUE)
[08:26:42.751]         }
[08:26:42.751]         {
[08:26:42.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:42.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:42.751]                 ...future.FUN(...future.X_jj, ...)
[08:26:42.751]             })
[08:26:42.751]         }
[08:26:42.751]     }, args = future.call.arguments)
[08:26:42.751] }
[08:26:42.751] Lazy evaluation: FALSE
[08:26:42.751] Asynchronous evaluation: TRUE
[08:26:42.751] Local evaluation: TRUE
[08:26:42.751] Environment: R_GlobalEnv
[08:26:42.751] Capture standard output: FALSE
[08:26:42.751] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:42.751] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:42.751] Packages: <none>
[08:26:42.751] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:42.751] Resolved: FALSE
[08:26:42.751] Value: <not collected>
[08:26:42.751] Conditions captured: <none>
[08:26:42.751] Early signaling: FALSE
[08:26:42.751] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:42.751] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:42.766] Chunk #1 of 2 ... DONE
[08:26:42.767] Chunk #2 of 2 ...
[08:26:42.767]  - Finding globals in 'X' for chunk #2 ...
[08:26:42.767] getGlobalsAndPackages() ...
[08:26:42.768] Searching for globals...
[08:26:42.768] 
[08:26:42.769] Searching for globals ... DONE
[08:26:42.769] - globals: [0] <none>
[08:26:42.769] getGlobalsAndPackages() ... DONE
[08:26:42.769]    + additional globals found: [n=0] 
[08:26:42.769]    + additional namespaces needed: [n=0] 
[08:26:42.770]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:42.770]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:42.770]  - seeds: <none>
[08:26:42.770]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:42.770] getGlobalsAndPackages() ...
[08:26:42.771] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:42.771] Resolving globals: FALSE
[08:26:42.771] Tweak future expression to call with '...' arguments ...
[08:26:42.771] {
[08:26:42.771]     do.call(function(...) {
[08:26:42.771]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:42.771]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:42.771]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:42.771]             on.exit(options(oopts), add = TRUE)
[08:26:42.771]         }
[08:26:42.771]         {
[08:26:42.771]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:42.771]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:42.771]                 ...future.FUN(...future.X_jj, ...)
[08:26:42.771]             })
[08:26:42.771]         }
[08:26:42.771]     }, args = future.call.arguments)
[08:26:42.771] }
[08:26:42.772] Tweak future expression to call with '...' arguments ... DONE
[08:26:42.773] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:42.773] 
[08:26:42.773] getGlobalsAndPackages() ... DONE
[08:26:42.774] run() for ‘Future’ ...
[08:26:42.774] - state: ‘created’
[08:26:42.774] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:42.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:42.779] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:42.779]   - Field: ‘label’
[08:26:42.779]   - Field: ‘local’
[08:26:42.779]   - Field: ‘owner’
[08:26:42.779]   - Field: ‘envir’
[08:26:42.780]   - Field: ‘workers’
[08:26:42.780]   - Field: ‘packages’
[08:26:42.780]   - Field: ‘gc’
[08:26:42.780]   - Field: ‘job’
[08:26:42.780]   - Field: ‘conditions’
[08:26:42.781]   - Field: ‘expr’
[08:26:42.781]   - Field: ‘uuid’
[08:26:42.781]   - Field: ‘seed’
[08:26:42.781]   - Field: ‘version’
[08:26:42.781]   - Field: ‘result’
[08:26:42.781]   - Field: ‘asynchronous’
[08:26:42.781]   - Field: ‘calls’
[08:26:42.782]   - Field: ‘globals’
[08:26:42.782]   - Field: ‘stdout’
[08:26:42.782]   - Field: ‘earlySignal’
[08:26:42.782]   - Field: ‘lazy’
[08:26:42.782]   - Field: ‘state’
[08:26:42.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:42.783] - Launch lazy future ...
[08:26:42.783] Packages needed by the future expression (n = 0): <none>
[08:26:42.784] Packages needed by future strategies (n = 0): <none>
[08:26:42.784] {
[08:26:42.784]     {
[08:26:42.784]         {
[08:26:42.784]             ...future.startTime <- base::Sys.time()
[08:26:42.784]             {
[08:26:42.784]                 {
[08:26:42.784]                   {
[08:26:42.784]                     {
[08:26:42.784]                       base::local({
[08:26:42.784]                         has_future <- base::requireNamespace("future", 
[08:26:42.784]                           quietly = TRUE)
[08:26:42.784]                         if (has_future) {
[08:26:42.784]                           ns <- base::getNamespace("future")
[08:26:42.784]                           version <- ns[[".package"]][["version"]]
[08:26:42.784]                           if (is.null(version)) 
[08:26:42.784]                             version <- utils::packageVersion("future")
[08:26:42.784]                         }
[08:26:42.784]                         else {
[08:26:42.784]                           version <- NULL
[08:26:42.784]                         }
[08:26:42.784]                         if (!has_future || version < "1.8.0") {
[08:26:42.784]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:42.784]                             "", base::R.version$version.string), 
[08:26:42.784]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:42.784]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:42.784]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:42.784]                               "release", "version")], collapse = " "), 
[08:26:42.784]                             hostname = base::Sys.info()[["nodename"]])
[08:26:42.784]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:42.784]                             info)
[08:26:42.784]                           info <- base::paste(info, collapse = "; ")
[08:26:42.784]                           if (!has_future) {
[08:26:42.784]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:42.784]                               info)
[08:26:42.784]                           }
[08:26:42.784]                           else {
[08:26:42.784]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:42.784]                               info, version)
[08:26:42.784]                           }
[08:26:42.784]                           base::stop(msg)
[08:26:42.784]                         }
[08:26:42.784]                       })
[08:26:42.784]                     }
[08:26:42.784]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:42.784]                     base::options(mc.cores = 1L)
[08:26:42.784]                   }
[08:26:42.784]                   ...future.strategy.old <- future::plan("list")
[08:26:42.784]                   options(future.plan = NULL)
[08:26:42.784]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:42.784]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:42.784]                 }
[08:26:42.784]                 ...future.workdir <- getwd()
[08:26:42.784]             }
[08:26:42.784]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:42.784]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:42.784]         }
[08:26:42.784]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:42.784]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:42.784]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:42.784]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:42.784]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:42.784]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:42.784]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:42.784]             base::names(...future.oldOptions))
[08:26:42.784]     }
[08:26:42.784]     if (FALSE) {
[08:26:42.784]     }
[08:26:42.784]     else {
[08:26:42.784]         if (FALSE) {
[08:26:42.784]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:42.784]                 open = "w")
[08:26:42.784]         }
[08:26:42.784]         else {
[08:26:42.784]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:42.784]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:42.784]         }
[08:26:42.784]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:42.784]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:42.784]             base::sink(type = "output", split = FALSE)
[08:26:42.784]             base::close(...future.stdout)
[08:26:42.784]         }, add = TRUE)
[08:26:42.784]     }
[08:26:42.784]     ...future.frame <- base::sys.nframe()
[08:26:42.784]     ...future.conditions <- base::list()
[08:26:42.784]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:42.784]     if (FALSE) {
[08:26:42.784]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:42.784]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:42.784]     }
[08:26:42.784]     ...future.result <- base::tryCatch({
[08:26:42.784]         base::withCallingHandlers({
[08:26:42.784]             ...future.value <- base::withVisible(base::local({
[08:26:42.784]                 withCallingHandlers({
[08:26:42.784]                   {
[08:26:42.784]                     do.call(function(...) {
[08:26:42.784]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:42.784]                       if (!identical(...future.globals.maxSize.org, 
[08:26:42.784]                         ...future.globals.maxSize)) {
[08:26:42.784]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:42.784]                         on.exit(options(oopts), add = TRUE)
[08:26:42.784]                       }
[08:26:42.784]                       {
[08:26:42.784]                         lapply(seq_along(...future.elements_ii), 
[08:26:42.784]                           FUN = function(jj) {
[08:26:42.784]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:42.784]                             ...future.FUN(...future.X_jj, ...)
[08:26:42.784]                           })
[08:26:42.784]                       }
[08:26:42.784]                     }, args = future.call.arguments)
[08:26:42.784]                   }
[08:26:42.784]                 }, immediateCondition = function(cond) {
[08:26:42.784]                   save_rds <- function (object, pathname, ...) 
[08:26:42.784]                   {
[08:26:42.784]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:42.784]                     if (file_test("-f", pathname_tmp)) {
[08:26:42.784]                       fi_tmp <- file.info(pathname_tmp)
[08:26:42.784]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:42.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:42.784]                         fi_tmp[["mtime"]])
[08:26:42.784]                     }
[08:26:42.784]                     tryCatch({
[08:26:42.784]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:42.784]                     }, error = function(ex) {
[08:26:42.784]                       msg <- conditionMessage(ex)
[08:26:42.784]                       fi_tmp <- file.info(pathname_tmp)
[08:26:42.784]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:42.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:42.784]                         fi_tmp[["mtime"]], msg)
[08:26:42.784]                       ex$message <- msg
[08:26:42.784]                       stop(ex)
[08:26:42.784]                     })
[08:26:42.784]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:42.784]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:42.784]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:42.784]                       fi_tmp <- file.info(pathname_tmp)
[08:26:42.784]                       fi <- file.info(pathname)
[08:26:42.784]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:42.784]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:42.784]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:42.784]                         fi[["size"]], fi[["mtime"]])
[08:26:42.784]                       stop(msg)
[08:26:42.784]                     }
[08:26:42.784]                     invisible(pathname)
[08:26:42.784]                   }
[08:26:42.784]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:42.784]                     rootPath = tempdir()) 
[08:26:42.784]                   {
[08:26:42.784]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:42.784]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:42.784]                       tmpdir = path, fileext = ".rds")
[08:26:42.784]                     save_rds(obj, file)
[08:26:42.784]                   }
[08:26:42.784]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:42.784]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:42.784]                   {
[08:26:42.784]                     inherits <- base::inherits
[08:26:42.784]                     invokeRestart <- base::invokeRestart
[08:26:42.784]                     is.null <- base::is.null
[08:26:42.784]                     muffled <- FALSE
[08:26:42.784]                     if (inherits(cond, "message")) {
[08:26:42.784]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:42.784]                       if (muffled) 
[08:26:42.784]                         invokeRestart("muffleMessage")
[08:26:42.784]                     }
[08:26:42.784]                     else if (inherits(cond, "warning")) {
[08:26:42.784]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:42.784]                       if (muffled) 
[08:26:42.784]                         invokeRestart("muffleWarning")
[08:26:42.784]                     }
[08:26:42.784]                     else if (inherits(cond, "condition")) {
[08:26:42.784]                       if (!is.null(pattern)) {
[08:26:42.784]                         computeRestarts <- base::computeRestarts
[08:26:42.784]                         grepl <- base::grepl
[08:26:42.784]                         restarts <- computeRestarts(cond)
[08:26:42.784]                         for (restart in restarts) {
[08:26:42.784]                           name <- restart$name
[08:26:42.784]                           if (is.null(name)) 
[08:26:42.784]                             next
[08:26:42.784]                           if (!grepl(pattern, name)) 
[08:26:42.784]                             next
[08:26:42.784]                           invokeRestart(restart)
[08:26:42.784]                           muffled <- TRUE
[08:26:42.784]                           break
[08:26:42.784]                         }
[08:26:42.784]                       }
[08:26:42.784]                     }
[08:26:42.784]                     invisible(muffled)
[08:26:42.784]                   }
[08:26:42.784]                   muffleCondition(cond)
[08:26:42.784]                 })
[08:26:42.784]             }))
[08:26:42.784]             future::FutureResult(value = ...future.value$value, 
[08:26:42.784]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:42.784]                   ...future.rng), globalenv = if (FALSE) 
[08:26:42.784]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:42.784]                     ...future.globalenv.names))
[08:26:42.784]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:42.784]         }, condition = base::local({
[08:26:42.784]             c <- base::c
[08:26:42.784]             inherits <- base::inherits
[08:26:42.784]             invokeRestart <- base::invokeRestart
[08:26:42.784]             length <- base::length
[08:26:42.784]             list <- base::list
[08:26:42.784]             seq.int <- base::seq.int
[08:26:42.784]             signalCondition <- base::signalCondition
[08:26:42.784]             sys.calls <- base::sys.calls
[08:26:42.784]             `[[` <- base::`[[`
[08:26:42.784]             `+` <- base::`+`
[08:26:42.784]             `<<-` <- base::`<<-`
[08:26:42.784]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:42.784]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:42.784]                   3L)]
[08:26:42.784]             }
[08:26:42.784]             function(cond) {
[08:26:42.784]                 is_error <- inherits(cond, "error")
[08:26:42.784]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:42.784]                   NULL)
[08:26:42.784]                 if (is_error) {
[08:26:42.784]                   sessionInformation <- function() {
[08:26:42.784]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:42.784]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:42.784]                       search = base::search(), system = base::Sys.info())
[08:26:42.784]                   }
[08:26:42.784]                   ...future.conditions[[length(...future.conditions) + 
[08:26:42.784]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:42.784]                     cond$call), session = sessionInformation(), 
[08:26:42.784]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:42.784]                   signalCondition(cond)
[08:26:42.784]                 }
[08:26:42.784]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:42.784]                 "immediateCondition"))) {
[08:26:42.784]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:42.784]                   ...future.conditions[[length(...future.conditions) + 
[08:26:42.784]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:42.784]                   if (TRUE && !signal) {
[08:26:42.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:42.784]                     {
[08:26:42.784]                       inherits <- base::inherits
[08:26:42.784]                       invokeRestart <- base::invokeRestart
[08:26:42.784]                       is.null <- base::is.null
[08:26:42.784]                       muffled <- FALSE
[08:26:42.784]                       if (inherits(cond, "message")) {
[08:26:42.784]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:42.784]                         if (muffled) 
[08:26:42.784]                           invokeRestart("muffleMessage")
[08:26:42.784]                       }
[08:26:42.784]                       else if (inherits(cond, "warning")) {
[08:26:42.784]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:42.784]                         if (muffled) 
[08:26:42.784]                           invokeRestart("muffleWarning")
[08:26:42.784]                       }
[08:26:42.784]                       else if (inherits(cond, "condition")) {
[08:26:42.784]                         if (!is.null(pattern)) {
[08:26:42.784]                           computeRestarts <- base::computeRestarts
[08:26:42.784]                           grepl <- base::grepl
[08:26:42.784]                           restarts <- computeRestarts(cond)
[08:26:42.784]                           for (restart in restarts) {
[08:26:42.784]                             name <- restart$name
[08:26:42.784]                             if (is.null(name)) 
[08:26:42.784]                               next
[08:26:42.784]                             if (!grepl(pattern, name)) 
[08:26:42.784]                               next
[08:26:42.784]                             invokeRestart(restart)
[08:26:42.784]                             muffled <- TRUE
[08:26:42.784]                             break
[08:26:42.784]                           }
[08:26:42.784]                         }
[08:26:42.784]                       }
[08:26:42.784]                       invisible(muffled)
[08:26:42.784]                     }
[08:26:42.784]                     muffleCondition(cond, pattern = "^muffle")
[08:26:42.784]                   }
[08:26:42.784]                 }
[08:26:42.784]                 else {
[08:26:42.784]                   if (TRUE) {
[08:26:42.784]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:42.784]                     {
[08:26:42.784]                       inherits <- base::inherits
[08:26:42.784]                       invokeRestart <- base::invokeRestart
[08:26:42.784]                       is.null <- base::is.null
[08:26:42.784]                       muffled <- FALSE
[08:26:42.784]                       if (inherits(cond, "message")) {
[08:26:42.784]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:42.784]                         if (muffled) 
[08:26:42.784]                           invokeRestart("muffleMessage")
[08:26:42.784]                       }
[08:26:42.784]                       else if (inherits(cond, "warning")) {
[08:26:42.784]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:42.784]                         if (muffled) 
[08:26:42.784]                           invokeRestart("muffleWarning")
[08:26:42.784]                       }
[08:26:42.784]                       else if (inherits(cond, "condition")) {
[08:26:42.784]                         if (!is.null(pattern)) {
[08:26:42.784]                           computeRestarts <- base::computeRestarts
[08:26:42.784]                           grepl <- base::grepl
[08:26:42.784]                           restarts <- computeRestarts(cond)
[08:26:42.784]                           for (restart in restarts) {
[08:26:42.784]                             name <- restart$name
[08:26:42.784]                             if (is.null(name)) 
[08:26:42.784]                               next
[08:26:42.784]                             if (!grepl(pattern, name)) 
[08:26:42.784]                               next
[08:26:42.784]                             invokeRestart(restart)
[08:26:42.784]                             muffled <- TRUE
[08:26:42.784]                             break
[08:26:42.784]                           }
[08:26:42.784]                         }
[08:26:42.784]                       }
[08:26:42.784]                       invisible(muffled)
[08:26:42.784]                     }
[08:26:42.784]                     muffleCondition(cond, pattern = "^muffle")
[08:26:42.784]                   }
[08:26:42.784]                 }
[08:26:42.784]             }
[08:26:42.784]         }))
[08:26:42.784]     }, error = function(ex) {
[08:26:42.784]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:42.784]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:42.784]                 ...future.rng), started = ...future.startTime, 
[08:26:42.784]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:42.784]             version = "1.8"), class = "FutureResult")
[08:26:42.784]     }, finally = {
[08:26:42.784]         if (!identical(...future.workdir, getwd())) 
[08:26:42.784]             setwd(...future.workdir)
[08:26:42.784]         {
[08:26:42.784]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:42.784]                 ...future.oldOptions$nwarnings <- NULL
[08:26:42.784]             }
[08:26:42.784]             base::options(...future.oldOptions)
[08:26:42.784]             if (.Platform$OS.type == "windows") {
[08:26:42.784]                 old_names <- names(...future.oldEnvVars)
[08:26:42.784]                 envs <- base::Sys.getenv()
[08:26:42.784]                 names <- names(envs)
[08:26:42.784]                 common <- intersect(names, old_names)
[08:26:42.784]                 added <- setdiff(names, old_names)
[08:26:42.784]                 removed <- setdiff(old_names, names)
[08:26:42.784]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:42.784]                   envs[common]]
[08:26:42.784]                 NAMES <- toupper(changed)
[08:26:42.784]                 args <- list()
[08:26:42.784]                 for (kk in seq_along(NAMES)) {
[08:26:42.784]                   name <- changed[[kk]]
[08:26:42.784]                   NAME <- NAMES[[kk]]
[08:26:42.784]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:42.784]                     next
[08:26:42.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:42.784]                 }
[08:26:42.784]                 NAMES <- toupper(added)
[08:26:42.784]                 for (kk in seq_along(NAMES)) {
[08:26:42.784]                   name <- added[[kk]]
[08:26:42.784]                   NAME <- NAMES[[kk]]
[08:26:42.784]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:42.784]                     next
[08:26:42.784]                   args[[name]] <- ""
[08:26:42.784]                 }
[08:26:42.784]                 NAMES <- toupper(removed)
[08:26:42.784]                 for (kk in seq_along(NAMES)) {
[08:26:42.784]                   name <- removed[[kk]]
[08:26:42.784]                   NAME <- NAMES[[kk]]
[08:26:42.784]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:42.784]                     next
[08:26:42.784]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:42.784]                 }
[08:26:42.784]                 if (length(args) > 0) 
[08:26:42.784]                   base::do.call(base::Sys.setenv, args = args)
[08:26:42.784]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:42.784]             }
[08:26:42.784]             else {
[08:26:42.784]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:42.784]             }
[08:26:42.784]             {
[08:26:42.784]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:42.784]                   0L) {
[08:26:42.784]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:42.784]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:42.784]                   base::options(opts)
[08:26:42.784]                 }
[08:26:42.784]                 {
[08:26:42.784]                   {
[08:26:42.784]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:42.784]                     NULL
[08:26:42.784]                   }
[08:26:42.784]                   options(future.plan = NULL)
[08:26:42.784]                   if (is.na(NA_character_)) 
[08:26:42.784]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:42.784]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:42.784]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:42.784]                     .init = FALSE)
[08:26:42.784]                 }
[08:26:42.784]             }
[08:26:42.784]         }
[08:26:42.784]     })
[08:26:42.784]     if (TRUE) {
[08:26:42.784]         base::sink(type = "output", split = FALSE)
[08:26:42.784]         if (FALSE) {
[08:26:42.784]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:42.784]         }
[08:26:42.784]         else {
[08:26:42.784]             ...future.result["stdout"] <- base::list(NULL)
[08:26:42.784]         }
[08:26:42.784]         base::close(...future.stdout)
[08:26:42.784]         ...future.stdout <- NULL
[08:26:42.784]     }
[08:26:42.784]     ...future.result$conditions <- ...future.conditions
[08:26:42.784]     ...future.result$finished <- base::Sys.time()
[08:26:42.784]     ...future.result
[08:26:42.784] }
[08:26:42.788] assign_globals() ...
[08:26:42.788] List of 5
[08:26:42.788]  $ ...future.FUN            :function (x)  
[08:26:42.788]  $ future.call.arguments    : list()
[08:26:42.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:42.788]  $ ...future.elements_ii    :List of 1
[08:26:42.788]   ..$ : int 0
[08:26:42.788]  $ ...future.seeds_ii       : NULL
[08:26:42.788]  $ ...future.globals.maxSize: NULL
[08:26:42.788]  - attr(*, "where")=List of 5
[08:26:42.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:42.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:42.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:42.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:42.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:42.788]  - attr(*, "resolved")= logi FALSE
[08:26:42.788]  - attr(*, "total_size")= num 5632
[08:26:42.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:42.788]  - attr(*, "already-done")= logi TRUE
[08:26:42.796] - reassign environment for ‘...future.FUN’
[08:26:42.796] - copied ‘...future.FUN’ to environment
[08:26:42.796] - copied ‘future.call.arguments’ to environment
[08:26:42.797] - copied ‘...future.elements_ii’ to environment
[08:26:42.797] - copied ‘...future.seeds_ii’ to environment
[08:26:42.797] - copied ‘...future.globals.maxSize’ to environment
[08:26:42.797] assign_globals() ... done
[08:26:42.797] requestCore(): workers = 2
[08:26:42.809] MulticoreFuture started
[08:26:42.809] - Launch lazy future ... done
[08:26:42.810] plan(): Setting new future strategy stack:
[08:26:42.810] run() for ‘MulticoreFuture’ ... done
[08:26:42.811] Created future:
[08:26:42.811] List of future strategies:
[08:26:42.811] 1. sequential:
[08:26:42.811]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:42.811]    - tweaked: FALSE
[08:26:42.811]    - call: NULL
[08:26:42.812] plan(): nbrOfWorkers() = 1
[08:26:42.815] plan(): Setting new future strategy stack:
[08:26:42.815] List of future strategies:
[08:26:42.815] 1. multicore:
[08:26:42.815]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:42.815]    - tweaked: FALSE
[08:26:42.815]    - call: plan(strategy)
[08:26:42.819] plan(): nbrOfWorkers() = 2
[08:26:42.811] MulticoreFuture:
[08:26:42.811] Label: ‘future_lapply-2’
[08:26:42.811] Expression:
[08:26:42.811] {
[08:26:42.811]     do.call(function(...) {
[08:26:42.811]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:42.811]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:42.811]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:42.811]             on.exit(options(oopts), add = TRUE)
[08:26:42.811]         }
[08:26:42.811]         {
[08:26:42.811]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:42.811]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:42.811]                 ...future.FUN(...future.X_jj, ...)
[08:26:42.811]             })
[08:26:42.811]         }
[08:26:42.811]     }, args = future.call.arguments)
[08:26:42.811] }
[08:26:42.811] Lazy evaluation: FALSE
[08:26:42.811] Asynchronous evaluation: TRUE
[08:26:42.811] Local evaluation: TRUE
[08:26:42.811] Environment: R_GlobalEnv
[08:26:42.811] Capture standard output: FALSE
[08:26:42.811] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:42.811] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:42.811] Packages: <none>
[08:26:42.811] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:42.811] Resolved: TRUE
[08:26:42.811] Value: <not collected>
[08:26:42.811] Conditions captured: <none>
[08:26:42.811] Early signaling: FALSE
[08:26:42.811] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:42.811] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:42.820] Chunk #2 of 2 ... DONE
[08:26:42.820] Launching 2 futures (chunks) ... DONE
[08:26:42.820] Resolving 2 futures (chunks) ...
[08:26:42.821] resolve() on list ...
[08:26:42.821]  recursive: 0
[08:26:42.821]  length: 2
[08:26:42.821] 
[08:26:42.832] Future #2
[08:26:42.833] result() for MulticoreFuture ...
[08:26:42.836] result() for MulticoreFuture ...
[08:26:42.836] result() for MulticoreFuture ... done
[08:26:42.836] result() for MulticoreFuture ... done
[08:26:42.836] result() for MulticoreFuture ...
[08:26:42.836] result() for MulticoreFuture ... done
[08:26:42.836] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:42.837] - nx: 2
[08:26:42.837] - relay: TRUE
[08:26:42.837] - stdout: TRUE
[08:26:42.837] - signal: TRUE
[08:26:42.837] - resignal: FALSE
[08:26:42.837] - force: TRUE
[08:26:42.838] - relayed: [n=2] FALSE, FALSE
[08:26:42.838] - queued futures: [n=2] FALSE, FALSE
[08:26:42.838]  - until=1
[08:26:42.838]  - relaying element #1
[08:26:42.838] - relayed: [n=2] FALSE, FALSE
[08:26:42.838] - queued futures: [n=2] FALSE, TRUE
[08:26:42.838] signalConditionsASAP(NULL, pos=2) ... done
[08:26:42.838]  length: 1 (resolved future 2)
[08:26:43.255] plan(): Setting new future strategy stack:
[08:26:43.255] List of future strategies:
[08:26:43.255] 1. multicore:
[08:26:43.255]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:43.255]    - tweaked: FALSE
[08:26:43.255]    - call: plan(strategy)
[08:26:43.257] plan(): nbrOfWorkers() = 2
[08:26:43.262] Future #1
[08:26:43.262] result() for MulticoreFuture ...
[08:26:43.263] result() for MulticoreFuture ...
[08:26:43.263] result() for MulticoreFuture ... done
[08:26:43.263] result() for MulticoreFuture ... done
[08:26:43.263] result() for MulticoreFuture ...
[08:26:43.263] result() for MulticoreFuture ... done
[08:26:43.264] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:43.264] - nx: 2
[08:26:43.264] - relay: TRUE
[08:26:43.264] - stdout: TRUE
[08:26:43.264] - signal: TRUE
[08:26:43.264] - resignal: FALSE
[08:26:43.264] - force: TRUE
[08:26:43.264] - relayed: [n=2] FALSE, FALSE
[08:26:43.264] - queued futures: [n=2] FALSE, TRUE
[08:26:43.265]  - until=1
[08:26:43.265]  - relaying element #1
[08:26:43.265] result() for MulticoreFuture ...
[08:26:43.265] result() for MulticoreFuture ... done
[08:26:43.265] result() for MulticoreFuture ...
[08:26:43.265] result() for MulticoreFuture ... done
[08:26:43.265] result() for MulticoreFuture ...
[08:26:43.265] result() for MulticoreFuture ... done
[08:26:43.266] result() for MulticoreFuture ...
[08:26:43.266] result() for MulticoreFuture ... done
[08:26:43.266] - relayed: [n=2] TRUE, FALSE
[08:26:43.266] - queued futures: [n=2] TRUE, TRUE
[08:26:43.266] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:43.266]  length: 0 (resolved future 1)
[08:26:43.266] Relaying remaining futures
[08:26:43.266] signalConditionsASAP(NULL, pos=0) ...
[08:26:43.266] - nx: 2
[08:26:43.266] - relay: TRUE
[08:26:43.267] - stdout: TRUE
[08:26:43.267] - signal: TRUE
[08:26:43.267] - resignal: FALSE
[08:26:43.267] - force: TRUE
[08:26:43.267] - relayed: [n=2] TRUE, FALSE
[08:26:43.267] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:43.267]  - relaying element #2
[08:26:43.267] result() for MulticoreFuture ...
[08:26:43.268] result() for MulticoreFuture ... done
[08:26:43.268] result() for MulticoreFuture ...
[08:26:43.268] result() for MulticoreFuture ... done
[08:26:43.268] result() for MulticoreFuture ...
[08:26:43.268] result() for MulticoreFuture ... done
[08:26:43.268] result() for MulticoreFuture ...
[08:26:43.268] result() for MulticoreFuture ... done
[08:26:43.268] - relayed: [n=2] TRUE, TRUE
[08:26:43.269] - queued futures: [n=2] TRUE, TRUE
[08:26:43.269] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[08:26:43.269] resolve() on list ... DONE
[08:26:43.269] result() for MulticoreFuture ...
[08:26:43.269] result() for MulticoreFuture ... done
[08:26:43.269] result() for MulticoreFuture ...
[08:26:43.269] result() for MulticoreFuture ... done
[08:26:43.269] result() for MulticoreFuture ...
[08:26:43.269] result() for MulticoreFuture ... done
[08:26:43.270] result() for MulticoreFuture ...
[08:26:43.270] result() for MulticoreFuture ... done
[08:26:43.270]  - Number of value chunks collected: 2
[08:26:43.270] Resolving 2 futures (chunks) ... DONE
[08:26:43.270] Reducing values from 2 chunks ...
[08:26:43.270]  - Number of values collected after concatenation: 2
[08:26:43.270]  - Number of values expected: 2
[08:26:43.270] Reducing values from 2 chunks ... DONE
[08:26:43.270] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[08:26:43.271] future_lapply() ...
[08:26:43.274] Number of chunks: 2
[08:26:43.274] getGlobalsAndPackagesXApply() ...
[08:26:43.274]  - future.globals: TRUE
[08:26:43.274] getGlobalsAndPackages() ...
[08:26:43.275] Searching for globals...
[08:26:43.276] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:43.277] Searching for globals ... DONE
[08:26:43.277] Resolving globals: FALSE
[08:26:43.277] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:43.278] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:43.278] - globals: [1] ‘FUN’
[08:26:43.278] 
[08:26:43.278] getGlobalsAndPackages() ... DONE
[08:26:43.278]  - globals found/used: [n=1] ‘FUN’
[08:26:43.278]  - needed namespaces: [n=0] 
[08:26:43.278] Finding globals ... DONE
[08:26:43.278]  - use_args: TRUE
[08:26:43.278]  - Getting '...' globals ...
[08:26:43.279] resolve() on list ...
[08:26:43.279]  recursive: 0
[08:26:43.279]  length: 1
[08:26:43.279]  elements: ‘...’
[08:26:43.279]  length: 0 (resolved future 1)
[08:26:43.280] resolve() on list ... DONE
[08:26:43.280]    - '...' content: [n=0] 
[08:26:43.280] List of 1
[08:26:43.280]  $ ...: list()
[08:26:43.280]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:43.280]  - attr(*, "where")=List of 1
[08:26:43.280]   ..$ ...:<environment: 0x55e10e78b638> 
[08:26:43.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:43.280]  - attr(*, "resolved")= logi TRUE
[08:26:43.280]  - attr(*, "total_size")= num NA
[08:26:43.286]  - Getting '...' globals ... DONE
[08:26:43.286] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:43.286] List of 2
[08:26:43.286]  $ ...future.FUN:function (x)  
[08:26:43.286]  $ ...          : list()
[08:26:43.286]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:43.286]  - attr(*, "where")=List of 2
[08:26:43.286]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:43.286]   ..$ ...          :<environment: 0x55e10e78b638> 
[08:26:43.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:43.286]  - attr(*, "resolved")= logi FALSE
[08:26:43.286]  - attr(*, "total_size")= num 5632
[08:26:43.289] Packages to be attached in all futures: [n=0] 
[08:26:43.289] getGlobalsAndPackagesXApply() ... DONE
[08:26:43.290] Number of futures (= number of chunks): 2
[08:26:43.290] Launching 2 futures (chunks) ...
[08:26:43.290] Chunk #1 of 2 ...
[08:26:43.290]  - Finding globals in 'X' for chunk #1 ...
[08:26:43.290] getGlobalsAndPackages() ...
[08:26:43.290] Searching for globals...
[08:26:43.291] 
[08:26:43.291] Searching for globals ... DONE
[08:26:43.291] - globals: [0] <none>
[08:26:43.291] getGlobalsAndPackages() ... DONE
[08:26:43.291]    + additional globals found: [n=0] 
[08:26:43.291]    + additional namespaces needed: [n=0] 
[08:26:43.291]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:43.291]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:43.291]  - seeds: <none>
[08:26:43.291]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.292] getGlobalsAndPackages() ...
[08:26:43.292] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.292] Resolving globals: FALSE
[08:26:43.292] Tweak future expression to call with '...' arguments ...
[08:26:43.292] {
[08:26:43.292]     do.call(function(...) {
[08:26:43.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:43.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.292]             on.exit(options(oopts), add = TRUE)
[08:26:43.292]         }
[08:26:43.292]         {
[08:26:43.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:43.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.292]                 ...future.FUN(...future.X_jj, ...)
[08:26:43.292]             })
[08:26:43.292]         }
[08:26:43.292]     }, args = future.call.arguments)
[08:26:43.292] }
[08:26:43.292] Tweak future expression to call with '...' arguments ... DONE
[08:26:43.293] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.293] 
[08:26:43.293] getGlobalsAndPackages() ... DONE
[08:26:43.293] run() for ‘Future’ ...
[08:26:43.293] - state: ‘created’
[08:26:43.294] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:43.295] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:43.296] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:43.296]   - Field: ‘label’
[08:26:43.296]   - Field: ‘local’
[08:26:43.296]   - Field: ‘owner’
[08:26:43.296]   - Field: ‘envir’
[08:26:43.296]   - Field: ‘workers’
[08:26:43.296]   - Field: ‘packages’
[08:26:43.296]   - Field: ‘gc’
[08:26:43.296]   - Field: ‘job’
[08:26:43.297]   - Field: ‘conditions’
[08:26:43.297]   - Field: ‘expr’
[08:26:43.297]   - Field: ‘uuid’
[08:26:43.297]   - Field: ‘seed’
[08:26:43.297]   - Field: ‘version’
[08:26:43.297]   - Field: ‘result’
[08:26:43.297]   - Field: ‘asynchronous’
[08:26:43.297]   - Field: ‘calls’
[08:26:43.297]   - Field: ‘globals’
[08:26:43.297]   - Field: ‘stdout’
[08:26:43.297]   - Field: ‘earlySignal’
[08:26:43.298]   - Field: ‘lazy’
[08:26:43.298]   - Field: ‘state’
[08:26:43.298] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:43.298] - Launch lazy future ...
[08:26:43.298] Packages needed by the future expression (n = 0): <none>
[08:26:43.298] Packages needed by future strategies (n = 0): <none>
[08:26:43.299] {
[08:26:43.299]     {
[08:26:43.299]         {
[08:26:43.299]             ...future.startTime <- base::Sys.time()
[08:26:43.299]             {
[08:26:43.299]                 {
[08:26:43.299]                   {
[08:26:43.299]                     {
[08:26:43.299]                       base::local({
[08:26:43.299]                         has_future <- base::requireNamespace("future", 
[08:26:43.299]                           quietly = TRUE)
[08:26:43.299]                         if (has_future) {
[08:26:43.299]                           ns <- base::getNamespace("future")
[08:26:43.299]                           version <- ns[[".package"]][["version"]]
[08:26:43.299]                           if (is.null(version)) 
[08:26:43.299]                             version <- utils::packageVersion("future")
[08:26:43.299]                         }
[08:26:43.299]                         else {
[08:26:43.299]                           version <- NULL
[08:26:43.299]                         }
[08:26:43.299]                         if (!has_future || version < "1.8.0") {
[08:26:43.299]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:43.299]                             "", base::R.version$version.string), 
[08:26:43.299]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:43.299]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:43.299]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:43.299]                               "release", "version")], collapse = " "), 
[08:26:43.299]                             hostname = base::Sys.info()[["nodename"]])
[08:26:43.299]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:43.299]                             info)
[08:26:43.299]                           info <- base::paste(info, collapse = "; ")
[08:26:43.299]                           if (!has_future) {
[08:26:43.299]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:43.299]                               info)
[08:26:43.299]                           }
[08:26:43.299]                           else {
[08:26:43.299]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:43.299]                               info, version)
[08:26:43.299]                           }
[08:26:43.299]                           base::stop(msg)
[08:26:43.299]                         }
[08:26:43.299]                       })
[08:26:43.299]                     }
[08:26:43.299]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:43.299]                     base::options(mc.cores = 1L)
[08:26:43.299]                   }
[08:26:43.299]                   ...future.strategy.old <- future::plan("list")
[08:26:43.299]                   options(future.plan = NULL)
[08:26:43.299]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:43.299]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:43.299]                 }
[08:26:43.299]                 ...future.workdir <- getwd()
[08:26:43.299]             }
[08:26:43.299]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:43.299]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:43.299]         }
[08:26:43.299]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:43.299]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:43.299]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:43.299]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:43.299]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:43.299]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:43.299]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:43.299]             base::names(...future.oldOptions))
[08:26:43.299]     }
[08:26:43.299]     if (FALSE) {
[08:26:43.299]     }
[08:26:43.299]     else {
[08:26:43.299]         if (TRUE) {
[08:26:43.299]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:43.299]                 open = "w")
[08:26:43.299]         }
[08:26:43.299]         else {
[08:26:43.299]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:43.299]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:43.299]         }
[08:26:43.299]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:43.299]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:43.299]             base::sink(type = "output", split = FALSE)
[08:26:43.299]             base::close(...future.stdout)
[08:26:43.299]         }, add = TRUE)
[08:26:43.299]     }
[08:26:43.299]     ...future.frame <- base::sys.nframe()
[08:26:43.299]     ...future.conditions <- base::list()
[08:26:43.299]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:43.299]     if (FALSE) {
[08:26:43.299]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:43.299]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:43.299]     }
[08:26:43.299]     ...future.result <- base::tryCatch({
[08:26:43.299]         base::withCallingHandlers({
[08:26:43.299]             ...future.value <- base::withVisible(base::local({
[08:26:43.299]                 withCallingHandlers({
[08:26:43.299]                   {
[08:26:43.299]                     do.call(function(...) {
[08:26:43.299]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.299]                       if (!identical(...future.globals.maxSize.org, 
[08:26:43.299]                         ...future.globals.maxSize)) {
[08:26:43.299]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.299]                         on.exit(options(oopts), add = TRUE)
[08:26:43.299]                       }
[08:26:43.299]                       {
[08:26:43.299]                         lapply(seq_along(...future.elements_ii), 
[08:26:43.299]                           FUN = function(jj) {
[08:26:43.299]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.299]                             ...future.FUN(...future.X_jj, ...)
[08:26:43.299]                           })
[08:26:43.299]                       }
[08:26:43.299]                     }, args = future.call.arguments)
[08:26:43.299]                   }
[08:26:43.299]                 }, immediateCondition = function(cond) {
[08:26:43.299]                   save_rds <- function (object, pathname, ...) 
[08:26:43.299]                   {
[08:26:43.299]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:43.299]                     if (file_test("-f", pathname_tmp)) {
[08:26:43.299]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.299]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:43.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.299]                         fi_tmp[["mtime"]])
[08:26:43.299]                     }
[08:26:43.299]                     tryCatch({
[08:26:43.299]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:43.299]                     }, error = function(ex) {
[08:26:43.299]                       msg <- conditionMessage(ex)
[08:26:43.299]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.299]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:43.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.299]                         fi_tmp[["mtime"]], msg)
[08:26:43.299]                       ex$message <- msg
[08:26:43.299]                       stop(ex)
[08:26:43.299]                     })
[08:26:43.299]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:43.299]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:43.299]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:43.299]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.299]                       fi <- file.info(pathname)
[08:26:43.299]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:43.299]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.299]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:43.299]                         fi[["size"]], fi[["mtime"]])
[08:26:43.299]                       stop(msg)
[08:26:43.299]                     }
[08:26:43.299]                     invisible(pathname)
[08:26:43.299]                   }
[08:26:43.299]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:43.299]                     rootPath = tempdir()) 
[08:26:43.299]                   {
[08:26:43.299]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:43.299]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:43.299]                       tmpdir = path, fileext = ".rds")
[08:26:43.299]                     save_rds(obj, file)
[08:26:43.299]                   }
[08:26:43.299]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:43.299]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.299]                   {
[08:26:43.299]                     inherits <- base::inherits
[08:26:43.299]                     invokeRestart <- base::invokeRestart
[08:26:43.299]                     is.null <- base::is.null
[08:26:43.299]                     muffled <- FALSE
[08:26:43.299]                     if (inherits(cond, "message")) {
[08:26:43.299]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:43.299]                       if (muffled) 
[08:26:43.299]                         invokeRestart("muffleMessage")
[08:26:43.299]                     }
[08:26:43.299]                     else if (inherits(cond, "warning")) {
[08:26:43.299]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:43.299]                       if (muffled) 
[08:26:43.299]                         invokeRestart("muffleWarning")
[08:26:43.299]                     }
[08:26:43.299]                     else if (inherits(cond, "condition")) {
[08:26:43.299]                       if (!is.null(pattern)) {
[08:26:43.299]                         computeRestarts <- base::computeRestarts
[08:26:43.299]                         grepl <- base::grepl
[08:26:43.299]                         restarts <- computeRestarts(cond)
[08:26:43.299]                         for (restart in restarts) {
[08:26:43.299]                           name <- restart$name
[08:26:43.299]                           if (is.null(name)) 
[08:26:43.299]                             next
[08:26:43.299]                           if (!grepl(pattern, name)) 
[08:26:43.299]                             next
[08:26:43.299]                           invokeRestart(restart)
[08:26:43.299]                           muffled <- TRUE
[08:26:43.299]                           break
[08:26:43.299]                         }
[08:26:43.299]                       }
[08:26:43.299]                     }
[08:26:43.299]                     invisible(muffled)
[08:26:43.299]                   }
[08:26:43.299]                   muffleCondition(cond)
[08:26:43.299]                 })
[08:26:43.299]             }))
[08:26:43.299]             future::FutureResult(value = ...future.value$value, 
[08:26:43.299]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:43.299]                   ...future.rng), globalenv = if (FALSE) 
[08:26:43.299]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:43.299]                     ...future.globalenv.names))
[08:26:43.299]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:43.299]         }, condition = base::local({
[08:26:43.299]             c <- base::c
[08:26:43.299]             inherits <- base::inherits
[08:26:43.299]             invokeRestart <- base::invokeRestart
[08:26:43.299]             length <- base::length
[08:26:43.299]             list <- base::list
[08:26:43.299]             seq.int <- base::seq.int
[08:26:43.299]             signalCondition <- base::signalCondition
[08:26:43.299]             sys.calls <- base::sys.calls
[08:26:43.299]             `[[` <- base::`[[`
[08:26:43.299]             `+` <- base::`+`
[08:26:43.299]             `<<-` <- base::`<<-`
[08:26:43.299]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:43.299]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:43.299]                   3L)]
[08:26:43.299]             }
[08:26:43.299]             function(cond) {
[08:26:43.299]                 is_error <- inherits(cond, "error")
[08:26:43.299]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:43.299]                   NULL)
[08:26:43.299]                 if (is_error) {
[08:26:43.299]                   sessionInformation <- function() {
[08:26:43.299]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:43.299]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:43.299]                       search = base::search(), system = base::Sys.info())
[08:26:43.299]                   }
[08:26:43.299]                   ...future.conditions[[length(...future.conditions) + 
[08:26:43.299]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:43.299]                     cond$call), session = sessionInformation(), 
[08:26:43.299]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:43.299]                   signalCondition(cond)
[08:26:43.299]                 }
[08:26:43.299]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:43.299]                 "immediateCondition"))) {
[08:26:43.299]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:43.299]                   ...future.conditions[[length(...future.conditions) + 
[08:26:43.299]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:43.299]                   if (TRUE && !signal) {
[08:26:43.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.299]                     {
[08:26:43.299]                       inherits <- base::inherits
[08:26:43.299]                       invokeRestart <- base::invokeRestart
[08:26:43.299]                       is.null <- base::is.null
[08:26:43.299]                       muffled <- FALSE
[08:26:43.299]                       if (inherits(cond, "message")) {
[08:26:43.299]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:43.299]                         if (muffled) 
[08:26:43.299]                           invokeRestart("muffleMessage")
[08:26:43.299]                       }
[08:26:43.299]                       else if (inherits(cond, "warning")) {
[08:26:43.299]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:43.299]                         if (muffled) 
[08:26:43.299]                           invokeRestart("muffleWarning")
[08:26:43.299]                       }
[08:26:43.299]                       else if (inherits(cond, "condition")) {
[08:26:43.299]                         if (!is.null(pattern)) {
[08:26:43.299]                           computeRestarts <- base::computeRestarts
[08:26:43.299]                           grepl <- base::grepl
[08:26:43.299]                           restarts <- computeRestarts(cond)
[08:26:43.299]                           for (restart in restarts) {
[08:26:43.299]                             name <- restart$name
[08:26:43.299]                             if (is.null(name)) 
[08:26:43.299]                               next
[08:26:43.299]                             if (!grepl(pattern, name)) 
[08:26:43.299]                               next
[08:26:43.299]                             invokeRestart(restart)
[08:26:43.299]                             muffled <- TRUE
[08:26:43.299]                             break
[08:26:43.299]                           }
[08:26:43.299]                         }
[08:26:43.299]                       }
[08:26:43.299]                       invisible(muffled)
[08:26:43.299]                     }
[08:26:43.299]                     muffleCondition(cond, pattern = "^muffle")
[08:26:43.299]                   }
[08:26:43.299]                 }
[08:26:43.299]                 else {
[08:26:43.299]                   if (TRUE) {
[08:26:43.299]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.299]                     {
[08:26:43.299]                       inherits <- base::inherits
[08:26:43.299]                       invokeRestart <- base::invokeRestart
[08:26:43.299]                       is.null <- base::is.null
[08:26:43.299]                       muffled <- FALSE
[08:26:43.299]                       if (inherits(cond, "message")) {
[08:26:43.299]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:43.299]                         if (muffled) 
[08:26:43.299]                           invokeRestart("muffleMessage")
[08:26:43.299]                       }
[08:26:43.299]                       else if (inherits(cond, "warning")) {
[08:26:43.299]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:43.299]                         if (muffled) 
[08:26:43.299]                           invokeRestart("muffleWarning")
[08:26:43.299]                       }
[08:26:43.299]                       else if (inherits(cond, "condition")) {
[08:26:43.299]                         if (!is.null(pattern)) {
[08:26:43.299]                           computeRestarts <- base::computeRestarts
[08:26:43.299]                           grepl <- base::grepl
[08:26:43.299]                           restarts <- computeRestarts(cond)
[08:26:43.299]                           for (restart in restarts) {
[08:26:43.299]                             name <- restart$name
[08:26:43.299]                             if (is.null(name)) 
[08:26:43.299]                               next
[08:26:43.299]                             if (!grepl(pattern, name)) 
[08:26:43.299]                               next
[08:26:43.299]                             invokeRestart(restart)
[08:26:43.299]                             muffled <- TRUE
[08:26:43.299]                             break
[08:26:43.299]                           }
[08:26:43.299]                         }
[08:26:43.299]                       }
[08:26:43.299]                       invisible(muffled)
[08:26:43.299]                     }
[08:26:43.299]                     muffleCondition(cond, pattern = "^muffle")
[08:26:43.299]                   }
[08:26:43.299]                 }
[08:26:43.299]             }
[08:26:43.299]         }))
[08:26:43.299]     }, error = function(ex) {
[08:26:43.299]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:43.299]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:43.299]                 ...future.rng), started = ...future.startTime, 
[08:26:43.299]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:43.299]             version = "1.8"), class = "FutureResult")
[08:26:43.299]     }, finally = {
[08:26:43.299]         if (!identical(...future.workdir, getwd())) 
[08:26:43.299]             setwd(...future.workdir)
[08:26:43.299]         {
[08:26:43.299]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:43.299]                 ...future.oldOptions$nwarnings <- NULL
[08:26:43.299]             }
[08:26:43.299]             base::options(...future.oldOptions)
[08:26:43.299]             if (.Platform$OS.type == "windows") {
[08:26:43.299]                 old_names <- names(...future.oldEnvVars)
[08:26:43.299]                 envs <- base::Sys.getenv()
[08:26:43.299]                 names <- names(envs)
[08:26:43.299]                 common <- intersect(names, old_names)
[08:26:43.299]                 added <- setdiff(names, old_names)
[08:26:43.299]                 removed <- setdiff(old_names, names)
[08:26:43.299]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:43.299]                   envs[common]]
[08:26:43.299]                 NAMES <- toupper(changed)
[08:26:43.299]                 args <- list()
[08:26:43.299]                 for (kk in seq_along(NAMES)) {
[08:26:43.299]                   name <- changed[[kk]]
[08:26:43.299]                   NAME <- NAMES[[kk]]
[08:26:43.299]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.299]                     next
[08:26:43.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:43.299]                 }
[08:26:43.299]                 NAMES <- toupper(added)
[08:26:43.299]                 for (kk in seq_along(NAMES)) {
[08:26:43.299]                   name <- added[[kk]]
[08:26:43.299]                   NAME <- NAMES[[kk]]
[08:26:43.299]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.299]                     next
[08:26:43.299]                   args[[name]] <- ""
[08:26:43.299]                 }
[08:26:43.299]                 NAMES <- toupper(removed)
[08:26:43.299]                 for (kk in seq_along(NAMES)) {
[08:26:43.299]                   name <- removed[[kk]]
[08:26:43.299]                   NAME <- NAMES[[kk]]
[08:26:43.299]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.299]                     next
[08:26:43.299]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:43.299]                 }
[08:26:43.299]                 if (length(args) > 0) 
[08:26:43.299]                   base::do.call(base::Sys.setenv, args = args)
[08:26:43.299]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:43.299]             }
[08:26:43.299]             else {
[08:26:43.299]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:43.299]             }
[08:26:43.299]             {
[08:26:43.299]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:43.299]                   0L) {
[08:26:43.299]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:43.299]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:43.299]                   base::options(opts)
[08:26:43.299]                 }
[08:26:43.299]                 {
[08:26:43.299]                   {
[08:26:43.299]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:43.299]                     NULL
[08:26:43.299]                   }
[08:26:43.299]                   options(future.plan = NULL)
[08:26:43.299]                   if (is.na(NA_character_)) 
[08:26:43.299]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:43.299]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:43.299]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:43.299]                     .init = FALSE)
[08:26:43.299]                 }
[08:26:43.299]             }
[08:26:43.299]         }
[08:26:43.299]     })
[08:26:43.299]     if (TRUE) {
[08:26:43.299]         base::sink(type = "output", split = FALSE)
[08:26:43.299]         if (TRUE) {
[08:26:43.299]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:43.299]         }
[08:26:43.299]         else {
[08:26:43.299]             ...future.result["stdout"] <- base::list(NULL)
[08:26:43.299]         }
[08:26:43.299]         base::close(...future.stdout)
[08:26:43.299]         ...future.stdout <- NULL
[08:26:43.299]     }
[08:26:43.299]     ...future.result$conditions <- ...future.conditions
[08:26:43.299]     ...future.result$finished <- base::Sys.time()
[08:26:43.299]     ...future.result
[08:26:43.299] }
[08:26:43.302] assign_globals() ...
[08:26:43.302] List of 5
[08:26:43.302]  $ ...future.FUN            :function (x)  
[08:26:43.302]  $ future.call.arguments    : list()
[08:26:43.302]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:43.302]  $ ...future.elements_ii    :List of 1
[08:26:43.302]   ..$ : int 1
[08:26:43.302]  $ ...future.seeds_ii       : NULL
[08:26:43.302]  $ ...future.globals.maxSize: NULL
[08:26:43.302]  - attr(*, "where")=List of 5
[08:26:43.302]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:43.302]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:43.302]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:43.302]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:43.302]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:43.302]  - attr(*, "resolved")= logi FALSE
[08:26:43.302]  - attr(*, "total_size")= num 5632
[08:26:43.302]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:43.302]  - attr(*, "already-done")= logi TRUE
[08:26:43.307] - reassign environment for ‘...future.FUN’
[08:26:43.307] - copied ‘...future.FUN’ to environment
[08:26:43.307] - copied ‘future.call.arguments’ to environment
[08:26:43.307] - copied ‘...future.elements_ii’ to environment
[08:26:43.307] - copied ‘...future.seeds_ii’ to environment
[08:26:43.307] - copied ‘...future.globals.maxSize’ to environment
[08:26:43.307] assign_globals() ... done
[08:26:43.308] requestCore(): workers = 2
[08:26:43.310] MulticoreFuture started
[08:26:43.311] - Launch lazy future ... done
[08:26:43.311] run() for ‘MulticoreFuture’ ... done
[08:26:43.311] Created future:
[08:26:43.311] plan(): Setting new future strategy stack:
[08:26:43.312] List of future strategies:
[08:26:43.312] 1. sequential:
[08:26:43.312]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:43.312]    - tweaked: FALSE
[08:26:43.312]    - call: NULL
[08:26:43.313] plan(): nbrOfWorkers() = 1
[08:26:43.311] MulticoreFuture:
[08:26:43.311] Label: ‘future_lapply-1’
[08:26:43.311] Expression:
[08:26:43.311] {
[08:26:43.311]     do.call(function(...) {
[08:26:43.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:43.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.311]             on.exit(options(oopts), add = TRUE)
[08:26:43.311]         }
[08:26:43.311]         {
[08:26:43.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:43.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.311]                 ...future.FUN(...future.X_jj, ...)
[08:26:43.311]             })
[08:26:43.311]         }
[08:26:43.311]     }, args = future.call.arguments)
[08:26:43.311] }
[08:26:43.311] Lazy evaluation: FALSE
[08:26:43.311] Asynchronous evaluation: TRUE
[08:26:43.311] Local evaluation: TRUE
[08:26:43.311] Environment: R_GlobalEnv
[08:26:43.311] Capture standard output: TRUE
[08:26:43.311] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:43.311] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:43.311] Packages: <none>
[08:26:43.311] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:43.311] Resolved: FALSE
[08:26:43.311] Value: <not collected>
[08:26:43.311] Conditions captured: <none>
[08:26:43.311] Early signaling: FALSE
[08:26:43.311] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:43.311] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:43.325] Chunk #1 of 2 ... DONE
[08:26:43.325] Chunk #2 of 2 ...
[08:26:43.325]  - Finding globals in 'X' for chunk #2 ...
[08:26:43.325] getGlobalsAndPackages() ...
[08:26:43.330] Searching for globals...
[08:26:43.331] 
[08:26:43.332] Searching for globals ... DONE
[08:26:43.332] - globals: [0] <none>
[08:26:43.333] getGlobalsAndPackages() ... DONE
[08:26:43.333]    + additional globals found: [n=0] 
[08:26:43.333]    + additional namespaces needed: [n=0] 
[08:26:43.334]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:43.334]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:43.335]  - seeds: <none>
[08:26:43.335]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.335] getGlobalsAndPackages() ...
[08:26:43.336] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.336] Resolving globals: FALSE
[08:26:43.336] Tweak future expression to call with '...' arguments ...
[08:26:43.337] {
[08:26:43.337]     do.call(function(...) {
[08:26:43.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:43.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.337]             on.exit(options(oopts), add = TRUE)
[08:26:43.337]         }
[08:26:43.337]         {
[08:26:43.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:43.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.337]                 ...future.FUN(...future.X_jj, ...)
[08:26:43.337]             })
[08:26:43.337]         }
[08:26:43.337]     }, args = future.call.arguments)
[08:26:43.337] }
[08:26:43.338] Tweak future expression to call with '...' arguments ... DONE
[08:26:43.339] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.339] 
[08:26:43.339] getGlobalsAndPackages() ... DONE
[08:26:43.340] run() for ‘Future’ ...
[08:26:43.340] - state: ‘created’
[08:26:43.340] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:43.343] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:43.344] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:43.344]   - Field: ‘label’
[08:26:43.344]   - Field: ‘local’
[08:26:43.344]   - Field: ‘owner’
[08:26:43.344]   - Field: ‘envir’
[08:26:43.344]   - Field: ‘workers’
[08:26:43.345]   - Field: ‘packages’
[08:26:43.345]   - Field: ‘gc’
[08:26:43.345]   - Field: ‘job’
[08:26:43.345]   - Field: ‘conditions’
[08:26:43.345]   - Field: ‘expr’
[08:26:43.345]   - Field: ‘uuid’
[08:26:43.345]   - Field: ‘seed’
[08:26:43.346]   - Field: ‘version’
[08:26:43.346]   - Field: ‘result’
[08:26:43.346]   - Field: ‘asynchronous’
[08:26:43.346]   - Field: ‘calls’
[08:26:43.346]   - Field: ‘globals’
[08:26:43.346]   - Field: ‘stdout’
[08:26:43.346]   - Field: ‘earlySignal’
[08:26:43.347]   - Field: ‘lazy’
[08:26:43.347]   - Field: ‘state’
[08:26:43.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:43.347] - Launch lazy future ...
[08:26:43.347] Packages needed by the future expression (n = 0): <none>
[08:26:43.348] Packages needed by future strategies (n = 0): <none>
[08:26:43.348] {
[08:26:43.348]     {
[08:26:43.348]         {
[08:26:43.348]             ...future.startTime <- base::Sys.time()
[08:26:43.348]             {
[08:26:43.348]                 {
[08:26:43.348]                   {
[08:26:43.348]                     {
[08:26:43.348]                       base::local({
[08:26:43.348]                         has_future <- base::requireNamespace("future", 
[08:26:43.348]                           quietly = TRUE)
[08:26:43.348]                         if (has_future) {
[08:26:43.348]                           ns <- base::getNamespace("future")
[08:26:43.348]                           version <- ns[[".package"]][["version"]]
[08:26:43.348]                           if (is.null(version)) 
[08:26:43.348]                             version <- utils::packageVersion("future")
[08:26:43.348]                         }
[08:26:43.348]                         else {
[08:26:43.348]                           version <- NULL
[08:26:43.348]                         }
[08:26:43.348]                         if (!has_future || version < "1.8.0") {
[08:26:43.348]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:43.348]                             "", base::R.version$version.string), 
[08:26:43.348]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:43.348]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:43.348]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:43.348]                               "release", "version")], collapse = " "), 
[08:26:43.348]                             hostname = base::Sys.info()[["nodename"]])
[08:26:43.348]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:43.348]                             info)
[08:26:43.348]                           info <- base::paste(info, collapse = "; ")
[08:26:43.348]                           if (!has_future) {
[08:26:43.348]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:43.348]                               info)
[08:26:43.348]                           }
[08:26:43.348]                           else {
[08:26:43.348]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:43.348]                               info, version)
[08:26:43.348]                           }
[08:26:43.348]                           base::stop(msg)
[08:26:43.348]                         }
[08:26:43.348]                       })
[08:26:43.348]                     }
[08:26:43.348]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:43.348]                     base::options(mc.cores = 1L)
[08:26:43.348]                   }
[08:26:43.348]                   ...future.strategy.old <- future::plan("list")
[08:26:43.348]                   options(future.plan = NULL)
[08:26:43.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:43.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:43.348]                 }
[08:26:43.348]                 ...future.workdir <- getwd()
[08:26:43.348]             }
[08:26:43.348]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:43.348]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:43.348]         }
[08:26:43.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:43.348]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:43.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:43.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:43.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:43.348]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:43.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:43.348]             base::names(...future.oldOptions))
[08:26:43.348]     }
[08:26:43.348]     if (FALSE) {
[08:26:43.348]     }
[08:26:43.348]     else {
[08:26:43.348]         if (TRUE) {
[08:26:43.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:43.348]                 open = "w")
[08:26:43.348]         }
[08:26:43.348]         else {
[08:26:43.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:43.348]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:43.348]         }
[08:26:43.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:43.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:43.348]             base::sink(type = "output", split = FALSE)
[08:26:43.348]             base::close(...future.stdout)
[08:26:43.348]         }, add = TRUE)
[08:26:43.348]     }
[08:26:43.348]     ...future.frame <- base::sys.nframe()
[08:26:43.348]     ...future.conditions <- base::list()
[08:26:43.348]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:43.348]     if (FALSE) {
[08:26:43.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:43.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:43.348]     }
[08:26:43.348]     ...future.result <- base::tryCatch({
[08:26:43.348]         base::withCallingHandlers({
[08:26:43.348]             ...future.value <- base::withVisible(base::local({
[08:26:43.348]                 withCallingHandlers({
[08:26:43.348]                   {
[08:26:43.348]                     do.call(function(...) {
[08:26:43.348]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.348]                       if (!identical(...future.globals.maxSize.org, 
[08:26:43.348]                         ...future.globals.maxSize)) {
[08:26:43.348]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.348]                         on.exit(options(oopts), add = TRUE)
[08:26:43.348]                       }
[08:26:43.348]                       {
[08:26:43.348]                         lapply(seq_along(...future.elements_ii), 
[08:26:43.348]                           FUN = function(jj) {
[08:26:43.348]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.348]                             ...future.FUN(...future.X_jj, ...)
[08:26:43.348]                           })
[08:26:43.348]                       }
[08:26:43.348]                     }, args = future.call.arguments)
[08:26:43.348]                   }
[08:26:43.348]                 }, immediateCondition = function(cond) {
[08:26:43.348]                   save_rds <- function (object, pathname, ...) 
[08:26:43.348]                   {
[08:26:43.348]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:43.348]                     if (file_test("-f", pathname_tmp)) {
[08:26:43.348]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.348]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:43.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.348]                         fi_tmp[["mtime"]])
[08:26:43.348]                     }
[08:26:43.348]                     tryCatch({
[08:26:43.348]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:43.348]                     }, error = function(ex) {
[08:26:43.348]                       msg <- conditionMessage(ex)
[08:26:43.348]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.348]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:43.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.348]                         fi_tmp[["mtime"]], msg)
[08:26:43.348]                       ex$message <- msg
[08:26:43.348]                       stop(ex)
[08:26:43.348]                     })
[08:26:43.348]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:43.348]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:43.348]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:43.348]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.348]                       fi <- file.info(pathname)
[08:26:43.348]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:43.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.348]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:43.348]                         fi[["size"]], fi[["mtime"]])
[08:26:43.348]                       stop(msg)
[08:26:43.348]                     }
[08:26:43.348]                     invisible(pathname)
[08:26:43.348]                   }
[08:26:43.348]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:43.348]                     rootPath = tempdir()) 
[08:26:43.348]                   {
[08:26:43.348]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:43.348]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:43.348]                       tmpdir = path, fileext = ".rds")
[08:26:43.348]                     save_rds(obj, file)
[08:26:43.348]                   }
[08:26:43.348]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:43.348]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.348]                   {
[08:26:43.348]                     inherits <- base::inherits
[08:26:43.348]                     invokeRestart <- base::invokeRestart
[08:26:43.348]                     is.null <- base::is.null
[08:26:43.348]                     muffled <- FALSE
[08:26:43.348]                     if (inherits(cond, "message")) {
[08:26:43.348]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:43.348]                       if (muffled) 
[08:26:43.348]                         invokeRestart("muffleMessage")
[08:26:43.348]                     }
[08:26:43.348]                     else if (inherits(cond, "warning")) {
[08:26:43.348]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:43.348]                       if (muffled) 
[08:26:43.348]                         invokeRestart("muffleWarning")
[08:26:43.348]                     }
[08:26:43.348]                     else if (inherits(cond, "condition")) {
[08:26:43.348]                       if (!is.null(pattern)) {
[08:26:43.348]                         computeRestarts <- base::computeRestarts
[08:26:43.348]                         grepl <- base::grepl
[08:26:43.348]                         restarts <- computeRestarts(cond)
[08:26:43.348]                         for (restart in restarts) {
[08:26:43.348]                           name <- restart$name
[08:26:43.348]                           if (is.null(name)) 
[08:26:43.348]                             next
[08:26:43.348]                           if (!grepl(pattern, name)) 
[08:26:43.348]                             next
[08:26:43.348]                           invokeRestart(restart)
[08:26:43.348]                           muffled <- TRUE
[08:26:43.348]                           break
[08:26:43.348]                         }
[08:26:43.348]                       }
[08:26:43.348]                     }
[08:26:43.348]                     invisible(muffled)
[08:26:43.348]                   }
[08:26:43.348]                   muffleCondition(cond)
[08:26:43.348]                 })
[08:26:43.348]             }))
[08:26:43.348]             future::FutureResult(value = ...future.value$value, 
[08:26:43.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:43.348]                   ...future.rng), globalenv = if (FALSE) 
[08:26:43.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:43.348]                     ...future.globalenv.names))
[08:26:43.348]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:43.348]         }, condition = base::local({
[08:26:43.348]             c <- base::c
[08:26:43.348]             inherits <- base::inherits
[08:26:43.348]             invokeRestart <- base::invokeRestart
[08:26:43.348]             length <- base::length
[08:26:43.348]             list <- base::list
[08:26:43.348]             seq.int <- base::seq.int
[08:26:43.348]             signalCondition <- base::signalCondition
[08:26:43.348]             sys.calls <- base::sys.calls
[08:26:43.348]             `[[` <- base::`[[`
[08:26:43.348]             `+` <- base::`+`
[08:26:43.348]             `<<-` <- base::`<<-`
[08:26:43.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:43.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:43.348]                   3L)]
[08:26:43.348]             }
[08:26:43.348]             function(cond) {
[08:26:43.348]                 is_error <- inherits(cond, "error")
[08:26:43.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:43.348]                   NULL)
[08:26:43.348]                 if (is_error) {
[08:26:43.348]                   sessionInformation <- function() {
[08:26:43.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:43.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:43.348]                       search = base::search(), system = base::Sys.info())
[08:26:43.348]                   }
[08:26:43.348]                   ...future.conditions[[length(...future.conditions) + 
[08:26:43.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:43.348]                     cond$call), session = sessionInformation(), 
[08:26:43.348]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:43.348]                   signalCondition(cond)
[08:26:43.348]                 }
[08:26:43.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:43.348]                 "immediateCondition"))) {
[08:26:43.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:43.348]                   ...future.conditions[[length(...future.conditions) + 
[08:26:43.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:43.348]                   if (TRUE && !signal) {
[08:26:43.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.348]                     {
[08:26:43.348]                       inherits <- base::inherits
[08:26:43.348]                       invokeRestart <- base::invokeRestart
[08:26:43.348]                       is.null <- base::is.null
[08:26:43.348]                       muffled <- FALSE
[08:26:43.348]                       if (inherits(cond, "message")) {
[08:26:43.348]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:43.348]                         if (muffled) 
[08:26:43.348]                           invokeRestart("muffleMessage")
[08:26:43.348]                       }
[08:26:43.348]                       else if (inherits(cond, "warning")) {
[08:26:43.348]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:43.348]                         if (muffled) 
[08:26:43.348]                           invokeRestart("muffleWarning")
[08:26:43.348]                       }
[08:26:43.348]                       else if (inherits(cond, "condition")) {
[08:26:43.348]                         if (!is.null(pattern)) {
[08:26:43.348]                           computeRestarts <- base::computeRestarts
[08:26:43.348]                           grepl <- base::grepl
[08:26:43.348]                           restarts <- computeRestarts(cond)
[08:26:43.348]                           for (restart in restarts) {
[08:26:43.348]                             name <- restart$name
[08:26:43.348]                             if (is.null(name)) 
[08:26:43.348]                               next
[08:26:43.348]                             if (!grepl(pattern, name)) 
[08:26:43.348]                               next
[08:26:43.348]                             invokeRestart(restart)
[08:26:43.348]                             muffled <- TRUE
[08:26:43.348]                             break
[08:26:43.348]                           }
[08:26:43.348]                         }
[08:26:43.348]                       }
[08:26:43.348]                       invisible(muffled)
[08:26:43.348]                     }
[08:26:43.348]                     muffleCondition(cond, pattern = "^muffle")
[08:26:43.348]                   }
[08:26:43.348]                 }
[08:26:43.348]                 else {
[08:26:43.348]                   if (TRUE) {
[08:26:43.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.348]                     {
[08:26:43.348]                       inherits <- base::inherits
[08:26:43.348]                       invokeRestart <- base::invokeRestart
[08:26:43.348]                       is.null <- base::is.null
[08:26:43.348]                       muffled <- FALSE
[08:26:43.348]                       if (inherits(cond, "message")) {
[08:26:43.348]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:43.348]                         if (muffled) 
[08:26:43.348]                           invokeRestart("muffleMessage")
[08:26:43.348]                       }
[08:26:43.348]                       else if (inherits(cond, "warning")) {
[08:26:43.348]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:43.348]                         if (muffled) 
[08:26:43.348]                           invokeRestart("muffleWarning")
[08:26:43.348]                       }
[08:26:43.348]                       else if (inherits(cond, "condition")) {
[08:26:43.348]                         if (!is.null(pattern)) {
[08:26:43.348]                           computeRestarts <- base::computeRestarts
[08:26:43.348]                           grepl <- base::grepl
[08:26:43.348]                           restarts <- computeRestarts(cond)
[08:26:43.348]                           for (restart in restarts) {
[08:26:43.348]                             name <- restart$name
[08:26:43.348]                             if (is.null(name)) 
[08:26:43.348]                               next
[08:26:43.348]                             if (!grepl(pattern, name)) 
[08:26:43.348]                               next
[08:26:43.348]                             invokeRestart(restart)
[08:26:43.348]                             muffled <- TRUE
[08:26:43.348]                             break
[08:26:43.348]                           }
[08:26:43.348]                         }
[08:26:43.348]                       }
[08:26:43.348]                       invisible(muffled)
[08:26:43.348]                     }
[08:26:43.348]                     muffleCondition(cond, pattern = "^muffle")
[08:26:43.348]                   }
[08:26:43.348]                 }
[08:26:43.348]             }
[08:26:43.348]         }))
[08:26:43.348]     }, error = function(ex) {
[08:26:43.348]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:43.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:43.348]                 ...future.rng), started = ...future.startTime, 
[08:26:43.348]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:43.348]             version = "1.8"), class = "FutureResult")
[08:26:43.348]     }, finally = {
[08:26:43.348]         if (!identical(...future.workdir, getwd())) 
[08:26:43.348]             setwd(...future.workdir)
[08:26:43.348]         {
[08:26:43.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:43.348]                 ...future.oldOptions$nwarnings <- NULL
[08:26:43.348]             }
[08:26:43.348]             base::options(...future.oldOptions)
[08:26:43.348]             if (.Platform$OS.type == "windows") {
[08:26:43.348]                 old_names <- names(...future.oldEnvVars)
[08:26:43.348]                 envs <- base::Sys.getenv()
[08:26:43.348]                 names <- names(envs)
[08:26:43.348]                 common <- intersect(names, old_names)
[08:26:43.348]                 added <- setdiff(names, old_names)
[08:26:43.348]                 removed <- setdiff(old_names, names)
[08:26:43.348]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:43.348]                   envs[common]]
[08:26:43.348]                 NAMES <- toupper(changed)
[08:26:43.348]                 args <- list()
[08:26:43.348]                 for (kk in seq_along(NAMES)) {
[08:26:43.348]                   name <- changed[[kk]]
[08:26:43.348]                   NAME <- NAMES[[kk]]
[08:26:43.348]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.348]                     next
[08:26:43.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:43.348]                 }
[08:26:43.348]                 NAMES <- toupper(added)
[08:26:43.348]                 for (kk in seq_along(NAMES)) {
[08:26:43.348]                   name <- added[[kk]]
[08:26:43.348]                   NAME <- NAMES[[kk]]
[08:26:43.348]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.348]                     next
[08:26:43.348]                   args[[name]] <- ""
[08:26:43.348]                 }
[08:26:43.348]                 NAMES <- toupper(removed)
[08:26:43.348]                 for (kk in seq_along(NAMES)) {
[08:26:43.348]                   name <- removed[[kk]]
[08:26:43.348]                   NAME <- NAMES[[kk]]
[08:26:43.348]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.348]                     next
[08:26:43.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:43.348]                 }
[08:26:43.348]                 if (length(args) > 0) 
[08:26:43.348]                   base::do.call(base::Sys.setenv, args = args)
[08:26:43.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:43.348]             }
[08:26:43.348]             else {
[08:26:43.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:43.348]             }
[08:26:43.348]             {
[08:26:43.348]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:43.348]                   0L) {
[08:26:43.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:43.348]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:43.348]                   base::options(opts)
[08:26:43.348]                 }
[08:26:43.348]                 {
[08:26:43.348]                   {
[08:26:43.348]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:43.348]                     NULL
[08:26:43.348]                   }
[08:26:43.348]                   options(future.plan = NULL)
[08:26:43.348]                   if (is.na(NA_character_)) 
[08:26:43.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:43.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:43.348]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:43.348]                     .init = FALSE)
[08:26:43.348]                 }
[08:26:43.348]             }
[08:26:43.348]         }
[08:26:43.348]     })
[08:26:43.348]     if (TRUE) {
[08:26:43.348]         base::sink(type = "output", split = FALSE)
[08:26:43.348]         if (TRUE) {
[08:26:43.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:43.348]         }
[08:26:43.348]         else {
[08:26:43.348]             ...future.result["stdout"] <- base::list(NULL)
[08:26:43.348]         }
[08:26:43.348]         base::close(...future.stdout)
[08:26:43.348]         ...future.stdout <- NULL
[08:26:43.348]     }
[08:26:43.348]     ...future.result$conditions <- ...future.conditions
[08:26:43.348]     ...future.result$finished <- base::Sys.time()
[08:26:43.348]     ...future.result
[08:26:43.348] }
[08:26:43.351] assign_globals() ...
[08:26:43.351] List of 5
[08:26:43.351]  $ ...future.FUN            :function (x)  
[08:26:43.351]  $ future.call.arguments    : list()
[08:26:43.351]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:43.351]  $ ...future.elements_ii    :List of 1
[08:26:43.351]   ..$ : int 0
[08:26:43.351]  $ ...future.seeds_ii       : NULL
[08:26:43.351]  $ ...future.globals.maxSize: NULL
[08:26:43.351]  - attr(*, "where")=List of 5
[08:26:43.351]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:43.351]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:43.351]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:43.351]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:43.351]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:43.351]  - attr(*, "resolved")= logi FALSE
[08:26:43.351]  - attr(*, "total_size")= num 5632
[08:26:43.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:43.351]  - attr(*, "already-done")= logi TRUE
[08:26:43.358] - reassign environment for ‘...future.FUN’
[08:26:43.358] - copied ‘...future.FUN’ to environment
[08:26:43.359] - copied ‘future.call.arguments’ to environment
[08:26:43.359] - copied ‘...future.elements_ii’ to environment
[08:26:43.359] - copied ‘...future.seeds_ii’ to environment
[08:26:43.359] - copied ‘...future.globals.maxSize’ to environment
[08:26:43.359] assign_globals() ... done
[08:26:43.359] requestCore(): workers = 2
[08:26:43.362] MulticoreFuture started
[08:26:43.362] - Launch lazy future ... done
[08:26:43.362] run() for ‘MulticoreFuture’ ... done
[08:26:43.363] Created future:
[08:26:43.363] plan(): Setting new future strategy stack:
[08:26:43.363] List of future strategies:
[08:26:43.363] 1. sequential:
[08:26:43.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:43.363]    - tweaked: FALSE
[08:26:43.363]    - call: NULL
[08:26:43.364] plan(): nbrOfWorkers() = 1
[08:26:43.367] plan(): Setting new future strategy stack:
[08:26:43.367] List of future strategies:
[08:26:43.367] 1. multicore:
[08:26:43.367]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:43.367]    - tweaked: FALSE
[08:26:43.367]    - call: plan(strategy)
[08:26:43.370] plan(): nbrOfWorkers() = 2
[08:26:43.363] MulticoreFuture:
[08:26:43.363] Label: ‘future_lapply-2’
[08:26:43.363] Expression:
[08:26:43.363] {
[08:26:43.363]     do.call(function(...) {
[08:26:43.363]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.363]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:43.363]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.363]             on.exit(options(oopts), add = TRUE)
[08:26:43.363]         }
[08:26:43.363]         {
[08:26:43.363]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:43.363]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.363]                 ...future.FUN(...future.X_jj, ...)
[08:26:43.363]             })
[08:26:43.363]         }
[08:26:43.363]     }, args = future.call.arguments)
[08:26:43.363] }
[08:26:43.363] Lazy evaluation: FALSE
[08:26:43.363] Asynchronous evaluation: TRUE
[08:26:43.363] Local evaluation: TRUE
[08:26:43.363] Environment: R_GlobalEnv
[08:26:43.363] Capture standard output: TRUE
[08:26:43.363] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:43.363] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:43.363] Packages: <none>
[08:26:43.363] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:43.363] Resolved: TRUE
[08:26:43.363] Value: <not collected>
[08:26:43.363] Conditions captured: <none>
[08:26:43.363] Early signaling: FALSE
[08:26:43.363] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:43.363] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:43.372] Chunk #2 of 2 ... DONE
[08:26:43.372] Launching 2 futures (chunks) ... DONE
[08:26:43.372] Resolving 2 futures (chunks) ...
[08:26:43.372] resolve() on list ...
[08:26:43.372]  recursive: 0
[08:26:43.372]  length: 2
[08:26:43.373] 
[08:26:43.383] Future #2
[08:26:43.384] result() for MulticoreFuture ...
[08:26:43.385] result() for MulticoreFuture ...
[08:26:43.385] result() for MulticoreFuture ... done
[08:26:43.385] result() for MulticoreFuture ... done
[08:26:43.385] result() for MulticoreFuture ...
[08:26:43.385] result() for MulticoreFuture ... done
[08:26:43.386] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:43.386] - nx: 2
[08:26:43.386] - relay: TRUE
[08:26:43.386] - stdout: TRUE
[08:26:43.386] - signal: TRUE
[08:26:43.386] - resignal: FALSE
[08:26:43.386] - force: TRUE
[08:26:43.386] - relayed: [n=2] FALSE, FALSE
[08:26:43.387] - queued futures: [n=2] FALSE, FALSE
[08:26:43.387]  - until=1
[08:26:43.387]  - relaying element #1
[08:26:43.387] - relayed: [n=2] FALSE, FALSE
[08:26:43.387] - queued futures: [n=2] FALSE, TRUE
[08:26:43.387] signalConditionsASAP(NULL, pos=2) ... done
[08:26:43.387]  length: 1 (resolved future 2)
[08:26:43.816] plan(): Setting new future strategy stack:
[08:26:43.816] List of future strategies:
[08:26:43.816] 1. multicore:
[08:26:43.816]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:43.816]    - tweaked: FALSE
[08:26:43.816]    - call: plan(strategy)
[08:26:43.823] plan(): nbrOfWorkers() = 2
[08:26:43.832] Future #1
[08:26:43.832] result() for MulticoreFuture ...
[08:26:43.833] result() for MulticoreFuture ...
[08:26:43.833] result() for MulticoreFuture ... done
[08:26:43.833] result() for MulticoreFuture ... done
[08:26:43.833] result() for MulticoreFuture ...
[08:26:43.834] result() for MulticoreFuture ... done
[08:26:43.834] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:43.834] - nx: 2
[08:26:43.834] - relay: TRUE
[08:26:43.834] - stdout: TRUE
[08:26:43.834] - signal: TRUE
[08:26:43.834] - resignal: FALSE
[08:26:43.834] - force: TRUE
[08:26:43.835] - relayed: [n=2] FALSE, FALSE
[08:26:43.835] - queued futures: [n=2] FALSE, TRUE
[08:26:43.835]  - until=1
[08:26:43.835]  - relaying element #1
[08:26:43.838] result() for MulticoreFuture ...
[08:26:43.838] result() for MulticoreFuture ... done
[08:26:43.838] result() for MulticoreFuture ...
[08:26:43.838] result() for MulticoreFuture ... done
[08:26:43.839] result() for MulticoreFuture ...
[08:26:43.839] result() for MulticoreFuture ... done
[08:26:43.839] result() for MulticoreFuture ...
[08:26:43.839] result() for MulticoreFuture ... done
[08:26:43.839] - relayed: [n=2] TRUE, FALSE
[08:26:43.839] - queued futures: [n=2] TRUE, TRUE
[08:26:43.840] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:43.840]  length: 0 (resolved future 1)
[08:26:43.840] Relaying remaining futures
[08:26:43.840] signalConditionsASAP(NULL, pos=0) ...
[08:26:43.840] - nx: 2
[08:26:43.841] - relay: TRUE
[08:26:43.841] - stdout: TRUE
[08:26:43.841] - signal: TRUE
[08:26:43.841] - resignal: FALSE
[08:26:43.841] - force: TRUE
[08:26:43.841] - relayed: [n=2] TRUE, FALSE
[08:26:43.841] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:43.842]  - relaying element #2
[08:26:43.842] result() for MulticoreFuture ...
[08:26:43.842] result() for MulticoreFuture ... done
[08:26:43.842] result() for MulticoreFuture ...
[08:26:43.842] result() for MulticoreFuture ... done
[08:26:43.842] result() for MulticoreFuture ...
[08:26:43.842] result() for MulticoreFuture ... done
[08:26:43.842] result() for MulticoreFuture ...
[08:26:43.843] result() for MulticoreFuture ... done
[08:26:43.843] - relayed: [n=2] TRUE, TRUE
[08:26:43.843] - queued futures: [n=2] TRUE, TRUE
[08:26:43.843] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[08:26:43.843] resolve() on list ... DONE
[08:26:43.843] result() for MulticoreFuture ...
[08:26:43.843] result() for MulticoreFuture ... done
[08:26:43.843] result() for MulticoreFuture ...
[08:26:43.843] result() for MulticoreFuture ... done
[08:26:43.844] result() for MulticoreFuture ...
[08:26:43.844] result() for MulticoreFuture ... done
[08:26:43.844] result() for MulticoreFuture ...
[08:26:43.844] result() for MulticoreFuture ... done
[08:26:43.844]  - Number of value chunks collected: 2
[08:26:43.844] Resolving 2 futures (chunks) ... DONE
[08:26:43.844] Reducing values from 2 chunks ...
[08:26:43.844]  - Number of values collected after concatenation: 2
[08:26:43.845]  - Number of values expected: 2
[08:26:43.845] Reducing values from 2 chunks ... DONE
[08:26:43.845] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[08:26:43.845] future_lapply() ...
[08:26:43.848] Number of chunks: 2
[08:26:43.848] getGlobalsAndPackagesXApply() ...
[08:26:43.849]  - future.globals: TRUE
[08:26:43.849] getGlobalsAndPackages() ...
[08:26:43.849] Searching for globals...
[08:26:43.850] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:43.851] Searching for globals ... DONE
[08:26:43.851] Resolving globals: FALSE
[08:26:43.851] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:43.852] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:43.852] - globals: [1] ‘FUN’
[08:26:43.852] 
[08:26:43.852] getGlobalsAndPackages() ... DONE
[08:26:43.852]  - globals found/used: [n=1] ‘FUN’
[08:26:43.852]  - needed namespaces: [n=0] 
[08:26:43.852] Finding globals ... DONE
[08:26:43.852]  - use_args: TRUE
[08:26:43.853]  - Getting '...' globals ...
[08:26:43.853] resolve() on list ...
[08:26:43.853]  recursive: 0
[08:26:43.853]  length: 1
[08:26:43.853]  elements: ‘...’
[08:26:43.853]  length: 0 (resolved future 1)
[08:26:43.854] resolve() on list ... DONE
[08:26:43.854]    - '...' content: [n=0] 
[08:26:43.854] List of 1
[08:26:43.854]  $ ...: list()
[08:26:43.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:43.854]  - attr(*, "where")=List of 1
[08:26:43.854]   ..$ ...:<environment: 0x55e10ceb3410> 
[08:26:43.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:43.854]  - attr(*, "resolved")= logi TRUE
[08:26:43.854]  - attr(*, "total_size")= num NA
[08:26:43.857]  - Getting '...' globals ... DONE
[08:26:43.857] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:43.857] List of 2
[08:26:43.857]  $ ...future.FUN:function (x)  
[08:26:43.857]  $ ...          : list()
[08:26:43.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:43.857]  - attr(*, "where")=List of 2
[08:26:43.857]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:43.857]   ..$ ...          :<environment: 0x55e10ceb3410> 
[08:26:43.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:43.857]  - attr(*, "resolved")= logi FALSE
[08:26:43.857]  - attr(*, "total_size")= num 5632
[08:26:43.860] Packages to be attached in all futures: [n=0] 
[08:26:43.860] getGlobalsAndPackagesXApply() ... DONE
[08:26:43.860] Number of futures (= number of chunks): 2
[08:26:43.860] Launching 2 futures (chunks) ...
[08:26:43.860] Chunk #1 of 2 ...
[08:26:43.860]  - Finding globals in 'X' for chunk #1 ...
[08:26:43.861] getGlobalsAndPackages() ...
[08:26:43.861] Searching for globals...
[08:26:43.861] 
[08:26:43.861] Searching for globals ... DONE
[08:26:43.861] - globals: [0] <none>
[08:26:43.861] getGlobalsAndPackages() ... DONE
[08:26:43.861]    + additional globals found: [n=0] 
[08:26:43.861]    + additional namespaces needed: [n=0] 
[08:26:43.862]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:43.862]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:43.862]  - seeds: <none>
[08:26:43.862]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.862] getGlobalsAndPackages() ...
[08:26:43.862] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.862] Resolving globals: FALSE
[08:26:43.862] Tweak future expression to call with '...' arguments ...
[08:26:43.862] {
[08:26:43.862]     do.call(function(...) {
[08:26:43.862]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.862]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:43.862]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.862]             on.exit(options(oopts), add = TRUE)
[08:26:43.862]         }
[08:26:43.862]         {
[08:26:43.862]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:43.862]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.862]                 ...future.FUN(...future.X_jj, ...)
[08:26:43.862]             })
[08:26:43.862]         }
[08:26:43.862]     }, args = future.call.arguments)
[08:26:43.862] }
[08:26:43.863] Tweak future expression to call with '...' arguments ... DONE
[08:26:43.863] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.863] 
[08:26:43.863] getGlobalsAndPackages() ... DONE
[08:26:43.864] run() for ‘Future’ ...
[08:26:43.864] - state: ‘created’
[08:26:43.864] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:43.868] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:43.868] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:43.868]   - Field: ‘label’
[08:26:43.868]   - Field: ‘local’
[08:26:43.869]   - Field: ‘owner’
[08:26:43.869]   - Field: ‘envir’
[08:26:43.869]   - Field: ‘workers’
[08:26:43.869]   - Field: ‘packages’
[08:26:43.869]   - Field: ‘gc’
[08:26:43.869]   - Field: ‘job’
[08:26:43.869]   - Field: ‘conditions’
[08:26:43.869]   - Field: ‘expr’
[08:26:43.869]   - Field: ‘uuid’
[08:26:43.870]   - Field: ‘seed’
[08:26:43.870]   - Field: ‘version’
[08:26:43.870]   - Field: ‘result’
[08:26:43.870]   - Field: ‘asynchronous’
[08:26:43.870]   - Field: ‘calls’
[08:26:43.870]   - Field: ‘globals’
[08:26:43.870]   - Field: ‘stdout’
[08:26:43.870]   - Field: ‘earlySignal’
[08:26:43.870]   - Field: ‘lazy’
[08:26:43.870]   - Field: ‘state’
[08:26:43.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:43.871] - Launch lazy future ...
[08:26:43.871] Packages needed by the future expression (n = 0): <none>
[08:26:43.871] Packages needed by future strategies (n = 0): <none>
[08:26:43.872] {
[08:26:43.872]     {
[08:26:43.872]         {
[08:26:43.872]             ...future.startTime <- base::Sys.time()
[08:26:43.872]             {
[08:26:43.872]                 {
[08:26:43.872]                   {
[08:26:43.872]                     {
[08:26:43.872]                       base::local({
[08:26:43.872]                         has_future <- base::requireNamespace("future", 
[08:26:43.872]                           quietly = TRUE)
[08:26:43.872]                         if (has_future) {
[08:26:43.872]                           ns <- base::getNamespace("future")
[08:26:43.872]                           version <- ns[[".package"]][["version"]]
[08:26:43.872]                           if (is.null(version)) 
[08:26:43.872]                             version <- utils::packageVersion("future")
[08:26:43.872]                         }
[08:26:43.872]                         else {
[08:26:43.872]                           version <- NULL
[08:26:43.872]                         }
[08:26:43.872]                         if (!has_future || version < "1.8.0") {
[08:26:43.872]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:43.872]                             "", base::R.version$version.string), 
[08:26:43.872]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:43.872]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:43.872]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:43.872]                               "release", "version")], collapse = " "), 
[08:26:43.872]                             hostname = base::Sys.info()[["nodename"]])
[08:26:43.872]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:43.872]                             info)
[08:26:43.872]                           info <- base::paste(info, collapse = "; ")
[08:26:43.872]                           if (!has_future) {
[08:26:43.872]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:43.872]                               info)
[08:26:43.872]                           }
[08:26:43.872]                           else {
[08:26:43.872]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:43.872]                               info, version)
[08:26:43.872]                           }
[08:26:43.872]                           base::stop(msg)
[08:26:43.872]                         }
[08:26:43.872]                       })
[08:26:43.872]                     }
[08:26:43.872]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:43.872]                     base::options(mc.cores = 1L)
[08:26:43.872]                   }
[08:26:43.872]                   ...future.strategy.old <- future::plan("list")
[08:26:43.872]                   options(future.plan = NULL)
[08:26:43.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:43.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:43.872]                 }
[08:26:43.872]                 ...future.workdir <- getwd()
[08:26:43.872]             }
[08:26:43.872]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:43.872]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:43.872]         }
[08:26:43.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:43.872]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:43.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:43.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:43.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:43.872]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:43.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:43.872]             base::names(...future.oldOptions))
[08:26:43.872]     }
[08:26:43.872]     if (TRUE) {
[08:26:43.872]     }
[08:26:43.872]     else {
[08:26:43.872]         if (NA) {
[08:26:43.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:43.872]                 open = "w")
[08:26:43.872]         }
[08:26:43.872]         else {
[08:26:43.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:43.872]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:43.872]         }
[08:26:43.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:43.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:43.872]             base::sink(type = "output", split = FALSE)
[08:26:43.872]             base::close(...future.stdout)
[08:26:43.872]         }, add = TRUE)
[08:26:43.872]     }
[08:26:43.872]     ...future.frame <- base::sys.nframe()
[08:26:43.872]     ...future.conditions <- base::list()
[08:26:43.872]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:43.872]     if (FALSE) {
[08:26:43.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:43.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:43.872]     }
[08:26:43.872]     ...future.result <- base::tryCatch({
[08:26:43.872]         base::withCallingHandlers({
[08:26:43.872]             ...future.value <- base::withVisible(base::local({
[08:26:43.872]                 withCallingHandlers({
[08:26:43.872]                   {
[08:26:43.872]                     do.call(function(...) {
[08:26:43.872]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.872]                       if (!identical(...future.globals.maxSize.org, 
[08:26:43.872]                         ...future.globals.maxSize)) {
[08:26:43.872]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.872]                         on.exit(options(oopts), add = TRUE)
[08:26:43.872]                       }
[08:26:43.872]                       {
[08:26:43.872]                         lapply(seq_along(...future.elements_ii), 
[08:26:43.872]                           FUN = function(jj) {
[08:26:43.872]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.872]                             ...future.FUN(...future.X_jj, ...)
[08:26:43.872]                           })
[08:26:43.872]                       }
[08:26:43.872]                     }, args = future.call.arguments)
[08:26:43.872]                   }
[08:26:43.872]                 }, immediateCondition = function(cond) {
[08:26:43.872]                   save_rds <- function (object, pathname, ...) 
[08:26:43.872]                   {
[08:26:43.872]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:43.872]                     if (file_test("-f", pathname_tmp)) {
[08:26:43.872]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.872]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:43.872]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.872]                         fi_tmp[["mtime"]])
[08:26:43.872]                     }
[08:26:43.872]                     tryCatch({
[08:26:43.872]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:43.872]                     }, error = function(ex) {
[08:26:43.872]                       msg <- conditionMessage(ex)
[08:26:43.872]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.872]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:43.872]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.872]                         fi_tmp[["mtime"]], msg)
[08:26:43.872]                       ex$message <- msg
[08:26:43.872]                       stop(ex)
[08:26:43.872]                     })
[08:26:43.872]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:43.872]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:43.872]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:43.872]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.872]                       fi <- file.info(pathname)
[08:26:43.872]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:43.872]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.872]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:43.872]                         fi[["size"]], fi[["mtime"]])
[08:26:43.872]                       stop(msg)
[08:26:43.872]                     }
[08:26:43.872]                     invisible(pathname)
[08:26:43.872]                   }
[08:26:43.872]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:43.872]                     rootPath = tempdir()) 
[08:26:43.872]                   {
[08:26:43.872]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:43.872]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:43.872]                       tmpdir = path, fileext = ".rds")
[08:26:43.872]                     save_rds(obj, file)
[08:26:43.872]                   }
[08:26:43.872]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:43.872]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.872]                   {
[08:26:43.872]                     inherits <- base::inherits
[08:26:43.872]                     invokeRestart <- base::invokeRestart
[08:26:43.872]                     is.null <- base::is.null
[08:26:43.872]                     muffled <- FALSE
[08:26:43.872]                     if (inherits(cond, "message")) {
[08:26:43.872]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:43.872]                       if (muffled) 
[08:26:43.872]                         invokeRestart("muffleMessage")
[08:26:43.872]                     }
[08:26:43.872]                     else if (inherits(cond, "warning")) {
[08:26:43.872]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:43.872]                       if (muffled) 
[08:26:43.872]                         invokeRestart("muffleWarning")
[08:26:43.872]                     }
[08:26:43.872]                     else if (inherits(cond, "condition")) {
[08:26:43.872]                       if (!is.null(pattern)) {
[08:26:43.872]                         computeRestarts <- base::computeRestarts
[08:26:43.872]                         grepl <- base::grepl
[08:26:43.872]                         restarts <- computeRestarts(cond)
[08:26:43.872]                         for (restart in restarts) {
[08:26:43.872]                           name <- restart$name
[08:26:43.872]                           if (is.null(name)) 
[08:26:43.872]                             next
[08:26:43.872]                           if (!grepl(pattern, name)) 
[08:26:43.872]                             next
[08:26:43.872]                           invokeRestart(restart)
[08:26:43.872]                           muffled <- TRUE
[08:26:43.872]                           break
[08:26:43.872]                         }
[08:26:43.872]                       }
[08:26:43.872]                     }
[08:26:43.872]                     invisible(muffled)
[08:26:43.872]                   }
[08:26:43.872]                   muffleCondition(cond)
[08:26:43.872]                 })
[08:26:43.872]             }))
[08:26:43.872]             future::FutureResult(value = ...future.value$value, 
[08:26:43.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:43.872]                   ...future.rng), globalenv = if (FALSE) 
[08:26:43.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:43.872]                     ...future.globalenv.names))
[08:26:43.872]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:43.872]         }, condition = base::local({
[08:26:43.872]             c <- base::c
[08:26:43.872]             inherits <- base::inherits
[08:26:43.872]             invokeRestart <- base::invokeRestart
[08:26:43.872]             length <- base::length
[08:26:43.872]             list <- base::list
[08:26:43.872]             seq.int <- base::seq.int
[08:26:43.872]             signalCondition <- base::signalCondition
[08:26:43.872]             sys.calls <- base::sys.calls
[08:26:43.872]             `[[` <- base::`[[`
[08:26:43.872]             `+` <- base::`+`
[08:26:43.872]             `<<-` <- base::`<<-`
[08:26:43.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:43.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:43.872]                   3L)]
[08:26:43.872]             }
[08:26:43.872]             function(cond) {
[08:26:43.872]                 is_error <- inherits(cond, "error")
[08:26:43.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:43.872]                   NULL)
[08:26:43.872]                 if (is_error) {
[08:26:43.872]                   sessionInformation <- function() {
[08:26:43.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:43.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:43.872]                       search = base::search(), system = base::Sys.info())
[08:26:43.872]                   }
[08:26:43.872]                   ...future.conditions[[length(...future.conditions) + 
[08:26:43.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:43.872]                     cond$call), session = sessionInformation(), 
[08:26:43.872]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:43.872]                   signalCondition(cond)
[08:26:43.872]                 }
[08:26:43.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:43.872]                 "immediateCondition"))) {
[08:26:43.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:43.872]                   ...future.conditions[[length(...future.conditions) + 
[08:26:43.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:43.872]                   if (TRUE && !signal) {
[08:26:43.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.872]                     {
[08:26:43.872]                       inherits <- base::inherits
[08:26:43.872]                       invokeRestart <- base::invokeRestart
[08:26:43.872]                       is.null <- base::is.null
[08:26:43.872]                       muffled <- FALSE
[08:26:43.872]                       if (inherits(cond, "message")) {
[08:26:43.872]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:43.872]                         if (muffled) 
[08:26:43.872]                           invokeRestart("muffleMessage")
[08:26:43.872]                       }
[08:26:43.872]                       else if (inherits(cond, "warning")) {
[08:26:43.872]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:43.872]                         if (muffled) 
[08:26:43.872]                           invokeRestart("muffleWarning")
[08:26:43.872]                       }
[08:26:43.872]                       else if (inherits(cond, "condition")) {
[08:26:43.872]                         if (!is.null(pattern)) {
[08:26:43.872]                           computeRestarts <- base::computeRestarts
[08:26:43.872]                           grepl <- base::grepl
[08:26:43.872]                           restarts <- computeRestarts(cond)
[08:26:43.872]                           for (restart in restarts) {
[08:26:43.872]                             name <- restart$name
[08:26:43.872]                             if (is.null(name)) 
[08:26:43.872]                               next
[08:26:43.872]                             if (!grepl(pattern, name)) 
[08:26:43.872]                               next
[08:26:43.872]                             invokeRestart(restart)
[08:26:43.872]                             muffled <- TRUE
[08:26:43.872]                             break
[08:26:43.872]                           }
[08:26:43.872]                         }
[08:26:43.872]                       }
[08:26:43.872]                       invisible(muffled)
[08:26:43.872]                     }
[08:26:43.872]                     muffleCondition(cond, pattern = "^muffle")
[08:26:43.872]                   }
[08:26:43.872]                 }
[08:26:43.872]                 else {
[08:26:43.872]                   if (TRUE) {
[08:26:43.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.872]                     {
[08:26:43.872]                       inherits <- base::inherits
[08:26:43.872]                       invokeRestart <- base::invokeRestart
[08:26:43.872]                       is.null <- base::is.null
[08:26:43.872]                       muffled <- FALSE
[08:26:43.872]                       if (inherits(cond, "message")) {
[08:26:43.872]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:43.872]                         if (muffled) 
[08:26:43.872]                           invokeRestart("muffleMessage")
[08:26:43.872]                       }
[08:26:43.872]                       else if (inherits(cond, "warning")) {
[08:26:43.872]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:43.872]                         if (muffled) 
[08:26:43.872]                           invokeRestart("muffleWarning")
[08:26:43.872]                       }
[08:26:43.872]                       else if (inherits(cond, "condition")) {
[08:26:43.872]                         if (!is.null(pattern)) {
[08:26:43.872]                           computeRestarts <- base::computeRestarts
[08:26:43.872]                           grepl <- base::grepl
[08:26:43.872]                           restarts <- computeRestarts(cond)
[08:26:43.872]                           for (restart in restarts) {
[08:26:43.872]                             name <- restart$name
[08:26:43.872]                             if (is.null(name)) 
[08:26:43.872]                               next
[08:26:43.872]                             if (!grepl(pattern, name)) 
[08:26:43.872]                               next
[08:26:43.872]                             invokeRestart(restart)
[08:26:43.872]                             muffled <- TRUE
[08:26:43.872]                             break
[08:26:43.872]                           }
[08:26:43.872]                         }
[08:26:43.872]                       }
[08:26:43.872]                       invisible(muffled)
[08:26:43.872]                     }
[08:26:43.872]                     muffleCondition(cond, pattern = "^muffle")
[08:26:43.872]                   }
[08:26:43.872]                 }
[08:26:43.872]             }
[08:26:43.872]         }))
[08:26:43.872]     }, error = function(ex) {
[08:26:43.872]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:43.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:43.872]                 ...future.rng), started = ...future.startTime, 
[08:26:43.872]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:43.872]             version = "1.8"), class = "FutureResult")
[08:26:43.872]     }, finally = {
[08:26:43.872]         if (!identical(...future.workdir, getwd())) 
[08:26:43.872]             setwd(...future.workdir)
[08:26:43.872]         {
[08:26:43.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:43.872]                 ...future.oldOptions$nwarnings <- NULL
[08:26:43.872]             }
[08:26:43.872]             base::options(...future.oldOptions)
[08:26:43.872]             if (.Platform$OS.type == "windows") {
[08:26:43.872]                 old_names <- names(...future.oldEnvVars)
[08:26:43.872]                 envs <- base::Sys.getenv()
[08:26:43.872]                 names <- names(envs)
[08:26:43.872]                 common <- intersect(names, old_names)
[08:26:43.872]                 added <- setdiff(names, old_names)
[08:26:43.872]                 removed <- setdiff(old_names, names)
[08:26:43.872]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:43.872]                   envs[common]]
[08:26:43.872]                 NAMES <- toupper(changed)
[08:26:43.872]                 args <- list()
[08:26:43.872]                 for (kk in seq_along(NAMES)) {
[08:26:43.872]                   name <- changed[[kk]]
[08:26:43.872]                   NAME <- NAMES[[kk]]
[08:26:43.872]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.872]                     next
[08:26:43.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:43.872]                 }
[08:26:43.872]                 NAMES <- toupper(added)
[08:26:43.872]                 for (kk in seq_along(NAMES)) {
[08:26:43.872]                   name <- added[[kk]]
[08:26:43.872]                   NAME <- NAMES[[kk]]
[08:26:43.872]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.872]                     next
[08:26:43.872]                   args[[name]] <- ""
[08:26:43.872]                 }
[08:26:43.872]                 NAMES <- toupper(removed)
[08:26:43.872]                 for (kk in seq_along(NAMES)) {
[08:26:43.872]                   name <- removed[[kk]]
[08:26:43.872]                   NAME <- NAMES[[kk]]
[08:26:43.872]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.872]                     next
[08:26:43.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:43.872]                 }
[08:26:43.872]                 if (length(args) > 0) 
[08:26:43.872]                   base::do.call(base::Sys.setenv, args = args)
[08:26:43.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:43.872]             }
[08:26:43.872]             else {
[08:26:43.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:43.872]             }
[08:26:43.872]             {
[08:26:43.872]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:43.872]                   0L) {
[08:26:43.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:43.872]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:43.872]                   base::options(opts)
[08:26:43.872]                 }
[08:26:43.872]                 {
[08:26:43.872]                   {
[08:26:43.872]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:43.872]                     NULL
[08:26:43.872]                   }
[08:26:43.872]                   options(future.plan = NULL)
[08:26:43.872]                   if (is.na(NA_character_)) 
[08:26:43.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:43.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:43.872]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:43.872]                     .init = FALSE)
[08:26:43.872]                 }
[08:26:43.872]             }
[08:26:43.872]         }
[08:26:43.872]     })
[08:26:43.872]     if (FALSE) {
[08:26:43.872]         base::sink(type = "output", split = FALSE)
[08:26:43.872]         if (NA) {
[08:26:43.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:43.872]         }
[08:26:43.872]         else {
[08:26:43.872]             ...future.result["stdout"] <- base::list(NULL)
[08:26:43.872]         }
[08:26:43.872]         base::close(...future.stdout)
[08:26:43.872]         ...future.stdout <- NULL
[08:26:43.872]     }
[08:26:43.872]     ...future.result$conditions <- ...future.conditions
[08:26:43.872]     ...future.result$finished <- base::Sys.time()
[08:26:43.872]     ...future.result
[08:26:43.872] }
[08:26:43.874] assign_globals() ...
[08:26:43.874] List of 5
[08:26:43.874]  $ ...future.FUN            :function (x)  
[08:26:43.874]  $ future.call.arguments    : list()
[08:26:43.874]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:43.874]  $ ...future.elements_ii    :List of 1
[08:26:43.874]   ..$ : int 1
[08:26:43.874]  $ ...future.seeds_ii       : NULL
[08:26:43.874]  $ ...future.globals.maxSize: NULL
[08:26:43.874]  - attr(*, "where")=List of 5
[08:26:43.874]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:43.874]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:43.874]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:43.874]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:43.874]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:43.874]  - attr(*, "resolved")= logi FALSE
[08:26:43.874]  - attr(*, "total_size")= num 5632
[08:26:43.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:43.874]  - attr(*, "already-done")= logi TRUE
[08:26:43.879] - reassign environment for ‘...future.FUN’
[08:26:43.879] - copied ‘...future.FUN’ to environment
[08:26:43.879] - copied ‘future.call.arguments’ to environment
[08:26:43.879] - copied ‘...future.elements_ii’ to environment
[08:26:43.879] - copied ‘...future.seeds_ii’ to environment
[08:26:43.879] - copied ‘...future.globals.maxSize’ to environment
[08:26:43.880] assign_globals() ... done
[08:26:43.880] requestCore(): workers = 2
[08:26:43.882] MulticoreFuture started
[08:26:43.882] - Launch lazy future ... done
[08:26:43.883] run() for ‘MulticoreFuture’ ... done
[08:26:43.883] Created future:
[08:26:43.883] plan(): Setting new future strategy stack:
[08:26:43.884] List of future strategies:
[08:26:43.884] 1. sequential:
[08:26:43.884]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:43.884]    - tweaked: FALSE
[08:26:43.884]    - call: NULL
[08:26:43.885] plan(): nbrOfWorkers() = 1
[08:26:43.883] MulticoreFuture:
[08:26:43.883] Label: ‘future_lapply-1’
[08:26:43.883] Expression:
[08:26:43.883] {
[08:26:43.883]     do.call(function(...) {
[08:26:43.883]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.883]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:43.883]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.883]             on.exit(options(oopts), add = TRUE)
[08:26:43.883]         }
[08:26:43.883]         {
[08:26:43.883]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:43.883]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.883]                 ...future.FUN(...future.X_jj, ...)
[08:26:43.883]             })
[08:26:43.883]         }
[08:26:43.883]     }, args = future.call.arguments)
[08:26:43.883] }
[08:26:43.883] Lazy evaluation: FALSE
[08:26:43.883] Asynchronous evaluation: TRUE
[08:26:43.883] Local evaluation: TRUE
[08:26:43.883] Environment: R_GlobalEnv
[08:26:43.883] Capture standard output: NA
[08:26:43.883] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:43.883] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:43.883] Packages: <none>
[08:26:43.883] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:43.883] Resolved: FALSE
[08:26:43.883] Value: <not collected>
[08:26:43.883] Conditions captured: <none>
[08:26:43.883] Early signaling: FALSE
[08:26:43.883] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:43.883] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:43.896] Chunk #1 of 2 ... DONE
[08:26:43.896] Chunk #2 of 2 ...
[08:26:43.897]  - Finding globals in 'X' for chunk #2 ...
[08:26:43.897] getGlobalsAndPackages() ...
[08:26:43.897] Searching for globals...
[08:26:43.898] 
[08:26:43.898] Searching for globals ... DONE
[08:26:43.898] - globals: [0] <none>
[08:26:43.898] getGlobalsAndPackages() ... DONE
[08:26:43.898]    + additional globals found: [n=0] 
[08:26:43.899]    + additional namespaces needed: [n=0] 
[08:26:43.899]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:43.899]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:43.899]  - seeds: <none>
[08:26:43.899]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.899] getGlobalsAndPackages() ...
[08:26:43.900] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.900] Resolving globals: FALSE
[08:26:43.900] Tweak future expression to call with '...' arguments ...
[08:26:43.900] {
[08:26:43.900]     do.call(function(...) {
[08:26:43.900]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.900]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:43.900]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.900]             on.exit(options(oopts), add = TRUE)
[08:26:43.900]         }
[08:26:43.900]         {
[08:26:43.900]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:43.900]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.900]                 ...future.FUN(...future.X_jj, ...)
[08:26:43.900]             })
[08:26:43.900]         }
[08:26:43.900]     }, args = future.call.arguments)
[08:26:43.900] }
[08:26:43.901] Tweak future expression to call with '...' arguments ... DONE
[08:26:43.902] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:43.902] 
[08:26:43.902] getGlobalsAndPackages() ... DONE
[08:26:43.903] run() for ‘Future’ ...
[08:26:43.903] - state: ‘created’
[08:26:43.903] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:43.907] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:43.907] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:43.907]   - Field: ‘label’
[08:26:43.907]   - Field: ‘local’
[08:26:43.907]   - Field: ‘owner’
[08:26:43.907]   - Field: ‘envir’
[08:26:43.908]   - Field: ‘workers’
[08:26:43.908]   - Field: ‘packages’
[08:26:43.908]   - Field: ‘gc’
[08:26:43.908]   - Field: ‘job’
[08:26:43.908]   - Field: ‘conditions’
[08:26:43.908]   - Field: ‘expr’
[08:26:43.908]   - Field: ‘uuid’
[08:26:43.908]   - Field: ‘seed’
[08:26:43.909]   - Field: ‘version’
[08:26:43.909]   - Field: ‘result’
[08:26:43.909]   - Field: ‘asynchronous’
[08:26:43.909]   - Field: ‘calls’
[08:26:43.909]   - Field: ‘globals’
[08:26:43.909]   - Field: ‘stdout’
[08:26:43.909]   - Field: ‘earlySignal’
[08:26:43.910]   - Field: ‘lazy’
[08:26:43.910]   - Field: ‘state’
[08:26:43.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:43.910] - Launch lazy future ...
[08:26:43.911] Packages needed by the future expression (n = 0): <none>
[08:26:43.911] Packages needed by future strategies (n = 0): <none>
[08:26:43.912] {
[08:26:43.912]     {
[08:26:43.912]         {
[08:26:43.912]             ...future.startTime <- base::Sys.time()
[08:26:43.912]             {
[08:26:43.912]                 {
[08:26:43.912]                   {
[08:26:43.912]                     {
[08:26:43.912]                       base::local({
[08:26:43.912]                         has_future <- base::requireNamespace("future", 
[08:26:43.912]                           quietly = TRUE)
[08:26:43.912]                         if (has_future) {
[08:26:43.912]                           ns <- base::getNamespace("future")
[08:26:43.912]                           version <- ns[[".package"]][["version"]]
[08:26:43.912]                           if (is.null(version)) 
[08:26:43.912]                             version <- utils::packageVersion("future")
[08:26:43.912]                         }
[08:26:43.912]                         else {
[08:26:43.912]                           version <- NULL
[08:26:43.912]                         }
[08:26:43.912]                         if (!has_future || version < "1.8.0") {
[08:26:43.912]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:43.912]                             "", base::R.version$version.string), 
[08:26:43.912]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:43.912]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:43.912]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:43.912]                               "release", "version")], collapse = " "), 
[08:26:43.912]                             hostname = base::Sys.info()[["nodename"]])
[08:26:43.912]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:43.912]                             info)
[08:26:43.912]                           info <- base::paste(info, collapse = "; ")
[08:26:43.912]                           if (!has_future) {
[08:26:43.912]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:43.912]                               info)
[08:26:43.912]                           }
[08:26:43.912]                           else {
[08:26:43.912]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:43.912]                               info, version)
[08:26:43.912]                           }
[08:26:43.912]                           base::stop(msg)
[08:26:43.912]                         }
[08:26:43.912]                       })
[08:26:43.912]                     }
[08:26:43.912]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:43.912]                     base::options(mc.cores = 1L)
[08:26:43.912]                   }
[08:26:43.912]                   ...future.strategy.old <- future::plan("list")
[08:26:43.912]                   options(future.plan = NULL)
[08:26:43.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:43.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:43.912]                 }
[08:26:43.912]                 ...future.workdir <- getwd()
[08:26:43.912]             }
[08:26:43.912]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:43.912]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:43.912]         }
[08:26:43.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:43.912]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:43.912]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:43.912]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:43.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:43.912]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:43.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:43.912]             base::names(...future.oldOptions))
[08:26:43.912]     }
[08:26:43.912]     if (TRUE) {
[08:26:43.912]     }
[08:26:43.912]     else {
[08:26:43.912]         if (NA) {
[08:26:43.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:43.912]                 open = "w")
[08:26:43.912]         }
[08:26:43.912]         else {
[08:26:43.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:43.912]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:43.912]         }
[08:26:43.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:43.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:43.912]             base::sink(type = "output", split = FALSE)
[08:26:43.912]             base::close(...future.stdout)
[08:26:43.912]         }, add = TRUE)
[08:26:43.912]     }
[08:26:43.912]     ...future.frame <- base::sys.nframe()
[08:26:43.912]     ...future.conditions <- base::list()
[08:26:43.912]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:43.912]     if (FALSE) {
[08:26:43.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:43.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:43.912]     }
[08:26:43.912]     ...future.result <- base::tryCatch({
[08:26:43.912]         base::withCallingHandlers({
[08:26:43.912]             ...future.value <- base::withVisible(base::local({
[08:26:43.912]                 withCallingHandlers({
[08:26:43.912]                   {
[08:26:43.912]                     do.call(function(...) {
[08:26:43.912]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.912]                       if (!identical(...future.globals.maxSize.org, 
[08:26:43.912]                         ...future.globals.maxSize)) {
[08:26:43.912]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.912]                         on.exit(options(oopts), add = TRUE)
[08:26:43.912]                       }
[08:26:43.912]                       {
[08:26:43.912]                         lapply(seq_along(...future.elements_ii), 
[08:26:43.912]                           FUN = function(jj) {
[08:26:43.912]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.912]                             ...future.FUN(...future.X_jj, ...)
[08:26:43.912]                           })
[08:26:43.912]                       }
[08:26:43.912]                     }, args = future.call.arguments)
[08:26:43.912]                   }
[08:26:43.912]                 }, immediateCondition = function(cond) {
[08:26:43.912]                   save_rds <- function (object, pathname, ...) 
[08:26:43.912]                   {
[08:26:43.912]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:43.912]                     if (file_test("-f", pathname_tmp)) {
[08:26:43.912]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.912]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:43.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.912]                         fi_tmp[["mtime"]])
[08:26:43.912]                     }
[08:26:43.912]                     tryCatch({
[08:26:43.912]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:43.912]                     }, error = function(ex) {
[08:26:43.912]                       msg <- conditionMessage(ex)
[08:26:43.912]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.912]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:43.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.912]                         fi_tmp[["mtime"]], msg)
[08:26:43.912]                       ex$message <- msg
[08:26:43.912]                       stop(ex)
[08:26:43.912]                     })
[08:26:43.912]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:43.912]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:43.912]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:43.912]                       fi_tmp <- file.info(pathname_tmp)
[08:26:43.912]                       fi <- file.info(pathname)
[08:26:43.912]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:43.912]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:43.912]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:43.912]                         fi[["size"]], fi[["mtime"]])
[08:26:43.912]                       stop(msg)
[08:26:43.912]                     }
[08:26:43.912]                     invisible(pathname)
[08:26:43.912]                   }
[08:26:43.912]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:43.912]                     rootPath = tempdir()) 
[08:26:43.912]                   {
[08:26:43.912]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:43.912]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:43.912]                       tmpdir = path, fileext = ".rds")
[08:26:43.912]                     save_rds(obj, file)
[08:26:43.912]                   }
[08:26:43.912]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:43.912]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.912]                   {
[08:26:43.912]                     inherits <- base::inherits
[08:26:43.912]                     invokeRestart <- base::invokeRestart
[08:26:43.912]                     is.null <- base::is.null
[08:26:43.912]                     muffled <- FALSE
[08:26:43.912]                     if (inherits(cond, "message")) {
[08:26:43.912]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:43.912]                       if (muffled) 
[08:26:43.912]                         invokeRestart("muffleMessage")
[08:26:43.912]                     }
[08:26:43.912]                     else if (inherits(cond, "warning")) {
[08:26:43.912]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:43.912]                       if (muffled) 
[08:26:43.912]                         invokeRestart("muffleWarning")
[08:26:43.912]                     }
[08:26:43.912]                     else if (inherits(cond, "condition")) {
[08:26:43.912]                       if (!is.null(pattern)) {
[08:26:43.912]                         computeRestarts <- base::computeRestarts
[08:26:43.912]                         grepl <- base::grepl
[08:26:43.912]                         restarts <- computeRestarts(cond)
[08:26:43.912]                         for (restart in restarts) {
[08:26:43.912]                           name <- restart$name
[08:26:43.912]                           if (is.null(name)) 
[08:26:43.912]                             next
[08:26:43.912]                           if (!grepl(pattern, name)) 
[08:26:43.912]                             next
[08:26:43.912]                           invokeRestart(restart)
[08:26:43.912]                           muffled <- TRUE
[08:26:43.912]                           break
[08:26:43.912]                         }
[08:26:43.912]                       }
[08:26:43.912]                     }
[08:26:43.912]                     invisible(muffled)
[08:26:43.912]                   }
[08:26:43.912]                   muffleCondition(cond)
[08:26:43.912]                 })
[08:26:43.912]             }))
[08:26:43.912]             future::FutureResult(value = ...future.value$value, 
[08:26:43.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:43.912]                   ...future.rng), globalenv = if (FALSE) 
[08:26:43.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:43.912]                     ...future.globalenv.names))
[08:26:43.912]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:43.912]         }, condition = base::local({
[08:26:43.912]             c <- base::c
[08:26:43.912]             inherits <- base::inherits
[08:26:43.912]             invokeRestart <- base::invokeRestart
[08:26:43.912]             length <- base::length
[08:26:43.912]             list <- base::list
[08:26:43.912]             seq.int <- base::seq.int
[08:26:43.912]             signalCondition <- base::signalCondition
[08:26:43.912]             sys.calls <- base::sys.calls
[08:26:43.912]             `[[` <- base::`[[`
[08:26:43.912]             `+` <- base::`+`
[08:26:43.912]             `<<-` <- base::`<<-`
[08:26:43.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:43.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:43.912]                   3L)]
[08:26:43.912]             }
[08:26:43.912]             function(cond) {
[08:26:43.912]                 is_error <- inherits(cond, "error")
[08:26:43.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:43.912]                   NULL)
[08:26:43.912]                 if (is_error) {
[08:26:43.912]                   sessionInformation <- function() {
[08:26:43.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:43.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:43.912]                       search = base::search(), system = base::Sys.info())
[08:26:43.912]                   }
[08:26:43.912]                   ...future.conditions[[length(...future.conditions) + 
[08:26:43.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:43.912]                     cond$call), session = sessionInformation(), 
[08:26:43.912]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:43.912]                   signalCondition(cond)
[08:26:43.912]                 }
[08:26:43.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:43.912]                 "immediateCondition"))) {
[08:26:43.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:43.912]                   ...future.conditions[[length(...future.conditions) + 
[08:26:43.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:43.912]                   if (TRUE && !signal) {
[08:26:43.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.912]                     {
[08:26:43.912]                       inherits <- base::inherits
[08:26:43.912]                       invokeRestart <- base::invokeRestart
[08:26:43.912]                       is.null <- base::is.null
[08:26:43.912]                       muffled <- FALSE
[08:26:43.912]                       if (inherits(cond, "message")) {
[08:26:43.912]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:43.912]                         if (muffled) 
[08:26:43.912]                           invokeRestart("muffleMessage")
[08:26:43.912]                       }
[08:26:43.912]                       else if (inherits(cond, "warning")) {
[08:26:43.912]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:43.912]                         if (muffled) 
[08:26:43.912]                           invokeRestart("muffleWarning")
[08:26:43.912]                       }
[08:26:43.912]                       else if (inherits(cond, "condition")) {
[08:26:43.912]                         if (!is.null(pattern)) {
[08:26:43.912]                           computeRestarts <- base::computeRestarts
[08:26:43.912]                           grepl <- base::grepl
[08:26:43.912]                           restarts <- computeRestarts(cond)
[08:26:43.912]                           for (restart in restarts) {
[08:26:43.912]                             name <- restart$name
[08:26:43.912]                             if (is.null(name)) 
[08:26:43.912]                               next
[08:26:43.912]                             if (!grepl(pattern, name)) 
[08:26:43.912]                               next
[08:26:43.912]                             invokeRestart(restart)
[08:26:43.912]                             muffled <- TRUE
[08:26:43.912]                             break
[08:26:43.912]                           }
[08:26:43.912]                         }
[08:26:43.912]                       }
[08:26:43.912]                       invisible(muffled)
[08:26:43.912]                     }
[08:26:43.912]                     muffleCondition(cond, pattern = "^muffle")
[08:26:43.912]                   }
[08:26:43.912]                 }
[08:26:43.912]                 else {
[08:26:43.912]                   if (TRUE) {
[08:26:43.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:43.912]                     {
[08:26:43.912]                       inherits <- base::inherits
[08:26:43.912]                       invokeRestart <- base::invokeRestart
[08:26:43.912]                       is.null <- base::is.null
[08:26:43.912]                       muffled <- FALSE
[08:26:43.912]                       if (inherits(cond, "message")) {
[08:26:43.912]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:43.912]                         if (muffled) 
[08:26:43.912]                           invokeRestart("muffleMessage")
[08:26:43.912]                       }
[08:26:43.912]                       else if (inherits(cond, "warning")) {
[08:26:43.912]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:43.912]                         if (muffled) 
[08:26:43.912]                           invokeRestart("muffleWarning")
[08:26:43.912]                       }
[08:26:43.912]                       else if (inherits(cond, "condition")) {
[08:26:43.912]                         if (!is.null(pattern)) {
[08:26:43.912]                           computeRestarts <- base::computeRestarts
[08:26:43.912]                           grepl <- base::grepl
[08:26:43.912]                           restarts <- computeRestarts(cond)
[08:26:43.912]                           for (restart in restarts) {
[08:26:43.912]                             name <- restart$name
[08:26:43.912]                             if (is.null(name)) 
[08:26:43.912]                               next
[08:26:43.912]                             if (!grepl(pattern, name)) 
[08:26:43.912]                               next
[08:26:43.912]                             invokeRestart(restart)
[08:26:43.912]                             muffled <- TRUE
[08:26:43.912]                             break
[08:26:43.912]                           }
[08:26:43.912]                         }
[08:26:43.912]                       }
[08:26:43.912]                       invisible(muffled)
[08:26:43.912]                     }
[08:26:43.912]                     muffleCondition(cond, pattern = "^muffle")
[08:26:43.912]                   }
[08:26:43.912]                 }
[08:26:43.912]             }
[08:26:43.912]         }))
[08:26:43.912]     }, error = function(ex) {
[08:26:43.912]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:43.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:43.912]                 ...future.rng), started = ...future.startTime, 
[08:26:43.912]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:43.912]             version = "1.8"), class = "FutureResult")
[08:26:43.912]     }, finally = {
[08:26:43.912]         if (!identical(...future.workdir, getwd())) 
[08:26:43.912]             setwd(...future.workdir)
[08:26:43.912]         {
[08:26:43.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:43.912]                 ...future.oldOptions$nwarnings <- NULL
[08:26:43.912]             }
[08:26:43.912]             base::options(...future.oldOptions)
[08:26:43.912]             if (.Platform$OS.type == "windows") {
[08:26:43.912]                 old_names <- names(...future.oldEnvVars)
[08:26:43.912]                 envs <- base::Sys.getenv()
[08:26:43.912]                 names <- names(envs)
[08:26:43.912]                 common <- intersect(names, old_names)
[08:26:43.912]                 added <- setdiff(names, old_names)
[08:26:43.912]                 removed <- setdiff(old_names, names)
[08:26:43.912]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:43.912]                   envs[common]]
[08:26:43.912]                 NAMES <- toupper(changed)
[08:26:43.912]                 args <- list()
[08:26:43.912]                 for (kk in seq_along(NAMES)) {
[08:26:43.912]                   name <- changed[[kk]]
[08:26:43.912]                   NAME <- NAMES[[kk]]
[08:26:43.912]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.912]                     next
[08:26:43.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:43.912]                 }
[08:26:43.912]                 NAMES <- toupper(added)
[08:26:43.912]                 for (kk in seq_along(NAMES)) {
[08:26:43.912]                   name <- added[[kk]]
[08:26:43.912]                   NAME <- NAMES[[kk]]
[08:26:43.912]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.912]                     next
[08:26:43.912]                   args[[name]] <- ""
[08:26:43.912]                 }
[08:26:43.912]                 NAMES <- toupper(removed)
[08:26:43.912]                 for (kk in seq_along(NAMES)) {
[08:26:43.912]                   name <- removed[[kk]]
[08:26:43.912]                   NAME <- NAMES[[kk]]
[08:26:43.912]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:43.912]                     next
[08:26:43.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:43.912]                 }
[08:26:43.912]                 if (length(args) > 0) 
[08:26:43.912]                   base::do.call(base::Sys.setenv, args = args)
[08:26:43.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:43.912]             }
[08:26:43.912]             else {
[08:26:43.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:43.912]             }
[08:26:43.912]             {
[08:26:43.912]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:43.912]                   0L) {
[08:26:43.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:43.912]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:43.912]                   base::options(opts)
[08:26:43.912]                 }
[08:26:43.912]                 {
[08:26:43.912]                   {
[08:26:43.912]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:43.912]                     NULL
[08:26:43.912]                   }
[08:26:43.912]                   options(future.plan = NULL)
[08:26:43.912]                   if (is.na(NA_character_)) 
[08:26:43.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:43.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:43.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:43.912]                     .init = FALSE)
[08:26:43.912]                 }
[08:26:43.912]             }
[08:26:43.912]         }
[08:26:43.912]     })
[08:26:43.912]     if (FALSE) {
[08:26:43.912]         base::sink(type = "output", split = FALSE)
[08:26:43.912]         if (NA) {
[08:26:43.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:43.912]         }
[08:26:43.912]         else {
[08:26:43.912]             ...future.result["stdout"] <- base::list(NULL)
[08:26:43.912]         }
[08:26:43.912]         base::close(...future.stdout)
[08:26:43.912]         ...future.stdout <- NULL
[08:26:43.912]     }
[08:26:43.912]     ...future.result$conditions <- ...future.conditions
[08:26:43.912]     ...future.result$finished <- base::Sys.time()
[08:26:43.912]     ...future.result
[08:26:43.912] }
[08:26:43.915] assign_globals() ...
[08:26:43.916] List of 5
[08:26:43.916]  $ ...future.FUN            :function (x)  
[08:26:43.916]  $ future.call.arguments    : list()
[08:26:43.916]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:43.916]  $ ...future.elements_ii    :List of 1
[08:26:43.916]   ..$ : int 0
[08:26:43.916]  $ ...future.seeds_ii       : NULL
[08:26:43.916]  $ ...future.globals.maxSize: NULL
[08:26:43.916]  - attr(*, "where")=List of 5
[08:26:43.916]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:43.916]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:26:43.916]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:43.916]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:43.916]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:43.916]  - attr(*, "resolved")= logi FALSE
[08:26:43.916]  - attr(*, "total_size")= num 5632
[08:26:43.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:43.916]  - attr(*, "already-done")= logi TRUE
[08:26:43.930] - reassign environment for ‘...future.FUN’
[08:26:43.930] - copied ‘...future.FUN’ to environment
[08:26:43.930] - copied ‘future.call.arguments’ to environment
[08:26:43.930] - copied ‘...future.elements_ii’ to environment
[08:26:43.931] - copied ‘...future.seeds_ii’ to environment
[08:26:43.931] - copied ‘...future.globals.maxSize’ to environment
[08:26:43.931] assign_globals() ... done
[08:26:43.931] requestCore(): workers = 2
[08:26:43.934] MulticoreFuture started
[08:26:43.934] - Launch lazy future ... done
[08:26:43.935] run() for ‘MulticoreFuture’ ... done
[08:26:43.935] Created future:
[08:26:43.935] plan(): Setting new future strategy stack:
[08:26:43.935] List of future strategies:
[08:26:43.935] 1. sequential:
[08:26:43.935]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:43.935]    - tweaked: FALSE
[08:26:43.935]    - call: NULL
[08:26:43.937] plan(): nbrOfWorkers() = 1
[08:26:43.939] plan(): Setting new future strategy stack:
[08:26:43.939] List of future strategies:
[08:26:43.939] 1. multicore:
[08:26:43.939]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:43.939]    - tweaked: FALSE
[08:26:43.939]    - call: plan(strategy)
[08:26:43.943] plan(): nbrOfWorkers() = 2
[08:26:43.935] MulticoreFuture:
[08:26:43.935] Label: ‘future_lapply-2’
[08:26:43.935] Expression:
[08:26:43.935] {
[08:26:43.935]     do.call(function(...) {
[08:26:43.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:43.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:43.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:43.935]             on.exit(options(oopts), add = TRUE)
[08:26:43.935]         }
[08:26:43.935]         {
[08:26:43.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:43.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:43.935]                 ...future.FUN(...future.X_jj, ...)
[08:26:43.935]             })
[08:26:43.935]         }
[08:26:43.935]     }, args = future.call.arguments)
[08:26:43.935] }
[08:26:43.935] Lazy evaluation: FALSE
[08:26:43.935] Asynchronous evaluation: TRUE
[08:26:43.935] Local evaluation: TRUE
[08:26:43.935] Environment: R_GlobalEnv
[08:26:43.935] Capture standard output: NA
[08:26:43.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:43.935] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:43.935] Packages: <none>
[08:26:43.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:43.935] Resolved: TRUE
[08:26:43.935] Value: <not collected>
[08:26:43.935] Conditions captured: <none>
[08:26:43.935] Early signaling: FALSE
[08:26:43.935] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:43.935] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:43.944] Chunk #2 of 2 ... DONE
[08:26:43.944] Launching 2 futures (chunks) ... DONE
[08:26:43.944] Resolving 2 futures (chunks) ...
[08:26:43.945] resolve() on list ...
[08:26:43.945]  recursive: 0
[08:26:43.945]  length: 2
[08:26:43.945] 
[08:26:43.956] Future #2
[08:26:43.956] result() for MulticoreFuture ...
[08:26:43.958] result() for MulticoreFuture ...
[08:26:43.958] result() for MulticoreFuture ... done
[08:26:43.958] result() for MulticoreFuture ... done
[08:26:43.958] result() for MulticoreFuture ...
[08:26:43.958] result() for MulticoreFuture ... done
[08:26:43.959] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:43.959] - nx: 2
[08:26:43.959] - relay: TRUE
[08:26:43.959] - stdout: TRUE
[08:26:43.959] - signal: TRUE
[08:26:43.959] - resignal: FALSE
[08:26:43.959] - force: TRUE
[08:26:43.960] - relayed: [n=2] FALSE, FALSE
[08:26:43.960] - queued futures: [n=2] FALSE, FALSE
[08:26:43.960]  - until=1
[08:26:43.960]  - relaying element #1
[08:26:43.960] - relayed: [n=2] FALSE, FALSE
[08:26:43.960] - queued futures: [n=2] FALSE, TRUE
[08:26:43.960] signalConditionsASAP(NULL, pos=2) ... done
[08:26:43.961]  length: 1 (resolved future 2)
[08:26:44.388] plan(): Setting new future strategy stack:
[08:26:44.388] List of future strategies:
[08:26:44.388] 1. multicore:
[08:26:44.388]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:44.388]    - tweaked: FALSE
[08:26:44.388]    - call: plan(strategy)
[08:26:44.391] plan(): nbrOfWorkers() = 2
[08:26:44.391] Future #1
[08:26:44.391] result() for MulticoreFuture ...
[08:26:44.392] result() for MulticoreFuture ...
[08:26:44.392] result() for MulticoreFuture ... done
[08:26:44.393] result() for MulticoreFuture ... done
[08:26:44.393] result() for MulticoreFuture ...
[08:26:44.393] result() for MulticoreFuture ... done
[08:26:44.393] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:44.393] - nx: 2
[08:26:44.393] - relay: TRUE
[08:26:44.393] - stdout: TRUE
[08:26:44.393] - signal: TRUE
[08:26:44.394] - resignal: FALSE
[08:26:44.394] - force: TRUE
[08:26:44.394] - relayed: [n=2] FALSE, FALSE
[08:26:44.394] - queued futures: [n=2] FALSE, TRUE
[08:26:44.394]  - until=1
[08:26:44.394]  - relaying element #1
[08:26:44.394] result() for MulticoreFuture ...
[08:26:44.394] result() for MulticoreFuture ... done
[08:26:44.394] result() for MulticoreFuture ...
[08:26:44.395] result() for MulticoreFuture ... done
[08:26:44.395] result() for MulticoreFuture ...
[08:26:44.395] result() for MulticoreFuture ... done
[08:26:44.395] result() for MulticoreFuture ...
[08:26:44.395] result() for MulticoreFuture ... done
[08:26:44.395] - relayed: [n=2] TRUE, FALSE
[08:26:44.395] - queued futures: [n=2] TRUE, TRUE
[08:26:44.395] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:44.396]  length: 0 (resolved future 1)
[08:26:44.396] Relaying remaining futures
[08:26:44.396] signalConditionsASAP(NULL, pos=0) ...
[08:26:44.396] - nx: 2
[08:26:44.396] - relay: TRUE
[08:26:44.396] - stdout: TRUE
[08:26:44.396] - signal: TRUE
[08:26:44.396] - resignal: FALSE
[08:26:44.396] - force: TRUE
[08:26:44.396] - relayed: [n=2] TRUE, FALSE
[08:26:44.397] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:44.397]  - relaying element #2
[08:26:44.397] result() for MulticoreFuture ...
[08:26:44.397] result() for MulticoreFuture ... done
[08:26:44.397] result() for MulticoreFuture ...
[08:26:44.397] result() for MulticoreFuture ... done
[08:26:44.397] result() for MulticoreFuture ...
[08:26:44.398] result() for MulticoreFuture ... done
[08:26:44.398] result() for MulticoreFuture ...
[08:26:44.398] result() for MulticoreFuture ... done
[08:26:44.398] - relayed: [n=2] TRUE, TRUE
[08:26:44.398] - queued futures: [n=2] TRUE, TRUE
[08:26:44.398] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[08:26:44.398] resolve() on list ... DONE
[08:26:44.398] result() for MulticoreFuture ...
[08:26:44.398] result() for MulticoreFuture ... done
[08:26:44.399] result() for MulticoreFuture ...
[08:26:44.399] result() for MulticoreFuture ... done
[08:26:44.399] result() for MulticoreFuture ...
[08:26:44.399] result() for MulticoreFuture ... done
[08:26:44.399] result() for MulticoreFuture ...
[08:26:44.399] result() for MulticoreFuture ... done
[08:26:44.399]  - Number of value chunks collected: 2
[08:26:44.399] Resolving 2 futures (chunks) ... DONE
[08:26:44.399] Reducing values from 2 chunks ...
[08:26:44.400]  - Number of values collected after concatenation: 2
[08:26:44.400]  - Number of values expected: 2
[08:26:44.400] Reducing values from 2 chunks ... DONE
[08:26:44.400] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[08:26:44.400] future_mapply() ...
[08:26:44.403] Number of chunks: 2
[08:26:44.403] getGlobalsAndPackagesXApply() ...
[08:26:44.403]  - future.globals: TRUE
[08:26:44.403] getGlobalsAndPackages() ...
[08:26:44.404] Searching for globals...
[08:26:44.408] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:44.408] Searching for globals ... DONE
[08:26:44.409] Resolving globals: FALSE
[08:26:44.409] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:44.410] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:44.410] - globals: [1] ‘FUN’
[08:26:44.410] 
[08:26:44.410] getGlobalsAndPackages() ... DONE
[08:26:44.411]  - globals found/used: [n=1] ‘FUN’
[08:26:44.411]  - needed namespaces: [n=0] 
[08:26:44.411] Finding globals ... DONE
[08:26:44.411] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:44.411] List of 2
[08:26:44.411]  $ ...future.FUN:function (x, y)  
[08:26:44.411]  $ MoreArgs     : NULL
[08:26:44.411]  - attr(*, "where")=List of 2
[08:26:44.411]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:44.411]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:44.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:44.411]  - attr(*, "resolved")= logi FALSE
[08:26:44.411]  - attr(*, "total_size")= num NA
[08:26:44.415] Packages to be attached in all futures: [n=0] 
[08:26:44.415] getGlobalsAndPackagesXApply() ... DONE
[08:26:44.415] Number of futures (= number of chunks): 2
[08:26:44.415] Launching 2 futures (chunks) ...
[08:26:44.415] Chunk #1 of 2 ...
[08:26:44.415]  - Finding globals in '...' for chunk #1 ...
[08:26:44.416] getGlobalsAndPackages() ...
[08:26:44.416] Searching for globals...
[08:26:44.416] 
[08:26:44.416] Searching for globals ... DONE
[08:26:44.416] - globals: [0] <none>
[08:26:44.416] getGlobalsAndPackages() ... DONE
[08:26:44.416]    + additional globals found: [n=0] 
[08:26:44.417]    + additional namespaces needed: [n=0] 
[08:26:44.417]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:44.417]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:44.417]  - seeds: <none>
[08:26:44.417]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:44.417] getGlobalsAndPackages() ...
[08:26:44.417] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:44.417] Resolving globals: FALSE
[08:26:44.418] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:44.418] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:44.419] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:44.419] 
[08:26:44.419] getGlobalsAndPackages() ... DONE
[08:26:44.419] run() for ‘Future’ ...
[08:26:44.419] - state: ‘created’
[08:26:44.419] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:44.421] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:44.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:44.422]   - Field: ‘label’
[08:26:44.422]   - Field: ‘local’
[08:26:44.422]   - Field: ‘owner’
[08:26:44.422]   - Field: ‘envir’
[08:26:44.422]   - Field: ‘workers’
[08:26:44.422]   - Field: ‘packages’
[08:26:44.422]   - Field: ‘gc’
[08:26:44.422]   - Field: ‘job’
[08:26:44.422]   - Field: ‘conditions’
[08:26:44.422]   - Field: ‘expr’
[08:26:44.423]   - Field: ‘uuid’
[08:26:44.423]   - Field: ‘seed’
[08:26:44.423]   - Field: ‘version’
[08:26:44.423]   - Field: ‘result’
[08:26:44.423]   - Field: ‘asynchronous’
[08:26:44.423]   - Field: ‘calls’
[08:26:44.423]   - Field: ‘globals’
[08:26:44.423]   - Field: ‘stdout’
[08:26:44.423]   - Field: ‘earlySignal’
[08:26:44.423]   - Field: ‘lazy’
[08:26:44.424]   - Field: ‘state’
[08:26:44.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:44.424] - Launch lazy future ...
[08:26:44.424] Packages needed by the future expression (n = 0): <none>
[08:26:44.424] Packages needed by future strategies (n = 0): <none>
[08:26:44.425] {
[08:26:44.425]     {
[08:26:44.425]         {
[08:26:44.425]             ...future.startTime <- base::Sys.time()
[08:26:44.425]             {
[08:26:44.425]                 {
[08:26:44.425]                   {
[08:26:44.425]                     {
[08:26:44.425]                       base::local({
[08:26:44.425]                         has_future <- base::requireNamespace("future", 
[08:26:44.425]                           quietly = TRUE)
[08:26:44.425]                         if (has_future) {
[08:26:44.425]                           ns <- base::getNamespace("future")
[08:26:44.425]                           version <- ns[[".package"]][["version"]]
[08:26:44.425]                           if (is.null(version)) 
[08:26:44.425]                             version <- utils::packageVersion("future")
[08:26:44.425]                         }
[08:26:44.425]                         else {
[08:26:44.425]                           version <- NULL
[08:26:44.425]                         }
[08:26:44.425]                         if (!has_future || version < "1.8.0") {
[08:26:44.425]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:44.425]                             "", base::R.version$version.string), 
[08:26:44.425]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:44.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:44.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:44.425]                               "release", "version")], collapse = " "), 
[08:26:44.425]                             hostname = base::Sys.info()[["nodename"]])
[08:26:44.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:44.425]                             info)
[08:26:44.425]                           info <- base::paste(info, collapse = "; ")
[08:26:44.425]                           if (!has_future) {
[08:26:44.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:44.425]                               info)
[08:26:44.425]                           }
[08:26:44.425]                           else {
[08:26:44.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:44.425]                               info, version)
[08:26:44.425]                           }
[08:26:44.425]                           base::stop(msg)
[08:26:44.425]                         }
[08:26:44.425]                       })
[08:26:44.425]                     }
[08:26:44.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:44.425]                     base::options(mc.cores = 1L)
[08:26:44.425]                   }
[08:26:44.425]                   ...future.strategy.old <- future::plan("list")
[08:26:44.425]                   options(future.plan = NULL)
[08:26:44.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:44.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:44.425]                 }
[08:26:44.425]                 ...future.workdir <- getwd()
[08:26:44.425]             }
[08:26:44.425]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:44.425]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:44.425]         }
[08:26:44.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:44.425]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:44.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:44.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:44.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:44.425]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:44.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:44.425]             base::names(...future.oldOptions))
[08:26:44.425]     }
[08:26:44.425]     if (FALSE) {
[08:26:44.425]     }
[08:26:44.425]     else {
[08:26:44.425]         if (FALSE) {
[08:26:44.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:44.425]                 open = "w")
[08:26:44.425]         }
[08:26:44.425]         else {
[08:26:44.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:44.425]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:44.425]         }
[08:26:44.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:44.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:44.425]             base::sink(type = "output", split = FALSE)
[08:26:44.425]             base::close(...future.stdout)
[08:26:44.425]         }, add = TRUE)
[08:26:44.425]     }
[08:26:44.425]     ...future.frame <- base::sys.nframe()
[08:26:44.425]     ...future.conditions <- base::list()
[08:26:44.425]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:44.425]     if (FALSE) {
[08:26:44.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:44.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:44.425]     }
[08:26:44.425]     ...future.result <- base::tryCatch({
[08:26:44.425]         base::withCallingHandlers({
[08:26:44.425]             ...future.value <- base::withVisible(base::local({
[08:26:44.425]                 withCallingHandlers({
[08:26:44.425]                   {
[08:26:44.425]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:44.425]                     if (!identical(...future.globals.maxSize.org, 
[08:26:44.425]                       ...future.globals.maxSize)) {
[08:26:44.425]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:44.425]                       on.exit(options(oopts), add = TRUE)
[08:26:44.425]                     }
[08:26:44.425]                     {
[08:26:44.425]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:44.425]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:44.425]                         USE.NAMES = FALSE)
[08:26:44.425]                       do.call(mapply, args = args)
[08:26:44.425]                     }
[08:26:44.425]                   }
[08:26:44.425]                 }, immediateCondition = function(cond) {
[08:26:44.425]                   save_rds <- function (object, pathname, ...) 
[08:26:44.425]                   {
[08:26:44.425]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:44.425]                     if (file_test("-f", pathname_tmp)) {
[08:26:44.425]                       fi_tmp <- file.info(pathname_tmp)
[08:26:44.425]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:44.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:44.425]                         fi_tmp[["mtime"]])
[08:26:44.425]                     }
[08:26:44.425]                     tryCatch({
[08:26:44.425]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:44.425]                     }, error = function(ex) {
[08:26:44.425]                       msg <- conditionMessage(ex)
[08:26:44.425]                       fi_tmp <- file.info(pathname_tmp)
[08:26:44.425]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:44.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:44.425]                         fi_tmp[["mtime"]], msg)
[08:26:44.425]                       ex$message <- msg
[08:26:44.425]                       stop(ex)
[08:26:44.425]                     })
[08:26:44.425]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:44.425]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:44.425]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:44.425]                       fi_tmp <- file.info(pathname_tmp)
[08:26:44.425]                       fi <- file.info(pathname)
[08:26:44.425]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:44.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:44.425]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:44.425]                         fi[["size"]], fi[["mtime"]])
[08:26:44.425]                       stop(msg)
[08:26:44.425]                     }
[08:26:44.425]                     invisible(pathname)
[08:26:44.425]                   }
[08:26:44.425]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:44.425]                     rootPath = tempdir()) 
[08:26:44.425]                   {
[08:26:44.425]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:44.425]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:44.425]                       tmpdir = path, fileext = ".rds")
[08:26:44.425]                     save_rds(obj, file)
[08:26:44.425]                   }
[08:26:44.425]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:44.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:44.425]                   {
[08:26:44.425]                     inherits <- base::inherits
[08:26:44.425]                     invokeRestart <- base::invokeRestart
[08:26:44.425]                     is.null <- base::is.null
[08:26:44.425]                     muffled <- FALSE
[08:26:44.425]                     if (inherits(cond, "message")) {
[08:26:44.425]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:44.425]                       if (muffled) 
[08:26:44.425]                         invokeRestart("muffleMessage")
[08:26:44.425]                     }
[08:26:44.425]                     else if (inherits(cond, "warning")) {
[08:26:44.425]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:44.425]                       if (muffled) 
[08:26:44.425]                         invokeRestart("muffleWarning")
[08:26:44.425]                     }
[08:26:44.425]                     else if (inherits(cond, "condition")) {
[08:26:44.425]                       if (!is.null(pattern)) {
[08:26:44.425]                         computeRestarts <- base::computeRestarts
[08:26:44.425]                         grepl <- base::grepl
[08:26:44.425]                         restarts <- computeRestarts(cond)
[08:26:44.425]                         for (restart in restarts) {
[08:26:44.425]                           name <- restart$name
[08:26:44.425]                           if (is.null(name)) 
[08:26:44.425]                             next
[08:26:44.425]                           if (!grepl(pattern, name)) 
[08:26:44.425]                             next
[08:26:44.425]                           invokeRestart(restart)
[08:26:44.425]                           muffled <- TRUE
[08:26:44.425]                           break
[08:26:44.425]                         }
[08:26:44.425]                       }
[08:26:44.425]                     }
[08:26:44.425]                     invisible(muffled)
[08:26:44.425]                   }
[08:26:44.425]                   muffleCondition(cond)
[08:26:44.425]                 })
[08:26:44.425]             }))
[08:26:44.425]             future::FutureResult(value = ...future.value$value, 
[08:26:44.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:44.425]                   ...future.rng), globalenv = if (FALSE) 
[08:26:44.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:44.425]                     ...future.globalenv.names))
[08:26:44.425]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:44.425]         }, condition = base::local({
[08:26:44.425]             c <- base::c
[08:26:44.425]             inherits <- base::inherits
[08:26:44.425]             invokeRestart <- base::invokeRestart
[08:26:44.425]             length <- base::length
[08:26:44.425]             list <- base::list
[08:26:44.425]             seq.int <- base::seq.int
[08:26:44.425]             signalCondition <- base::signalCondition
[08:26:44.425]             sys.calls <- base::sys.calls
[08:26:44.425]             `[[` <- base::`[[`
[08:26:44.425]             `+` <- base::`+`
[08:26:44.425]             `<<-` <- base::`<<-`
[08:26:44.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:44.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:44.425]                   3L)]
[08:26:44.425]             }
[08:26:44.425]             function(cond) {
[08:26:44.425]                 is_error <- inherits(cond, "error")
[08:26:44.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:44.425]                   NULL)
[08:26:44.425]                 if (is_error) {
[08:26:44.425]                   sessionInformation <- function() {
[08:26:44.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:44.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:44.425]                       search = base::search(), system = base::Sys.info())
[08:26:44.425]                   }
[08:26:44.425]                   ...future.conditions[[length(...future.conditions) + 
[08:26:44.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:44.425]                     cond$call), session = sessionInformation(), 
[08:26:44.425]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:44.425]                   signalCondition(cond)
[08:26:44.425]                 }
[08:26:44.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:44.425]                 "immediateCondition"))) {
[08:26:44.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:44.425]                   ...future.conditions[[length(...future.conditions) + 
[08:26:44.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:44.425]                   if (TRUE && !signal) {
[08:26:44.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:44.425]                     {
[08:26:44.425]                       inherits <- base::inherits
[08:26:44.425]                       invokeRestart <- base::invokeRestart
[08:26:44.425]                       is.null <- base::is.null
[08:26:44.425]                       muffled <- FALSE
[08:26:44.425]                       if (inherits(cond, "message")) {
[08:26:44.425]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:44.425]                         if (muffled) 
[08:26:44.425]                           invokeRestart("muffleMessage")
[08:26:44.425]                       }
[08:26:44.425]                       else if (inherits(cond, "warning")) {
[08:26:44.425]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:44.425]                         if (muffled) 
[08:26:44.425]                           invokeRestart("muffleWarning")
[08:26:44.425]                       }
[08:26:44.425]                       else if (inherits(cond, "condition")) {
[08:26:44.425]                         if (!is.null(pattern)) {
[08:26:44.425]                           computeRestarts <- base::computeRestarts
[08:26:44.425]                           grepl <- base::grepl
[08:26:44.425]                           restarts <- computeRestarts(cond)
[08:26:44.425]                           for (restart in restarts) {
[08:26:44.425]                             name <- restart$name
[08:26:44.425]                             if (is.null(name)) 
[08:26:44.425]                               next
[08:26:44.425]                             if (!grepl(pattern, name)) 
[08:26:44.425]                               next
[08:26:44.425]                             invokeRestart(restart)
[08:26:44.425]                             muffled <- TRUE
[08:26:44.425]                             break
[08:26:44.425]                           }
[08:26:44.425]                         }
[08:26:44.425]                       }
[08:26:44.425]                       invisible(muffled)
[08:26:44.425]                     }
[08:26:44.425]                     muffleCondition(cond, pattern = "^muffle")
[08:26:44.425]                   }
[08:26:44.425]                 }
[08:26:44.425]                 else {
[08:26:44.425]                   if (TRUE) {
[08:26:44.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:44.425]                     {
[08:26:44.425]                       inherits <- base::inherits
[08:26:44.425]                       invokeRestart <- base::invokeRestart
[08:26:44.425]                       is.null <- base::is.null
[08:26:44.425]                       muffled <- FALSE
[08:26:44.425]                       if (inherits(cond, "message")) {
[08:26:44.425]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:44.425]                         if (muffled) 
[08:26:44.425]                           invokeRestart("muffleMessage")
[08:26:44.425]                       }
[08:26:44.425]                       else if (inherits(cond, "warning")) {
[08:26:44.425]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:44.425]                         if (muffled) 
[08:26:44.425]                           invokeRestart("muffleWarning")
[08:26:44.425]                       }
[08:26:44.425]                       else if (inherits(cond, "condition")) {
[08:26:44.425]                         if (!is.null(pattern)) {
[08:26:44.425]                           computeRestarts <- base::computeRestarts
[08:26:44.425]                           grepl <- base::grepl
[08:26:44.425]                           restarts <- computeRestarts(cond)
[08:26:44.425]                           for (restart in restarts) {
[08:26:44.425]                             name <- restart$name
[08:26:44.425]                             if (is.null(name)) 
[08:26:44.425]                               next
[08:26:44.425]                             if (!grepl(pattern, name)) 
[08:26:44.425]                               next
[08:26:44.425]                             invokeRestart(restart)
[08:26:44.425]                             muffled <- TRUE
[08:26:44.425]                             break
[08:26:44.425]                           }
[08:26:44.425]                         }
[08:26:44.425]                       }
[08:26:44.425]                       invisible(muffled)
[08:26:44.425]                     }
[08:26:44.425]                     muffleCondition(cond, pattern = "^muffle")
[08:26:44.425]                   }
[08:26:44.425]                 }
[08:26:44.425]             }
[08:26:44.425]         }))
[08:26:44.425]     }, error = function(ex) {
[08:26:44.425]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:44.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:44.425]                 ...future.rng), started = ...future.startTime, 
[08:26:44.425]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:44.425]             version = "1.8"), class = "FutureResult")
[08:26:44.425]     }, finally = {
[08:26:44.425]         if (!identical(...future.workdir, getwd())) 
[08:26:44.425]             setwd(...future.workdir)
[08:26:44.425]         {
[08:26:44.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:44.425]                 ...future.oldOptions$nwarnings <- NULL
[08:26:44.425]             }
[08:26:44.425]             base::options(...future.oldOptions)
[08:26:44.425]             if (.Platform$OS.type == "windows") {
[08:26:44.425]                 old_names <- names(...future.oldEnvVars)
[08:26:44.425]                 envs <- base::Sys.getenv()
[08:26:44.425]                 names <- names(envs)
[08:26:44.425]                 common <- intersect(names, old_names)
[08:26:44.425]                 added <- setdiff(names, old_names)
[08:26:44.425]                 removed <- setdiff(old_names, names)
[08:26:44.425]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:44.425]                   envs[common]]
[08:26:44.425]                 NAMES <- toupper(changed)
[08:26:44.425]                 args <- list()
[08:26:44.425]                 for (kk in seq_along(NAMES)) {
[08:26:44.425]                   name <- changed[[kk]]
[08:26:44.425]                   NAME <- NAMES[[kk]]
[08:26:44.425]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:44.425]                     next
[08:26:44.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:44.425]                 }
[08:26:44.425]                 NAMES <- toupper(added)
[08:26:44.425]                 for (kk in seq_along(NAMES)) {
[08:26:44.425]                   name <- added[[kk]]
[08:26:44.425]                   NAME <- NAMES[[kk]]
[08:26:44.425]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:44.425]                     next
[08:26:44.425]                   args[[name]] <- ""
[08:26:44.425]                 }
[08:26:44.425]                 NAMES <- toupper(removed)
[08:26:44.425]                 for (kk in seq_along(NAMES)) {
[08:26:44.425]                   name <- removed[[kk]]
[08:26:44.425]                   NAME <- NAMES[[kk]]
[08:26:44.425]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:44.425]                     next
[08:26:44.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:44.425]                 }
[08:26:44.425]                 if (length(args) > 0) 
[08:26:44.425]                   base::do.call(base::Sys.setenv, args = args)
[08:26:44.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:44.425]             }
[08:26:44.425]             else {
[08:26:44.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:44.425]             }
[08:26:44.425]             {
[08:26:44.425]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:44.425]                   0L) {
[08:26:44.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:44.425]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:44.425]                   base::options(opts)
[08:26:44.425]                 }
[08:26:44.425]                 {
[08:26:44.425]                   {
[08:26:44.425]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:44.425]                     NULL
[08:26:44.425]                   }
[08:26:44.425]                   options(future.plan = NULL)
[08:26:44.425]                   if (is.na(NA_character_)) 
[08:26:44.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:44.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:44.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:44.425]                     .init = FALSE)
[08:26:44.425]                 }
[08:26:44.425]             }
[08:26:44.425]         }
[08:26:44.425]     })
[08:26:44.425]     if (TRUE) {
[08:26:44.425]         base::sink(type = "output", split = FALSE)
[08:26:44.425]         if (FALSE) {
[08:26:44.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:44.425]         }
[08:26:44.425]         else {
[08:26:44.425]             ...future.result["stdout"] <- base::list(NULL)
[08:26:44.425]         }
[08:26:44.425]         base::close(...future.stdout)
[08:26:44.425]         ...future.stdout <- NULL
[08:26:44.425]     }
[08:26:44.425]     ...future.result$conditions <- ...future.conditions
[08:26:44.425]     ...future.result$finished <- base::Sys.time()
[08:26:44.425]     ...future.result
[08:26:44.425] }
[08:26:44.428] assign_globals() ...
[08:26:44.428] List of 5
[08:26:44.428]  $ ...future.FUN            :function (x, y)  
[08:26:44.428]  $ MoreArgs                 : NULL
[08:26:44.428]  $ ...future.elements_ii    :List of 2
[08:26:44.428]   ..$ :List of 1
[08:26:44.428]   .. ..$ : int 1
[08:26:44.428]   ..$ :List of 1
[08:26:44.428]   .. ..$ : int 0
[08:26:44.428]  $ ...future.seeds_ii       : NULL
[08:26:44.428]  $ ...future.globals.maxSize: NULL
[08:26:44.428]  - attr(*, "where")=List of 5
[08:26:44.428]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:44.428]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:44.428]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:44.428]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:44.428]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:44.428]  - attr(*, "resolved")= logi FALSE
[08:26:44.428]  - attr(*, "total_size")= num 1218
[08:26:44.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:44.428]  - attr(*, "already-done")= logi TRUE
[08:26:44.434] - reassign environment for ‘...future.FUN’
[08:26:44.434] - copied ‘...future.FUN’ to environment
[08:26:44.434] - copied ‘MoreArgs’ to environment
[08:26:44.434] - copied ‘...future.elements_ii’ to environment
[08:26:44.434] - copied ‘...future.seeds_ii’ to environment
[08:26:44.434] - copied ‘...future.globals.maxSize’ to environment
[08:26:44.434] assign_globals() ... done
[08:26:44.435] requestCore(): workers = 2
[08:26:44.437] MulticoreFuture started
[08:26:44.438] - Launch lazy future ... done
[08:26:44.438] run() for ‘MulticoreFuture’ ... done
[08:26:44.438] Created future:
[08:26:44.438] plan(): Setting new future strategy stack:
[08:26:44.438] List of future strategies:
[08:26:44.438] 1. sequential:
[08:26:44.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:44.438]    - tweaked: FALSE
[08:26:44.438]    - call: NULL
[08:26:44.439] plan(): nbrOfWorkers() = 1
[08:26:44.438] MulticoreFuture:
[08:26:44.438] Label: ‘future_mapply-1’
[08:26:44.438] Expression:
[08:26:44.438] {
[08:26:44.438]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:44.438]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:44.438]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:44.438]         on.exit(options(oopts), add = TRUE)
[08:26:44.438]     }
[08:26:44.438]     {
[08:26:44.438]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:44.438]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:44.438]         do.call(mapply, args = args)
[08:26:44.438]     }
[08:26:44.438] }
[08:26:44.438] Lazy evaluation: FALSE
[08:26:44.438] Asynchronous evaluation: TRUE
[08:26:44.438] Local evaluation: TRUE
[08:26:44.438] Environment: R_GlobalEnv
[08:26:44.438] Capture standard output: FALSE
[08:26:44.438] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:44.438] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:44.438] Packages: <none>
[08:26:44.438] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:44.438] Resolved: FALSE
[08:26:44.438] Value: <not collected>
[08:26:44.438] Conditions captured: <none>
[08:26:44.438] Early signaling: FALSE
[08:26:44.438] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:44.438] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:44.456] Chunk #1 of 2 ... DONE
[08:26:44.456] Chunk #2 of 2 ...
[08:26:44.457]  - Finding globals in '...' for chunk #2 ...
[08:26:44.457] getGlobalsAndPackages() ...
[08:26:44.458] Searching for globals...
[08:26:44.460] 
[08:26:44.460] Searching for globals ... DONE
[08:26:44.460] - globals: [0] <none>
[08:26:44.461] getGlobalsAndPackages() ... DONE
[08:26:44.461]    + additional globals found: [n=0] 
[08:26:44.462]    + additional namespaces needed: [n=0] 
[08:26:44.462]  - Finding globals in '...' for chunk #2 ... DONE
[08:26:44.462]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:44.462]  - seeds: <none>
[08:26:44.463]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:44.463] getGlobalsAndPackages() ...
[08:26:44.463] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:44.464] Resolving globals: FALSE
[08:26:44.465] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:44.466] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:44.466] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:44.466] 
[08:26:44.467] getGlobalsAndPackages() ... DONE
[08:26:44.467] run() for ‘Future’ ...
[08:26:44.468] - state: ‘created’
[08:26:44.468] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:44.471] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:44.471] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:44.471]   - Field: ‘label’
[08:26:44.472]   - Field: ‘local’
[08:26:44.472]   - Field: ‘owner’
[08:26:44.472]   - Field: ‘envir’
[08:26:44.472]   - Field: ‘workers’
[08:26:44.472]   - Field: ‘packages’
[08:26:44.472]   - Field: ‘gc’
[08:26:44.473]   - Field: ‘job’
[08:26:44.473]   - Field: ‘conditions’
[08:26:44.473]   - Field: ‘expr’
[08:26:44.473]   - Field: ‘uuid’
[08:26:44.473]   - Field: ‘seed’
[08:26:44.473]   - Field: ‘version’
[08:26:44.473]   - Field: ‘result’
[08:26:44.473]   - Field: ‘asynchronous’
[08:26:44.474]   - Field: ‘calls’
[08:26:44.474]   - Field: ‘globals’
[08:26:44.474]   - Field: ‘stdout’
[08:26:44.474]   - Field: ‘earlySignal’
[08:26:44.474]   - Field: ‘lazy’
[08:26:44.474]   - Field: ‘state’
[08:26:44.474] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:44.475] - Launch lazy future ...
[08:26:44.475] Packages needed by the future expression (n = 0): <none>
[08:26:44.475] Packages needed by future strategies (n = 0): <none>
[08:26:44.476] {
[08:26:44.476]     {
[08:26:44.476]         {
[08:26:44.476]             ...future.startTime <- base::Sys.time()
[08:26:44.476]             {
[08:26:44.476]                 {
[08:26:44.476]                   {
[08:26:44.476]                     {
[08:26:44.476]                       base::local({
[08:26:44.476]                         has_future <- base::requireNamespace("future", 
[08:26:44.476]                           quietly = TRUE)
[08:26:44.476]                         if (has_future) {
[08:26:44.476]                           ns <- base::getNamespace("future")
[08:26:44.476]                           version <- ns[[".package"]][["version"]]
[08:26:44.476]                           if (is.null(version)) 
[08:26:44.476]                             version <- utils::packageVersion("future")
[08:26:44.476]                         }
[08:26:44.476]                         else {
[08:26:44.476]                           version <- NULL
[08:26:44.476]                         }
[08:26:44.476]                         if (!has_future || version < "1.8.0") {
[08:26:44.476]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:44.476]                             "", base::R.version$version.string), 
[08:26:44.476]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:44.476]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:44.476]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:44.476]                               "release", "version")], collapse = " "), 
[08:26:44.476]                             hostname = base::Sys.info()[["nodename"]])
[08:26:44.476]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:44.476]                             info)
[08:26:44.476]                           info <- base::paste(info, collapse = "; ")
[08:26:44.476]                           if (!has_future) {
[08:26:44.476]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:44.476]                               info)
[08:26:44.476]                           }
[08:26:44.476]                           else {
[08:26:44.476]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:44.476]                               info, version)
[08:26:44.476]                           }
[08:26:44.476]                           base::stop(msg)
[08:26:44.476]                         }
[08:26:44.476]                       })
[08:26:44.476]                     }
[08:26:44.476]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:44.476]                     base::options(mc.cores = 1L)
[08:26:44.476]                   }
[08:26:44.476]                   ...future.strategy.old <- future::plan("list")
[08:26:44.476]                   options(future.plan = NULL)
[08:26:44.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:44.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:44.476]                 }
[08:26:44.476]                 ...future.workdir <- getwd()
[08:26:44.476]             }
[08:26:44.476]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:44.476]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:44.476]         }
[08:26:44.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:44.476]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:44.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:44.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:44.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:44.476]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:44.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:44.476]             base::names(...future.oldOptions))
[08:26:44.476]     }
[08:26:44.476]     if (FALSE) {
[08:26:44.476]     }
[08:26:44.476]     else {
[08:26:44.476]         if (FALSE) {
[08:26:44.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:44.476]                 open = "w")
[08:26:44.476]         }
[08:26:44.476]         else {
[08:26:44.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:44.476]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:44.476]         }
[08:26:44.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:44.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:44.476]             base::sink(type = "output", split = FALSE)
[08:26:44.476]             base::close(...future.stdout)
[08:26:44.476]         }, add = TRUE)
[08:26:44.476]     }
[08:26:44.476]     ...future.frame <- base::sys.nframe()
[08:26:44.476]     ...future.conditions <- base::list()
[08:26:44.476]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:44.476]     if (FALSE) {
[08:26:44.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:44.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:44.476]     }
[08:26:44.476]     ...future.result <- base::tryCatch({
[08:26:44.476]         base::withCallingHandlers({
[08:26:44.476]             ...future.value <- base::withVisible(base::local({
[08:26:44.476]                 withCallingHandlers({
[08:26:44.476]                   {
[08:26:44.476]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:44.476]                     if (!identical(...future.globals.maxSize.org, 
[08:26:44.476]                       ...future.globals.maxSize)) {
[08:26:44.476]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:44.476]                       on.exit(options(oopts), add = TRUE)
[08:26:44.476]                     }
[08:26:44.476]                     {
[08:26:44.476]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:44.476]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:44.476]                         USE.NAMES = FALSE)
[08:26:44.476]                       do.call(mapply, args = args)
[08:26:44.476]                     }
[08:26:44.476]                   }
[08:26:44.476]                 }, immediateCondition = function(cond) {
[08:26:44.476]                   save_rds <- function (object, pathname, ...) 
[08:26:44.476]                   {
[08:26:44.476]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:44.476]                     if (file_test("-f", pathname_tmp)) {
[08:26:44.476]                       fi_tmp <- file.info(pathname_tmp)
[08:26:44.476]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:44.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:44.476]                         fi_tmp[["mtime"]])
[08:26:44.476]                     }
[08:26:44.476]                     tryCatch({
[08:26:44.476]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:44.476]                     }, error = function(ex) {
[08:26:44.476]                       msg <- conditionMessage(ex)
[08:26:44.476]                       fi_tmp <- file.info(pathname_tmp)
[08:26:44.476]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:44.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:44.476]                         fi_tmp[["mtime"]], msg)
[08:26:44.476]                       ex$message <- msg
[08:26:44.476]                       stop(ex)
[08:26:44.476]                     })
[08:26:44.476]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:44.476]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:44.476]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:44.476]                       fi_tmp <- file.info(pathname_tmp)
[08:26:44.476]                       fi <- file.info(pathname)
[08:26:44.476]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:44.476]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:44.476]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:44.476]                         fi[["size"]], fi[["mtime"]])
[08:26:44.476]                       stop(msg)
[08:26:44.476]                     }
[08:26:44.476]                     invisible(pathname)
[08:26:44.476]                   }
[08:26:44.476]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:44.476]                     rootPath = tempdir()) 
[08:26:44.476]                   {
[08:26:44.476]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:44.476]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:44.476]                       tmpdir = path, fileext = ".rds")
[08:26:44.476]                     save_rds(obj, file)
[08:26:44.476]                   }
[08:26:44.476]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:44.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:44.476]                   {
[08:26:44.476]                     inherits <- base::inherits
[08:26:44.476]                     invokeRestart <- base::invokeRestart
[08:26:44.476]                     is.null <- base::is.null
[08:26:44.476]                     muffled <- FALSE
[08:26:44.476]                     if (inherits(cond, "message")) {
[08:26:44.476]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:44.476]                       if (muffled) 
[08:26:44.476]                         invokeRestart("muffleMessage")
[08:26:44.476]                     }
[08:26:44.476]                     else if (inherits(cond, "warning")) {
[08:26:44.476]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:44.476]                       if (muffled) 
[08:26:44.476]                         invokeRestart("muffleWarning")
[08:26:44.476]                     }
[08:26:44.476]                     else if (inherits(cond, "condition")) {
[08:26:44.476]                       if (!is.null(pattern)) {
[08:26:44.476]                         computeRestarts <- base::computeRestarts
[08:26:44.476]                         grepl <- base::grepl
[08:26:44.476]                         restarts <- computeRestarts(cond)
[08:26:44.476]                         for (restart in restarts) {
[08:26:44.476]                           name <- restart$name
[08:26:44.476]                           if (is.null(name)) 
[08:26:44.476]                             next
[08:26:44.476]                           if (!grepl(pattern, name)) 
[08:26:44.476]                             next
[08:26:44.476]                           invokeRestart(restart)
[08:26:44.476]                           muffled <- TRUE
[08:26:44.476]                           break
[08:26:44.476]                         }
[08:26:44.476]                       }
[08:26:44.476]                     }
[08:26:44.476]                     invisible(muffled)
[08:26:44.476]                   }
[08:26:44.476]                   muffleCondition(cond)
[08:26:44.476]                 })
[08:26:44.476]             }))
[08:26:44.476]             future::FutureResult(value = ...future.value$value, 
[08:26:44.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:44.476]                   ...future.rng), globalenv = if (FALSE) 
[08:26:44.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:44.476]                     ...future.globalenv.names))
[08:26:44.476]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:44.476]         }, condition = base::local({
[08:26:44.476]             c <- base::c
[08:26:44.476]             inherits <- base::inherits
[08:26:44.476]             invokeRestart <- base::invokeRestart
[08:26:44.476]             length <- base::length
[08:26:44.476]             list <- base::list
[08:26:44.476]             seq.int <- base::seq.int
[08:26:44.476]             signalCondition <- base::signalCondition
[08:26:44.476]             sys.calls <- base::sys.calls
[08:26:44.476]             `[[` <- base::`[[`
[08:26:44.476]             `+` <- base::`+`
[08:26:44.476]             `<<-` <- base::`<<-`
[08:26:44.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:44.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:44.476]                   3L)]
[08:26:44.476]             }
[08:26:44.476]             function(cond) {
[08:26:44.476]                 is_error <- inherits(cond, "error")
[08:26:44.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:44.476]                   NULL)
[08:26:44.476]                 if (is_error) {
[08:26:44.476]                   sessionInformation <- function() {
[08:26:44.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:44.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:44.476]                       search = base::search(), system = base::Sys.info())
[08:26:44.476]                   }
[08:26:44.476]                   ...future.conditions[[length(...future.conditions) + 
[08:26:44.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:44.476]                     cond$call), session = sessionInformation(), 
[08:26:44.476]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:44.476]                   signalCondition(cond)
[08:26:44.476]                 }
[08:26:44.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:44.476]                 "immediateCondition"))) {
[08:26:44.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:44.476]                   ...future.conditions[[length(...future.conditions) + 
[08:26:44.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:44.476]                   if (TRUE && !signal) {
[08:26:44.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:44.476]                     {
[08:26:44.476]                       inherits <- base::inherits
[08:26:44.476]                       invokeRestart <- base::invokeRestart
[08:26:44.476]                       is.null <- base::is.null
[08:26:44.476]                       muffled <- FALSE
[08:26:44.476]                       if (inherits(cond, "message")) {
[08:26:44.476]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:44.476]                         if (muffled) 
[08:26:44.476]                           invokeRestart("muffleMessage")
[08:26:44.476]                       }
[08:26:44.476]                       else if (inherits(cond, "warning")) {
[08:26:44.476]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:44.476]                         if (muffled) 
[08:26:44.476]                           invokeRestart("muffleWarning")
[08:26:44.476]                       }
[08:26:44.476]                       else if (inherits(cond, "condition")) {
[08:26:44.476]                         if (!is.null(pattern)) {
[08:26:44.476]                           computeRestarts <- base::computeRestarts
[08:26:44.476]                           grepl <- base::grepl
[08:26:44.476]                           restarts <- computeRestarts(cond)
[08:26:44.476]                           for (restart in restarts) {
[08:26:44.476]                             name <- restart$name
[08:26:44.476]                             if (is.null(name)) 
[08:26:44.476]                               next
[08:26:44.476]                             if (!grepl(pattern, name)) 
[08:26:44.476]                               next
[08:26:44.476]                             invokeRestart(restart)
[08:26:44.476]                             muffled <- TRUE
[08:26:44.476]                             break
[08:26:44.476]                           }
[08:26:44.476]                         }
[08:26:44.476]                       }
[08:26:44.476]                       invisible(muffled)
[08:26:44.476]                     }
[08:26:44.476]                     muffleCondition(cond, pattern = "^muffle")
[08:26:44.476]                   }
[08:26:44.476]                 }
[08:26:44.476]                 else {
[08:26:44.476]                   if (TRUE) {
[08:26:44.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:44.476]                     {
[08:26:44.476]                       inherits <- base::inherits
[08:26:44.476]                       invokeRestart <- base::invokeRestart
[08:26:44.476]                       is.null <- base::is.null
[08:26:44.476]                       muffled <- FALSE
[08:26:44.476]                       if (inherits(cond, "message")) {
[08:26:44.476]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:44.476]                         if (muffled) 
[08:26:44.476]                           invokeRestart("muffleMessage")
[08:26:44.476]                       }
[08:26:44.476]                       else if (inherits(cond, "warning")) {
[08:26:44.476]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:44.476]                         if (muffled) 
[08:26:44.476]                           invokeRestart("muffleWarning")
[08:26:44.476]                       }
[08:26:44.476]                       else if (inherits(cond, "condition")) {
[08:26:44.476]                         if (!is.null(pattern)) {
[08:26:44.476]                           computeRestarts <- base::computeRestarts
[08:26:44.476]                           grepl <- base::grepl
[08:26:44.476]                           restarts <- computeRestarts(cond)
[08:26:44.476]                           for (restart in restarts) {
[08:26:44.476]                             name <- restart$name
[08:26:44.476]                             if (is.null(name)) 
[08:26:44.476]                               next
[08:26:44.476]                             if (!grepl(pattern, name)) 
[08:26:44.476]                               next
[08:26:44.476]                             invokeRestart(restart)
[08:26:44.476]                             muffled <- TRUE
[08:26:44.476]                             break
[08:26:44.476]                           }
[08:26:44.476]                         }
[08:26:44.476]                       }
[08:26:44.476]                       invisible(muffled)
[08:26:44.476]                     }
[08:26:44.476]                     muffleCondition(cond, pattern = "^muffle")
[08:26:44.476]                   }
[08:26:44.476]                 }
[08:26:44.476]             }
[08:26:44.476]         }))
[08:26:44.476]     }, error = function(ex) {
[08:26:44.476]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:44.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:44.476]                 ...future.rng), started = ...future.startTime, 
[08:26:44.476]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:44.476]             version = "1.8"), class = "FutureResult")
[08:26:44.476]     }, finally = {
[08:26:44.476]         if (!identical(...future.workdir, getwd())) 
[08:26:44.476]             setwd(...future.workdir)
[08:26:44.476]         {
[08:26:44.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:44.476]                 ...future.oldOptions$nwarnings <- NULL
[08:26:44.476]             }
[08:26:44.476]             base::options(...future.oldOptions)
[08:26:44.476]             if (.Platform$OS.type == "windows") {
[08:26:44.476]                 old_names <- names(...future.oldEnvVars)
[08:26:44.476]                 envs <- base::Sys.getenv()
[08:26:44.476]                 names <- names(envs)
[08:26:44.476]                 common <- intersect(names, old_names)
[08:26:44.476]                 added <- setdiff(names, old_names)
[08:26:44.476]                 removed <- setdiff(old_names, names)
[08:26:44.476]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:44.476]                   envs[common]]
[08:26:44.476]                 NAMES <- toupper(changed)
[08:26:44.476]                 args <- list()
[08:26:44.476]                 for (kk in seq_along(NAMES)) {
[08:26:44.476]                   name <- changed[[kk]]
[08:26:44.476]                   NAME <- NAMES[[kk]]
[08:26:44.476]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:44.476]                     next
[08:26:44.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:44.476]                 }
[08:26:44.476]                 NAMES <- toupper(added)
[08:26:44.476]                 for (kk in seq_along(NAMES)) {
[08:26:44.476]                   name <- added[[kk]]
[08:26:44.476]                   NAME <- NAMES[[kk]]
[08:26:44.476]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:44.476]                     next
[08:26:44.476]                   args[[name]] <- ""
[08:26:44.476]                 }
[08:26:44.476]                 NAMES <- toupper(removed)
[08:26:44.476]                 for (kk in seq_along(NAMES)) {
[08:26:44.476]                   name <- removed[[kk]]
[08:26:44.476]                   NAME <- NAMES[[kk]]
[08:26:44.476]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:44.476]                     next
[08:26:44.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:44.476]                 }
[08:26:44.476]                 if (length(args) > 0) 
[08:26:44.476]                   base::do.call(base::Sys.setenv, args = args)
[08:26:44.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:44.476]             }
[08:26:44.476]             else {
[08:26:44.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:44.476]             }
[08:26:44.476]             {
[08:26:44.476]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:44.476]                   0L) {
[08:26:44.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:44.476]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:44.476]                   base::options(opts)
[08:26:44.476]                 }
[08:26:44.476]                 {
[08:26:44.476]                   {
[08:26:44.476]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:44.476]                     NULL
[08:26:44.476]                   }
[08:26:44.476]                   options(future.plan = NULL)
[08:26:44.476]                   if (is.na(NA_character_)) 
[08:26:44.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:44.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:44.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:44.476]                     .init = FALSE)
[08:26:44.476]                 }
[08:26:44.476]             }
[08:26:44.476]         }
[08:26:44.476]     })
[08:26:44.476]     if (TRUE) {
[08:26:44.476]         base::sink(type = "output", split = FALSE)
[08:26:44.476]         if (FALSE) {
[08:26:44.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:44.476]         }
[08:26:44.476]         else {
[08:26:44.476]             ...future.result["stdout"] <- base::list(NULL)
[08:26:44.476]         }
[08:26:44.476]         base::close(...future.stdout)
[08:26:44.476]         ...future.stdout <- NULL
[08:26:44.476]     }
[08:26:44.476]     ...future.result$conditions <- ...future.conditions
[08:26:44.476]     ...future.result$finished <- base::Sys.time()
[08:26:44.476]     ...future.result
[08:26:44.476] }
[08:26:44.479] assign_globals() ...
[08:26:44.479] List of 5
[08:26:44.479]  $ ...future.FUN            :function (x, y)  
[08:26:44.479]  $ MoreArgs                 : NULL
[08:26:44.479]  $ ...future.elements_ii    :List of 2
[08:26:44.479]   ..$ :List of 1
[08:26:44.479]   .. ..$ : int 0
[08:26:44.479]   ..$ :List of 1
[08:26:44.479]   .. ..$ : int 1
[08:26:44.479]  $ ...future.seeds_ii       : NULL
[08:26:44.479]  $ ...future.globals.maxSize: NULL
[08:26:44.479]  - attr(*, "where")=List of 5
[08:26:44.479]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:44.479]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:44.479]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:44.479]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:44.479]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:44.479]  - attr(*, "resolved")= logi FALSE
[08:26:44.479]  - attr(*, "total_size")= num 1218
[08:26:44.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:44.479]  - attr(*, "already-done")= logi TRUE
[08:26:44.487] - reassign environment for ‘...future.FUN’
[08:26:44.487] - copied ‘...future.FUN’ to environment
[08:26:44.487] - copied ‘MoreArgs’ to environment
[08:26:44.487] - copied ‘...future.elements_ii’ to environment
[08:26:44.487] - copied ‘...future.seeds_ii’ to environment
[08:26:44.487] - copied ‘...future.globals.maxSize’ to environment
[08:26:44.488] assign_globals() ... done
[08:26:44.488] requestCore(): workers = 2
[08:26:44.491] MulticoreFuture started
[08:26:44.491] - Launch lazy future ... done
[08:26:44.491] run() for ‘MulticoreFuture’ ... done
[08:26:44.492] Created future:
[08:26:44.492] plan(): Setting new future strategy stack:
[08:26:44.492] List of future strategies:
[08:26:44.492] 1. sequential:
[08:26:44.492]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:44.492]    - tweaked: FALSE
[08:26:44.492]    - call: NULL
[08:26:44.493] plan(): nbrOfWorkers() = 1
[08:26:44.495] plan(): Setting new future strategy stack:
[08:26:44.496] List of future strategies:
[08:26:44.496] 1. multicore:
[08:26:44.496]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:44.496]    - tweaked: FALSE
[08:26:44.496]    - call: plan(strategy)
[08:26:44.499] plan(): nbrOfWorkers() = 2
[08:26:44.492] MulticoreFuture:
[08:26:44.492] Label: ‘future_mapply-2’
[08:26:44.492] Expression:
[08:26:44.492] {
[08:26:44.492]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:44.492]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:44.492]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:44.492]         on.exit(options(oopts), add = TRUE)
[08:26:44.492]     }
[08:26:44.492]     {
[08:26:44.492]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:44.492]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:44.492]         do.call(mapply, args = args)
[08:26:44.492]     }
[08:26:44.492] }
[08:26:44.492] Lazy evaluation: FALSE
[08:26:44.492] Asynchronous evaluation: TRUE
[08:26:44.492] Local evaluation: TRUE
[08:26:44.492] Environment: R_GlobalEnv
[08:26:44.492] Capture standard output: FALSE
[08:26:44.492] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:44.492] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:44.492] Packages: <none>
[08:26:44.492] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:44.492] Resolved: TRUE
[08:26:44.492] Value: <not collected>
[08:26:44.492] Conditions captured: <none>
[08:26:44.492] Early signaling: FALSE
[08:26:44.492] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:44.492] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:44.501] Chunk #2 of 2 ... DONE
[08:26:44.501] Launching 2 futures (chunks) ... DONE
[08:26:44.501] Resolving 2 futures (chunks) ...
[08:26:44.501] resolve() on list ...
[08:26:44.501]  recursive: 0
[08:26:44.502]  length: 2
[08:26:44.502] 
[08:26:44.513] Future #2
[08:26:44.513] result() for MulticoreFuture ...
[08:26:44.514] result() for MulticoreFuture ...
[08:26:44.514] result() for MulticoreFuture ... done
[08:26:44.514] result() for MulticoreFuture ... done
[08:26:44.515] result() for MulticoreFuture ...
[08:26:44.515] result() for MulticoreFuture ... done
[08:26:44.515] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:44.515] - nx: 2
[08:26:44.515] - relay: TRUE
[08:26:44.515] - stdout: TRUE
[08:26:44.516] - signal: TRUE
[08:26:44.516] - resignal: FALSE
[08:26:44.516] - force: TRUE
[08:26:44.516] - relayed: [n=2] FALSE, FALSE
[08:26:44.516] - queued futures: [n=2] FALSE, FALSE
[08:26:44.516]  - until=1
[08:26:44.516]  - relaying element #1
[08:26:44.517] - relayed: [n=2] FALSE, FALSE
[08:26:44.517] - queued futures: [n=2] FALSE, TRUE
[08:26:44.517] signalConditionsASAP(NULL, pos=2) ... done
[08:26:44.517]  length: 1 (resolved future 2)
[08:26:44.946] plan(): Setting new future strategy stack:
[08:26:44.946] List of future strategies:
[08:26:44.946] 1. multicore:
[08:26:44.946]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:44.946]    - tweaked: FALSE
[08:26:44.946]    - call: plan(strategy)
[08:26:44.950] plan(): nbrOfWorkers() = 2
[08:26:44.958] Future #1
[08:26:44.961] result() for MulticoreFuture ...
[08:26:44.962] result() for MulticoreFuture ...
[08:26:44.962] result() for MulticoreFuture ... done
[08:26:44.963] result() for MulticoreFuture ... done
[08:26:44.963] result() for MulticoreFuture ...
[08:26:44.963] result() for MulticoreFuture ... done
[08:26:44.963] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:44.963] - nx: 2
[08:26:44.964] - relay: TRUE
[08:26:44.964] - stdout: TRUE
[08:26:44.964] - signal: TRUE
[08:26:44.964] - resignal: FALSE
[08:26:44.964] - force: TRUE
[08:26:44.964] - relayed: [n=2] FALSE, FALSE
[08:26:44.965] - queued futures: [n=2] FALSE, TRUE
[08:26:44.965]  - until=1
[08:26:44.965]  - relaying element #1
[08:26:44.965] result() for MulticoreFuture ...
[08:26:44.965] result() for MulticoreFuture ... done
[08:26:44.965] result() for MulticoreFuture ...
[08:26:44.966] result() for MulticoreFuture ... done
[08:26:44.966] result() for MulticoreFuture ...
[08:26:44.966] result() for MulticoreFuture ... done
[08:26:44.966] result() for MulticoreFuture ...
[08:26:44.966] result() for MulticoreFuture ... done
[08:26:44.966] - relayed: [n=2] TRUE, FALSE
[08:26:44.966] - queued futures: [n=2] TRUE, TRUE
[08:26:44.966] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:44.967]  length: 0 (resolved future 1)
[08:26:44.967] Relaying remaining futures
[08:26:44.967] signalConditionsASAP(NULL, pos=0) ...
[08:26:44.967] - nx: 2
[08:26:44.967] - relay: TRUE
[08:26:44.967] - stdout: TRUE
[08:26:44.967] - signal: TRUE
[08:26:44.967] - resignal: FALSE
[08:26:44.967] - force: TRUE
[08:26:44.967] - relayed: [n=2] TRUE, FALSE
[08:26:44.968] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:44.968]  - relaying element #2
[08:26:44.968] result() for MulticoreFuture ...
[08:26:44.968] result() for MulticoreFuture ... done
[08:26:44.968] result() for MulticoreFuture ...
[08:26:44.968] result() for MulticoreFuture ... done
[08:26:44.968] result() for MulticoreFuture ...
[08:26:44.968] result() for MulticoreFuture ... done
[08:26:44.969] result() for MulticoreFuture ...
[08:26:44.969] result() for MulticoreFuture ... done
[08:26:44.969] - relayed: [n=2] TRUE, TRUE
[08:26:44.969] - queued futures: [n=2] TRUE, TRUE
[08:26:44.969] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[08:26:44.969] resolve() on list ... DONE
[08:26:44.969] result() for MulticoreFuture ...
[08:26:44.969] result() for MulticoreFuture ... done
[08:26:44.969] result() for MulticoreFuture ...
[08:26:44.970] result() for MulticoreFuture ... done
[08:26:44.970] result() for MulticoreFuture ...
[08:26:44.970] result() for MulticoreFuture ... done
[08:26:44.970] result() for MulticoreFuture ...
[08:26:44.970] result() for MulticoreFuture ... done
[08:26:44.970]  - Number of value chunks collected: 2
[08:26:44.970] Resolving 2 futures (chunks) ... DONE
[08:26:44.970] Reducing values from 2 chunks ...
[08:26:44.970]  - Number of values collected after concatenation: 2
[08:26:44.971]  - Number of values expected: 2
[08:26:44.971] Reducing values from 2 chunks ... DONE
[08:26:44.971] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[08:26:44.971] future_mapply() ...
[08:26:44.973] Number of chunks: 2
[08:26:44.974] getGlobalsAndPackagesXApply() ...
[08:26:44.974]  - future.globals: TRUE
[08:26:44.974] getGlobalsAndPackages() ...
[08:26:44.974] Searching for globals...
[08:26:44.976] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:44.976] Searching for globals ... DONE
[08:26:44.976] Resolving globals: FALSE
[08:26:44.977] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:44.977] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:44.977] - globals: [1] ‘FUN’
[08:26:44.977] 
[08:26:44.977] getGlobalsAndPackages() ... DONE
[08:26:44.978]  - globals found/used: [n=1] ‘FUN’
[08:26:44.978]  - needed namespaces: [n=0] 
[08:26:44.978] Finding globals ... DONE
[08:26:44.978] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:44.978] List of 2
[08:26:44.978]  $ ...future.FUN:function (x, y)  
[08:26:44.978]  $ MoreArgs     : NULL
[08:26:44.978]  - attr(*, "where")=List of 2
[08:26:44.978]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:44.978]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:44.978]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:44.978]  - attr(*, "resolved")= logi FALSE
[08:26:44.978]  - attr(*, "total_size")= num NA
[08:26:44.981] Packages to be attached in all futures: [n=0] 
[08:26:44.981] getGlobalsAndPackagesXApply() ... DONE
[08:26:44.981] Number of futures (= number of chunks): 2
[08:26:44.981] Launching 2 futures (chunks) ...
[08:26:44.982] Chunk #1 of 2 ...
[08:26:44.982]  - Finding globals in '...' for chunk #1 ...
[08:26:44.982] getGlobalsAndPackages() ...
[08:26:44.982] Searching for globals...
[08:26:44.982] 
[08:26:44.982] Searching for globals ... DONE
[08:26:44.982] - globals: [0] <none>
[08:26:44.982] getGlobalsAndPackages() ... DONE
[08:26:44.983]    + additional globals found: [n=0] 
[08:26:44.983]    + additional namespaces needed: [n=0] 
[08:26:44.983]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:44.983]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:44.983]  - seeds: <none>
[08:26:44.983]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:44.983] getGlobalsAndPackages() ...
[08:26:44.983] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:44.983] Resolving globals: FALSE
[08:26:44.984] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:44.984] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:44.984] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:44.984] 
[08:26:44.985] getGlobalsAndPackages() ... DONE
[08:26:44.985] run() for ‘Future’ ...
[08:26:44.985] - state: ‘created’
[08:26:44.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:44.987] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:44.987] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:44.987]   - Field: ‘label’
[08:26:44.987]   - Field: ‘local’
[08:26:44.987]   - Field: ‘owner’
[08:26:44.987]   - Field: ‘envir’
[08:26:44.989]   - Field: ‘workers’
[08:26:44.990]   - Field: ‘packages’
[08:26:44.990]   - Field: ‘gc’
[08:26:44.990]   - Field: ‘job’
[08:26:44.990]   - Field: ‘conditions’
[08:26:44.990]   - Field: ‘expr’
[08:26:44.990]   - Field: ‘uuid’
[08:26:44.990]   - Field: ‘seed’
[08:26:44.990]   - Field: ‘version’
[08:26:44.991]   - Field: ‘result’
[08:26:44.991]   - Field: ‘asynchronous’
[08:26:44.991]   - Field: ‘calls’
[08:26:44.991]   - Field: ‘globals’
[08:26:44.991]   - Field: ‘stdout’
[08:26:44.991]   - Field: ‘earlySignal’
[08:26:44.991]   - Field: ‘lazy’
[08:26:44.991]   - Field: ‘state’
[08:26:44.991] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:44.992] - Launch lazy future ...
[08:26:44.992] Packages needed by the future expression (n = 0): <none>
[08:26:44.992] Packages needed by future strategies (n = 0): <none>
[08:26:44.993] {
[08:26:44.993]     {
[08:26:44.993]         {
[08:26:44.993]             ...future.startTime <- base::Sys.time()
[08:26:44.993]             {
[08:26:44.993]                 {
[08:26:44.993]                   {
[08:26:44.993]                     {
[08:26:44.993]                       base::local({
[08:26:44.993]                         has_future <- base::requireNamespace("future", 
[08:26:44.993]                           quietly = TRUE)
[08:26:44.993]                         if (has_future) {
[08:26:44.993]                           ns <- base::getNamespace("future")
[08:26:44.993]                           version <- ns[[".package"]][["version"]]
[08:26:44.993]                           if (is.null(version)) 
[08:26:44.993]                             version <- utils::packageVersion("future")
[08:26:44.993]                         }
[08:26:44.993]                         else {
[08:26:44.993]                           version <- NULL
[08:26:44.993]                         }
[08:26:44.993]                         if (!has_future || version < "1.8.0") {
[08:26:44.993]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:44.993]                             "", base::R.version$version.string), 
[08:26:44.993]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:44.993]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:44.993]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:44.993]                               "release", "version")], collapse = " "), 
[08:26:44.993]                             hostname = base::Sys.info()[["nodename"]])
[08:26:44.993]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:44.993]                             info)
[08:26:44.993]                           info <- base::paste(info, collapse = "; ")
[08:26:44.993]                           if (!has_future) {
[08:26:44.993]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:44.993]                               info)
[08:26:44.993]                           }
[08:26:44.993]                           else {
[08:26:44.993]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:44.993]                               info, version)
[08:26:44.993]                           }
[08:26:44.993]                           base::stop(msg)
[08:26:44.993]                         }
[08:26:44.993]                       })
[08:26:44.993]                     }
[08:26:44.993]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:44.993]                     base::options(mc.cores = 1L)
[08:26:44.993]                   }
[08:26:44.993]                   ...future.strategy.old <- future::plan("list")
[08:26:44.993]                   options(future.plan = NULL)
[08:26:44.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:44.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:44.993]                 }
[08:26:44.993]                 ...future.workdir <- getwd()
[08:26:44.993]             }
[08:26:44.993]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:44.993]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:44.993]         }
[08:26:44.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:44.993]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:44.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:44.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:44.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:44.993]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:44.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:44.993]             base::names(...future.oldOptions))
[08:26:44.993]     }
[08:26:44.993]     if (FALSE) {
[08:26:44.993]     }
[08:26:44.993]     else {
[08:26:44.993]         if (TRUE) {
[08:26:44.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:44.993]                 open = "w")
[08:26:44.993]         }
[08:26:44.993]         else {
[08:26:44.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:44.993]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:44.993]         }
[08:26:44.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:44.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:44.993]             base::sink(type = "output", split = FALSE)
[08:26:44.993]             base::close(...future.stdout)
[08:26:44.993]         }, add = TRUE)
[08:26:44.993]     }
[08:26:44.993]     ...future.frame <- base::sys.nframe()
[08:26:44.993]     ...future.conditions <- base::list()
[08:26:44.993]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:44.993]     if (FALSE) {
[08:26:44.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:44.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:44.993]     }
[08:26:44.993]     ...future.result <- base::tryCatch({
[08:26:44.993]         base::withCallingHandlers({
[08:26:44.993]             ...future.value <- base::withVisible(base::local({
[08:26:44.993]                 withCallingHandlers({
[08:26:44.993]                   {
[08:26:44.993]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:44.993]                     if (!identical(...future.globals.maxSize.org, 
[08:26:44.993]                       ...future.globals.maxSize)) {
[08:26:44.993]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:44.993]                       on.exit(options(oopts), add = TRUE)
[08:26:44.993]                     }
[08:26:44.993]                     {
[08:26:44.993]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:44.993]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:44.993]                         USE.NAMES = FALSE)
[08:26:44.993]                       do.call(mapply, args = args)
[08:26:44.993]                     }
[08:26:44.993]                   }
[08:26:44.993]                 }, immediateCondition = function(cond) {
[08:26:44.993]                   save_rds <- function (object, pathname, ...) 
[08:26:44.993]                   {
[08:26:44.993]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:44.993]                     if (file_test("-f", pathname_tmp)) {
[08:26:44.993]                       fi_tmp <- file.info(pathname_tmp)
[08:26:44.993]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:44.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:44.993]                         fi_tmp[["mtime"]])
[08:26:44.993]                     }
[08:26:44.993]                     tryCatch({
[08:26:44.993]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:44.993]                     }, error = function(ex) {
[08:26:44.993]                       msg <- conditionMessage(ex)
[08:26:44.993]                       fi_tmp <- file.info(pathname_tmp)
[08:26:44.993]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:44.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:44.993]                         fi_tmp[["mtime"]], msg)
[08:26:44.993]                       ex$message <- msg
[08:26:44.993]                       stop(ex)
[08:26:44.993]                     })
[08:26:44.993]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:44.993]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:44.993]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:44.993]                       fi_tmp <- file.info(pathname_tmp)
[08:26:44.993]                       fi <- file.info(pathname)
[08:26:44.993]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:44.993]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:44.993]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:44.993]                         fi[["size"]], fi[["mtime"]])
[08:26:44.993]                       stop(msg)
[08:26:44.993]                     }
[08:26:44.993]                     invisible(pathname)
[08:26:44.993]                   }
[08:26:44.993]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:44.993]                     rootPath = tempdir()) 
[08:26:44.993]                   {
[08:26:44.993]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:44.993]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:44.993]                       tmpdir = path, fileext = ".rds")
[08:26:44.993]                     save_rds(obj, file)
[08:26:44.993]                   }
[08:26:44.993]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:44.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:44.993]                   {
[08:26:44.993]                     inherits <- base::inherits
[08:26:44.993]                     invokeRestart <- base::invokeRestart
[08:26:44.993]                     is.null <- base::is.null
[08:26:44.993]                     muffled <- FALSE
[08:26:44.993]                     if (inherits(cond, "message")) {
[08:26:44.993]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:44.993]                       if (muffled) 
[08:26:44.993]                         invokeRestart("muffleMessage")
[08:26:44.993]                     }
[08:26:44.993]                     else if (inherits(cond, "warning")) {
[08:26:44.993]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:44.993]                       if (muffled) 
[08:26:44.993]                         invokeRestart("muffleWarning")
[08:26:44.993]                     }
[08:26:44.993]                     else if (inherits(cond, "condition")) {
[08:26:44.993]                       if (!is.null(pattern)) {
[08:26:44.993]                         computeRestarts <- base::computeRestarts
[08:26:44.993]                         grepl <- base::grepl
[08:26:44.993]                         restarts <- computeRestarts(cond)
[08:26:44.993]                         for (restart in restarts) {
[08:26:44.993]                           name <- restart$name
[08:26:44.993]                           if (is.null(name)) 
[08:26:44.993]                             next
[08:26:44.993]                           if (!grepl(pattern, name)) 
[08:26:44.993]                             next
[08:26:44.993]                           invokeRestart(restart)
[08:26:44.993]                           muffled <- TRUE
[08:26:44.993]                           break
[08:26:44.993]                         }
[08:26:44.993]                       }
[08:26:44.993]                     }
[08:26:44.993]                     invisible(muffled)
[08:26:44.993]                   }
[08:26:44.993]                   muffleCondition(cond)
[08:26:44.993]                 })
[08:26:44.993]             }))
[08:26:44.993]             future::FutureResult(value = ...future.value$value, 
[08:26:44.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:44.993]                   ...future.rng), globalenv = if (FALSE) 
[08:26:44.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:44.993]                     ...future.globalenv.names))
[08:26:44.993]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:44.993]         }, condition = base::local({
[08:26:44.993]             c <- base::c
[08:26:44.993]             inherits <- base::inherits
[08:26:44.993]             invokeRestart <- base::invokeRestart
[08:26:44.993]             length <- base::length
[08:26:44.993]             list <- base::list
[08:26:44.993]             seq.int <- base::seq.int
[08:26:44.993]             signalCondition <- base::signalCondition
[08:26:44.993]             sys.calls <- base::sys.calls
[08:26:44.993]             `[[` <- base::`[[`
[08:26:44.993]             `+` <- base::`+`
[08:26:44.993]             `<<-` <- base::`<<-`
[08:26:44.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:44.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:44.993]                   3L)]
[08:26:44.993]             }
[08:26:44.993]             function(cond) {
[08:26:44.993]                 is_error <- inherits(cond, "error")
[08:26:44.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:44.993]                   NULL)
[08:26:44.993]                 if (is_error) {
[08:26:44.993]                   sessionInformation <- function() {
[08:26:44.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:44.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:44.993]                       search = base::search(), system = base::Sys.info())
[08:26:44.993]                   }
[08:26:44.993]                   ...future.conditions[[length(...future.conditions) + 
[08:26:44.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:44.993]                     cond$call), session = sessionInformation(), 
[08:26:44.993]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:44.993]                   signalCondition(cond)
[08:26:44.993]                 }
[08:26:44.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:44.993]                 "immediateCondition"))) {
[08:26:44.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:44.993]                   ...future.conditions[[length(...future.conditions) + 
[08:26:44.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:44.993]                   if (TRUE && !signal) {
[08:26:44.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:44.993]                     {
[08:26:44.993]                       inherits <- base::inherits
[08:26:44.993]                       invokeRestart <- base::invokeRestart
[08:26:44.993]                       is.null <- base::is.null
[08:26:44.993]                       muffled <- FALSE
[08:26:44.993]                       if (inherits(cond, "message")) {
[08:26:44.993]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:44.993]                         if (muffled) 
[08:26:44.993]                           invokeRestart("muffleMessage")
[08:26:44.993]                       }
[08:26:44.993]                       else if (inherits(cond, "warning")) {
[08:26:44.993]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:44.993]                         if (muffled) 
[08:26:44.993]                           invokeRestart("muffleWarning")
[08:26:44.993]                       }
[08:26:44.993]                       else if (inherits(cond, "condition")) {
[08:26:44.993]                         if (!is.null(pattern)) {
[08:26:44.993]                           computeRestarts <- base::computeRestarts
[08:26:44.993]                           grepl <- base::grepl
[08:26:44.993]                           restarts <- computeRestarts(cond)
[08:26:44.993]                           for (restart in restarts) {
[08:26:44.993]                             name <- restart$name
[08:26:44.993]                             if (is.null(name)) 
[08:26:44.993]                               next
[08:26:44.993]                             if (!grepl(pattern, name)) 
[08:26:44.993]                               next
[08:26:44.993]                             invokeRestart(restart)
[08:26:44.993]                             muffled <- TRUE
[08:26:44.993]                             break
[08:26:44.993]                           }
[08:26:44.993]                         }
[08:26:44.993]                       }
[08:26:44.993]                       invisible(muffled)
[08:26:44.993]                     }
[08:26:44.993]                     muffleCondition(cond, pattern = "^muffle")
[08:26:44.993]                   }
[08:26:44.993]                 }
[08:26:44.993]                 else {
[08:26:44.993]                   if (TRUE) {
[08:26:44.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:44.993]                     {
[08:26:44.993]                       inherits <- base::inherits
[08:26:44.993]                       invokeRestart <- base::invokeRestart
[08:26:44.993]                       is.null <- base::is.null
[08:26:44.993]                       muffled <- FALSE
[08:26:44.993]                       if (inherits(cond, "message")) {
[08:26:44.993]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:44.993]                         if (muffled) 
[08:26:44.993]                           invokeRestart("muffleMessage")
[08:26:44.993]                       }
[08:26:44.993]                       else if (inherits(cond, "warning")) {
[08:26:44.993]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:44.993]                         if (muffled) 
[08:26:44.993]                           invokeRestart("muffleWarning")
[08:26:44.993]                       }
[08:26:44.993]                       else if (inherits(cond, "condition")) {
[08:26:44.993]                         if (!is.null(pattern)) {
[08:26:44.993]                           computeRestarts <- base::computeRestarts
[08:26:44.993]                           grepl <- base::grepl
[08:26:44.993]                           restarts <- computeRestarts(cond)
[08:26:44.993]                           for (restart in restarts) {
[08:26:44.993]                             name <- restart$name
[08:26:44.993]                             if (is.null(name)) 
[08:26:44.993]                               next
[08:26:44.993]                             if (!grepl(pattern, name)) 
[08:26:44.993]                               next
[08:26:44.993]                             invokeRestart(restart)
[08:26:44.993]                             muffled <- TRUE
[08:26:44.993]                             break
[08:26:44.993]                           }
[08:26:44.993]                         }
[08:26:44.993]                       }
[08:26:44.993]                       invisible(muffled)
[08:26:44.993]                     }
[08:26:44.993]                     muffleCondition(cond, pattern = "^muffle")
[08:26:44.993]                   }
[08:26:44.993]                 }
[08:26:44.993]             }
[08:26:44.993]         }))
[08:26:44.993]     }, error = function(ex) {
[08:26:44.993]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:44.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:44.993]                 ...future.rng), started = ...future.startTime, 
[08:26:44.993]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:44.993]             version = "1.8"), class = "FutureResult")
[08:26:44.993]     }, finally = {
[08:26:44.993]         if (!identical(...future.workdir, getwd())) 
[08:26:44.993]             setwd(...future.workdir)
[08:26:44.993]         {
[08:26:44.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:44.993]                 ...future.oldOptions$nwarnings <- NULL
[08:26:44.993]             }
[08:26:44.993]             base::options(...future.oldOptions)
[08:26:44.993]             if (.Platform$OS.type == "windows") {
[08:26:44.993]                 old_names <- names(...future.oldEnvVars)
[08:26:44.993]                 envs <- base::Sys.getenv()
[08:26:44.993]                 names <- names(envs)
[08:26:44.993]                 common <- intersect(names, old_names)
[08:26:44.993]                 added <- setdiff(names, old_names)
[08:26:44.993]                 removed <- setdiff(old_names, names)
[08:26:44.993]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:44.993]                   envs[common]]
[08:26:44.993]                 NAMES <- toupper(changed)
[08:26:44.993]                 args <- list()
[08:26:44.993]                 for (kk in seq_along(NAMES)) {
[08:26:44.993]                   name <- changed[[kk]]
[08:26:44.993]                   NAME <- NAMES[[kk]]
[08:26:44.993]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:44.993]                     next
[08:26:44.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:44.993]                 }
[08:26:44.993]                 NAMES <- toupper(added)
[08:26:44.993]                 for (kk in seq_along(NAMES)) {
[08:26:44.993]                   name <- added[[kk]]
[08:26:44.993]                   NAME <- NAMES[[kk]]
[08:26:44.993]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:44.993]                     next
[08:26:44.993]                   args[[name]] <- ""
[08:26:44.993]                 }
[08:26:44.993]                 NAMES <- toupper(removed)
[08:26:44.993]                 for (kk in seq_along(NAMES)) {
[08:26:44.993]                   name <- removed[[kk]]
[08:26:44.993]                   NAME <- NAMES[[kk]]
[08:26:44.993]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:44.993]                     next
[08:26:44.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:44.993]                 }
[08:26:44.993]                 if (length(args) > 0) 
[08:26:44.993]                   base::do.call(base::Sys.setenv, args = args)
[08:26:44.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:44.993]             }
[08:26:44.993]             else {
[08:26:44.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:44.993]             }
[08:26:44.993]             {
[08:26:44.993]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:44.993]                   0L) {
[08:26:44.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:44.993]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:44.993]                   base::options(opts)
[08:26:44.993]                 }
[08:26:44.993]                 {
[08:26:44.993]                   {
[08:26:44.993]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:44.993]                     NULL
[08:26:44.993]                   }
[08:26:44.993]                   options(future.plan = NULL)
[08:26:44.993]                   if (is.na(NA_character_)) 
[08:26:44.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:44.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:44.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:44.993]                     .init = FALSE)
[08:26:44.993]                 }
[08:26:44.993]             }
[08:26:44.993]         }
[08:26:44.993]     })
[08:26:44.993]     if (TRUE) {
[08:26:44.993]         base::sink(type = "output", split = FALSE)
[08:26:44.993]         if (TRUE) {
[08:26:44.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:44.993]         }
[08:26:44.993]         else {
[08:26:44.993]             ...future.result["stdout"] <- base::list(NULL)
[08:26:44.993]         }
[08:26:44.993]         base::close(...future.stdout)
[08:26:44.993]         ...future.stdout <- NULL
[08:26:44.993]     }
[08:26:44.993]     ...future.result$conditions <- ...future.conditions
[08:26:44.993]     ...future.result$finished <- base::Sys.time()
[08:26:44.993]     ...future.result
[08:26:44.993] }
[08:26:44.995] assign_globals() ...
[08:26:44.995] List of 5
[08:26:44.995]  $ ...future.FUN            :function (x, y)  
[08:26:44.995]  $ MoreArgs                 : NULL
[08:26:44.995]  $ ...future.elements_ii    :List of 2
[08:26:44.995]   ..$ :List of 1
[08:26:44.995]   .. ..$ : int 1
[08:26:44.995]   ..$ :List of 1
[08:26:44.995]   .. ..$ : int 0
[08:26:44.995]  $ ...future.seeds_ii       : NULL
[08:26:44.995]  $ ...future.globals.maxSize: NULL
[08:26:44.995]  - attr(*, "where")=List of 5
[08:26:44.995]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:44.995]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:44.995]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:44.995]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:44.995]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:44.995]  - attr(*, "resolved")= logi FALSE
[08:26:44.995]  - attr(*, "total_size")= num 1218
[08:26:44.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:44.995]  - attr(*, "already-done")= logi TRUE
[08:26:45.000] - reassign environment for ‘...future.FUN’
[08:26:45.000] - copied ‘...future.FUN’ to environment
[08:26:45.000] - copied ‘MoreArgs’ to environment
[08:26:45.001] - copied ‘...future.elements_ii’ to environment
[08:26:45.001] - copied ‘...future.seeds_ii’ to environment
[08:26:45.001] - copied ‘...future.globals.maxSize’ to environment
[08:26:45.001] assign_globals() ... done
[08:26:45.001] requestCore(): workers = 2
[08:26:45.003] MulticoreFuture started
[08:26:45.004] - Launch lazy future ... done
[08:26:45.004] run() for ‘MulticoreFuture’ ... done
[08:26:45.004] Created future:
[08:26:45.005] plan(): Setting new future strategy stack:
[08:26:45.005] List of future strategies:
[08:26:45.005] 1. sequential:
[08:26:45.005]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:45.005]    - tweaked: FALSE
[08:26:45.005]    - call: NULL
[08:26:45.006] plan(): nbrOfWorkers() = 1
[08:26:45.004] MulticoreFuture:
[08:26:45.004] Label: ‘future_mapply-1’
[08:26:45.004] Expression:
[08:26:45.004] {
[08:26:45.004]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:45.004]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:45.004]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:45.004]         on.exit(options(oopts), add = TRUE)
[08:26:45.004]     }
[08:26:45.004]     {
[08:26:45.004]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:45.004]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:45.004]         do.call(mapply, args = args)
[08:26:45.004]     }
[08:26:45.004] }
[08:26:45.004] Lazy evaluation: FALSE
[08:26:45.004] Asynchronous evaluation: TRUE
[08:26:45.004] Local evaluation: TRUE
[08:26:45.004] Environment: R_GlobalEnv
[08:26:45.004] Capture standard output: TRUE
[08:26:45.004] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:45.004] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:45.004] Packages: <none>
[08:26:45.004] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:45.004] Resolved: FALSE
[08:26:45.004] Value: <not collected>
[08:26:45.004] Conditions captured: <none>
[08:26:45.004] Early signaling: FALSE
[08:26:45.004] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:45.004] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:45.017] Chunk #1 of 2 ... DONE
[08:26:45.017] Chunk #2 of 2 ...
[08:26:45.017]  - Finding globals in '...' for chunk #2 ...
[08:26:45.018] getGlobalsAndPackages() ...
[08:26:45.018] Searching for globals...
[08:26:45.018] 
[08:26:45.019] Searching for globals ... DONE
[08:26:45.019] - globals: [0] <none>
[08:26:45.019] getGlobalsAndPackages() ... DONE
[08:26:45.019]    + additional globals found: [n=0] 
[08:26:45.019]    + additional namespaces needed: [n=0] 
[08:26:45.019]  - Finding globals in '...' for chunk #2 ... DONE
[08:26:45.020]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:45.020]  - seeds: <none>
[08:26:45.020]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:45.020] getGlobalsAndPackages() ...
[08:26:45.020] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:45.020] Resolving globals: FALSE
[08:26:45.021] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:45.022] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:45.022] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:45.023] 
[08:26:45.023] getGlobalsAndPackages() ... DONE
[08:26:45.023] run() for ‘Future’ ...
[08:26:45.024] - state: ‘created’
[08:26:45.024] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:45.027] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:45.027] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:45.027]   - Field: ‘label’
[08:26:45.027]   - Field: ‘local’
[08:26:45.028]   - Field: ‘owner’
[08:26:45.028]   - Field: ‘envir’
[08:26:45.028]   - Field: ‘workers’
[08:26:45.028]   - Field: ‘packages’
[08:26:45.028]   - Field: ‘gc’
[08:26:45.028]   - Field: ‘job’
[08:26:45.028]   - Field: ‘conditions’
[08:26:45.029]   - Field: ‘expr’
[08:26:45.029]   - Field: ‘uuid’
[08:26:45.029]   - Field: ‘seed’
[08:26:45.029]   - Field: ‘version’
[08:26:45.029]   - Field: ‘result’
[08:26:45.029]   - Field: ‘asynchronous’
[08:26:45.030]   - Field: ‘calls’
[08:26:45.030]   - Field: ‘globals’
[08:26:45.030]   - Field: ‘stdout’
[08:26:45.030]   - Field: ‘earlySignal’
[08:26:45.030]   - Field: ‘lazy’
[08:26:45.030]   - Field: ‘state’
[08:26:45.030] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:45.031] - Launch lazy future ...
[08:26:45.031] Packages needed by the future expression (n = 0): <none>
[08:26:45.031] Packages needed by future strategies (n = 0): <none>
[08:26:45.032] {
[08:26:45.032]     {
[08:26:45.032]         {
[08:26:45.032]             ...future.startTime <- base::Sys.time()
[08:26:45.032]             {
[08:26:45.032]                 {
[08:26:45.032]                   {
[08:26:45.032]                     {
[08:26:45.032]                       base::local({
[08:26:45.032]                         has_future <- base::requireNamespace("future", 
[08:26:45.032]                           quietly = TRUE)
[08:26:45.032]                         if (has_future) {
[08:26:45.032]                           ns <- base::getNamespace("future")
[08:26:45.032]                           version <- ns[[".package"]][["version"]]
[08:26:45.032]                           if (is.null(version)) 
[08:26:45.032]                             version <- utils::packageVersion("future")
[08:26:45.032]                         }
[08:26:45.032]                         else {
[08:26:45.032]                           version <- NULL
[08:26:45.032]                         }
[08:26:45.032]                         if (!has_future || version < "1.8.0") {
[08:26:45.032]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:45.032]                             "", base::R.version$version.string), 
[08:26:45.032]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:45.032]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:45.032]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:45.032]                               "release", "version")], collapse = " "), 
[08:26:45.032]                             hostname = base::Sys.info()[["nodename"]])
[08:26:45.032]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:45.032]                             info)
[08:26:45.032]                           info <- base::paste(info, collapse = "; ")
[08:26:45.032]                           if (!has_future) {
[08:26:45.032]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:45.032]                               info)
[08:26:45.032]                           }
[08:26:45.032]                           else {
[08:26:45.032]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:45.032]                               info, version)
[08:26:45.032]                           }
[08:26:45.032]                           base::stop(msg)
[08:26:45.032]                         }
[08:26:45.032]                       })
[08:26:45.032]                     }
[08:26:45.032]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:45.032]                     base::options(mc.cores = 1L)
[08:26:45.032]                   }
[08:26:45.032]                   ...future.strategy.old <- future::plan("list")
[08:26:45.032]                   options(future.plan = NULL)
[08:26:45.032]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:45.032]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:45.032]                 }
[08:26:45.032]                 ...future.workdir <- getwd()
[08:26:45.032]             }
[08:26:45.032]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:45.032]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:45.032]         }
[08:26:45.032]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:45.032]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:45.032]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:45.032]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:45.032]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:45.032]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:45.032]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:45.032]             base::names(...future.oldOptions))
[08:26:45.032]     }
[08:26:45.032]     if (FALSE) {
[08:26:45.032]     }
[08:26:45.032]     else {
[08:26:45.032]         if (TRUE) {
[08:26:45.032]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:45.032]                 open = "w")
[08:26:45.032]         }
[08:26:45.032]         else {
[08:26:45.032]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:45.032]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:45.032]         }
[08:26:45.032]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:45.032]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:45.032]             base::sink(type = "output", split = FALSE)
[08:26:45.032]             base::close(...future.stdout)
[08:26:45.032]         }, add = TRUE)
[08:26:45.032]     }
[08:26:45.032]     ...future.frame <- base::sys.nframe()
[08:26:45.032]     ...future.conditions <- base::list()
[08:26:45.032]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:45.032]     if (FALSE) {
[08:26:45.032]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:45.032]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:45.032]     }
[08:26:45.032]     ...future.result <- base::tryCatch({
[08:26:45.032]         base::withCallingHandlers({
[08:26:45.032]             ...future.value <- base::withVisible(base::local({
[08:26:45.032]                 withCallingHandlers({
[08:26:45.032]                   {
[08:26:45.032]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:45.032]                     if (!identical(...future.globals.maxSize.org, 
[08:26:45.032]                       ...future.globals.maxSize)) {
[08:26:45.032]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:45.032]                       on.exit(options(oopts), add = TRUE)
[08:26:45.032]                     }
[08:26:45.032]                     {
[08:26:45.032]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:45.032]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:45.032]                         USE.NAMES = FALSE)
[08:26:45.032]                       do.call(mapply, args = args)
[08:26:45.032]                     }
[08:26:45.032]                   }
[08:26:45.032]                 }, immediateCondition = function(cond) {
[08:26:45.032]                   save_rds <- function (object, pathname, ...) 
[08:26:45.032]                   {
[08:26:45.032]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:45.032]                     if (file_test("-f", pathname_tmp)) {
[08:26:45.032]                       fi_tmp <- file.info(pathname_tmp)
[08:26:45.032]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:45.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:45.032]                         fi_tmp[["mtime"]])
[08:26:45.032]                     }
[08:26:45.032]                     tryCatch({
[08:26:45.032]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:45.032]                     }, error = function(ex) {
[08:26:45.032]                       msg <- conditionMessage(ex)
[08:26:45.032]                       fi_tmp <- file.info(pathname_tmp)
[08:26:45.032]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:45.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:45.032]                         fi_tmp[["mtime"]], msg)
[08:26:45.032]                       ex$message <- msg
[08:26:45.032]                       stop(ex)
[08:26:45.032]                     })
[08:26:45.032]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:45.032]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:45.032]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:45.032]                       fi_tmp <- file.info(pathname_tmp)
[08:26:45.032]                       fi <- file.info(pathname)
[08:26:45.032]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:45.032]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:45.032]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:45.032]                         fi[["size"]], fi[["mtime"]])
[08:26:45.032]                       stop(msg)
[08:26:45.032]                     }
[08:26:45.032]                     invisible(pathname)
[08:26:45.032]                   }
[08:26:45.032]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:45.032]                     rootPath = tempdir()) 
[08:26:45.032]                   {
[08:26:45.032]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:45.032]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:45.032]                       tmpdir = path, fileext = ".rds")
[08:26:45.032]                     save_rds(obj, file)
[08:26:45.032]                   }
[08:26:45.032]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:45.032]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:45.032]                   {
[08:26:45.032]                     inherits <- base::inherits
[08:26:45.032]                     invokeRestart <- base::invokeRestart
[08:26:45.032]                     is.null <- base::is.null
[08:26:45.032]                     muffled <- FALSE
[08:26:45.032]                     if (inherits(cond, "message")) {
[08:26:45.032]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:45.032]                       if (muffled) 
[08:26:45.032]                         invokeRestart("muffleMessage")
[08:26:45.032]                     }
[08:26:45.032]                     else if (inherits(cond, "warning")) {
[08:26:45.032]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:45.032]                       if (muffled) 
[08:26:45.032]                         invokeRestart("muffleWarning")
[08:26:45.032]                     }
[08:26:45.032]                     else if (inherits(cond, "condition")) {
[08:26:45.032]                       if (!is.null(pattern)) {
[08:26:45.032]                         computeRestarts <- base::computeRestarts
[08:26:45.032]                         grepl <- base::grepl
[08:26:45.032]                         restarts <- computeRestarts(cond)
[08:26:45.032]                         for (restart in restarts) {
[08:26:45.032]                           name <- restart$name
[08:26:45.032]                           if (is.null(name)) 
[08:26:45.032]                             next
[08:26:45.032]                           if (!grepl(pattern, name)) 
[08:26:45.032]                             next
[08:26:45.032]                           invokeRestart(restart)
[08:26:45.032]                           muffled <- TRUE
[08:26:45.032]                           break
[08:26:45.032]                         }
[08:26:45.032]                       }
[08:26:45.032]                     }
[08:26:45.032]                     invisible(muffled)
[08:26:45.032]                   }
[08:26:45.032]                   muffleCondition(cond)
[08:26:45.032]                 })
[08:26:45.032]             }))
[08:26:45.032]             future::FutureResult(value = ...future.value$value, 
[08:26:45.032]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:45.032]                   ...future.rng), globalenv = if (FALSE) 
[08:26:45.032]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:45.032]                     ...future.globalenv.names))
[08:26:45.032]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:45.032]         }, condition = base::local({
[08:26:45.032]             c <- base::c
[08:26:45.032]             inherits <- base::inherits
[08:26:45.032]             invokeRestart <- base::invokeRestart
[08:26:45.032]             length <- base::length
[08:26:45.032]             list <- base::list
[08:26:45.032]             seq.int <- base::seq.int
[08:26:45.032]             signalCondition <- base::signalCondition
[08:26:45.032]             sys.calls <- base::sys.calls
[08:26:45.032]             `[[` <- base::`[[`
[08:26:45.032]             `+` <- base::`+`
[08:26:45.032]             `<<-` <- base::`<<-`
[08:26:45.032]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:45.032]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:45.032]                   3L)]
[08:26:45.032]             }
[08:26:45.032]             function(cond) {
[08:26:45.032]                 is_error <- inherits(cond, "error")
[08:26:45.032]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:45.032]                   NULL)
[08:26:45.032]                 if (is_error) {
[08:26:45.032]                   sessionInformation <- function() {
[08:26:45.032]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:45.032]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:45.032]                       search = base::search(), system = base::Sys.info())
[08:26:45.032]                   }
[08:26:45.032]                   ...future.conditions[[length(...future.conditions) + 
[08:26:45.032]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:45.032]                     cond$call), session = sessionInformation(), 
[08:26:45.032]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:45.032]                   signalCondition(cond)
[08:26:45.032]                 }
[08:26:45.032]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:45.032]                 "immediateCondition"))) {
[08:26:45.032]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:45.032]                   ...future.conditions[[length(...future.conditions) + 
[08:26:45.032]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:45.032]                   if (TRUE && !signal) {
[08:26:45.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:45.032]                     {
[08:26:45.032]                       inherits <- base::inherits
[08:26:45.032]                       invokeRestart <- base::invokeRestart
[08:26:45.032]                       is.null <- base::is.null
[08:26:45.032]                       muffled <- FALSE
[08:26:45.032]                       if (inherits(cond, "message")) {
[08:26:45.032]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:45.032]                         if (muffled) 
[08:26:45.032]                           invokeRestart("muffleMessage")
[08:26:45.032]                       }
[08:26:45.032]                       else if (inherits(cond, "warning")) {
[08:26:45.032]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:45.032]                         if (muffled) 
[08:26:45.032]                           invokeRestart("muffleWarning")
[08:26:45.032]                       }
[08:26:45.032]                       else if (inherits(cond, "condition")) {
[08:26:45.032]                         if (!is.null(pattern)) {
[08:26:45.032]                           computeRestarts <- base::computeRestarts
[08:26:45.032]                           grepl <- base::grepl
[08:26:45.032]                           restarts <- computeRestarts(cond)
[08:26:45.032]                           for (restart in restarts) {
[08:26:45.032]                             name <- restart$name
[08:26:45.032]                             if (is.null(name)) 
[08:26:45.032]                               next
[08:26:45.032]                             if (!grepl(pattern, name)) 
[08:26:45.032]                               next
[08:26:45.032]                             invokeRestart(restart)
[08:26:45.032]                             muffled <- TRUE
[08:26:45.032]                             break
[08:26:45.032]                           }
[08:26:45.032]                         }
[08:26:45.032]                       }
[08:26:45.032]                       invisible(muffled)
[08:26:45.032]                     }
[08:26:45.032]                     muffleCondition(cond, pattern = "^muffle")
[08:26:45.032]                   }
[08:26:45.032]                 }
[08:26:45.032]                 else {
[08:26:45.032]                   if (TRUE) {
[08:26:45.032]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:45.032]                     {
[08:26:45.032]                       inherits <- base::inherits
[08:26:45.032]                       invokeRestart <- base::invokeRestart
[08:26:45.032]                       is.null <- base::is.null
[08:26:45.032]                       muffled <- FALSE
[08:26:45.032]                       if (inherits(cond, "message")) {
[08:26:45.032]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:45.032]                         if (muffled) 
[08:26:45.032]                           invokeRestart("muffleMessage")
[08:26:45.032]                       }
[08:26:45.032]                       else if (inherits(cond, "warning")) {
[08:26:45.032]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:45.032]                         if (muffled) 
[08:26:45.032]                           invokeRestart("muffleWarning")
[08:26:45.032]                       }
[08:26:45.032]                       else if (inherits(cond, "condition")) {
[08:26:45.032]                         if (!is.null(pattern)) {
[08:26:45.032]                           computeRestarts <- base::computeRestarts
[08:26:45.032]                           grepl <- base::grepl
[08:26:45.032]                           restarts <- computeRestarts(cond)
[08:26:45.032]                           for (restart in restarts) {
[08:26:45.032]                             name <- restart$name
[08:26:45.032]                             if (is.null(name)) 
[08:26:45.032]                               next
[08:26:45.032]                             if (!grepl(pattern, name)) 
[08:26:45.032]                               next
[08:26:45.032]                             invokeRestart(restart)
[08:26:45.032]                             muffled <- TRUE
[08:26:45.032]                             break
[08:26:45.032]                           }
[08:26:45.032]                         }
[08:26:45.032]                       }
[08:26:45.032]                       invisible(muffled)
[08:26:45.032]                     }
[08:26:45.032]                     muffleCondition(cond, pattern = "^muffle")
[08:26:45.032]                   }
[08:26:45.032]                 }
[08:26:45.032]             }
[08:26:45.032]         }))
[08:26:45.032]     }, error = function(ex) {
[08:26:45.032]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:45.032]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:45.032]                 ...future.rng), started = ...future.startTime, 
[08:26:45.032]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:45.032]             version = "1.8"), class = "FutureResult")
[08:26:45.032]     }, finally = {
[08:26:45.032]         if (!identical(...future.workdir, getwd())) 
[08:26:45.032]             setwd(...future.workdir)
[08:26:45.032]         {
[08:26:45.032]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:45.032]                 ...future.oldOptions$nwarnings <- NULL
[08:26:45.032]             }
[08:26:45.032]             base::options(...future.oldOptions)
[08:26:45.032]             if (.Platform$OS.type == "windows") {
[08:26:45.032]                 old_names <- names(...future.oldEnvVars)
[08:26:45.032]                 envs <- base::Sys.getenv()
[08:26:45.032]                 names <- names(envs)
[08:26:45.032]                 common <- intersect(names, old_names)
[08:26:45.032]                 added <- setdiff(names, old_names)
[08:26:45.032]                 removed <- setdiff(old_names, names)
[08:26:45.032]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:45.032]                   envs[common]]
[08:26:45.032]                 NAMES <- toupper(changed)
[08:26:45.032]                 args <- list()
[08:26:45.032]                 for (kk in seq_along(NAMES)) {
[08:26:45.032]                   name <- changed[[kk]]
[08:26:45.032]                   NAME <- NAMES[[kk]]
[08:26:45.032]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:45.032]                     next
[08:26:45.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:45.032]                 }
[08:26:45.032]                 NAMES <- toupper(added)
[08:26:45.032]                 for (kk in seq_along(NAMES)) {
[08:26:45.032]                   name <- added[[kk]]
[08:26:45.032]                   NAME <- NAMES[[kk]]
[08:26:45.032]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:45.032]                     next
[08:26:45.032]                   args[[name]] <- ""
[08:26:45.032]                 }
[08:26:45.032]                 NAMES <- toupper(removed)
[08:26:45.032]                 for (kk in seq_along(NAMES)) {
[08:26:45.032]                   name <- removed[[kk]]
[08:26:45.032]                   NAME <- NAMES[[kk]]
[08:26:45.032]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:45.032]                     next
[08:26:45.032]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:45.032]                 }
[08:26:45.032]                 if (length(args) > 0) 
[08:26:45.032]                   base::do.call(base::Sys.setenv, args = args)
[08:26:45.032]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:45.032]             }
[08:26:45.032]             else {
[08:26:45.032]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:45.032]             }
[08:26:45.032]             {
[08:26:45.032]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:45.032]                   0L) {
[08:26:45.032]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:45.032]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:45.032]                   base::options(opts)
[08:26:45.032]                 }
[08:26:45.032]                 {
[08:26:45.032]                   {
[08:26:45.032]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:45.032]                     NULL
[08:26:45.032]                   }
[08:26:45.032]                   options(future.plan = NULL)
[08:26:45.032]                   if (is.na(NA_character_)) 
[08:26:45.032]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:45.032]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:45.032]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:45.032]                     .init = FALSE)
[08:26:45.032]                 }
[08:26:45.032]             }
[08:26:45.032]         }
[08:26:45.032]     })
[08:26:45.032]     if (TRUE) {
[08:26:45.032]         base::sink(type = "output", split = FALSE)
[08:26:45.032]         if (TRUE) {
[08:26:45.032]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:45.032]         }
[08:26:45.032]         else {
[08:26:45.032]             ...future.result["stdout"] <- base::list(NULL)
[08:26:45.032]         }
[08:26:45.032]         base::close(...future.stdout)
[08:26:45.032]         ...future.stdout <- NULL
[08:26:45.032]     }
[08:26:45.032]     ...future.result$conditions <- ...future.conditions
[08:26:45.032]     ...future.result$finished <- base::Sys.time()
[08:26:45.032]     ...future.result
[08:26:45.032] }
[08:26:45.035] assign_globals() ...
[08:26:45.036] List of 5
[08:26:45.036]  $ ...future.FUN            :function (x, y)  
[08:26:45.036]  $ MoreArgs                 : NULL
[08:26:45.036]  $ ...future.elements_ii    :List of 2
[08:26:45.036]   ..$ :List of 1
[08:26:45.036]   .. ..$ : int 0
[08:26:45.036]   ..$ :List of 1
[08:26:45.036]   .. ..$ : int 1
[08:26:45.036]  $ ...future.seeds_ii       : NULL
[08:26:45.036]  $ ...future.globals.maxSize: NULL
[08:26:45.036]  - attr(*, "where")=List of 5
[08:26:45.036]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:45.036]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:45.036]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:45.036]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:45.036]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:45.036]  - attr(*, "resolved")= logi FALSE
[08:26:45.036]  - attr(*, "total_size")= num 1218
[08:26:45.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:45.036]  - attr(*, "already-done")= logi TRUE
[08:26:45.050] - reassign environment for ‘...future.FUN’
[08:26:45.050] - copied ‘...future.FUN’ to environment
[08:26:45.050] - copied ‘MoreArgs’ to environment
[08:26:45.050] - copied ‘...future.elements_ii’ to environment
[08:26:45.050] - copied ‘...future.seeds_ii’ to environment
[08:26:45.051] - copied ‘...future.globals.maxSize’ to environment
[08:26:45.051] assign_globals() ... done
[08:26:45.051] requestCore(): workers = 2
[08:26:45.054] MulticoreFuture started
[08:26:45.054] - Launch lazy future ... done
[08:26:45.054] run() for ‘MulticoreFuture’ ... done
[08:26:45.055] Created future:
[08:26:45.055] plan(): Setting new future strategy stack:
[08:26:45.055] List of future strategies:
[08:26:45.055] 1. sequential:
[08:26:45.055]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:45.055]    - tweaked: FALSE
[08:26:45.055]    - call: NULL
[08:26:45.056] plan(): nbrOfWorkers() = 1
[08:26:45.058] plan(): Setting new future strategy stack:
[08:26:45.059] List of future strategies:
[08:26:45.059] 1. multicore:
[08:26:45.059]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:45.059]    - tweaked: FALSE
[08:26:45.059]    - call: plan(strategy)
[08:26:45.062] plan(): nbrOfWorkers() = 2
[08:26:45.055] MulticoreFuture:
[08:26:45.055] Label: ‘future_mapply-2’
[08:26:45.055] Expression:
[08:26:45.055] {
[08:26:45.055]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:45.055]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:45.055]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:45.055]         on.exit(options(oopts), add = TRUE)
[08:26:45.055]     }
[08:26:45.055]     {
[08:26:45.055]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:45.055]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:45.055]         do.call(mapply, args = args)
[08:26:45.055]     }
[08:26:45.055] }
[08:26:45.055] Lazy evaluation: FALSE
[08:26:45.055] Asynchronous evaluation: TRUE
[08:26:45.055] Local evaluation: TRUE
[08:26:45.055] Environment: R_GlobalEnv
[08:26:45.055] Capture standard output: TRUE
[08:26:45.055] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:45.055] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:45.055] Packages: <none>
[08:26:45.055] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:45.055] Resolved: TRUE
[08:26:45.055] Value: <not collected>
[08:26:45.055] Conditions captured: <none>
[08:26:45.055] Early signaling: FALSE
[08:26:45.055] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:45.055] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:45.063] Chunk #2 of 2 ... DONE
[08:26:45.064] Launching 2 futures (chunks) ... DONE
[08:26:45.064] Resolving 2 futures (chunks) ...
[08:26:45.064] resolve() on list ...
[08:26:45.064]  recursive: 0
[08:26:45.064]  length: 2
[08:26:45.064] 
[08:26:45.075] Future #2
[08:26:45.075] result() for MulticoreFuture ...
[08:26:45.077] result() for MulticoreFuture ...
[08:26:45.077] result() for MulticoreFuture ... done
[08:26:45.077] result() for MulticoreFuture ... done
[08:26:45.077] result() for MulticoreFuture ...
[08:26:45.077] result() for MulticoreFuture ... done
[08:26:45.077] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:45.078] - nx: 2
[08:26:45.078] - relay: TRUE
[08:26:45.078] - stdout: TRUE
[08:26:45.078] - signal: TRUE
[08:26:45.078] - resignal: FALSE
[08:26:45.078] - force: TRUE
[08:26:45.078] - relayed: [n=2] FALSE, FALSE
[08:26:45.079] - queued futures: [n=2] FALSE, FALSE
[08:26:45.079]  - until=1
[08:26:45.079]  - relaying element #1
[08:26:45.079] - relayed: [n=2] FALSE, FALSE
[08:26:45.079] - queued futures: [n=2] FALSE, TRUE
[08:26:45.079] signalConditionsASAP(NULL, pos=2) ... done
[08:26:45.080]  length: 1 (resolved future 2)
[08:26:45.509] plan(): Setting new future strategy stack:
[08:26:45.509] List of future strategies:
[08:26:45.509] 1. multicore:
[08:26:45.509]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:45.509]    - tweaked: FALSE
[08:26:45.509]    - call: plan(strategy)
[08:26:45.512] plan(): nbrOfWorkers() = 2
[08:26:45.521] Future #1
[08:26:45.521] result() for MulticoreFuture ...
[08:26:45.522] result() for MulticoreFuture ...
[08:26:45.522] result() for MulticoreFuture ... done
[08:26:45.522] result() for MulticoreFuture ... done
[08:26:45.522] result() for MulticoreFuture ...
[08:26:45.522] result() for MulticoreFuture ... done
[08:26:45.522] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:45.522] - nx: 2
[08:26:45.522] - relay: TRUE
[08:26:45.523] - stdout: TRUE
[08:26:45.523] - signal: TRUE
[08:26:45.523] - resignal: FALSE
[08:26:45.523] - force: TRUE
[08:26:45.523] - relayed: [n=2] FALSE, FALSE
[08:26:45.523] - queued futures: [n=2] FALSE, TRUE
[08:26:45.523]  - until=1
[08:26:45.523]  - relaying element #1
[08:26:45.523] result() for MulticoreFuture ...
[08:26:45.524] result() for MulticoreFuture ... done
[08:26:45.524] result() for MulticoreFuture ...
[08:26:45.524] result() for MulticoreFuture ... done
[08:26:45.524] result() for MulticoreFuture ...
[08:26:45.524] result() for MulticoreFuture ... done
[08:26:45.524] result() for MulticoreFuture ...
[08:26:45.524] result() for MulticoreFuture ... done
[08:26:45.524] - relayed: [n=2] TRUE, FALSE
[08:26:45.525] - queued futures: [n=2] TRUE, TRUE
[08:26:45.525] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:45.525]  length: 0 (resolved future 1)
[08:26:45.525] Relaying remaining futures
[08:26:45.525] signalConditionsASAP(NULL, pos=0) ...
[08:26:45.525] - nx: 2
[08:26:45.525] - relay: TRUE
[08:26:45.525] - stdout: TRUE
[08:26:45.526] - signal: TRUE
[08:26:45.526] - resignal: FALSE
[08:26:45.526] - force: TRUE
[08:26:45.526] - relayed: [n=2] TRUE, FALSE
[08:26:45.526] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:45.526]  - relaying element #2
[08:26:45.526] result() for MulticoreFuture ...
[08:26:45.526] result() for MulticoreFuture ... done
[08:26:45.527] result() for MulticoreFuture ...
[08:26:45.527] result() for MulticoreFuture ... done
[08:26:45.527] result() for MulticoreFuture ...
[08:26:45.527] result() for MulticoreFuture ... done
[08:26:45.527] result() for MulticoreFuture ...
[08:26:45.527] result() for MulticoreFuture ... done
[08:26:45.527] - relayed: [n=2] TRUE, TRUE
[08:26:45.527] - queued futures: [n=2] TRUE, TRUE
[08:26:45.528] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[08:26:45.528] resolve() on list ... DONE
[08:26:45.528] result() for MulticoreFuture ...
[08:26:45.528] result() for MulticoreFuture ... done
[08:26:45.528] result() for MulticoreFuture ...
[08:26:45.528] result() for MulticoreFuture ... done
[08:26:45.528] result() for MulticoreFuture ...
[08:26:45.528] result() for MulticoreFuture ... done
[08:26:45.528] result() for MulticoreFuture ...
[08:26:45.529] result() for MulticoreFuture ... done
[08:26:45.529]  - Number of value chunks collected: 2
[08:26:45.529] Resolving 2 futures (chunks) ... DONE
[08:26:45.529] Reducing values from 2 chunks ...
[08:26:45.529]  - Number of values collected after concatenation: 2
[08:26:45.529]  - Number of values expected: 2
[08:26:45.529] Reducing values from 2 chunks ... DONE
[08:26:45.529] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[08:26:45.530] future_mapply() ...
[08:26:45.532] Number of chunks: 2
[08:26:45.533] getGlobalsAndPackagesXApply() ...
[08:26:45.533]  - future.globals: TRUE
[08:26:45.533] getGlobalsAndPackages() ...
[08:26:45.533] Searching for globals...
[08:26:45.543] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:45.543] Searching for globals ... DONE
[08:26:45.543] Resolving globals: FALSE
[08:26:45.544] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:45.544] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:45.545] - globals: [1] ‘FUN’
[08:26:45.545] 
[08:26:45.545] getGlobalsAndPackages() ... DONE
[08:26:45.545]  - globals found/used: [n=1] ‘FUN’
[08:26:45.545]  - needed namespaces: [n=0] 
[08:26:45.545] Finding globals ... DONE
[08:26:45.546] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:45.546] List of 2
[08:26:45.546]  $ ...future.FUN:function (x, y)  
[08:26:45.546]  $ MoreArgs     : NULL
[08:26:45.546]  - attr(*, "where")=List of 2
[08:26:45.546]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:45.546]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:45.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:45.546]  - attr(*, "resolved")= logi FALSE
[08:26:45.546]  - attr(*, "total_size")= num NA
[08:26:45.549] Packages to be attached in all futures: [n=0] 
[08:26:45.549] getGlobalsAndPackagesXApply() ... DONE
[08:26:45.549] Number of futures (= number of chunks): 2
[08:26:45.549] Launching 2 futures (chunks) ...
[08:26:45.549] Chunk #1 of 2 ...
[08:26:45.550]  - Finding globals in '...' for chunk #1 ...
[08:26:45.550] getGlobalsAndPackages() ...
[08:26:45.550] Searching for globals...
[08:26:45.550] 
[08:26:45.550] Searching for globals ... DONE
[08:26:45.550] - globals: [0] <none>
[08:26:45.550] getGlobalsAndPackages() ... DONE
[08:26:45.551]    + additional globals found: [n=0] 
[08:26:45.551]    + additional namespaces needed: [n=0] 
[08:26:45.551]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:45.551]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:45.551]  - seeds: <none>
[08:26:45.551]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:45.551] getGlobalsAndPackages() ...
[08:26:45.551] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:45.551] Resolving globals: FALSE
[08:26:45.552] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:45.552] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:45.552] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:45.553] 
[08:26:45.553] getGlobalsAndPackages() ... DONE
[08:26:45.553] run() for ‘Future’ ...
[08:26:45.553] - state: ‘created’
[08:26:45.553] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:45.555] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:45.555] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:45.555]   - Field: ‘label’
[08:26:45.555]   - Field: ‘local’
[08:26:45.556]   - Field: ‘owner’
[08:26:45.556]   - Field: ‘envir’
[08:26:45.556]   - Field: ‘workers’
[08:26:45.556]   - Field: ‘packages’
[08:26:45.556]   - Field: ‘gc’
[08:26:45.556]   - Field: ‘job’
[08:26:45.556]   - Field: ‘conditions’
[08:26:45.556]   - Field: ‘expr’
[08:26:45.556]   - Field: ‘uuid’
[08:26:45.556]   - Field: ‘seed’
[08:26:45.556]   - Field: ‘version’
[08:26:45.557]   - Field: ‘result’
[08:26:45.557]   - Field: ‘asynchronous’
[08:26:45.557]   - Field: ‘calls’
[08:26:45.557]   - Field: ‘globals’
[08:26:45.557]   - Field: ‘stdout’
[08:26:45.557]   - Field: ‘earlySignal’
[08:26:45.557]   - Field: ‘lazy’
[08:26:45.557]   - Field: ‘state’
[08:26:45.557] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:45.557] - Launch lazy future ...
[08:26:45.558] Packages needed by the future expression (n = 0): <none>
[08:26:45.558] Packages needed by future strategies (n = 0): <none>
[08:26:45.558] {
[08:26:45.558]     {
[08:26:45.558]         {
[08:26:45.558]             ...future.startTime <- base::Sys.time()
[08:26:45.558]             {
[08:26:45.558]                 {
[08:26:45.558]                   {
[08:26:45.558]                     {
[08:26:45.558]                       base::local({
[08:26:45.558]                         has_future <- base::requireNamespace("future", 
[08:26:45.558]                           quietly = TRUE)
[08:26:45.558]                         if (has_future) {
[08:26:45.558]                           ns <- base::getNamespace("future")
[08:26:45.558]                           version <- ns[[".package"]][["version"]]
[08:26:45.558]                           if (is.null(version)) 
[08:26:45.558]                             version <- utils::packageVersion("future")
[08:26:45.558]                         }
[08:26:45.558]                         else {
[08:26:45.558]                           version <- NULL
[08:26:45.558]                         }
[08:26:45.558]                         if (!has_future || version < "1.8.0") {
[08:26:45.558]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:45.558]                             "", base::R.version$version.string), 
[08:26:45.558]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:45.558]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:45.558]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:45.558]                               "release", "version")], collapse = " "), 
[08:26:45.558]                             hostname = base::Sys.info()[["nodename"]])
[08:26:45.558]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:45.558]                             info)
[08:26:45.558]                           info <- base::paste(info, collapse = "; ")
[08:26:45.558]                           if (!has_future) {
[08:26:45.558]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:45.558]                               info)
[08:26:45.558]                           }
[08:26:45.558]                           else {
[08:26:45.558]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:45.558]                               info, version)
[08:26:45.558]                           }
[08:26:45.558]                           base::stop(msg)
[08:26:45.558]                         }
[08:26:45.558]                       })
[08:26:45.558]                     }
[08:26:45.558]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:45.558]                     base::options(mc.cores = 1L)
[08:26:45.558]                   }
[08:26:45.558]                   ...future.strategy.old <- future::plan("list")
[08:26:45.558]                   options(future.plan = NULL)
[08:26:45.558]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:45.558]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:45.558]                 }
[08:26:45.558]                 ...future.workdir <- getwd()
[08:26:45.558]             }
[08:26:45.558]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:45.558]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:45.558]         }
[08:26:45.558]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:45.558]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:45.558]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:45.558]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:45.558]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:45.558]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:45.558]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:45.558]             base::names(...future.oldOptions))
[08:26:45.558]     }
[08:26:45.558]     if (TRUE) {
[08:26:45.558]     }
[08:26:45.558]     else {
[08:26:45.558]         if (NA) {
[08:26:45.558]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:45.558]                 open = "w")
[08:26:45.558]         }
[08:26:45.558]         else {
[08:26:45.558]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:45.558]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:45.558]         }
[08:26:45.558]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:45.558]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:45.558]             base::sink(type = "output", split = FALSE)
[08:26:45.558]             base::close(...future.stdout)
[08:26:45.558]         }, add = TRUE)
[08:26:45.558]     }
[08:26:45.558]     ...future.frame <- base::sys.nframe()
[08:26:45.558]     ...future.conditions <- base::list()
[08:26:45.558]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:45.558]     if (FALSE) {
[08:26:45.558]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:45.558]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:45.558]     }
[08:26:45.558]     ...future.result <- base::tryCatch({
[08:26:45.558]         base::withCallingHandlers({
[08:26:45.558]             ...future.value <- base::withVisible(base::local({
[08:26:45.558]                 withCallingHandlers({
[08:26:45.558]                   {
[08:26:45.558]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:45.558]                     if (!identical(...future.globals.maxSize.org, 
[08:26:45.558]                       ...future.globals.maxSize)) {
[08:26:45.558]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:45.558]                       on.exit(options(oopts), add = TRUE)
[08:26:45.558]                     }
[08:26:45.558]                     {
[08:26:45.558]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:45.558]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:45.558]                         USE.NAMES = FALSE)
[08:26:45.558]                       do.call(mapply, args = args)
[08:26:45.558]                     }
[08:26:45.558]                   }
[08:26:45.558]                 }, immediateCondition = function(cond) {
[08:26:45.558]                   save_rds <- function (object, pathname, ...) 
[08:26:45.558]                   {
[08:26:45.558]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:45.558]                     if (file_test("-f", pathname_tmp)) {
[08:26:45.558]                       fi_tmp <- file.info(pathname_tmp)
[08:26:45.558]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:45.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:45.558]                         fi_tmp[["mtime"]])
[08:26:45.558]                     }
[08:26:45.558]                     tryCatch({
[08:26:45.558]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:45.558]                     }, error = function(ex) {
[08:26:45.558]                       msg <- conditionMessage(ex)
[08:26:45.558]                       fi_tmp <- file.info(pathname_tmp)
[08:26:45.558]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:45.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:45.558]                         fi_tmp[["mtime"]], msg)
[08:26:45.558]                       ex$message <- msg
[08:26:45.558]                       stop(ex)
[08:26:45.558]                     })
[08:26:45.558]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:45.558]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:45.558]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:45.558]                       fi_tmp <- file.info(pathname_tmp)
[08:26:45.558]                       fi <- file.info(pathname)
[08:26:45.558]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:45.558]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:45.558]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:45.558]                         fi[["size"]], fi[["mtime"]])
[08:26:45.558]                       stop(msg)
[08:26:45.558]                     }
[08:26:45.558]                     invisible(pathname)
[08:26:45.558]                   }
[08:26:45.558]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:45.558]                     rootPath = tempdir()) 
[08:26:45.558]                   {
[08:26:45.558]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:45.558]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:45.558]                       tmpdir = path, fileext = ".rds")
[08:26:45.558]                     save_rds(obj, file)
[08:26:45.558]                   }
[08:26:45.558]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:45.558]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:45.558]                   {
[08:26:45.558]                     inherits <- base::inherits
[08:26:45.558]                     invokeRestart <- base::invokeRestart
[08:26:45.558]                     is.null <- base::is.null
[08:26:45.558]                     muffled <- FALSE
[08:26:45.558]                     if (inherits(cond, "message")) {
[08:26:45.558]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:45.558]                       if (muffled) 
[08:26:45.558]                         invokeRestart("muffleMessage")
[08:26:45.558]                     }
[08:26:45.558]                     else if (inherits(cond, "warning")) {
[08:26:45.558]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:45.558]                       if (muffled) 
[08:26:45.558]                         invokeRestart("muffleWarning")
[08:26:45.558]                     }
[08:26:45.558]                     else if (inherits(cond, "condition")) {
[08:26:45.558]                       if (!is.null(pattern)) {
[08:26:45.558]                         computeRestarts <- base::computeRestarts
[08:26:45.558]                         grepl <- base::grepl
[08:26:45.558]                         restarts <- computeRestarts(cond)
[08:26:45.558]                         for (restart in restarts) {
[08:26:45.558]                           name <- restart$name
[08:26:45.558]                           if (is.null(name)) 
[08:26:45.558]                             next
[08:26:45.558]                           if (!grepl(pattern, name)) 
[08:26:45.558]                             next
[08:26:45.558]                           invokeRestart(restart)
[08:26:45.558]                           muffled <- TRUE
[08:26:45.558]                           break
[08:26:45.558]                         }
[08:26:45.558]                       }
[08:26:45.558]                     }
[08:26:45.558]                     invisible(muffled)
[08:26:45.558]                   }
[08:26:45.558]                   muffleCondition(cond)
[08:26:45.558]                 })
[08:26:45.558]             }))
[08:26:45.558]             future::FutureResult(value = ...future.value$value, 
[08:26:45.558]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:45.558]                   ...future.rng), globalenv = if (FALSE) 
[08:26:45.558]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:45.558]                     ...future.globalenv.names))
[08:26:45.558]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:45.558]         }, condition = base::local({
[08:26:45.558]             c <- base::c
[08:26:45.558]             inherits <- base::inherits
[08:26:45.558]             invokeRestart <- base::invokeRestart
[08:26:45.558]             length <- base::length
[08:26:45.558]             list <- base::list
[08:26:45.558]             seq.int <- base::seq.int
[08:26:45.558]             signalCondition <- base::signalCondition
[08:26:45.558]             sys.calls <- base::sys.calls
[08:26:45.558]             `[[` <- base::`[[`
[08:26:45.558]             `+` <- base::`+`
[08:26:45.558]             `<<-` <- base::`<<-`
[08:26:45.558]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:45.558]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:45.558]                   3L)]
[08:26:45.558]             }
[08:26:45.558]             function(cond) {
[08:26:45.558]                 is_error <- inherits(cond, "error")
[08:26:45.558]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:45.558]                   NULL)
[08:26:45.558]                 if (is_error) {
[08:26:45.558]                   sessionInformation <- function() {
[08:26:45.558]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:45.558]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:45.558]                       search = base::search(), system = base::Sys.info())
[08:26:45.558]                   }
[08:26:45.558]                   ...future.conditions[[length(...future.conditions) + 
[08:26:45.558]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:45.558]                     cond$call), session = sessionInformation(), 
[08:26:45.558]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:45.558]                   signalCondition(cond)
[08:26:45.558]                 }
[08:26:45.558]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:45.558]                 "immediateCondition"))) {
[08:26:45.558]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:45.558]                   ...future.conditions[[length(...future.conditions) + 
[08:26:45.558]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:45.558]                   if (TRUE && !signal) {
[08:26:45.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:45.558]                     {
[08:26:45.558]                       inherits <- base::inherits
[08:26:45.558]                       invokeRestart <- base::invokeRestart
[08:26:45.558]                       is.null <- base::is.null
[08:26:45.558]                       muffled <- FALSE
[08:26:45.558]                       if (inherits(cond, "message")) {
[08:26:45.558]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:45.558]                         if (muffled) 
[08:26:45.558]                           invokeRestart("muffleMessage")
[08:26:45.558]                       }
[08:26:45.558]                       else if (inherits(cond, "warning")) {
[08:26:45.558]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:45.558]                         if (muffled) 
[08:26:45.558]                           invokeRestart("muffleWarning")
[08:26:45.558]                       }
[08:26:45.558]                       else if (inherits(cond, "condition")) {
[08:26:45.558]                         if (!is.null(pattern)) {
[08:26:45.558]                           computeRestarts <- base::computeRestarts
[08:26:45.558]                           grepl <- base::grepl
[08:26:45.558]                           restarts <- computeRestarts(cond)
[08:26:45.558]                           for (restart in restarts) {
[08:26:45.558]                             name <- restart$name
[08:26:45.558]                             if (is.null(name)) 
[08:26:45.558]                               next
[08:26:45.558]                             if (!grepl(pattern, name)) 
[08:26:45.558]                               next
[08:26:45.558]                             invokeRestart(restart)
[08:26:45.558]                             muffled <- TRUE
[08:26:45.558]                             break
[08:26:45.558]                           }
[08:26:45.558]                         }
[08:26:45.558]                       }
[08:26:45.558]                       invisible(muffled)
[08:26:45.558]                     }
[08:26:45.558]                     muffleCondition(cond, pattern = "^muffle")
[08:26:45.558]                   }
[08:26:45.558]                 }
[08:26:45.558]                 else {
[08:26:45.558]                   if (TRUE) {
[08:26:45.558]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:45.558]                     {
[08:26:45.558]                       inherits <- base::inherits
[08:26:45.558]                       invokeRestart <- base::invokeRestart
[08:26:45.558]                       is.null <- base::is.null
[08:26:45.558]                       muffled <- FALSE
[08:26:45.558]                       if (inherits(cond, "message")) {
[08:26:45.558]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:45.558]                         if (muffled) 
[08:26:45.558]                           invokeRestart("muffleMessage")
[08:26:45.558]                       }
[08:26:45.558]                       else if (inherits(cond, "warning")) {
[08:26:45.558]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:45.558]                         if (muffled) 
[08:26:45.558]                           invokeRestart("muffleWarning")
[08:26:45.558]                       }
[08:26:45.558]                       else if (inherits(cond, "condition")) {
[08:26:45.558]                         if (!is.null(pattern)) {
[08:26:45.558]                           computeRestarts <- base::computeRestarts
[08:26:45.558]                           grepl <- base::grepl
[08:26:45.558]                           restarts <- computeRestarts(cond)
[08:26:45.558]                           for (restart in restarts) {
[08:26:45.558]                             name <- restart$name
[08:26:45.558]                             if (is.null(name)) 
[08:26:45.558]                               next
[08:26:45.558]                             if (!grepl(pattern, name)) 
[08:26:45.558]                               next
[08:26:45.558]                             invokeRestart(restart)
[08:26:45.558]                             muffled <- TRUE
[08:26:45.558]                             break
[08:26:45.558]                           }
[08:26:45.558]                         }
[08:26:45.558]                       }
[08:26:45.558]                       invisible(muffled)
[08:26:45.558]                     }
[08:26:45.558]                     muffleCondition(cond, pattern = "^muffle")
[08:26:45.558]                   }
[08:26:45.558]                 }
[08:26:45.558]             }
[08:26:45.558]         }))
[08:26:45.558]     }, error = function(ex) {
[08:26:45.558]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:45.558]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:45.558]                 ...future.rng), started = ...future.startTime, 
[08:26:45.558]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:45.558]             version = "1.8"), class = "FutureResult")
[08:26:45.558]     }, finally = {
[08:26:45.558]         if (!identical(...future.workdir, getwd())) 
[08:26:45.558]             setwd(...future.workdir)
[08:26:45.558]         {
[08:26:45.558]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:45.558]                 ...future.oldOptions$nwarnings <- NULL
[08:26:45.558]             }
[08:26:45.558]             base::options(...future.oldOptions)
[08:26:45.558]             if (.Platform$OS.type == "windows") {
[08:26:45.558]                 old_names <- names(...future.oldEnvVars)
[08:26:45.558]                 envs <- base::Sys.getenv()
[08:26:45.558]                 names <- names(envs)
[08:26:45.558]                 common <- intersect(names, old_names)
[08:26:45.558]                 added <- setdiff(names, old_names)
[08:26:45.558]                 removed <- setdiff(old_names, names)
[08:26:45.558]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:45.558]                   envs[common]]
[08:26:45.558]                 NAMES <- toupper(changed)
[08:26:45.558]                 args <- list()
[08:26:45.558]                 for (kk in seq_along(NAMES)) {
[08:26:45.558]                   name <- changed[[kk]]
[08:26:45.558]                   NAME <- NAMES[[kk]]
[08:26:45.558]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:45.558]                     next
[08:26:45.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:45.558]                 }
[08:26:45.558]                 NAMES <- toupper(added)
[08:26:45.558]                 for (kk in seq_along(NAMES)) {
[08:26:45.558]                   name <- added[[kk]]
[08:26:45.558]                   NAME <- NAMES[[kk]]
[08:26:45.558]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:45.558]                     next
[08:26:45.558]                   args[[name]] <- ""
[08:26:45.558]                 }
[08:26:45.558]                 NAMES <- toupper(removed)
[08:26:45.558]                 for (kk in seq_along(NAMES)) {
[08:26:45.558]                   name <- removed[[kk]]
[08:26:45.558]                   NAME <- NAMES[[kk]]
[08:26:45.558]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:45.558]                     next
[08:26:45.558]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:45.558]                 }
[08:26:45.558]                 if (length(args) > 0) 
[08:26:45.558]                   base::do.call(base::Sys.setenv, args = args)
[08:26:45.558]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:45.558]             }
[08:26:45.558]             else {
[08:26:45.558]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:45.558]             }
[08:26:45.558]             {
[08:26:45.558]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:45.558]                   0L) {
[08:26:45.558]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:45.558]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:45.558]                   base::options(opts)
[08:26:45.558]                 }
[08:26:45.558]                 {
[08:26:45.558]                   {
[08:26:45.558]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:45.558]                     NULL
[08:26:45.558]                   }
[08:26:45.558]                   options(future.plan = NULL)
[08:26:45.558]                   if (is.na(NA_character_)) 
[08:26:45.558]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:45.558]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:45.558]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:45.558]                     .init = FALSE)
[08:26:45.558]                 }
[08:26:45.558]             }
[08:26:45.558]         }
[08:26:45.558]     })
[08:26:45.558]     if (FALSE) {
[08:26:45.558]         base::sink(type = "output", split = FALSE)
[08:26:45.558]         if (NA) {
[08:26:45.558]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:45.558]         }
[08:26:45.558]         else {
[08:26:45.558]             ...future.result["stdout"] <- base::list(NULL)
[08:26:45.558]         }
[08:26:45.558]         base::close(...future.stdout)
[08:26:45.558]         ...future.stdout <- NULL
[08:26:45.558]     }
[08:26:45.558]     ...future.result$conditions <- ...future.conditions
[08:26:45.558]     ...future.result$finished <- base::Sys.time()
[08:26:45.558]     ...future.result
[08:26:45.558] }
[08:26:45.561] assign_globals() ...
[08:26:45.561] List of 5
[08:26:45.561]  $ ...future.FUN            :function (x, y)  
[08:26:45.561]  $ MoreArgs                 : NULL
[08:26:45.561]  $ ...future.elements_ii    :List of 2
[08:26:45.561]   ..$ :List of 1
[08:26:45.561]   .. ..$ : int 1
[08:26:45.561]   ..$ :List of 1
[08:26:45.561]   .. ..$ : int 0
[08:26:45.561]  $ ...future.seeds_ii       : NULL
[08:26:45.561]  $ ...future.globals.maxSize: NULL
[08:26:45.561]  - attr(*, "where")=List of 5
[08:26:45.561]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:45.561]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:45.561]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:45.561]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:45.561]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:45.561]  - attr(*, "resolved")= logi FALSE
[08:26:45.561]  - attr(*, "total_size")= num 1218
[08:26:45.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:45.561]  - attr(*, "already-done")= logi TRUE
[08:26:45.566] - reassign environment for ‘...future.FUN’
[08:26:45.566] - copied ‘...future.FUN’ to environment
[08:26:45.566] - copied ‘MoreArgs’ to environment
[08:26:45.567] - copied ‘...future.elements_ii’ to environment
[08:26:45.567] - copied ‘...future.seeds_ii’ to environment
[08:26:45.567] - copied ‘...future.globals.maxSize’ to environment
[08:26:45.567] assign_globals() ... done
[08:26:45.567] requestCore(): workers = 2
[08:26:45.570] MulticoreFuture started
[08:26:45.570] - Launch lazy future ... done
[08:26:45.570] run() for ‘MulticoreFuture’ ... done
[08:26:45.571] Created future:
[08:26:45.571] plan(): Setting new future strategy stack:
[08:26:45.571] List of future strategies:
[08:26:45.571] 1. sequential:
[08:26:45.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:45.571]    - tweaked: FALSE
[08:26:45.571]    - call: NULL
[08:26:45.572] plan(): nbrOfWorkers() = 1
[08:26:45.571] MulticoreFuture:
[08:26:45.571] Label: ‘future_mapply-1’
[08:26:45.571] Expression:
[08:26:45.571] {
[08:26:45.571]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:45.571]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:45.571]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:45.571]         on.exit(options(oopts), add = TRUE)
[08:26:45.571]     }
[08:26:45.571]     {
[08:26:45.571]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:45.571]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:45.571]         do.call(mapply, args = args)
[08:26:45.571]     }
[08:26:45.571] }
[08:26:45.571] Lazy evaluation: FALSE
[08:26:45.571] Asynchronous evaluation: TRUE
[08:26:45.571] Local evaluation: TRUE
[08:26:45.571] Environment: R_GlobalEnv
[08:26:45.571] Capture standard output: NA
[08:26:45.571] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:45.571] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:45.571] Packages: <none>
[08:26:45.571] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:45.571] Resolved: FALSE
[08:26:45.571] Value: <not collected>
[08:26:45.571] Conditions captured: <none>
[08:26:45.571] Early signaling: FALSE
[08:26:45.571] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:45.571] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:45.584] Chunk #1 of 2 ... DONE
[08:26:45.589] Chunk #2 of 2 ...
[08:26:45.589]  - Finding globals in '...' for chunk #2 ...
[08:26:45.590] getGlobalsAndPackages() ...
[08:26:45.590] Searching for globals...
[08:26:45.592] 
[08:26:45.592] Searching for globals ... DONE
[08:26:45.593] - globals: [0] <none>
[08:26:45.593] getGlobalsAndPackages() ... DONE
[08:26:45.593]    + additional globals found: [n=0] 
[08:26:45.594]    + additional namespaces needed: [n=0] 
[08:26:45.594]  - Finding globals in '...' for chunk #2 ... DONE
[08:26:45.594]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:45.595]  - seeds: <none>
[08:26:45.595]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:45.595] getGlobalsAndPackages() ...
[08:26:45.595] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:45.596] Resolving globals: FALSE
[08:26:45.597] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:45.598] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:45.599] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:45.599] 
[08:26:45.599] getGlobalsAndPackages() ... DONE
[08:26:45.600] run() for ‘Future’ ...
[08:26:45.600] - state: ‘created’
[08:26:45.601] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:26:45.604] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:45.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:26:45.604]   - Field: ‘label’
[08:26:45.605]   - Field: ‘local’
[08:26:45.605]   - Field: ‘owner’
[08:26:45.605]   - Field: ‘envir’
[08:26:45.605]   - Field: ‘workers’
[08:26:45.605]   - Field: ‘packages’
[08:26:45.605]   - Field: ‘gc’
[08:26:45.606]   - Field: ‘job’
[08:26:45.606]   - Field: ‘conditions’
[08:26:45.606]   - Field: ‘expr’
[08:26:45.606]   - Field: ‘uuid’
[08:26:45.606]   - Field: ‘seed’
[08:26:45.606]   - Field: ‘version’
[08:26:45.606]   - Field: ‘result’
[08:26:45.607]   - Field: ‘asynchronous’
[08:26:45.607]   - Field: ‘calls’
[08:26:45.607]   - Field: ‘globals’
[08:26:45.607]   - Field: ‘stdout’
[08:26:45.607]   - Field: ‘earlySignal’
[08:26:45.607]   - Field: ‘lazy’
[08:26:45.607]   - Field: ‘state’
[08:26:45.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:26:45.608] - Launch lazy future ...
[08:26:45.608] Packages needed by the future expression (n = 0): <none>
[08:26:45.608] Packages needed by future strategies (n = 0): <none>
[08:26:45.609] {
[08:26:45.609]     {
[08:26:45.609]         {
[08:26:45.609]             ...future.startTime <- base::Sys.time()
[08:26:45.609]             {
[08:26:45.609]                 {
[08:26:45.609]                   {
[08:26:45.609]                     {
[08:26:45.609]                       base::local({
[08:26:45.609]                         has_future <- base::requireNamespace("future", 
[08:26:45.609]                           quietly = TRUE)
[08:26:45.609]                         if (has_future) {
[08:26:45.609]                           ns <- base::getNamespace("future")
[08:26:45.609]                           version <- ns[[".package"]][["version"]]
[08:26:45.609]                           if (is.null(version)) 
[08:26:45.609]                             version <- utils::packageVersion("future")
[08:26:45.609]                         }
[08:26:45.609]                         else {
[08:26:45.609]                           version <- NULL
[08:26:45.609]                         }
[08:26:45.609]                         if (!has_future || version < "1.8.0") {
[08:26:45.609]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:45.609]                             "", base::R.version$version.string), 
[08:26:45.609]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:45.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:45.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:45.609]                               "release", "version")], collapse = " "), 
[08:26:45.609]                             hostname = base::Sys.info()[["nodename"]])
[08:26:45.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:45.609]                             info)
[08:26:45.609]                           info <- base::paste(info, collapse = "; ")
[08:26:45.609]                           if (!has_future) {
[08:26:45.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:45.609]                               info)
[08:26:45.609]                           }
[08:26:45.609]                           else {
[08:26:45.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:45.609]                               info, version)
[08:26:45.609]                           }
[08:26:45.609]                           base::stop(msg)
[08:26:45.609]                         }
[08:26:45.609]                       })
[08:26:45.609]                     }
[08:26:45.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:45.609]                     base::options(mc.cores = 1L)
[08:26:45.609]                   }
[08:26:45.609]                   ...future.strategy.old <- future::plan("list")
[08:26:45.609]                   options(future.plan = NULL)
[08:26:45.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:45.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:45.609]                 }
[08:26:45.609]                 ...future.workdir <- getwd()
[08:26:45.609]             }
[08:26:45.609]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:45.609]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:45.609]         }
[08:26:45.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:45.609]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:45.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:45.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:45.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:45.609]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:45.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:45.609]             base::names(...future.oldOptions))
[08:26:45.609]     }
[08:26:45.609]     if (TRUE) {
[08:26:45.609]     }
[08:26:45.609]     else {
[08:26:45.609]         if (NA) {
[08:26:45.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:45.609]                 open = "w")
[08:26:45.609]         }
[08:26:45.609]         else {
[08:26:45.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:45.609]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:45.609]         }
[08:26:45.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:45.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:45.609]             base::sink(type = "output", split = FALSE)
[08:26:45.609]             base::close(...future.stdout)
[08:26:45.609]         }, add = TRUE)
[08:26:45.609]     }
[08:26:45.609]     ...future.frame <- base::sys.nframe()
[08:26:45.609]     ...future.conditions <- base::list()
[08:26:45.609]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:45.609]     if (FALSE) {
[08:26:45.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:45.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:45.609]     }
[08:26:45.609]     ...future.result <- base::tryCatch({
[08:26:45.609]         base::withCallingHandlers({
[08:26:45.609]             ...future.value <- base::withVisible(base::local({
[08:26:45.609]                 withCallingHandlers({
[08:26:45.609]                   {
[08:26:45.609]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:45.609]                     if (!identical(...future.globals.maxSize.org, 
[08:26:45.609]                       ...future.globals.maxSize)) {
[08:26:45.609]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:45.609]                       on.exit(options(oopts), add = TRUE)
[08:26:45.609]                     }
[08:26:45.609]                     {
[08:26:45.609]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:45.609]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:45.609]                         USE.NAMES = FALSE)
[08:26:45.609]                       do.call(mapply, args = args)
[08:26:45.609]                     }
[08:26:45.609]                   }
[08:26:45.609]                 }, immediateCondition = function(cond) {
[08:26:45.609]                   save_rds <- function (object, pathname, ...) 
[08:26:45.609]                   {
[08:26:45.609]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:26:45.609]                     if (file_test("-f", pathname_tmp)) {
[08:26:45.609]                       fi_tmp <- file.info(pathname_tmp)
[08:26:45.609]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:26:45.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:45.609]                         fi_tmp[["mtime"]])
[08:26:45.609]                     }
[08:26:45.609]                     tryCatch({
[08:26:45.609]                       saveRDS(object, file = pathname_tmp, ...)
[08:26:45.609]                     }, error = function(ex) {
[08:26:45.609]                       msg <- conditionMessage(ex)
[08:26:45.609]                       fi_tmp <- file.info(pathname_tmp)
[08:26:45.609]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:26:45.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:45.609]                         fi_tmp[["mtime"]], msg)
[08:26:45.609]                       ex$message <- msg
[08:26:45.609]                       stop(ex)
[08:26:45.609]                     })
[08:26:45.609]                     stopifnot(file_test("-f", pathname_tmp))
[08:26:45.609]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:26:45.609]                     if (!res || file_test("-f", pathname_tmp)) {
[08:26:45.609]                       fi_tmp <- file.info(pathname_tmp)
[08:26:45.609]                       fi <- file.info(pathname)
[08:26:45.609]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:26:45.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:26:45.609]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:26:45.609]                         fi[["size"]], fi[["mtime"]])
[08:26:45.609]                       stop(msg)
[08:26:45.609]                     }
[08:26:45.609]                     invisible(pathname)
[08:26:45.609]                   }
[08:26:45.609]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:26:45.609]                     rootPath = tempdir()) 
[08:26:45.609]                   {
[08:26:45.609]                     obj <- list(time = Sys.time(), condition = cond)
[08:26:45.609]                     file <- tempfile(pattern = class(cond)[1], 
[08:26:45.609]                       tmpdir = path, fileext = ".rds")
[08:26:45.609]                     save_rds(obj, file)
[08:26:45.609]                   }
[08:26:45.609]                   saveImmediateCondition(cond, path = "/tmp/RtmptS80SI/.future/immediateConditions")
[08:26:45.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:45.609]                   {
[08:26:45.609]                     inherits <- base::inherits
[08:26:45.609]                     invokeRestart <- base::invokeRestart
[08:26:45.609]                     is.null <- base::is.null
[08:26:45.609]                     muffled <- FALSE
[08:26:45.609]                     if (inherits(cond, "message")) {
[08:26:45.609]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:45.609]                       if (muffled) 
[08:26:45.609]                         invokeRestart("muffleMessage")
[08:26:45.609]                     }
[08:26:45.609]                     else if (inherits(cond, "warning")) {
[08:26:45.609]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:45.609]                       if (muffled) 
[08:26:45.609]                         invokeRestart("muffleWarning")
[08:26:45.609]                     }
[08:26:45.609]                     else if (inherits(cond, "condition")) {
[08:26:45.609]                       if (!is.null(pattern)) {
[08:26:45.609]                         computeRestarts <- base::computeRestarts
[08:26:45.609]                         grepl <- base::grepl
[08:26:45.609]                         restarts <- computeRestarts(cond)
[08:26:45.609]                         for (restart in restarts) {
[08:26:45.609]                           name <- restart$name
[08:26:45.609]                           if (is.null(name)) 
[08:26:45.609]                             next
[08:26:45.609]                           if (!grepl(pattern, name)) 
[08:26:45.609]                             next
[08:26:45.609]                           invokeRestart(restart)
[08:26:45.609]                           muffled <- TRUE
[08:26:45.609]                           break
[08:26:45.609]                         }
[08:26:45.609]                       }
[08:26:45.609]                     }
[08:26:45.609]                     invisible(muffled)
[08:26:45.609]                   }
[08:26:45.609]                   muffleCondition(cond)
[08:26:45.609]                 })
[08:26:45.609]             }))
[08:26:45.609]             future::FutureResult(value = ...future.value$value, 
[08:26:45.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:45.609]                   ...future.rng), globalenv = if (FALSE) 
[08:26:45.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:45.609]                     ...future.globalenv.names))
[08:26:45.609]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:45.609]         }, condition = base::local({
[08:26:45.609]             c <- base::c
[08:26:45.609]             inherits <- base::inherits
[08:26:45.609]             invokeRestart <- base::invokeRestart
[08:26:45.609]             length <- base::length
[08:26:45.609]             list <- base::list
[08:26:45.609]             seq.int <- base::seq.int
[08:26:45.609]             signalCondition <- base::signalCondition
[08:26:45.609]             sys.calls <- base::sys.calls
[08:26:45.609]             `[[` <- base::`[[`
[08:26:45.609]             `+` <- base::`+`
[08:26:45.609]             `<<-` <- base::`<<-`
[08:26:45.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:45.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:45.609]                   3L)]
[08:26:45.609]             }
[08:26:45.609]             function(cond) {
[08:26:45.609]                 is_error <- inherits(cond, "error")
[08:26:45.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:45.609]                   NULL)
[08:26:45.609]                 if (is_error) {
[08:26:45.609]                   sessionInformation <- function() {
[08:26:45.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:45.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:45.609]                       search = base::search(), system = base::Sys.info())
[08:26:45.609]                   }
[08:26:45.609]                   ...future.conditions[[length(...future.conditions) + 
[08:26:45.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:45.609]                     cond$call), session = sessionInformation(), 
[08:26:45.609]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:45.609]                   signalCondition(cond)
[08:26:45.609]                 }
[08:26:45.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:45.609]                 "immediateCondition"))) {
[08:26:45.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:45.609]                   ...future.conditions[[length(...future.conditions) + 
[08:26:45.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:45.609]                   if (TRUE && !signal) {
[08:26:45.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:45.609]                     {
[08:26:45.609]                       inherits <- base::inherits
[08:26:45.609]                       invokeRestart <- base::invokeRestart
[08:26:45.609]                       is.null <- base::is.null
[08:26:45.609]                       muffled <- FALSE
[08:26:45.609]                       if (inherits(cond, "message")) {
[08:26:45.609]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:45.609]                         if (muffled) 
[08:26:45.609]                           invokeRestart("muffleMessage")
[08:26:45.609]                       }
[08:26:45.609]                       else if (inherits(cond, "warning")) {
[08:26:45.609]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:45.609]                         if (muffled) 
[08:26:45.609]                           invokeRestart("muffleWarning")
[08:26:45.609]                       }
[08:26:45.609]                       else if (inherits(cond, "condition")) {
[08:26:45.609]                         if (!is.null(pattern)) {
[08:26:45.609]                           computeRestarts <- base::computeRestarts
[08:26:45.609]                           grepl <- base::grepl
[08:26:45.609]                           restarts <- computeRestarts(cond)
[08:26:45.609]                           for (restart in restarts) {
[08:26:45.609]                             name <- restart$name
[08:26:45.609]                             if (is.null(name)) 
[08:26:45.609]                               next
[08:26:45.609]                             if (!grepl(pattern, name)) 
[08:26:45.609]                               next
[08:26:45.609]                             invokeRestart(restart)
[08:26:45.609]                             muffled <- TRUE
[08:26:45.609]                             break
[08:26:45.609]                           }
[08:26:45.609]                         }
[08:26:45.609]                       }
[08:26:45.609]                       invisible(muffled)
[08:26:45.609]                     }
[08:26:45.609]                     muffleCondition(cond, pattern = "^muffle")
[08:26:45.609]                   }
[08:26:45.609]                 }
[08:26:45.609]                 else {
[08:26:45.609]                   if (TRUE) {
[08:26:45.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:45.609]                     {
[08:26:45.609]                       inherits <- base::inherits
[08:26:45.609]                       invokeRestart <- base::invokeRestart
[08:26:45.609]                       is.null <- base::is.null
[08:26:45.609]                       muffled <- FALSE
[08:26:45.609]                       if (inherits(cond, "message")) {
[08:26:45.609]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:45.609]                         if (muffled) 
[08:26:45.609]                           invokeRestart("muffleMessage")
[08:26:45.609]                       }
[08:26:45.609]                       else if (inherits(cond, "warning")) {
[08:26:45.609]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:45.609]                         if (muffled) 
[08:26:45.609]                           invokeRestart("muffleWarning")
[08:26:45.609]                       }
[08:26:45.609]                       else if (inherits(cond, "condition")) {
[08:26:45.609]                         if (!is.null(pattern)) {
[08:26:45.609]                           computeRestarts <- base::computeRestarts
[08:26:45.609]                           grepl <- base::grepl
[08:26:45.609]                           restarts <- computeRestarts(cond)
[08:26:45.609]                           for (restart in restarts) {
[08:26:45.609]                             name <- restart$name
[08:26:45.609]                             if (is.null(name)) 
[08:26:45.609]                               next
[08:26:45.609]                             if (!grepl(pattern, name)) 
[08:26:45.609]                               next
[08:26:45.609]                             invokeRestart(restart)
[08:26:45.609]                             muffled <- TRUE
[08:26:45.609]                             break
[08:26:45.609]                           }
[08:26:45.609]                         }
[08:26:45.609]                       }
[08:26:45.609]                       invisible(muffled)
[08:26:45.609]                     }
[08:26:45.609]                     muffleCondition(cond, pattern = "^muffle")
[08:26:45.609]                   }
[08:26:45.609]                 }
[08:26:45.609]             }
[08:26:45.609]         }))
[08:26:45.609]     }, error = function(ex) {
[08:26:45.609]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:45.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:45.609]                 ...future.rng), started = ...future.startTime, 
[08:26:45.609]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:45.609]             version = "1.8"), class = "FutureResult")
[08:26:45.609]     }, finally = {
[08:26:45.609]         if (!identical(...future.workdir, getwd())) 
[08:26:45.609]             setwd(...future.workdir)
[08:26:45.609]         {
[08:26:45.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:45.609]                 ...future.oldOptions$nwarnings <- NULL
[08:26:45.609]             }
[08:26:45.609]             base::options(...future.oldOptions)
[08:26:45.609]             if (.Platform$OS.type == "windows") {
[08:26:45.609]                 old_names <- names(...future.oldEnvVars)
[08:26:45.609]                 envs <- base::Sys.getenv()
[08:26:45.609]                 names <- names(envs)
[08:26:45.609]                 common <- intersect(names, old_names)
[08:26:45.609]                 added <- setdiff(names, old_names)
[08:26:45.609]                 removed <- setdiff(old_names, names)
[08:26:45.609]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:45.609]                   envs[common]]
[08:26:45.609]                 NAMES <- toupper(changed)
[08:26:45.609]                 args <- list()
[08:26:45.609]                 for (kk in seq_along(NAMES)) {
[08:26:45.609]                   name <- changed[[kk]]
[08:26:45.609]                   NAME <- NAMES[[kk]]
[08:26:45.609]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:45.609]                     next
[08:26:45.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:45.609]                 }
[08:26:45.609]                 NAMES <- toupper(added)
[08:26:45.609]                 for (kk in seq_along(NAMES)) {
[08:26:45.609]                   name <- added[[kk]]
[08:26:45.609]                   NAME <- NAMES[[kk]]
[08:26:45.609]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:45.609]                     next
[08:26:45.609]                   args[[name]] <- ""
[08:26:45.609]                 }
[08:26:45.609]                 NAMES <- toupper(removed)
[08:26:45.609]                 for (kk in seq_along(NAMES)) {
[08:26:45.609]                   name <- removed[[kk]]
[08:26:45.609]                   NAME <- NAMES[[kk]]
[08:26:45.609]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:45.609]                     next
[08:26:45.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:45.609]                 }
[08:26:45.609]                 if (length(args) > 0) 
[08:26:45.609]                   base::do.call(base::Sys.setenv, args = args)
[08:26:45.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:45.609]             }
[08:26:45.609]             else {
[08:26:45.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:45.609]             }
[08:26:45.609]             {
[08:26:45.609]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:45.609]                   0L) {
[08:26:45.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:45.609]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:45.609]                   base::options(opts)
[08:26:45.609]                 }
[08:26:45.609]                 {
[08:26:45.609]                   {
[08:26:45.609]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:45.609]                     NULL
[08:26:45.609]                   }
[08:26:45.609]                   options(future.plan = NULL)
[08:26:45.609]                   if (is.na(NA_character_)) 
[08:26:45.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:45.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:45.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:45.609]                     .init = FALSE)
[08:26:45.609]                 }
[08:26:45.609]             }
[08:26:45.609]         }
[08:26:45.609]     })
[08:26:45.609]     if (FALSE) {
[08:26:45.609]         base::sink(type = "output", split = FALSE)
[08:26:45.609]         if (NA) {
[08:26:45.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:45.609]         }
[08:26:45.609]         else {
[08:26:45.609]             ...future.result["stdout"] <- base::list(NULL)
[08:26:45.609]         }
[08:26:45.609]         base::close(...future.stdout)
[08:26:45.609]         ...future.stdout <- NULL
[08:26:45.609]     }
[08:26:45.609]     ...future.result$conditions <- ...future.conditions
[08:26:45.609]     ...future.result$finished <- base::Sys.time()
[08:26:45.609]     ...future.result
[08:26:45.609] }
[08:26:45.612] assign_globals() ...
[08:26:45.612] List of 5
[08:26:45.612]  $ ...future.FUN            :function (x, y)  
[08:26:45.612]  $ MoreArgs                 : NULL
[08:26:45.612]  $ ...future.elements_ii    :List of 2
[08:26:45.612]   ..$ :List of 1
[08:26:45.612]   .. ..$ : int 0
[08:26:45.612]   ..$ :List of 1
[08:26:45.612]   .. ..$ : int 1
[08:26:45.612]  $ ...future.seeds_ii       : NULL
[08:26:45.612]  $ ...future.globals.maxSize: NULL
[08:26:45.612]  - attr(*, "where")=List of 5
[08:26:45.612]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:26:45.612]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[08:26:45.612]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:26:45.612]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:26:45.612]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:26:45.612]  - attr(*, "resolved")= logi FALSE
[08:26:45.612]  - attr(*, "total_size")= num 1218
[08:26:45.612]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:45.612]  - attr(*, "already-done")= logi TRUE
[08:26:45.619] - reassign environment for ‘...future.FUN’
[08:26:45.619] - copied ‘...future.FUN’ to environment
[08:26:45.619] - copied ‘MoreArgs’ to environment
[08:26:45.620] - copied ‘...future.elements_ii’ to environment
[08:26:45.620] - copied ‘...future.seeds_ii’ to environment
[08:26:45.620] - copied ‘...future.globals.maxSize’ to environment
[08:26:45.620] assign_globals() ... done
[08:26:45.620] requestCore(): workers = 2
[08:26:45.623] MulticoreFuture started
[08:26:45.623] - Launch lazy future ... done
[08:26:45.623] run() for ‘MulticoreFuture’ ... done
[08:26:45.624] Created future:
[08:26:45.624] plan(): Setting new future strategy stack:
[08:26:45.624] List of future strategies:
[08:26:45.624] 1. sequential:
[08:26:45.624]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:45.624]    - tweaked: FALSE
[08:26:45.624]    - call: NULL
[08:26:45.625] plan(): nbrOfWorkers() = 1
[08:26:45.628] plan(): Setting new future strategy stack:
[08:26:45.628] List of future strategies:
[08:26:45.628] 1. multicore:
[08:26:45.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:45.628]    - tweaked: FALSE
[08:26:45.628]    - call: plan(strategy)
[08:26:45.631] plan(): nbrOfWorkers() = 2
[08:26:45.624] MulticoreFuture:
[08:26:45.624] Label: ‘future_mapply-2’
[08:26:45.624] Expression:
[08:26:45.624] {
[08:26:45.624]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:45.624]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:45.624]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:45.624]         on.exit(options(oopts), add = TRUE)
[08:26:45.624]     }
[08:26:45.624]     {
[08:26:45.624]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:45.624]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:45.624]         do.call(mapply, args = args)
[08:26:45.624]     }
[08:26:45.624] }
[08:26:45.624] Lazy evaluation: FALSE
[08:26:45.624] Asynchronous evaluation: TRUE
[08:26:45.624] Local evaluation: TRUE
[08:26:45.624] Environment: R_GlobalEnv
[08:26:45.624] Capture standard output: NA
[08:26:45.624] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:45.624] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:45.624] Packages: <none>
[08:26:45.624] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:45.624] Resolved: TRUE
[08:26:45.624] Value: <not collected>
[08:26:45.624] Conditions captured: <none>
[08:26:45.624] Early signaling: FALSE
[08:26:45.624] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:45.624] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:45.632] Chunk #2 of 2 ... DONE
[08:26:45.633] Launching 2 futures (chunks) ... DONE
[08:26:45.633] Resolving 2 futures (chunks) ...
[08:26:45.633] resolve() on list ...
[08:26:45.633]  recursive: 0
[08:26:45.633]  length: 2
[08:26:45.633] 
[08:26:45.644] Future #2
[08:26:45.645] result() for MulticoreFuture ...
[08:26:45.646] result() for MulticoreFuture ...
[08:26:45.646] result() for MulticoreFuture ... done
[08:26:45.646] result() for MulticoreFuture ... done
[08:26:45.646] result() for MulticoreFuture ...
[08:26:45.646] result() for MulticoreFuture ... done
[08:26:45.647] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:26:45.647] - nx: 2
[08:26:45.647] - relay: TRUE
[08:26:45.647] - stdout: TRUE
[08:26:45.647] - signal: TRUE
[08:26:45.647] - resignal: FALSE
[08:26:45.647] - force: TRUE
[08:26:45.648] - relayed: [n=2] FALSE, FALSE
[08:26:45.648] - queued futures: [n=2] FALSE, FALSE
[08:26:45.648]  - until=1
[08:26:45.648]  - relaying element #1
[08:26:45.648] - relayed: [n=2] FALSE, FALSE
[08:26:45.648] - queued futures: [n=2] FALSE, TRUE
[08:26:45.648] signalConditionsASAP(NULL, pos=2) ... done
[08:26:45.649]  length: 1 (resolved future 2)
[08:26:46.079] plan(): Setting new future strategy stack:
[08:26:46.079] List of future strategies:
[08:26:46.079] 1. multicore:
[08:26:46.079]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:26:46.079]    - tweaked: FALSE
[08:26:46.079]    - call: plan(strategy)
[08:26:46.083] plan(): nbrOfWorkers() = 2
[08:26:46.093] Future #1
[08:26:46.094] result() for MulticoreFuture ...
[08:26:46.095] result() for MulticoreFuture ...
[08:26:46.095] result() for MulticoreFuture ... done
[08:26:46.095] result() for MulticoreFuture ... done
[08:26:46.095] result() for MulticoreFuture ...
[08:26:46.095] result() for MulticoreFuture ... done
[08:26:46.095] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:26:46.096] - nx: 2
[08:26:46.096] - relay: TRUE
[08:26:46.096] - stdout: TRUE
[08:26:46.096] - signal: TRUE
[08:26:46.096] - resignal: FALSE
[08:26:46.096] - force: TRUE
[08:26:46.101] - relayed: [n=2] FALSE, FALSE
[08:26:46.101] - queued futures: [n=2] FALSE, TRUE
[08:26:46.101]  - until=1
[08:26:46.102]  - relaying element #1
[08:26:46.102] result() for MulticoreFuture ...
[08:26:46.102] result() for MulticoreFuture ... done
[08:26:46.102] result() for MulticoreFuture ...
[08:26:46.102] result() for MulticoreFuture ... done
[08:26:46.103] result() for MulticoreFuture ...
[08:26:46.103] result() for MulticoreFuture ... done
[08:26:46.103] result() for MulticoreFuture ...
[08:26:46.103] result() for MulticoreFuture ... done
[08:26:46.103] - relayed: [n=2] TRUE, FALSE
[08:26:46.104] - queued futures: [n=2] TRUE, TRUE
[08:26:46.104] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:26:46.104]  length: 0 (resolved future 1)
[08:26:46.104] Relaying remaining futures
[08:26:46.104] signalConditionsASAP(NULL, pos=0) ...
[08:26:46.104] - nx: 2
[08:26:46.105] - relay: TRUE
[08:26:46.105] - stdout: TRUE
[08:26:46.105] - signal: TRUE
[08:26:46.105] - resignal: FALSE
[08:26:46.105] - force: TRUE
[08:26:46.105] - relayed: [n=2] TRUE, FALSE
[08:26:46.106] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:46.106]  - relaying element #2
[08:26:46.106] result() for MulticoreFuture ...
[08:26:46.106] result() for MulticoreFuture ... done
[08:26:46.106] result() for MulticoreFuture ...
[08:26:46.107] result() for MulticoreFuture ... done
[08:26:46.107] result() for MulticoreFuture ...
[08:26:46.107] result() for MulticoreFuture ... done
[08:26:46.107] result() for MulticoreFuture ...
[08:26:46.107] result() for MulticoreFuture ... done
[08:26:46.107] - relayed: [n=2] TRUE, TRUE
[08:26:46.108] - queued futures: [n=2] TRUE, TRUE
[08:26:46.108] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[08:26:46.108] resolve() on list ... DONE
[08:26:46.108] result() for MulticoreFuture ...
[08:26:46.108] result() for MulticoreFuture ... done
[08:26:46.108] result() for MulticoreFuture ...
[08:26:46.108] result() for MulticoreFuture ... done
[08:26:46.108] result() for MulticoreFuture ...
[08:26:46.109] result() for MulticoreFuture ... done
[08:26:46.109] result() for MulticoreFuture ...
[08:26:46.109] result() for MulticoreFuture ... done
[08:26:46.109]  - Number of value chunks collected: 2
[08:26:46.109] Resolving 2 futures (chunks) ... DONE
[08:26:46.109] Reducing values from 2 chunks ...
[08:26:46.109]  - Number of values collected after concatenation: 2
[08:26:46.109]  - Number of values expected: 2
[08:26:46.109] Reducing values from 2 chunks ... DONE
[08:26:46.110] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[08:26:46.110] plan(): Setting new future strategy stack:
[08:26:46.110] List of future strategies:
[08:26:46.110] 1. multisession:
[08:26:46.110]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:46.110]    - tweaked: FALSE
[08:26:46.110]    - call: plan(strategy)
[08:26:46.111] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:26:46.111] multisession:
[08:26:46.111] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:26:46.111] - tweaked: FALSE
[08:26:46.111] - call: plan(strategy)
[08:26:46.116] getGlobalsAndPackages() ...
[08:26:46.116] Not searching for globals
[08:26:46.116] - globals: [0] <none>
[08:26:46.116] getGlobalsAndPackages() ... DONE
[08:26:46.637] Packages needed by the future expression (n = 0): <none>
[08:26:46.637] Packages needed by future strategies (n = 0): <none>
[08:26:46.638] {
[08:26:46.638]     {
[08:26:46.638]         {
[08:26:46.638]             ...future.startTime <- base::Sys.time()
[08:26:46.638]             {
[08:26:46.638]                 {
[08:26:46.638]                   {
[08:26:46.638]                     {
[08:26:46.638]                       base::local({
[08:26:46.638]                         has_future <- base::requireNamespace("future", 
[08:26:46.638]                           quietly = TRUE)
[08:26:46.638]                         if (has_future) {
[08:26:46.638]                           ns <- base::getNamespace("future")
[08:26:46.638]                           version <- ns[[".package"]][["version"]]
[08:26:46.638]                           if (is.null(version)) 
[08:26:46.638]                             version <- utils::packageVersion("future")
[08:26:46.638]                         }
[08:26:46.638]                         else {
[08:26:46.638]                           version <- NULL
[08:26:46.638]                         }
[08:26:46.638]                         if (!has_future || version < "1.8.0") {
[08:26:46.638]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:46.638]                             "", base::R.version$version.string), 
[08:26:46.638]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:46.638]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:46.638]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:46.638]                               "release", "version")], collapse = " "), 
[08:26:46.638]                             hostname = base::Sys.info()[["nodename"]])
[08:26:46.638]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:46.638]                             info)
[08:26:46.638]                           info <- base::paste(info, collapse = "; ")
[08:26:46.638]                           if (!has_future) {
[08:26:46.638]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:46.638]                               info)
[08:26:46.638]                           }
[08:26:46.638]                           else {
[08:26:46.638]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:46.638]                               info, version)
[08:26:46.638]                           }
[08:26:46.638]                           base::stop(msg)
[08:26:46.638]                         }
[08:26:46.638]                       })
[08:26:46.638]                     }
[08:26:46.638]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:46.638]                     base::options(mc.cores = 1L)
[08:26:46.638]                   }
[08:26:46.638]                   ...future.strategy.old <- future::plan("list")
[08:26:46.638]                   options(future.plan = NULL)
[08:26:46.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:46.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:46.638]                 }
[08:26:46.638]                 ...future.workdir <- getwd()
[08:26:46.638]             }
[08:26:46.638]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:46.638]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:46.638]         }
[08:26:46.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:46.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:26:46.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:46.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:46.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:46.638]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:46.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:46.638]             base::names(...future.oldOptions))
[08:26:46.638]     }
[08:26:46.638]     if (FALSE) {
[08:26:46.638]     }
[08:26:46.638]     else {
[08:26:46.638]         if (TRUE) {
[08:26:46.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:46.638]                 open = "w")
[08:26:46.638]         }
[08:26:46.638]         else {
[08:26:46.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:46.638]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:46.638]         }
[08:26:46.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:46.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:46.638]             base::sink(type = "output", split = FALSE)
[08:26:46.638]             base::close(...future.stdout)
[08:26:46.638]         }, add = TRUE)
[08:26:46.638]     }
[08:26:46.638]     ...future.frame <- base::sys.nframe()
[08:26:46.638]     ...future.conditions <- base::list()
[08:26:46.638]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:46.638]     if (FALSE) {
[08:26:46.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:46.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:46.638]     }
[08:26:46.638]     ...future.result <- base::tryCatch({
[08:26:46.638]         base::withCallingHandlers({
[08:26:46.638]             ...future.value <- base::withVisible(base::local({
[08:26:46.638]                 ...future.makeSendCondition <- base::local({
[08:26:46.638]                   sendCondition <- NULL
[08:26:46.638]                   function(frame = 1L) {
[08:26:46.638]                     if (is.function(sendCondition)) 
[08:26:46.638]                       return(sendCondition)
[08:26:46.638]                     ns <- getNamespace("parallel")
[08:26:46.638]                     if (exists("sendData", mode = "function", 
[08:26:46.638]                       envir = ns)) {
[08:26:46.638]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:46.638]                         envir = ns)
[08:26:46.638]                       envir <- sys.frame(frame)
[08:26:46.638]                       master <- NULL
[08:26:46.638]                       while (!identical(envir, .GlobalEnv) && 
[08:26:46.638]                         !identical(envir, emptyenv())) {
[08:26:46.638]                         if (exists("master", mode = "list", envir = envir, 
[08:26:46.638]                           inherits = FALSE)) {
[08:26:46.638]                           master <- get("master", mode = "list", 
[08:26:46.638]                             envir = envir, inherits = FALSE)
[08:26:46.638]                           if (inherits(master, c("SOCKnode", 
[08:26:46.638]                             "SOCK0node"))) {
[08:26:46.638]                             sendCondition <<- function(cond) {
[08:26:46.638]                               data <- list(type = "VALUE", value = cond, 
[08:26:46.638]                                 success = TRUE)
[08:26:46.638]                               parallel_sendData(master, data)
[08:26:46.638]                             }
[08:26:46.638]                             return(sendCondition)
[08:26:46.638]                           }
[08:26:46.638]                         }
[08:26:46.638]                         frame <- frame + 1L
[08:26:46.638]                         envir <- sys.frame(frame)
[08:26:46.638]                       }
[08:26:46.638]                     }
[08:26:46.638]                     sendCondition <<- function(cond) NULL
[08:26:46.638]                   }
[08:26:46.638]                 })
[08:26:46.638]                 withCallingHandlers({
[08:26:46.638]                   NA
[08:26:46.638]                 }, immediateCondition = function(cond) {
[08:26:46.638]                   sendCondition <- ...future.makeSendCondition()
[08:26:46.638]                   sendCondition(cond)
[08:26:46.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:46.638]                   {
[08:26:46.638]                     inherits <- base::inherits
[08:26:46.638]                     invokeRestart <- base::invokeRestart
[08:26:46.638]                     is.null <- base::is.null
[08:26:46.638]                     muffled <- FALSE
[08:26:46.638]                     if (inherits(cond, "message")) {
[08:26:46.638]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:46.638]                       if (muffled) 
[08:26:46.638]                         invokeRestart("muffleMessage")
[08:26:46.638]                     }
[08:26:46.638]                     else if (inherits(cond, "warning")) {
[08:26:46.638]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:46.638]                       if (muffled) 
[08:26:46.638]                         invokeRestart("muffleWarning")
[08:26:46.638]                     }
[08:26:46.638]                     else if (inherits(cond, "condition")) {
[08:26:46.638]                       if (!is.null(pattern)) {
[08:26:46.638]                         computeRestarts <- base::computeRestarts
[08:26:46.638]                         grepl <- base::grepl
[08:26:46.638]                         restarts <- computeRestarts(cond)
[08:26:46.638]                         for (restart in restarts) {
[08:26:46.638]                           name <- restart$name
[08:26:46.638]                           if (is.null(name)) 
[08:26:46.638]                             next
[08:26:46.638]                           if (!grepl(pattern, name)) 
[08:26:46.638]                             next
[08:26:46.638]                           invokeRestart(restart)
[08:26:46.638]                           muffled <- TRUE
[08:26:46.638]                           break
[08:26:46.638]                         }
[08:26:46.638]                       }
[08:26:46.638]                     }
[08:26:46.638]                     invisible(muffled)
[08:26:46.638]                   }
[08:26:46.638]                   muffleCondition(cond)
[08:26:46.638]                 })
[08:26:46.638]             }))
[08:26:46.638]             future::FutureResult(value = ...future.value$value, 
[08:26:46.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:46.638]                   ...future.rng), globalenv = if (FALSE) 
[08:26:46.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:46.638]                     ...future.globalenv.names))
[08:26:46.638]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:46.638]         }, condition = base::local({
[08:26:46.638]             c <- base::c
[08:26:46.638]             inherits <- base::inherits
[08:26:46.638]             invokeRestart <- base::invokeRestart
[08:26:46.638]             length <- base::length
[08:26:46.638]             list <- base::list
[08:26:46.638]             seq.int <- base::seq.int
[08:26:46.638]             signalCondition <- base::signalCondition
[08:26:46.638]             sys.calls <- base::sys.calls
[08:26:46.638]             `[[` <- base::`[[`
[08:26:46.638]             `+` <- base::`+`
[08:26:46.638]             `<<-` <- base::`<<-`
[08:26:46.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:46.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:46.638]                   3L)]
[08:26:46.638]             }
[08:26:46.638]             function(cond) {
[08:26:46.638]                 is_error <- inherits(cond, "error")
[08:26:46.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:46.638]                   NULL)
[08:26:46.638]                 if (is_error) {
[08:26:46.638]                   sessionInformation <- function() {
[08:26:46.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:46.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:46.638]                       search = base::search(), system = base::Sys.info())
[08:26:46.638]                   }
[08:26:46.638]                   ...future.conditions[[length(...future.conditions) + 
[08:26:46.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:46.638]                     cond$call), session = sessionInformation(), 
[08:26:46.638]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:46.638]                   signalCondition(cond)
[08:26:46.638]                 }
[08:26:46.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:46.638]                 "immediateCondition"))) {
[08:26:46.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:46.638]                   ...future.conditions[[length(...future.conditions) + 
[08:26:46.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:46.638]                   if (TRUE && !signal) {
[08:26:46.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:46.638]                     {
[08:26:46.638]                       inherits <- base::inherits
[08:26:46.638]                       invokeRestart <- base::invokeRestart
[08:26:46.638]                       is.null <- base::is.null
[08:26:46.638]                       muffled <- FALSE
[08:26:46.638]                       if (inherits(cond, "message")) {
[08:26:46.638]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:46.638]                         if (muffled) 
[08:26:46.638]                           invokeRestart("muffleMessage")
[08:26:46.638]                       }
[08:26:46.638]                       else if (inherits(cond, "warning")) {
[08:26:46.638]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:46.638]                         if (muffled) 
[08:26:46.638]                           invokeRestart("muffleWarning")
[08:26:46.638]                       }
[08:26:46.638]                       else if (inherits(cond, "condition")) {
[08:26:46.638]                         if (!is.null(pattern)) {
[08:26:46.638]                           computeRestarts <- base::computeRestarts
[08:26:46.638]                           grepl <- base::grepl
[08:26:46.638]                           restarts <- computeRestarts(cond)
[08:26:46.638]                           for (restart in restarts) {
[08:26:46.638]                             name <- restart$name
[08:26:46.638]                             if (is.null(name)) 
[08:26:46.638]                               next
[08:26:46.638]                             if (!grepl(pattern, name)) 
[08:26:46.638]                               next
[08:26:46.638]                             invokeRestart(restart)
[08:26:46.638]                             muffled <- TRUE
[08:26:46.638]                             break
[08:26:46.638]                           }
[08:26:46.638]                         }
[08:26:46.638]                       }
[08:26:46.638]                       invisible(muffled)
[08:26:46.638]                     }
[08:26:46.638]                     muffleCondition(cond, pattern = "^muffle")
[08:26:46.638]                   }
[08:26:46.638]                 }
[08:26:46.638]                 else {
[08:26:46.638]                   if (TRUE) {
[08:26:46.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:46.638]                     {
[08:26:46.638]                       inherits <- base::inherits
[08:26:46.638]                       invokeRestart <- base::invokeRestart
[08:26:46.638]                       is.null <- base::is.null
[08:26:46.638]                       muffled <- FALSE
[08:26:46.638]                       if (inherits(cond, "message")) {
[08:26:46.638]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:46.638]                         if (muffled) 
[08:26:46.638]                           invokeRestart("muffleMessage")
[08:26:46.638]                       }
[08:26:46.638]                       else if (inherits(cond, "warning")) {
[08:26:46.638]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:46.638]                         if (muffled) 
[08:26:46.638]                           invokeRestart("muffleWarning")
[08:26:46.638]                       }
[08:26:46.638]                       else if (inherits(cond, "condition")) {
[08:26:46.638]                         if (!is.null(pattern)) {
[08:26:46.638]                           computeRestarts <- base::computeRestarts
[08:26:46.638]                           grepl <- base::grepl
[08:26:46.638]                           restarts <- computeRestarts(cond)
[08:26:46.638]                           for (restart in restarts) {
[08:26:46.638]                             name <- restart$name
[08:26:46.638]                             if (is.null(name)) 
[08:26:46.638]                               next
[08:26:46.638]                             if (!grepl(pattern, name)) 
[08:26:46.638]                               next
[08:26:46.638]                             invokeRestart(restart)
[08:26:46.638]                             muffled <- TRUE
[08:26:46.638]                             break
[08:26:46.638]                           }
[08:26:46.638]                         }
[08:26:46.638]                       }
[08:26:46.638]                       invisible(muffled)
[08:26:46.638]                     }
[08:26:46.638]                     muffleCondition(cond, pattern = "^muffle")
[08:26:46.638]                   }
[08:26:46.638]                 }
[08:26:46.638]             }
[08:26:46.638]         }))
[08:26:46.638]     }, error = function(ex) {
[08:26:46.638]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:46.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:46.638]                 ...future.rng), started = ...future.startTime, 
[08:26:46.638]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:46.638]             version = "1.8"), class = "FutureResult")
[08:26:46.638]     }, finally = {
[08:26:46.638]         if (!identical(...future.workdir, getwd())) 
[08:26:46.638]             setwd(...future.workdir)
[08:26:46.638]         {
[08:26:46.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:46.638]                 ...future.oldOptions$nwarnings <- NULL
[08:26:46.638]             }
[08:26:46.638]             base::options(...future.oldOptions)
[08:26:46.638]             if (.Platform$OS.type == "windows") {
[08:26:46.638]                 old_names <- names(...future.oldEnvVars)
[08:26:46.638]                 envs <- base::Sys.getenv()
[08:26:46.638]                 names <- names(envs)
[08:26:46.638]                 common <- intersect(names, old_names)
[08:26:46.638]                 added <- setdiff(names, old_names)
[08:26:46.638]                 removed <- setdiff(old_names, names)
[08:26:46.638]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:46.638]                   envs[common]]
[08:26:46.638]                 NAMES <- toupper(changed)
[08:26:46.638]                 args <- list()
[08:26:46.638]                 for (kk in seq_along(NAMES)) {
[08:26:46.638]                   name <- changed[[kk]]
[08:26:46.638]                   NAME <- NAMES[[kk]]
[08:26:46.638]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:46.638]                     next
[08:26:46.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:46.638]                 }
[08:26:46.638]                 NAMES <- toupper(added)
[08:26:46.638]                 for (kk in seq_along(NAMES)) {
[08:26:46.638]                   name <- added[[kk]]
[08:26:46.638]                   NAME <- NAMES[[kk]]
[08:26:46.638]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:46.638]                     next
[08:26:46.638]                   args[[name]] <- ""
[08:26:46.638]                 }
[08:26:46.638]                 NAMES <- toupper(removed)
[08:26:46.638]                 for (kk in seq_along(NAMES)) {
[08:26:46.638]                   name <- removed[[kk]]
[08:26:46.638]                   NAME <- NAMES[[kk]]
[08:26:46.638]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:46.638]                     next
[08:26:46.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:46.638]                 }
[08:26:46.638]                 if (length(args) > 0) 
[08:26:46.638]                   base::do.call(base::Sys.setenv, args = args)
[08:26:46.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:46.638]             }
[08:26:46.638]             else {
[08:26:46.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:46.638]             }
[08:26:46.638]             {
[08:26:46.638]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:46.638]                   0L) {
[08:26:46.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:46.638]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:46.638]                   base::options(opts)
[08:26:46.638]                 }
[08:26:46.638]                 {
[08:26:46.638]                   {
[08:26:46.638]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:46.638]                     NULL
[08:26:46.638]                   }
[08:26:46.638]                   options(future.plan = NULL)
[08:26:46.638]                   if (is.na(NA_character_)) 
[08:26:46.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:46.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:46.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:46.638]                     .init = FALSE)
[08:26:46.638]                 }
[08:26:46.638]             }
[08:26:46.638]         }
[08:26:46.638]     })
[08:26:46.638]     if (TRUE) {
[08:26:46.638]         base::sink(type = "output", split = FALSE)
[08:26:46.638]         if (TRUE) {
[08:26:46.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:46.638]         }
[08:26:46.638]         else {
[08:26:46.638]             ...future.result["stdout"] <- base::list(NULL)
[08:26:46.638]         }
[08:26:46.638]         base::close(...future.stdout)
[08:26:46.638]         ...future.stdout <- NULL
[08:26:46.638]     }
[08:26:46.638]     ...future.result$conditions <- ...future.conditions
[08:26:46.638]     ...future.result$finished <- base::Sys.time()
[08:26:46.638]     ...future.result
[08:26:46.638] }
[08:26:46.697] MultisessionFuture started
[08:26:46.697] result() for ClusterFuture ...
[08:26:46.698] receiveMessageFromWorker() for ClusterFuture ...
[08:26:46.698] - Validating connection of MultisessionFuture
[08:26:46.731] - received message: FutureResult
[08:26:46.731] - Received FutureResult
[08:26:46.731] - Erased future from FutureRegistry
[08:26:46.732] result() for ClusterFuture ...
[08:26:46.732] - result already collected: FutureResult
[08:26:46.732] result() for ClusterFuture ... done
[08:26:46.732] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:46.732] result() for ClusterFuture ... done
[08:26:46.732] result() for ClusterFuture ...
[08:26:46.732] - result already collected: FutureResult
[08:26:46.732] result() for ClusterFuture ... done
[08:26:46.732] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:26:46.734] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[08:26:46.734] future_lapply() ...
[08:26:46.737] Number of chunks: 2
[08:26:46.737] getGlobalsAndPackagesXApply() ...
[08:26:46.737]  - future.globals: TRUE
[08:26:46.737] getGlobalsAndPackages() ...
[08:26:46.737] Searching for globals...
[08:26:46.739] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:46.739] Searching for globals ... DONE
[08:26:46.739] Resolving globals: FALSE
[08:26:46.739] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:46.740] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:46.740] - globals: [1] ‘FUN’
[08:26:46.740] 
[08:26:46.740] getGlobalsAndPackages() ... DONE
[08:26:46.740]  - globals found/used: [n=1] ‘FUN’
[08:26:46.740]  - needed namespaces: [n=0] 
[08:26:46.740] Finding globals ... DONE
[08:26:46.740]  - use_args: TRUE
[08:26:46.740]  - Getting '...' globals ...
[08:26:46.741] resolve() on list ...
[08:26:46.741]  recursive: 0
[08:26:46.741]  length: 1
[08:26:46.741]  elements: ‘...’
[08:26:46.741]  length: 0 (resolved future 1)
[08:26:46.741] resolve() on list ... DONE
[08:26:46.741]    - '...' content: [n=0] 
[08:26:46.741] List of 1
[08:26:46.741]  $ ...: list()
[08:26:46.741]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:46.741]  - attr(*, "where")=List of 1
[08:26:46.741]   ..$ ...:<environment: 0x55e10e82e128> 
[08:26:46.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:46.741]  - attr(*, "resolved")= logi TRUE
[08:26:46.741]  - attr(*, "total_size")= num NA
[08:26:46.744]  - Getting '...' globals ... DONE
[08:26:46.744] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:46.744] List of 2
[08:26:46.744]  $ ...future.FUN:function (x)  
[08:26:46.744]  $ ...          : list()
[08:26:46.744]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:46.744]  - attr(*, "where")=List of 2
[08:26:46.744]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:46.744]   ..$ ...          :<environment: 0x55e10e82e128> 
[08:26:46.744]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:46.744]  - attr(*, "resolved")= logi FALSE
[08:26:46.744]  - attr(*, "total_size")= num 5632
[08:26:46.747] Packages to be attached in all futures: [n=0] 
[08:26:46.747] getGlobalsAndPackagesXApply() ... DONE
[08:26:46.747] Number of futures (= number of chunks): 2
[08:26:46.747] Launching 2 futures (chunks) ...
[08:26:46.748] Chunk #1 of 2 ...
[08:26:46.748]  - Finding globals in 'X' for chunk #1 ...
[08:26:46.748] getGlobalsAndPackages() ...
[08:26:46.748] Searching for globals...
[08:26:46.748] 
[08:26:46.748] Searching for globals ... DONE
[08:26:46.748] - globals: [0] <none>
[08:26:46.748] getGlobalsAndPackages() ... DONE
[08:26:46.749]    + additional globals found: [n=0] 
[08:26:46.749]    + additional namespaces needed: [n=0] 
[08:26:46.749]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:46.749]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:46.749]  - seeds: <none>
[08:26:46.749]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:46.749] getGlobalsAndPackages() ...
[08:26:46.749] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:46.749] Resolving globals: FALSE
[08:26:46.749] Tweak future expression to call with '...' arguments ...
[08:26:46.750] {
[08:26:46.750]     do.call(function(...) {
[08:26:46.750]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:46.750]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:46.750]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:46.750]             on.exit(options(oopts), add = TRUE)
[08:26:46.750]         }
[08:26:46.750]         {
[08:26:46.750]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:46.750]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:46.750]                 ...future.FUN(...future.X_jj, ...)
[08:26:46.750]             })
[08:26:46.750]         }
[08:26:46.750]     }, args = future.call.arguments)
[08:26:46.750] }
[08:26:46.750] Tweak future expression to call with '...' arguments ... DONE
[08:26:46.750] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:46.750] 
[08:26:46.750] getGlobalsAndPackages() ... DONE
[08:26:46.751] run() for ‘Future’ ...
[08:26:46.751] - state: ‘created’
[08:26:46.751] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:46.767] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:46.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:46.767]   - Field: ‘node’
[08:26:46.767]   - Field: ‘label’
[08:26:46.767]   - Field: ‘local’
[08:26:46.767]   - Field: ‘owner’
[08:26:46.767]   - Field: ‘envir’
[08:26:46.767]   - Field: ‘workers’
[08:26:46.768]   - Field: ‘packages’
[08:26:46.768]   - Field: ‘gc’
[08:26:46.768]   - Field: ‘conditions’
[08:26:46.768]   - Field: ‘persistent’
[08:26:46.768]   - Field: ‘expr’
[08:26:46.768]   - Field: ‘uuid’
[08:26:46.768]   - Field: ‘seed’
[08:26:46.768]   - Field: ‘version’
[08:26:46.768]   - Field: ‘result’
[08:26:46.769]   - Field: ‘asynchronous’
[08:26:46.769]   - Field: ‘calls’
[08:26:46.769]   - Field: ‘globals’
[08:26:46.769]   - Field: ‘stdout’
[08:26:46.769]   - Field: ‘earlySignal’
[08:26:46.769]   - Field: ‘lazy’
[08:26:46.769]   - Field: ‘state’
[08:26:46.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:46.769] - Launch lazy future ...
[08:26:46.770] Packages needed by the future expression (n = 0): <none>
[08:26:46.770] Packages needed by future strategies (n = 0): <none>
[08:26:46.771] {
[08:26:46.771]     {
[08:26:46.771]         {
[08:26:46.771]             ...future.startTime <- base::Sys.time()
[08:26:46.771]             {
[08:26:46.771]                 {
[08:26:46.771]                   {
[08:26:46.771]                     {
[08:26:46.771]                       base::local({
[08:26:46.771]                         has_future <- base::requireNamespace("future", 
[08:26:46.771]                           quietly = TRUE)
[08:26:46.771]                         if (has_future) {
[08:26:46.771]                           ns <- base::getNamespace("future")
[08:26:46.771]                           version <- ns[[".package"]][["version"]]
[08:26:46.771]                           if (is.null(version)) 
[08:26:46.771]                             version <- utils::packageVersion("future")
[08:26:46.771]                         }
[08:26:46.771]                         else {
[08:26:46.771]                           version <- NULL
[08:26:46.771]                         }
[08:26:46.771]                         if (!has_future || version < "1.8.0") {
[08:26:46.771]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:46.771]                             "", base::R.version$version.string), 
[08:26:46.771]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:46.771]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:46.771]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:46.771]                               "release", "version")], collapse = " "), 
[08:26:46.771]                             hostname = base::Sys.info()[["nodename"]])
[08:26:46.771]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:46.771]                             info)
[08:26:46.771]                           info <- base::paste(info, collapse = "; ")
[08:26:46.771]                           if (!has_future) {
[08:26:46.771]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:46.771]                               info)
[08:26:46.771]                           }
[08:26:46.771]                           else {
[08:26:46.771]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:46.771]                               info, version)
[08:26:46.771]                           }
[08:26:46.771]                           base::stop(msg)
[08:26:46.771]                         }
[08:26:46.771]                       })
[08:26:46.771]                     }
[08:26:46.771]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:46.771]                     base::options(mc.cores = 1L)
[08:26:46.771]                   }
[08:26:46.771]                   ...future.strategy.old <- future::plan("list")
[08:26:46.771]                   options(future.plan = NULL)
[08:26:46.771]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:46.771]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:46.771]                 }
[08:26:46.771]                 ...future.workdir <- getwd()
[08:26:46.771]             }
[08:26:46.771]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:46.771]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:46.771]         }
[08:26:46.771]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:46.771]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:46.771]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:46.771]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:46.771]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:46.771]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:46.771]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:46.771]             base::names(...future.oldOptions))
[08:26:46.771]     }
[08:26:46.771]     if (FALSE) {
[08:26:46.771]     }
[08:26:46.771]     else {
[08:26:46.771]         if (FALSE) {
[08:26:46.771]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:46.771]                 open = "w")
[08:26:46.771]         }
[08:26:46.771]         else {
[08:26:46.771]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:46.771]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:46.771]         }
[08:26:46.771]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:46.771]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:46.771]             base::sink(type = "output", split = FALSE)
[08:26:46.771]             base::close(...future.stdout)
[08:26:46.771]         }, add = TRUE)
[08:26:46.771]     }
[08:26:46.771]     ...future.frame <- base::sys.nframe()
[08:26:46.771]     ...future.conditions <- base::list()
[08:26:46.771]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:46.771]     if (FALSE) {
[08:26:46.771]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:46.771]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:46.771]     }
[08:26:46.771]     ...future.result <- base::tryCatch({
[08:26:46.771]         base::withCallingHandlers({
[08:26:46.771]             ...future.value <- base::withVisible(base::local({
[08:26:46.771]                 ...future.makeSendCondition <- base::local({
[08:26:46.771]                   sendCondition <- NULL
[08:26:46.771]                   function(frame = 1L) {
[08:26:46.771]                     if (is.function(sendCondition)) 
[08:26:46.771]                       return(sendCondition)
[08:26:46.771]                     ns <- getNamespace("parallel")
[08:26:46.771]                     if (exists("sendData", mode = "function", 
[08:26:46.771]                       envir = ns)) {
[08:26:46.771]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:46.771]                         envir = ns)
[08:26:46.771]                       envir <- sys.frame(frame)
[08:26:46.771]                       master <- NULL
[08:26:46.771]                       while (!identical(envir, .GlobalEnv) && 
[08:26:46.771]                         !identical(envir, emptyenv())) {
[08:26:46.771]                         if (exists("master", mode = "list", envir = envir, 
[08:26:46.771]                           inherits = FALSE)) {
[08:26:46.771]                           master <- get("master", mode = "list", 
[08:26:46.771]                             envir = envir, inherits = FALSE)
[08:26:46.771]                           if (inherits(master, c("SOCKnode", 
[08:26:46.771]                             "SOCK0node"))) {
[08:26:46.771]                             sendCondition <<- function(cond) {
[08:26:46.771]                               data <- list(type = "VALUE", value = cond, 
[08:26:46.771]                                 success = TRUE)
[08:26:46.771]                               parallel_sendData(master, data)
[08:26:46.771]                             }
[08:26:46.771]                             return(sendCondition)
[08:26:46.771]                           }
[08:26:46.771]                         }
[08:26:46.771]                         frame <- frame + 1L
[08:26:46.771]                         envir <- sys.frame(frame)
[08:26:46.771]                       }
[08:26:46.771]                     }
[08:26:46.771]                     sendCondition <<- function(cond) NULL
[08:26:46.771]                   }
[08:26:46.771]                 })
[08:26:46.771]                 withCallingHandlers({
[08:26:46.771]                   {
[08:26:46.771]                     do.call(function(...) {
[08:26:46.771]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:46.771]                       if (!identical(...future.globals.maxSize.org, 
[08:26:46.771]                         ...future.globals.maxSize)) {
[08:26:46.771]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:46.771]                         on.exit(options(oopts), add = TRUE)
[08:26:46.771]                       }
[08:26:46.771]                       {
[08:26:46.771]                         lapply(seq_along(...future.elements_ii), 
[08:26:46.771]                           FUN = function(jj) {
[08:26:46.771]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:46.771]                             ...future.FUN(...future.X_jj, ...)
[08:26:46.771]                           })
[08:26:46.771]                       }
[08:26:46.771]                     }, args = future.call.arguments)
[08:26:46.771]                   }
[08:26:46.771]                 }, immediateCondition = function(cond) {
[08:26:46.771]                   sendCondition <- ...future.makeSendCondition()
[08:26:46.771]                   sendCondition(cond)
[08:26:46.771]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:46.771]                   {
[08:26:46.771]                     inherits <- base::inherits
[08:26:46.771]                     invokeRestart <- base::invokeRestart
[08:26:46.771]                     is.null <- base::is.null
[08:26:46.771]                     muffled <- FALSE
[08:26:46.771]                     if (inherits(cond, "message")) {
[08:26:46.771]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:46.771]                       if (muffled) 
[08:26:46.771]                         invokeRestart("muffleMessage")
[08:26:46.771]                     }
[08:26:46.771]                     else if (inherits(cond, "warning")) {
[08:26:46.771]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:46.771]                       if (muffled) 
[08:26:46.771]                         invokeRestart("muffleWarning")
[08:26:46.771]                     }
[08:26:46.771]                     else if (inherits(cond, "condition")) {
[08:26:46.771]                       if (!is.null(pattern)) {
[08:26:46.771]                         computeRestarts <- base::computeRestarts
[08:26:46.771]                         grepl <- base::grepl
[08:26:46.771]                         restarts <- computeRestarts(cond)
[08:26:46.771]                         for (restart in restarts) {
[08:26:46.771]                           name <- restart$name
[08:26:46.771]                           if (is.null(name)) 
[08:26:46.771]                             next
[08:26:46.771]                           if (!grepl(pattern, name)) 
[08:26:46.771]                             next
[08:26:46.771]                           invokeRestart(restart)
[08:26:46.771]                           muffled <- TRUE
[08:26:46.771]                           break
[08:26:46.771]                         }
[08:26:46.771]                       }
[08:26:46.771]                     }
[08:26:46.771]                     invisible(muffled)
[08:26:46.771]                   }
[08:26:46.771]                   muffleCondition(cond)
[08:26:46.771]                 })
[08:26:46.771]             }))
[08:26:46.771]             future::FutureResult(value = ...future.value$value, 
[08:26:46.771]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:46.771]                   ...future.rng), globalenv = if (FALSE) 
[08:26:46.771]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:46.771]                     ...future.globalenv.names))
[08:26:46.771]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:46.771]         }, condition = base::local({
[08:26:46.771]             c <- base::c
[08:26:46.771]             inherits <- base::inherits
[08:26:46.771]             invokeRestart <- base::invokeRestart
[08:26:46.771]             length <- base::length
[08:26:46.771]             list <- base::list
[08:26:46.771]             seq.int <- base::seq.int
[08:26:46.771]             signalCondition <- base::signalCondition
[08:26:46.771]             sys.calls <- base::sys.calls
[08:26:46.771]             `[[` <- base::`[[`
[08:26:46.771]             `+` <- base::`+`
[08:26:46.771]             `<<-` <- base::`<<-`
[08:26:46.771]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:46.771]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:46.771]                   3L)]
[08:26:46.771]             }
[08:26:46.771]             function(cond) {
[08:26:46.771]                 is_error <- inherits(cond, "error")
[08:26:46.771]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:46.771]                   NULL)
[08:26:46.771]                 if (is_error) {
[08:26:46.771]                   sessionInformation <- function() {
[08:26:46.771]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:46.771]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:46.771]                       search = base::search(), system = base::Sys.info())
[08:26:46.771]                   }
[08:26:46.771]                   ...future.conditions[[length(...future.conditions) + 
[08:26:46.771]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:46.771]                     cond$call), session = sessionInformation(), 
[08:26:46.771]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:46.771]                   signalCondition(cond)
[08:26:46.771]                 }
[08:26:46.771]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:46.771]                 "immediateCondition"))) {
[08:26:46.771]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:46.771]                   ...future.conditions[[length(...future.conditions) + 
[08:26:46.771]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:46.771]                   if (TRUE && !signal) {
[08:26:46.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:46.771]                     {
[08:26:46.771]                       inherits <- base::inherits
[08:26:46.771]                       invokeRestart <- base::invokeRestart
[08:26:46.771]                       is.null <- base::is.null
[08:26:46.771]                       muffled <- FALSE
[08:26:46.771]                       if (inherits(cond, "message")) {
[08:26:46.771]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:46.771]                         if (muffled) 
[08:26:46.771]                           invokeRestart("muffleMessage")
[08:26:46.771]                       }
[08:26:46.771]                       else if (inherits(cond, "warning")) {
[08:26:46.771]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:46.771]                         if (muffled) 
[08:26:46.771]                           invokeRestart("muffleWarning")
[08:26:46.771]                       }
[08:26:46.771]                       else if (inherits(cond, "condition")) {
[08:26:46.771]                         if (!is.null(pattern)) {
[08:26:46.771]                           computeRestarts <- base::computeRestarts
[08:26:46.771]                           grepl <- base::grepl
[08:26:46.771]                           restarts <- computeRestarts(cond)
[08:26:46.771]                           for (restart in restarts) {
[08:26:46.771]                             name <- restart$name
[08:26:46.771]                             if (is.null(name)) 
[08:26:46.771]                               next
[08:26:46.771]                             if (!grepl(pattern, name)) 
[08:26:46.771]                               next
[08:26:46.771]                             invokeRestart(restart)
[08:26:46.771]                             muffled <- TRUE
[08:26:46.771]                             break
[08:26:46.771]                           }
[08:26:46.771]                         }
[08:26:46.771]                       }
[08:26:46.771]                       invisible(muffled)
[08:26:46.771]                     }
[08:26:46.771]                     muffleCondition(cond, pattern = "^muffle")
[08:26:46.771]                   }
[08:26:46.771]                 }
[08:26:46.771]                 else {
[08:26:46.771]                   if (TRUE) {
[08:26:46.771]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:46.771]                     {
[08:26:46.771]                       inherits <- base::inherits
[08:26:46.771]                       invokeRestart <- base::invokeRestart
[08:26:46.771]                       is.null <- base::is.null
[08:26:46.771]                       muffled <- FALSE
[08:26:46.771]                       if (inherits(cond, "message")) {
[08:26:46.771]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:46.771]                         if (muffled) 
[08:26:46.771]                           invokeRestart("muffleMessage")
[08:26:46.771]                       }
[08:26:46.771]                       else if (inherits(cond, "warning")) {
[08:26:46.771]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:46.771]                         if (muffled) 
[08:26:46.771]                           invokeRestart("muffleWarning")
[08:26:46.771]                       }
[08:26:46.771]                       else if (inherits(cond, "condition")) {
[08:26:46.771]                         if (!is.null(pattern)) {
[08:26:46.771]                           computeRestarts <- base::computeRestarts
[08:26:46.771]                           grepl <- base::grepl
[08:26:46.771]                           restarts <- computeRestarts(cond)
[08:26:46.771]                           for (restart in restarts) {
[08:26:46.771]                             name <- restart$name
[08:26:46.771]                             if (is.null(name)) 
[08:26:46.771]                               next
[08:26:46.771]                             if (!grepl(pattern, name)) 
[08:26:46.771]                               next
[08:26:46.771]                             invokeRestart(restart)
[08:26:46.771]                             muffled <- TRUE
[08:26:46.771]                             break
[08:26:46.771]                           }
[08:26:46.771]                         }
[08:26:46.771]                       }
[08:26:46.771]                       invisible(muffled)
[08:26:46.771]                     }
[08:26:46.771]                     muffleCondition(cond, pattern = "^muffle")
[08:26:46.771]                   }
[08:26:46.771]                 }
[08:26:46.771]             }
[08:26:46.771]         }))
[08:26:46.771]     }, error = function(ex) {
[08:26:46.771]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:46.771]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:46.771]                 ...future.rng), started = ...future.startTime, 
[08:26:46.771]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:46.771]             version = "1.8"), class = "FutureResult")
[08:26:46.771]     }, finally = {
[08:26:46.771]         if (!identical(...future.workdir, getwd())) 
[08:26:46.771]             setwd(...future.workdir)
[08:26:46.771]         {
[08:26:46.771]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:46.771]                 ...future.oldOptions$nwarnings <- NULL
[08:26:46.771]             }
[08:26:46.771]             base::options(...future.oldOptions)
[08:26:46.771]             if (.Platform$OS.type == "windows") {
[08:26:46.771]                 old_names <- names(...future.oldEnvVars)
[08:26:46.771]                 envs <- base::Sys.getenv()
[08:26:46.771]                 names <- names(envs)
[08:26:46.771]                 common <- intersect(names, old_names)
[08:26:46.771]                 added <- setdiff(names, old_names)
[08:26:46.771]                 removed <- setdiff(old_names, names)
[08:26:46.771]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:46.771]                   envs[common]]
[08:26:46.771]                 NAMES <- toupper(changed)
[08:26:46.771]                 args <- list()
[08:26:46.771]                 for (kk in seq_along(NAMES)) {
[08:26:46.771]                   name <- changed[[kk]]
[08:26:46.771]                   NAME <- NAMES[[kk]]
[08:26:46.771]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:46.771]                     next
[08:26:46.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:46.771]                 }
[08:26:46.771]                 NAMES <- toupper(added)
[08:26:46.771]                 for (kk in seq_along(NAMES)) {
[08:26:46.771]                   name <- added[[kk]]
[08:26:46.771]                   NAME <- NAMES[[kk]]
[08:26:46.771]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:46.771]                     next
[08:26:46.771]                   args[[name]] <- ""
[08:26:46.771]                 }
[08:26:46.771]                 NAMES <- toupper(removed)
[08:26:46.771]                 for (kk in seq_along(NAMES)) {
[08:26:46.771]                   name <- removed[[kk]]
[08:26:46.771]                   NAME <- NAMES[[kk]]
[08:26:46.771]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:46.771]                     next
[08:26:46.771]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:46.771]                 }
[08:26:46.771]                 if (length(args) > 0) 
[08:26:46.771]                   base::do.call(base::Sys.setenv, args = args)
[08:26:46.771]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:46.771]             }
[08:26:46.771]             else {
[08:26:46.771]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:46.771]             }
[08:26:46.771]             {
[08:26:46.771]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:46.771]                   0L) {
[08:26:46.771]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:46.771]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:46.771]                   base::options(opts)
[08:26:46.771]                 }
[08:26:46.771]                 {
[08:26:46.771]                   {
[08:26:46.771]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:46.771]                     NULL
[08:26:46.771]                   }
[08:26:46.771]                   options(future.plan = NULL)
[08:26:46.771]                   if (is.na(NA_character_)) 
[08:26:46.771]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:46.771]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:46.771]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:46.771]                     .init = FALSE)
[08:26:46.771]                 }
[08:26:46.771]             }
[08:26:46.771]         }
[08:26:46.771]     })
[08:26:46.771]     if (TRUE) {
[08:26:46.771]         base::sink(type = "output", split = FALSE)
[08:26:46.771]         if (FALSE) {
[08:26:46.771]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:46.771]         }
[08:26:46.771]         else {
[08:26:46.771]             ...future.result["stdout"] <- base::list(NULL)
[08:26:46.771]         }
[08:26:46.771]         base::close(...future.stdout)
[08:26:46.771]         ...future.stdout <- NULL
[08:26:46.771]     }
[08:26:46.771]     ...future.result$conditions <- ...future.conditions
[08:26:46.771]     ...future.result$finished <- base::Sys.time()
[08:26:46.771]     ...future.result
[08:26:46.771] }
[08:26:46.774] Exporting 5 global objects (1.46 KiB) to cluster node #1 ...
[08:26:46.774] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ...
[08:26:46.775] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ... DONE
[08:26:46.775] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:46.775] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:46.776] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[08:26:46.776] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[08:26:46.776] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:46.777] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:46.777] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:46.777] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:46.777] Exporting 5 global objects (1.46 KiB) to cluster node #1 ... DONE
[08:26:46.778] MultisessionFuture started
[08:26:46.778] - Launch lazy future ... done
[08:26:46.778] run() for ‘MultisessionFuture’ ... done
[08:26:46.779] Created future:
[08:26:46.779] MultisessionFuture:
[08:26:46.779] Label: ‘future_lapply-1’
[08:26:46.779] Expression:
[08:26:46.779] {
[08:26:46.779]     do.call(function(...) {
[08:26:46.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:46.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:46.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:46.779]             on.exit(options(oopts), add = TRUE)
[08:26:46.779]         }
[08:26:46.779]         {
[08:26:46.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:46.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:46.779]                 ...future.FUN(...future.X_jj, ...)
[08:26:46.779]             })
[08:26:46.779]         }
[08:26:46.779]     }, args = future.call.arguments)
[08:26:46.779] }
[08:26:46.779] Lazy evaluation: FALSE
[08:26:46.779] Asynchronous evaluation: TRUE
[08:26:46.779] Local evaluation: TRUE
[08:26:46.779] Environment: R_GlobalEnv
[08:26:46.779] Capture standard output: FALSE
[08:26:46.779] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:46.779] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:46.779] Packages: <none>
[08:26:46.779] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:46.779] Resolved: FALSE
[08:26:46.779] Value: <not collected>
[08:26:46.779] Conditions captured: <none>
[08:26:46.779] Early signaling: FALSE
[08:26:46.779] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:46.779] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:46.791] Chunk #1 of 2 ... DONE
[08:26:46.791] Chunk #2 of 2 ...
[08:26:46.791]  - Finding globals in 'X' for chunk #2 ...
[08:26:46.791] getGlobalsAndPackages() ...
[08:26:46.792] Searching for globals...
[08:26:46.792] 
[08:26:46.792] Searching for globals ... DONE
[08:26:46.792] - globals: [0] <none>
[08:26:46.792] getGlobalsAndPackages() ... DONE
[08:26:46.792]    + additional globals found: [n=0] 
[08:26:46.793]    + additional namespaces needed: [n=0] 
[08:26:46.793]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:46.793]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:46.793]  - seeds: <none>
[08:26:46.793]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:46.793] getGlobalsAndPackages() ...
[08:26:46.793] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:46.793] Resolving globals: FALSE
[08:26:46.794] Tweak future expression to call with '...' arguments ...
[08:26:46.794] {
[08:26:46.794]     do.call(function(...) {
[08:26:46.794]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:46.794]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:46.794]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:46.794]             on.exit(options(oopts), add = TRUE)
[08:26:46.794]         }
[08:26:46.794]         {
[08:26:46.794]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:46.794]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:46.794]                 ...future.FUN(...future.X_jj, ...)
[08:26:46.794]             })
[08:26:46.794]         }
[08:26:46.794]     }, args = future.call.arguments)
[08:26:46.794] }
[08:26:46.794] Tweak future expression to call with '...' arguments ... DONE
[08:26:46.795] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:46.795] 
[08:26:46.795] getGlobalsAndPackages() ... DONE
[08:26:46.795] run() for ‘Future’ ...
[08:26:46.795] - state: ‘created’
[08:26:46.796] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:46.811] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:46.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:46.812]   - Field: ‘node’
[08:26:46.812]   - Field: ‘label’
[08:26:46.812]   - Field: ‘local’
[08:26:46.812]   - Field: ‘owner’
[08:26:46.812]   - Field: ‘envir’
[08:26:46.812]   - Field: ‘workers’
[08:26:46.812]   - Field: ‘packages’
[08:26:46.812]   - Field: ‘gc’
[08:26:46.812]   - Field: ‘conditions’
[08:26:46.812]   - Field: ‘persistent’
[08:26:46.813]   - Field: ‘expr’
[08:26:46.813]   - Field: ‘uuid’
[08:26:46.813]   - Field: ‘seed’
[08:26:46.813]   - Field: ‘version’
[08:26:46.813]   - Field: ‘result’
[08:26:46.813]   - Field: ‘asynchronous’
[08:26:46.813]   - Field: ‘calls’
[08:26:46.813]   - Field: ‘globals’
[08:26:46.814]   - Field: ‘stdout’
[08:26:46.814]   - Field: ‘earlySignal’
[08:26:46.814]   - Field: ‘lazy’
[08:26:46.814]   - Field: ‘state’
[08:26:46.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:46.814] - Launch lazy future ...
[08:26:46.815] Packages needed by the future expression (n = 0): <none>
[08:26:46.815] Packages needed by future strategies (n = 0): <none>
[08:26:46.815] {
[08:26:46.815]     {
[08:26:46.815]         {
[08:26:46.815]             ...future.startTime <- base::Sys.time()
[08:26:46.815]             {
[08:26:46.815]                 {
[08:26:46.815]                   {
[08:26:46.815]                     {
[08:26:46.815]                       base::local({
[08:26:46.815]                         has_future <- base::requireNamespace("future", 
[08:26:46.815]                           quietly = TRUE)
[08:26:46.815]                         if (has_future) {
[08:26:46.815]                           ns <- base::getNamespace("future")
[08:26:46.815]                           version <- ns[[".package"]][["version"]]
[08:26:46.815]                           if (is.null(version)) 
[08:26:46.815]                             version <- utils::packageVersion("future")
[08:26:46.815]                         }
[08:26:46.815]                         else {
[08:26:46.815]                           version <- NULL
[08:26:46.815]                         }
[08:26:46.815]                         if (!has_future || version < "1.8.0") {
[08:26:46.815]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:46.815]                             "", base::R.version$version.string), 
[08:26:46.815]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:46.815]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:46.815]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:46.815]                               "release", "version")], collapse = " "), 
[08:26:46.815]                             hostname = base::Sys.info()[["nodename"]])
[08:26:46.815]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:46.815]                             info)
[08:26:46.815]                           info <- base::paste(info, collapse = "; ")
[08:26:46.815]                           if (!has_future) {
[08:26:46.815]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:46.815]                               info)
[08:26:46.815]                           }
[08:26:46.815]                           else {
[08:26:46.815]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:46.815]                               info, version)
[08:26:46.815]                           }
[08:26:46.815]                           base::stop(msg)
[08:26:46.815]                         }
[08:26:46.815]                       })
[08:26:46.815]                     }
[08:26:46.815]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:46.815]                     base::options(mc.cores = 1L)
[08:26:46.815]                   }
[08:26:46.815]                   ...future.strategy.old <- future::plan("list")
[08:26:46.815]                   options(future.plan = NULL)
[08:26:46.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:46.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:46.815]                 }
[08:26:46.815]                 ...future.workdir <- getwd()
[08:26:46.815]             }
[08:26:46.815]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:46.815]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:46.815]         }
[08:26:46.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:46.815]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:46.815]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:46.815]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:46.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:46.815]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:46.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:46.815]             base::names(...future.oldOptions))
[08:26:46.815]     }
[08:26:46.815]     if (FALSE) {
[08:26:46.815]     }
[08:26:46.815]     else {
[08:26:46.815]         if (FALSE) {
[08:26:46.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:46.815]                 open = "w")
[08:26:46.815]         }
[08:26:46.815]         else {
[08:26:46.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:46.815]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:46.815]         }
[08:26:46.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:46.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:46.815]             base::sink(type = "output", split = FALSE)
[08:26:46.815]             base::close(...future.stdout)
[08:26:46.815]         }, add = TRUE)
[08:26:46.815]     }
[08:26:46.815]     ...future.frame <- base::sys.nframe()
[08:26:46.815]     ...future.conditions <- base::list()
[08:26:46.815]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:46.815]     if (FALSE) {
[08:26:46.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:46.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:46.815]     }
[08:26:46.815]     ...future.result <- base::tryCatch({
[08:26:46.815]         base::withCallingHandlers({
[08:26:46.815]             ...future.value <- base::withVisible(base::local({
[08:26:46.815]                 ...future.makeSendCondition <- base::local({
[08:26:46.815]                   sendCondition <- NULL
[08:26:46.815]                   function(frame = 1L) {
[08:26:46.815]                     if (is.function(sendCondition)) 
[08:26:46.815]                       return(sendCondition)
[08:26:46.815]                     ns <- getNamespace("parallel")
[08:26:46.815]                     if (exists("sendData", mode = "function", 
[08:26:46.815]                       envir = ns)) {
[08:26:46.815]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:46.815]                         envir = ns)
[08:26:46.815]                       envir <- sys.frame(frame)
[08:26:46.815]                       master <- NULL
[08:26:46.815]                       while (!identical(envir, .GlobalEnv) && 
[08:26:46.815]                         !identical(envir, emptyenv())) {
[08:26:46.815]                         if (exists("master", mode = "list", envir = envir, 
[08:26:46.815]                           inherits = FALSE)) {
[08:26:46.815]                           master <- get("master", mode = "list", 
[08:26:46.815]                             envir = envir, inherits = FALSE)
[08:26:46.815]                           if (inherits(master, c("SOCKnode", 
[08:26:46.815]                             "SOCK0node"))) {
[08:26:46.815]                             sendCondition <<- function(cond) {
[08:26:46.815]                               data <- list(type = "VALUE", value = cond, 
[08:26:46.815]                                 success = TRUE)
[08:26:46.815]                               parallel_sendData(master, data)
[08:26:46.815]                             }
[08:26:46.815]                             return(sendCondition)
[08:26:46.815]                           }
[08:26:46.815]                         }
[08:26:46.815]                         frame <- frame + 1L
[08:26:46.815]                         envir <- sys.frame(frame)
[08:26:46.815]                       }
[08:26:46.815]                     }
[08:26:46.815]                     sendCondition <<- function(cond) NULL
[08:26:46.815]                   }
[08:26:46.815]                 })
[08:26:46.815]                 withCallingHandlers({
[08:26:46.815]                   {
[08:26:46.815]                     do.call(function(...) {
[08:26:46.815]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:46.815]                       if (!identical(...future.globals.maxSize.org, 
[08:26:46.815]                         ...future.globals.maxSize)) {
[08:26:46.815]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:46.815]                         on.exit(options(oopts), add = TRUE)
[08:26:46.815]                       }
[08:26:46.815]                       {
[08:26:46.815]                         lapply(seq_along(...future.elements_ii), 
[08:26:46.815]                           FUN = function(jj) {
[08:26:46.815]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:46.815]                             ...future.FUN(...future.X_jj, ...)
[08:26:46.815]                           })
[08:26:46.815]                       }
[08:26:46.815]                     }, args = future.call.arguments)
[08:26:46.815]                   }
[08:26:46.815]                 }, immediateCondition = function(cond) {
[08:26:46.815]                   sendCondition <- ...future.makeSendCondition()
[08:26:46.815]                   sendCondition(cond)
[08:26:46.815]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:46.815]                   {
[08:26:46.815]                     inherits <- base::inherits
[08:26:46.815]                     invokeRestart <- base::invokeRestart
[08:26:46.815]                     is.null <- base::is.null
[08:26:46.815]                     muffled <- FALSE
[08:26:46.815]                     if (inherits(cond, "message")) {
[08:26:46.815]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:46.815]                       if (muffled) 
[08:26:46.815]                         invokeRestart("muffleMessage")
[08:26:46.815]                     }
[08:26:46.815]                     else if (inherits(cond, "warning")) {
[08:26:46.815]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:46.815]                       if (muffled) 
[08:26:46.815]                         invokeRestart("muffleWarning")
[08:26:46.815]                     }
[08:26:46.815]                     else if (inherits(cond, "condition")) {
[08:26:46.815]                       if (!is.null(pattern)) {
[08:26:46.815]                         computeRestarts <- base::computeRestarts
[08:26:46.815]                         grepl <- base::grepl
[08:26:46.815]                         restarts <- computeRestarts(cond)
[08:26:46.815]                         for (restart in restarts) {
[08:26:46.815]                           name <- restart$name
[08:26:46.815]                           if (is.null(name)) 
[08:26:46.815]                             next
[08:26:46.815]                           if (!grepl(pattern, name)) 
[08:26:46.815]                             next
[08:26:46.815]                           invokeRestart(restart)
[08:26:46.815]                           muffled <- TRUE
[08:26:46.815]                           break
[08:26:46.815]                         }
[08:26:46.815]                       }
[08:26:46.815]                     }
[08:26:46.815]                     invisible(muffled)
[08:26:46.815]                   }
[08:26:46.815]                   muffleCondition(cond)
[08:26:46.815]                 })
[08:26:46.815]             }))
[08:26:46.815]             future::FutureResult(value = ...future.value$value, 
[08:26:46.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:46.815]                   ...future.rng), globalenv = if (FALSE) 
[08:26:46.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:46.815]                     ...future.globalenv.names))
[08:26:46.815]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:46.815]         }, condition = base::local({
[08:26:46.815]             c <- base::c
[08:26:46.815]             inherits <- base::inherits
[08:26:46.815]             invokeRestart <- base::invokeRestart
[08:26:46.815]             length <- base::length
[08:26:46.815]             list <- base::list
[08:26:46.815]             seq.int <- base::seq.int
[08:26:46.815]             signalCondition <- base::signalCondition
[08:26:46.815]             sys.calls <- base::sys.calls
[08:26:46.815]             `[[` <- base::`[[`
[08:26:46.815]             `+` <- base::`+`
[08:26:46.815]             `<<-` <- base::`<<-`
[08:26:46.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:46.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:46.815]                   3L)]
[08:26:46.815]             }
[08:26:46.815]             function(cond) {
[08:26:46.815]                 is_error <- inherits(cond, "error")
[08:26:46.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:46.815]                   NULL)
[08:26:46.815]                 if (is_error) {
[08:26:46.815]                   sessionInformation <- function() {
[08:26:46.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:46.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:46.815]                       search = base::search(), system = base::Sys.info())
[08:26:46.815]                   }
[08:26:46.815]                   ...future.conditions[[length(...future.conditions) + 
[08:26:46.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:46.815]                     cond$call), session = sessionInformation(), 
[08:26:46.815]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:46.815]                   signalCondition(cond)
[08:26:46.815]                 }
[08:26:46.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:46.815]                 "immediateCondition"))) {
[08:26:46.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:46.815]                   ...future.conditions[[length(...future.conditions) + 
[08:26:46.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:46.815]                   if (TRUE && !signal) {
[08:26:46.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:46.815]                     {
[08:26:46.815]                       inherits <- base::inherits
[08:26:46.815]                       invokeRestart <- base::invokeRestart
[08:26:46.815]                       is.null <- base::is.null
[08:26:46.815]                       muffled <- FALSE
[08:26:46.815]                       if (inherits(cond, "message")) {
[08:26:46.815]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:46.815]                         if (muffled) 
[08:26:46.815]                           invokeRestart("muffleMessage")
[08:26:46.815]                       }
[08:26:46.815]                       else if (inherits(cond, "warning")) {
[08:26:46.815]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:46.815]                         if (muffled) 
[08:26:46.815]                           invokeRestart("muffleWarning")
[08:26:46.815]                       }
[08:26:46.815]                       else if (inherits(cond, "condition")) {
[08:26:46.815]                         if (!is.null(pattern)) {
[08:26:46.815]                           computeRestarts <- base::computeRestarts
[08:26:46.815]                           grepl <- base::grepl
[08:26:46.815]                           restarts <- computeRestarts(cond)
[08:26:46.815]                           for (restart in restarts) {
[08:26:46.815]                             name <- restart$name
[08:26:46.815]                             if (is.null(name)) 
[08:26:46.815]                               next
[08:26:46.815]                             if (!grepl(pattern, name)) 
[08:26:46.815]                               next
[08:26:46.815]                             invokeRestart(restart)
[08:26:46.815]                             muffled <- TRUE
[08:26:46.815]                             break
[08:26:46.815]                           }
[08:26:46.815]                         }
[08:26:46.815]                       }
[08:26:46.815]                       invisible(muffled)
[08:26:46.815]                     }
[08:26:46.815]                     muffleCondition(cond, pattern = "^muffle")
[08:26:46.815]                   }
[08:26:46.815]                 }
[08:26:46.815]                 else {
[08:26:46.815]                   if (TRUE) {
[08:26:46.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:46.815]                     {
[08:26:46.815]                       inherits <- base::inherits
[08:26:46.815]                       invokeRestart <- base::invokeRestart
[08:26:46.815]                       is.null <- base::is.null
[08:26:46.815]                       muffled <- FALSE
[08:26:46.815]                       if (inherits(cond, "message")) {
[08:26:46.815]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:46.815]                         if (muffled) 
[08:26:46.815]                           invokeRestart("muffleMessage")
[08:26:46.815]                       }
[08:26:46.815]                       else if (inherits(cond, "warning")) {
[08:26:46.815]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:46.815]                         if (muffled) 
[08:26:46.815]                           invokeRestart("muffleWarning")
[08:26:46.815]                       }
[08:26:46.815]                       else if (inherits(cond, "condition")) {
[08:26:46.815]                         if (!is.null(pattern)) {
[08:26:46.815]                           computeRestarts <- base::computeRestarts
[08:26:46.815]                           grepl <- base::grepl
[08:26:46.815]                           restarts <- computeRestarts(cond)
[08:26:46.815]                           for (restart in restarts) {
[08:26:46.815]                             name <- restart$name
[08:26:46.815]                             if (is.null(name)) 
[08:26:46.815]                               next
[08:26:46.815]                             if (!grepl(pattern, name)) 
[08:26:46.815]                               next
[08:26:46.815]                             invokeRestart(restart)
[08:26:46.815]                             muffled <- TRUE
[08:26:46.815]                             break
[08:26:46.815]                           }
[08:26:46.815]                         }
[08:26:46.815]                       }
[08:26:46.815]                       invisible(muffled)
[08:26:46.815]                     }
[08:26:46.815]                     muffleCondition(cond, pattern = "^muffle")
[08:26:46.815]                   }
[08:26:46.815]                 }
[08:26:46.815]             }
[08:26:46.815]         }))
[08:26:46.815]     }, error = function(ex) {
[08:26:46.815]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:46.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:46.815]                 ...future.rng), started = ...future.startTime, 
[08:26:46.815]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:46.815]             version = "1.8"), class = "FutureResult")
[08:26:46.815]     }, finally = {
[08:26:46.815]         if (!identical(...future.workdir, getwd())) 
[08:26:46.815]             setwd(...future.workdir)
[08:26:46.815]         {
[08:26:46.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:46.815]                 ...future.oldOptions$nwarnings <- NULL
[08:26:46.815]             }
[08:26:46.815]             base::options(...future.oldOptions)
[08:26:46.815]             if (.Platform$OS.type == "windows") {
[08:26:46.815]                 old_names <- names(...future.oldEnvVars)
[08:26:46.815]                 envs <- base::Sys.getenv()
[08:26:46.815]                 names <- names(envs)
[08:26:46.815]                 common <- intersect(names, old_names)
[08:26:46.815]                 added <- setdiff(names, old_names)
[08:26:46.815]                 removed <- setdiff(old_names, names)
[08:26:46.815]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:46.815]                   envs[common]]
[08:26:46.815]                 NAMES <- toupper(changed)
[08:26:46.815]                 args <- list()
[08:26:46.815]                 for (kk in seq_along(NAMES)) {
[08:26:46.815]                   name <- changed[[kk]]
[08:26:46.815]                   NAME <- NAMES[[kk]]
[08:26:46.815]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:46.815]                     next
[08:26:46.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:46.815]                 }
[08:26:46.815]                 NAMES <- toupper(added)
[08:26:46.815]                 for (kk in seq_along(NAMES)) {
[08:26:46.815]                   name <- added[[kk]]
[08:26:46.815]                   NAME <- NAMES[[kk]]
[08:26:46.815]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:46.815]                     next
[08:26:46.815]                   args[[name]] <- ""
[08:26:46.815]                 }
[08:26:46.815]                 NAMES <- toupper(removed)
[08:26:46.815]                 for (kk in seq_along(NAMES)) {
[08:26:46.815]                   name <- removed[[kk]]
[08:26:46.815]                   NAME <- NAMES[[kk]]
[08:26:46.815]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:46.815]                     next
[08:26:46.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:46.815]                 }
[08:26:46.815]                 if (length(args) > 0) 
[08:26:46.815]                   base::do.call(base::Sys.setenv, args = args)
[08:26:46.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:46.815]             }
[08:26:46.815]             else {
[08:26:46.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:46.815]             }
[08:26:46.815]             {
[08:26:46.815]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:46.815]                   0L) {
[08:26:46.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:46.815]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:46.815]                   base::options(opts)
[08:26:46.815]                 }
[08:26:46.815]                 {
[08:26:46.815]                   {
[08:26:46.815]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:46.815]                     NULL
[08:26:46.815]                   }
[08:26:46.815]                   options(future.plan = NULL)
[08:26:46.815]                   if (is.na(NA_character_)) 
[08:26:46.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:46.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:46.815]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:46.815]                     .init = FALSE)
[08:26:46.815]                 }
[08:26:46.815]             }
[08:26:46.815]         }
[08:26:46.815]     })
[08:26:46.815]     if (TRUE) {
[08:26:46.815]         base::sink(type = "output", split = FALSE)
[08:26:46.815]         if (FALSE) {
[08:26:46.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:46.815]         }
[08:26:46.815]         else {
[08:26:46.815]             ...future.result["stdout"] <- base::list(NULL)
[08:26:46.815]         }
[08:26:46.815]         base::close(...future.stdout)
[08:26:46.815]         ...future.stdout <- NULL
[08:26:46.815]     }
[08:26:46.815]     ...future.result$conditions <- ...future.conditions
[08:26:46.815]     ...future.result$finished <- base::Sys.time()
[08:26:46.815]     ...future.result
[08:26:46.815] }
[08:26:46.872] Exporting 5 global objects (1.46 KiB) to cluster node #2 ...
[08:26:46.872] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ...
[08:26:46.873] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ... DONE
[08:26:46.873] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:46.873] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:46.873] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[08:26:46.874] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[08:26:46.874] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:46.874] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:46.874] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:46.875] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:46.875] Exporting 5 global objects (1.46 KiB) to cluster node #2 ... DONE
[08:26:46.876] MultisessionFuture started
[08:26:46.876] - Launch lazy future ... done
[08:26:46.876] run() for ‘MultisessionFuture’ ... done
[08:26:46.876] Created future:
[08:26:46.876] MultisessionFuture:
[08:26:46.876] Label: ‘future_lapply-2’
[08:26:46.876] Expression:
[08:26:46.876] {
[08:26:46.876]     do.call(function(...) {
[08:26:46.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:46.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:46.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:46.876]             on.exit(options(oopts), add = TRUE)
[08:26:46.876]         }
[08:26:46.876]         {
[08:26:46.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:46.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:46.876]                 ...future.FUN(...future.X_jj, ...)
[08:26:46.876]             })
[08:26:46.876]         }
[08:26:46.876]     }, args = future.call.arguments)
[08:26:46.876] }
[08:26:46.876] Lazy evaluation: FALSE
[08:26:46.876] Asynchronous evaluation: TRUE
[08:26:46.876] Local evaluation: TRUE
[08:26:46.876] Environment: R_GlobalEnv
[08:26:46.876] Capture standard output: FALSE
[08:26:46.876] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:46.876] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:46.876] Packages: <none>
[08:26:46.876] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:46.876] Resolved: FALSE
[08:26:46.876] Value: <not collected>
[08:26:46.876] Conditions captured: <none>
[08:26:46.876] Early signaling: FALSE
[08:26:46.876] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:46.876] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:46.888] Chunk #2 of 2 ... DONE
[08:26:46.888] Launching 2 futures (chunks) ... DONE
[08:26:46.888] Resolving 2 futures (chunks) ...
[08:26:46.889] resolve() on list ...
[08:26:46.889]  recursive: 0
[08:26:46.889]  length: 2
[08:26:46.889] 
[08:26:46.964] receiveMessageFromWorker() for ClusterFuture ...
[08:26:46.964] - Validating connection of MultisessionFuture
[08:26:46.965] - received message: FutureResult
[08:26:46.965] - Received FutureResult
[08:26:46.965] - Erased future from FutureRegistry
[08:26:46.965] result() for ClusterFuture ...
[08:26:46.965] - result already collected: FutureResult
[08:26:46.965] result() for ClusterFuture ... done
[08:26:46.965] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:46.966] Future #2
[08:26:46.966] result() for ClusterFuture ...
[08:26:46.966] - result already collected: FutureResult
[08:26:46.966] result() for ClusterFuture ... done
[08:26:46.966] result() for ClusterFuture ...
[08:26:46.966] - result already collected: FutureResult
[08:26:46.966] result() for ClusterFuture ... done
[08:26:46.966] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:46.966] - nx: 2
[08:26:46.967] - relay: TRUE
[08:26:46.967] - stdout: TRUE
[08:26:46.967] - signal: TRUE
[08:26:46.967] - resignal: FALSE
[08:26:46.967] - force: TRUE
[08:26:46.967] - relayed: [n=2] FALSE, FALSE
[08:26:46.967] - queued futures: [n=2] FALSE, FALSE
[08:26:46.967]  - until=1
[08:26:46.967]  - relaying element #1
[08:26:46.967] - relayed: [n=2] FALSE, FALSE
[08:26:46.968] - queued futures: [n=2] FALSE, TRUE
[08:26:46.968] signalConditionsASAP(NULL, pos=2) ... done
[08:26:46.968]  length: 1 (resolved future 2)
[08:26:47.325] receiveMessageFromWorker() for ClusterFuture ...
[08:26:47.325] - Validating connection of MultisessionFuture
[08:26:47.326] - received message: FutureResult
[08:26:47.326] - Received FutureResult
[08:26:47.326] - Erased future from FutureRegistry
[08:26:47.326] result() for ClusterFuture ...
[08:26:47.326] - result already collected: FutureResult
[08:26:47.326] result() for ClusterFuture ... done
[08:26:47.326] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:47.327] Future #1
[08:26:47.327] result() for ClusterFuture ...
[08:26:47.327] - result already collected: FutureResult
[08:26:47.327] result() for ClusterFuture ... done
[08:26:47.327] result() for ClusterFuture ...
[08:26:47.327] - result already collected: FutureResult
[08:26:47.327] result() for ClusterFuture ... done
[08:26:47.327] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:47.327] - nx: 2
[08:26:47.328] - relay: TRUE
[08:26:47.328] - stdout: TRUE
[08:26:47.328] - signal: TRUE
[08:26:47.328] - resignal: FALSE
[08:26:47.328] - force: TRUE
[08:26:47.328] - relayed: [n=2] FALSE, FALSE
[08:26:47.328] - queued futures: [n=2] FALSE, TRUE
[08:26:47.328]  - until=1
[08:26:47.328]  - relaying element #1
[08:26:47.328] result() for ClusterFuture ...
[08:26:47.329] - result already collected: FutureResult
[08:26:47.329] result() for ClusterFuture ... done
[08:26:47.329] result() for ClusterFuture ...
[08:26:47.329] - result already collected: FutureResult
[08:26:47.329] result() for ClusterFuture ... done
[08:26:47.329] result() for ClusterFuture ...
[08:26:47.329] - result already collected: FutureResult
[08:26:47.329] result() for ClusterFuture ... done
[08:26:47.329] result() for ClusterFuture ...
[08:26:47.329] - result already collected: FutureResult
[08:26:47.330] result() for ClusterFuture ... done
[08:26:47.330] - relayed: [n=2] TRUE, FALSE
[08:26:47.330] - queued futures: [n=2] TRUE, TRUE
[08:26:47.330] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:47.330]  length: 0 (resolved future 1)
[08:26:47.330] Relaying remaining futures
[08:26:47.330] signalConditionsASAP(NULL, pos=0) ...
[08:26:47.330] - nx: 2
[08:26:47.330] - relay: TRUE
[08:26:47.331] - stdout: TRUE
[08:26:47.331] - signal: TRUE
[08:26:47.331] - resignal: FALSE
[08:26:47.331] - force: TRUE
[08:26:47.331] - relayed: [n=2] TRUE, FALSE
[08:26:47.331] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:47.331]  - relaying element #2
[08:26:47.331] result() for ClusterFuture ...
[08:26:47.331] - result already collected: FutureResult
[08:26:47.331] result() for ClusterFuture ... done
[08:26:47.332] result() for ClusterFuture ...
[08:26:47.332] - result already collected: FutureResult
[08:26:47.332] result() for ClusterFuture ... done
[08:26:47.332] result() for ClusterFuture ...
[08:26:47.332] - result already collected: FutureResult
[08:26:47.332] result() for ClusterFuture ... done
[08:26:47.332] result() for ClusterFuture ...
[08:26:47.332] - result already collected: FutureResult
[08:26:47.333] result() for ClusterFuture ... done
[08:26:47.333] - relayed: [n=2] TRUE, TRUE
[08:26:47.333] - queued futures: [n=2] TRUE, TRUE
[08:26:47.333] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[08:26:47.333] resolve() on list ... DONE
[08:26:47.333] result() for ClusterFuture ...
[08:26:47.333] - result already collected: FutureResult
[08:26:47.333] result() for ClusterFuture ... done
[08:26:47.333] result() for ClusterFuture ...
[08:26:47.334] - result already collected: FutureResult
[08:26:47.334] result() for ClusterFuture ... done
[08:26:47.334] result() for ClusterFuture ...
[08:26:47.334] - result already collected: FutureResult
[08:26:47.334] result() for ClusterFuture ... done
[08:26:47.334] result() for ClusterFuture ...
[08:26:47.334] - result already collected: FutureResult
[08:26:47.334] result() for ClusterFuture ... done
[08:26:47.334]  - Number of value chunks collected: 2
[08:26:47.335] Resolving 2 futures (chunks) ... DONE
[08:26:47.335] Reducing values from 2 chunks ...
[08:26:47.335]  - Number of values collected after concatenation: 2
[08:26:47.335]  - Number of values expected: 2
[08:26:47.335] Reducing values from 2 chunks ... DONE
[08:26:47.335] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[08:26:47.336] future_lapply() ...
[08:26:47.338] Number of chunks: 2
[08:26:47.339] getGlobalsAndPackagesXApply() ...
[08:26:47.339]  - future.globals: TRUE
[08:26:47.339] getGlobalsAndPackages() ...
[08:26:47.339] Searching for globals...
[08:26:47.341] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:47.341] Searching for globals ... DONE
[08:26:47.341] Resolving globals: FALSE
[08:26:47.342] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:47.342] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:47.342] - globals: [1] ‘FUN’
[08:26:47.342] 
[08:26:47.342] getGlobalsAndPackages() ... DONE
[08:26:47.342]  - globals found/used: [n=1] ‘FUN’
[08:26:47.343]  - needed namespaces: [n=0] 
[08:26:47.343] Finding globals ... DONE
[08:26:47.343]  - use_args: TRUE
[08:26:47.343]  - Getting '...' globals ...
[08:26:47.343] resolve() on list ...
[08:26:47.343]  recursive: 0
[08:26:47.344]  length: 1
[08:26:47.344]  elements: ‘...’
[08:26:47.344]  length: 0 (resolved future 1)
[08:26:47.344] resolve() on list ... DONE
[08:26:47.344]    - '...' content: [n=0] 
[08:26:47.344] List of 1
[08:26:47.344]  $ ...: list()
[08:26:47.344]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:47.344]  - attr(*, "where")=List of 1
[08:26:47.344]   ..$ ...:<environment: 0x55e110e9cc38> 
[08:26:47.344]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:47.344]  - attr(*, "resolved")= logi TRUE
[08:26:47.344]  - attr(*, "total_size")= num NA
[08:26:47.350]  - Getting '...' globals ... DONE
[08:26:47.350] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:47.350] List of 2
[08:26:47.350]  $ ...future.FUN:function (x)  
[08:26:47.350]  $ ...          : list()
[08:26:47.350]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:47.350]  - attr(*, "where")=List of 2
[08:26:47.350]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:47.350]   ..$ ...          :<environment: 0x55e110e9cc38> 
[08:26:47.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:47.350]  - attr(*, "resolved")= logi FALSE
[08:26:47.350]  - attr(*, "total_size")= num 5632
[08:26:47.353] Packages to be attached in all futures: [n=0] 
[08:26:47.353] getGlobalsAndPackagesXApply() ... DONE
[08:26:47.353] Number of futures (= number of chunks): 2
[08:26:47.353] Launching 2 futures (chunks) ...
[08:26:47.353] Chunk #1 of 2 ...
[08:26:47.353]  - Finding globals in 'X' for chunk #1 ...
[08:26:47.354] getGlobalsAndPackages() ...
[08:26:47.354] Searching for globals...
[08:26:47.354] 
[08:26:47.354] Searching for globals ... DONE
[08:26:47.354] - globals: [0] <none>
[08:26:47.354] getGlobalsAndPackages() ... DONE
[08:26:47.354]    + additional globals found: [n=0] 
[08:26:47.354]    + additional namespaces needed: [n=0] 
[08:26:47.354]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:47.355]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:47.355]  - seeds: <none>
[08:26:47.355]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.355] getGlobalsAndPackages() ...
[08:26:47.355] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.355] Resolving globals: FALSE
[08:26:47.355] Tweak future expression to call with '...' arguments ...
[08:26:47.355] {
[08:26:47.355]     do.call(function(...) {
[08:26:47.355]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.355]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:47.355]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.355]             on.exit(options(oopts), add = TRUE)
[08:26:47.355]         }
[08:26:47.355]         {
[08:26:47.355]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:47.355]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.355]                 ...future.FUN(...future.X_jj, ...)
[08:26:47.355]             })
[08:26:47.355]         }
[08:26:47.355]     }, args = future.call.arguments)
[08:26:47.355] }
[08:26:47.355] Tweak future expression to call with '...' arguments ... DONE
[08:26:47.356] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.356] 
[08:26:47.356] getGlobalsAndPackages() ... DONE
[08:26:47.356] run() for ‘Future’ ...
[08:26:47.356] - state: ‘created’
[08:26:47.357] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:47.371] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:47.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:47.371]   - Field: ‘node’
[08:26:47.371]   - Field: ‘label’
[08:26:47.371]   - Field: ‘local’
[08:26:47.371]   - Field: ‘owner’
[08:26:47.371]   - Field: ‘envir’
[08:26:47.372]   - Field: ‘workers’
[08:26:47.372]   - Field: ‘packages’
[08:26:47.372]   - Field: ‘gc’
[08:26:47.372]   - Field: ‘conditions’
[08:26:47.372]   - Field: ‘persistent’
[08:26:47.372]   - Field: ‘expr’
[08:26:47.372]   - Field: ‘uuid’
[08:26:47.372]   - Field: ‘seed’
[08:26:47.372]   - Field: ‘version’
[08:26:47.372]   - Field: ‘result’
[08:26:47.372]   - Field: ‘asynchronous’
[08:26:47.372]   - Field: ‘calls’
[08:26:47.373]   - Field: ‘globals’
[08:26:47.373]   - Field: ‘stdout’
[08:26:47.373]   - Field: ‘earlySignal’
[08:26:47.373]   - Field: ‘lazy’
[08:26:47.373]   - Field: ‘state’
[08:26:47.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:47.373] - Launch lazy future ...
[08:26:47.373] Packages needed by the future expression (n = 0): <none>
[08:26:47.374] Packages needed by future strategies (n = 0): <none>
[08:26:47.374] {
[08:26:47.374]     {
[08:26:47.374]         {
[08:26:47.374]             ...future.startTime <- base::Sys.time()
[08:26:47.374]             {
[08:26:47.374]                 {
[08:26:47.374]                   {
[08:26:47.374]                     {
[08:26:47.374]                       base::local({
[08:26:47.374]                         has_future <- base::requireNamespace("future", 
[08:26:47.374]                           quietly = TRUE)
[08:26:47.374]                         if (has_future) {
[08:26:47.374]                           ns <- base::getNamespace("future")
[08:26:47.374]                           version <- ns[[".package"]][["version"]]
[08:26:47.374]                           if (is.null(version)) 
[08:26:47.374]                             version <- utils::packageVersion("future")
[08:26:47.374]                         }
[08:26:47.374]                         else {
[08:26:47.374]                           version <- NULL
[08:26:47.374]                         }
[08:26:47.374]                         if (!has_future || version < "1.8.0") {
[08:26:47.374]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:47.374]                             "", base::R.version$version.string), 
[08:26:47.374]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:47.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:47.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:47.374]                               "release", "version")], collapse = " "), 
[08:26:47.374]                             hostname = base::Sys.info()[["nodename"]])
[08:26:47.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:47.374]                             info)
[08:26:47.374]                           info <- base::paste(info, collapse = "; ")
[08:26:47.374]                           if (!has_future) {
[08:26:47.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:47.374]                               info)
[08:26:47.374]                           }
[08:26:47.374]                           else {
[08:26:47.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:47.374]                               info, version)
[08:26:47.374]                           }
[08:26:47.374]                           base::stop(msg)
[08:26:47.374]                         }
[08:26:47.374]                       })
[08:26:47.374]                     }
[08:26:47.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:47.374]                     base::options(mc.cores = 1L)
[08:26:47.374]                   }
[08:26:47.374]                   ...future.strategy.old <- future::plan("list")
[08:26:47.374]                   options(future.plan = NULL)
[08:26:47.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:47.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:47.374]                 }
[08:26:47.374]                 ...future.workdir <- getwd()
[08:26:47.374]             }
[08:26:47.374]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:47.374]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:47.374]         }
[08:26:47.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:47.374]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:47.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:47.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:47.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:47.374]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:47.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:47.374]             base::names(...future.oldOptions))
[08:26:47.374]     }
[08:26:47.374]     if (FALSE) {
[08:26:47.374]     }
[08:26:47.374]     else {
[08:26:47.374]         if (TRUE) {
[08:26:47.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:47.374]                 open = "w")
[08:26:47.374]         }
[08:26:47.374]         else {
[08:26:47.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:47.374]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:47.374]         }
[08:26:47.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:47.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:47.374]             base::sink(type = "output", split = FALSE)
[08:26:47.374]             base::close(...future.stdout)
[08:26:47.374]         }, add = TRUE)
[08:26:47.374]     }
[08:26:47.374]     ...future.frame <- base::sys.nframe()
[08:26:47.374]     ...future.conditions <- base::list()
[08:26:47.374]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:47.374]     if (FALSE) {
[08:26:47.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:47.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:47.374]     }
[08:26:47.374]     ...future.result <- base::tryCatch({
[08:26:47.374]         base::withCallingHandlers({
[08:26:47.374]             ...future.value <- base::withVisible(base::local({
[08:26:47.374]                 ...future.makeSendCondition <- base::local({
[08:26:47.374]                   sendCondition <- NULL
[08:26:47.374]                   function(frame = 1L) {
[08:26:47.374]                     if (is.function(sendCondition)) 
[08:26:47.374]                       return(sendCondition)
[08:26:47.374]                     ns <- getNamespace("parallel")
[08:26:47.374]                     if (exists("sendData", mode = "function", 
[08:26:47.374]                       envir = ns)) {
[08:26:47.374]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:47.374]                         envir = ns)
[08:26:47.374]                       envir <- sys.frame(frame)
[08:26:47.374]                       master <- NULL
[08:26:47.374]                       while (!identical(envir, .GlobalEnv) && 
[08:26:47.374]                         !identical(envir, emptyenv())) {
[08:26:47.374]                         if (exists("master", mode = "list", envir = envir, 
[08:26:47.374]                           inherits = FALSE)) {
[08:26:47.374]                           master <- get("master", mode = "list", 
[08:26:47.374]                             envir = envir, inherits = FALSE)
[08:26:47.374]                           if (inherits(master, c("SOCKnode", 
[08:26:47.374]                             "SOCK0node"))) {
[08:26:47.374]                             sendCondition <<- function(cond) {
[08:26:47.374]                               data <- list(type = "VALUE", value = cond, 
[08:26:47.374]                                 success = TRUE)
[08:26:47.374]                               parallel_sendData(master, data)
[08:26:47.374]                             }
[08:26:47.374]                             return(sendCondition)
[08:26:47.374]                           }
[08:26:47.374]                         }
[08:26:47.374]                         frame <- frame + 1L
[08:26:47.374]                         envir <- sys.frame(frame)
[08:26:47.374]                       }
[08:26:47.374]                     }
[08:26:47.374]                     sendCondition <<- function(cond) NULL
[08:26:47.374]                   }
[08:26:47.374]                 })
[08:26:47.374]                 withCallingHandlers({
[08:26:47.374]                   {
[08:26:47.374]                     do.call(function(...) {
[08:26:47.374]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.374]                       if (!identical(...future.globals.maxSize.org, 
[08:26:47.374]                         ...future.globals.maxSize)) {
[08:26:47.374]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.374]                         on.exit(options(oopts), add = TRUE)
[08:26:47.374]                       }
[08:26:47.374]                       {
[08:26:47.374]                         lapply(seq_along(...future.elements_ii), 
[08:26:47.374]                           FUN = function(jj) {
[08:26:47.374]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.374]                             ...future.FUN(...future.X_jj, ...)
[08:26:47.374]                           })
[08:26:47.374]                       }
[08:26:47.374]                     }, args = future.call.arguments)
[08:26:47.374]                   }
[08:26:47.374]                 }, immediateCondition = function(cond) {
[08:26:47.374]                   sendCondition <- ...future.makeSendCondition()
[08:26:47.374]                   sendCondition(cond)
[08:26:47.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:47.374]                   {
[08:26:47.374]                     inherits <- base::inherits
[08:26:47.374]                     invokeRestart <- base::invokeRestart
[08:26:47.374]                     is.null <- base::is.null
[08:26:47.374]                     muffled <- FALSE
[08:26:47.374]                     if (inherits(cond, "message")) {
[08:26:47.374]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:47.374]                       if (muffled) 
[08:26:47.374]                         invokeRestart("muffleMessage")
[08:26:47.374]                     }
[08:26:47.374]                     else if (inherits(cond, "warning")) {
[08:26:47.374]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:47.374]                       if (muffled) 
[08:26:47.374]                         invokeRestart("muffleWarning")
[08:26:47.374]                     }
[08:26:47.374]                     else if (inherits(cond, "condition")) {
[08:26:47.374]                       if (!is.null(pattern)) {
[08:26:47.374]                         computeRestarts <- base::computeRestarts
[08:26:47.374]                         grepl <- base::grepl
[08:26:47.374]                         restarts <- computeRestarts(cond)
[08:26:47.374]                         for (restart in restarts) {
[08:26:47.374]                           name <- restart$name
[08:26:47.374]                           if (is.null(name)) 
[08:26:47.374]                             next
[08:26:47.374]                           if (!grepl(pattern, name)) 
[08:26:47.374]                             next
[08:26:47.374]                           invokeRestart(restart)
[08:26:47.374]                           muffled <- TRUE
[08:26:47.374]                           break
[08:26:47.374]                         }
[08:26:47.374]                       }
[08:26:47.374]                     }
[08:26:47.374]                     invisible(muffled)
[08:26:47.374]                   }
[08:26:47.374]                   muffleCondition(cond)
[08:26:47.374]                 })
[08:26:47.374]             }))
[08:26:47.374]             future::FutureResult(value = ...future.value$value, 
[08:26:47.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:47.374]                   ...future.rng), globalenv = if (FALSE) 
[08:26:47.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:47.374]                     ...future.globalenv.names))
[08:26:47.374]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:47.374]         }, condition = base::local({
[08:26:47.374]             c <- base::c
[08:26:47.374]             inherits <- base::inherits
[08:26:47.374]             invokeRestart <- base::invokeRestart
[08:26:47.374]             length <- base::length
[08:26:47.374]             list <- base::list
[08:26:47.374]             seq.int <- base::seq.int
[08:26:47.374]             signalCondition <- base::signalCondition
[08:26:47.374]             sys.calls <- base::sys.calls
[08:26:47.374]             `[[` <- base::`[[`
[08:26:47.374]             `+` <- base::`+`
[08:26:47.374]             `<<-` <- base::`<<-`
[08:26:47.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:47.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:47.374]                   3L)]
[08:26:47.374]             }
[08:26:47.374]             function(cond) {
[08:26:47.374]                 is_error <- inherits(cond, "error")
[08:26:47.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:47.374]                   NULL)
[08:26:47.374]                 if (is_error) {
[08:26:47.374]                   sessionInformation <- function() {
[08:26:47.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:47.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:47.374]                       search = base::search(), system = base::Sys.info())
[08:26:47.374]                   }
[08:26:47.374]                   ...future.conditions[[length(...future.conditions) + 
[08:26:47.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:47.374]                     cond$call), session = sessionInformation(), 
[08:26:47.374]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:47.374]                   signalCondition(cond)
[08:26:47.374]                 }
[08:26:47.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:47.374]                 "immediateCondition"))) {
[08:26:47.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:47.374]                   ...future.conditions[[length(...future.conditions) + 
[08:26:47.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:47.374]                   if (TRUE && !signal) {
[08:26:47.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:47.374]                     {
[08:26:47.374]                       inherits <- base::inherits
[08:26:47.374]                       invokeRestart <- base::invokeRestart
[08:26:47.374]                       is.null <- base::is.null
[08:26:47.374]                       muffled <- FALSE
[08:26:47.374]                       if (inherits(cond, "message")) {
[08:26:47.374]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:47.374]                         if (muffled) 
[08:26:47.374]                           invokeRestart("muffleMessage")
[08:26:47.374]                       }
[08:26:47.374]                       else if (inherits(cond, "warning")) {
[08:26:47.374]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:47.374]                         if (muffled) 
[08:26:47.374]                           invokeRestart("muffleWarning")
[08:26:47.374]                       }
[08:26:47.374]                       else if (inherits(cond, "condition")) {
[08:26:47.374]                         if (!is.null(pattern)) {
[08:26:47.374]                           computeRestarts <- base::computeRestarts
[08:26:47.374]                           grepl <- base::grepl
[08:26:47.374]                           restarts <- computeRestarts(cond)
[08:26:47.374]                           for (restart in restarts) {
[08:26:47.374]                             name <- restart$name
[08:26:47.374]                             if (is.null(name)) 
[08:26:47.374]                               next
[08:26:47.374]                             if (!grepl(pattern, name)) 
[08:26:47.374]                               next
[08:26:47.374]                             invokeRestart(restart)
[08:26:47.374]                             muffled <- TRUE
[08:26:47.374]                             break
[08:26:47.374]                           }
[08:26:47.374]                         }
[08:26:47.374]                       }
[08:26:47.374]                       invisible(muffled)
[08:26:47.374]                     }
[08:26:47.374]                     muffleCondition(cond, pattern = "^muffle")
[08:26:47.374]                   }
[08:26:47.374]                 }
[08:26:47.374]                 else {
[08:26:47.374]                   if (TRUE) {
[08:26:47.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:47.374]                     {
[08:26:47.374]                       inherits <- base::inherits
[08:26:47.374]                       invokeRestart <- base::invokeRestart
[08:26:47.374]                       is.null <- base::is.null
[08:26:47.374]                       muffled <- FALSE
[08:26:47.374]                       if (inherits(cond, "message")) {
[08:26:47.374]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:47.374]                         if (muffled) 
[08:26:47.374]                           invokeRestart("muffleMessage")
[08:26:47.374]                       }
[08:26:47.374]                       else if (inherits(cond, "warning")) {
[08:26:47.374]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:47.374]                         if (muffled) 
[08:26:47.374]                           invokeRestart("muffleWarning")
[08:26:47.374]                       }
[08:26:47.374]                       else if (inherits(cond, "condition")) {
[08:26:47.374]                         if (!is.null(pattern)) {
[08:26:47.374]                           computeRestarts <- base::computeRestarts
[08:26:47.374]                           grepl <- base::grepl
[08:26:47.374]                           restarts <- computeRestarts(cond)
[08:26:47.374]                           for (restart in restarts) {
[08:26:47.374]                             name <- restart$name
[08:26:47.374]                             if (is.null(name)) 
[08:26:47.374]                               next
[08:26:47.374]                             if (!grepl(pattern, name)) 
[08:26:47.374]                               next
[08:26:47.374]                             invokeRestart(restart)
[08:26:47.374]                             muffled <- TRUE
[08:26:47.374]                             break
[08:26:47.374]                           }
[08:26:47.374]                         }
[08:26:47.374]                       }
[08:26:47.374]                       invisible(muffled)
[08:26:47.374]                     }
[08:26:47.374]                     muffleCondition(cond, pattern = "^muffle")
[08:26:47.374]                   }
[08:26:47.374]                 }
[08:26:47.374]             }
[08:26:47.374]         }))
[08:26:47.374]     }, error = function(ex) {
[08:26:47.374]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:47.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:47.374]                 ...future.rng), started = ...future.startTime, 
[08:26:47.374]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:47.374]             version = "1.8"), class = "FutureResult")
[08:26:47.374]     }, finally = {
[08:26:47.374]         if (!identical(...future.workdir, getwd())) 
[08:26:47.374]             setwd(...future.workdir)
[08:26:47.374]         {
[08:26:47.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:47.374]                 ...future.oldOptions$nwarnings <- NULL
[08:26:47.374]             }
[08:26:47.374]             base::options(...future.oldOptions)
[08:26:47.374]             if (.Platform$OS.type == "windows") {
[08:26:47.374]                 old_names <- names(...future.oldEnvVars)
[08:26:47.374]                 envs <- base::Sys.getenv()
[08:26:47.374]                 names <- names(envs)
[08:26:47.374]                 common <- intersect(names, old_names)
[08:26:47.374]                 added <- setdiff(names, old_names)
[08:26:47.374]                 removed <- setdiff(old_names, names)
[08:26:47.374]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:47.374]                   envs[common]]
[08:26:47.374]                 NAMES <- toupper(changed)
[08:26:47.374]                 args <- list()
[08:26:47.374]                 for (kk in seq_along(NAMES)) {
[08:26:47.374]                   name <- changed[[kk]]
[08:26:47.374]                   NAME <- NAMES[[kk]]
[08:26:47.374]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:47.374]                     next
[08:26:47.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:47.374]                 }
[08:26:47.374]                 NAMES <- toupper(added)
[08:26:47.374]                 for (kk in seq_along(NAMES)) {
[08:26:47.374]                   name <- added[[kk]]
[08:26:47.374]                   NAME <- NAMES[[kk]]
[08:26:47.374]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:47.374]                     next
[08:26:47.374]                   args[[name]] <- ""
[08:26:47.374]                 }
[08:26:47.374]                 NAMES <- toupper(removed)
[08:26:47.374]                 for (kk in seq_along(NAMES)) {
[08:26:47.374]                   name <- removed[[kk]]
[08:26:47.374]                   NAME <- NAMES[[kk]]
[08:26:47.374]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:47.374]                     next
[08:26:47.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:47.374]                 }
[08:26:47.374]                 if (length(args) > 0) 
[08:26:47.374]                   base::do.call(base::Sys.setenv, args = args)
[08:26:47.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:47.374]             }
[08:26:47.374]             else {
[08:26:47.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:47.374]             }
[08:26:47.374]             {
[08:26:47.374]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:47.374]                   0L) {
[08:26:47.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:47.374]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:47.374]                   base::options(opts)
[08:26:47.374]                 }
[08:26:47.374]                 {
[08:26:47.374]                   {
[08:26:47.374]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:47.374]                     NULL
[08:26:47.374]                   }
[08:26:47.374]                   options(future.plan = NULL)
[08:26:47.374]                   if (is.na(NA_character_)) 
[08:26:47.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:47.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:47.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:47.374]                     .init = FALSE)
[08:26:47.374]                 }
[08:26:47.374]             }
[08:26:47.374]         }
[08:26:47.374]     })
[08:26:47.374]     if (TRUE) {
[08:26:47.374]         base::sink(type = "output", split = FALSE)
[08:26:47.374]         if (TRUE) {
[08:26:47.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:47.374]         }
[08:26:47.374]         else {
[08:26:47.374]             ...future.result["stdout"] <- base::list(NULL)
[08:26:47.374]         }
[08:26:47.374]         base::close(...future.stdout)
[08:26:47.374]         ...future.stdout <- NULL
[08:26:47.374]     }
[08:26:47.374]     ...future.result$conditions <- ...future.conditions
[08:26:47.374]     ...future.result$finished <- base::Sys.time()
[08:26:47.374]     ...future.result
[08:26:47.374] }
[08:26:47.377] Exporting 5 global objects (1.46 KiB) to cluster node #1 ...
[08:26:47.377] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ...
[08:26:47.378] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ... DONE
[08:26:47.378] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:47.378] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:47.379] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[08:26:47.379] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[08:26:47.379] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:47.379] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:47.380] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:47.380] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:47.380] Exporting 5 global objects (1.46 KiB) to cluster node #1 ... DONE
[08:26:47.381] MultisessionFuture started
[08:26:47.381] - Launch lazy future ... done
[08:26:47.381] run() for ‘MultisessionFuture’ ... done
[08:26:47.381] Created future:
[08:26:47.381] MultisessionFuture:
[08:26:47.381] Label: ‘future_lapply-1’
[08:26:47.381] Expression:
[08:26:47.381] {
[08:26:47.381]     do.call(function(...) {
[08:26:47.381]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.381]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:47.381]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.381]             on.exit(options(oopts), add = TRUE)
[08:26:47.381]         }
[08:26:47.381]         {
[08:26:47.381]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:47.381]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.381]                 ...future.FUN(...future.X_jj, ...)
[08:26:47.381]             })
[08:26:47.381]         }
[08:26:47.381]     }, args = future.call.arguments)
[08:26:47.381] }
[08:26:47.381] Lazy evaluation: FALSE
[08:26:47.381] Asynchronous evaluation: TRUE
[08:26:47.381] Local evaluation: TRUE
[08:26:47.381] Environment: R_GlobalEnv
[08:26:47.381] Capture standard output: TRUE
[08:26:47.381] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:47.381] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:47.381] Packages: <none>
[08:26:47.381] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:47.381] Resolved: FALSE
[08:26:47.381] Value: <not collected>
[08:26:47.381] Conditions captured: <none>
[08:26:47.381] Early signaling: FALSE
[08:26:47.381] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:47.381] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:47.393] Chunk #1 of 2 ... DONE
[08:26:47.393] Chunk #2 of 2 ...
[08:26:47.393]  - Finding globals in 'X' for chunk #2 ...
[08:26:47.393] getGlobalsAndPackages() ...
[08:26:47.393] Searching for globals...
[08:26:47.394] 
[08:26:47.394] Searching for globals ... DONE
[08:26:47.394] - globals: [0] <none>
[08:26:47.394] getGlobalsAndPackages() ... DONE
[08:26:47.394]    + additional globals found: [n=0] 
[08:26:47.394]    + additional namespaces needed: [n=0] 
[08:26:47.394]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:47.394]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:47.394]  - seeds: <none>
[08:26:47.395]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.395] getGlobalsAndPackages() ...
[08:26:47.395] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.395] Resolving globals: FALSE
[08:26:47.395] Tweak future expression to call with '...' arguments ...
[08:26:47.395] {
[08:26:47.395]     do.call(function(...) {
[08:26:47.395]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.395]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:47.395]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.395]             on.exit(options(oopts), add = TRUE)
[08:26:47.395]         }
[08:26:47.395]         {
[08:26:47.395]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:47.395]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.395]                 ...future.FUN(...future.X_jj, ...)
[08:26:47.395]             })
[08:26:47.395]         }
[08:26:47.395]     }, args = future.call.arguments)
[08:26:47.395] }
[08:26:47.395] Tweak future expression to call with '...' arguments ... DONE
[08:26:47.396] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.396] 
[08:26:47.396] getGlobalsAndPackages() ... DONE
[08:26:47.396] run() for ‘Future’ ...
[08:26:47.396] - state: ‘created’
[08:26:47.397] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:47.412] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:47.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:47.412]   - Field: ‘node’
[08:26:47.412]   - Field: ‘label’
[08:26:47.412]   - Field: ‘local’
[08:26:47.413]   - Field: ‘owner’
[08:26:47.413]   - Field: ‘envir’
[08:26:47.413]   - Field: ‘workers’
[08:26:47.413]   - Field: ‘packages’
[08:26:47.413]   - Field: ‘gc’
[08:26:47.413]   - Field: ‘conditions’
[08:26:47.413]   - Field: ‘persistent’
[08:26:47.413]   - Field: ‘expr’
[08:26:47.413]   - Field: ‘uuid’
[08:26:47.413]   - Field: ‘seed’
[08:26:47.414]   - Field: ‘version’
[08:26:47.414]   - Field: ‘result’
[08:26:47.414]   - Field: ‘asynchronous’
[08:26:47.414]   - Field: ‘calls’
[08:26:47.414]   - Field: ‘globals’
[08:26:47.414]   - Field: ‘stdout’
[08:26:47.414]   - Field: ‘earlySignal’
[08:26:47.414]   - Field: ‘lazy’
[08:26:47.414]   - Field: ‘state’
[08:26:47.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:47.414] - Launch lazy future ...
[08:26:47.415] Packages needed by the future expression (n = 0): <none>
[08:26:47.415] Packages needed by future strategies (n = 0): <none>
[08:26:47.415] {
[08:26:47.415]     {
[08:26:47.415]         {
[08:26:47.415]             ...future.startTime <- base::Sys.time()
[08:26:47.415]             {
[08:26:47.415]                 {
[08:26:47.415]                   {
[08:26:47.415]                     {
[08:26:47.415]                       base::local({
[08:26:47.415]                         has_future <- base::requireNamespace("future", 
[08:26:47.415]                           quietly = TRUE)
[08:26:47.415]                         if (has_future) {
[08:26:47.415]                           ns <- base::getNamespace("future")
[08:26:47.415]                           version <- ns[[".package"]][["version"]]
[08:26:47.415]                           if (is.null(version)) 
[08:26:47.415]                             version <- utils::packageVersion("future")
[08:26:47.415]                         }
[08:26:47.415]                         else {
[08:26:47.415]                           version <- NULL
[08:26:47.415]                         }
[08:26:47.415]                         if (!has_future || version < "1.8.0") {
[08:26:47.415]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:47.415]                             "", base::R.version$version.string), 
[08:26:47.415]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:47.415]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:47.415]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:47.415]                               "release", "version")], collapse = " "), 
[08:26:47.415]                             hostname = base::Sys.info()[["nodename"]])
[08:26:47.415]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:47.415]                             info)
[08:26:47.415]                           info <- base::paste(info, collapse = "; ")
[08:26:47.415]                           if (!has_future) {
[08:26:47.415]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:47.415]                               info)
[08:26:47.415]                           }
[08:26:47.415]                           else {
[08:26:47.415]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:47.415]                               info, version)
[08:26:47.415]                           }
[08:26:47.415]                           base::stop(msg)
[08:26:47.415]                         }
[08:26:47.415]                       })
[08:26:47.415]                     }
[08:26:47.415]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:47.415]                     base::options(mc.cores = 1L)
[08:26:47.415]                   }
[08:26:47.415]                   ...future.strategy.old <- future::plan("list")
[08:26:47.415]                   options(future.plan = NULL)
[08:26:47.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:47.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:47.415]                 }
[08:26:47.415]                 ...future.workdir <- getwd()
[08:26:47.415]             }
[08:26:47.415]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:47.415]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:47.415]         }
[08:26:47.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:47.415]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:47.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:47.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:47.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:47.415]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:47.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:47.415]             base::names(...future.oldOptions))
[08:26:47.415]     }
[08:26:47.415]     if (FALSE) {
[08:26:47.415]     }
[08:26:47.415]     else {
[08:26:47.415]         if (TRUE) {
[08:26:47.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:47.415]                 open = "w")
[08:26:47.415]         }
[08:26:47.415]         else {
[08:26:47.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:47.415]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:47.415]         }
[08:26:47.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:47.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:47.415]             base::sink(type = "output", split = FALSE)
[08:26:47.415]             base::close(...future.stdout)
[08:26:47.415]         }, add = TRUE)
[08:26:47.415]     }
[08:26:47.415]     ...future.frame <- base::sys.nframe()
[08:26:47.415]     ...future.conditions <- base::list()
[08:26:47.415]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:47.415]     if (FALSE) {
[08:26:47.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:47.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:47.415]     }
[08:26:47.415]     ...future.result <- base::tryCatch({
[08:26:47.415]         base::withCallingHandlers({
[08:26:47.415]             ...future.value <- base::withVisible(base::local({
[08:26:47.415]                 ...future.makeSendCondition <- base::local({
[08:26:47.415]                   sendCondition <- NULL
[08:26:47.415]                   function(frame = 1L) {
[08:26:47.415]                     if (is.function(sendCondition)) 
[08:26:47.415]                       return(sendCondition)
[08:26:47.415]                     ns <- getNamespace("parallel")
[08:26:47.415]                     if (exists("sendData", mode = "function", 
[08:26:47.415]                       envir = ns)) {
[08:26:47.415]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:47.415]                         envir = ns)
[08:26:47.415]                       envir <- sys.frame(frame)
[08:26:47.415]                       master <- NULL
[08:26:47.415]                       while (!identical(envir, .GlobalEnv) && 
[08:26:47.415]                         !identical(envir, emptyenv())) {
[08:26:47.415]                         if (exists("master", mode = "list", envir = envir, 
[08:26:47.415]                           inherits = FALSE)) {
[08:26:47.415]                           master <- get("master", mode = "list", 
[08:26:47.415]                             envir = envir, inherits = FALSE)
[08:26:47.415]                           if (inherits(master, c("SOCKnode", 
[08:26:47.415]                             "SOCK0node"))) {
[08:26:47.415]                             sendCondition <<- function(cond) {
[08:26:47.415]                               data <- list(type = "VALUE", value = cond, 
[08:26:47.415]                                 success = TRUE)
[08:26:47.415]                               parallel_sendData(master, data)
[08:26:47.415]                             }
[08:26:47.415]                             return(sendCondition)
[08:26:47.415]                           }
[08:26:47.415]                         }
[08:26:47.415]                         frame <- frame + 1L
[08:26:47.415]                         envir <- sys.frame(frame)
[08:26:47.415]                       }
[08:26:47.415]                     }
[08:26:47.415]                     sendCondition <<- function(cond) NULL
[08:26:47.415]                   }
[08:26:47.415]                 })
[08:26:47.415]                 withCallingHandlers({
[08:26:47.415]                   {
[08:26:47.415]                     do.call(function(...) {
[08:26:47.415]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.415]                       if (!identical(...future.globals.maxSize.org, 
[08:26:47.415]                         ...future.globals.maxSize)) {
[08:26:47.415]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.415]                         on.exit(options(oopts), add = TRUE)
[08:26:47.415]                       }
[08:26:47.415]                       {
[08:26:47.415]                         lapply(seq_along(...future.elements_ii), 
[08:26:47.415]                           FUN = function(jj) {
[08:26:47.415]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.415]                             ...future.FUN(...future.X_jj, ...)
[08:26:47.415]                           })
[08:26:47.415]                       }
[08:26:47.415]                     }, args = future.call.arguments)
[08:26:47.415]                   }
[08:26:47.415]                 }, immediateCondition = function(cond) {
[08:26:47.415]                   sendCondition <- ...future.makeSendCondition()
[08:26:47.415]                   sendCondition(cond)
[08:26:47.415]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:47.415]                   {
[08:26:47.415]                     inherits <- base::inherits
[08:26:47.415]                     invokeRestart <- base::invokeRestart
[08:26:47.415]                     is.null <- base::is.null
[08:26:47.415]                     muffled <- FALSE
[08:26:47.415]                     if (inherits(cond, "message")) {
[08:26:47.415]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:47.415]                       if (muffled) 
[08:26:47.415]                         invokeRestart("muffleMessage")
[08:26:47.415]                     }
[08:26:47.415]                     else if (inherits(cond, "warning")) {
[08:26:47.415]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:47.415]                       if (muffled) 
[08:26:47.415]                         invokeRestart("muffleWarning")
[08:26:47.415]                     }
[08:26:47.415]                     else if (inherits(cond, "condition")) {
[08:26:47.415]                       if (!is.null(pattern)) {
[08:26:47.415]                         computeRestarts <- base::computeRestarts
[08:26:47.415]                         grepl <- base::grepl
[08:26:47.415]                         restarts <- computeRestarts(cond)
[08:26:47.415]                         for (restart in restarts) {
[08:26:47.415]                           name <- restart$name
[08:26:47.415]                           if (is.null(name)) 
[08:26:47.415]                             next
[08:26:47.415]                           if (!grepl(pattern, name)) 
[08:26:47.415]                             next
[08:26:47.415]                           invokeRestart(restart)
[08:26:47.415]                           muffled <- TRUE
[08:26:47.415]                           break
[08:26:47.415]                         }
[08:26:47.415]                       }
[08:26:47.415]                     }
[08:26:47.415]                     invisible(muffled)
[08:26:47.415]                   }
[08:26:47.415]                   muffleCondition(cond)
[08:26:47.415]                 })
[08:26:47.415]             }))
[08:26:47.415]             future::FutureResult(value = ...future.value$value, 
[08:26:47.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:47.415]                   ...future.rng), globalenv = if (FALSE) 
[08:26:47.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:47.415]                     ...future.globalenv.names))
[08:26:47.415]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:47.415]         }, condition = base::local({
[08:26:47.415]             c <- base::c
[08:26:47.415]             inherits <- base::inherits
[08:26:47.415]             invokeRestart <- base::invokeRestart
[08:26:47.415]             length <- base::length
[08:26:47.415]             list <- base::list
[08:26:47.415]             seq.int <- base::seq.int
[08:26:47.415]             signalCondition <- base::signalCondition
[08:26:47.415]             sys.calls <- base::sys.calls
[08:26:47.415]             `[[` <- base::`[[`
[08:26:47.415]             `+` <- base::`+`
[08:26:47.415]             `<<-` <- base::`<<-`
[08:26:47.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:47.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:47.415]                   3L)]
[08:26:47.415]             }
[08:26:47.415]             function(cond) {
[08:26:47.415]                 is_error <- inherits(cond, "error")
[08:26:47.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:47.415]                   NULL)
[08:26:47.415]                 if (is_error) {
[08:26:47.415]                   sessionInformation <- function() {
[08:26:47.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:47.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:47.415]                       search = base::search(), system = base::Sys.info())
[08:26:47.415]                   }
[08:26:47.415]                   ...future.conditions[[length(...future.conditions) + 
[08:26:47.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:47.415]                     cond$call), session = sessionInformation(), 
[08:26:47.415]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:47.415]                   signalCondition(cond)
[08:26:47.415]                 }
[08:26:47.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:47.415]                 "immediateCondition"))) {
[08:26:47.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:47.415]                   ...future.conditions[[length(...future.conditions) + 
[08:26:47.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:47.415]                   if (TRUE && !signal) {
[08:26:47.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:47.415]                     {
[08:26:47.415]                       inherits <- base::inherits
[08:26:47.415]                       invokeRestart <- base::invokeRestart
[08:26:47.415]                       is.null <- base::is.null
[08:26:47.415]                       muffled <- FALSE
[08:26:47.415]                       if (inherits(cond, "message")) {
[08:26:47.415]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:47.415]                         if (muffled) 
[08:26:47.415]                           invokeRestart("muffleMessage")
[08:26:47.415]                       }
[08:26:47.415]                       else if (inherits(cond, "warning")) {
[08:26:47.415]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:47.415]                         if (muffled) 
[08:26:47.415]                           invokeRestart("muffleWarning")
[08:26:47.415]                       }
[08:26:47.415]                       else if (inherits(cond, "condition")) {
[08:26:47.415]                         if (!is.null(pattern)) {
[08:26:47.415]                           computeRestarts <- base::computeRestarts
[08:26:47.415]                           grepl <- base::grepl
[08:26:47.415]                           restarts <- computeRestarts(cond)
[08:26:47.415]                           for (restart in restarts) {
[08:26:47.415]                             name <- restart$name
[08:26:47.415]                             if (is.null(name)) 
[08:26:47.415]                               next
[08:26:47.415]                             if (!grepl(pattern, name)) 
[08:26:47.415]                               next
[08:26:47.415]                             invokeRestart(restart)
[08:26:47.415]                             muffled <- TRUE
[08:26:47.415]                             break
[08:26:47.415]                           }
[08:26:47.415]                         }
[08:26:47.415]                       }
[08:26:47.415]                       invisible(muffled)
[08:26:47.415]                     }
[08:26:47.415]                     muffleCondition(cond, pattern = "^muffle")
[08:26:47.415]                   }
[08:26:47.415]                 }
[08:26:47.415]                 else {
[08:26:47.415]                   if (TRUE) {
[08:26:47.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:47.415]                     {
[08:26:47.415]                       inherits <- base::inherits
[08:26:47.415]                       invokeRestart <- base::invokeRestart
[08:26:47.415]                       is.null <- base::is.null
[08:26:47.415]                       muffled <- FALSE
[08:26:47.415]                       if (inherits(cond, "message")) {
[08:26:47.415]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:47.415]                         if (muffled) 
[08:26:47.415]                           invokeRestart("muffleMessage")
[08:26:47.415]                       }
[08:26:47.415]                       else if (inherits(cond, "warning")) {
[08:26:47.415]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:47.415]                         if (muffled) 
[08:26:47.415]                           invokeRestart("muffleWarning")
[08:26:47.415]                       }
[08:26:47.415]                       else if (inherits(cond, "condition")) {
[08:26:47.415]                         if (!is.null(pattern)) {
[08:26:47.415]                           computeRestarts <- base::computeRestarts
[08:26:47.415]                           grepl <- base::grepl
[08:26:47.415]                           restarts <- computeRestarts(cond)
[08:26:47.415]                           for (restart in restarts) {
[08:26:47.415]                             name <- restart$name
[08:26:47.415]                             if (is.null(name)) 
[08:26:47.415]                               next
[08:26:47.415]                             if (!grepl(pattern, name)) 
[08:26:47.415]                               next
[08:26:47.415]                             invokeRestart(restart)
[08:26:47.415]                             muffled <- TRUE
[08:26:47.415]                             break
[08:26:47.415]                           }
[08:26:47.415]                         }
[08:26:47.415]                       }
[08:26:47.415]                       invisible(muffled)
[08:26:47.415]                     }
[08:26:47.415]                     muffleCondition(cond, pattern = "^muffle")
[08:26:47.415]                   }
[08:26:47.415]                 }
[08:26:47.415]             }
[08:26:47.415]         }))
[08:26:47.415]     }, error = function(ex) {
[08:26:47.415]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:47.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:47.415]                 ...future.rng), started = ...future.startTime, 
[08:26:47.415]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:47.415]             version = "1.8"), class = "FutureResult")
[08:26:47.415]     }, finally = {
[08:26:47.415]         if (!identical(...future.workdir, getwd())) 
[08:26:47.415]             setwd(...future.workdir)
[08:26:47.415]         {
[08:26:47.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:47.415]                 ...future.oldOptions$nwarnings <- NULL
[08:26:47.415]             }
[08:26:47.415]             base::options(...future.oldOptions)
[08:26:47.415]             if (.Platform$OS.type == "windows") {
[08:26:47.415]                 old_names <- names(...future.oldEnvVars)
[08:26:47.415]                 envs <- base::Sys.getenv()
[08:26:47.415]                 names <- names(envs)
[08:26:47.415]                 common <- intersect(names, old_names)
[08:26:47.415]                 added <- setdiff(names, old_names)
[08:26:47.415]                 removed <- setdiff(old_names, names)
[08:26:47.415]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:47.415]                   envs[common]]
[08:26:47.415]                 NAMES <- toupper(changed)
[08:26:47.415]                 args <- list()
[08:26:47.415]                 for (kk in seq_along(NAMES)) {
[08:26:47.415]                   name <- changed[[kk]]
[08:26:47.415]                   NAME <- NAMES[[kk]]
[08:26:47.415]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:47.415]                     next
[08:26:47.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:47.415]                 }
[08:26:47.415]                 NAMES <- toupper(added)
[08:26:47.415]                 for (kk in seq_along(NAMES)) {
[08:26:47.415]                   name <- added[[kk]]
[08:26:47.415]                   NAME <- NAMES[[kk]]
[08:26:47.415]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:47.415]                     next
[08:26:47.415]                   args[[name]] <- ""
[08:26:47.415]                 }
[08:26:47.415]                 NAMES <- toupper(removed)
[08:26:47.415]                 for (kk in seq_along(NAMES)) {
[08:26:47.415]                   name <- removed[[kk]]
[08:26:47.415]                   NAME <- NAMES[[kk]]
[08:26:47.415]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:47.415]                     next
[08:26:47.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:47.415]                 }
[08:26:47.415]                 if (length(args) > 0) 
[08:26:47.415]                   base::do.call(base::Sys.setenv, args = args)
[08:26:47.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:47.415]             }
[08:26:47.415]             else {
[08:26:47.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:47.415]             }
[08:26:47.415]             {
[08:26:47.415]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:47.415]                   0L) {
[08:26:47.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:47.415]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:47.415]                   base::options(opts)
[08:26:47.415]                 }
[08:26:47.415]                 {
[08:26:47.415]                   {
[08:26:47.415]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:47.415]                     NULL
[08:26:47.415]                   }
[08:26:47.415]                   options(future.plan = NULL)
[08:26:47.415]                   if (is.na(NA_character_)) 
[08:26:47.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:47.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:47.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:47.415]                     .init = FALSE)
[08:26:47.415]                 }
[08:26:47.415]             }
[08:26:47.415]         }
[08:26:47.415]     })
[08:26:47.415]     if (TRUE) {
[08:26:47.415]         base::sink(type = "output", split = FALSE)
[08:26:47.415]         if (TRUE) {
[08:26:47.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:47.415]         }
[08:26:47.415]         else {
[08:26:47.415]             ...future.result["stdout"] <- base::list(NULL)
[08:26:47.415]         }
[08:26:47.415]         base::close(...future.stdout)
[08:26:47.415]         ...future.stdout <- NULL
[08:26:47.415]     }
[08:26:47.415]     ...future.result$conditions <- ...future.conditions
[08:26:47.415]     ...future.result$finished <- base::Sys.time()
[08:26:47.415]     ...future.result
[08:26:47.415] }
[08:26:47.418] Exporting 5 global objects (1.46 KiB) to cluster node #2 ...
[08:26:47.419] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ...
[08:26:47.419] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ... DONE
[08:26:47.419] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:47.420] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:47.420] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[08:26:47.420] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[08:26:47.420] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:47.421] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:47.421] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:47.421] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:47.421] Exporting 5 global objects (1.46 KiB) to cluster node #2 ... DONE
[08:26:47.422] MultisessionFuture started
[08:26:47.422] - Launch lazy future ... done
[08:26:47.422] run() for ‘MultisessionFuture’ ... done
[08:26:47.422] Created future:
[08:26:47.422] MultisessionFuture:
[08:26:47.422] Label: ‘future_lapply-2’
[08:26:47.422] Expression:
[08:26:47.422] {
[08:26:47.422]     do.call(function(...) {
[08:26:47.422]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.422]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:47.422]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.422]             on.exit(options(oopts), add = TRUE)
[08:26:47.422]         }
[08:26:47.422]         {
[08:26:47.422]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:47.422]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.422]                 ...future.FUN(...future.X_jj, ...)
[08:26:47.422]             })
[08:26:47.422]         }
[08:26:47.422]     }, args = future.call.arguments)
[08:26:47.422] }
[08:26:47.422] Lazy evaluation: FALSE
[08:26:47.422] Asynchronous evaluation: TRUE
[08:26:47.422] Local evaluation: TRUE
[08:26:47.422] Environment: R_GlobalEnv
[08:26:47.422] Capture standard output: TRUE
[08:26:47.422] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:47.422] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:47.422] Packages: <none>
[08:26:47.422] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:47.422] Resolved: FALSE
[08:26:47.422] Value: <not collected>
[08:26:47.422] Conditions captured: <none>
[08:26:47.422] Early signaling: FALSE
[08:26:47.422] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:47.422] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:47.434] Chunk #2 of 2 ... DONE
[08:26:47.434] Launching 2 futures (chunks) ... DONE
[08:26:47.434] Resolving 2 futures (chunks) ...
[08:26:47.435] resolve() on list ...
[08:26:47.435]  recursive: 0
[08:26:47.435]  length: 2
[08:26:47.435] 
[08:26:47.478] receiveMessageFromWorker() for ClusterFuture ...
[08:26:47.478] - Validating connection of MultisessionFuture
[08:26:47.478] - received message: FutureResult
[08:26:47.478] - Received FutureResult
[08:26:47.479] - Erased future from FutureRegistry
[08:26:47.479] result() for ClusterFuture ...
[08:26:47.479] - result already collected: FutureResult
[08:26:47.479] result() for ClusterFuture ... done
[08:26:47.479] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:47.479] Future #2
[08:26:47.479] result() for ClusterFuture ...
[08:26:47.479] - result already collected: FutureResult
[08:26:47.479] result() for ClusterFuture ... done
[08:26:47.479] result() for ClusterFuture ...
[08:26:47.480] - result already collected: FutureResult
[08:26:47.480] result() for ClusterFuture ... done
[08:26:47.480] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:47.480] - nx: 2
[08:26:47.480] - relay: TRUE
[08:26:47.480] - stdout: TRUE
[08:26:47.480] - signal: TRUE
[08:26:47.480] - resignal: FALSE
[08:26:47.480] - force: TRUE
[08:26:47.480] - relayed: [n=2] FALSE, FALSE
[08:26:47.480] - queued futures: [n=2] FALSE, FALSE
[08:26:47.481]  - until=1
[08:26:47.481]  - relaying element #1
[08:26:47.481] - relayed: [n=2] FALSE, FALSE
[08:26:47.481] - queued futures: [n=2] FALSE, TRUE
[08:26:47.481] signalConditionsASAP(NULL, pos=2) ... done
[08:26:47.481]  length: 1 (resolved future 2)
[08:26:47.931] receiveMessageFromWorker() for ClusterFuture ...
[08:26:47.932] - Validating connection of MultisessionFuture
[08:26:47.932] - received message: FutureResult
[08:26:47.932] - Received FutureResult
[08:26:47.932] - Erased future from FutureRegistry
[08:26:47.932] result() for ClusterFuture ...
[08:26:47.932] - result already collected: FutureResult
[08:26:47.932] result() for ClusterFuture ... done
[08:26:47.932] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:47.933] Future #1
[08:26:47.933] result() for ClusterFuture ...
[08:26:47.933] - result already collected: FutureResult
[08:26:47.933] result() for ClusterFuture ... done
[08:26:47.933] result() for ClusterFuture ...
[08:26:47.933] - result already collected: FutureResult
[08:26:47.933] result() for ClusterFuture ... done
[08:26:47.933] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:47.933] - nx: 2
[08:26:47.933] - relay: TRUE
[08:26:47.933] - stdout: TRUE
[08:26:47.933] - signal: TRUE
[08:26:47.934] - resignal: FALSE
[08:26:47.934] - force: TRUE
[08:26:47.934] - relayed: [n=2] FALSE, FALSE
[08:26:47.934] - queued futures: [n=2] FALSE, TRUE
[08:26:47.934]  - until=1
[08:26:47.934]  - relaying element #1
[08:26:47.934] result() for ClusterFuture ...
[08:26:47.934] - result already collected: FutureResult
[08:26:47.934] result() for ClusterFuture ... done
[08:26:47.934] result() for ClusterFuture ...
[08:26:47.934] - result already collected: FutureResult
[08:26:47.934] result() for ClusterFuture ... done
[08:26:47.935] result() for ClusterFuture ...
[08:26:47.935] - result already collected: FutureResult
[08:26:47.935] result() for ClusterFuture ... done
[08:26:47.935] result() for ClusterFuture ...
[08:26:47.935] - result already collected: FutureResult
[08:26:47.935] result() for ClusterFuture ... done
[08:26:47.935] - relayed: [n=2] TRUE, FALSE
[08:26:47.935] - queued futures: [n=2] TRUE, TRUE
[08:26:47.935] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:47.935]  length: 0 (resolved future 1)
[08:26:47.935] Relaying remaining futures
[08:26:47.936] signalConditionsASAP(NULL, pos=0) ...
[08:26:47.936] - nx: 2
[08:26:47.936] - relay: TRUE
[08:26:47.936] - stdout: TRUE
[08:26:47.936] - signal: TRUE
[08:26:47.936] - resignal: FALSE
[08:26:47.936] - force: TRUE
[08:26:47.936] - relayed: [n=2] TRUE, FALSE
[08:26:47.936] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:47.936]  - relaying element #2
[08:26:47.936] result() for ClusterFuture ...
[08:26:47.936] - result already collected: FutureResult
[08:26:47.937] result() for ClusterFuture ... done
[08:26:47.937] result() for ClusterFuture ...
[08:26:47.937] - result already collected: FutureResult
[08:26:47.937] result() for ClusterFuture ... done
[08:26:47.937] result() for ClusterFuture ...
[08:26:47.937] - result already collected: FutureResult
[08:26:47.937] result() for ClusterFuture ... done
[08:26:47.937] result() for ClusterFuture ...
[08:26:47.937] - result already collected: FutureResult
[08:26:47.937] result() for ClusterFuture ... done
[08:26:47.937] - relayed: [n=2] TRUE, TRUE
[08:26:47.937] - queued futures: [n=2] TRUE, TRUE
[08:26:47.938] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[08:26:47.938] resolve() on list ... DONE
[08:26:47.938] result() for ClusterFuture ...
[08:26:47.938] - result already collected: FutureResult
[08:26:47.938] result() for ClusterFuture ... done
[08:26:47.938] result() for ClusterFuture ...
[08:26:47.938] - result already collected: FutureResult
[08:26:47.938] result() for ClusterFuture ... done
[08:26:47.938] result() for ClusterFuture ...
[08:26:47.938] - result already collected: FutureResult
[08:26:47.938] result() for ClusterFuture ... done
[08:26:47.938] result() for ClusterFuture ...
[08:26:47.939] - result already collected: FutureResult
[08:26:47.939] result() for ClusterFuture ... done
[08:26:47.939]  - Number of value chunks collected: 2
[08:26:47.939] Resolving 2 futures (chunks) ... DONE
[08:26:47.939] Reducing values from 2 chunks ...
[08:26:47.939]  - Number of values collected after concatenation: 2
[08:26:47.939]  - Number of values expected: 2
[08:26:47.939] Reducing values from 2 chunks ... DONE
[08:26:47.939] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[08:26:47.940] future_lapply() ...
[08:26:47.942] Number of chunks: 2
[08:26:47.942] getGlobalsAndPackagesXApply() ...
[08:26:47.942]  - future.globals: TRUE
[08:26:47.942] getGlobalsAndPackages() ...
[08:26:47.942] Searching for globals...
[08:26:47.944] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[08:26:47.944] Searching for globals ... DONE
[08:26:47.944] Resolving globals: FALSE
[08:26:47.945] The total size of the 1 globals is 841 bytes (841 bytes)
[08:26:47.945] The total size of the 1 globals exported for future expression (‘FUN()’) is 841 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (841 bytes of class ‘function’)
[08:26:47.945] - globals: [1] ‘FUN’
[08:26:47.945] 
[08:26:47.945] getGlobalsAndPackages() ... DONE
[08:26:47.945]  - globals found/used: [n=1] ‘FUN’
[08:26:47.945]  - needed namespaces: [n=0] 
[08:26:47.945] Finding globals ... DONE
[08:26:47.946]  - use_args: TRUE
[08:26:47.946]  - Getting '...' globals ...
[08:26:47.946] resolve() on list ...
[08:26:47.946]  recursive: 0
[08:26:47.946]  length: 1
[08:26:47.946]  elements: ‘...’
[08:26:47.946]  length: 0 (resolved future 1)
[08:26:47.946] resolve() on list ... DONE
[08:26:47.947]    - '...' content: [n=0] 
[08:26:47.947] List of 1
[08:26:47.947]  $ ...: list()
[08:26:47.947]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:47.947]  - attr(*, "where")=List of 1
[08:26:47.947]   ..$ ...:<environment: 0x55e1106f3c28> 
[08:26:47.947]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:47.947]  - attr(*, "resolved")= logi TRUE
[08:26:47.947]  - attr(*, "total_size")= num NA
[08:26:47.949]  - Getting '...' globals ... DONE
[08:26:47.949] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:26:47.949] List of 2
[08:26:47.949]  $ ...future.FUN:function (x)  
[08:26:47.949]  $ ...          : list()
[08:26:47.949]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:26:47.949]  - attr(*, "where")=List of 2
[08:26:47.949]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:47.949]   ..$ ...          :<environment: 0x55e1106f3c28> 
[08:26:47.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:47.949]  - attr(*, "resolved")= logi FALSE
[08:26:47.949]  - attr(*, "total_size")= num 5632
[08:26:47.952] Packages to be attached in all futures: [n=0] 
[08:26:47.952] getGlobalsAndPackagesXApply() ... DONE
[08:26:47.952] Number of futures (= number of chunks): 2
[08:26:47.953] Launching 2 futures (chunks) ...
[08:26:47.953] Chunk #1 of 2 ...
[08:26:47.953]  - Finding globals in 'X' for chunk #1 ...
[08:26:47.953] getGlobalsAndPackages() ...
[08:26:47.953] Searching for globals...
[08:26:47.953] 
[08:26:47.953] Searching for globals ... DONE
[08:26:47.953] - globals: [0] <none>
[08:26:47.953] getGlobalsAndPackages() ... DONE
[08:26:47.954]    + additional globals found: [n=0] 
[08:26:47.954]    + additional namespaces needed: [n=0] 
[08:26:47.954]  - Finding globals in 'X' for chunk #1 ... DONE
[08:26:47.954]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:47.954]  - seeds: <none>
[08:26:47.954]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.954] getGlobalsAndPackages() ...
[08:26:47.954] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.954] Resolving globals: FALSE
[08:26:47.954] Tweak future expression to call with '...' arguments ...
[08:26:47.955] {
[08:26:47.955]     do.call(function(...) {
[08:26:47.955]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.955]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:47.955]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.955]             on.exit(options(oopts), add = TRUE)
[08:26:47.955]         }
[08:26:47.955]         {
[08:26:47.955]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:47.955]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.955]                 ...future.FUN(...future.X_jj, ...)
[08:26:47.955]             })
[08:26:47.955]         }
[08:26:47.955]     }, args = future.call.arguments)
[08:26:47.955] }
[08:26:47.955] Tweak future expression to call with '...' arguments ... DONE
[08:26:47.955] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.955] 
[08:26:47.955] getGlobalsAndPackages() ... DONE
[08:26:47.956] run() for ‘Future’ ...
[08:26:47.956] - state: ‘created’
[08:26:47.956] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:47.971] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:47.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:47.971]   - Field: ‘node’
[08:26:47.971]   - Field: ‘label’
[08:26:47.971]   - Field: ‘local’
[08:26:47.971]   - Field: ‘owner’
[08:26:47.971]   - Field: ‘envir’
[08:26:47.972]   - Field: ‘workers’
[08:26:47.972]   - Field: ‘packages’
[08:26:47.972]   - Field: ‘gc’
[08:26:47.972]   - Field: ‘conditions’
[08:26:47.972]   - Field: ‘persistent’
[08:26:47.972]   - Field: ‘expr’
[08:26:47.972]   - Field: ‘uuid’
[08:26:47.972]   - Field: ‘seed’
[08:26:47.972]   - Field: ‘version’
[08:26:47.972]   - Field: ‘result’
[08:26:47.972]   - Field: ‘asynchronous’
[08:26:47.972]   - Field: ‘calls’
[08:26:47.973]   - Field: ‘globals’
[08:26:47.973]   - Field: ‘stdout’
[08:26:47.973]   - Field: ‘earlySignal’
[08:26:47.973]   - Field: ‘lazy’
[08:26:47.973]   - Field: ‘state’
[08:26:47.973] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:47.973] - Launch lazy future ...
[08:26:47.973] Packages needed by the future expression (n = 0): <none>
[08:26:47.974] Packages needed by future strategies (n = 0): <none>
[08:26:47.974] {
[08:26:47.974]     {
[08:26:47.974]         {
[08:26:47.974]             ...future.startTime <- base::Sys.time()
[08:26:47.974]             {
[08:26:47.974]                 {
[08:26:47.974]                   {
[08:26:47.974]                     {
[08:26:47.974]                       base::local({
[08:26:47.974]                         has_future <- base::requireNamespace("future", 
[08:26:47.974]                           quietly = TRUE)
[08:26:47.974]                         if (has_future) {
[08:26:47.974]                           ns <- base::getNamespace("future")
[08:26:47.974]                           version <- ns[[".package"]][["version"]]
[08:26:47.974]                           if (is.null(version)) 
[08:26:47.974]                             version <- utils::packageVersion("future")
[08:26:47.974]                         }
[08:26:47.974]                         else {
[08:26:47.974]                           version <- NULL
[08:26:47.974]                         }
[08:26:47.974]                         if (!has_future || version < "1.8.0") {
[08:26:47.974]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:47.974]                             "", base::R.version$version.string), 
[08:26:47.974]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:47.974]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:47.974]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:47.974]                               "release", "version")], collapse = " "), 
[08:26:47.974]                             hostname = base::Sys.info()[["nodename"]])
[08:26:47.974]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:47.974]                             info)
[08:26:47.974]                           info <- base::paste(info, collapse = "; ")
[08:26:47.974]                           if (!has_future) {
[08:26:47.974]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:47.974]                               info)
[08:26:47.974]                           }
[08:26:47.974]                           else {
[08:26:47.974]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:47.974]                               info, version)
[08:26:47.974]                           }
[08:26:47.974]                           base::stop(msg)
[08:26:47.974]                         }
[08:26:47.974]                       })
[08:26:47.974]                     }
[08:26:47.974]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:47.974]                     base::options(mc.cores = 1L)
[08:26:47.974]                   }
[08:26:47.974]                   ...future.strategy.old <- future::plan("list")
[08:26:47.974]                   options(future.plan = NULL)
[08:26:47.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:47.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:47.974]                 }
[08:26:47.974]                 ...future.workdir <- getwd()
[08:26:47.974]             }
[08:26:47.974]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:47.974]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:47.974]         }
[08:26:47.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:47.974]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:47.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:47.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:47.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:47.974]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:47.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:47.974]             base::names(...future.oldOptions))
[08:26:47.974]     }
[08:26:47.974]     if (TRUE) {
[08:26:47.974]     }
[08:26:47.974]     else {
[08:26:47.974]         if (NA) {
[08:26:47.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:47.974]                 open = "w")
[08:26:47.974]         }
[08:26:47.974]         else {
[08:26:47.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:47.974]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:47.974]         }
[08:26:47.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:47.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:47.974]             base::sink(type = "output", split = FALSE)
[08:26:47.974]             base::close(...future.stdout)
[08:26:47.974]         }, add = TRUE)
[08:26:47.974]     }
[08:26:47.974]     ...future.frame <- base::sys.nframe()
[08:26:47.974]     ...future.conditions <- base::list()
[08:26:47.974]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:47.974]     if (FALSE) {
[08:26:47.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:47.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:47.974]     }
[08:26:47.974]     ...future.result <- base::tryCatch({
[08:26:47.974]         base::withCallingHandlers({
[08:26:47.974]             ...future.value <- base::withVisible(base::local({
[08:26:47.974]                 ...future.makeSendCondition <- base::local({
[08:26:47.974]                   sendCondition <- NULL
[08:26:47.974]                   function(frame = 1L) {
[08:26:47.974]                     if (is.function(sendCondition)) 
[08:26:47.974]                       return(sendCondition)
[08:26:47.974]                     ns <- getNamespace("parallel")
[08:26:47.974]                     if (exists("sendData", mode = "function", 
[08:26:47.974]                       envir = ns)) {
[08:26:47.974]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:47.974]                         envir = ns)
[08:26:47.974]                       envir <- sys.frame(frame)
[08:26:47.974]                       master <- NULL
[08:26:47.974]                       while (!identical(envir, .GlobalEnv) && 
[08:26:47.974]                         !identical(envir, emptyenv())) {
[08:26:47.974]                         if (exists("master", mode = "list", envir = envir, 
[08:26:47.974]                           inherits = FALSE)) {
[08:26:47.974]                           master <- get("master", mode = "list", 
[08:26:47.974]                             envir = envir, inherits = FALSE)
[08:26:47.974]                           if (inherits(master, c("SOCKnode", 
[08:26:47.974]                             "SOCK0node"))) {
[08:26:47.974]                             sendCondition <<- function(cond) {
[08:26:47.974]                               data <- list(type = "VALUE", value = cond, 
[08:26:47.974]                                 success = TRUE)
[08:26:47.974]                               parallel_sendData(master, data)
[08:26:47.974]                             }
[08:26:47.974]                             return(sendCondition)
[08:26:47.974]                           }
[08:26:47.974]                         }
[08:26:47.974]                         frame <- frame + 1L
[08:26:47.974]                         envir <- sys.frame(frame)
[08:26:47.974]                       }
[08:26:47.974]                     }
[08:26:47.974]                     sendCondition <<- function(cond) NULL
[08:26:47.974]                   }
[08:26:47.974]                 })
[08:26:47.974]                 withCallingHandlers({
[08:26:47.974]                   {
[08:26:47.974]                     do.call(function(...) {
[08:26:47.974]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.974]                       if (!identical(...future.globals.maxSize.org, 
[08:26:47.974]                         ...future.globals.maxSize)) {
[08:26:47.974]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.974]                         on.exit(options(oopts), add = TRUE)
[08:26:47.974]                       }
[08:26:47.974]                       {
[08:26:47.974]                         lapply(seq_along(...future.elements_ii), 
[08:26:47.974]                           FUN = function(jj) {
[08:26:47.974]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.974]                             ...future.FUN(...future.X_jj, ...)
[08:26:47.974]                           })
[08:26:47.974]                       }
[08:26:47.974]                     }, args = future.call.arguments)
[08:26:47.974]                   }
[08:26:47.974]                 }, immediateCondition = function(cond) {
[08:26:47.974]                   sendCondition <- ...future.makeSendCondition()
[08:26:47.974]                   sendCondition(cond)
[08:26:47.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:47.974]                   {
[08:26:47.974]                     inherits <- base::inherits
[08:26:47.974]                     invokeRestart <- base::invokeRestart
[08:26:47.974]                     is.null <- base::is.null
[08:26:47.974]                     muffled <- FALSE
[08:26:47.974]                     if (inherits(cond, "message")) {
[08:26:47.974]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:47.974]                       if (muffled) 
[08:26:47.974]                         invokeRestart("muffleMessage")
[08:26:47.974]                     }
[08:26:47.974]                     else if (inherits(cond, "warning")) {
[08:26:47.974]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:47.974]                       if (muffled) 
[08:26:47.974]                         invokeRestart("muffleWarning")
[08:26:47.974]                     }
[08:26:47.974]                     else if (inherits(cond, "condition")) {
[08:26:47.974]                       if (!is.null(pattern)) {
[08:26:47.974]                         computeRestarts <- base::computeRestarts
[08:26:47.974]                         grepl <- base::grepl
[08:26:47.974]                         restarts <- computeRestarts(cond)
[08:26:47.974]                         for (restart in restarts) {
[08:26:47.974]                           name <- restart$name
[08:26:47.974]                           if (is.null(name)) 
[08:26:47.974]                             next
[08:26:47.974]                           if (!grepl(pattern, name)) 
[08:26:47.974]                             next
[08:26:47.974]                           invokeRestart(restart)
[08:26:47.974]                           muffled <- TRUE
[08:26:47.974]                           break
[08:26:47.974]                         }
[08:26:47.974]                       }
[08:26:47.974]                     }
[08:26:47.974]                     invisible(muffled)
[08:26:47.974]                   }
[08:26:47.974]                   muffleCondition(cond)
[08:26:47.974]                 })
[08:26:47.974]             }))
[08:26:47.974]             future::FutureResult(value = ...future.value$value, 
[08:26:47.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:47.974]                   ...future.rng), globalenv = if (FALSE) 
[08:26:47.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:47.974]                     ...future.globalenv.names))
[08:26:47.974]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:47.974]         }, condition = base::local({
[08:26:47.974]             c <- base::c
[08:26:47.974]             inherits <- base::inherits
[08:26:47.974]             invokeRestart <- base::invokeRestart
[08:26:47.974]             length <- base::length
[08:26:47.974]             list <- base::list
[08:26:47.974]             seq.int <- base::seq.int
[08:26:47.974]             signalCondition <- base::signalCondition
[08:26:47.974]             sys.calls <- base::sys.calls
[08:26:47.974]             `[[` <- base::`[[`
[08:26:47.974]             `+` <- base::`+`
[08:26:47.974]             `<<-` <- base::`<<-`
[08:26:47.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:47.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:47.974]                   3L)]
[08:26:47.974]             }
[08:26:47.974]             function(cond) {
[08:26:47.974]                 is_error <- inherits(cond, "error")
[08:26:47.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:47.974]                   NULL)
[08:26:47.974]                 if (is_error) {
[08:26:47.974]                   sessionInformation <- function() {
[08:26:47.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:47.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:47.974]                       search = base::search(), system = base::Sys.info())
[08:26:47.974]                   }
[08:26:47.974]                   ...future.conditions[[length(...future.conditions) + 
[08:26:47.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:47.974]                     cond$call), session = sessionInformation(), 
[08:26:47.974]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:47.974]                   signalCondition(cond)
[08:26:47.974]                 }
[08:26:47.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:47.974]                 "immediateCondition"))) {
[08:26:47.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:47.974]                   ...future.conditions[[length(...future.conditions) + 
[08:26:47.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:47.974]                   if (TRUE && !signal) {
[08:26:47.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:47.974]                     {
[08:26:47.974]                       inherits <- base::inherits
[08:26:47.974]                       invokeRestart <- base::invokeRestart
[08:26:47.974]                       is.null <- base::is.null
[08:26:47.974]                       muffled <- FALSE
[08:26:47.974]                       if (inherits(cond, "message")) {
[08:26:47.974]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:47.974]                         if (muffled) 
[08:26:47.974]                           invokeRestart("muffleMessage")
[08:26:47.974]                       }
[08:26:47.974]                       else if (inherits(cond, "warning")) {
[08:26:47.974]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:47.974]                         if (muffled) 
[08:26:47.974]                           invokeRestart("muffleWarning")
[08:26:47.974]                       }
[08:26:47.974]                       else if (inherits(cond, "condition")) {
[08:26:47.974]                         if (!is.null(pattern)) {
[08:26:47.974]                           computeRestarts <- base::computeRestarts
[08:26:47.974]                           grepl <- base::grepl
[08:26:47.974]                           restarts <- computeRestarts(cond)
[08:26:47.974]                           for (restart in restarts) {
[08:26:47.974]                             name <- restart$name
[08:26:47.974]                             if (is.null(name)) 
[08:26:47.974]                               next
[08:26:47.974]                             if (!grepl(pattern, name)) 
[08:26:47.974]                               next
[08:26:47.974]                             invokeRestart(restart)
[08:26:47.974]                             muffled <- TRUE
[08:26:47.974]                             break
[08:26:47.974]                           }
[08:26:47.974]                         }
[08:26:47.974]                       }
[08:26:47.974]                       invisible(muffled)
[08:26:47.974]                     }
[08:26:47.974]                     muffleCondition(cond, pattern = "^muffle")
[08:26:47.974]                   }
[08:26:47.974]                 }
[08:26:47.974]                 else {
[08:26:47.974]                   if (TRUE) {
[08:26:47.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:47.974]                     {
[08:26:47.974]                       inherits <- base::inherits
[08:26:47.974]                       invokeRestart <- base::invokeRestart
[08:26:47.974]                       is.null <- base::is.null
[08:26:47.974]                       muffled <- FALSE
[08:26:47.974]                       if (inherits(cond, "message")) {
[08:26:47.974]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:47.974]                         if (muffled) 
[08:26:47.974]                           invokeRestart("muffleMessage")
[08:26:47.974]                       }
[08:26:47.974]                       else if (inherits(cond, "warning")) {
[08:26:47.974]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:47.974]                         if (muffled) 
[08:26:47.974]                           invokeRestart("muffleWarning")
[08:26:47.974]                       }
[08:26:47.974]                       else if (inherits(cond, "condition")) {
[08:26:47.974]                         if (!is.null(pattern)) {
[08:26:47.974]                           computeRestarts <- base::computeRestarts
[08:26:47.974]                           grepl <- base::grepl
[08:26:47.974]                           restarts <- computeRestarts(cond)
[08:26:47.974]                           for (restart in restarts) {
[08:26:47.974]                             name <- restart$name
[08:26:47.974]                             if (is.null(name)) 
[08:26:47.974]                               next
[08:26:47.974]                             if (!grepl(pattern, name)) 
[08:26:47.974]                               next
[08:26:47.974]                             invokeRestart(restart)
[08:26:47.974]                             muffled <- TRUE
[08:26:47.974]                             break
[08:26:47.974]                           }
[08:26:47.974]                         }
[08:26:47.974]                       }
[08:26:47.974]                       invisible(muffled)
[08:26:47.974]                     }
[08:26:47.974]                     muffleCondition(cond, pattern = "^muffle")
[08:26:47.974]                   }
[08:26:47.974]                 }
[08:26:47.974]             }
[08:26:47.974]         }))
[08:26:47.974]     }, error = function(ex) {
[08:26:47.974]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:47.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:47.974]                 ...future.rng), started = ...future.startTime, 
[08:26:47.974]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:47.974]             version = "1.8"), class = "FutureResult")
[08:26:47.974]     }, finally = {
[08:26:47.974]         if (!identical(...future.workdir, getwd())) 
[08:26:47.974]             setwd(...future.workdir)
[08:26:47.974]         {
[08:26:47.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:47.974]                 ...future.oldOptions$nwarnings <- NULL
[08:26:47.974]             }
[08:26:47.974]             base::options(...future.oldOptions)
[08:26:47.974]             if (.Platform$OS.type == "windows") {
[08:26:47.974]                 old_names <- names(...future.oldEnvVars)
[08:26:47.974]                 envs <- base::Sys.getenv()
[08:26:47.974]                 names <- names(envs)
[08:26:47.974]                 common <- intersect(names, old_names)
[08:26:47.974]                 added <- setdiff(names, old_names)
[08:26:47.974]                 removed <- setdiff(old_names, names)
[08:26:47.974]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:47.974]                   envs[common]]
[08:26:47.974]                 NAMES <- toupper(changed)
[08:26:47.974]                 args <- list()
[08:26:47.974]                 for (kk in seq_along(NAMES)) {
[08:26:47.974]                   name <- changed[[kk]]
[08:26:47.974]                   NAME <- NAMES[[kk]]
[08:26:47.974]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:47.974]                     next
[08:26:47.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:47.974]                 }
[08:26:47.974]                 NAMES <- toupper(added)
[08:26:47.974]                 for (kk in seq_along(NAMES)) {
[08:26:47.974]                   name <- added[[kk]]
[08:26:47.974]                   NAME <- NAMES[[kk]]
[08:26:47.974]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:47.974]                     next
[08:26:47.974]                   args[[name]] <- ""
[08:26:47.974]                 }
[08:26:47.974]                 NAMES <- toupper(removed)
[08:26:47.974]                 for (kk in seq_along(NAMES)) {
[08:26:47.974]                   name <- removed[[kk]]
[08:26:47.974]                   NAME <- NAMES[[kk]]
[08:26:47.974]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:47.974]                     next
[08:26:47.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:47.974]                 }
[08:26:47.974]                 if (length(args) > 0) 
[08:26:47.974]                   base::do.call(base::Sys.setenv, args = args)
[08:26:47.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:47.974]             }
[08:26:47.974]             else {
[08:26:47.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:47.974]             }
[08:26:47.974]             {
[08:26:47.974]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:47.974]                   0L) {
[08:26:47.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:47.974]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:47.974]                   base::options(opts)
[08:26:47.974]                 }
[08:26:47.974]                 {
[08:26:47.974]                   {
[08:26:47.974]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:47.974]                     NULL
[08:26:47.974]                   }
[08:26:47.974]                   options(future.plan = NULL)
[08:26:47.974]                   if (is.na(NA_character_)) 
[08:26:47.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:47.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:47.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:47.974]                     .init = FALSE)
[08:26:47.974]                 }
[08:26:47.974]             }
[08:26:47.974]         }
[08:26:47.974]     })
[08:26:47.974]     if (FALSE) {
[08:26:47.974]         base::sink(type = "output", split = FALSE)
[08:26:47.974]         if (NA) {
[08:26:47.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:47.974]         }
[08:26:47.974]         else {
[08:26:47.974]             ...future.result["stdout"] <- base::list(NULL)
[08:26:47.974]         }
[08:26:47.974]         base::close(...future.stdout)
[08:26:47.974]         ...future.stdout <- NULL
[08:26:47.974]     }
[08:26:47.974]     ...future.result$conditions <- ...future.conditions
[08:26:47.974]     ...future.result$finished <- base::Sys.time()
[08:26:47.974]     ...future.result
[08:26:47.974] }
[08:26:47.977] Exporting 5 global objects (1.46 KiB) to cluster node #1 ...
[08:26:47.977] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ...
[08:26:47.978] Exporting ‘...future.FUN’ (841 bytes) to cluster node #1 ... DONE
[08:26:47.978] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:26:47.978] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:26:47.978] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[08:26:47.979] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[08:26:47.979] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:47.979] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:47.979] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:47.980] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:47.980] Exporting 5 global objects (1.46 KiB) to cluster node #1 ... DONE
[08:26:47.980] MultisessionFuture started
[08:26:47.980] - Launch lazy future ... done
[08:26:47.980] run() for ‘MultisessionFuture’ ... done
[08:26:47.981] Created future:
[08:26:47.981] MultisessionFuture:
[08:26:47.981] Label: ‘future_lapply-1’
[08:26:47.981] Expression:
[08:26:47.981] {
[08:26:47.981]     do.call(function(...) {
[08:26:47.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:47.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.981]             on.exit(options(oopts), add = TRUE)
[08:26:47.981]         }
[08:26:47.981]         {
[08:26:47.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:47.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.981]                 ...future.FUN(...future.X_jj, ...)
[08:26:47.981]             })
[08:26:47.981]         }
[08:26:47.981]     }, args = future.call.arguments)
[08:26:47.981] }
[08:26:47.981] Lazy evaluation: FALSE
[08:26:47.981] Asynchronous evaluation: TRUE
[08:26:47.981] Local evaluation: TRUE
[08:26:47.981] Environment: R_GlobalEnv
[08:26:47.981] Capture standard output: NA
[08:26:47.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:47.981] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:47.981] Packages: <none>
[08:26:47.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:47.981] Resolved: FALSE
[08:26:47.981] Value: <not collected>
[08:26:47.981] Conditions captured: <none>
[08:26:47.981] Early signaling: FALSE
[08:26:47.981] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:47.981] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:47.992] Chunk #1 of 2 ... DONE
[08:26:47.993] Chunk #2 of 2 ...
[08:26:47.993]  - Finding globals in 'X' for chunk #2 ...
[08:26:47.993] getGlobalsAndPackages() ...
[08:26:47.993] Searching for globals...
[08:26:47.993] 
[08:26:47.993] Searching for globals ... DONE
[08:26:47.996] - globals: [0] <none>
[08:26:47.996] getGlobalsAndPackages() ... DONE
[08:26:47.996]    + additional globals found: [n=0] 
[08:26:47.996]    + additional namespaces needed: [n=0] 
[08:26:47.996]  - Finding globals in 'X' for chunk #2 ... DONE
[08:26:47.996]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:47.996]  - seeds: <none>
[08:26:47.996]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.997] getGlobalsAndPackages() ...
[08:26:47.997] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.997] Resolving globals: FALSE
[08:26:47.997] Tweak future expression to call with '...' arguments ...
[08:26:47.997] {
[08:26:47.997]     do.call(function(...) {
[08:26:47.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:47.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:47.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:47.997]             on.exit(options(oopts), add = TRUE)
[08:26:47.997]         }
[08:26:47.997]         {
[08:26:47.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:47.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:47.997]                 ...future.FUN(...future.X_jj, ...)
[08:26:47.997]             })
[08:26:47.997]         }
[08:26:47.997]     }, args = future.call.arguments)
[08:26:47.997] }
[08:26:47.997] Tweak future expression to call with '...' arguments ... DONE
[08:26:47.998] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:47.998] 
[08:26:47.998] getGlobalsAndPackages() ... DONE
[08:26:47.998] run() for ‘Future’ ...
[08:26:47.998] - state: ‘created’
[08:26:47.999] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:48.014] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:48.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:48.014]   - Field: ‘node’
[08:26:48.014]   - Field: ‘label’
[08:26:48.014]   - Field: ‘local’
[08:26:48.014]   - Field: ‘owner’
[08:26:48.014]   - Field: ‘envir’
[08:26:48.014]   - Field: ‘workers’
[08:26:48.015]   - Field: ‘packages’
[08:26:48.015]   - Field: ‘gc’
[08:26:48.015]   - Field: ‘conditions’
[08:26:48.015]   - Field: ‘persistent’
[08:26:48.015]   - Field: ‘expr’
[08:26:48.015]   - Field: ‘uuid’
[08:26:48.015]   - Field: ‘seed’
[08:26:48.015]   - Field: ‘version’
[08:26:48.015]   - Field: ‘result’
[08:26:48.015]   - Field: ‘asynchronous’
[08:26:48.015]   - Field: ‘calls’
[08:26:48.015]   - Field: ‘globals’
[08:26:48.016]   - Field: ‘stdout’
[08:26:48.016]   - Field: ‘earlySignal’
[08:26:48.016]   - Field: ‘lazy’
[08:26:48.016]   - Field: ‘state’
[08:26:48.016] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:48.016] - Launch lazy future ...
[08:26:48.016] Packages needed by the future expression (n = 0): <none>
[08:26:48.016] Packages needed by future strategies (n = 0): <none>
[08:26:48.017] {
[08:26:48.017]     {
[08:26:48.017]         {
[08:26:48.017]             ...future.startTime <- base::Sys.time()
[08:26:48.017]             {
[08:26:48.017]                 {
[08:26:48.017]                   {
[08:26:48.017]                     {
[08:26:48.017]                       base::local({
[08:26:48.017]                         has_future <- base::requireNamespace("future", 
[08:26:48.017]                           quietly = TRUE)
[08:26:48.017]                         if (has_future) {
[08:26:48.017]                           ns <- base::getNamespace("future")
[08:26:48.017]                           version <- ns[[".package"]][["version"]]
[08:26:48.017]                           if (is.null(version)) 
[08:26:48.017]                             version <- utils::packageVersion("future")
[08:26:48.017]                         }
[08:26:48.017]                         else {
[08:26:48.017]                           version <- NULL
[08:26:48.017]                         }
[08:26:48.017]                         if (!has_future || version < "1.8.0") {
[08:26:48.017]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:48.017]                             "", base::R.version$version.string), 
[08:26:48.017]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:48.017]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:48.017]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:48.017]                               "release", "version")], collapse = " "), 
[08:26:48.017]                             hostname = base::Sys.info()[["nodename"]])
[08:26:48.017]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:48.017]                             info)
[08:26:48.017]                           info <- base::paste(info, collapse = "; ")
[08:26:48.017]                           if (!has_future) {
[08:26:48.017]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:48.017]                               info)
[08:26:48.017]                           }
[08:26:48.017]                           else {
[08:26:48.017]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:48.017]                               info, version)
[08:26:48.017]                           }
[08:26:48.017]                           base::stop(msg)
[08:26:48.017]                         }
[08:26:48.017]                       })
[08:26:48.017]                     }
[08:26:48.017]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:48.017]                     base::options(mc.cores = 1L)
[08:26:48.017]                   }
[08:26:48.017]                   ...future.strategy.old <- future::plan("list")
[08:26:48.017]                   options(future.plan = NULL)
[08:26:48.017]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:48.017]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:48.017]                 }
[08:26:48.017]                 ...future.workdir <- getwd()
[08:26:48.017]             }
[08:26:48.017]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:48.017]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:48.017]         }
[08:26:48.017]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:48.017]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:48.017]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:48.017]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:48.017]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:48.017]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:48.017]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:48.017]             base::names(...future.oldOptions))
[08:26:48.017]     }
[08:26:48.017]     if (TRUE) {
[08:26:48.017]     }
[08:26:48.017]     else {
[08:26:48.017]         if (NA) {
[08:26:48.017]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:48.017]                 open = "w")
[08:26:48.017]         }
[08:26:48.017]         else {
[08:26:48.017]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:48.017]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:48.017]         }
[08:26:48.017]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:48.017]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:48.017]             base::sink(type = "output", split = FALSE)
[08:26:48.017]             base::close(...future.stdout)
[08:26:48.017]         }, add = TRUE)
[08:26:48.017]     }
[08:26:48.017]     ...future.frame <- base::sys.nframe()
[08:26:48.017]     ...future.conditions <- base::list()
[08:26:48.017]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:48.017]     if (FALSE) {
[08:26:48.017]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:48.017]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:48.017]     }
[08:26:48.017]     ...future.result <- base::tryCatch({
[08:26:48.017]         base::withCallingHandlers({
[08:26:48.017]             ...future.value <- base::withVisible(base::local({
[08:26:48.017]                 ...future.makeSendCondition <- base::local({
[08:26:48.017]                   sendCondition <- NULL
[08:26:48.017]                   function(frame = 1L) {
[08:26:48.017]                     if (is.function(sendCondition)) 
[08:26:48.017]                       return(sendCondition)
[08:26:48.017]                     ns <- getNamespace("parallel")
[08:26:48.017]                     if (exists("sendData", mode = "function", 
[08:26:48.017]                       envir = ns)) {
[08:26:48.017]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:48.017]                         envir = ns)
[08:26:48.017]                       envir <- sys.frame(frame)
[08:26:48.017]                       master <- NULL
[08:26:48.017]                       while (!identical(envir, .GlobalEnv) && 
[08:26:48.017]                         !identical(envir, emptyenv())) {
[08:26:48.017]                         if (exists("master", mode = "list", envir = envir, 
[08:26:48.017]                           inherits = FALSE)) {
[08:26:48.017]                           master <- get("master", mode = "list", 
[08:26:48.017]                             envir = envir, inherits = FALSE)
[08:26:48.017]                           if (inherits(master, c("SOCKnode", 
[08:26:48.017]                             "SOCK0node"))) {
[08:26:48.017]                             sendCondition <<- function(cond) {
[08:26:48.017]                               data <- list(type = "VALUE", value = cond, 
[08:26:48.017]                                 success = TRUE)
[08:26:48.017]                               parallel_sendData(master, data)
[08:26:48.017]                             }
[08:26:48.017]                             return(sendCondition)
[08:26:48.017]                           }
[08:26:48.017]                         }
[08:26:48.017]                         frame <- frame + 1L
[08:26:48.017]                         envir <- sys.frame(frame)
[08:26:48.017]                       }
[08:26:48.017]                     }
[08:26:48.017]                     sendCondition <<- function(cond) NULL
[08:26:48.017]                   }
[08:26:48.017]                 })
[08:26:48.017]                 withCallingHandlers({
[08:26:48.017]                   {
[08:26:48.017]                     do.call(function(...) {
[08:26:48.017]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:48.017]                       if (!identical(...future.globals.maxSize.org, 
[08:26:48.017]                         ...future.globals.maxSize)) {
[08:26:48.017]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:48.017]                         on.exit(options(oopts), add = TRUE)
[08:26:48.017]                       }
[08:26:48.017]                       {
[08:26:48.017]                         lapply(seq_along(...future.elements_ii), 
[08:26:48.017]                           FUN = function(jj) {
[08:26:48.017]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:48.017]                             ...future.FUN(...future.X_jj, ...)
[08:26:48.017]                           })
[08:26:48.017]                       }
[08:26:48.017]                     }, args = future.call.arguments)
[08:26:48.017]                   }
[08:26:48.017]                 }, immediateCondition = function(cond) {
[08:26:48.017]                   sendCondition <- ...future.makeSendCondition()
[08:26:48.017]                   sendCondition(cond)
[08:26:48.017]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:48.017]                   {
[08:26:48.017]                     inherits <- base::inherits
[08:26:48.017]                     invokeRestart <- base::invokeRestart
[08:26:48.017]                     is.null <- base::is.null
[08:26:48.017]                     muffled <- FALSE
[08:26:48.017]                     if (inherits(cond, "message")) {
[08:26:48.017]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:48.017]                       if (muffled) 
[08:26:48.017]                         invokeRestart("muffleMessage")
[08:26:48.017]                     }
[08:26:48.017]                     else if (inherits(cond, "warning")) {
[08:26:48.017]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:48.017]                       if (muffled) 
[08:26:48.017]                         invokeRestart("muffleWarning")
[08:26:48.017]                     }
[08:26:48.017]                     else if (inherits(cond, "condition")) {
[08:26:48.017]                       if (!is.null(pattern)) {
[08:26:48.017]                         computeRestarts <- base::computeRestarts
[08:26:48.017]                         grepl <- base::grepl
[08:26:48.017]                         restarts <- computeRestarts(cond)
[08:26:48.017]                         for (restart in restarts) {
[08:26:48.017]                           name <- restart$name
[08:26:48.017]                           if (is.null(name)) 
[08:26:48.017]                             next
[08:26:48.017]                           if (!grepl(pattern, name)) 
[08:26:48.017]                             next
[08:26:48.017]                           invokeRestart(restart)
[08:26:48.017]                           muffled <- TRUE
[08:26:48.017]                           break
[08:26:48.017]                         }
[08:26:48.017]                       }
[08:26:48.017]                     }
[08:26:48.017]                     invisible(muffled)
[08:26:48.017]                   }
[08:26:48.017]                   muffleCondition(cond)
[08:26:48.017]                 })
[08:26:48.017]             }))
[08:26:48.017]             future::FutureResult(value = ...future.value$value, 
[08:26:48.017]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:48.017]                   ...future.rng), globalenv = if (FALSE) 
[08:26:48.017]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:48.017]                     ...future.globalenv.names))
[08:26:48.017]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:48.017]         }, condition = base::local({
[08:26:48.017]             c <- base::c
[08:26:48.017]             inherits <- base::inherits
[08:26:48.017]             invokeRestart <- base::invokeRestart
[08:26:48.017]             length <- base::length
[08:26:48.017]             list <- base::list
[08:26:48.017]             seq.int <- base::seq.int
[08:26:48.017]             signalCondition <- base::signalCondition
[08:26:48.017]             sys.calls <- base::sys.calls
[08:26:48.017]             `[[` <- base::`[[`
[08:26:48.017]             `+` <- base::`+`
[08:26:48.017]             `<<-` <- base::`<<-`
[08:26:48.017]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:48.017]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:48.017]                   3L)]
[08:26:48.017]             }
[08:26:48.017]             function(cond) {
[08:26:48.017]                 is_error <- inherits(cond, "error")
[08:26:48.017]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:48.017]                   NULL)
[08:26:48.017]                 if (is_error) {
[08:26:48.017]                   sessionInformation <- function() {
[08:26:48.017]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:48.017]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:48.017]                       search = base::search(), system = base::Sys.info())
[08:26:48.017]                   }
[08:26:48.017]                   ...future.conditions[[length(...future.conditions) + 
[08:26:48.017]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:48.017]                     cond$call), session = sessionInformation(), 
[08:26:48.017]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:48.017]                   signalCondition(cond)
[08:26:48.017]                 }
[08:26:48.017]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:48.017]                 "immediateCondition"))) {
[08:26:48.017]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:48.017]                   ...future.conditions[[length(...future.conditions) + 
[08:26:48.017]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:48.017]                   if (TRUE && !signal) {
[08:26:48.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:48.017]                     {
[08:26:48.017]                       inherits <- base::inherits
[08:26:48.017]                       invokeRestart <- base::invokeRestart
[08:26:48.017]                       is.null <- base::is.null
[08:26:48.017]                       muffled <- FALSE
[08:26:48.017]                       if (inherits(cond, "message")) {
[08:26:48.017]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:48.017]                         if (muffled) 
[08:26:48.017]                           invokeRestart("muffleMessage")
[08:26:48.017]                       }
[08:26:48.017]                       else if (inherits(cond, "warning")) {
[08:26:48.017]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:48.017]                         if (muffled) 
[08:26:48.017]                           invokeRestart("muffleWarning")
[08:26:48.017]                       }
[08:26:48.017]                       else if (inherits(cond, "condition")) {
[08:26:48.017]                         if (!is.null(pattern)) {
[08:26:48.017]                           computeRestarts <- base::computeRestarts
[08:26:48.017]                           grepl <- base::grepl
[08:26:48.017]                           restarts <- computeRestarts(cond)
[08:26:48.017]                           for (restart in restarts) {
[08:26:48.017]                             name <- restart$name
[08:26:48.017]                             if (is.null(name)) 
[08:26:48.017]                               next
[08:26:48.017]                             if (!grepl(pattern, name)) 
[08:26:48.017]                               next
[08:26:48.017]                             invokeRestart(restart)
[08:26:48.017]                             muffled <- TRUE
[08:26:48.017]                             break
[08:26:48.017]                           }
[08:26:48.017]                         }
[08:26:48.017]                       }
[08:26:48.017]                       invisible(muffled)
[08:26:48.017]                     }
[08:26:48.017]                     muffleCondition(cond, pattern = "^muffle")
[08:26:48.017]                   }
[08:26:48.017]                 }
[08:26:48.017]                 else {
[08:26:48.017]                   if (TRUE) {
[08:26:48.017]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:48.017]                     {
[08:26:48.017]                       inherits <- base::inherits
[08:26:48.017]                       invokeRestart <- base::invokeRestart
[08:26:48.017]                       is.null <- base::is.null
[08:26:48.017]                       muffled <- FALSE
[08:26:48.017]                       if (inherits(cond, "message")) {
[08:26:48.017]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:48.017]                         if (muffled) 
[08:26:48.017]                           invokeRestart("muffleMessage")
[08:26:48.017]                       }
[08:26:48.017]                       else if (inherits(cond, "warning")) {
[08:26:48.017]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:48.017]                         if (muffled) 
[08:26:48.017]                           invokeRestart("muffleWarning")
[08:26:48.017]                       }
[08:26:48.017]                       else if (inherits(cond, "condition")) {
[08:26:48.017]                         if (!is.null(pattern)) {
[08:26:48.017]                           computeRestarts <- base::computeRestarts
[08:26:48.017]                           grepl <- base::grepl
[08:26:48.017]                           restarts <- computeRestarts(cond)
[08:26:48.017]                           for (restart in restarts) {
[08:26:48.017]                             name <- restart$name
[08:26:48.017]                             if (is.null(name)) 
[08:26:48.017]                               next
[08:26:48.017]                             if (!grepl(pattern, name)) 
[08:26:48.017]                               next
[08:26:48.017]                             invokeRestart(restart)
[08:26:48.017]                             muffled <- TRUE
[08:26:48.017]                             break
[08:26:48.017]                           }
[08:26:48.017]                         }
[08:26:48.017]                       }
[08:26:48.017]                       invisible(muffled)
[08:26:48.017]                     }
[08:26:48.017]                     muffleCondition(cond, pattern = "^muffle")
[08:26:48.017]                   }
[08:26:48.017]                 }
[08:26:48.017]             }
[08:26:48.017]         }))
[08:26:48.017]     }, error = function(ex) {
[08:26:48.017]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:48.017]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:48.017]                 ...future.rng), started = ...future.startTime, 
[08:26:48.017]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:48.017]             version = "1.8"), class = "FutureResult")
[08:26:48.017]     }, finally = {
[08:26:48.017]         if (!identical(...future.workdir, getwd())) 
[08:26:48.017]             setwd(...future.workdir)
[08:26:48.017]         {
[08:26:48.017]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:48.017]                 ...future.oldOptions$nwarnings <- NULL
[08:26:48.017]             }
[08:26:48.017]             base::options(...future.oldOptions)
[08:26:48.017]             if (.Platform$OS.type == "windows") {
[08:26:48.017]                 old_names <- names(...future.oldEnvVars)
[08:26:48.017]                 envs <- base::Sys.getenv()
[08:26:48.017]                 names <- names(envs)
[08:26:48.017]                 common <- intersect(names, old_names)
[08:26:48.017]                 added <- setdiff(names, old_names)
[08:26:48.017]                 removed <- setdiff(old_names, names)
[08:26:48.017]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:48.017]                   envs[common]]
[08:26:48.017]                 NAMES <- toupper(changed)
[08:26:48.017]                 args <- list()
[08:26:48.017]                 for (kk in seq_along(NAMES)) {
[08:26:48.017]                   name <- changed[[kk]]
[08:26:48.017]                   NAME <- NAMES[[kk]]
[08:26:48.017]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:48.017]                     next
[08:26:48.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:48.017]                 }
[08:26:48.017]                 NAMES <- toupper(added)
[08:26:48.017]                 for (kk in seq_along(NAMES)) {
[08:26:48.017]                   name <- added[[kk]]
[08:26:48.017]                   NAME <- NAMES[[kk]]
[08:26:48.017]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:48.017]                     next
[08:26:48.017]                   args[[name]] <- ""
[08:26:48.017]                 }
[08:26:48.017]                 NAMES <- toupper(removed)
[08:26:48.017]                 for (kk in seq_along(NAMES)) {
[08:26:48.017]                   name <- removed[[kk]]
[08:26:48.017]                   NAME <- NAMES[[kk]]
[08:26:48.017]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:48.017]                     next
[08:26:48.017]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:48.017]                 }
[08:26:48.017]                 if (length(args) > 0) 
[08:26:48.017]                   base::do.call(base::Sys.setenv, args = args)
[08:26:48.017]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:48.017]             }
[08:26:48.017]             else {
[08:26:48.017]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:48.017]             }
[08:26:48.017]             {
[08:26:48.017]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:48.017]                   0L) {
[08:26:48.017]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:48.017]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:48.017]                   base::options(opts)
[08:26:48.017]                 }
[08:26:48.017]                 {
[08:26:48.017]                   {
[08:26:48.017]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:48.017]                     NULL
[08:26:48.017]                   }
[08:26:48.017]                   options(future.plan = NULL)
[08:26:48.017]                   if (is.na(NA_character_)) 
[08:26:48.017]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:48.017]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:48.017]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:48.017]                     .init = FALSE)
[08:26:48.017]                 }
[08:26:48.017]             }
[08:26:48.017]         }
[08:26:48.017]     })
[08:26:48.017]     if (FALSE) {
[08:26:48.017]         base::sink(type = "output", split = FALSE)
[08:26:48.017]         if (NA) {
[08:26:48.017]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:48.017]         }
[08:26:48.017]         else {
[08:26:48.017]             ...future.result["stdout"] <- base::list(NULL)
[08:26:48.017]         }
[08:26:48.017]         base::close(...future.stdout)
[08:26:48.017]         ...future.stdout <- NULL
[08:26:48.017]     }
[08:26:48.017]     ...future.result$conditions <- ...future.conditions
[08:26:48.017]     ...future.result$finished <- base::Sys.time()
[08:26:48.017]     ...future.result
[08:26:48.017] }
[08:26:48.020] Exporting 5 global objects (1.46 KiB) to cluster node #2 ...
[08:26:48.020] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ...
[08:26:48.021] Exporting ‘...future.FUN’ (841 bytes) to cluster node #2 ... DONE
[08:26:48.021] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:26:48.021] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:26:48.021] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[08:26:48.022] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[08:26:48.022] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:48.022] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:48.022] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:48.023] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:48.023] Exporting 5 global objects (1.46 KiB) to cluster node #2 ... DONE
[08:26:48.023] MultisessionFuture started
[08:26:48.023] - Launch lazy future ... done
[08:26:48.024] run() for ‘MultisessionFuture’ ... done
[08:26:48.024] Created future:
[08:26:48.024] MultisessionFuture:
[08:26:48.024] Label: ‘future_lapply-2’
[08:26:48.024] Expression:
[08:26:48.024] {
[08:26:48.024]     do.call(function(...) {
[08:26:48.024]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:48.024]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:48.024]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:48.024]             on.exit(options(oopts), add = TRUE)
[08:26:48.024]         }
[08:26:48.024]         {
[08:26:48.024]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:26:48.024]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:26:48.024]                 ...future.FUN(...future.X_jj, ...)
[08:26:48.024]             })
[08:26:48.024]         }
[08:26:48.024]     }, args = future.call.arguments)
[08:26:48.024] }
[08:26:48.024] Lazy evaluation: FALSE
[08:26:48.024] Asynchronous evaluation: TRUE
[08:26:48.024] Local evaluation: TRUE
[08:26:48.024] Environment: R_GlobalEnv
[08:26:48.024] Capture standard output: NA
[08:26:48.024] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:48.024] Globals: 5 objects totaling 1.01 KiB (function ‘...future.FUN’ of 841 bytes, DotDotDotList ‘future.call.arguments’ of 97 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:48.024] Packages: <none>
[08:26:48.024] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:48.024] Resolved: FALSE
[08:26:48.024] Value: <not collected>
[08:26:48.024] Conditions captured: <none>
[08:26:48.024] Early signaling: FALSE
[08:26:48.024] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:48.024] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:48.035] Chunk #2 of 2 ... DONE
[08:26:48.036] Launching 2 futures (chunks) ... DONE
[08:26:48.036] Resolving 2 futures (chunks) ...
[08:26:48.036] resolve() on list ...
[08:26:48.036]  recursive: 0
[08:26:48.036]  length: 2
[08:26:48.036] 
[08:26:48.079] receiveMessageFromWorker() for ClusterFuture ...
[08:26:48.079] - Validating connection of MultisessionFuture
[08:26:48.080] - received message: FutureResult
[08:26:48.080] - Received FutureResult
[08:26:48.080] - Erased future from FutureRegistry
[08:26:48.080] result() for ClusterFuture ...
[08:26:48.080] - result already collected: FutureResult
[08:26:48.080] result() for ClusterFuture ... done
[08:26:48.080] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:48.080] Future #2
[08:26:48.080] result() for ClusterFuture ...
[08:26:48.081] - result already collected: FutureResult
[08:26:48.081] result() for ClusterFuture ... done
[08:26:48.081] result() for ClusterFuture ...
[08:26:48.081] - result already collected: FutureResult
[08:26:48.081] result() for ClusterFuture ... done
[08:26:48.081] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:48.081] - nx: 2
[08:26:48.081] - relay: TRUE
[08:26:48.081] - stdout: TRUE
[08:26:48.081] - signal: TRUE
[08:26:48.081] - resignal: FALSE
[08:26:48.081] - force: TRUE
[08:26:48.082] - relayed: [n=2] FALSE, FALSE
[08:26:48.082] - queued futures: [n=2] FALSE, FALSE
[08:26:48.082]  - until=1
[08:26:48.082]  - relaying element #1
[08:26:48.082] - relayed: [n=2] FALSE, FALSE
[08:26:48.082] - queued futures: [n=2] FALSE, TRUE
[08:26:48.082] signalConditionsASAP(NULL, pos=2) ... done
[08:26:48.082]  length: 1 (resolved future 2)
[08:26:48.533] receiveMessageFromWorker() for ClusterFuture ...
[08:26:48.533] - Validating connection of MultisessionFuture
[08:26:48.533] - received message: FutureResult
[08:26:48.533] - Received FutureResult
[08:26:48.533] - Erased future from FutureRegistry
[08:26:48.533] result() for ClusterFuture ...
[08:26:48.534] - result already collected: FutureResult
[08:26:48.534] result() for ClusterFuture ... done
[08:26:48.534] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:48.534] Future #1
[08:26:48.534] result() for ClusterFuture ...
[08:26:48.534] - result already collected: FutureResult
[08:26:48.534] result() for ClusterFuture ... done
[08:26:48.534] result() for ClusterFuture ...
[08:26:48.534] - result already collected: FutureResult
[08:26:48.534] result() for ClusterFuture ... done
[08:26:48.534] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:48.535] - nx: 2
[08:26:48.535] - relay: TRUE
[08:26:48.535] - stdout: TRUE
[08:26:48.535] - signal: TRUE
[08:26:48.535] - resignal: FALSE
[08:26:48.535] - force: TRUE
[08:26:48.535] - relayed: [n=2] FALSE, FALSE
[08:26:48.535] - queued futures: [n=2] FALSE, TRUE
[08:26:48.535]  - until=1
[08:26:48.535]  - relaying element #1
[08:26:48.535] result() for ClusterFuture ...
[08:26:48.535] - result already collected: FutureResult
[08:26:48.536] result() for ClusterFuture ... done
[08:26:48.536] result() for ClusterFuture ...
[08:26:48.536] - result already collected: FutureResult
[08:26:48.536] result() for ClusterFuture ... done
[08:26:48.536] result() for ClusterFuture ...
[08:26:48.536] - result already collected: FutureResult
[08:26:48.536] result() for ClusterFuture ... done
[08:26:48.536] result() for ClusterFuture ...
[08:26:48.536] - result already collected: FutureResult
[08:26:48.536] result() for ClusterFuture ... done
[08:26:48.536] - relayed: [n=2] TRUE, FALSE
[08:26:48.536] - queued futures: [n=2] TRUE, TRUE
[08:26:48.537] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:48.537]  length: 0 (resolved future 1)
[08:26:48.537] Relaying remaining futures
[08:26:48.537] signalConditionsASAP(NULL, pos=0) ...
[08:26:48.537] - nx: 2
[08:26:48.537] - relay: TRUE
[08:26:48.537] - stdout: TRUE
[08:26:48.537] - signal: TRUE
[08:26:48.537] - resignal: FALSE
[08:26:48.537] - force: TRUE
[08:26:48.537] - relayed: [n=2] TRUE, FALSE
[08:26:48.537] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:48.538]  - relaying element #2
[08:26:48.538] result() for ClusterFuture ...
[08:26:48.538] - result already collected: FutureResult
[08:26:48.538] result() for ClusterFuture ... done
[08:26:48.538] result() for ClusterFuture ...
[08:26:48.538] - result already collected: FutureResult
[08:26:48.538] result() for ClusterFuture ... done
[08:26:48.538] result() for ClusterFuture ...
[08:26:48.538] - result already collected: FutureResult
[08:26:48.538] result() for ClusterFuture ... done
[08:26:48.538] result() for ClusterFuture ...
[08:26:48.538] - result already collected: FutureResult
[08:26:48.539] result() for ClusterFuture ... done
[08:26:48.539] - relayed: [n=2] TRUE, TRUE
[08:26:48.539] - queued futures: [n=2] TRUE, TRUE
[08:26:48.539] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[08:26:48.539] resolve() on list ... DONE
[08:26:48.539] result() for ClusterFuture ...
[08:26:48.539] - result already collected: FutureResult
[08:26:48.539] result() for ClusterFuture ... done
[08:26:48.539] result() for ClusterFuture ...
[08:26:48.539] - result already collected: FutureResult
[08:26:48.539] result() for ClusterFuture ... done
[08:26:48.539] result() for ClusterFuture ...
[08:26:48.540] - result already collected: FutureResult
[08:26:48.540] result() for ClusterFuture ... done
[08:26:48.540] result() for ClusterFuture ...
[08:26:48.540] - result already collected: FutureResult
[08:26:48.540] result() for ClusterFuture ... done
[08:26:48.540]  - Number of value chunks collected: 2
[08:26:48.540] Resolving 2 futures (chunks) ... DONE
[08:26:48.540] Reducing values from 2 chunks ...
[08:26:48.540]  - Number of values collected after concatenation: 2
[08:26:48.540]  - Number of values expected: 2
[08:26:48.540] Reducing values from 2 chunks ... DONE
[08:26:48.540] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[08:26:48.541] future_mapply() ...
[08:26:48.543] Number of chunks: 2
[08:26:48.543] getGlobalsAndPackagesXApply() ...
[08:26:48.543]  - future.globals: TRUE
[08:26:48.543] getGlobalsAndPackages() ...
[08:26:48.543] Searching for globals...
[08:26:48.545] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:48.545] Searching for globals ... DONE
[08:26:48.545] Resolving globals: FALSE
[08:26:48.545] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:48.546] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:48.546] - globals: [1] ‘FUN’
[08:26:48.546] 
[08:26:48.546] getGlobalsAndPackages() ... DONE
[08:26:48.546]  - globals found/used: [n=1] ‘FUN’
[08:26:48.546]  - needed namespaces: [n=0] 
[08:26:48.546] Finding globals ... DONE
[08:26:48.547] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:48.547] List of 2
[08:26:48.547]  $ ...future.FUN:function (x, y)  
[08:26:48.547]  $ MoreArgs     : NULL
[08:26:48.547]  - attr(*, "where")=List of 2
[08:26:48.547]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:48.547]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:48.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:48.547]  - attr(*, "resolved")= logi FALSE
[08:26:48.547]  - attr(*, "total_size")= num NA
[08:26:48.549] Packages to be attached in all futures: [n=0] 
[08:26:48.549] getGlobalsAndPackagesXApply() ... DONE
[08:26:48.550] Number of futures (= number of chunks): 2
[08:26:48.550] Launching 2 futures (chunks) ...
[08:26:48.550] Chunk #1 of 2 ...
[08:26:48.550]  - Finding globals in '...' for chunk #1 ...
[08:26:48.550] getGlobalsAndPackages() ...
[08:26:48.550] Searching for globals...
[08:26:48.550] 
[08:26:48.551] Searching for globals ... DONE
[08:26:48.551] - globals: [0] <none>
[08:26:48.551] getGlobalsAndPackages() ... DONE
[08:26:48.551]    + additional globals found: [n=0] 
[08:26:48.551]    + additional namespaces needed: [n=0] 
[08:26:48.551]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:48.551]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:48.551]  - seeds: <none>
[08:26:48.551]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:48.551] getGlobalsAndPackages() ...
[08:26:48.551] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:48.552] Resolving globals: FALSE
[08:26:48.552] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:48.552] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:48.553] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:48.553] 
[08:26:48.553] getGlobalsAndPackages() ... DONE
[08:26:48.553] run() for ‘Future’ ...
[08:26:48.553] - state: ‘created’
[08:26:48.553] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:48.568] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:48.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:48.568]   - Field: ‘node’
[08:26:48.568]   - Field: ‘label’
[08:26:48.568]   - Field: ‘local’
[08:26:48.568]   - Field: ‘owner’
[08:26:48.568]   - Field: ‘envir’
[08:26:48.569]   - Field: ‘workers’
[08:26:48.569]   - Field: ‘packages’
[08:26:48.569]   - Field: ‘gc’
[08:26:48.569]   - Field: ‘conditions’
[08:26:48.569]   - Field: ‘persistent’
[08:26:48.569]   - Field: ‘expr’
[08:26:48.569]   - Field: ‘uuid’
[08:26:48.569]   - Field: ‘seed’
[08:26:48.569]   - Field: ‘version’
[08:26:48.569]   - Field: ‘result’
[08:26:48.569]   - Field: ‘asynchronous’
[08:26:48.569]   - Field: ‘calls’
[08:26:48.570]   - Field: ‘globals’
[08:26:48.570]   - Field: ‘stdout’
[08:26:48.570]   - Field: ‘earlySignal’
[08:26:48.570]   - Field: ‘lazy’
[08:26:48.570]   - Field: ‘state’
[08:26:48.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:48.570] - Launch lazy future ...
[08:26:48.570] Packages needed by the future expression (n = 0): <none>
[08:26:48.571] Packages needed by future strategies (n = 0): <none>
[08:26:48.571] {
[08:26:48.571]     {
[08:26:48.571]         {
[08:26:48.571]             ...future.startTime <- base::Sys.time()
[08:26:48.571]             {
[08:26:48.571]                 {
[08:26:48.571]                   {
[08:26:48.571]                     {
[08:26:48.571]                       base::local({
[08:26:48.571]                         has_future <- base::requireNamespace("future", 
[08:26:48.571]                           quietly = TRUE)
[08:26:48.571]                         if (has_future) {
[08:26:48.571]                           ns <- base::getNamespace("future")
[08:26:48.571]                           version <- ns[[".package"]][["version"]]
[08:26:48.571]                           if (is.null(version)) 
[08:26:48.571]                             version <- utils::packageVersion("future")
[08:26:48.571]                         }
[08:26:48.571]                         else {
[08:26:48.571]                           version <- NULL
[08:26:48.571]                         }
[08:26:48.571]                         if (!has_future || version < "1.8.0") {
[08:26:48.571]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:48.571]                             "", base::R.version$version.string), 
[08:26:48.571]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:48.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:48.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:48.571]                               "release", "version")], collapse = " "), 
[08:26:48.571]                             hostname = base::Sys.info()[["nodename"]])
[08:26:48.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:48.571]                             info)
[08:26:48.571]                           info <- base::paste(info, collapse = "; ")
[08:26:48.571]                           if (!has_future) {
[08:26:48.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:48.571]                               info)
[08:26:48.571]                           }
[08:26:48.571]                           else {
[08:26:48.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:48.571]                               info, version)
[08:26:48.571]                           }
[08:26:48.571]                           base::stop(msg)
[08:26:48.571]                         }
[08:26:48.571]                       })
[08:26:48.571]                     }
[08:26:48.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:48.571]                     base::options(mc.cores = 1L)
[08:26:48.571]                   }
[08:26:48.571]                   ...future.strategy.old <- future::plan("list")
[08:26:48.571]                   options(future.plan = NULL)
[08:26:48.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:48.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:48.571]                 }
[08:26:48.571]                 ...future.workdir <- getwd()
[08:26:48.571]             }
[08:26:48.571]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:48.571]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:48.571]         }
[08:26:48.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:48.571]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:48.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:48.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:48.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:48.571]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:48.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:48.571]             base::names(...future.oldOptions))
[08:26:48.571]     }
[08:26:48.571]     if (FALSE) {
[08:26:48.571]     }
[08:26:48.571]     else {
[08:26:48.571]         if (FALSE) {
[08:26:48.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:48.571]                 open = "w")
[08:26:48.571]         }
[08:26:48.571]         else {
[08:26:48.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:48.571]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:48.571]         }
[08:26:48.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:48.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:48.571]             base::sink(type = "output", split = FALSE)
[08:26:48.571]             base::close(...future.stdout)
[08:26:48.571]         }, add = TRUE)
[08:26:48.571]     }
[08:26:48.571]     ...future.frame <- base::sys.nframe()
[08:26:48.571]     ...future.conditions <- base::list()
[08:26:48.571]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:48.571]     if (FALSE) {
[08:26:48.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:48.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:48.571]     }
[08:26:48.571]     ...future.result <- base::tryCatch({
[08:26:48.571]         base::withCallingHandlers({
[08:26:48.571]             ...future.value <- base::withVisible(base::local({
[08:26:48.571]                 ...future.makeSendCondition <- base::local({
[08:26:48.571]                   sendCondition <- NULL
[08:26:48.571]                   function(frame = 1L) {
[08:26:48.571]                     if (is.function(sendCondition)) 
[08:26:48.571]                       return(sendCondition)
[08:26:48.571]                     ns <- getNamespace("parallel")
[08:26:48.571]                     if (exists("sendData", mode = "function", 
[08:26:48.571]                       envir = ns)) {
[08:26:48.571]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:48.571]                         envir = ns)
[08:26:48.571]                       envir <- sys.frame(frame)
[08:26:48.571]                       master <- NULL
[08:26:48.571]                       while (!identical(envir, .GlobalEnv) && 
[08:26:48.571]                         !identical(envir, emptyenv())) {
[08:26:48.571]                         if (exists("master", mode = "list", envir = envir, 
[08:26:48.571]                           inherits = FALSE)) {
[08:26:48.571]                           master <- get("master", mode = "list", 
[08:26:48.571]                             envir = envir, inherits = FALSE)
[08:26:48.571]                           if (inherits(master, c("SOCKnode", 
[08:26:48.571]                             "SOCK0node"))) {
[08:26:48.571]                             sendCondition <<- function(cond) {
[08:26:48.571]                               data <- list(type = "VALUE", value = cond, 
[08:26:48.571]                                 success = TRUE)
[08:26:48.571]                               parallel_sendData(master, data)
[08:26:48.571]                             }
[08:26:48.571]                             return(sendCondition)
[08:26:48.571]                           }
[08:26:48.571]                         }
[08:26:48.571]                         frame <- frame + 1L
[08:26:48.571]                         envir <- sys.frame(frame)
[08:26:48.571]                       }
[08:26:48.571]                     }
[08:26:48.571]                     sendCondition <<- function(cond) NULL
[08:26:48.571]                   }
[08:26:48.571]                 })
[08:26:48.571]                 withCallingHandlers({
[08:26:48.571]                   {
[08:26:48.571]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:48.571]                     if (!identical(...future.globals.maxSize.org, 
[08:26:48.571]                       ...future.globals.maxSize)) {
[08:26:48.571]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:48.571]                       on.exit(options(oopts), add = TRUE)
[08:26:48.571]                     }
[08:26:48.571]                     {
[08:26:48.571]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:48.571]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:48.571]                         USE.NAMES = FALSE)
[08:26:48.571]                       do.call(mapply, args = args)
[08:26:48.571]                     }
[08:26:48.571]                   }
[08:26:48.571]                 }, immediateCondition = function(cond) {
[08:26:48.571]                   sendCondition <- ...future.makeSendCondition()
[08:26:48.571]                   sendCondition(cond)
[08:26:48.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:48.571]                   {
[08:26:48.571]                     inherits <- base::inherits
[08:26:48.571]                     invokeRestart <- base::invokeRestart
[08:26:48.571]                     is.null <- base::is.null
[08:26:48.571]                     muffled <- FALSE
[08:26:48.571]                     if (inherits(cond, "message")) {
[08:26:48.571]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:48.571]                       if (muffled) 
[08:26:48.571]                         invokeRestart("muffleMessage")
[08:26:48.571]                     }
[08:26:48.571]                     else if (inherits(cond, "warning")) {
[08:26:48.571]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:48.571]                       if (muffled) 
[08:26:48.571]                         invokeRestart("muffleWarning")
[08:26:48.571]                     }
[08:26:48.571]                     else if (inherits(cond, "condition")) {
[08:26:48.571]                       if (!is.null(pattern)) {
[08:26:48.571]                         computeRestarts <- base::computeRestarts
[08:26:48.571]                         grepl <- base::grepl
[08:26:48.571]                         restarts <- computeRestarts(cond)
[08:26:48.571]                         for (restart in restarts) {
[08:26:48.571]                           name <- restart$name
[08:26:48.571]                           if (is.null(name)) 
[08:26:48.571]                             next
[08:26:48.571]                           if (!grepl(pattern, name)) 
[08:26:48.571]                             next
[08:26:48.571]                           invokeRestart(restart)
[08:26:48.571]                           muffled <- TRUE
[08:26:48.571]                           break
[08:26:48.571]                         }
[08:26:48.571]                       }
[08:26:48.571]                     }
[08:26:48.571]                     invisible(muffled)
[08:26:48.571]                   }
[08:26:48.571]                   muffleCondition(cond)
[08:26:48.571]                 })
[08:26:48.571]             }))
[08:26:48.571]             future::FutureResult(value = ...future.value$value, 
[08:26:48.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:48.571]                   ...future.rng), globalenv = if (FALSE) 
[08:26:48.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:48.571]                     ...future.globalenv.names))
[08:26:48.571]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:48.571]         }, condition = base::local({
[08:26:48.571]             c <- base::c
[08:26:48.571]             inherits <- base::inherits
[08:26:48.571]             invokeRestart <- base::invokeRestart
[08:26:48.571]             length <- base::length
[08:26:48.571]             list <- base::list
[08:26:48.571]             seq.int <- base::seq.int
[08:26:48.571]             signalCondition <- base::signalCondition
[08:26:48.571]             sys.calls <- base::sys.calls
[08:26:48.571]             `[[` <- base::`[[`
[08:26:48.571]             `+` <- base::`+`
[08:26:48.571]             `<<-` <- base::`<<-`
[08:26:48.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:48.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:48.571]                   3L)]
[08:26:48.571]             }
[08:26:48.571]             function(cond) {
[08:26:48.571]                 is_error <- inherits(cond, "error")
[08:26:48.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:48.571]                   NULL)
[08:26:48.571]                 if (is_error) {
[08:26:48.571]                   sessionInformation <- function() {
[08:26:48.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:48.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:48.571]                       search = base::search(), system = base::Sys.info())
[08:26:48.571]                   }
[08:26:48.571]                   ...future.conditions[[length(...future.conditions) + 
[08:26:48.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:48.571]                     cond$call), session = sessionInformation(), 
[08:26:48.571]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:48.571]                   signalCondition(cond)
[08:26:48.571]                 }
[08:26:48.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:48.571]                 "immediateCondition"))) {
[08:26:48.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:48.571]                   ...future.conditions[[length(...future.conditions) + 
[08:26:48.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:48.571]                   if (TRUE && !signal) {
[08:26:48.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:48.571]                     {
[08:26:48.571]                       inherits <- base::inherits
[08:26:48.571]                       invokeRestart <- base::invokeRestart
[08:26:48.571]                       is.null <- base::is.null
[08:26:48.571]                       muffled <- FALSE
[08:26:48.571]                       if (inherits(cond, "message")) {
[08:26:48.571]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:48.571]                         if (muffled) 
[08:26:48.571]                           invokeRestart("muffleMessage")
[08:26:48.571]                       }
[08:26:48.571]                       else if (inherits(cond, "warning")) {
[08:26:48.571]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:48.571]                         if (muffled) 
[08:26:48.571]                           invokeRestart("muffleWarning")
[08:26:48.571]                       }
[08:26:48.571]                       else if (inherits(cond, "condition")) {
[08:26:48.571]                         if (!is.null(pattern)) {
[08:26:48.571]                           computeRestarts <- base::computeRestarts
[08:26:48.571]                           grepl <- base::grepl
[08:26:48.571]                           restarts <- computeRestarts(cond)
[08:26:48.571]                           for (restart in restarts) {
[08:26:48.571]                             name <- restart$name
[08:26:48.571]                             if (is.null(name)) 
[08:26:48.571]                               next
[08:26:48.571]                             if (!grepl(pattern, name)) 
[08:26:48.571]                               next
[08:26:48.571]                             invokeRestart(restart)
[08:26:48.571]                             muffled <- TRUE
[08:26:48.571]                             break
[08:26:48.571]                           }
[08:26:48.571]                         }
[08:26:48.571]                       }
[08:26:48.571]                       invisible(muffled)
[08:26:48.571]                     }
[08:26:48.571]                     muffleCondition(cond, pattern = "^muffle")
[08:26:48.571]                   }
[08:26:48.571]                 }
[08:26:48.571]                 else {
[08:26:48.571]                   if (TRUE) {
[08:26:48.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:48.571]                     {
[08:26:48.571]                       inherits <- base::inherits
[08:26:48.571]                       invokeRestart <- base::invokeRestart
[08:26:48.571]                       is.null <- base::is.null
[08:26:48.571]                       muffled <- FALSE
[08:26:48.571]                       if (inherits(cond, "message")) {
[08:26:48.571]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:48.571]                         if (muffled) 
[08:26:48.571]                           invokeRestart("muffleMessage")
[08:26:48.571]                       }
[08:26:48.571]                       else if (inherits(cond, "warning")) {
[08:26:48.571]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:48.571]                         if (muffled) 
[08:26:48.571]                           invokeRestart("muffleWarning")
[08:26:48.571]                       }
[08:26:48.571]                       else if (inherits(cond, "condition")) {
[08:26:48.571]                         if (!is.null(pattern)) {
[08:26:48.571]                           computeRestarts <- base::computeRestarts
[08:26:48.571]                           grepl <- base::grepl
[08:26:48.571]                           restarts <- computeRestarts(cond)
[08:26:48.571]                           for (restart in restarts) {
[08:26:48.571]                             name <- restart$name
[08:26:48.571]                             if (is.null(name)) 
[08:26:48.571]                               next
[08:26:48.571]                             if (!grepl(pattern, name)) 
[08:26:48.571]                               next
[08:26:48.571]                             invokeRestart(restart)
[08:26:48.571]                             muffled <- TRUE
[08:26:48.571]                             break
[08:26:48.571]                           }
[08:26:48.571]                         }
[08:26:48.571]                       }
[08:26:48.571]                       invisible(muffled)
[08:26:48.571]                     }
[08:26:48.571]                     muffleCondition(cond, pattern = "^muffle")
[08:26:48.571]                   }
[08:26:48.571]                 }
[08:26:48.571]             }
[08:26:48.571]         }))
[08:26:48.571]     }, error = function(ex) {
[08:26:48.571]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:48.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:48.571]                 ...future.rng), started = ...future.startTime, 
[08:26:48.571]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:48.571]             version = "1.8"), class = "FutureResult")
[08:26:48.571]     }, finally = {
[08:26:48.571]         if (!identical(...future.workdir, getwd())) 
[08:26:48.571]             setwd(...future.workdir)
[08:26:48.571]         {
[08:26:48.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:48.571]                 ...future.oldOptions$nwarnings <- NULL
[08:26:48.571]             }
[08:26:48.571]             base::options(...future.oldOptions)
[08:26:48.571]             if (.Platform$OS.type == "windows") {
[08:26:48.571]                 old_names <- names(...future.oldEnvVars)
[08:26:48.571]                 envs <- base::Sys.getenv()
[08:26:48.571]                 names <- names(envs)
[08:26:48.571]                 common <- intersect(names, old_names)
[08:26:48.571]                 added <- setdiff(names, old_names)
[08:26:48.571]                 removed <- setdiff(old_names, names)
[08:26:48.571]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:48.571]                   envs[common]]
[08:26:48.571]                 NAMES <- toupper(changed)
[08:26:48.571]                 args <- list()
[08:26:48.571]                 for (kk in seq_along(NAMES)) {
[08:26:48.571]                   name <- changed[[kk]]
[08:26:48.571]                   NAME <- NAMES[[kk]]
[08:26:48.571]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:48.571]                     next
[08:26:48.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:48.571]                 }
[08:26:48.571]                 NAMES <- toupper(added)
[08:26:48.571]                 for (kk in seq_along(NAMES)) {
[08:26:48.571]                   name <- added[[kk]]
[08:26:48.571]                   NAME <- NAMES[[kk]]
[08:26:48.571]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:48.571]                     next
[08:26:48.571]                   args[[name]] <- ""
[08:26:48.571]                 }
[08:26:48.571]                 NAMES <- toupper(removed)
[08:26:48.571]                 for (kk in seq_along(NAMES)) {
[08:26:48.571]                   name <- removed[[kk]]
[08:26:48.571]                   NAME <- NAMES[[kk]]
[08:26:48.571]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:48.571]                     next
[08:26:48.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:48.571]                 }
[08:26:48.571]                 if (length(args) > 0) 
[08:26:48.571]                   base::do.call(base::Sys.setenv, args = args)
[08:26:48.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:48.571]             }
[08:26:48.571]             else {
[08:26:48.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:48.571]             }
[08:26:48.571]             {
[08:26:48.571]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:48.571]                   0L) {
[08:26:48.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:48.571]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:48.571]                   base::options(opts)
[08:26:48.571]                 }
[08:26:48.571]                 {
[08:26:48.571]                   {
[08:26:48.571]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:48.571]                     NULL
[08:26:48.571]                   }
[08:26:48.571]                   options(future.plan = NULL)
[08:26:48.571]                   if (is.na(NA_character_)) 
[08:26:48.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:48.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:48.571]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:48.571]                     .init = FALSE)
[08:26:48.571]                 }
[08:26:48.571]             }
[08:26:48.571]         }
[08:26:48.571]     })
[08:26:48.571]     if (TRUE) {
[08:26:48.571]         base::sink(type = "output", split = FALSE)
[08:26:48.571]         if (FALSE) {
[08:26:48.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:48.571]         }
[08:26:48.571]         else {
[08:26:48.571]             ...future.result["stdout"] <- base::list(NULL)
[08:26:48.571]         }
[08:26:48.571]         base::close(...future.stdout)
[08:26:48.571]         ...future.stdout <- NULL
[08:26:48.571]     }
[08:26:48.571]     ...future.result$conditions <- ...future.conditions
[08:26:48.571]     ...future.result$finished <- base::Sys.time()
[08:26:48.571]     ...future.result
[08:26:48.571] }
[08:26:48.574] Exporting 5 global objects (1.63 KiB) to cluster node #1 ...
[08:26:48.574] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[08:26:48.575] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[08:26:48.575] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:26:48.575] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:26:48.575] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[08:26:48.576] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[08:26:48.576] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:48.576] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:48.576] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:48.577] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:48.577] Exporting 5 global objects (1.63 KiB) to cluster node #1 ... DONE
[08:26:48.577] MultisessionFuture started
[08:26:48.577] - Launch lazy future ... done
[08:26:48.577] run() for ‘MultisessionFuture’ ... done
[08:26:48.578] Created future:
[08:26:48.578] MultisessionFuture:
[08:26:48.578] Label: ‘future_mapply-1’
[08:26:48.578] Expression:
[08:26:48.578] {
[08:26:48.578]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:48.578]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:48.578]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:48.578]         on.exit(options(oopts), add = TRUE)
[08:26:48.578]     }
[08:26:48.578]     {
[08:26:48.578]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:48.578]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:48.578]         do.call(mapply, args = args)
[08:26:48.578]     }
[08:26:48.578] }
[08:26:48.578] Lazy evaluation: FALSE
[08:26:48.578] Asynchronous evaluation: TRUE
[08:26:48.578] Local evaluation: TRUE
[08:26:48.578] Environment: R_GlobalEnv
[08:26:48.578] Capture standard output: FALSE
[08:26:48.578] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:48.578] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:48.578] Packages: <none>
[08:26:48.578] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:48.578] Resolved: FALSE
[08:26:48.578] Value: <not collected>
[08:26:48.578] Conditions captured: <none>
[08:26:48.578] Early signaling: FALSE
[08:26:48.578] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:48.578] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:48.589] Chunk #1 of 2 ... DONE
[08:26:48.589] Chunk #2 of 2 ...
[08:26:48.590]  - Finding globals in '...' for chunk #2 ...
[08:26:48.590] getGlobalsAndPackages() ...
[08:26:48.590] Searching for globals...
[08:26:48.590] 
[08:26:48.590] Searching for globals ... DONE
[08:26:48.590] - globals: [0] <none>
[08:26:48.590] getGlobalsAndPackages() ... DONE
[08:26:48.590]    + additional globals found: [n=0] 
[08:26:48.591]    + additional namespaces needed: [n=0] 
[08:26:48.591]  - Finding globals in '...' for chunk #2 ... DONE
[08:26:48.591]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:48.591]  - seeds: <none>
[08:26:48.591]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:48.591] getGlobalsAndPackages() ...
[08:26:48.591] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:48.591] Resolving globals: FALSE
[08:26:48.592] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:48.592] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:48.592] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:48.592] 
[08:26:48.592] getGlobalsAndPackages() ... DONE
[08:26:48.593] run() for ‘Future’ ...
[08:26:48.593] - state: ‘created’
[08:26:48.593] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:48.608] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:48.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:48.608]   - Field: ‘node’
[08:26:48.608]   - Field: ‘label’
[08:26:48.608]   - Field: ‘local’
[08:26:48.608]   - Field: ‘owner’
[08:26:48.608]   - Field: ‘envir’
[08:26:48.608]   - Field: ‘workers’
[08:26:48.608]   - Field: ‘packages’
[08:26:48.609]   - Field: ‘gc’
[08:26:48.609]   - Field: ‘conditions’
[08:26:48.609]   - Field: ‘persistent’
[08:26:48.609]   - Field: ‘expr’
[08:26:48.609]   - Field: ‘uuid’
[08:26:48.609]   - Field: ‘seed’
[08:26:48.609]   - Field: ‘version’
[08:26:48.609]   - Field: ‘result’
[08:26:48.609]   - Field: ‘asynchronous’
[08:26:48.609]   - Field: ‘calls’
[08:26:48.609]   - Field: ‘globals’
[08:26:48.609]   - Field: ‘stdout’
[08:26:48.610]   - Field: ‘earlySignal’
[08:26:48.610]   - Field: ‘lazy’
[08:26:48.610]   - Field: ‘state’
[08:26:48.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:48.610] - Launch lazy future ...
[08:26:48.610] Packages needed by the future expression (n = 0): <none>
[08:26:48.610] Packages needed by future strategies (n = 0): <none>
[08:26:48.611] {
[08:26:48.611]     {
[08:26:48.611]         {
[08:26:48.611]             ...future.startTime <- base::Sys.time()
[08:26:48.611]             {
[08:26:48.611]                 {
[08:26:48.611]                   {
[08:26:48.611]                     {
[08:26:48.611]                       base::local({
[08:26:48.611]                         has_future <- base::requireNamespace("future", 
[08:26:48.611]                           quietly = TRUE)
[08:26:48.611]                         if (has_future) {
[08:26:48.611]                           ns <- base::getNamespace("future")
[08:26:48.611]                           version <- ns[[".package"]][["version"]]
[08:26:48.611]                           if (is.null(version)) 
[08:26:48.611]                             version <- utils::packageVersion("future")
[08:26:48.611]                         }
[08:26:48.611]                         else {
[08:26:48.611]                           version <- NULL
[08:26:48.611]                         }
[08:26:48.611]                         if (!has_future || version < "1.8.0") {
[08:26:48.611]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:48.611]                             "", base::R.version$version.string), 
[08:26:48.611]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:48.611]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:48.611]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:48.611]                               "release", "version")], collapse = " "), 
[08:26:48.611]                             hostname = base::Sys.info()[["nodename"]])
[08:26:48.611]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:48.611]                             info)
[08:26:48.611]                           info <- base::paste(info, collapse = "; ")
[08:26:48.611]                           if (!has_future) {
[08:26:48.611]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:48.611]                               info)
[08:26:48.611]                           }
[08:26:48.611]                           else {
[08:26:48.611]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:48.611]                               info, version)
[08:26:48.611]                           }
[08:26:48.611]                           base::stop(msg)
[08:26:48.611]                         }
[08:26:48.611]                       })
[08:26:48.611]                     }
[08:26:48.611]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:48.611]                     base::options(mc.cores = 1L)
[08:26:48.611]                   }
[08:26:48.611]                   ...future.strategy.old <- future::plan("list")
[08:26:48.611]                   options(future.plan = NULL)
[08:26:48.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:48.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:48.611]                 }
[08:26:48.611]                 ...future.workdir <- getwd()
[08:26:48.611]             }
[08:26:48.611]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:48.611]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:48.611]         }
[08:26:48.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:48.611]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:48.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:48.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:48.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:48.611]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:48.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:48.611]             base::names(...future.oldOptions))
[08:26:48.611]     }
[08:26:48.611]     if (FALSE) {
[08:26:48.611]     }
[08:26:48.611]     else {
[08:26:48.611]         if (FALSE) {
[08:26:48.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:48.611]                 open = "w")
[08:26:48.611]         }
[08:26:48.611]         else {
[08:26:48.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:48.611]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:48.611]         }
[08:26:48.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:48.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:48.611]             base::sink(type = "output", split = FALSE)
[08:26:48.611]             base::close(...future.stdout)
[08:26:48.611]         }, add = TRUE)
[08:26:48.611]     }
[08:26:48.611]     ...future.frame <- base::sys.nframe()
[08:26:48.611]     ...future.conditions <- base::list()
[08:26:48.611]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:48.611]     if (FALSE) {
[08:26:48.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:48.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:48.611]     }
[08:26:48.611]     ...future.result <- base::tryCatch({
[08:26:48.611]         base::withCallingHandlers({
[08:26:48.611]             ...future.value <- base::withVisible(base::local({
[08:26:48.611]                 ...future.makeSendCondition <- base::local({
[08:26:48.611]                   sendCondition <- NULL
[08:26:48.611]                   function(frame = 1L) {
[08:26:48.611]                     if (is.function(sendCondition)) 
[08:26:48.611]                       return(sendCondition)
[08:26:48.611]                     ns <- getNamespace("parallel")
[08:26:48.611]                     if (exists("sendData", mode = "function", 
[08:26:48.611]                       envir = ns)) {
[08:26:48.611]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:48.611]                         envir = ns)
[08:26:48.611]                       envir <- sys.frame(frame)
[08:26:48.611]                       master <- NULL
[08:26:48.611]                       while (!identical(envir, .GlobalEnv) && 
[08:26:48.611]                         !identical(envir, emptyenv())) {
[08:26:48.611]                         if (exists("master", mode = "list", envir = envir, 
[08:26:48.611]                           inherits = FALSE)) {
[08:26:48.611]                           master <- get("master", mode = "list", 
[08:26:48.611]                             envir = envir, inherits = FALSE)
[08:26:48.611]                           if (inherits(master, c("SOCKnode", 
[08:26:48.611]                             "SOCK0node"))) {
[08:26:48.611]                             sendCondition <<- function(cond) {
[08:26:48.611]                               data <- list(type = "VALUE", value = cond, 
[08:26:48.611]                                 success = TRUE)
[08:26:48.611]                               parallel_sendData(master, data)
[08:26:48.611]                             }
[08:26:48.611]                             return(sendCondition)
[08:26:48.611]                           }
[08:26:48.611]                         }
[08:26:48.611]                         frame <- frame + 1L
[08:26:48.611]                         envir <- sys.frame(frame)
[08:26:48.611]                       }
[08:26:48.611]                     }
[08:26:48.611]                     sendCondition <<- function(cond) NULL
[08:26:48.611]                   }
[08:26:48.611]                 })
[08:26:48.611]                 withCallingHandlers({
[08:26:48.611]                   {
[08:26:48.611]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:48.611]                     if (!identical(...future.globals.maxSize.org, 
[08:26:48.611]                       ...future.globals.maxSize)) {
[08:26:48.611]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:48.611]                       on.exit(options(oopts), add = TRUE)
[08:26:48.611]                     }
[08:26:48.611]                     {
[08:26:48.611]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:48.611]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:48.611]                         USE.NAMES = FALSE)
[08:26:48.611]                       do.call(mapply, args = args)
[08:26:48.611]                     }
[08:26:48.611]                   }
[08:26:48.611]                 }, immediateCondition = function(cond) {
[08:26:48.611]                   sendCondition <- ...future.makeSendCondition()
[08:26:48.611]                   sendCondition(cond)
[08:26:48.611]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:48.611]                   {
[08:26:48.611]                     inherits <- base::inherits
[08:26:48.611]                     invokeRestart <- base::invokeRestart
[08:26:48.611]                     is.null <- base::is.null
[08:26:48.611]                     muffled <- FALSE
[08:26:48.611]                     if (inherits(cond, "message")) {
[08:26:48.611]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:48.611]                       if (muffled) 
[08:26:48.611]                         invokeRestart("muffleMessage")
[08:26:48.611]                     }
[08:26:48.611]                     else if (inherits(cond, "warning")) {
[08:26:48.611]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:48.611]                       if (muffled) 
[08:26:48.611]                         invokeRestart("muffleWarning")
[08:26:48.611]                     }
[08:26:48.611]                     else if (inherits(cond, "condition")) {
[08:26:48.611]                       if (!is.null(pattern)) {
[08:26:48.611]                         computeRestarts <- base::computeRestarts
[08:26:48.611]                         grepl <- base::grepl
[08:26:48.611]                         restarts <- computeRestarts(cond)
[08:26:48.611]                         for (restart in restarts) {
[08:26:48.611]                           name <- restart$name
[08:26:48.611]                           if (is.null(name)) 
[08:26:48.611]                             next
[08:26:48.611]                           if (!grepl(pattern, name)) 
[08:26:48.611]                             next
[08:26:48.611]                           invokeRestart(restart)
[08:26:48.611]                           muffled <- TRUE
[08:26:48.611]                           break
[08:26:48.611]                         }
[08:26:48.611]                       }
[08:26:48.611]                     }
[08:26:48.611]                     invisible(muffled)
[08:26:48.611]                   }
[08:26:48.611]                   muffleCondition(cond)
[08:26:48.611]                 })
[08:26:48.611]             }))
[08:26:48.611]             future::FutureResult(value = ...future.value$value, 
[08:26:48.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:48.611]                   ...future.rng), globalenv = if (FALSE) 
[08:26:48.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:48.611]                     ...future.globalenv.names))
[08:26:48.611]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:48.611]         }, condition = base::local({
[08:26:48.611]             c <- base::c
[08:26:48.611]             inherits <- base::inherits
[08:26:48.611]             invokeRestart <- base::invokeRestart
[08:26:48.611]             length <- base::length
[08:26:48.611]             list <- base::list
[08:26:48.611]             seq.int <- base::seq.int
[08:26:48.611]             signalCondition <- base::signalCondition
[08:26:48.611]             sys.calls <- base::sys.calls
[08:26:48.611]             `[[` <- base::`[[`
[08:26:48.611]             `+` <- base::`+`
[08:26:48.611]             `<<-` <- base::`<<-`
[08:26:48.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:48.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:48.611]                   3L)]
[08:26:48.611]             }
[08:26:48.611]             function(cond) {
[08:26:48.611]                 is_error <- inherits(cond, "error")
[08:26:48.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:48.611]                   NULL)
[08:26:48.611]                 if (is_error) {
[08:26:48.611]                   sessionInformation <- function() {
[08:26:48.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:48.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:48.611]                       search = base::search(), system = base::Sys.info())
[08:26:48.611]                   }
[08:26:48.611]                   ...future.conditions[[length(...future.conditions) + 
[08:26:48.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:48.611]                     cond$call), session = sessionInformation(), 
[08:26:48.611]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:48.611]                   signalCondition(cond)
[08:26:48.611]                 }
[08:26:48.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:48.611]                 "immediateCondition"))) {
[08:26:48.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:48.611]                   ...future.conditions[[length(...future.conditions) + 
[08:26:48.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:48.611]                   if (TRUE && !signal) {
[08:26:48.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:48.611]                     {
[08:26:48.611]                       inherits <- base::inherits
[08:26:48.611]                       invokeRestart <- base::invokeRestart
[08:26:48.611]                       is.null <- base::is.null
[08:26:48.611]                       muffled <- FALSE
[08:26:48.611]                       if (inherits(cond, "message")) {
[08:26:48.611]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:48.611]                         if (muffled) 
[08:26:48.611]                           invokeRestart("muffleMessage")
[08:26:48.611]                       }
[08:26:48.611]                       else if (inherits(cond, "warning")) {
[08:26:48.611]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:48.611]                         if (muffled) 
[08:26:48.611]                           invokeRestart("muffleWarning")
[08:26:48.611]                       }
[08:26:48.611]                       else if (inherits(cond, "condition")) {
[08:26:48.611]                         if (!is.null(pattern)) {
[08:26:48.611]                           computeRestarts <- base::computeRestarts
[08:26:48.611]                           grepl <- base::grepl
[08:26:48.611]                           restarts <- computeRestarts(cond)
[08:26:48.611]                           for (restart in restarts) {
[08:26:48.611]                             name <- restart$name
[08:26:48.611]                             if (is.null(name)) 
[08:26:48.611]                               next
[08:26:48.611]                             if (!grepl(pattern, name)) 
[08:26:48.611]                               next
[08:26:48.611]                             invokeRestart(restart)
[08:26:48.611]                             muffled <- TRUE
[08:26:48.611]                             break
[08:26:48.611]                           }
[08:26:48.611]                         }
[08:26:48.611]                       }
[08:26:48.611]                       invisible(muffled)
[08:26:48.611]                     }
[08:26:48.611]                     muffleCondition(cond, pattern = "^muffle")
[08:26:48.611]                   }
[08:26:48.611]                 }
[08:26:48.611]                 else {
[08:26:48.611]                   if (TRUE) {
[08:26:48.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:48.611]                     {
[08:26:48.611]                       inherits <- base::inherits
[08:26:48.611]                       invokeRestart <- base::invokeRestart
[08:26:48.611]                       is.null <- base::is.null
[08:26:48.611]                       muffled <- FALSE
[08:26:48.611]                       if (inherits(cond, "message")) {
[08:26:48.611]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:48.611]                         if (muffled) 
[08:26:48.611]                           invokeRestart("muffleMessage")
[08:26:48.611]                       }
[08:26:48.611]                       else if (inherits(cond, "warning")) {
[08:26:48.611]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:48.611]                         if (muffled) 
[08:26:48.611]                           invokeRestart("muffleWarning")
[08:26:48.611]                       }
[08:26:48.611]                       else if (inherits(cond, "condition")) {
[08:26:48.611]                         if (!is.null(pattern)) {
[08:26:48.611]                           computeRestarts <- base::computeRestarts
[08:26:48.611]                           grepl <- base::grepl
[08:26:48.611]                           restarts <- computeRestarts(cond)
[08:26:48.611]                           for (restart in restarts) {
[08:26:48.611]                             name <- restart$name
[08:26:48.611]                             if (is.null(name)) 
[08:26:48.611]                               next
[08:26:48.611]                             if (!grepl(pattern, name)) 
[08:26:48.611]                               next
[08:26:48.611]                             invokeRestart(restart)
[08:26:48.611]                             muffled <- TRUE
[08:26:48.611]                             break
[08:26:48.611]                           }
[08:26:48.611]                         }
[08:26:48.611]                       }
[08:26:48.611]                       invisible(muffled)
[08:26:48.611]                     }
[08:26:48.611]                     muffleCondition(cond, pattern = "^muffle")
[08:26:48.611]                   }
[08:26:48.611]                 }
[08:26:48.611]             }
[08:26:48.611]         }))
[08:26:48.611]     }, error = function(ex) {
[08:26:48.611]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:48.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:48.611]                 ...future.rng), started = ...future.startTime, 
[08:26:48.611]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:48.611]             version = "1.8"), class = "FutureResult")
[08:26:48.611]     }, finally = {
[08:26:48.611]         if (!identical(...future.workdir, getwd())) 
[08:26:48.611]             setwd(...future.workdir)
[08:26:48.611]         {
[08:26:48.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:48.611]                 ...future.oldOptions$nwarnings <- NULL
[08:26:48.611]             }
[08:26:48.611]             base::options(...future.oldOptions)
[08:26:48.611]             if (.Platform$OS.type == "windows") {
[08:26:48.611]                 old_names <- names(...future.oldEnvVars)
[08:26:48.611]                 envs <- base::Sys.getenv()
[08:26:48.611]                 names <- names(envs)
[08:26:48.611]                 common <- intersect(names, old_names)
[08:26:48.611]                 added <- setdiff(names, old_names)
[08:26:48.611]                 removed <- setdiff(old_names, names)
[08:26:48.611]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:48.611]                   envs[common]]
[08:26:48.611]                 NAMES <- toupper(changed)
[08:26:48.611]                 args <- list()
[08:26:48.611]                 for (kk in seq_along(NAMES)) {
[08:26:48.611]                   name <- changed[[kk]]
[08:26:48.611]                   NAME <- NAMES[[kk]]
[08:26:48.611]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:48.611]                     next
[08:26:48.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:48.611]                 }
[08:26:48.611]                 NAMES <- toupper(added)
[08:26:48.611]                 for (kk in seq_along(NAMES)) {
[08:26:48.611]                   name <- added[[kk]]
[08:26:48.611]                   NAME <- NAMES[[kk]]
[08:26:48.611]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:48.611]                     next
[08:26:48.611]                   args[[name]] <- ""
[08:26:48.611]                 }
[08:26:48.611]                 NAMES <- toupper(removed)
[08:26:48.611]                 for (kk in seq_along(NAMES)) {
[08:26:48.611]                   name <- removed[[kk]]
[08:26:48.611]                   NAME <- NAMES[[kk]]
[08:26:48.611]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:48.611]                     next
[08:26:48.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:48.611]                 }
[08:26:48.611]                 if (length(args) > 0) 
[08:26:48.611]                   base::do.call(base::Sys.setenv, args = args)
[08:26:48.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:48.611]             }
[08:26:48.611]             else {
[08:26:48.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:48.611]             }
[08:26:48.611]             {
[08:26:48.611]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:48.611]                   0L) {
[08:26:48.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:48.611]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:48.611]                   base::options(opts)
[08:26:48.611]                 }
[08:26:48.611]                 {
[08:26:48.611]                   {
[08:26:48.611]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:48.611]                     NULL
[08:26:48.611]                   }
[08:26:48.611]                   options(future.plan = NULL)
[08:26:48.611]                   if (is.na(NA_character_)) 
[08:26:48.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:48.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:48.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:48.611]                     .init = FALSE)
[08:26:48.611]                 }
[08:26:48.611]             }
[08:26:48.611]         }
[08:26:48.611]     })
[08:26:48.611]     if (TRUE) {
[08:26:48.611]         base::sink(type = "output", split = FALSE)
[08:26:48.611]         if (FALSE) {
[08:26:48.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:48.611]         }
[08:26:48.611]         else {
[08:26:48.611]             ...future.result["stdout"] <- base::list(NULL)
[08:26:48.611]         }
[08:26:48.611]         base::close(...future.stdout)
[08:26:48.611]         ...future.stdout <- NULL
[08:26:48.611]     }
[08:26:48.611]     ...future.result$conditions <- ...future.conditions
[08:26:48.611]     ...future.result$finished <- base::Sys.time()
[08:26:48.611]     ...future.result
[08:26:48.611] }
[08:26:48.614] Exporting 5 global objects (1.63 KiB) to cluster node #2 ...
[08:26:48.614] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[08:26:48.615] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[08:26:48.615] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:26:48.615] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:26:48.615] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[08:26:48.616] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[08:26:48.616] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:48.616] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:48.616] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:48.617] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:48.617] Exporting 5 global objects (1.63 KiB) to cluster node #2 ... DONE
[08:26:48.617] MultisessionFuture started
[08:26:48.618] - Launch lazy future ... done
[08:26:48.618] run() for ‘MultisessionFuture’ ... done
[08:26:48.618] Created future:
[08:26:48.618] MultisessionFuture:
[08:26:48.618] Label: ‘future_mapply-2’
[08:26:48.618] Expression:
[08:26:48.618] {
[08:26:48.618]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:48.618]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:48.618]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:48.618]         on.exit(options(oopts), add = TRUE)
[08:26:48.618]     }
[08:26:48.618]     {
[08:26:48.618]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:48.618]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:48.618]         do.call(mapply, args = args)
[08:26:48.618]     }
[08:26:48.618] }
[08:26:48.618] Lazy evaluation: FALSE
[08:26:48.618] Asynchronous evaluation: TRUE
[08:26:48.618] Local evaluation: TRUE
[08:26:48.618] Environment: R_GlobalEnv
[08:26:48.618] Capture standard output: FALSE
[08:26:48.618] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:48.618] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:48.618] Packages: <none>
[08:26:48.618] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:48.618] Resolved: FALSE
[08:26:48.618] Value: <not collected>
[08:26:48.618] Conditions captured: <none>
[08:26:48.618] Early signaling: FALSE
[08:26:48.618] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:48.618] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:48.630] Chunk #2 of 2 ... DONE
[08:26:48.630] Launching 2 futures (chunks) ... DONE
[08:26:48.630] Resolving 2 futures (chunks) ...
[08:26:48.630] resolve() on list ...
[08:26:48.630]  recursive: 0
[08:26:48.630]  length: 2
[08:26:48.630] 
[08:26:48.673] receiveMessageFromWorker() for ClusterFuture ...
[08:26:48.673] - Validating connection of MultisessionFuture
[08:26:48.673] - received message: FutureResult
[08:26:48.673] - Received FutureResult
[08:26:48.674] - Erased future from FutureRegistry
[08:26:48.674] result() for ClusterFuture ...
[08:26:48.674] - result already collected: FutureResult
[08:26:48.674] result() for ClusterFuture ... done
[08:26:48.674] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:48.674] Future #2
[08:26:48.674] result() for ClusterFuture ...
[08:26:48.674] - result already collected: FutureResult
[08:26:48.674] result() for ClusterFuture ... done
[08:26:48.674] result() for ClusterFuture ...
[08:26:48.674] - result already collected: FutureResult
[08:26:48.675] result() for ClusterFuture ... done
[08:26:48.675] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:48.675] - nx: 2
[08:26:48.675] - relay: TRUE
[08:26:48.675] - stdout: TRUE
[08:26:48.675] - signal: TRUE
[08:26:48.675] - resignal: FALSE
[08:26:48.675] - force: TRUE
[08:26:48.675] - relayed: [n=2] FALSE, FALSE
[08:26:48.675] - queued futures: [n=2] FALSE, FALSE
[08:26:48.675]  - until=1
[08:26:48.676]  - relaying element #1
[08:26:48.676] - relayed: [n=2] FALSE, FALSE
[08:26:48.676] - queued futures: [n=2] FALSE, TRUE
[08:26:48.676] signalConditionsASAP(NULL, pos=2) ... done
[08:26:48.676]  length: 1 (resolved future 2)
[08:26:49.128] receiveMessageFromWorker() for ClusterFuture ...
[08:26:49.129] - Validating connection of MultisessionFuture
[08:26:49.129] - received message: FutureResult
[08:26:49.129] - Received FutureResult
[08:26:49.129] - Erased future from FutureRegistry
[08:26:49.129] result() for ClusterFuture ...
[08:26:49.129] - result already collected: FutureResult
[08:26:49.129] result() for ClusterFuture ... done
[08:26:49.129] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:49.129] Future #1
[08:26:49.130] result() for ClusterFuture ...
[08:26:49.130] - result already collected: FutureResult
[08:26:49.130] result() for ClusterFuture ... done
[08:26:49.130] result() for ClusterFuture ...
[08:26:49.130] - result already collected: FutureResult
[08:26:49.130] result() for ClusterFuture ... done
[08:26:49.130] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:49.130] - nx: 2
[08:26:49.130] - relay: TRUE
[08:26:49.130] - stdout: TRUE
[08:26:49.130] - signal: TRUE
[08:26:49.130] - resignal: FALSE
[08:26:49.131] - force: TRUE
[08:26:49.131] - relayed: [n=2] FALSE, FALSE
[08:26:49.131] - queued futures: [n=2] FALSE, TRUE
[08:26:49.131]  - until=1
[08:26:49.131]  - relaying element #1
[08:26:49.131] result() for ClusterFuture ...
[08:26:49.131] - result already collected: FutureResult
[08:26:49.131] result() for ClusterFuture ... done
[08:26:49.131] result() for ClusterFuture ...
[08:26:49.131] - result already collected: FutureResult
[08:26:49.131] result() for ClusterFuture ... done
[08:26:49.131] result() for ClusterFuture ...
[08:26:49.132] - result already collected: FutureResult
[08:26:49.132] result() for ClusterFuture ... done
[08:26:49.132] result() for ClusterFuture ...
[08:26:49.132] - result already collected: FutureResult
[08:26:49.132] result() for ClusterFuture ... done
[08:26:49.132] - relayed: [n=2] TRUE, FALSE
[08:26:49.132] - queued futures: [n=2] TRUE, TRUE
[08:26:49.132] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:49.132]  length: 0 (resolved future 1)
[08:26:49.132] Relaying remaining futures
[08:26:49.132] signalConditionsASAP(NULL, pos=0) ...
[08:26:49.132] - nx: 2
[08:26:49.133] - relay: TRUE
[08:26:49.133] - stdout: TRUE
[08:26:49.133] - signal: TRUE
[08:26:49.133] - resignal: FALSE
[08:26:49.133] - force: TRUE
[08:26:49.133] - relayed: [n=2] TRUE, FALSE
[08:26:49.133] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:49.133]  - relaying element #2
[08:26:49.133] result() for ClusterFuture ...
[08:26:49.133] - result already collected: FutureResult
[08:26:49.133] result() for ClusterFuture ... done
[08:26:49.133] result() for ClusterFuture ...
[08:26:49.134] - result already collected: FutureResult
[08:26:49.134] result() for ClusterFuture ... done
[08:26:49.134] result() for ClusterFuture ...
[08:26:49.134] - result already collected: FutureResult
[08:26:49.134] result() for ClusterFuture ... done
[08:26:49.134] result() for ClusterFuture ...
[08:26:49.134] - result already collected: FutureResult
[08:26:49.134] result() for ClusterFuture ... done
[08:26:49.134] - relayed: [n=2] TRUE, TRUE
[08:26:49.134] - queued futures: [n=2] TRUE, TRUE
[08:26:49.134] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[08:26:49.134] resolve() on list ... DONE
[08:26:49.135] result() for ClusterFuture ...
[08:26:49.135] - result already collected: FutureResult
[08:26:49.135] result() for ClusterFuture ... done
[08:26:49.135] result() for ClusterFuture ...
[08:26:49.135] - result already collected: FutureResult
[08:26:49.135] result() for ClusterFuture ... done
[08:26:49.135] result() for ClusterFuture ...
[08:26:49.135] - result already collected: FutureResult
[08:26:49.135] result() for ClusterFuture ... done
[08:26:49.135] result() for ClusterFuture ...
[08:26:49.135] - result already collected: FutureResult
[08:26:49.135] result() for ClusterFuture ... done
[08:26:49.135]  - Number of value chunks collected: 2
[08:26:49.136] Resolving 2 futures (chunks) ... DONE
[08:26:49.136] Reducing values from 2 chunks ...
[08:26:49.136]  - Number of values collected after concatenation: 2
[08:26:49.136]  - Number of values expected: 2
[08:26:49.136] Reducing values from 2 chunks ... DONE
[08:26:49.136] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[08:26:49.136] future_mapply() ...
[08:26:49.138] Number of chunks: 2
[08:26:49.138] getGlobalsAndPackagesXApply() ...
[08:26:49.138]  - future.globals: TRUE
[08:26:49.139] getGlobalsAndPackages() ...
[08:26:49.139] Searching for globals...
[08:26:49.140] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:49.140] Searching for globals ... DONE
[08:26:49.141] Resolving globals: FALSE
[08:26:49.141] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:49.141] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:49.141] - globals: [1] ‘FUN’
[08:26:49.142] 
[08:26:49.142] getGlobalsAndPackages() ... DONE
[08:26:49.142]  - globals found/used: [n=1] ‘FUN’
[08:26:49.142]  - needed namespaces: [n=0] 
[08:26:49.142] Finding globals ... DONE
[08:26:49.142] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:49.142] List of 2
[08:26:49.142]  $ ...future.FUN:function (x, y)  
[08:26:49.142]  $ MoreArgs     : NULL
[08:26:49.142]  - attr(*, "where")=List of 2
[08:26:49.142]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:49.142]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:49.142]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:49.142]  - attr(*, "resolved")= logi FALSE
[08:26:49.142]  - attr(*, "total_size")= num NA
[08:26:49.145] Packages to be attached in all futures: [n=0] 
[08:26:49.145] getGlobalsAndPackagesXApply() ... DONE
[08:26:49.145] Number of futures (= number of chunks): 2
[08:26:49.145] Launching 2 futures (chunks) ...
[08:26:49.145] Chunk #1 of 2 ...
[08:26:49.145]  - Finding globals in '...' for chunk #1 ...
[08:26:49.145] getGlobalsAndPackages() ...
[08:26:49.146] Searching for globals...
[08:26:49.146] 
[08:26:49.146] Searching for globals ... DONE
[08:26:49.146] - globals: [0] <none>
[08:26:49.146] getGlobalsAndPackages() ... DONE
[08:26:49.146]    + additional globals found: [n=0] 
[08:26:49.146]    + additional namespaces needed: [n=0] 
[08:26:49.146]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:49.147]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:49.147]  - seeds: <none>
[08:26:49.147]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.147] getGlobalsAndPackages() ...
[08:26:49.147] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.147] Resolving globals: FALSE
[08:26:49.147] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:49.148] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:49.148] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.148] 
[08:26:49.148] getGlobalsAndPackages() ... DONE
[08:26:49.149] run() for ‘Future’ ...
[08:26:49.149] - state: ‘created’
[08:26:49.149] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:49.165] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:49.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:49.165]   - Field: ‘node’
[08:26:49.165]   - Field: ‘label’
[08:26:49.165]   - Field: ‘local’
[08:26:49.165]   - Field: ‘owner’
[08:26:49.165]   - Field: ‘envir’
[08:26:49.166]   - Field: ‘workers’
[08:26:49.166]   - Field: ‘packages’
[08:26:49.166]   - Field: ‘gc’
[08:26:49.166]   - Field: ‘conditions’
[08:26:49.166]   - Field: ‘persistent’
[08:26:49.166]   - Field: ‘expr’
[08:26:49.166]   - Field: ‘uuid’
[08:26:49.166]   - Field: ‘seed’
[08:26:49.166]   - Field: ‘version’
[08:26:49.166]   - Field: ‘result’
[08:26:49.166]   - Field: ‘asynchronous’
[08:26:49.167]   - Field: ‘calls’
[08:26:49.167]   - Field: ‘globals’
[08:26:49.167]   - Field: ‘stdout’
[08:26:49.167]   - Field: ‘earlySignal’
[08:26:49.167]   - Field: ‘lazy’
[08:26:49.167]   - Field: ‘state’
[08:26:49.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:49.167] - Launch lazy future ...
[08:26:49.167] Packages needed by the future expression (n = 0): <none>
[08:26:49.168] Packages needed by future strategies (n = 0): <none>
[08:26:49.168] {
[08:26:49.168]     {
[08:26:49.168]         {
[08:26:49.168]             ...future.startTime <- base::Sys.time()
[08:26:49.168]             {
[08:26:49.168]                 {
[08:26:49.168]                   {
[08:26:49.168]                     {
[08:26:49.168]                       base::local({
[08:26:49.168]                         has_future <- base::requireNamespace("future", 
[08:26:49.168]                           quietly = TRUE)
[08:26:49.168]                         if (has_future) {
[08:26:49.168]                           ns <- base::getNamespace("future")
[08:26:49.168]                           version <- ns[[".package"]][["version"]]
[08:26:49.168]                           if (is.null(version)) 
[08:26:49.168]                             version <- utils::packageVersion("future")
[08:26:49.168]                         }
[08:26:49.168]                         else {
[08:26:49.168]                           version <- NULL
[08:26:49.168]                         }
[08:26:49.168]                         if (!has_future || version < "1.8.0") {
[08:26:49.168]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:49.168]                             "", base::R.version$version.string), 
[08:26:49.168]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:49.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:49.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:49.168]                               "release", "version")], collapse = " "), 
[08:26:49.168]                             hostname = base::Sys.info()[["nodename"]])
[08:26:49.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:49.168]                             info)
[08:26:49.168]                           info <- base::paste(info, collapse = "; ")
[08:26:49.168]                           if (!has_future) {
[08:26:49.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:49.168]                               info)
[08:26:49.168]                           }
[08:26:49.168]                           else {
[08:26:49.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:49.168]                               info, version)
[08:26:49.168]                           }
[08:26:49.168]                           base::stop(msg)
[08:26:49.168]                         }
[08:26:49.168]                       })
[08:26:49.168]                     }
[08:26:49.168]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:49.168]                     base::options(mc.cores = 1L)
[08:26:49.168]                   }
[08:26:49.168]                   ...future.strategy.old <- future::plan("list")
[08:26:49.168]                   options(future.plan = NULL)
[08:26:49.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:49.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:49.168]                 }
[08:26:49.168]                 ...future.workdir <- getwd()
[08:26:49.168]             }
[08:26:49.168]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:49.168]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:49.168]         }
[08:26:49.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:49.168]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:49.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:49.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:49.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:49.168]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:49.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:49.168]             base::names(...future.oldOptions))
[08:26:49.168]     }
[08:26:49.168]     if (FALSE) {
[08:26:49.168]     }
[08:26:49.168]     else {
[08:26:49.168]         if (TRUE) {
[08:26:49.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:49.168]                 open = "w")
[08:26:49.168]         }
[08:26:49.168]         else {
[08:26:49.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:49.168]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:49.168]         }
[08:26:49.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:49.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:49.168]             base::sink(type = "output", split = FALSE)
[08:26:49.168]             base::close(...future.stdout)
[08:26:49.168]         }, add = TRUE)
[08:26:49.168]     }
[08:26:49.168]     ...future.frame <- base::sys.nframe()
[08:26:49.168]     ...future.conditions <- base::list()
[08:26:49.168]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:49.168]     if (FALSE) {
[08:26:49.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:49.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:49.168]     }
[08:26:49.168]     ...future.result <- base::tryCatch({
[08:26:49.168]         base::withCallingHandlers({
[08:26:49.168]             ...future.value <- base::withVisible(base::local({
[08:26:49.168]                 ...future.makeSendCondition <- base::local({
[08:26:49.168]                   sendCondition <- NULL
[08:26:49.168]                   function(frame = 1L) {
[08:26:49.168]                     if (is.function(sendCondition)) 
[08:26:49.168]                       return(sendCondition)
[08:26:49.168]                     ns <- getNamespace("parallel")
[08:26:49.168]                     if (exists("sendData", mode = "function", 
[08:26:49.168]                       envir = ns)) {
[08:26:49.168]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:49.168]                         envir = ns)
[08:26:49.168]                       envir <- sys.frame(frame)
[08:26:49.168]                       master <- NULL
[08:26:49.168]                       while (!identical(envir, .GlobalEnv) && 
[08:26:49.168]                         !identical(envir, emptyenv())) {
[08:26:49.168]                         if (exists("master", mode = "list", envir = envir, 
[08:26:49.168]                           inherits = FALSE)) {
[08:26:49.168]                           master <- get("master", mode = "list", 
[08:26:49.168]                             envir = envir, inherits = FALSE)
[08:26:49.168]                           if (inherits(master, c("SOCKnode", 
[08:26:49.168]                             "SOCK0node"))) {
[08:26:49.168]                             sendCondition <<- function(cond) {
[08:26:49.168]                               data <- list(type = "VALUE", value = cond, 
[08:26:49.168]                                 success = TRUE)
[08:26:49.168]                               parallel_sendData(master, data)
[08:26:49.168]                             }
[08:26:49.168]                             return(sendCondition)
[08:26:49.168]                           }
[08:26:49.168]                         }
[08:26:49.168]                         frame <- frame + 1L
[08:26:49.168]                         envir <- sys.frame(frame)
[08:26:49.168]                       }
[08:26:49.168]                     }
[08:26:49.168]                     sendCondition <<- function(cond) NULL
[08:26:49.168]                   }
[08:26:49.168]                 })
[08:26:49.168]                 withCallingHandlers({
[08:26:49.168]                   {
[08:26:49.168]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:49.168]                     if (!identical(...future.globals.maxSize.org, 
[08:26:49.168]                       ...future.globals.maxSize)) {
[08:26:49.168]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:49.168]                       on.exit(options(oopts), add = TRUE)
[08:26:49.168]                     }
[08:26:49.168]                     {
[08:26:49.168]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:49.168]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:49.168]                         USE.NAMES = FALSE)
[08:26:49.168]                       do.call(mapply, args = args)
[08:26:49.168]                     }
[08:26:49.168]                   }
[08:26:49.168]                 }, immediateCondition = function(cond) {
[08:26:49.168]                   sendCondition <- ...future.makeSendCondition()
[08:26:49.168]                   sendCondition(cond)
[08:26:49.168]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.168]                   {
[08:26:49.168]                     inherits <- base::inherits
[08:26:49.168]                     invokeRestart <- base::invokeRestart
[08:26:49.168]                     is.null <- base::is.null
[08:26:49.168]                     muffled <- FALSE
[08:26:49.168]                     if (inherits(cond, "message")) {
[08:26:49.168]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:49.168]                       if (muffled) 
[08:26:49.168]                         invokeRestart("muffleMessage")
[08:26:49.168]                     }
[08:26:49.168]                     else if (inherits(cond, "warning")) {
[08:26:49.168]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:49.168]                       if (muffled) 
[08:26:49.168]                         invokeRestart("muffleWarning")
[08:26:49.168]                     }
[08:26:49.168]                     else if (inherits(cond, "condition")) {
[08:26:49.168]                       if (!is.null(pattern)) {
[08:26:49.168]                         computeRestarts <- base::computeRestarts
[08:26:49.168]                         grepl <- base::grepl
[08:26:49.168]                         restarts <- computeRestarts(cond)
[08:26:49.168]                         for (restart in restarts) {
[08:26:49.168]                           name <- restart$name
[08:26:49.168]                           if (is.null(name)) 
[08:26:49.168]                             next
[08:26:49.168]                           if (!grepl(pattern, name)) 
[08:26:49.168]                             next
[08:26:49.168]                           invokeRestart(restart)
[08:26:49.168]                           muffled <- TRUE
[08:26:49.168]                           break
[08:26:49.168]                         }
[08:26:49.168]                       }
[08:26:49.168]                     }
[08:26:49.168]                     invisible(muffled)
[08:26:49.168]                   }
[08:26:49.168]                   muffleCondition(cond)
[08:26:49.168]                 })
[08:26:49.168]             }))
[08:26:49.168]             future::FutureResult(value = ...future.value$value, 
[08:26:49.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:49.168]                   ...future.rng), globalenv = if (FALSE) 
[08:26:49.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:49.168]                     ...future.globalenv.names))
[08:26:49.168]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:49.168]         }, condition = base::local({
[08:26:49.168]             c <- base::c
[08:26:49.168]             inherits <- base::inherits
[08:26:49.168]             invokeRestart <- base::invokeRestart
[08:26:49.168]             length <- base::length
[08:26:49.168]             list <- base::list
[08:26:49.168]             seq.int <- base::seq.int
[08:26:49.168]             signalCondition <- base::signalCondition
[08:26:49.168]             sys.calls <- base::sys.calls
[08:26:49.168]             `[[` <- base::`[[`
[08:26:49.168]             `+` <- base::`+`
[08:26:49.168]             `<<-` <- base::`<<-`
[08:26:49.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:49.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:49.168]                   3L)]
[08:26:49.168]             }
[08:26:49.168]             function(cond) {
[08:26:49.168]                 is_error <- inherits(cond, "error")
[08:26:49.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:49.168]                   NULL)
[08:26:49.168]                 if (is_error) {
[08:26:49.168]                   sessionInformation <- function() {
[08:26:49.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:49.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:49.168]                       search = base::search(), system = base::Sys.info())
[08:26:49.168]                   }
[08:26:49.168]                   ...future.conditions[[length(...future.conditions) + 
[08:26:49.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:49.168]                     cond$call), session = sessionInformation(), 
[08:26:49.168]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:49.168]                   signalCondition(cond)
[08:26:49.168]                 }
[08:26:49.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:49.168]                 "immediateCondition"))) {
[08:26:49.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:49.168]                   ...future.conditions[[length(...future.conditions) + 
[08:26:49.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:49.168]                   if (TRUE && !signal) {
[08:26:49.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.168]                     {
[08:26:49.168]                       inherits <- base::inherits
[08:26:49.168]                       invokeRestart <- base::invokeRestart
[08:26:49.168]                       is.null <- base::is.null
[08:26:49.168]                       muffled <- FALSE
[08:26:49.168]                       if (inherits(cond, "message")) {
[08:26:49.168]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:49.168]                         if (muffled) 
[08:26:49.168]                           invokeRestart("muffleMessage")
[08:26:49.168]                       }
[08:26:49.168]                       else if (inherits(cond, "warning")) {
[08:26:49.168]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:49.168]                         if (muffled) 
[08:26:49.168]                           invokeRestart("muffleWarning")
[08:26:49.168]                       }
[08:26:49.168]                       else if (inherits(cond, "condition")) {
[08:26:49.168]                         if (!is.null(pattern)) {
[08:26:49.168]                           computeRestarts <- base::computeRestarts
[08:26:49.168]                           grepl <- base::grepl
[08:26:49.168]                           restarts <- computeRestarts(cond)
[08:26:49.168]                           for (restart in restarts) {
[08:26:49.168]                             name <- restart$name
[08:26:49.168]                             if (is.null(name)) 
[08:26:49.168]                               next
[08:26:49.168]                             if (!grepl(pattern, name)) 
[08:26:49.168]                               next
[08:26:49.168]                             invokeRestart(restart)
[08:26:49.168]                             muffled <- TRUE
[08:26:49.168]                             break
[08:26:49.168]                           }
[08:26:49.168]                         }
[08:26:49.168]                       }
[08:26:49.168]                       invisible(muffled)
[08:26:49.168]                     }
[08:26:49.168]                     muffleCondition(cond, pattern = "^muffle")
[08:26:49.168]                   }
[08:26:49.168]                 }
[08:26:49.168]                 else {
[08:26:49.168]                   if (TRUE) {
[08:26:49.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.168]                     {
[08:26:49.168]                       inherits <- base::inherits
[08:26:49.168]                       invokeRestart <- base::invokeRestart
[08:26:49.168]                       is.null <- base::is.null
[08:26:49.168]                       muffled <- FALSE
[08:26:49.168]                       if (inherits(cond, "message")) {
[08:26:49.168]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:49.168]                         if (muffled) 
[08:26:49.168]                           invokeRestart("muffleMessage")
[08:26:49.168]                       }
[08:26:49.168]                       else if (inherits(cond, "warning")) {
[08:26:49.168]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:49.168]                         if (muffled) 
[08:26:49.168]                           invokeRestart("muffleWarning")
[08:26:49.168]                       }
[08:26:49.168]                       else if (inherits(cond, "condition")) {
[08:26:49.168]                         if (!is.null(pattern)) {
[08:26:49.168]                           computeRestarts <- base::computeRestarts
[08:26:49.168]                           grepl <- base::grepl
[08:26:49.168]                           restarts <- computeRestarts(cond)
[08:26:49.168]                           for (restart in restarts) {
[08:26:49.168]                             name <- restart$name
[08:26:49.168]                             if (is.null(name)) 
[08:26:49.168]                               next
[08:26:49.168]                             if (!grepl(pattern, name)) 
[08:26:49.168]                               next
[08:26:49.168]                             invokeRestart(restart)
[08:26:49.168]                             muffled <- TRUE
[08:26:49.168]                             break
[08:26:49.168]                           }
[08:26:49.168]                         }
[08:26:49.168]                       }
[08:26:49.168]                       invisible(muffled)
[08:26:49.168]                     }
[08:26:49.168]                     muffleCondition(cond, pattern = "^muffle")
[08:26:49.168]                   }
[08:26:49.168]                 }
[08:26:49.168]             }
[08:26:49.168]         }))
[08:26:49.168]     }, error = function(ex) {
[08:26:49.168]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:49.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:49.168]                 ...future.rng), started = ...future.startTime, 
[08:26:49.168]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:49.168]             version = "1.8"), class = "FutureResult")
[08:26:49.168]     }, finally = {
[08:26:49.168]         if (!identical(...future.workdir, getwd())) 
[08:26:49.168]             setwd(...future.workdir)
[08:26:49.168]         {
[08:26:49.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:49.168]                 ...future.oldOptions$nwarnings <- NULL
[08:26:49.168]             }
[08:26:49.168]             base::options(...future.oldOptions)
[08:26:49.168]             if (.Platform$OS.type == "windows") {
[08:26:49.168]                 old_names <- names(...future.oldEnvVars)
[08:26:49.168]                 envs <- base::Sys.getenv()
[08:26:49.168]                 names <- names(envs)
[08:26:49.168]                 common <- intersect(names, old_names)
[08:26:49.168]                 added <- setdiff(names, old_names)
[08:26:49.168]                 removed <- setdiff(old_names, names)
[08:26:49.168]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:49.168]                   envs[common]]
[08:26:49.168]                 NAMES <- toupper(changed)
[08:26:49.168]                 args <- list()
[08:26:49.168]                 for (kk in seq_along(NAMES)) {
[08:26:49.168]                   name <- changed[[kk]]
[08:26:49.168]                   NAME <- NAMES[[kk]]
[08:26:49.168]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.168]                     next
[08:26:49.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:49.168]                 }
[08:26:49.168]                 NAMES <- toupper(added)
[08:26:49.168]                 for (kk in seq_along(NAMES)) {
[08:26:49.168]                   name <- added[[kk]]
[08:26:49.168]                   NAME <- NAMES[[kk]]
[08:26:49.168]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.168]                     next
[08:26:49.168]                   args[[name]] <- ""
[08:26:49.168]                 }
[08:26:49.168]                 NAMES <- toupper(removed)
[08:26:49.168]                 for (kk in seq_along(NAMES)) {
[08:26:49.168]                   name <- removed[[kk]]
[08:26:49.168]                   NAME <- NAMES[[kk]]
[08:26:49.168]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.168]                     next
[08:26:49.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:49.168]                 }
[08:26:49.168]                 if (length(args) > 0) 
[08:26:49.168]                   base::do.call(base::Sys.setenv, args = args)
[08:26:49.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:49.168]             }
[08:26:49.168]             else {
[08:26:49.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:49.168]             }
[08:26:49.168]             {
[08:26:49.168]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:49.168]                   0L) {
[08:26:49.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:49.168]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:49.168]                   base::options(opts)
[08:26:49.168]                 }
[08:26:49.168]                 {
[08:26:49.168]                   {
[08:26:49.168]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:49.168]                     NULL
[08:26:49.168]                   }
[08:26:49.168]                   options(future.plan = NULL)
[08:26:49.168]                   if (is.na(NA_character_)) 
[08:26:49.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:49.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:49.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:49.168]                     .init = FALSE)
[08:26:49.168]                 }
[08:26:49.168]             }
[08:26:49.168]         }
[08:26:49.168]     })
[08:26:49.168]     if (TRUE) {
[08:26:49.168]         base::sink(type = "output", split = FALSE)
[08:26:49.168]         if (TRUE) {
[08:26:49.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:49.168]         }
[08:26:49.168]         else {
[08:26:49.168]             ...future.result["stdout"] <- base::list(NULL)
[08:26:49.168]         }
[08:26:49.168]         base::close(...future.stdout)
[08:26:49.168]         ...future.stdout <- NULL
[08:26:49.168]     }
[08:26:49.168]     ...future.result$conditions <- ...future.conditions
[08:26:49.168]     ...future.result$finished <- base::Sys.time()
[08:26:49.168]     ...future.result
[08:26:49.168] }
[08:26:49.171] Exporting 5 global objects (1.63 KiB) to cluster node #1 ...
[08:26:49.171] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[08:26:49.172] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[08:26:49.172] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:26:49.172] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:26:49.172] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[08:26:49.173] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[08:26:49.173] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:49.173] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:49.173] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:49.174] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:49.174] Exporting 5 global objects (1.63 KiB) to cluster node #1 ... DONE
[08:26:49.174] MultisessionFuture started
[08:26:49.175] - Launch lazy future ... done
[08:26:49.175] run() for ‘MultisessionFuture’ ... done
[08:26:49.175] Created future:
[08:26:49.175] MultisessionFuture:
[08:26:49.175] Label: ‘future_mapply-1’
[08:26:49.175] Expression:
[08:26:49.175] {
[08:26:49.175]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:49.175]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:49.175]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:49.175]         on.exit(options(oopts), add = TRUE)
[08:26:49.175]     }
[08:26:49.175]     {
[08:26:49.175]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:49.175]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:49.175]         do.call(mapply, args = args)
[08:26:49.175]     }
[08:26:49.175] }
[08:26:49.175] Lazy evaluation: FALSE
[08:26:49.175] Asynchronous evaluation: TRUE
[08:26:49.175] Local evaluation: TRUE
[08:26:49.175] Environment: R_GlobalEnv
[08:26:49.175] Capture standard output: TRUE
[08:26:49.175] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:49.175] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:49.175] Packages: <none>
[08:26:49.175] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:49.175] Resolved: FALSE
[08:26:49.175] Value: <not collected>
[08:26:49.175] Conditions captured: <none>
[08:26:49.175] Early signaling: FALSE
[08:26:49.175] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:49.175] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:49.187] Chunk #1 of 2 ... DONE
[08:26:49.187] Chunk #2 of 2 ...
[08:26:49.187]  - Finding globals in '...' for chunk #2 ...
[08:26:49.187] getGlobalsAndPackages() ...
[08:26:49.187] Searching for globals...
[08:26:49.187] 
[08:26:49.187] Searching for globals ... DONE
[08:26:49.188] - globals: [0] <none>
[08:26:49.188] getGlobalsAndPackages() ... DONE
[08:26:49.188]    + additional globals found: [n=0] 
[08:26:49.188]    + additional namespaces needed: [n=0] 
[08:26:49.188]  - Finding globals in '...' for chunk #2 ... DONE
[08:26:49.188]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:49.188]  - seeds: <none>
[08:26:49.188]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.188] getGlobalsAndPackages() ...
[08:26:49.188] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.189] Resolving globals: FALSE
[08:26:49.189] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:49.189] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:49.190] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.190] 
[08:26:49.190] getGlobalsAndPackages() ... DONE
[08:26:49.190] run() for ‘Future’ ...
[08:26:49.190] - state: ‘created’
[08:26:49.190] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:49.205] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:49.205] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:49.205]   - Field: ‘node’
[08:26:49.205]   - Field: ‘label’
[08:26:49.205]   - Field: ‘local’
[08:26:49.206]   - Field: ‘owner’
[08:26:49.206]   - Field: ‘envir’
[08:26:49.206]   - Field: ‘workers’
[08:26:49.206]   - Field: ‘packages’
[08:26:49.206]   - Field: ‘gc’
[08:26:49.206]   - Field: ‘conditions’
[08:26:49.206]   - Field: ‘persistent’
[08:26:49.206]   - Field: ‘expr’
[08:26:49.206]   - Field: ‘uuid’
[08:26:49.206]   - Field: ‘seed’
[08:26:49.206]   - Field: ‘version’
[08:26:49.207]   - Field: ‘result’
[08:26:49.207]   - Field: ‘asynchronous’
[08:26:49.207]   - Field: ‘calls’
[08:26:49.207]   - Field: ‘globals’
[08:26:49.207]   - Field: ‘stdout’
[08:26:49.207]   - Field: ‘earlySignal’
[08:26:49.207]   - Field: ‘lazy’
[08:26:49.207]   - Field: ‘state’
[08:26:49.207] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:49.207] - Launch lazy future ...
[08:26:49.208] Packages needed by the future expression (n = 0): <none>
[08:26:49.208] Packages needed by future strategies (n = 0): <none>
[08:26:49.208] {
[08:26:49.208]     {
[08:26:49.208]         {
[08:26:49.208]             ...future.startTime <- base::Sys.time()
[08:26:49.208]             {
[08:26:49.208]                 {
[08:26:49.208]                   {
[08:26:49.208]                     {
[08:26:49.208]                       base::local({
[08:26:49.208]                         has_future <- base::requireNamespace("future", 
[08:26:49.208]                           quietly = TRUE)
[08:26:49.208]                         if (has_future) {
[08:26:49.208]                           ns <- base::getNamespace("future")
[08:26:49.208]                           version <- ns[[".package"]][["version"]]
[08:26:49.208]                           if (is.null(version)) 
[08:26:49.208]                             version <- utils::packageVersion("future")
[08:26:49.208]                         }
[08:26:49.208]                         else {
[08:26:49.208]                           version <- NULL
[08:26:49.208]                         }
[08:26:49.208]                         if (!has_future || version < "1.8.0") {
[08:26:49.208]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:49.208]                             "", base::R.version$version.string), 
[08:26:49.208]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:49.208]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:49.208]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:49.208]                               "release", "version")], collapse = " "), 
[08:26:49.208]                             hostname = base::Sys.info()[["nodename"]])
[08:26:49.208]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:49.208]                             info)
[08:26:49.208]                           info <- base::paste(info, collapse = "; ")
[08:26:49.208]                           if (!has_future) {
[08:26:49.208]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:49.208]                               info)
[08:26:49.208]                           }
[08:26:49.208]                           else {
[08:26:49.208]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:49.208]                               info, version)
[08:26:49.208]                           }
[08:26:49.208]                           base::stop(msg)
[08:26:49.208]                         }
[08:26:49.208]                       })
[08:26:49.208]                     }
[08:26:49.208]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:49.208]                     base::options(mc.cores = 1L)
[08:26:49.208]                   }
[08:26:49.208]                   ...future.strategy.old <- future::plan("list")
[08:26:49.208]                   options(future.plan = NULL)
[08:26:49.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:49.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:49.208]                 }
[08:26:49.208]                 ...future.workdir <- getwd()
[08:26:49.208]             }
[08:26:49.208]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:49.208]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:49.208]         }
[08:26:49.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:49.208]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:49.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:49.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:49.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:49.208]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:49.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:49.208]             base::names(...future.oldOptions))
[08:26:49.208]     }
[08:26:49.208]     if (FALSE) {
[08:26:49.208]     }
[08:26:49.208]     else {
[08:26:49.208]         if (TRUE) {
[08:26:49.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:49.208]                 open = "w")
[08:26:49.208]         }
[08:26:49.208]         else {
[08:26:49.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:49.208]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:49.208]         }
[08:26:49.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:49.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:49.208]             base::sink(type = "output", split = FALSE)
[08:26:49.208]             base::close(...future.stdout)
[08:26:49.208]         }, add = TRUE)
[08:26:49.208]     }
[08:26:49.208]     ...future.frame <- base::sys.nframe()
[08:26:49.208]     ...future.conditions <- base::list()
[08:26:49.208]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:49.208]     if (FALSE) {
[08:26:49.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:49.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:49.208]     }
[08:26:49.208]     ...future.result <- base::tryCatch({
[08:26:49.208]         base::withCallingHandlers({
[08:26:49.208]             ...future.value <- base::withVisible(base::local({
[08:26:49.208]                 ...future.makeSendCondition <- base::local({
[08:26:49.208]                   sendCondition <- NULL
[08:26:49.208]                   function(frame = 1L) {
[08:26:49.208]                     if (is.function(sendCondition)) 
[08:26:49.208]                       return(sendCondition)
[08:26:49.208]                     ns <- getNamespace("parallel")
[08:26:49.208]                     if (exists("sendData", mode = "function", 
[08:26:49.208]                       envir = ns)) {
[08:26:49.208]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:49.208]                         envir = ns)
[08:26:49.208]                       envir <- sys.frame(frame)
[08:26:49.208]                       master <- NULL
[08:26:49.208]                       while (!identical(envir, .GlobalEnv) && 
[08:26:49.208]                         !identical(envir, emptyenv())) {
[08:26:49.208]                         if (exists("master", mode = "list", envir = envir, 
[08:26:49.208]                           inherits = FALSE)) {
[08:26:49.208]                           master <- get("master", mode = "list", 
[08:26:49.208]                             envir = envir, inherits = FALSE)
[08:26:49.208]                           if (inherits(master, c("SOCKnode", 
[08:26:49.208]                             "SOCK0node"))) {
[08:26:49.208]                             sendCondition <<- function(cond) {
[08:26:49.208]                               data <- list(type = "VALUE", value = cond, 
[08:26:49.208]                                 success = TRUE)
[08:26:49.208]                               parallel_sendData(master, data)
[08:26:49.208]                             }
[08:26:49.208]                             return(sendCondition)
[08:26:49.208]                           }
[08:26:49.208]                         }
[08:26:49.208]                         frame <- frame + 1L
[08:26:49.208]                         envir <- sys.frame(frame)
[08:26:49.208]                       }
[08:26:49.208]                     }
[08:26:49.208]                     sendCondition <<- function(cond) NULL
[08:26:49.208]                   }
[08:26:49.208]                 })
[08:26:49.208]                 withCallingHandlers({
[08:26:49.208]                   {
[08:26:49.208]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:49.208]                     if (!identical(...future.globals.maxSize.org, 
[08:26:49.208]                       ...future.globals.maxSize)) {
[08:26:49.208]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:49.208]                       on.exit(options(oopts), add = TRUE)
[08:26:49.208]                     }
[08:26:49.208]                     {
[08:26:49.208]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:49.208]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:49.208]                         USE.NAMES = FALSE)
[08:26:49.208]                       do.call(mapply, args = args)
[08:26:49.208]                     }
[08:26:49.208]                   }
[08:26:49.208]                 }, immediateCondition = function(cond) {
[08:26:49.208]                   sendCondition <- ...future.makeSendCondition()
[08:26:49.208]                   sendCondition(cond)
[08:26:49.208]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.208]                   {
[08:26:49.208]                     inherits <- base::inherits
[08:26:49.208]                     invokeRestart <- base::invokeRestart
[08:26:49.208]                     is.null <- base::is.null
[08:26:49.208]                     muffled <- FALSE
[08:26:49.208]                     if (inherits(cond, "message")) {
[08:26:49.208]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:49.208]                       if (muffled) 
[08:26:49.208]                         invokeRestart("muffleMessage")
[08:26:49.208]                     }
[08:26:49.208]                     else if (inherits(cond, "warning")) {
[08:26:49.208]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:49.208]                       if (muffled) 
[08:26:49.208]                         invokeRestart("muffleWarning")
[08:26:49.208]                     }
[08:26:49.208]                     else if (inherits(cond, "condition")) {
[08:26:49.208]                       if (!is.null(pattern)) {
[08:26:49.208]                         computeRestarts <- base::computeRestarts
[08:26:49.208]                         grepl <- base::grepl
[08:26:49.208]                         restarts <- computeRestarts(cond)
[08:26:49.208]                         for (restart in restarts) {
[08:26:49.208]                           name <- restart$name
[08:26:49.208]                           if (is.null(name)) 
[08:26:49.208]                             next
[08:26:49.208]                           if (!grepl(pattern, name)) 
[08:26:49.208]                             next
[08:26:49.208]                           invokeRestart(restart)
[08:26:49.208]                           muffled <- TRUE
[08:26:49.208]                           break
[08:26:49.208]                         }
[08:26:49.208]                       }
[08:26:49.208]                     }
[08:26:49.208]                     invisible(muffled)
[08:26:49.208]                   }
[08:26:49.208]                   muffleCondition(cond)
[08:26:49.208]                 })
[08:26:49.208]             }))
[08:26:49.208]             future::FutureResult(value = ...future.value$value, 
[08:26:49.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:49.208]                   ...future.rng), globalenv = if (FALSE) 
[08:26:49.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:49.208]                     ...future.globalenv.names))
[08:26:49.208]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:49.208]         }, condition = base::local({
[08:26:49.208]             c <- base::c
[08:26:49.208]             inherits <- base::inherits
[08:26:49.208]             invokeRestart <- base::invokeRestart
[08:26:49.208]             length <- base::length
[08:26:49.208]             list <- base::list
[08:26:49.208]             seq.int <- base::seq.int
[08:26:49.208]             signalCondition <- base::signalCondition
[08:26:49.208]             sys.calls <- base::sys.calls
[08:26:49.208]             `[[` <- base::`[[`
[08:26:49.208]             `+` <- base::`+`
[08:26:49.208]             `<<-` <- base::`<<-`
[08:26:49.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:49.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:49.208]                   3L)]
[08:26:49.208]             }
[08:26:49.208]             function(cond) {
[08:26:49.208]                 is_error <- inherits(cond, "error")
[08:26:49.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:49.208]                   NULL)
[08:26:49.208]                 if (is_error) {
[08:26:49.208]                   sessionInformation <- function() {
[08:26:49.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:49.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:49.208]                       search = base::search(), system = base::Sys.info())
[08:26:49.208]                   }
[08:26:49.208]                   ...future.conditions[[length(...future.conditions) + 
[08:26:49.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:49.208]                     cond$call), session = sessionInformation(), 
[08:26:49.208]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:49.208]                   signalCondition(cond)
[08:26:49.208]                 }
[08:26:49.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:49.208]                 "immediateCondition"))) {
[08:26:49.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:49.208]                   ...future.conditions[[length(...future.conditions) + 
[08:26:49.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:49.208]                   if (TRUE && !signal) {
[08:26:49.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.208]                     {
[08:26:49.208]                       inherits <- base::inherits
[08:26:49.208]                       invokeRestart <- base::invokeRestart
[08:26:49.208]                       is.null <- base::is.null
[08:26:49.208]                       muffled <- FALSE
[08:26:49.208]                       if (inherits(cond, "message")) {
[08:26:49.208]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:49.208]                         if (muffled) 
[08:26:49.208]                           invokeRestart("muffleMessage")
[08:26:49.208]                       }
[08:26:49.208]                       else if (inherits(cond, "warning")) {
[08:26:49.208]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:49.208]                         if (muffled) 
[08:26:49.208]                           invokeRestart("muffleWarning")
[08:26:49.208]                       }
[08:26:49.208]                       else if (inherits(cond, "condition")) {
[08:26:49.208]                         if (!is.null(pattern)) {
[08:26:49.208]                           computeRestarts <- base::computeRestarts
[08:26:49.208]                           grepl <- base::grepl
[08:26:49.208]                           restarts <- computeRestarts(cond)
[08:26:49.208]                           for (restart in restarts) {
[08:26:49.208]                             name <- restart$name
[08:26:49.208]                             if (is.null(name)) 
[08:26:49.208]                               next
[08:26:49.208]                             if (!grepl(pattern, name)) 
[08:26:49.208]                               next
[08:26:49.208]                             invokeRestart(restart)
[08:26:49.208]                             muffled <- TRUE
[08:26:49.208]                             break
[08:26:49.208]                           }
[08:26:49.208]                         }
[08:26:49.208]                       }
[08:26:49.208]                       invisible(muffled)
[08:26:49.208]                     }
[08:26:49.208]                     muffleCondition(cond, pattern = "^muffle")
[08:26:49.208]                   }
[08:26:49.208]                 }
[08:26:49.208]                 else {
[08:26:49.208]                   if (TRUE) {
[08:26:49.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.208]                     {
[08:26:49.208]                       inherits <- base::inherits
[08:26:49.208]                       invokeRestart <- base::invokeRestart
[08:26:49.208]                       is.null <- base::is.null
[08:26:49.208]                       muffled <- FALSE
[08:26:49.208]                       if (inherits(cond, "message")) {
[08:26:49.208]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:49.208]                         if (muffled) 
[08:26:49.208]                           invokeRestart("muffleMessage")
[08:26:49.208]                       }
[08:26:49.208]                       else if (inherits(cond, "warning")) {
[08:26:49.208]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:49.208]                         if (muffled) 
[08:26:49.208]                           invokeRestart("muffleWarning")
[08:26:49.208]                       }
[08:26:49.208]                       else if (inherits(cond, "condition")) {
[08:26:49.208]                         if (!is.null(pattern)) {
[08:26:49.208]                           computeRestarts <- base::computeRestarts
[08:26:49.208]                           grepl <- base::grepl
[08:26:49.208]                           restarts <- computeRestarts(cond)
[08:26:49.208]                           for (restart in restarts) {
[08:26:49.208]                             name <- restart$name
[08:26:49.208]                             if (is.null(name)) 
[08:26:49.208]                               next
[08:26:49.208]                             if (!grepl(pattern, name)) 
[08:26:49.208]                               next
[08:26:49.208]                             invokeRestart(restart)
[08:26:49.208]                             muffled <- TRUE
[08:26:49.208]                             break
[08:26:49.208]                           }
[08:26:49.208]                         }
[08:26:49.208]                       }
[08:26:49.208]                       invisible(muffled)
[08:26:49.208]                     }
[08:26:49.208]                     muffleCondition(cond, pattern = "^muffle")
[08:26:49.208]                   }
[08:26:49.208]                 }
[08:26:49.208]             }
[08:26:49.208]         }))
[08:26:49.208]     }, error = function(ex) {
[08:26:49.208]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:49.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:49.208]                 ...future.rng), started = ...future.startTime, 
[08:26:49.208]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:49.208]             version = "1.8"), class = "FutureResult")
[08:26:49.208]     }, finally = {
[08:26:49.208]         if (!identical(...future.workdir, getwd())) 
[08:26:49.208]             setwd(...future.workdir)
[08:26:49.208]         {
[08:26:49.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:49.208]                 ...future.oldOptions$nwarnings <- NULL
[08:26:49.208]             }
[08:26:49.208]             base::options(...future.oldOptions)
[08:26:49.208]             if (.Platform$OS.type == "windows") {
[08:26:49.208]                 old_names <- names(...future.oldEnvVars)
[08:26:49.208]                 envs <- base::Sys.getenv()
[08:26:49.208]                 names <- names(envs)
[08:26:49.208]                 common <- intersect(names, old_names)
[08:26:49.208]                 added <- setdiff(names, old_names)
[08:26:49.208]                 removed <- setdiff(old_names, names)
[08:26:49.208]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:49.208]                   envs[common]]
[08:26:49.208]                 NAMES <- toupper(changed)
[08:26:49.208]                 args <- list()
[08:26:49.208]                 for (kk in seq_along(NAMES)) {
[08:26:49.208]                   name <- changed[[kk]]
[08:26:49.208]                   NAME <- NAMES[[kk]]
[08:26:49.208]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.208]                     next
[08:26:49.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:49.208]                 }
[08:26:49.208]                 NAMES <- toupper(added)
[08:26:49.208]                 for (kk in seq_along(NAMES)) {
[08:26:49.208]                   name <- added[[kk]]
[08:26:49.208]                   NAME <- NAMES[[kk]]
[08:26:49.208]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.208]                     next
[08:26:49.208]                   args[[name]] <- ""
[08:26:49.208]                 }
[08:26:49.208]                 NAMES <- toupper(removed)
[08:26:49.208]                 for (kk in seq_along(NAMES)) {
[08:26:49.208]                   name <- removed[[kk]]
[08:26:49.208]                   NAME <- NAMES[[kk]]
[08:26:49.208]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.208]                     next
[08:26:49.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:49.208]                 }
[08:26:49.208]                 if (length(args) > 0) 
[08:26:49.208]                   base::do.call(base::Sys.setenv, args = args)
[08:26:49.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:49.208]             }
[08:26:49.208]             else {
[08:26:49.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:49.208]             }
[08:26:49.208]             {
[08:26:49.208]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:49.208]                   0L) {
[08:26:49.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:49.208]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:49.208]                   base::options(opts)
[08:26:49.208]                 }
[08:26:49.208]                 {
[08:26:49.208]                   {
[08:26:49.208]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:49.208]                     NULL
[08:26:49.208]                   }
[08:26:49.208]                   options(future.plan = NULL)
[08:26:49.208]                   if (is.na(NA_character_)) 
[08:26:49.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:49.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:49.208]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:49.208]                     .init = FALSE)
[08:26:49.208]                 }
[08:26:49.208]             }
[08:26:49.208]         }
[08:26:49.208]     })
[08:26:49.208]     if (TRUE) {
[08:26:49.208]         base::sink(type = "output", split = FALSE)
[08:26:49.208]         if (TRUE) {
[08:26:49.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:49.208]         }
[08:26:49.208]         else {
[08:26:49.208]             ...future.result["stdout"] <- base::list(NULL)
[08:26:49.208]         }
[08:26:49.208]         base::close(...future.stdout)
[08:26:49.208]         ...future.stdout <- NULL
[08:26:49.208]     }
[08:26:49.208]     ...future.result$conditions <- ...future.conditions
[08:26:49.208]     ...future.result$finished <- base::Sys.time()
[08:26:49.208]     ...future.result
[08:26:49.208] }
[08:26:49.211] Exporting 5 global objects (1.63 KiB) to cluster node #2 ...
[08:26:49.211] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[08:26:49.212] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[08:26:49.212] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:26:49.212] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:26:49.213] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[08:26:49.213] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[08:26:49.213] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:49.213] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:49.214] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:49.214] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:49.214] Exporting 5 global objects (1.63 KiB) to cluster node #2 ... DONE
[08:26:49.215] MultisessionFuture started
[08:26:49.215] - Launch lazy future ... done
[08:26:49.215] run() for ‘MultisessionFuture’ ... done
[08:26:49.215] Created future:
[08:26:49.216] MultisessionFuture:
[08:26:49.216] Label: ‘future_mapply-2’
[08:26:49.216] Expression:
[08:26:49.216] {
[08:26:49.216]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:49.216]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:49.216]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:49.216]         on.exit(options(oopts), add = TRUE)
[08:26:49.216]     }
[08:26:49.216]     {
[08:26:49.216]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:49.216]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:49.216]         do.call(mapply, args = args)
[08:26:49.216]     }
[08:26:49.216] }
[08:26:49.216] Lazy evaluation: FALSE
[08:26:49.216] Asynchronous evaluation: TRUE
[08:26:49.216] Local evaluation: TRUE
[08:26:49.216] Environment: R_GlobalEnv
[08:26:49.216] Capture standard output: TRUE
[08:26:49.216] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:49.216] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:49.216] Packages: <none>
[08:26:49.216] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:49.216] Resolved: FALSE
[08:26:49.216] Value: <not collected>
[08:26:49.216] Conditions captured: <none>
[08:26:49.216] Early signaling: FALSE
[08:26:49.216] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:49.216] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:49.227] Chunk #2 of 2 ... DONE
[08:26:49.228] Launching 2 futures (chunks) ... DONE
[08:26:49.228] Resolving 2 futures (chunks) ...
[08:26:49.228] resolve() on list ...
[08:26:49.228]  recursive: 0
[08:26:49.228]  length: 2
[08:26:49.228] 
[08:26:49.271] receiveMessageFromWorker() for ClusterFuture ...
[08:26:49.272] - Validating connection of MultisessionFuture
[08:26:49.272] - received message: FutureResult
[08:26:49.272] - Received FutureResult
[08:26:49.272] - Erased future from FutureRegistry
[08:26:49.272] result() for ClusterFuture ...
[08:26:49.272] - result already collected: FutureResult
[08:26:49.272] result() for ClusterFuture ... done
[08:26:49.272] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:49.272] Future #2
[08:26:49.273] result() for ClusterFuture ...
[08:26:49.273] - result already collected: FutureResult
[08:26:49.273] result() for ClusterFuture ... done
[08:26:49.273] result() for ClusterFuture ...
[08:26:49.273] - result already collected: FutureResult
[08:26:49.273] result() for ClusterFuture ... done
[08:26:49.273] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:49.273] - nx: 2
[08:26:49.273] - relay: TRUE
[08:26:49.273] - stdout: TRUE
[08:26:49.273] - signal: TRUE
[08:26:49.274] - resignal: FALSE
[08:26:49.274] - force: TRUE
[08:26:49.274] - relayed: [n=2] FALSE, FALSE
[08:26:49.274] - queued futures: [n=2] FALSE, FALSE
[08:26:49.274]  - until=1
[08:26:49.274]  - relaying element #1
[08:26:49.274] - relayed: [n=2] FALSE, FALSE
[08:26:49.274] - queued futures: [n=2] FALSE, TRUE
[08:26:49.274] signalConditionsASAP(NULL, pos=2) ... done
[08:26:49.274]  length: 1 (resolved future 2)
[08:26:49.726] receiveMessageFromWorker() for ClusterFuture ...
[08:26:49.726] - Validating connection of MultisessionFuture
[08:26:49.726] - received message: FutureResult
[08:26:49.726] - Received FutureResult
[08:26:49.727] - Erased future from FutureRegistry
[08:26:49.727] result() for ClusterFuture ...
[08:26:49.727] - result already collected: FutureResult
[08:26:49.727] result() for ClusterFuture ... done
[08:26:49.727] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:49.727] Future #1
[08:26:49.727] result() for ClusterFuture ...
[08:26:49.727] - result already collected: FutureResult
[08:26:49.727] result() for ClusterFuture ... done
[08:26:49.727] result() for ClusterFuture ...
[08:26:49.727] - result already collected: FutureResult
[08:26:49.728] result() for ClusterFuture ... done
[08:26:49.728] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:49.728] - nx: 2
[08:26:49.728] - relay: TRUE
[08:26:49.728] - stdout: TRUE
[08:26:49.728] - signal: TRUE
[08:26:49.728] - resignal: FALSE
[08:26:49.728] - force: TRUE
[08:26:49.728] - relayed: [n=2] FALSE, FALSE
[08:26:49.728] - queued futures: [n=2] FALSE, TRUE
[08:26:49.728]  - until=1
[08:26:49.729]  - relaying element #1
[08:26:49.729] result() for ClusterFuture ...
[08:26:49.729] - result already collected: FutureResult
[08:26:49.729] result() for ClusterFuture ... done
[08:26:49.729] result() for ClusterFuture ...
[08:26:49.729] - result already collected: FutureResult
[08:26:49.729] result() for ClusterFuture ... done
[08:26:49.729] result() for ClusterFuture ...
[08:26:49.729] - result already collected: FutureResult
[08:26:49.729] result() for ClusterFuture ... done
[08:26:49.729] result() for ClusterFuture ...
[08:26:49.730] - result already collected: FutureResult
[08:26:49.730] result() for ClusterFuture ... done
[08:26:49.730] - relayed: [n=2] TRUE, FALSE
[08:26:49.730] - queued futures: [n=2] TRUE, TRUE
[08:26:49.730] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:49.730]  length: 0 (resolved future 1)
[08:26:49.730] Relaying remaining futures
[08:26:49.730] signalConditionsASAP(NULL, pos=0) ...
[08:26:49.730] - nx: 2
[08:26:49.730] - relay: TRUE
[08:26:49.730] - stdout: TRUE
[08:26:49.730] - signal: TRUE
[08:26:49.731] - resignal: FALSE
[08:26:49.731] - force: TRUE
[08:26:49.731] - relayed: [n=2] TRUE, FALSE
[08:26:49.731] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:49.731]  - relaying element #2
[08:26:49.731] result() for ClusterFuture ...
[08:26:49.731] - result already collected: FutureResult
[08:26:49.731] result() for ClusterFuture ... done
[08:26:49.731] result() for ClusterFuture ...
[08:26:49.731] - result already collected: FutureResult
[08:26:49.731] result() for ClusterFuture ... done
[08:26:49.732] result() for ClusterFuture ...
[08:26:49.732] - result already collected: FutureResult
[08:26:49.732] result() for ClusterFuture ... done
[08:26:49.732] result() for ClusterFuture ...
[08:26:49.732] - result already collected: FutureResult
[08:26:49.732] result() for ClusterFuture ... done
[08:26:49.732] - relayed: [n=2] TRUE, TRUE
[08:26:49.732] - queued futures: [n=2] TRUE, TRUE
[08:26:49.732] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[08:26:49.732] resolve() on list ... DONE
[08:26:49.732] result() for ClusterFuture ...
[08:26:49.732] - result already collected: FutureResult
[08:26:49.733] result() for ClusterFuture ... done
[08:26:49.733] result() for ClusterFuture ...
[08:26:49.733] - result already collected: FutureResult
[08:26:49.733] result() for ClusterFuture ... done
[08:26:49.733] result() for ClusterFuture ...
[08:26:49.733] - result already collected: FutureResult
[08:26:49.733] result() for ClusterFuture ... done
[08:26:49.733] result() for ClusterFuture ...
[08:26:49.733] - result already collected: FutureResult
[08:26:49.733] result() for ClusterFuture ... done
[08:26:49.733]  - Number of value chunks collected: 2
[08:26:49.734] Resolving 2 futures (chunks) ... DONE
[08:26:49.734] Reducing values from 2 chunks ...
[08:26:49.734]  - Number of values collected after concatenation: 2
[08:26:49.734]  - Number of values expected: 2
[08:26:49.734] Reducing values from 2 chunks ... DONE
[08:26:49.734] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[08:26:49.734] future_mapply() ...
[08:26:49.736] Number of chunks: 2
[08:26:49.736] getGlobalsAndPackagesXApply() ...
[08:26:49.736]  - future.globals: TRUE
[08:26:49.737] getGlobalsAndPackages() ...
[08:26:49.737] Searching for globals...
[08:26:49.738] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[08:26:49.739] Searching for globals ... DONE
[08:26:49.739] Resolving globals: FALSE
[08:26:49.739] The total size of the 1 globals is 1.04 KiB (1066 bytes)
[08:26:49.739] The total size of the 1 globals exported for future expression (‘FUN()’) is 1.04 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.04 KiB of class ‘function’)
[08:26:49.740] - globals: [1] ‘FUN’
[08:26:49.740] 
[08:26:49.740] getGlobalsAndPackages() ... DONE
[08:26:49.740]  - globals found/used: [n=1] ‘FUN’
[08:26:49.740]  - needed namespaces: [n=0] 
[08:26:49.740] Finding globals ... DONE
[08:26:49.740] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[08:26:49.740] List of 2
[08:26:49.740]  $ ...future.FUN:function (x, y)  
[08:26:49.740]  $ MoreArgs     : NULL
[08:26:49.740]  - attr(*, "where")=List of 2
[08:26:49.740]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:26:49.740]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[08:26:49.740]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:26:49.740]  - attr(*, "resolved")= logi FALSE
[08:26:49.740]  - attr(*, "total_size")= num NA
[08:26:49.743] Packages to be attached in all futures: [n=0] 
[08:26:49.743] getGlobalsAndPackagesXApply() ... DONE
[08:26:49.743] Number of futures (= number of chunks): 2
[08:26:49.743] Launching 2 futures (chunks) ...
[08:26:49.743] Chunk #1 of 2 ...
[08:26:49.744]  - Finding globals in '...' for chunk #1 ...
[08:26:49.744] getGlobalsAndPackages() ...
[08:26:49.744] Searching for globals...
[08:26:49.744] 
[08:26:49.744] Searching for globals ... DONE
[08:26:49.744] - globals: [0] <none>
[08:26:49.744] getGlobalsAndPackages() ... DONE
[08:26:49.744]    + additional globals found: [n=0] 
[08:26:49.745]    + additional namespaces needed: [n=0] 
[08:26:49.745]  - Finding globals in '...' for chunk #1 ... DONE
[08:26:49.745]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:49.745]  - seeds: <none>
[08:26:49.745]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.745] getGlobalsAndPackages() ...
[08:26:49.745] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.745] Resolving globals: FALSE
[08:26:49.746] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:49.746] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:49.746] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.746] 
[08:26:49.749] getGlobalsAndPackages() ... DONE
[08:26:49.749] run() for ‘Future’ ...
[08:26:49.749] - state: ‘created’
[08:26:49.749] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:49.764] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:49.764] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:49.765]   - Field: ‘node’
[08:26:49.765]   - Field: ‘label’
[08:26:49.765]   - Field: ‘local’
[08:26:49.765]   - Field: ‘owner’
[08:26:49.765]   - Field: ‘envir’
[08:26:49.765]   - Field: ‘workers’
[08:26:49.765]   - Field: ‘packages’
[08:26:49.765]   - Field: ‘gc’
[08:26:49.765]   - Field: ‘conditions’
[08:26:49.765]   - Field: ‘persistent’
[08:26:49.765]   - Field: ‘expr’
[08:26:49.766]   - Field: ‘uuid’
[08:26:49.766]   - Field: ‘seed’
[08:26:49.766]   - Field: ‘version’
[08:26:49.766]   - Field: ‘result’
[08:26:49.766]   - Field: ‘asynchronous’
[08:26:49.766]   - Field: ‘calls’
[08:26:49.766]   - Field: ‘globals’
[08:26:49.766]   - Field: ‘stdout’
[08:26:49.766]   - Field: ‘earlySignal’
[08:26:49.766]   - Field: ‘lazy’
[08:26:49.766]   - Field: ‘state’
[08:26:49.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:49.767] - Launch lazy future ...
[08:26:49.767] Packages needed by the future expression (n = 0): <none>
[08:26:49.767] Packages needed by future strategies (n = 0): <none>
[08:26:49.767] {
[08:26:49.767]     {
[08:26:49.767]         {
[08:26:49.767]             ...future.startTime <- base::Sys.time()
[08:26:49.767]             {
[08:26:49.767]                 {
[08:26:49.767]                   {
[08:26:49.767]                     {
[08:26:49.767]                       base::local({
[08:26:49.767]                         has_future <- base::requireNamespace("future", 
[08:26:49.767]                           quietly = TRUE)
[08:26:49.767]                         if (has_future) {
[08:26:49.767]                           ns <- base::getNamespace("future")
[08:26:49.767]                           version <- ns[[".package"]][["version"]]
[08:26:49.767]                           if (is.null(version)) 
[08:26:49.767]                             version <- utils::packageVersion("future")
[08:26:49.767]                         }
[08:26:49.767]                         else {
[08:26:49.767]                           version <- NULL
[08:26:49.767]                         }
[08:26:49.767]                         if (!has_future || version < "1.8.0") {
[08:26:49.767]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:49.767]                             "", base::R.version$version.string), 
[08:26:49.767]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:49.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:49.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:49.767]                               "release", "version")], collapse = " "), 
[08:26:49.767]                             hostname = base::Sys.info()[["nodename"]])
[08:26:49.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:49.767]                             info)
[08:26:49.767]                           info <- base::paste(info, collapse = "; ")
[08:26:49.767]                           if (!has_future) {
[08:26:49.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:49.767]                               info)
[08:26:49.767]                           }
[08:26:49.767]                           else {
[08:26:49.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:49.767]                               info, version)
[08:26:49.767]                           }
[08:26:49.767]                           base::stop(msg)
[08:26:49.767]                         }
[08:26:49.767]                       })
[08:26:49.767]                     }
[08:26:49.767]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:49.767]                     base::options(mc.cores = 1L)
[08:26:49.767]                   }
[08:26:49.767]                   ...future.strategy.old <- future::plan("list")
[08:26:49.767]                   options(future.plan = NULL)
[08:26:49.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:49.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:49.767]                 }
[08:26:49.767]                 ...future.workdir <- getwd()
[08:26:49.767]             }
[08:26:49.767]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:49.767]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:49.767]         }
[08:26:49.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:49.767]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:49.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:49.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:49.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:49.767]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:49.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:49.767]             base::names(...future.oldOptions))
[08:26:49.767]     }
[08:26:49.767]     if (TRUE) {
[08:26:49.767]     }
[08:26:49.767]     else {
[08:26:49.767]         if (NA) {
[08:26:49.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:49.767]                 open = "w")
[08:26:49.767]         }
[08:26:49.767]         else {
[08:26:49.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:49.767]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:49.767]         }
[08:26:49.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:49.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:49.767]             base::sink(type = "output", split = FALSE)
[08:26:49.767]             base::close(...future.stdout)
[08:26:49.767]         }, add = TRUE)
[08:26:49.767]     }
[08:26:49.767]     ...future.frame <- base::sys.nframe()
[08:26:49.767]     ...future.conditions <- base::list()
[08:26:49.767]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:49.767]     if (FALSE) {
[08:26:49.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:49.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:49.767]     }
[08:26:49.767]     ...future.result <- base::tryCatch({
[08:26:49.767]         base::withCallingHandlers({
[08:26:49.767]             ...future.value <- base::withVisible(base::local({
[08:26:49.767]                 ...future.makeSendCondition <- base::local({
[08:26:49.767]                   sendCondition <- NULL
[08:26:49.767]                   function(frame = 1L) {
[08:26:49.767]                     if (is.function(sendCondition)) 
[08:26:49.767]                       return(sendCondition)
[08:26:49.767]                     ns <- getNamespace("parallel")
[08:26:49.767]                     if (exists("sendData", mode = "function", 
[08:26:49.767]                       envir = ns)) {
[08:26:49.767]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:49.767]                         envir = ns)
[08:26:49.767]                       envir <- sys.frame(frame)
[08:26:49.767]                       master <- NULL
[08:26:49.767]                       while (!identical(envir, .GlobalEnv) && 
[08:26:49.767]                         !identical(envir, emptyenv())) {
[08:26:49.767]                         if (exists("master", mode = "list", envir = envir, 
[08:26:49.767]                           inherits = FALSE)) {
[08:26:49.767]                           master <- get("master", mode = "list", 
[08:26:49.767]                             envir = envir, inherits = FALSE)
[08:26:49.767]                           if (inherits(master, c("SOCKnode", 
[08:26:49.767]                             "SOCK0node"))) {
[08:26:49.767]                             sendCondition <<- function(cond) {
[08:26:49.767]                               data <- list(type = "VALUE", value = cond, 
[08:26:49.767]                                 success = TRUE)
[08:26:49.767]                               parallel_sendData(master, data)
[08:26:49.767]                             }
[08:26:49.767]                             return(sendCondition)
[08:26:49.767]                           }
[08:26:49.767]                         }
[08:26:49.767]                         frame <- frame + 1L
[08:26:49.767]                         envir <- sys.frame(frame)
[08:26:49.767]                       }
[08:26:49.767]                     }
[08:26:49.767]                     sendCondition <<- function(cond) NULL
[08:26:49.767]                   }
[08:26:49.767]                 })
[08:26:49.767]                 withCallingHandlers({
[08:26:49.767]                   {
[08:26:49.767]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:49.767]                     if (!identical(...future.globals.maxSize.org, 
[08:26:49.767]                       ...future.globals.maxSize)) {
[08:26:49.767]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:49.767]                       on.exit(options(oopts), add = TRUE)
[08:26:49.767]                     }
[08:26:49.767]                     {
[08:26:49.767]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:49.767]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:49.767]                         USE.NAMES = FALSE)
[08:26:49.767]                       do.call(mapply, args = args)
[08:26:49.767]                     }
[08:26:49.767]                   }
[08:26:49.767]                 }, immediateCondition = function(cond) {
[08:26:49.767]                   sendCondition <- ...future.makeSendCondition()
[08:26:49.767]                   sendCondition(cond)
[08:26:49.767]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.767]                   {
[08:26:49.767]                     inherits <- base::inherits
[08:26:49.767]                     invokeRestart <- base::invokeRestart
[08:26:49.767]                     is.null <- base::is.null
[08:26:49.767]                     muffled <- FALSE
[08:26:49.767]                     if (inherits(cond, "message")) {
[08:26:49.767]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:49.767]                       if (muffled) 
[08:26:49.767]                         invokeRestart("muffleMessage")
[08:26:49.767]                     }
[08:26:49.767]                     else if (inherits(cond, "warning")) {
[08:26:49.767]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:49.767]                       if (muffled) 
[08:26:49.767]                         invokeRestart("muffleWarning")
[08:26:49.767]                     }
[08:26:49.767]                     else if (inherits(cond, "condition")) {
[08:26:49.767]                       if (!is.null(pattern)) {
[08:26:49.767]                         computeRestarts <- base::computeRestarts
[08:26:49.767]                         grepl <- base::grepl
[08:26:49.767]                         restarts <- computeRestarts(cond)
[08:26:49.767]                         for (restart in restarts) {
[08:26:49.767]                           name <- restart$name
[08:26:49.767]                           if (is.null(name)) 
[08:26:49.767]                             next
[08:26:49.767]                           if (!grepl(pattern, name)) 
[08:26:49.767]                             next
[08:26:49.767]                           invokeRestart(restart)
[08:26:49.767]                           muffled <- TRUE
[08:26:49.767]                           break
[08:26:49.767]                         }
[08:26:49.767]                       }
[08:26:49.767]                     }
[08:26:49.767]                     invisible(muffled)
[08:26:49.767]                   }
[08:26:49.767]                   muffleCondition(cond)
[08:26:49.767]                 })
[08:26:49.767]             }))
[08:26:49.767]             future::FutureResult(value = ...future.value$value, 
[08:26:49.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:49.767]                   ...future.rng), globalenv = if (FALSE) 
[08:26:49.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:49.767]                     ...future.globalenv.names))
[08:26:49.767]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:49.767]         }, condition = base::local({
[08:26:49.767]             c <- base::c
[08:26:49.767]             inherits <- base::inherits
[08:26:49.767]             invokeRestart <- base::invokeRestart
[08:26:49.767]             length <- base::length
[08:26:49.767]             list <- base::list
[08:26:49.767]             seq.int <- base::seq.int
[08:26:49.767]             signalCondition <- base::signalCondition
[08:26:49.767]             sys.calls <- base::sys.calls
[08:26:49.767]             `[[` <- base::`[[`
[08:26:49.767]             `+` <- base::`+`
[08:26:49.767]             `<<-` <- base::`<<-`
[08:26:49.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:49.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:49.767]                   3L)]
[08:26:49.767]             }
[08:26:49.767]             function(cond) {
[08:26:49.767]                 is_error <- inherits(cond, "error")
[08:26:49.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:49.767]                   NULL)
[08:26:49.767]                 if (is_error) {
[08:26:49.767]                   sessionInformation <- function() {
[08:26:49.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:49.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:49.767]                       search = base::search(), system = base::Sys.info())
[08:26:49.767]                   }
[08:26:49.767]                   ...future.conditions[[length(...future.conditions) + 
[08:26:49.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:49.767]                     cond$call), session = sessionInformation(), 
[08:26:49.767]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:49.767]                   signalCondition(cond)
[08:26:49.767]                 }
[08:26:49.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:49.767]                 "immediateCondition"))) {
[08:26:49.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:49.767]                   ...future.conditions[[length(...future.conditions) + 
[08:26:49.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:49.767]                   if (TRUE && !signal) {
[08:26:49.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.767]                     {
[08:26:49.767]                       inherits <- base::inherits
[08:26:49.767]                       invokeRestart <- base::invokeRestart
[08:26:49.767]                       is.null <- base::is.null
[08:26:49.767]                       muffled <- FALSE
[08:26:49.767]                       if (inherits(cond, "message")) {
[08:26:49.767]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:49.767]                         if (muffled) 
[08:26:49.767]                           invokeRestart("muffleMessage")
[08:26:49.767]                       }
[08:26:49.767]                       else if (inherits(cond, "warning")) {
[08:26:49.767]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:49.767]                         if (muffled) 
[08:26:49.767]                           invokeRestart("muffleWarning")
[08:26:49.767]                       }
[08:26:49.767]                       else if (inherits(cond, "condition")) {
[08:26:49.767]                         if (!is.null(pattern)) {
[08:26:49.767]                           computeRestarts <- base::computeRestarts
[08:26:49.767]                           grepl <- base::grepl
[08:26:49.767]                           restarts <- computeRestarts(cond)
[08:26:49.767]                           for (restart in restarts) {
[08:26:49.767]                             name <- restart$name
[08:26:49.767]                             if (is.null(name)) 
[08:26:49.767]                               next
[08:26:49.767]                             if (!grepl(pattern, name)) 
[08:26:49.767]                               next
[08:26:49.767]                             invokeRestart(restart)
[08:26:49.767]                             muffled <- TRUE
[08:26:49.767]                             break
[08:26:49.767]                           }
[08:26:49.767]                         }
[08:26:49.767]                       }
[08:26:49.767]                       invisible(muffled)
[08:26:49.767]                     }
[08:26:49.767]                     muffleCondition(cond, pattern = "^muffle")
[08:26:49.767]                   }
[08:26:49.767]                 }
[08:26:49.767]                 else {
[08:26:49.767]                   if (TRUE) {
[08:26:49.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.767]                     {
[08:26:49.767]                       inherits <- base::inherits
[08:26:49.767]                       invokeRestart <- base::invokeRestart
[08:26:49.767]                       is.null <- base::is.null
[08:26:49.767]                       muffled <- FALSE
[08:26:49.767]                       if (inherits(cond, "message")) {
[08:26:49.767]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:49.767]                         if (muffled) 
[08:26:49.767]                           invokeRestart("muffleMessage")
[08:26:49.767]                       }
[08:26:49.767]                       else if (inherits(cond, "warning")) {
[08:26:49.767]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:49.767]                         if (muffled) 
[08:26:49.767]                           invokeRestart("muffleWarning")
[08:26:49.767]                       }
[08:26:49.767]                       else if (inherits(cond, "condition")) {
[08:26:49.767]                         if (!is.null(pattern)) {
[08:26:49.767]                           computeRestarts <- base::computeRestarts
[08:26:49.767]                           grepl <- base::grepl
[08:26:49.767]                           restarts <- computeRestarts(cond)
[08:26:49.767]                           for (restart in restarts) {
[08:26:49.767]                             name <- restart$name
[08:26:49.767]                             if (is.null(name)) 
[08:26:49.767]                               next
[08:26:49.767]                             if (!grepl(pattern, name)) 
[08:26:49.767]                               next
[08:26:49.767]                             invokeRestart(restart)
[08:26:49.767]                             muffled <- TRUE
[08:26:49.767]                             break
[08:26:49.767]                           }
[08:26:49.767]                         }
[08:26:49.767]                       }
[08:26:49.767]                       invisible(muffled)
[08:26:49.767]                     }
[08:26:49.767]                     muffleCondition(cond, pattern = "^muffle")
[08:26:49.767]                   }
[08:26:49.767]                 }
[08:26:49.767]             }
[08:26:49.767]         }))
[08:26:49.767]     }, error = function(ex) {
[08:26:49.767]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:49.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:49.767]                 ...future.rng), started = ...future.startTime, 
[08:26:49.767]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:49.767]             version = "1.8"), class = "FutureResult")
[08:26:49.767]     }, finally = {
[08:26:49.767]         if (!identical(...future.workdir, getwd())) 
[08:26:49.767]             setwd(...future.workdir)
[08:26:49.767]         {
[08:26:49.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:49.767]                 ...future.oldOptions$nwarnings <- NULL
[08:26:49.767]             }
[08:26:49.767]             base::options(...future.oldOptions)
[08:26:49.767]             if (.Platform$OS.type == "windows") {
[08:26:49.767]                 old_names <- names(...future.oldEnvVars)
[08:26:49.767]                 envs <- base::Sys.getenv()
[08:26:49.767]                 names <- names(envs)
[08:26:49.767]                 common <- intersect(names, old_names)
[08:26:49.767]                 added <- setdiff(names, old_names)
[08:26:49.767]                 removed <- setdiff(old_names, names)
[08:26:49.767]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:49.767]                   envs[common]]
[08:26:49.767]                 NAMES <- toupper(changed)
[08:26:49.767]                 args <- list()
[08:26:49.767]                 for (kk in seq_along(NAMES)) {
[08:26:49.767]                   name <- changed[[kk]]
[08:26:49.767]                   NAME <- NAMES[[kk]]
[08:26:49.767]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.767]                     next
[08:26:49.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:49.767]                 }
[08:26:49.767]                 NAMES <- toupper(added)
[08:26:49.767]                 for (kk in seq_along(NAMES)) {
[08:26:49.767]                   name <- added[[kk]]
[08:26:49.767]                   NAME <- NAMES[[kk]]
[08:26:49.767]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.767]                     next
[08:26:49.767]                   args[[name]] <- ""
[08:26:49.767]                 }
[08:26:49.767]                 NAMES <- toupper(removed)
[08:26:49.767]                 for (kk in seq_along(NAMES)) {
[08:26:49.767]                   name <- removed[[kk]]
[08:26:49.767]                   NAME <- NAMES[[kk]]
[08:26:49.767]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.767]                     next
[08:26:49.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:49.767]                 }
[08:26:49.767]                 if (length(args) > 0) 
[08:26:49.767]                   base::do.call(base::Sys.setenv, args = args)
[08:26:49.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:49.767]             }
[08:26:49.767]             else {
[08:26:49.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:49.767]             }
[08:26:49.767]             {
[08:26:49.767]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:49.767]                   0L) {
[08:26:49.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:49.767]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:49.767]                   base::options(opts)
[08:26:49.767]                 }
[08:26:49.767]                 {
[08:26:49.767]                   {
[08:26:49.767]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:49.767]                     NULL
[08:26:49.767]                   }
[08:26:49.767]                   options(future.plan = NULL)
[08:26:49.767]                   if (is.na(NA_character_)) 
[08:26:49.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:49.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:49.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:49.767]                     .init = FALSE)
[08:26:49.767]                 }
[08:26:49.767]             }
[08:26:49.767]         }
[08:26:49.767]     })
[08:26:49.767]     if (FALSE) {
[08:26:49.767]         base::sink(type = "output", split = FALSE)
[08:26:49.767]         if (NA) {
[08:26:49.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:49.767]         }
[08:26:49.767]         else {
[08:26:49.767]             ...future.result["stdout"] <- base::list(NULL)
[08:26:49.767]         }
[08:26:49.767]         base::close(...future.stdout)
[08:26:49.767]         ...future.stdout <- NULL
[08:26:49.767]     }
[08:26:49.767]     ...future.result$conditions <- ...future.conditions
[08:26:49.767]     ...future.result$finished <- base::Sys.time()
[08:26:49.767]     ...future.result
[08:26:49.767] }
[08:26:49.771] Exporting 5 global objects (1.63 KiB) to cluster node #1 ...
[08:26:49.771] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ...
[08:26:49.771] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #1 ... DONE
[08:26:49.771] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ...
[08:26:49.772] Exporting ‘MoreArgs’ (27 bytes) to cluster node #1 ... DONE
[08:26:49.772] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[08:26:49.772] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[08:26:49.773] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:26:49.773] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:26:49.773] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ...
[08:26:49.773] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #1 ... DONE
[08:26:49.774] Exporting 5 global objects (1.63 KiB) to cluster node #1 ... DONE
[08:26:49.774] MultisessionFuture started
[08:26:49.774] - Launch lazy future ... done
[08:26:49.774] run() for ‘MultisessionFuture’ ... done
[08:26:49.774] Created future:
[08:26:49.774] MultisessionFuture:
[08:26:49.774] Label: ‘future_mapply-1’
[08:26:49.774] Expression:
[08:26:49.774] {
[08:26:49.774]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:49.774]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:49.774]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:49.774]         on.exit(options(oopts), add = TRUE)
[08:26:49.774]     }
[08:26:49.774]     {
[08:26:49.774]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:49.774]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:49.774]         do.call(mapply, args = args)
[08:26:49.774]     }
[08:26:49.774] }
[08:26:49.774] Lazy evaluation: FALSE
[08:26:49.774] Asynchronous evaluation: TRUE
[08:26:49.774] Local evaluation: TRUE
[08:26:49.774] Environment: R_GlobalEnv
[08:26:49.774] Capture standard output: NA
[08:26:49.774] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:49.774] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:49.774] Packages: <none>
[08:26:49.774] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:49.774] Resolved: FALSE
[08:26:49.774] Value: <not collected>
[08:26:49.774] Conditions captured: <none>
[08:26:49.774] Early signaling: FALSE
[08:26:49.774] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:49.774] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:49.786] Chunk #1 of 2 ... DONE
[08:26:49.786] Chunk #2 of 2 ...
[08:26:49.786]  - Finding globals in '...' for chunk #2 ...
[08:26:49.787] getGlobalsAndPackages() ...
[08:26:49.787] Searching for globals...
[08:26:49.787] 
[08:26:49.787] Searching for globals ... DONE
[08:26:49.787] - globals: [0] <none>
[08:26:49.787] getGlobalsAndPackages() ... DONE
[08:26:49.787]    + additional globals found: [n=0] 
[08:26:49.788]    + additional namespaces needed: [n=0] 
[08:26:49.788]  - Finding globals in '...' for chunk #2 ... DONE
[08:26:49.788]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[08:26:49.788]  - seeds: <none>
[08:26:49.788]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.788] getGlobalsAndPackages() ...
[08:26:49.788] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.788] Resolving globals: FALSE
[08:26:49.789] The total size of the 5 globals is 1.19 KiB (1218 bytes)
[08:26:49.789] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 1.19 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (1.04 KiB of class ‘function’), ‘...future.elements_ii’ (71 bytes of class ‘list’) and ‘MoreArgs’ (27 bytes of class ‘NULL’)
[08:26:49.789] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:26:49.789] 
[08:26:49.790] getGlobalsAndPackages() ... DONE
[08:26:49.790] run() for ‘Future’ ...
[08:26:49.790] - state: ‘created’
[08:26:49.790] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:26:49.805] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:49.805] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:26:49.805]   - Field: ‘node’
[08:26:49.805]   - Field: ‘label’
[08:26:49.806]   - Field: ‘local’
[08:26:49.806]   - Field: ‘owner’
[08:26:49.806]   - Field: ‘envir’
[08:26:49.806]   - Field: ‘workers’
[08:26:49.806]   - Field: ‘packages’
[08:26:49.806]   - Field: ‘gc’
[08:26:49.806]   - Field: ‘conditions’
[08:26:49.806]   - Field: ‘persistent’
[08:26:49.806]   - Field: ‘expr’
[08:26:49.806]   - Field: ‘uuid’
[08:26:49.806]   - Field: ‘seed’
[08:26:49.807]   - Field: ‘version’
[08:26:49.807]   - Field: ‘result’
[08:26:49.807]   - Field: ‘asynchronous’
[08:26:49.807]   - Field: ‘calls’
[08:26:49.807]   - Field: ‘globals’
[08:26:49.807]   - Field: ‘stdout’
[08:26:49.807]   - Field: ‘earlySignal’
[08:26:49.807]   - Field: ‘lazy’
[08:26:49.807]   - Field: ‘state’
[08:26:49.807] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:26:49.807] - Launch lazy future ...
[08:26:49.808] Packages needed by the future expression (n = 0): <none>
[08:26:49.808] Packages needed by future strategies (n = 0): <none>
[08:26:49.808] {
[08:26:49.808]     {
[08:26:49.808]         {
[08:26:49.808]             ...future.startTime <- base::Sys.time()
[08:26:49.808]             {
[08:26:49.808]                 {
[08:26:49.808]                   {
[08:26:49.808]                     {
[08:26:49.808]                       base::local({
[08:26:49.808]                         has_future <- base::requireNamespace("future", 
[08:26:49.808]                           quietly = TRUE)
[08:26:49.808]                         if (has_future) {
[08:26:49.808]                           ns <- base::getNamespace("future")
[08:26:49.808]                           version <- ns[[".package"]][["version"]]
[08:26:49.808]                           if (is.null(version)) 
[08:26:49.808]                             version <- utils::packageVersion("future")
[08:26:49.808]                         }
[08:26:49.808]                         else {
[08:26:49.808]                           version <- NULL
[08:26:49.808]                         }
[08:26:49.808]                         if (!has_future || version < "1.8.0") {
[08:26:49.808]                           info <- base::c(r_version = base::gsub("R version ", 
[08:26:49.808]                             "", base::R.version$version.string), 
[08:26:49.808]                             platform = base::sprintf("%s (%s-bit)", 
[08:26:49.808]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:26:49.808]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:26:49.808]                               "release", "version")], collapse = " "), 
[08:26:49.808]                             hostname = base::Sys.info()[["nodename"]])
[08:26:49.808]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:26:49.808]                             info)
[08:26:49.808]                           info <- base::paste(info, collapse = "; ")
[08:26:49.808]                           if (!has_future) {
[08:26:49.808]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:26:49.808]                               info)
[08:26:49.808]                           }
[08:26:49.808]                           else {
[08:26:49.808]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:26:49.808]                               info, version)
[08:26:49.808]                           }
[08:26:49.808]                           base::stop(msg)
[08:26:49.808]                         }
[08:26:49.808]                       })
[08:26:49.808]                     }
[08:26:49.808]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:26:49.808]                     base::options(mc.cores = 1L)
[08:26:49.808]                   }
[08:26:49.808]                   ...future.strategy.old <- future::plan("list")
[08:26:49.808]                   options(future.plan = NULL)
[08:26:49.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:26:49.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:26:49.808]                 }
[08:26:49.808]                 ...future.workdir <- getwd()
[08:26:49.808]             }
[08:26:49.808]             ...future.oldOptions <- base::as.list(base::.Options)
[08:26:49.808]             ...future.oldEnvVars <- base::Sys.getenv()
[08:26:49.808]         }
[08:26:49.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:26:49.808]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[08:26:49.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:26:49.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:26:49.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:26:49.808]             future.stdout.windows.reencode = NULL, width = 80L)
[08:26:49.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:26:49.808]             base::names(...future.oldOptions))
[08:26:49.808]     }
[08:26:49.808]     if (TRUE) {
[08:26:49.808]     }
[08:26:49.808]     else {
[08:26:49.808]         if (NA) {
[08:26:49.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:26:49.808]                 open = "w")
[08:26:49.808]         }
[08:26:49.808]         else {
[08:26:49.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:26:49.808]                 windows = "NUL", "/dev/null"), open = "w")
[08:26:49.808]         }
[08:26:49.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:26:49.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:26:49.808]             base::sink(type = "output", split = FALSE)
[08:26:49.808]             base::close(...future.stdout)
[08:26:49.808]         }, add = TRUE)
[08:26:49.808]     }
[08:26:49.808]     ...future.frame <- base::sys.nframe()
[08:26:49.808]     ...future.conditions <- base::list()
[08:26:49.808]     ...future.rng <- base::globalenv()$.Random.seed
[08:26:49.808]     if (FALSE) {
[08:26:49.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:26:49.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:26:49.808]     }
[08:26:49.808]     ...future.result <- base::tryCatch({
[08:26:49.808]         base::withCallingHandlers({
[08:26:49.808]             ...future.value <- base::withVisible(base::local({
[08:26:49.808]                 ...future.makeSendCondition <- base::local({
[08:26:49.808]                   sendCondition <- NULL
[08:26:49.808]                   function(frame = 1L) {
[08:26:49.808]                     if (is.function(sendCondition)) 
[08:26:49.808]                       return(sendCondition)
[08:26:49.808]                     ns <- getNamespace("parallel")
[08:26:49.808]                     if (exists("sendData", mode = "function", 
[08:26:49.808]                       envir = ns)) {
[08:26:49.808]                       parallel_sendData <- get("sendData", mode = "function", 
[08:26:49.808]                         envir = ns)
[08:26:49.808]                       envir <- sys.frame(frame)
[08:26:49.808]                       master <- NULL
[08:26:49.808]                       while (!identical(envir, .GlobalEnv) && 
[08:26:49.808]                         !identical(envir, emptyenv())) {
[08:26:49.808]                         if (exists("master", mode = "list", envir = envir, 
[08:26:49.808]                           inherits = FALSE)) {
[08:26:49.808]                           master <- get("master", mode = "list", 
[08:26:49.808]                             envir = envir, inherits = FALSE)
[08:26:49.808]                           if (inherits(master, c("SOCKnode", 
[08:26:49.808]                             "SOCK0node"))) {
[08:26:49.808]                             sendCondition <<- function(cond) {
[08:26:49.808]                               data <- list(type = "VALUE", value = cond, 
[08:26:49.808]                                 success = TRUE)
[08:26:49.808]                               parallel_sendData(master, data)
[08:26:49.808]                             }
[08:26:49.808]                             return(sendCondition)
[08:26:49.808]                           }
[08:26:49.808]                         }
[08:26:49.808]                         frame <- frame + 1L
[08:26:49.808]                         envir <- sys.frame(frame)
[08:26:49.808]                       }
[08:26:49.808]                     }
[08:26:49.808]                     sendCondition <<- function(cond) NULL
[08:26:49.808]                   }
[08:26:49.808]                 })
[08:26:49.808]                 withCallingHandlers({
[08:26:49.808]                   {
[08:26:49.808]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:49.808]                     if (!identical(...future.globals.maxSize.org, 
[08:26:49.808]                       ...future.globals.maxSize)) {
[08:26:49.808]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:49.808]                       on.exit(options(oopts), add = TRUE)
[08:26:49.808]                     }
[08:26:49.808]                     {
[08:26:49.808]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:49.808]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[08:26:49.808]                         USE.NAMES = FALSE)
[08:26:49.808]                       do.call(mapply, args = args)
[08:26:49.808]                     }
[08:26:49.808]                   }
[08:26:49.808]                 }, immediateCondition = function(cond) {
[08:26:49.808]                   sendCondition <- ...future.makeSendCondition()
[08:26:49.808]                   sendCondition(cond)
[08:26:49.808]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.808]                   {
[08:26:49.808]                     inherits <- base::inherits
[08:26:49.808]                     invokeRestart <- base::invokeRestart
[08:26:49.808]                     is.null <- base::is.null
[08:26:49.808]                     muffled <- FALSE
[08:26:49.808]                     if (inherits(cond, "message")) {
[08:26:49.808]                       muffled <- grepl(pattern, "muffleMessage")
[08:26:49.808]                       if (muffled) 
[08:26:49.808]                         invokeRestart("muffleMessage")
[08:26:49.808]                     }
[08:26:49.808]                     else if (inherits(cond, "warning")) {
[08:26:49.808]                       muffled <- grepl(pattern, "muffleWarning")
[08:26:49.808]                       if (muffled) 
[08:26:49.808]                         invokeRestart("muffleWarning")
[08:26:49.808]                     }
[08:26:49.808]                     else if (inherits(cond, "condition")) {
[08:26:49.808]                       if (!is.null(pattern)) {
[08:26:49.808]                         computeRestarts <- base::computeRestarts
[08:26:49.808]                         grepl <- base::grepl
[08:26:49.808]                         restarts <- computeRestarts(cond)
[08:26:49.808]                         for (restart in restarts) {
[08:26:49.808]                           name <- restart$name
[08:26:49.808]                           if (is.null(name)) 
[08:26:49.808]                             next
[08:26:49.808]                           if (!grepl(pattern, name)) 
[08:26:49.808]                             next
[08:26:49.808]                           invokeRestart(restart)
[08:26:49.808]                           muffled <- TRUE
[08:26:49.808]                           break
[08:26:49.808]                         }
[08:26:49.808]                       }
[08:26:49.808]                     }
[08:26:49.808]                     invisible(muffled)
[08:26:49.808]                   }
[08:26:49.808]                   muffleCondition(cond)
[08:26:49.808]                 })
[08:26:49.808]             }))
[08:26:49.808]             future::FutureResult(value = ...future.value$value, 
[08:26:49.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:49.808]                   ...future.rng), globalenv = if (FALSE) 
[08:26:49.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:26:49.808]                     ...future.globalenv.names))
[08:26:49.808]                 else NULL, started = ...future.startTime, version = "1.8")
[08:26:49.808]         }, condition = base::local({
[08:26:49.808]             c <- base::c
[08:26:49.808]             inherits <- base::inherits
[08:26:49.808]             invokeRestart <- base::invokeRestart
[08:26:49.808]             length <- base::length
[08:26:49.808]             list <- base::list
[08:26:49.808]             seq.int <- base::seq.int
[08:26:49.808]             signalCondition <- base::signalCondition
[08:26:49.808]             sys.calls <- base::sys.calls
[08:26:49.808]             `[[` <- base::`[[`
[08:26:49.808]             `+` <- base::`+`
[08:26:49.808]             `<<-` <- base::`<<-`
[08:26:49.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:26:49.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:26:49.808]                   3L)]
[08:26:49.808]             }
[08:26:49.808]             function(cond) {
[08:26:49.808]                 is_error <- inherits(cond, "error")
[08:26:49.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:26:49.808]                   NULL)
[08:26:49.808]                 if (is_error) {
[08:26:49.808]                   sessionInformation <- function() {
[08:26:49.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:26:49.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:26:49.808]                       search = base::search(), system = base::Sys.info())
[08:26:49.808]                   }
[08:26:49.808]                   ...future.conditions[[length(...future.conditions) + 
[08:26:49.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:26:49.808]                     cond$call), session = sessionInformation(), 
[08:26:49.808]                     timestamp = base::Sys.time(), signaled = 0L)
[08:26:49.808]                   signalCondition(cond)
[08:26:49.808]                 }
[08:26:49.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:26:49.808]                 "immediateCondition"))) {
[08:26:49.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:26:49.808]                   ...future.conditions[[length(...future.conditions) + 
[08:26:49.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:26:49.808]                   if (TRUE && !signal) {
[08:26:49.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.808]                     {
[08:26:49.808]                       inherits <- base::inherits
[08:26:49.808]                       invokeRestart <- base::invokeRestart
[08:26:49.808]                       is.null <- base::is.null
[08:26:49.808]                       muffled <- FALSE
[08:26:49.808]                       if (inherits(cond, "message")) {
[08:26:49.808]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:49.808]                         if (muffled) 
[08:26:49.808]                           invokeRestart("muffleMessage")
[08:26:49.808]                       }
[08:26:49.808]                       else if (inherits(cond, "warning")) {
[08:26:49.808]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:49.808]                         if (muffled) 
[08:26:49.808]                           invokeRestart("muffleWarning")
[08:26:49.808]                       }
[08:26:49.808]                       else if (inherits(cond, "condition")) {
[08:26:49.808]                         if (!is.null(pattern)) {
[08:26:49.808]                           computeRestarts <- base::computeRestarts
[08:26:49.808]                           grepl <- base::grepl
[08:26:49.808]                           restarts <- computeRestarts(cond)
[08:26:49.808]                           for (restart in restarts) {
[08:26:49.808]                             name <- restart$name
[08:26:49.808]                             if (is.null(name)) 
[08:26:49.808]                               next
[08:26:49.808]                             if (!grepl(pattern, name)) 
[08:26:49.808]                               next
[08:26:49.808]                             invokeRestart(restart)
[08:26:49.808]                             muffled <- TRUE
[08:26:49.808]                             break
[08:26:49.808]                           }
[08:26:49.808]                         }
[08:26:49.808]                       }
[08:26:49.808]                       invisible(muffled)
[08:26:49.808]                     }
[08:26:49.808]                     muffleCondition(cond, pattern = "^muffle")
[08:26:49.808]                   }
[08:26:49.808]                 }
[08:26:49.808]                 else {
[08:26:49.808]                   if (TRUE) {
[08:26:49.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:26:49.808]                     {
[08:26:49.808]                       inherits <- base::inherits
[08:26:49.808]                       invokeRestart <- base::invokeRestart
[08:26:49.808]                       is.null <- base::is.null
[08:26:49.808]                       muffled <- FALSE
[08:26:49.808]                       if (inherits(cond, "message")) {
[08:26:49.808]                         muffled <- grepl(pattern, "muffleMessage")
[08:26:49.808]                         if (muffled) 
[08:26:49.808]                           invokeRestart("muffleMessage")
[08:26:49.808]                       }
[08:26:49.808]                       else if (inherits(cond, "warning")) {
[08:26:49.808]                         muffled <- grepl(pattern, "muffleWarning")
[08:26:49.808]                         if (muffled) 
[08:26:49.808]                           invokeRestart("muffleWarning")
[08:26:49.808]                       }
[08:26:49.808]                       else if (inherits(cond, "condition")) {
[08:26:49.808]                         if (!is.null(pattern)) {
[08:26:49.808]                           computeRestarts <- base::computeRestarts
[08:26:49.808]                           grepl <- base::grepl
[08:26:49.808]                           restarts <- computeRestarts(cond)
[08:26:49.808]                           for (restart in restarts) {
[08:26:49.808]                             name <- restart$name
[08:26:49.808]                             if (is.null(name)) 
[08:26:49.808]                               next
[08:26:49.808]                             if (!grepl(pattern, name)) 
[08:26:49.808]                               next
[08:26:49.808]                             invokeRestart(restart)
[08:26:49.808]                             muffled <- TRUE
[08:26:49.808]                             break
[08:26:49.808]                           }
[08:26:49.808]                         }
[08:26:49.808]                       }
[08:26:49.808]                       invisible(muffled)
[08:26:49.808]                     }
[08:26:49.808]                     muffleCondition(cond, pattern = "^muffle")
[08:26:49.808]                   }
[08:26:49.808]                 }
[08:26:49.808]             }
[08:26:49.808]         }))
[08:26:49.808]     }, error = function(ex) {
[08:26:49.808]         base::structure(base::list(value = NULL, visible = NULL, 
[08:26:49.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:26:49.808]                 ...future.rng), started = ...future.startTime, 
[08:26:49.808]             finished = Sys.time(), session_uuid = NA_character_, 
[08:26:49.808]             version = "1.8"), class = "FutureResult")
[08:26:49.808]     }, finally = {
[08:26:49.808]         if (!identical(...future.workdir, getwd())) 
[08:26:49.808]             setwd(...future.workdir)
[08:26:49.808]         {
[08:26:49.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:26:49.808]                 ...future.oldOptions$nwarnings <- NULL
[08:26:49.808]             }
[08:26:49.808]             base::options(...future.oldOptions)
[08:26:49.808]             if (.Platform$OS.type == "windows") {
[08:26:49.808]                 old_names <- names(...future.oldEnvVars)
[08:26:49.808]                 envs <- base::Sys.getenv()
[08:26:49.808]                 names <- names(envs)
[08:26:49.808]                 common <- intersect(names, old_names)
[08:26:49.808]                 added <- setdiff(names, old_names)
[08:26:49.808]                 removed <- setdiff(old_names, names)
[08:26:49.808]                 changed <- common[...future.oldEnvVars[common] != 
[08:26:49.808]                   envs[common]]
[08:26:49.808]                 NAMES <- toupper(changed)
[08:26:49.808]                 args <- list()
[08:26:49.808]                 for (kk in seq_along(NAMES)) {
[08:26:49.808]                   name <- changed[[kk]]
[08:26:49.808]                   NAME <- NAMES[[kk]]
[08:26:49.808]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.808]                     next
[08:26:49.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:49.808]                 }
[08:26:49.808]                 NAMES <- toupper(added)
[08:26:49.808]                 for (kk in seq_along(NAMES)) {
[08:26:49.808]                   name <- added[[kk]]
[08:26:49.808]                   NAME <- NAMES[[kk]]
[08:26:49.808]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.808]                     next
[08:26:49.808]                   args[[name]] <- ""
[08:26:49.808]                 }
[08:26:49.808]                 NAMES <- toupper(removed)
[08:26:49.808]                 for (kk in seq_along(NAMES)) {
[08:26:49.808]                   name <- removed[[kk]]
[08:26:49.808]                   NAME <- NAMES[[kk]]
[08:26:49.808]                   if (name != NAME && is.element(NAME, old_names)) 
[08:26:49.808]                     next
[08:26:49.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:26:49.808]                 }
[08:26:49.808]                 if (length(args) > 0) 
[08:26:49.808]                   base::do.call(base::Sys.setenv, args = args)
[08:26:49.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:26:49.808]             }
[08:26:49.808]             else {
[08:26:49.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:26:49.808]             }
[08:26:49.808]             {
[08:26:49.808]                 if (base::length(...future.futureOptionsAdded) > 
[08:26:49.808]                   0L) {
[08:26:49.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:26:49.808]                   base::names(opts) <- ...future.futureOptionsAdded
[08:26:49.808]                   base::options(opts)
[08:26:49.808]                 }
[08:26:49.808]                 {
[08:26:49.808]                   {
[08:26:49.808]                     base::options(mc.cores = ...future.mc.cores.old)
[08:26:49.808]                     NULL
[08:26:49.808]                   }
[08:26:49.808]                   options(future.plan = NULL)
[08:26:49.808]                   if (is.na(NA_character_)) 
[08:26:49.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:26:49.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:26:49.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:26:49.808]                     .init = FALSE)
[08:26:49.808]                 }
[08:26:49.808]             }
[08:26:49.808]         }
[08:26:49.808]     })
[08:26:49.808]     if (FALSE) {
[08:26:49.808]         base::sink(type = "output", split = FALSE)
[08:26:49.808]         if (NA) {
[08:26:49.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:26:49.808]         }
[08:26:49.808]         else {
[08:26:49.808]             ...future.result["stdout"] <- base::list(NULL)
[08:26:49.808]         }
[08:26:49.808]         base::close(...future.stdout)
[08:26:49.808]         ...future.stdout <- NULL
[08:26:49.808]     }
[08:26:49.808]     ...future.result$conditions <- ...future.conditions
[08:26:49.808]     ...future.result$finished <- base::Sys.time()
[08:26:49.808]     ...future.result
[08:26:49.808] }
[08:26:49.811] Exporting 5 global objects (1.63 KiB) to cluster node #2 ...
[08:26:49.812] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ...
[08:26:49.812] Exporting ‘...future.FUN’ (1.04 KiB) to cluster node #2 ... DONE
[08:26:49.812] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ...
[08:26:49.813] Exporting ‘MoreArgs’ (27 bytes) to cluster node #2 ... DONE
[08:26:49.813] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[08:26:49.813] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[08:26:49.813] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:26:49.814] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:26:49.814] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ...
[08:26:49.814] Exporting ‘...future.globals.maxSize’ (27 bytes) to cluster node #2 ... DONE
[08:26:49.814] Exporting 5 global objects (1.63 KiB) to cluster node #2 ... DONE
[08:26:49.815] MultisessionFuture started
[08:26:49.815] - Launch lazy future ... done
[08:26:49.815] run() for ‘MultisessionFuture’ ... done
[08:26:49.815] Created future:
[08:26:49.816] MultisessionFuture:
[08:26:49.816] Label: ‘future_mapply-2’
[08:26:49.816] Expression:
[08:26:49.816] {
[08:26:49.816]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:26:49.816]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:26:49.816]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:26:49.816]         on.exit(options(oopts), add = TRUE)
[08:26:49.816]     }
[08:26:49.816]     {
[08:26:49.816]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[08:26:49.816]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[08:26:49.816]         do.call(mapply, args = args)
[08:26:49.816]     }
[08:26:49.816] }
[08:26:49.816] Lazy evaluation: FALSE
[08:26:49.816] Asynchronous evaluation: TRUE
[08:26:49.816] Local evaluation: TRUE
[08:26:49.816] Environment: R_GlobalEnv
[08:26:49.816] Capture standard output: NA
[08:26:49.816] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:26:49.816] Globals: 5 objects totaling 1.19 KiB (function ‘...future.FUN’ of 1.04 KiB, NULL ‘MoreArgs’ of 27 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, NULL ‘...future.globals.maxSize’ of 27 bytes)
[08:26:49.816] Packages: <none>
[08:26:49.816] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:26:49.816] Resolved: FALSE
[08:26:49.816] Value: <not collected>
[08:26:49.816] Conditions captured: <none>
[08:26:49.816] Early signaling: FALSE
[08:26:49.816] Owner process: bd425f1e-86f6-3d8d-d669-b9a80ea6c0a1
[08:26:49.816] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:26:49.827] Chunk #2 of 2 ... DONE
[08:26:49.828] Launching 2 futures (chunks) ... DONE
[08:26:49.828] Resolving 2 futures (chunks) ...
[08:26:49.828] resolve() on list ...
[08:26:49.828]  recursive: 0
[08:26:49.828]  length: 2
[08:26:49.828] 
[08:26:49.871] receiveMessageFromWorker() for ClusterFuture ...
[08:26:49.871] - Validating connection of MultisessionFuture
[08:26:49.871] - received message: FutureResult
[08:26:49.871] - Received FutureResult
[08:26:49.871] - Erased future from FutureRegistry
[08:26:49.872] result() for ClusterFuture ...
[08:26:49.872] - result already collected: FutureResult
[08:26:49.872] result() for ClusterFuture ... done
[08:26:49.872] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:49.872] Future #2
[08:26:49.872] result() for ClusterFuture ...
[08:26:49.872] - result already collected: FutureResult
[08:26:49.872] result() for ClusterFuture ... done
[08:26:49.872] result() for ClusterFuture ...
[08:26:49.872] - result already collected: FutureResult
[08:26:49.872] result() for ClusterFuture ... done
[08:26:49.873] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:26:49.873] - nx: 2
[08:26:49.873] - relay: TRUE
[08:26:49.873] - stdout: TRUE
[08:26:49.873] - signal: TRUE
[08:26:49.873] - resignal: FALSE
[08:26:49.873] - force: TRUE
[08:26:49.873] - relayed: [n=2] FALSE, FALSE
[08:26:49.873] - queued futures: [n=2] FALSE, FALSE
[08:26:49.873]  - until=1
[08:26:49.873]  - relaying element #1
[08:26:49.873] - relayed: [n=2] FALSE, FALSE
[08:26:49.874] - queued futures: [n=2] FALSE, TRUE
[08:26:49.874] signalConditionsASAP(NULL, pos=2) ... done
[08:26:49.874]  length: 1 (resolved future 2)
[08:26:50.325] receiveMessageFromWorker() for ClusterFuture ...
[08:26:50.325] - Validating connection of MultisessionFuture
[08:26:50.325] - received message: FutureResult
[08:26:50.325] - Received FutureResult
[08:26:50.326] - Erased future from FutureRegistry
[08:26:50.326] result() for ClusterFuture ...
[08:26:50.326] - result already collected: FutureResult
[08:26:50.326] result() for ClusterFuture ... done
[08:26:50.326] receiveMessageFromWorker() for ClusterFuture ... done
[08:26:50.326] Future #1
[08:26:50.326] result() for ClusterFuture ...
[08:26:50.326] - result already collected: FutureResult
[08:26:50.326] result() for ClusterFuture ... done
[08:26:50.326] result() for ClusterFuture ...
[08:26:50.326] - result already collected: FutureResult
[08:26:50.327] result() for ClusterFuture ... done
[08:26:50.327] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:26:50.327] - nx: 2
[08:26:50.327] - relay: TRUE
[08:26:50.327] - stdout: TRUE
[08:26:50.327] - signal: TRUE
[08:26:50.327] - resignal: FALSE
[08:26:50.327] - force: TRUE
[08:26:50.327] - relayed: [n=2] FALSE, FALSE
[08:26:50.327] - queued futures: [n=2] FALSE, TRUE
[08:26:50.327]  - until=1
[08:26:50.327]  - relaying element #1
[08:26:50.328] result() for ClusterFuture ...
[08:26:50.328] - result already collected: FutureResult
[08:26:50.328] result() for ClusterFuture ... done
[08:26:50.328] result() for ClusterFuture ...
[08:26:50.328] - result already collected: FutureResult
[08:26:50.328] result() for ClusterFuture ... done
[08:26:50.328] result() for ClusterFuture ...
[08:26:50.328] - result already collected: FutureResult
[08:26:50.328] result() for ClusterFuture ... done
[08:26:50.328] result() for ClusterFuture ...
[08:26:50.328] - result already collected: FutureResult
[08:26:50.328] result() for ClusterFuture ... done
[08:26:50.329] - relayed: [n=2] TRUE, FALSE
[08:26:50.329] - queued futures: [n=2] TRUE, TRUE
[08:26:50.329] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:26:50.329]  length: 0 (resolved future 1)
[08:26:50.329] Relaying remaining futures
[08:26:50.329] signalConditionsASAP(NULL, pos=0) ...
[08:26:50.329] - nx: 2
[08:26:50.329] - relay: TRUE
[08:26:50.329] - stdout: TRUE
[08:26:50.329] - signal: TRUE
[08:26:50.329] - resignal: FALSE
[08:26:50.329] - force: TRUE
[08:26:50.330] - relayed: [n=2] TRUE, FALSE
[08:26:50.330] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:26:50.330]  - relaying element #2
[08:26:50.330] result() for ClusterFuture ...
[08:26:50.330] - result already collected: FutureResult
[08:26:50.330] result() for ClusterFuture ... done
[08:26:50.330] result() for ClusterFuture ...
[08:26:50.330] - result already collected: FutureResult
[08:26:50.330] result() for ClusterFuture ... done
[08:26:50.330] result() for ClusterFuture ...
[08:26:50.330] - result already collected: FutureResult
[08:26:50.331] result() for ClusterFuture ... done
[08:26:50.331] result() for ClusterFuture ...
[08:26:50.331] - result already collected: FutureResult
[08:26:50.331] result() for ClusterFuture ... done
[08:26:50.331] - relayed: [n=2] TRUE, TRUE
[08:26:50.331] - queued futures: [n=2] TRUE, TRUE
[08:26:50.331] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[08:26:50.331] resolve() on list ... DONE
[08:26:50.331] result() for ClusterFuture ...
[08:26:50.331] - result already collected: FutureResult
[08:26:50.331] result() for ClusterFuture ... done
[08:26:50.331] result() for ClusterFuture ...
[08:26:50.332] - result already collected: FutureResult
[08:26:50.332] result() for ClusterFuture ... done
[08:26:50.332] result() for ClusterFuture ...
[08:26:50.332] - result already collected: FutureResult
[08:26:50.332] result() for ClusterFuture ... done
[08:26:50.332] result() for ClusterFuture ...
[08:26:50.332] - result already collected: FutureResult
[08:26:50.332] result() for ClusterFuture ... done
[08:26:50.332]  - Number of value chunks collected: 2
[08:26:50.332] Resolving 2 futures (chunks) ... DONE
[08:26:50.332] Reducing values from 2 chunks ...
[08:26:50.333]  - Number of values collected after concatenation: 2
[08:26:50.333]  - Number of values expected: 2
[08:26:50.333] Reducing values from 2 chunks ... DONE
[08:26:50.333] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[08:26:50.334] plan(): Setting new future strategy stack:
[08:26:50.334] List of future strategies:
[08:26:50.334] 1. FutureStrategy:
[08:26:50.334]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:26:50.334]    - tweaked: FALSE
[08:26:50.334]    - call: future::plan(oplan)
[08:26:50.335] plan(): nbrOfWorkers() = 1
> 
