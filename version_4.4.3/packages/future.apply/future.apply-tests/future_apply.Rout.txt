
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:58:38.189] plan(): Setting new future strategy stack:
[10:58:38.189] List of future strategies:
[10:58:38.189] 1. sequential:
[10:58:38.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.189]    - tweaked: FALSE
[10:58:38.189]    - call: future::plan("sequential")
[10:58:38.203] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:58:38.264] plan(): Setting new future strategy stack:
[10:58:38.265] List of future strategies:
[10:58:38.265] 1. sequential:
[10:58:38.265]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.265]    - tweaked: FALSE
[10:58:38.265]    - call: plan(strategy)
[10:58:38.276] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[10:58:38.277] getGlobalsAndPackagesXApply() ...
[10:58:38.278]  - future.globals: TRUE
[10:58:38.278] getGlobalsAndPackages() ...
[10:58:38.278] Searching for globals...
[10:58:38.317] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:58:38.317] Searching for globals ... DONE
[10:58:38.317] Resolving globals: FALSE
[10:58:38.319] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:58:38.320] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:58:38.320] - globals: [1] ‘FUN’
[10:58:38.320] 
[10:58:38.320] getGlobalsAndPackages() ... DONE
[10:58:38.320]  - globals found/used: [n=1] ‘FUN’
[10:58:38.320]  - needed namespaces: [n=0] 
[10:58:38.320] Finding globals ... DONE
[10:58:38.320]  - use_args: TRUE
[10:58:38.321]  - Getting '...' globals ...
[10:58:38.321] resolve() on list ...
[10:58:38.321]  recursive: 0
[10:58:38.322]  length: 1
[10:58:38.322]  elements: ‘...’
[10:58:38.322]  length: 0 (resolved future 1)
[10:58:38.322] resolve() on list ... DONE
[10:58:38.322]    - '...' content: [n=0] 
[10:58:38.322] List of 1
[10:58:38.322]  $ ...: list()
[10:58:38.322]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.322]  - attr(*, "where")=List of 1
[10:58:38.322]   ..$ ...:<environment: 0x5635bf276100> 
[10:58:38.322]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.322]  - attr(*, "resolved")= logi TRUE
[10:58:38.322]  - attr(*, "total_size")= num NA
[10:58:38.326]  - Getting '...' globals ... DONE
[10:58:38.327] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.327] List of 2
[10:58:38.327]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.327]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.327]  $ ...          : list()
[10:58:38.327]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.327]  - attr(*, "where")=List of 2
[10:58:38.327]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.327]   ..$ ...          :<environment: 0x5635bf276100> 
[10:58:38.327]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.327]  - attr(*, "resolved")= logi FALSE
[10:58:38.327]  - attr(*, "total_size")= num 65963
[10:58:38.329] Packages to be attached in all futures: [n=0] 
[10:58:38.329] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.330] future_lapply() ...
[10:58:38.360] Number of chunks: 1
[10:58:38.360] getGlobalsAndPackagesXApply() ...
[10:58:38.360]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.361]  - use_args: TRUE
[10:58:38.361] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.361] List of 2
[10:58:38.361]  $ ...          : list()
[10:58:38.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.361]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.361]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.361]  - attr(*, "where")=List of 2
[10:58:38.361]   ..$ ...          :<environment: 0x5635bf276100> 
[10:58:38.361]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:38.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.361]  - attr(*, "resolved")= logi FALSE
[10:58:38.361]  - attr(*, "total_size")= num NA
[10:58:38.364] Packages to be attached in all futures: [n=0] 
[10:58:38.364] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.364] Number of futures (= number of chunks): 1
[10:58:38.364] Launching 1 futures (chunks) ...
[10:58:38.364] Chunk #1 of 1 ...
[10:58:38.365]  - seeds: <none>
[10:58:38.365]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.365] getGlobalsAndPackages() ...
[10:58:38.365] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.365] Resolving globals: FALSE
[10:58:38.365] Tweak future expression to call with '...' arguments ...
[10:58:38.365] {
[10:58:38.365]     do.call(function(...) {
[10:58:38.365]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.365]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.365]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.365]             on.exit(options(oopts), add = TRUE)
[10:58:38.365]         }
[10:58:38.365]         {
[10:58:38.365]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.365]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.365]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.365]             })
[10:58:38.365]         }
[10:58:38.365]     }, args = future.call.arguments)
[10:58:38.365] }
[10:58:38.366] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.366] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.366] 
[10:58:38.366] getGlobalsAndPackages() ... DONE
[10:58:38.367] run() for ‘Future’ ...
[10:58:38.367] - state: ‘created’
[10:58:38.367] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.367] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.367] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.368]   - Field: ‘label’
[10:58:38.368]   - Field: ‘local’
[10:58:38.368]   - Field: ‘owner’
[10:58:38.368]   - Field: ‘envir’
[10:58:38.368]   - Field: ‘packages’
[10:58:38.368]   - Field: ‘gc’
[10:58:38.368]   - Field: ‘conditions’
[10:58:38.368]   - Field: ‘expr’
[10:58:38.368]   - Field: ‘uuid’
[10:58:38.368]   - Field: ‘seed’
[10:58:38.368]   - Field: ‘version’
[10:58:38.368]   - Field: ‘result’
[10:58:38.368]   - Field: ‘asynchronous’
[10:58:38.369]   - Field: ‘calls’
[10:58:38.369]   - Field: ‘globals’
[10:58:38.369]   - Field: ‘stdout’
[10:58:38.369]   - Field: ‘earlySignal’
[10:58:38.369]   - Field: ‘lazy’
[10:58:38.369]   - Field: ‘state’
[10:58:38.369] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.369] - Launch lazy future ...
[10:58:38.370] Packages needed by the future expression (n = 0): <none>
[10:58:38.370] Packages needed by future strategies (n = 0): <none>
[10:58:38.370] {
[10:58:38.370]     {
[10:58:38.370]         {
[10:58:38.370]             ...future.startTime <- base::Sys.time()
[10:58:38.370]             {
[10:58:38.370]                 {
[10:58:38.370]                   {
[10:58:38.370]                     base::local({
[10:58:38.370]                       has_future <- base::requireNamespace("future", 
[10:58:38.370]                         quietly = TRUE)
[10:58:38.370]                       if (has_future) {
[10:58:38.370]                         ns <- base::getNamespace("future")
[10:58:38.370]                         version <- ns[[".package"]][["version"]]
[10:58:38.370]                         if (is.null(version)) 
[10:58:38.370]                           version <- utils::packageVersion("future")
[10:58:38.370]                       }
[10:58:38.370]                       else {
[10:58:38.370]                         version <- NULL
[10:58:38.370]                       }
[10:58:38.370]                       if (!has_future || version < "1.8.0") {
[10:58:38.370]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.370]                           "", base::R.version$version.string), 
[10:58:38.370]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:38.370]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.370]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.370]                             "release", "version")], collapse = " "), 
[10:58:38.370]                           hostname = base::Sys.info()[["nodename"]])
[10:58:38.370]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.370]                           info)
[10:58:38.370]                         info <- base::paste(info, collapse = "; ")
[10:58:38.370]                         if (!has_future) {
[10:58:38.370]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.370]                             info)
[10:58:38.370]                         }
[10:58:38.370]                         else {
[10:58:38.370]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.370]                             info, version)
[10:58:38.370]                         }
[10:58:38.370]                         base::stop(msg)
[10:58:38.370]                       }
[10:58:38.370]                     })
[10:58:38.370]                   }
[10:58:38.370]                   ...future.strategy.old <- future::plan("list")
[10:58:38.370]                   options(future.plan = NULL)
[10:58:38.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.370]                 }
[10:58:38.370]                 ...future.workdir <- getwd()
[10:58:38.370]             }
[10:58:38.370]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.370]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.370]         }
[10:58:38.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.370]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.370]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.370]             base::names(...future.oldOptions))
[10:58:38.370]     }
[10:58:38.370]     if (FALSE) {
[10:58:38.370]     }
[10:58:38.370]     else {
[10:58:38.370]         if (TRUE) {
[10:58:38.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.370]                 open = "w")
[10:58:38.370]         }
[10:58:38.370]         else {
[10:58:38.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.370]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.370]         }
[10:58:38.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.370]             base::sink(type = "output", split = FALSE)
[10:58:38.370]             base::close(...future.stdout)
[10:58:38.370]         }, add = TRUE)
[10:58:38.370]     }
[10:58:38.370]     ...future.frame <- base::sys.nframe()
[10:58:38.370]     ...future.conditions <- base::list()
[10:58:38.370]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.370]     if (FALSE) {
[10:58:38.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.370]     }
[10:58:38.370]     ...future.result <- base::tryCatch({
[10:58:38.370]         base::withCallingHandlers({
[10:58:38.370]             ...future.value <- base::withVisible(base::local({
[10:58:38.370]                 do.call(function(...) {
[10:58:38.370]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.370]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.370]                     ...future.globals.maxSize)) {
[10:58:38.370]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.370]                     on.exit(options(oopts), add = TRUE)
[10:58:38.370]                   }
[10:58:38.370]                   {
[10:58:38.370]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.370]                       FUN = function(jj) {
[10:58:38.370]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.370]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.370]                       })
[10:58:38.370]                   }
[10:58:38.370]                 }, args = future.call.arguments)
[10:58:38.370]             }))
[10:58:38.370]             future::FutureResult(value = ...future.value$value, 
[10:58:38.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.370]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.370]                     ...future.globalenv.names))
[10:58:38.370]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.370]         }, condition = base::local({
[10:58:38.370]             c <- base::c
[10:58:38.370]             inherits <- base::inherits
[10:58:38.370]             invokeRestart <- base::invokeRestart
[10:58:38.370]             length <- base::length
[10:58:38.370]             list <- base::list
[10:58:38.370]             seq.int <- base::seq.int
[10:58:38.370]             signalCondition <- base::signalCondition
[10:58:38.370]             sys.calls <- base::sys.calls
[10:58:38.370]             `[[` <- base::`[[`
[10:58:38.370]             `+` <- base::`+`
[10:58:38.370]             `<<-` <- base::`<<-`
[10:58:38.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.370]                   3L)]
[10:58:38.370]             }
[10:58:38.370]             function(cond) {
[10:58:38.370]                 is_error <- inherits(cond, "error")
[10:58:38.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.370]                   NULL)
[10:58:38.370]                 if (is_error) {
[10:58:38.370]                   sessionInformation <- function() {
[10:58:38.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.370]                       search = base::search(), system = base::Sys.info())
[10:58:38.370]                   }
[10:58:38.370]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.370]                     cond$call), session = sessionInformation(), 
[10:58:38.370]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.370]                   signalCondition(cond)
[10:58:38.370]                 }
[10:58:38.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.370]                 "immediateCondition"))) {
[10:58:38.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.370]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.370]                   if (TRUE && !signal) {
[10:58:38.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.370]                     {
[10:58:38.370]                       inherits <- base::inherits
[10:58:38.370]                       invokeRestart <- base::invokeRestart
[10:58:38.370]                       is.null <- base::is.null
[10:58:38.370]                       muffled <- FALSE
[10:58:38.370]                       if (inherits(cond, "message")) {
[10:58:38.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.370]                         if (muffled) 
[10:58:38.370]                           invokeRestart("muffleMessage")
[10:58:38.370]                       }
[10:58:38.370]                       else if (inherits(cond, "warning")) {
[10:58:38.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.370]                         if (muffled) 
[10:58:38.370]                           invokeRestart("muffleWarning")
[10:58:38.370]                       }
[10:58:38.370]                       else if (inherits(cond, "condition")) {
[10:58:38.370]                         if (!is.null(pattern)) {
[10:58:38.370]                           computeRestarts <- base::computeRestarts
[10:58:38.370]                           grepl <- base::grepl
[10:58:38.370]                           restarts <- computeRestarts(cond)
[10:58:38.370]                           for (restart in restarts) {
[10:58:38.370]                             name <- restart$name
[10:58:38.370]                             if (is.null(name)) 
[10:58:38.370]                               next
[10:58:38.370]                             if (!grepl(pattern, name)) 
[10:58:38.370]                               next
[10:58:38.370]                             invokeRestart(restart)
[10:58:38.370]                             muffled <- TRUE
[10:58:38.370]                             break
[10:58:38.370]                           }
[10:58:38.370]                         }
[10:58:38.370]                       }
[10:58:38.370]                       invisible(muffled)
[10:58:38.370]                     }
[10:58:38.370]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.370]                   }
[10:58:38.370]                 }
[10:58:38.370]                 else {
[10:58:38.370]                   if (TRUE) {
[10:58:38.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.370]                     {
[10:58:38.370]                       inherits <- base::inherits
[10:58:38.370]                       invokeRestart <- base::invokeRestart
[10:58:38.370]                       is.null <- base::is.null
[10:58:38.370]                       muffled <- FALSE
[10:58:38.370]                       if (inherits(cond, "message")) {
[10:58:38.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.370]                         if (muffled) 
[10:58:38.370]                           invokeRestart("muffleMessage")
[10:58:38.370]                       }
[10:58:38.370]                       else if (inherits(cond, "warning")) {
[10:58:38.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.370]                         if (muffled) 
[10:58:38.370]                           invokeRestart("muffleWarning")
[10:58:38.370]                       }
[10:58:38.370]                       else if (inherits(cond, "condition")) {
[10:58:38.370]                         if (!is.null(pattern)) {
[10:58:38.370]                           computeRestarts <- base::computeRestarts
[10:58:38.370]                           grepl <- base::grepl
[10:58:38.370]                           restarts <- computeRestarts(cond)
[10:58:38.370]                           for (restart in restarts) {
[10:58:38.370]                             name <- restart$name
[10:58:38.370]                             if (is.null(name)) 
[10:58:38.370]                               next
[10:58:38.370]                             if (!grepl(pattern, name)) 
[10:58:38.370]                               next
[10:58:38.370]                             invokeRestart(restart)
[10:58:38.370]                             muffled <- TRUE
[10:58:38.370]                             break
[10:58:38.370]                           }
[10:58:38.370]                         }
[10:58:38.370]                       }
[10:58:38.370]                       invisible(muffled)
[10:58:38.370]                     }
[10:58:38.370]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.370]                   }
[10:58:38.370]                 }
[10:58:38.370]             }
[10:58:38.370]         }))
[10:58:38.370]     }, error = function(ex) {
[10:58:38.370]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.370]                 ...future.rng), started = ...future.startTime, 
[10:58:38.370]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.370]             version = "1.8"), class = "FutureResult")
[10:58:38.370]     }, finally = {
[10:58:38.370]         if (!identical(...future.workdir, getwd())) 
[10:58:38.370]             setwd(...future.workdir)
[10:58:38.370]         {
[10:58:38.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.370]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.370]             }
[10:58:38.370]             base::options(...future.oldOptions)
[10:58:38.370]             if (.Platform$OS.type == "windows") {
[10:58:38.370]                 old_names <- names(...future.oldEnvVars)
[10:58:38.370]                 envs <- base::Sys.getenv()
[10:58:38.370]                 names <- names(envs)
[10:58:38.370]                 common <- intersect(names, old_names)
[10:58:38.370]                 added <- setdiff(names, old_names)
[10:58:38.370]                 removed <- setdiff(old_names, names)
[10:58:38.370]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.370]                   envs[common]]
[10:58:38.370]                 NAMES <- toupper(changed)
[10:58:38.370]                 args <- list()
[10:58:38.370]                 for (kk in seq_along(NAMES)) {
[10:58:38.370]                   name <- changed[[kk]]
[10:58:38.370]                   NAME <- NAMES[[kk]]
[10:58:38.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.370]                     next
[10:58:38.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.370]                 }
[10:58:38.370]                 NAMES <- toupper(added)
[10:58:38.370]                 for (kk in seq_along(NAMES)) {
[10:58:38.370]                   name <- added[[kk]]
[10:58:38.370]                   NAME <- NAMES[[kk]]
[10:58:38.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.370]                     next
[10:58:38.370]                   args[[name]] <- ""
[10:58:38.370]                 }
[10:58:38.370]                 NAMES <- toupper(removed)
[10:58:38.370]                 for (kk in seq_along(NAMES)) {
[10:58:38.370]                   name <- removed[[kk]]
[10:58:38.370]                   NAME <- NAMES[[kk]]
[10:58:38.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.370]                     next
[10:58:38.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.370]                 }
[10:58:38.370]                 if (length(args) > 0) 
[10:58:38.370]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.370]             }
[10:58:38.370]             else {
[10:58:38.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.370]             }
[10:58:38.370]             {
[10:58:38.370]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.370]                   0L) {
[10:58:38.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.370]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.370]                   base::options(opts)
[10:58:38.370]                 }
[10:58:38.370]                 {
[10:58:38.370]                   {
[10:58:38.370]                     NULL
[10:58:38.370]                     RNGkind("Mersenne-Twister")
[10:58:38.370]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:38.370]                       inherits = FALSE)
[10:58:38.370]                   }
[10:58:38.370]                   options(future.plan = NULL)
[10:58:38.370]                   if (is.na(NA_character_)) 
[10:58:38.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.370]                     .init = FALSE)
[10:58:38.370]                 }
[10:58:38.370]             }
[10:58:38.370]         }
[10:58:38.370]     })
[10:58:38.370]     if (TRUE) {
[10:58:38.370]         base::sink(type = "output", split = FALSE)
[10:58:38.370]         if (TRUE) {
[10:58:38.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.370]         }
[10:58:38.370]         else {
[10:58:38.370]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.370]         }
[10:58:38.370]         base::close(...future.stdout)
[10:58:38.370]         ...future.stdout <- NULL
[10:58:38.370]     }
[10:58:38.370]     ...future.result$conditions <- ...future.conditions
[10:58:38.370]     ...future.result$finished <- base::Sys.time()
[10:58:38.370]     ...future.result
[10:58:38.370] }
[10:58:38.372] assign_globals() ...
[10:58:38.372] List of 5
[10:58:38.372]  $ future.call.arguments    : list()
[10:58:38.372]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.372]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.372]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.372]  $ ...future.elements_ii    :List of 2
[10:58:38.372]   ..$ : num [1:4] 1 3 1 7
[10:58:38.372]   ..$ : num [1:4] 2 4 6 8
[10:58:38.372]  $ ...future.seeds_ii       : NULL
[10:58:38.372]  $ ...future.globals.maxSize: num Inf
[10:58:38.372]  - attr(*, "resolved")= logi FALSE
[10:58:38.372]  - attr(*, "total_size")= num NA
[10:58:38.372]  - attr(*, "where")=List of 5
[10:58:38.372]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.372]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.372]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.372]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.372]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.372]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.372]  - attr(*, "already-done")= logi TRUE
[10:58:38.377] - copied ‘future.call.arguments’ to environment
[10:58:38.377] - copied ‘...future.FUN’ to environment
[10:58:38.377] - copied ‘...future.elements_ii’ to environment
[10:58:38.377] - copied ‘...future.seeds_ii’ to environment
[10:58:38.378] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.378] assign_globals() ... done
[10:58:38.378] plan(): Setting new future strategy stack:
[10:58:38.378] List of future strategies:
[10:58:38.378] 1. sequential:
[10:58:38.378]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.378]    - tweaked: FALSE
[10:58:38.378]    - call: NULL
[10:58:38.378] plan(): nbrOfWorkers() = 1
[10:58:38.380] plan(): Setting new future strategy stack:
[10:58:38.380] List of future strategies:
[10:58:38.380] 1. sequential:
[10:58:38.380]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.380]    - tweaked: FALSE
[10:58:38.380]    - call: plan(strategy)
[10:58:38.380] plan(): nbrOfWorkers() = 1
[10:58:38.380] SequentialFuture started (and completed)
[10:58:38.381] - Launch lazy future ... done
[10:58:38.381] run() for ‘SequentialFuture’ ... done
[10:58:38.381] Created future:
[10:58:38.381] SequentialFuture:
[10:58:38.381] Label: ‘future_apply-1’
[10:58:38.381] Expression:
[10:58:38.381] {
[10:58:38.381]     do.call(function(...) {
[10:58:38.381]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.381]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.381]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.381]             on.exit(options(oopts), add = TRUE)
[10:58:38.381]         }
[10:58:38.381]         {
[10:58:38.381]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.381]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.381]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.381]             })
[10:58:38.381]         }
[10:58:38.381]     }, args = future.call.arguments)
[10:58:38.381] }
[10:58:38.381] Lazy evaluation: FALSE
[10:58:38.381] Asynchronous evaluation: FALSE
[10:58:38.381] Local evaluation: TRUE
[10:58:38.381] Environment: R_GlobalEnv
[10:58:38.381] Capture standard output: TRUE
[10:58:38.381] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.381] Globals: 5 objects totaling 31.56 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 111 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.381] Packages: <none>
[10:58:38.381] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.381] Resolved: TRUE
[10:58:38.381] Value: 429 bytes of class ‘list’
[10:58:38.381] Early signaling: FALSE
[10:58:38.381] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.381] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.382] Chunk #1 of 1 ... DONE
[10:58:38.382] Launching 1 futures (chunks) ... DONE
[10:58:38.383] Resolving 1 futures (chunks) ...
[10:58:38.383] resolve() on list ...
[10:58:38.383]  recursive: 0
[10:58:38.383]  length: 1
[10:58:38.383] 
[10:58:38.383] resolved() for ‘SequentialFuture’ ...
[10:58:38.383] - state: ‘finished’
[10:58:38.383] - run: TRUE
[10:58:38.383] - result: ‘FutureResult’
[10:58:38.383] resolved() for ‘SequentialFuture’ ... done
[10:58:38.384] Future #1
[10:58:38.384] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.384] - nx: 1
[10:58:38.384] - relay: TRUE
[10:58:38.384] - stdout: TRUE
[10:58:38.384] - signal: TRUE
[10:58:38.384] - resignal: FALSE
[10:58:38.384] - force: TRUE
[10:58:38.384] - relayed: [n=1] FALSE
[10:58:38.386] - queued futures: [n=1] FALSE
[10:58:38.386]  - until=1
[10:58:38.386]  - relaying element #1
[10:58:38.386] - relayed: [n=1] TRUE
[10:58:38.386] - queued futures: [n=1] TRUE
[10:58:38.386] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.386]  length: 0 (resolved future 1)
[10:58:38.386] Relaying remaining futures
[10:58:38.386] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.387] - nx: 1
[10:58:38.387] - relay: TRUE
[10:58:38.387] - stdout: TRUE
[10:58:38.387] - signal: TRUE
[10:58:38.387] - resignal: FALSE
[10:58:38.387] - force: TRUE
[10:58:38.387] - relayed: [n=1] TRUE
[10:58:38.387] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.387] - relayed: [n=1] TRUE
[10:58:38.387] - queued futures: [n=1] TRUE
[10:58:38.387] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.387] resolve() on list ... DONE
[10:58:38.388]  - Number of value chunks collected: 1
[10:58:38.388] Resolving 1 futures (chunks) ... DONE
[10:58:38.388] Reducing values from 1 chunks ...
[10:58:38.388]  - Number of values collected after concatenation: 2
[10:58:38.388]  - Number of values expected: 2
[10:58:38.388] Reducing values from 1 chunks ... DONE
[10:58:38.388] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:58:38.389] getGlobalsAndPackagesXApply() ...
[10:58:38.389]  - future.globals: TRUE
[10:58:38.389] getGlobalsAndPackages() ...
[10:58:38.389] Searching for globals...
[10:58:38.419] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:58:38.419] Searching for globals ... DONE
[10:58:38.419] Resolving globals: FALSE
[10:58:38.422] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:58:38.422] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:58:38.422] - globals: [1] ‘FUN’
[10:58:38.422] 
[10:58:38.423] getGlobalsAndPackages() ... DONE
[10:58:38.423]  - globals found/used: [n=1] ‘FUN’
[10:58:38.423]  - needed namespaces: [n=0] 
[10:58:38.423] Finding globals ... DONE
[10:58:38.423]  - use_args: TRUE
[10:58:38.423]  - Getting '...' globals ...
[10:58:38.423] resolve() on list ...
[10:58:38.423]  recursive: 0
[10:58:38.423]  length: 1
[10:58:38.423]  elements: ‘...’
[10:58:38.424]  length: 0 (resolved future 1)
[10:58:38.424] resolve() on list ... DONE
[10:58:38.424]    - '...' content: [n=0] 
[10:58:38.424] List of 1
[10:58:38.424]  $ ...: list()
[10:58:38.424]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.424]  - attr(*, "where")=List of 1
[10:58:38.424]   ..$ ...:<environment: 0x5635bd9bc4a0> 
[10:58:38.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.424]  - attr(*, "resolved")= logi TRUE
[10:58:38.424]  - attr(*, "total_size")= num NA
[10:58:38.426]  - Getting '...' globals ... DONE
[10:58:38.426] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.427] List of 2
[10:58:38.427]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.427]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.427]  $ ...          : list()
[10:58:38.427]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.427]  - attr(*, "where")=List of 2
[10:58:38.427]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.427]   ..$ ...          :<environment: 0x5635bd9bc4a0> 
[10:58:38.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.427]  - attr(*, "resolved")= logi FALSE
[10:58:38.427]  - attr(*, "total_size")= num 65967
[10:58:38.429] Packages to be attached in all futures: [n=0] 
[10:58:38.429] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.429] future_lapply() ...
[10:58:38.458] Number of chunks: 1
[10:58:38.458] getGlobalsAndPackagesXApply() ...
[10:58:38.459]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.459]  - use_args: TRUE
[10:58:38.459] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.459] List of 2
[10:58:38.459]  $ ...          : list()
[10:58:38.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.459]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.459]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.459]  - attr(*, "where")=List of 2
[10:58:38.459]   ..$ ...          :<environment: 0x5635bd9bc4a0> 
[10:58:38.459]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:38.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.459]  - attr(*, "resolved")= logi FALSE
[10:58:38.459]  - attr(*, "total_size")= num NA
[10:58:38.462] Packages to be attached in all futures: [n=0] 
[10:58:38.462] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.462] Number of futures (= number of chunks): 1
[10:58:38.462] Launching 1 futures (chunks) ...
[10:58:38.462] Chunk #1 of 1 ...
[10:58:38.462]  - seeds: <none>
[10:58:38.463]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.463] getGlobalsAndPackages() ...
[10:58:38.463] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.463] Resolving globals: FALSE
[10:58:38.463] Tweak future expression to call with '...' arguments ...
[10:58:38.463] {
[10:58:38.463]     do.call(function(...) {
[10:58:38.463]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.463]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.463]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.463]             on.exit(options(oopts), add = TRUE)
[10:58:38.463]         }
[10:58:38.463]         {
[10:58:38.463]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.463]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.463]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.463]             })
[10:58:38.463]         }
[10:58:38.463]     }, args = future.call.arguments)
[10:58:38.463] }
[10:58:38.463] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.464] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.464] 
[10:58:38.464] getGlobalsAndPackages() ... DONE
[10:58:38.464] run() for ‘Future’ ...
[10:58:38.464] - state: ‘created’
[10:58:38.464] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.465] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.465] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.465]   - Field: ‘label’
[10:58:38.465]   - Field: ‘local’
[10:58:38.465]   - Field: ‘owner’
[10:58:38.465]   - Field: ‘envir’
[10:58:38.465]   - Field: ‘packages’
[10:58:38.465]   - Field: ‘gc’
[10:58:38.465]   - Field: ‘conditions’
[10:58:38.465]   - Field: ‘expr’
[10:58:38.465]   - Field: ‘uuid’
[10:58:38.465]   - Field: ‘seed’
[10:58:38.466]   - Field: ‘version’
[10:58:38.466]   - Field: ‘result’
[10:58:38.466]   - Field: ‘asynchronous’
[10:58:38.466]   - Field: ‘calls’
[10:58:38.466]   - Field: ‘globals’
[10:58:38.466]   - Field: ‘stdout’
[10:58:38.466]   - Field: ‘earlySignal’
[10:58:38.466]   - Field: ‘lazy’
[10:58:38.466]   - Field: ‘state’
[10:58:38.466] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.466] - Launch lazy future ...
[10:58:38.467] Packages needed by the future expression (n = 0): <none>
[10:58:38.467] Packages needed by future strategies (n = 0): <none>
[10:58:38.467] {
[10:58:38.467]     {
[10:58:38.467]         {
[10:58:38.467]             ...future.startTime <- base::Sys.time()
[10:58:38.467]             {
[10:58:38.467]                 {
[10:58:38.467]                   {
[10:58:38.467]                     base::local({
[10:58:38.467]                       has_future <- base::requireNamespace("future", 
[10:58:38.467]                         quietly = TRUE)
[10:58:38.467]                       if (has_future) {
[10:58:38.467]                         ns <- base::getNamespace("future")
[10:58:38.467]                         version <- ns[[".package"]][["version"]]
[10:58:38.467]                         if (is.null(version)) 
[10:58:38.467]                           version <- utils::packageVersion("future")
[10:58:38.467]                       }
[10:58:38.467]                       else {
[10:58:38.467]                         version <- NULL
[10:58:38.467]                       }
[10:58:38.467]                       if (!has_future || version < "1.8.0") {
[10:58:38.467]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.467]                           "", base::R.version$version.string), 
[10:58:38.467]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:38.467]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.467]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.467]                             "release", "version")], collapse = " "), 
[10:58:38.467]                           hostname = base::Sys.info()[["nodename"]])
[10:58:38.467]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.467]                           info)
[10:58:38.467]                         info <- base::paste(info, collapse = "; ")
[10:58:38.467]                         if (!has_future) {
[10:58:38.467]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.467]                             info)
[10:58:38.467]                         }
[10:58:38.467]                         else {
[10:58:38.467]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.467]                             info, version)
[10:58:38.467]                         }
[10:58:38.467]                         base::stop(msg)
[10:58:38.467]                       }
[10:58:38.467]                     })
[10:58:38.467]                   }
[10:58:38.467]                   ...future.strategy.old <- future::plan("list")
[10:58:38.467]                   options(future.plan = NULL)
[10:58:38.467]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.467]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.467]                 }
[10:58:38.467]                 ...future.workdir <- getwd()
[10:58:38.467]             }
[10:58:38.467]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.467]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.467]         }
[10:58:38.467]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.467]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.467]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.467]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.467]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.467]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.467]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.467]             base::names(...future.oldOptions))
[10:58:38.467]     }
[10:58:38.467]     if (FALSE) {
[10:58:38.467]     }
[10:58:38.467]     else {
[10:58:38.467]         if (TRUE) {
[10:58:38.467]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.467]                 open = "w")
[10:58:38.467]         }
[10:58:38.467]         else {
[10:58:38.467]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.467]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.467]         }
[10:58:38.467]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.467]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.467]             base::sink(type = "output", split = FALSE)
[10:58:38.467]             base::close(...future.stdout)
[10:58:38.467]         }, add = TRUE)
[10:58:38.467]     }
[10:58:38.467]     ...future.frame <- base::sys.nframe()
[10:58:38.467]     ...future.conditions <- base::list()
[10:58:38.467]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.467]     if (FALSE) {
[10:58:38.467]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.467]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.467]     }
[10:58:38.467]     ...future.result <- base::tryCatch({
[10:58:38.467]         base::withCallingHandlers({
[10:58:38.467]             ...future.value <- base::withVisible(base::local({
[10:58:38.467]                 do.call(function(...) {
[10:58:38.467]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.467]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.467]                     ...future.globals.maxSize)) {
[10:58:38.467]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.467]                     on.exit(options(oopts), add = TRUE)
[10:58:38.467]                   }
[10:58:38.467]                   {
[10:58:38.467]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.467]                       FUN = function(jj) {
[10:58:38.467]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.467]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.467]                       })
[10:58:38.467]                   }
[10:58:38.467]                 }, args = future.call.arguments)
[10:58:38.467]             }))
[10:58:38.467]             future::FutureResult(value = ...future.value$value, 
[10:58:38.467]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.467]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.467]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.467]                     ...future.globalenv.names))
[10:58:38.467]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.467]         }, condition = base::local({
[10:58:38.467]             c <- base::c
[10:58:38.467]             inherits <- base::inherits
[10:58:38.467]             invokeRestart <- base::invokeRestart
[10:58:38.467]             length <- base::length
[10:58:38.467]             list <- base::list
[10:58:38.467]             seq.int <- base::seq.int
[10:58:38.467]             signalCondition <- base::signalCondition
[10:58:38.467]             sys.calls <- base::sys.calls
[10:58:38.467]             `[[` <- base::`[[`
[10:58:38.467]             `+` <- base::`+`
[10:58:38.467]             `<<-` <- base::`<<-`
[10:58:38.467]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.467]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.467]                   3L)]
[10:58:38.467]             }
[10:58:38.467]             function(cond) {
[10:58:38.467]                 is_error <- inherits(cond, "error")
[10:58:38.467]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.467]                   NULL)
[10:58:38.467]                 if (is_error) {
[10:58:38.467]                   sessionInformation <- function() {
[10:58:38.467]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.467]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.467]                       search = base::search(), system = base::Sys.info())
[10:58:38.467]                   }
[10:58:38.467]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.467]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.467]                     cond$call), session = sessionInformation(), 
[10:58:38.467]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.467]                   signalCondition(cond)
[10:58:38.467]                 }
[10:58:38.467]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.467]                 "immediateCondition"))) {
[10:58:38.467]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.467]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.467]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.467]                   if (TRUE && !signal) {
[10:58:38.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.467]                     {
[10:58:38.467]                       inherits <- base::inherits
[10:58:38.467]                       invokeRestart <- base::invokeRestart
[10:58:38.467]                       is.null <- base::is.null
[10:58:38.467]                       muffled <- FALSE
[10:58:38.467]                       if (inherits(cond, "message")) {
[10:58:38.467]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.467]                         if (muffled) 
[10:58:38.467]                           invokeRestart("muffleMessage")
[10:58:38.467]                       }
[10:58:38.467]                       else if (inherits(cond, "warning")) {
[10:58:38.467]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.467]                         if (muffled) 
[10:58:38.467]                           invokeRestart("muffleWarning")
[10:58:38.467]                       }
[10:58:38.467]                       else if (inherits(cond, "condition")) {
[10:58:38.467]                         if (!is.null(pattern)) {
[10:58:38.467]                           computeRestarts <- base::computeRestarts
[10:58:38.467]                           grepl <- base::grepl
[10:58:38.467]                           restarts <- computeRestarts(cond)
[10:58:38.467]                           for (restart in restarts) {
[10:58:38.467]                             name <- restart$name
[10:58:38.467]                             if (is.null(name)) 
[10:58:38.467]                               next
[10:58:38.467]                             if (!grepl(pattern, name)) 
[10:58:38.467]                               next
[10:58:38.467]                             invokeRestart(restart)
[10:58:38.467]                             muffled <- TRUE
[10:58:38.467]                             break
[10:58:38.467]                           }
[10:58:38.467]                         }
[10:58:38.467]                       }
[10:58:38.467]                       invisible(muffled)
[10:58:38.467]                     }
[10:58:38.467]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.467]                   }
[10:58:38.467]                 }
[10:58:38.467]                 else {
[10:58:38.467]                   if (TRUE) {
[10:58:38.467]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.467]                     {
[10:58:38.467]                       inherits <- base::inherits
[10:58:38.467]                       invokeRestart <- base::invokeRestart
[10:58:38.467]                       is.null <- base::is.null
[10:58:38.467]                       muffled <- FALSE
[10:58:38.467]                       if (inherits(cond, "message")) {
[10:58:38.467]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.467]                         if (muffled) 
[10:58:38.467]                           invokeRestart("muffleMessage")
[10:58:38.467]                       }
[10:58:38.467]                       else if (inherits(cond, "warning")) {
[10:58:38.467]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.467]                         if (muffled) 
[10:58:38.467]                           invokeRestart("muffleWarning")
[10:58:38.467]                       }
[10:58:38.467]                       else if (inherits(cond, "condition")) {
[10:58:38.467]                         if (!is.null(pattern)) {
[10:58:38.467]                           computeRestarts <- base::computeRestarts
[10:58:38.467]                           grepl <- base::grepl
[10:58:38.467]                           restarts <- computeRestarts(cond)
[10:58:38.467]                           for (restart in restarts) {
[10:58:38.467]                             name <- restart$name
[10:58:38.467]                             if (is.null(name)) 
[10:58:38.467]                               next
[10:58:38.467]                             if (!grepl(pattern, name)) 
[10:58:38.467]                               next
[10:58:38.467]                             invokeRestart(restart)
[10:58:38.467]                             muffled <- TRUE
[10:58:38.467]                             break
[10:58:38.467]                           }
[10:58:38.467]                         }
[10:58:38.467]                       }
[10:58:38.467]                       invisible(muffled)
[10:58:38.467]                     }
[10:58:38.467]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.467]                   }
[10:58:38.467]                 }
[10:58:38.467]             }
[10:58:38.467]         }))
[10:58:38.467]     }, error = function(ex) {
[10:58:38.467]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.467]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.467]                 ...future.rng), started = ...future.startTime, 
[10:58:38.467]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.467]             version = "1.8"), class = "FutureResult")
[10:58:38.467]     }, finally = {
[10:58:38.467]         if (!identical(...future.workdir, getwd())) 
[10:58:38.467]             setwd(...future.workdir)
[10:58:38.467]         {
[10:58:38.467]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.467]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.467]             }
[10:58:38.467]             base::options(...future.oldOptions)
[10:58:38.467]             if (.Platform$OS.type == "windows") {
[10:58:38.467]                 old_names <- names(...future.oldEnvVars)
[10:58:38.467]                 envs <- base::Sys.getenv()
[10:58:38.467]                 names <- names(envs)
[10:58:38.467]                 common <- intersect(names, old_names)
[10:58:38.467]                 added <- setdiff(names, old_names)
[10:58:38.467]                 removed <- setdiff(old_names, names)
[10:58:38.467]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.467]                   envs[common]]
[10:58:38.467]                 NAMES <- toupper(changed)
[10:58:38.467]                 args <- list()
[10:58:38.467]                 for (kk in seq_along(NAMES)) {
[10:58:38.467]                   name <- changed[[kk]]
[10:58:38.467]                   NAME <- NAMES[[kk]]
[10:58:38.467]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.467]                     next
[10:58:38.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.467]                 }
[10:58:38.467]                 NAMES <- toupper(added)
[10:58:38.467]                 for (kk in seq_along(NAMES)) {
[10:58:38.467]                   name <- added[[kk]]
[10:58:38.467]                   NAME <- NAMES[[kk]]
[10:58:38.467]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.467]                     next
[10:58:38.467]                   args[[name]] <- ""
[10:58:38.467]                 }
[10:58:38.467]                 NAMES <- toupper(removed)
[10:58:38.467]                 for (kk in seq_along(NAMES)) {
[10:58:38.467]                   name <- removed[[kk]]
[10:58:38.467]                   NAME <- NAMES[[kk]]
[10:58:38.467]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.467]                     next
[10:58:38.467]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.467]                 }
[10:58:38.467]                 if (length(args) > 0) 
[10:58:38.467]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.467]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.467]             }
[10:58:38.467]             else {
[10:58:38.467]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.467]             }
[10:58:38.467]             {
[10:58:38.467]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.467]                   0L) {
[10:58:38.467]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.467]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.467]                   base::options(opts)
[10:58:38.467]                 }
[10:58:38.467]                 {
[10:58:38.467]                   {
[10:58:38.467]                     NULL
[10:58:38.467]                     RNGkind("Mersenne-Twister")
[10:58:38.467]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:38.467]                       inherits = FALSE)
[10:58:38.467]                   }
[10:58:38.467]                   options(future.plan = NULL)
[10:58:38.467]                   if (is.na(NA_character_)) 
[10:58:38.467]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.467]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.467]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.467]                     .init = FALSE)
[10:58:38.467]                 }
[10:58:38.467]             }
[10:58:38.467]         }
[10:58:38.467]     })
[10:58:38.467]     if (TRUE) {
[10:58:38.467]         base::sink(type = "output", split = FALSE)
[10:58:38.467]         if (TRUE) {
[10:58:38.467]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.467]         }
[10:58:38.467]         else {
[10:58:38.467]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.467]         }
[10:58:38.467]         base::close(...future.stdout)
[10:58:38.467]         ...future.stdout <- NULL
[10:58:38.467]     }
[10:58:38.467]     ...future.result$conditions <- ...future.conditions
[10:58:38.467]     ...future.result$finished <- base::Sys.time()
[10:58:38.467]     ...future.result
[10:58:38.467] }
[10:58:38.469] assign_globals() ...
[10:58:38.469] List of 5
[10:58:38.469]  $ future.call.arguments    : list()
[10:58:38.469]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.469]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.469]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.469]  $ ...future.elements_ii    :List of 2
[10:58:38.469]   ..$ : num [1:4] 1 3 1 7
[10:58:38.469]   ..$ : num [1:4] 2 4 6 8
[10:58:38.469]  $ ...future.seeds_ii       : NULL
[10:58:38.469]  $ ...future.globals.maxSize: num Inf
[10:58:38.469]  - attr(*, "resolved")= logi FALSE
[10:58:38.469]  - attr(*, "total_size")= num NA
[10:58:38.469]  - attr(*, "where")=List of 5
[10:58:38.469]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.469]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.469]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.469]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.469]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.469]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.469]  - attr(*, "already-done")= logi TRUE
[10:58:38.473] - copied ‘future.call.arguments’ to environment
[10:58:38.474] - copied ‘...future.FUN’ to environment
[10:58:38.474] - copied ‘...future.elements_ii’ to environment
[10:58:38.474] - copied ‘...future.seeds_ii’ to environment
[10:58:38.474] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.474] assign_globals() ... done
[10:58:38.474] plan(): Setting new future strategy stack:
[10:58:38.474] List of future strategies:
[10:58:38.474] 1. sequential:
[10:58:38.474]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.474]    - tweaked: FALSE
[10:58:38.474]    - call: NULL
[10:58:38.475] plan(): nbrOfWorkers() = 1
[10:58:38.476] plan(): Setting new future strategy stack:
[10:58:38.476] List of future strategies:
[10:58:38.476] 1. sequential:
[10:58:38.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.476]    - tweaked: FALSE
[10:58:38.476]    - call: plan(strategy)
[10:58:38.476] plan(): nbrOfWorkers() = 1
[10:58:38.476] SequentialFuture started (and completed)
[10:58:38.476] - Launch lazy future ... done
[10:58:38.476] run() for ‘SequentialFuture’ ... done
[10:58:38.476] Created future:
[10:58:38.477] SequentialFuture:
[10:58:38.477] Label: ‘future_apply-1’
[10:58:38.477] Expression:
[10:58:38.477] {
[10:58:38.477]     do.call(function(...) {
[10:58:38.477]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.477]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.477]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.477]             on.exit(options(oopts), add = TRUE)
[10:58:38.477]         }
[10:58:38.477]         {
[10:58:38.477]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.477]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.477]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.477]             })
[10:58:38.477]         }
[10:58:38.477]     }, args = future.call.arguments)
[10:58:38.477] }
[10:58:38.477] Lazy evaluation: FALSE
[10:58:38.477] Asynchronous evaluation: FALSE
[10:58:38.477] Local evaluation: TRUE
[10:58:38.477] Environment: R_GlobalEnv
[10:58:38.477] Capture standard output: TRUE
[10:58:38.477] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.477] Globals: 5 objects totaling 31.56 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 111 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.477] Packages: <none>
[10:58:38.477] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.477] Resolved: TRUE
[10:58:38.477] Value: 429 bytes of class ‘list’
[10:58:38.477] Early signaling: FALSE
[10:58:38.477] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.477] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.478] Chunk #1 of 1 ... DONE
[10:58:38.478] Launching 1 futures (chunks) ... DONE
[10:58:38.478] Resolving 1 futures (chunks) ...
[10:58:38.478] resolve() on list ...
[10:58:38.478]  recursive: 0
[10:58:38.478]  length: 1
[10:58:38.478] 
[10:58:38.478] resolved() for ‘SequentialFuture’ ...
[10:58:38.478] - state: ‘finished’
[10:58:38.478] - run: TRUE
[10:58:38.478] - result: ‘FutureResult’
[10:58:38.479] resolved() for ‘SequentialFuture’ ... done
[10:58:38.479] Future #1
[10:58:38.479] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.479] - nx: 1
[10:58:38.479] - relay: TRUE
[10:58:38.480] - stdout: TRUE
[10:58:38.480] - signal: TRUE
[10:58:38.480] - resignal: FALSE
[10:58:38.480] - force: TRUE
[10:58:38.480] - relayed: [n=1] FALSE
[10:58:38.480] - queued futures: [n=1] FALSE
[10:58:38.480]  - until=1
[10:58:38.480]  - relaying element #1
[10:58:38.481] - relayed: [n=1] TRUE
[10:58:38.481] - queued futures: [n=1] TRUE
[10:58:38.481] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.481]  length: 0 (resolved future 1)
[10:58:38.481] Relaying remaining futures
[10:58:38.481] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.481] - nx: 1
[10:58:38.481] - relay: TRUE
[10:58:38.481] - stdout: TRUE
[10:58:38.481] - signal: TRUE
[10:58:38.481] - resignal: FALSE
[10:58:38.481] - force: TRUE
[10:58:38.482] - relayed: [n=1] TRUE
[10:58:38.482] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.482] - relayed: [n=1] TRUE
[10:58:38.482] - queued futures: [n=1] TRUE
[10:58:38.482] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.482] resolve() on list ... DONE
[10:58:38.482]  - Number of value chunks collected: 1
[10:58:38.482] Resolving 1 futures (chunks) ... DONE
[10:58:38.482] Reducing values from 1 chunks ...
[10:58:38.482]  - Number of values collected after concatenation: 2
[10:58:38.482]  - Number of values expected: 2
[10:58:38.482] Reducing values from 1 chunks ... DONE
[10:58:38.483] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:58:38.484] getGlobalsAndPackagesXApply() ...
[10:58:38.484]  - future.globals: TRUE
[10:58:38.484] getGlobalsAndPackages() ...
[10:58:38.485] Searching for globals...
[10:58:38.486] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:38.486] Searching for globals ... DONE
[10:58:38.486] Resolving globals: FALSE
[10:58:38.486] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:38.486] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:38.486] - globals: [1] ‘FUN’
[10:58:38.487] - packages: [1] ‘stats’
[10:58:38.487] getGlobalsAndPackages() ... DONE
[10:58:38.487]  - globals found/used: [n=1] ‘FUN’
[10:58:38.487]  - needed namespaces: [n=1] ‘stats’
[10:58:38.487] Finding globals ... DONE
[10:58:38.487]  - use_args: TRUE
[10:58:38.487]  - Getting '...' globals ...
[10:58:38.487] resolve() on list ...
[10:58:38.487]  recursive: 0
[10:58:38.488]  length: 1
[10:58:38.488]  elements: ‘...’
[10:58:38.488]  length: 0 (resolved future 1)
[10:58:38.488] resolve() on list ... DONE
[10:58:38.488]    - '...' content: [n=0] 
[10:58:38.488] List of 1
[10:58:38.488]  $ ...: list()
[10:58:38.488]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.488]  - attr(*, "where")=List of 1
[10:58:38.488]   ..$ ...:<environment: 0x5635bd10d360> 
[10:58:38.488]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.488]  - attr(*, "resolved")= logi TRUE
[10:58:38.488]  - attr(*, "total_size")= num NA
[10:58:38.490]  - Getting '...' globals ... DONE
[10:58:38.490] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.490] List of 2
[10:58:38.490]  $ ...future.FUN:function (x, ...)  
[10:58:38.490]  $ ...          : list()
[10:58:38.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.490]  - attr(*, "where")=List of 2
[10:58:38.490]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.490]   ..$ ...          :<environment: 0x5635bd10d360> 
[10:58:38.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.490]  - attr(*, "resolved")= logi FALSE
[10:58:38.490]  - attr(*, "total_size")= num 2586
[10:58:38.493] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:38.493] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.493] future_lapply() ...
[10:58:38.494] Number of chunks: 1
[10:58:38.494] getGlobalsAndPackagesXApply() ...
[10:58:38.494]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.494]  - use_args: TRUE
[10:58:38.494] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.494] List of 2
[10:58:38.494]  $ ...          : list()
[10:58:38.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.494]  $ ...future.FUN:function (x, ...)  
[10:58:38.494]  - attr(*, "where")=List of 2
[10:58:38.494]   ..$ ...          :<environment: 0x5635bd10d360> 
[10:58:38.494]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:58:38.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.494]  - attr(*, "resolved")= logi FALSE
[10:58:38.494]  - attr(*, "total_size")= num NA
[10:58:38.497] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:38.497] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.497] Number of futures (= number of chunks): 1
[10:58:38.497] Launching 1 futures (chunks) ...
[10:58:38.497] Chunk #1 of 1 ...
[10:58:38.497]  - seeds: <none>
[10:58:38.497]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.498] getGlobalsAndPackages() ...
[10:58:38.498] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.498] Resolving globals: FALSE
[10:58:38.498] Tweak future expression to call with '...' arguments ...
[10:58:38.498] {
[10:58:38.498]     do.call(function(...) {
[10:58:38.498]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.498]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.498]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.498]             on.exit(options(oopts), add = TRUE)
[10:58:38.498]         }
[10:58:38.498]         {
[10:58:38.498]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.498]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.498]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.498]             })
[10:58:38.498]         }
[10:58:38.498]     }, args = future.call.arguments)
[10:58:38.498] }
[10:58:38.498] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.499] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.499] - packages: [1] ‘stats’
[10:58:38.499] getGlobalsAndPackages() ... DONE
[10:58:38.499] run() for ‘Future’ ...
[10:58:38.499] - state: ‘created’
[10:58:38.499] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.499] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.500] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.500]   - Field: ‘label’
[10:58:38.500]   - Field: ‘local’
[10:58:38.500]   - Field: ‘owner’
[10:58:38.500]   - Field: ‘envir’
[10:58:38.500]   - Field: ‘packages’
[10:58:38.500]   - Field: ‘gc’
[10:58:38.500]   - Field: ‘conditions’
[10:58:38.500]   - Field: ‘expr’
[10:58:38.500]   - Field: ‘uuid’
[10:58:38.500]   - Field: ‘seed’
[10:58:38.500]   - Field: ‘version’
[10:58:38.501]   - Field: ‘result’
[10:58:38.501]   - Field: ‘asynchronous’
[10:58:38.502]   - Field: ‘calls’
[10:58:38.502]   - Field: ‘globals’
[10:58:38.502]   - Field: ‘stdout’
[10:58:38.502]   - Field: ‘earlySignal’
[10:58:38.502]   - Field: ‘lazy’
[10:58:38.502]   - Field: ‘state’
[10:58:38.502] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.502] - Launch lazy future ...
[10:58:38.502] Packages needed by the future expression (n = 1): ‘stats’
[10:58:38.502] Packages needed by future strategies (n = 0): <none>
[10:58:38.503] {
[10:58:38.503]     {
[10:58:38.503]         {
[10:58:38.503]             ...future.startTime <- base::Sys.time()
[10:58:38.503]             {
[10:58:38.503]                 {
[10:58:38.503]                   {
[10:58:38.503]                     {
[10:58:38.503]                       base::local({
[10:58:38.503]                         has_future <- base::requireNamespace("future", 
[10:58:38.503]                           quietly = TRUE)
[10:58:38.503]                         if (has_future) {
[10:58:38.503]                           ns <- base::getNamespace("future")
[10:58:38.503]                           version <- ns[[".package"]][["version"]]
[10:58:38.503]                           if (is.null(version)) 
[10:58:38.503]                             version <- utils::packageVersion("future")
[10:58:38.503]                         }
[10:58:38.503]                         else {
[10:58:38.503]                           version <- NULL
[10:58:38.503]                         }
[10:58:38.503]                         if (!has_future || version < "1.8.0") {
[10:58:38.503]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.503]                             "", base::R.version$version.string), 
[10:58:38.503]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:38.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.503]                               "release", "version")], collapse = " "), 
[10:58:38.503]                             hostname = base::Sys.info()[["nodename"]])
[10:58:38.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.503]                             info)
[10:58:38.503]                           info <- base::paste(info, collapse = "; ")
[10:58:38.503]                           if (!has_future) {
[10:58:38.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.503]                               info)
[10:58:38.503]                           }
[10:58:38.503]                           else {
[10:58:38.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.503]                               info, version)
[10:58:38.503]                           }
[10:58:38.503]                           base::stop(msg)
[10:58:38.503]                         }
[10:58:38.503]                       })
[10:58:38.503]                     }
[10:58:38.503]                     base::local({
[10:58:38.503]                       for (pkg in "stats") {
[10:58:38.503]                         base::loadNamespace(pkg)
[10:58:38.503]                         base::library(pkg, character.only = TRUE)
[10:58:38.503]                       }
[10:58:38.503]                     })
[10:58:38.503]                   }
[10:58:38.503]                   ...future.strategy.old <- future::plan("list")
[10:58:38.503]                   options(future.plan = NULL)
[10:58:38.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.503]                 }
[10:58:38.503]                 ...future.workdir <- getwd()
[10:58:38.503]             }
[10:58:38.503]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.503]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.503]         }
[10:58:38.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.503]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.503]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.503]             base::names(...future.oldOptions))
[10:58:38.503]     }
[10:58:38.503]     if (FALSE) {
[10:58:38.503]     }
[10:58:38.503]     else {
[10:58:38.503]         if (TRUE) {
[10:58:38.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.503]                 open = "w")
[10:58:38.503]         }
[10:58:38.503]         else {
[10:58:38.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.503]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.503]         }
[10:58:38.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.503]             base::sink(type = "output", split = FALSE)
[10:58:38.503]             base::close(...future.stdout)
[10:58:38.503]         }, add = TRUE)
[10:58:38.503]     }
[10:58:38.503]     ...future.frame <- base::sys.nframe()
[10:58:38.503]     ...future.conditions <- base::list()
[10:58:38.503]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.503]     if (FALSE) {
[10:58:38.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.503]     }
[10:58:38.503]     ...future.result <- base::tryCatch({
[10:58:38.503]         base::withCallingHandlers({
[10:58:38.503]             ...future.value <- base::withVisible(base::local({
[10:58:38.503]                 do.call(function(...) {
[10:58:38.503]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.503]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.503]                     ...future.globals.maxSize)) {
[10:58:38.503]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.503]                     on.exit(options(oopts), add = TRUE)
[10:58:38.503]                   }
[10:58:38.503]                   {
[10:58:38.503]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.503]                       FUN = function(jj) {
[10:58:38.503]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.503]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.503]                       })
[10:58:38.503]                   }
[10:58:38.503]                 }, args = future.call.arguments)
[10:58:38.503]             }))
[10:58:38.503]             future::FutureResult(value = ...future.value$value, 
[10:58:38.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.503]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.503]                     ...future.globalenv.names))
[10:58:38.503]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.503]         }, condition = base::local({
[10:58:38.503]             c <- base::c
[10:58:38.503]             inherits <- base::inherits
[10:58:38.503]             invokeRestart <- base::invokeRestart
[10:58:38.503]             length <- base::length
[10:58:38.503]             list <- base::list
[10:58:38.503]             seq.int <- base::seq.int
[10:58:38.503]             signalCondition <- base::signalCondition
[10:58:38.503]             sys.calls <- base::sys.calls
[10:58:38.503]             `[[` <- base::`[[`
[10:58:38.503]             `+` <- base::`+`
[10:58:38.503]             `<<-` <- base::`<<-`
[10:58:38.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.503]                   3L)]
[10:58:38.503]             }
[10:58:38.503]             function(cond) {
[10:58:38.503]                 is_error <- inherits(cond, "error")
[10:58:38.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.503]                   NULL)
[10:58:38.503]                 if (is_error) {
[10:58:38.503]                   sessionInformation <- function() {
[10:58:38.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.503]                       search = base::search(), system = base::Sys.info())
[10:58:38.503]                   }
[10:58:38.503]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.503]                     cond$call), session = sessionInformation(), 
[10:58:38.503]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.503]                   signalCondition(cond)
[10:58:38.503]                 }
[10:58:38.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.503]                 "immediateCondition"))) {
[10:58:38.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.503]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.503]                   if (TRUE && !signal) {
[10:58:38.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.503]                     {
[10:58:38.503]                       inherits <- base::inherits
[10:58:38.503]                       invokeRestart <- base::invokeRestart
[10:58:38.503]                       is.null <- base::is.null
[10:58:38.503]                       muffled <- FALSE
[10:58:38.503]                       if (inherits(cond, "message")) {
[10:58:38.503]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.503]                         if (muffled) 
[10:58:38.503]                           invokeRestart("muffleMessage")
[10:58:38.503]                       }
[10:58:38.503]                       else if (inherits(cond, "warning")) {
[10:58:38.503]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.503]                         if (muffled) 
[10:58:38.503]                           invokeRestart("muffleWarning")
[10:58:38.503]                       }
[10:58:38.503]                       else if (inherits(cond, "condition")) {
[10:58:38.503]                         if (!is.null(pattern)) {
[10:58:38.503]                           computeRestarts <- base::computeRestarts
[10:58:38.503]                           grepl <- base::grepl
[10:58:38.503]                           restarts <- computeRestarts(cond)
[10:58:38.503]                           for (restart in restarts) {
[10:58:38.503]                             name <- restart$name
[10:58:38.503]                             if (is.null(name)) 
[10:58:38.503]                               next
[10:58:38.503]                             if (!grepl(pattern, name)) 
[10:58:38.503]                               next
[10:58:38.503]                             invokeRestart(restart)
[10:58:38.503]                             muffled <- TRUE
[10:58:38.503]                             break
[10:58:38.503]                           }
[10:58:38.503]                         }
[10:58:38.503]                       }
[10:58:38.503]                       invisible(muffled)
[10:58:38.503]                     }
[10:58:38.503]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.503]                   }
[10:58:38.503]                 }
[10:58:38.503]                 else {
[10:58:38.503]                   if (TRUE) {
[10:58:38.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.503]                     {
[10:58:38.503]                       inherits <- base::inherits
[10:58:38.503]                       invokeRestart <- base::invokeRestart
[10:58:38.503]                       is.null <- base::is.null
[10:58:38.503]                       muffled <- FALSE
[10:58:38.503]                       if (inherits(cond, "message")) {
[10:58:38.503]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.503]                         if (muffled) 
[10:58:38.503]                           invokeRestart("muffleMessage")
[10:58:38.503]                       }
[10:58:38.503]                       else if (inherits(cond, "warning")) {
[10:58:38.503]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.503]                         if (muffled) 
[10:58:38.503]                           invokeRestart("muffleWarning")
[10:58:38.503]                       }
[10:58:38.503]                       else if (inherits(cond, "condition")) {
[10:58:38.503]                         if (!is.null(pattern)) {
[10:58:38.503]                           computeRestarts <- base::computeRestarts
[10:58:38.503]                           grepl <- base::grepl
[10:58:38.503]                           restarts <- computeRestarts(cond)
[10:58:38.503]                           for (restart in restarts) {
[10:58:38.503]                             name <- restart$name
[10:58:38.503]                             if (is.null(name)) 
[10:58:38.503]                               next
[10:58:38.503]                             if (!grepl(pattern, name)) 
[10:58:38.503]                               next
[10:58:38.503]                             invokeRestart(restart)
[10:58:38.503]                             muffled <- TRUE
[10:58:38.503]                             break
[10:58:38.503]                           }
[10:58:38.503]                         }
[10:58:38.503]                       }
[10:58:38.503]                       invisible(muffled)
[10:58:38.503]                     }
[10:58:38.503]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.503]                   }
[10:58:38.503]                 }
[10:58:38.503]             }
[10:58:38.503]         }))
[10:58:38.503]     }, error = function(ex) {
[10:58:38.503]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.503]                 ...future.rng), started = ...future.startTime, 
[10:58:38.503]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.503]             version = "1.8"), class = "FutureResult")
[10:58:38.503]     }, finally = {
[10:58:38.503]         if (!identical(...future.workdir, getwd())) 
[10:58:38.503]             setwd(...future.workdir)
[10:58:38.503]         {
[10:58:38.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.503]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.503]             }
[10:58:38.503]             base::options(...future.oldOptions)
[10:58:38.503]             if (.Platform$OS.type == "windows") {
[10:58:38.503]                 old_names <- names(...future.oldEnvVars)
[10:58:38.503]                 envs <- base::Sys.getenv()
[10:58:38.503]                 names <- names(envs)
[10:58:38.503]                 common <- intersect(names, old_names)
[10:58:38.503]                 added <- setdiff(names, old_names)
[10:58:38.503]                 removed <- setdiff(old_names, names)
[10:58:38.503]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.503]                   envs[common]]
[10:58:38.503]                 NAMES <- toupper(changed)
[10:58:38.503]                 args <- list()
[10:58:38.503]                 for (kk in seq_along(NAMES)) {
[10:58:38.503]                   name <- changed[[kk]]
[10:58:38.503]                   NAME <- NAMES[[kk]]
[10:58:38.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.503]                     next
[10:58:38.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.503]                 }
[10:58:38.503]                 NAMES <- toupper(added)
[10:58:38.503]                 for (kk in seq_along(NAMES)) {
[10:58:38.503]                   name <- added[[kk]]
[10:58:38.503]                   NAME <- NAMES[[kk]]
[10:58:38.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.503]                     next
[10:58:38.503]                   args[[name]] <- ""
[10:58:38.503]                 }
[10:58:38.503]                 NAMES <- toupper(removed)
[10:58:38.503]                 for (kk in seq_along(NAMES)) {
[10:58:38.503]                   name <- removed[[kk]]
[10:58:38.503]                   NAME <- NAMES[[kk]]
[10:58:38.503]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.503]                     next
[10:58:38.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.503]                 }
[10:58:38.503]                 if (length(args) > 0) 
[10:58:38.503]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.503]             }
[10:58:38.503]             else {
[10:58:38.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.503]             }
[10:58:38.503]             {
[10:58:38.503]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.503]                   0L) {
[10:58:38.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.503]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.503]                   base::options(opts)
[10:58:38.503]                 }
[10:58:38.503]                 {
[10:58:38.503]                   {
[10:58:38.503]                     NULL
[10:58:38.503]                     RNGkind("Mersenne-Twister")
[10:58:38.503]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:38.503]                       inherits = FALSE)
[10:58:38.503]                   }
[10:58:38.503]                   options(future.plan = NULL)
[10:58:38.503]                   if (is.na(NA_character_)) 
[10:58:38.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.503]                     .init = FALSE)
[10:58:38.503]                 }
[10:58:38.503]             }
[10:58:38.503]         }
[10:58:38.503]     })
[10:58:38.503]     if (TRUE) {
[10:58:38.503]         base::sink(type = "output", split = FALSE)
[10:58:38.503]         if (TRUE) {
[10:58:38.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.503]         }
[10:58:38.503]         else {
[10:58:38.503]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.503]         }
[10:58:38.503]         base::close(...future.stdout)
[10:58:38.503]         ...future.stdout <- NULL
[10:58:38.503]     }
[10:58:38.503]     ...future.result$conditions <- ...future.conditions
[10:58:38.503]     ...future.result$finished <- base::Sys.time()
[10:58:38.503]     ...future.result
[10:58:38.503] }
[10:58:38.505] assign_globals() ...
[10:58:38.505] List of 5
[10:58:38.505]  $ future.call.arguments    : list()
[10:58:38.505]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.505]  $ ...future.FUN            :function (x, ...)  
[10:58:38.505]  $ ...future.elements_ii    :List of 2
[10:58:38.505]   ..$ : num [1:4] 1 3 1 7
[10:58:38.505]   ..$ : num [1:4] 2 4 6 8
[10:58:38.505]  $ ...future.seeds_ii       : NULL
[10:58:38.505]  $ ...future.globals.maxSize: num Inf
[10:58:38.505]  - attr(*, "resolved")= logi FALSE
[10:58:38.505]  - attr(*, "total_size")= num NA
[10:58:38.505]  - attr(*, "where")=List of 5
[10:58:38.505]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.505]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.505]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.505]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.505]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.505]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.505]  - attr(*, "already-done")= logi TRUE
[10:58:38.509] - copied ‘future.call.arguments’ to environment
[10:58:38.509] - copied ‘...future.FUN’ to environment
[10:58:38.509] - copied ‘...future.elements_ii’ to environment
[10:58:38.510] - copied ‘...future.seeds_ii’ to environment
[10:58:38.510] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.510] assign_globals() ... done
[10:58:38.510] plan(): Setting new future strategy stack:
[10:58:38.510] List of future strategies:
[10:58:38.510] 1. sequential:
[10:58:38.510]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.510]    - tweaked: FALSE
[10:58:38.510]    - call: NULL
[10:58:38.511] plan(): nbrOfWorkers() = 1
[10:58:38.512] plan(): Setting new future strategy stack:
[10:58:38.512] List of future strategies:
[10:58:38.512] 1. sequential:
[10:58:38.512]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.512]    - tweaked: FALSE
[10:58:38.512]    - call: plan(strategy)
[10:58:38.512] plan(): nbrOfWorkers() = 1
[10:58:38.512] SequentialFuture started (and completed)
[10:58:38.512] - Launch lazy future ... done
[10:58:38.512] run() for ‘SequentialFuture’ ... done
[10:58:38.512] Created future:
[10:58:38.513] SequentialFuture:
[10:58:38.513] Label: ‘future_apply-1’
[10:58:38.513] Expression:
[10:58:38.513] {
[10:58:38.513]     do.call(function(...) {
[10:58:38.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.513]             on.exit(options(oopts), add = TRUE)
[10:58:38.513]         }
[10:58:38.513]         {
[10:58:38.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.513]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.513]             })
[10:58:38.513]         }
[10:58:38.513]     }, args = future.call.arguments)
[10:58:38.513] }
[10:58:38.513] Lazy evaluation: FALSE
[10:58:38.513] Asynchronous evaluation: FALSE
[10:58:38.513] Local evaluation: TRUE
[10:58:38.513] Environment: R_GlobalEnv
[10:58:38.513] Capture standard output: TRUE
[10:58:38.513] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.513] Globals: 5 objects totaling 585 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 111 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.513] Packages: 1 packages (‘stats’)
[10:58:38.513] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.513] Resolved: TRUE
[10:58:38.513] Value: 290 bytes of class ‘list’
[10:58:38.513] Early signaling: FALSE
[10:58:38.513] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.513] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.513] Chunk #1 of 1 ... DONE
[10:58:38.513] Launching 1 futures (chunks) ... DONE
[10:58:38.513] Resolving 1 futures (chunks) ...
[10:58:38.514] resolve() on list ...
[10:58:38.514]  recursive: 0
[10:58:38.514]  length: 1
[10:58:38.514] 
[10:58:38.514] resolved() for ‘SequentialFuture’ ...
[10:58:38.514] - state: ‘finished’
[10:58:38.514] - run: TRUE
[10:58:38.514] - result: ‘FutureResult’
[10:58:38.514] resolved() for ‘SequentialFuture’ ... done
[10:58:38.514] Future #1
[10:58:38.514] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.515] - nx: 1
[10:58:38.515] - relay: TRUE
[10:58:38.515] - stdout: TRUE
[10:58:38.515] - signal: TRUE
[10:58:38.515] - resignal: FALSE
[10:58:38.515] - force: TRUE
[10:58:38.515] - relayed: [n=1] FALSE
[10:58:38.515] - queued futures: [n=1] FALSE
[10:58:38.515]  - until=1
[10:58:38.515]  - relaying element #1
[10:58:38.515] - relayed: [n=1] TRUE
[10:58:38.515] - queued futures: [n=1] TRUE
[10:58:38.516] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.516]  length: 0 (resolved future 1)
[10:58:38.516] Relaying remaining futures
[10:58:38.516] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.516] - nx: 1
[10:58:38.516] - relay: TRUE
[10:58:38.516] - stdout: TRUE
[10:58:38.516] - signal: TRUE
[10:58:38.516] - resignal: FALSE
[10:58:38.516] - force: TRUE
[10:58:38.516] - relayed: [n=1] TRUE
[10:58:38.516] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.516] - relayed: [n=1] TRUE
[10:58:38.517] - queued futures: [n=1] TRUE
[10:58:38.517] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.517] resolve() on list ... DONE
[10:58:38.517]  - Number of value chunks collected: 1
[10:58:38.517] Resolving 1 futures (chunks) ... DONE
[10:58:38.517] Reducing values from 1 chunks ...
[10:58:38.517]  - Number of values collected after concatenation: 2
[10:58:38.517]  - Number of values expected: 2
[10:58:38.517] Reducing values from 1 chunks ... DONE
[10:58:38.517] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:58:38.518] getGlobalsAndPackagesXApply() ...
[10:58:38.518]  - future.globals: TRUE
[10:58:38.518] getGlobalsAndPackages() ...
[10:58:38.518] Searching for globals...
[10:58:38.519] - globals found: [1] ‘FUN’
[10:58:38.519] Searching for globals ... DONE
[10:58:38.519] Resolving globals: FALSE
[10:58:38.519] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:38.520] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:38.520] - globals: [1] ‘FUN’
[10:58:38.520] 
[10:58:38.520] getGlobalsAndPackages() ... DONE
[10:58:38.520]  - globals found/used: [n=1] ‘FUN’
[10:58:38.520]  - needed namespaces: [n=0] 
[10:58:38.520] Finding globals ... DONE
[10:58:38.520]  - use_args: TRUE
[10:58:38.520]  - Getting '...' globals ...
[10:58:38.521] resolve() on list ...
[10:58:38.521]  recursive: 0
[10:58:38.521]  length: 1
[10:58:38.521]  elements: ‘...’
[10:58:38.521]  length: 0 (resolved future 1)
[10:58:38.521] resolve() on list ... DONE
[10:58:38.521]    - '...' content: [n=0] 
[10:58:38.521] List of 1
[10:58:38.521]  $ ...: list()
[10:58:38.521]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.521]  - attr(*, "where")=List of 1
[10:58:38.521]   ..$ ...:<environment: 0x5635bf623db8> 
[10:58:38.521]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.521]  - attr(*, "resolved")= logi TRUE
[10:58:38.521]  - attr(*, "total_size")= num NA
[10:58:38.524]  - Getting '...' globals ... DONE
[10:58:38.524] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.525] List of 2
[10:58:38.525]  $ ...future.FUN:function (x)  
[10:58:38.525]  $ ...          : list()
[10:58:38.525]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.525]  - attr(*, "where")=List of 2
[10:58:38.525]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.525]   ..$ ...          :<environment: 0x5635bf623db8> 
[10:58:38.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.525]  - attr(*, "resolved")= logi FALSE
[10:58:38.525]  - attr(*, "total_size")= num 2624
[10:58:38.527] Packages to be attached in all futures: [n=0] 
[10:58:38.527] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.527] future_lapply() ...
[10:58:38.528] Number of chunks: 1
[10:58:38.528] getGlobalsAndPackagesXApply() ...
[10:58:38.528]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.528]  - use_args: TRUE
[10:58:38.528] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.528] List of 2
[10:58:38.528]  $ ...          : list()
[10:58:38.528]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.528]  $ ...future.FUN:function (x)  
[10:58:38.528]  - attr(*, "where")=List of 2
[10:58:38.528]   ..$ ...          :<environment: 0x5635bf623db8> 
[10:58:38.528]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:38.528]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.528]  - attr(*, "resolved")= logi FALSE
[10:58:38.528]  - attr(*, "total_size")= num NA
[10:58:38.531] Packages to be attached in all futures: [n=0] 
[10:58:38.531] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.531] Number of futures (= number of chunks): 1
[10:58:38.532] Launching 1 futures (chunks) ...
[10:58:38.532] Chunk #1 of 1 ...
[10:58:38.532]  - seeds: <none>
[10:58:38.532]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.532] getGlobalsAndPackages() ...
[10:58:38.532] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.532] Resolving globals: FALSE
[10:58:38.532] Tweak future expression to call with '...' arguments ...
[10:58:38.532] {
[10:58:38.532]     do.call(function(...) {
[10:58:38.532]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.532]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.532]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.532]             on.exit(options(oopts), add = TRUE)
[10:58:38.532]         }
[10:58:38.532]         {
[10:58:38.532]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.532]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.532]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.532]             })
[10:58:38.532]         }
[10:58:38.532]     }, args = future.call.arguments)
[10:58:38.532] }
[10:58:38.533] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.533] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.533] 
[10:58:38.533] getGlobalsAndPackages() ... DONE
[10:58:38.533] run() for ‘Future’ ...
[10:58:38.533] - state: ‘created’
[10:58:38.533] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.534] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.534]   - Field: ‘label’
[10:58:38.534]   - Field: ‘local’
[10:58:38.534]   - Field: ‘owner’
[10:58:38.534]   - Field: ‘envir’
[10:58:38.534]   - Field: ‘packages’
[10:58:38.534]   - Field: ‘gc’
[10:58:38.534]   - Field: ‘conditions’
[10:58:38.534]   - Field: ‘expr’
[10:58:38.535]   - Field: ‘uuid’
[10:58:38.535]   - Field: ‘seed’
[10:58:38.535]   - Field: ‘version’
[10:58:38.535]   - Field: ‘result’
[10:58:38.535]   - Field: ‘asynchronous’
[10:58:38.535]   - Field: ‘calls’
[10:58:38.535]   - Field: ‘globals’
[10:58:38.535]   - Field: ‘stdout’
[10:58:38.535]   - Field: ‘earlySignal’
[10:58:38.535]   - Field: ‘lazy’
[10:58:38.535]   - Field: ‘state’
[10:58:38.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.536] - Launch lazy future ...
[10:58:38.536] Packages needed by the future expression (n = 0): <none>
[10:58:38.536] Packages needed by future strategies (n = 0): <none>
[10:58:38.536] {
[10:58:38.536]     {
[10:58:38.536]         {
[10:58:38.536]             ...future.startTime <- base::Sys.time()
[10:58:38.536]             {
[10:58:38.536]                 {
[10:58:38.536]                   {
[10:58:38.536]                     base::local({
[10:58:38.536]                       has_future <- base::requireNamespace("future", 
[10:58:38.536]                         quietly = TRUE)
[10:58:38.536]                       if (has_future) {
[10:58:38.536]                         ns <- base::getNamespace("future")
[10:58:38.536]                         version <- ns[[".package"]][["version"]]
[10:58:38.536]                         if (is.null(version)) 
[10:58:38.536]                           version <- utils::packageVersion("future")
[10:58:38.536]                       }
[10:58:38.536]                       else {
[10:58:38.536]                         version <- NULL
[10:58:38.536]                       }
[10:58:38.536]                       if (!has_future || version < "1.8.0") {
[10:58:38.536]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.536]                           "", base::R.version$version.string), 
[10:58:38.536]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:38.536]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.536]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.536]                             "release", "version")], collapse = " "), 
[10:58:38.536]                           hostname = base::Sys.info()[["nodename"]])
[10:58:38.536]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.536]                           info)
[10:58:38.536]                         info <- base::paste(info, collapse = "; ")
[10:58:38.536]                         if (!has_future) {
[10:58:38.536]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.536]                             info)
[10:58:38.536]                         }
[10:58:38.536]                         else {
[10:58:38.536]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.536]                             info, version)
[10:58:38.536]                         }
[10:58:38.536]                         base::stop(msg)
[10:58:38.536]                       }
[10:58:38.536]                     })
[10:58:38.536]                   }
[10:58:38.536]                   ...future.strategy.old <- future::plan("list")
[10:58:38.536]                   options(future.plan = NULL)
[10:58:38.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.536]                 }
[10:58:38.536]                 ...future.workdir <- getwd()
[10:58:38.536]             }
[10:58:38.536]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.536]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.536]         }
[10:58:38.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.536]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.536]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.536]             base::names(...future.oldOptions))
[10:58:38.536]     }
[10:58:38.536]     if (FALSE) {
[10:58:38.536]     }
[10:58:38.536]     else {
[10:58:38.536]         if (TRUE) {
[10:58:38.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.536]                 open = "w")
[10:58:38.536]         }
[10:58:38.536]         else {
[10:58:38.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.536]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.536]         }
[10:58:38.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.536]             base::sink(type = "output", split = FALSE)
[10:58:38.536]             base::close(...future.stdout)
[10:58:38.536]         }, add = TRUE)
[10:58:38.536]     }
[10:58:38.536]     ...future.frame <- base::sys.nframe()
[10:58:38.536]     ...future.conditions <- base::list()
[10:58:38.536]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.536]     if (FALSE) {
[10:58:38.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.536]     }
[10:58:38.536]     ...future.result <- base::tryCatch({
[10:58:38.536]         base::withCallingHandlers({
[10:58:38.536]             ...future.value <- base::withVisible(base::local({
[10:58:38.536]                 do.call(function(...) {
[10:58:38.536]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.536]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.536]                     ...future.globals.maxSize)) {
[10:58:38.536]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.536]                     on.exit(options(oopts), add = TRUE)
[10:58:38.536]                   }
[10:58:38.536]                   {
[10:58:38.536]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.536]                       FUN = function(jj) {
[10:58:38.536]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.536]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.536]                       })
[10:58:38.536]                   }
[10:58:38.536]                 }, args = future.call.arguments)
[10:58:38.536]             }))
[10:58:38.536]             future::FutureResult(value = ...future.value$value, 
[10:58:38.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.536]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.536]                     ...future.globalenv.names))
[10:58:38.536]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.536]         }, condition = base::local({
[10:58:38.536]             c <- base::c
[10:58:38.536]             inherits <- base::inherits
[10:58:38.536]             invokeRestart <- base::invokeRestart
[10:58:38.536]             length <- base::length
[10:58:38.536]             list <- base::list
[10:58:38.536]             seq.int <- base::seq.int
[10:58:38.536]             signalCondition <- base::signalCondition
[10:58:38.536]             sys.calls <- base::sys.calls
[10:58:38.536]             `[[` <- base::`[[`
[10:58:38.536]             `+` <- base::`+`
[10:58:38.536]             `<<-` <- base::`<<-`
[10:58:38.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.536]                   3L)]
[10:58:38.536]             }
[10:58:38.536]             function(cond) {
[10:58:38.536]                 is_error <- inherits(cond, "error")
[10:58:38.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.536]                   NULL)
[10:58:38.536]                 if (is_error) {
[10:58:38.536]                   sessionInformation <- function() {
[10:58:38.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.536]                       search = base::search(), system = base::Sys.info())
[10:58:38.536]                   }
[10:58:38.536]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.536]                     cond$call), session = sessionInformation(), 
[10:58:38.536]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.536]                   signalCondition(cond)
[10:58:38.536]                 }
[10:58:38.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.536]                 "immediateCondition"))) {
[10:58:38.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.536]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.536]                   if (TRUE && !signal) {
[10:58:38.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.536]                     {
[10:58:38.536]                       inherits <- base::inherits
[10:58:38.536]                       invokeRestart <- base::invokeRestart
[10:58:38.536]                       is.null <- base::is.null
[10:58:38.536]                       muffled <- FALSE
[10:58:38.536]                       if (inherits(cond, "message")) {
[10:58:38.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.536]                         if (muffled) 
[10:58:38.536]                           invokeRestart("muffleMessage")
[10:58:38.536]                       }
[10:58:38.536]                       else if (inherits(cond, "warning")) {
[10:58:38.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.536]                         if (muffled) 
[10:58:38.536]                           invokeRestart("muffleWarning")
[10:58:38.536]                       }
[10:58:38.536]                       else if (inherits(cond, "condition")) {
[10:58:38.536]                         if (!is.null(pattern)) {
[10:58:38.536]                           computeRestarts <- base::computeRestarts
[10:58:38.536]                           grepl <- base::grepl
[10:58:38.536]                           restarts <- computeRestarts(cond)
[10:58:38.536]                           for (restart in restarts) {
[10:58:38.536]                             name <- restart$name
[10:58:38.536]                             if (is.null(name)) 
[10:58:38.536]                               next
[10:58:38.536]                             if (!grepl(pattern, name)) 
[10:58:38.536]                               next
[10:58:38.536]                             invokeRestart(restart)
[10:58:38.536]                             muffled <- TRUE
[10:58:38.536]                             break
[10:58:38.536]                           }
[10:58:38.536]                         }
[10:58:38.536]                       }
[10:58:38.536]                       invisible(muffled)
[10:58:38.536]                     }
[10:58:38.536]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.536]                   }
[10:58:38.536]                 }
[10:58:38.536]                 else {
[10:58:38.536]                   if (TRUE) {
[10:58:38.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.536]                     {
[10:58:38.536]                       inherits <- base::inherits
[10:58:38.536]                       invokeRestart <- base::invokeRestart
[10:58:38.536]                       is.null <- base::is.null
[10:58:38.536]                       muffled <- FALSE
[10:58:38.536]                       if (inherits(cond, "message")) {
[10:58:38.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.536]                         if (muffled) 
[10:58:38.536]                           invokeRestart("muffleMessage")
[10:58:38.536]                       }
[10:58:38.536]                       else if (inherits(cond, "warning")) {
[10:58:38.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.536]                         if (muffled) 
[10:58:38.536]                           invokeRestart("muffleWarning")
[10:58:38.536]                       }
[10:58:38.536]                       else if (inherits(cond, "condition")) {
[10:58:38.536]                         if (!is.null(pattern)) {
[10:58:38.536]                           computeRestarts <- base::computeRestarts
[10:58:38.536]                           grepl <- base::grepl
[10:58:38.536]                           restarts <- computeRestarts(cond)
[10:58:38.536]                           for (restart in restarts) {
[10:58:38.536]                             name <- restart$name
[10:58:38.536]                             if (is.null(name)) 
[10:58:38.536]                               next
[10:58:38.536]                             if (!grepl(pattern, name)) 
[10:58:38.536]                               next
[10:58:38.536]                             invokeRestart(restart)
[10:58:38.536]                             muffled <- TRUE
[10:58:38.536]                             break
[10:58:38.536]                           }
[10:58:38.536]                         }
[10:58:38.536]                       }
[10:58:38.536]                       invisible(muffled)
[10:58:38.536]                     }
[10:58:38.536]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.536]                   }
[10:58:38.536]                 }
[10:58:38.536]             }
[10:58:38.536]         }))
[10:58:38.536]     }, error = function(ex) {
[10:58:38.536]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.536]                 ...future.rng), started = ...future.startTime, 
[10:58:38.536]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.536]             version = "1.8"), class = "FutureResult")
[10:58:38.536]     }, finally = {
[10:58:38.536]         if (!identical(...future.workdir, getwd())) 
[10:58:38.536]             setwd(...future.workdir)
[10:58:38.536]         {
[10:58:38.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.536]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.536]             }
[10:58:38.536]             base::options(...future.oldOptions)
[10:58:38.536]             if (.Platform$OS.type == "windows") {
[10:58:38.536]                 old_names <- names(...future.oldEnvVars)
[10:58:38.536]                 envs <- base::Sys.getenv()
[10:58:38.536]                 names <- names(envs)
[10:58:38.536]                 common <- intersect(names, old_names)
[10:58:38.536]                 added <- setdiff(names, old_names)
[10:58:38.536]                 removed <- setdiff(old_names, names)
[10:58:38.536]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.536]                   envs[common]]
[10:58:38.536]                 NAMES <- toupper(changed)
[10:58:38.536]                 args <- list()
[10:58:38.536]                 for (kk in seq_along(NAMES)) {
[10:58:38.536]                   name <- changed[[kk]]
[10:58:38.536]                   NAME <- NAMES[[kk]]
[10:58:38.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.536]                     next
[10:58:38.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.536]                 }
[10:58:38.536]                 NAMES <- toupper(added)
[10:58:38.536]                 for (kk in seq_along(NAMES)) {
[10:58:38.536]                   name <- added[[kk]]
[10:58:38.536]                   NAME <- NAMES[[kk]]
[10:58:38.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.536]                     next
[10:58:38.536]                   args[[name]] <- ""
[10:58:38.536]                 }
[10:58:38.536]                 NAMES <- toupper(removed)
[10:58:38.536]                 for (kk in seq_along(NAMES)) {
[10:58:38.536]                   name <- removed[[kk]]
[10:58:38.536]                   NAME <- NAMES[[kk]]
[10:58:38.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.536]                     next
[10:58:38.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.536]                 }
[10:58:38.536]                 if (length(args) > 0) 
[10:58:38.536]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.536]             }
[10:58:38.536]             else {
[10:58:38.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.536]             }
[10:58:38.536]             {
[10:58:38.536]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.536]                   0L) {
[10:58:38.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.536]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.536]                   base::options(opts)
[10:58:38.536]                 }
[10:58:38.536]                 {
[10:58:38.536]                   {
[10:58:38.536]                     NULL
[10:58:38.536]                     RNGkind("Mersenne-Twister")
[10:58:38.536]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:38.536]                       inherits = FALSE)
[10:58:38.536]                   }
[10:58:38.536]                   options(future.plan = NULL)
[10:58:38.536]                   if (is.na(NA_character_)) 
[10:58:38.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.536]                     .init = FALSE)
[10:58:38.536]                 }
[10:58:38.536]             }
[10:58:38.536]         }
[10:58:38.536]     })
[10:58:38.536]     if (TRUE) {
[10:58:38.536]         base::sink(type = "output", split = FALSE)
[10:58:38.536]         if (TRUE) {
[10:58:38.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.536]         }
[10:58:38.536]         else {
[10:58:38.536]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.536]         }
[10:58:38.536]         base::close(...future.stdout)
[10:58:38.536]         ...future.stdout <- NULL
[10:58:38.536]     }
[10:58:38.536]     ...future.result$conditions <- ...future.conditions
[10:58:38.536]     ...future.result$finished <- base::Sys.time()
[10:58:38.536]     ...future.result
[10:58:38.536] }
[10:58:38.538] assign_globals() ...
[10:58:38.538] List of 5
[10:58:38.538]  $ future.call.arguments    : list()
[10:58:38.538]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.538]  $ ...future.FUN            :function (x)  
[10:58:38.538]  $ ...future.elements_ii    :List of 2
[10:58:38.538]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:58:38.538]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:58:38.538]  $ ...future.seeds_ii       : NULL
[10:58:38.538]  $ ...future.globals.maxSize: num Inf
[10:58:38.538]  - attr(*, "resolved")= logi FALSE
[10:58:38.538]  - attr(*, "total_size")= num NA
[10:58:38.538]  - attr(*, "where")=List of 5
[10:58:38.538]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.538]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.538]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.538]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.538]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.538]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.538]  - attr(*, "already-done")= logi TRUE
[10:58:38.543] - copied ‘future.call.arguments’ to environment
[10:58:38.543] - copied ‘...future.FUN’ to environment
[10:58:38.543] - copied ‘...future.elements_ii’ to environment
[10:58:38.543] - copied ‘...future.seeds_ii’ to environment
[10:58:38.543] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.543] assign_globals() ... done
[10:58:38.543] plan(): Setting new future strategy stack:
[10:58:38.543] List of future strategies:
[10:58:38.543] 1. sequential:
[10:58:38.543]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.543]    - tweaked: FALSE
[10:58:38.543]    - call: NULL
[10:58:38.544] plan(): nbrOfWorkers() = 1
[10:58:38.545] plan(): Setting new future strategy stack:
[10:58:38.545] List of future strategies:
[10:58:38.545] 1. sequential:
[10:58:38.545]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.545]    - tweaked: FALSE
[10:58:38.545]    - call: plan(strategy)
[10:58:38.546] plan(): nbrOfWorkers() = 1
[10:58:38.546] SequentialFuture started (and completed)
[10:58:38.546] - Launch lazy future ... done
[10:58:38.546] run() for ‘SequentialFuture’ ... done
[10:58:38.546] Created future:
[10:58:38.546] SequentialFuture:
[10:58:38.546] Label: ‘future_apply-1’
[10:58:38.546] Expression:
[10:58:38.546] {
[10:58:38.546]     do.call(function(...) {
[10:58:38.546]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.546]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.546]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.546]             on.exit(options(oopts), add = TRUE)
[10:58:38.546]         }
[10:58:38.546]         {
[10:58:38.546]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.546]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.546]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.546]             })
[10:58:38.546]         }
[10:58:38.546]     }, args = future.call.arguments)
[10:58:38.546] }
[10:58:38.546] Lazy evaluation: FALSE
[10:58:38.546] Asynchronous evaluation: FALSE
[10:58:38.546] Local evaluation: TRUE
[10:58:38.546] Environment: R_GlobalEnv
[10:58:38.546] Capture standard output: TRUE
[10:58:38.546] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.546] Globals: 5 objects totaling 523 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 175 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.546] Packages: <none>
[10:58:38.546] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.546] Resolved: TRUE
[10:58:38.546] Value: 175 bytes of class ‘list’
[10:58:38.546] Early signaling: FALSE
[10:58:38.546] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.546] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.547] Chunk #1 of 1 ... DONE
[10:58:38.547] Launching 1 futures (chunks) ... DONE
[10:58:38.547] Resolving 1 futures (chunks) ...
[10:58:38.547] resolve() on list ...
[10:58:38.547]  recursive: 0
[10:58:38.547]  length: 1
[10:58:38.547] 
[10:58:38.547] resolved() for ‘SequentialFuture’ ...
[10:58:38.548] - state: ‘finished’
[10:58:38.548] - run: TRUE
[10:58:38.548] - result: ‘FutureResult’
[10:58:38.548] resolved() for ‘SequentialFuture’ ... done
[10:58:38.548] Future #1
[10:58:38.548] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.548] - nx: 1
[10:58:38.548] - relay: TRUE
[10:58:38.548] - stdout: TRUE
[10:58:38.548] - signal: TRUE
[10:58:38.548] - resignal: FALSE
[10:58:38.548] - force: TRUE
[10:58:38.549] - relayed: [n=1] FALSE
[10:58:38.549] - queued futures: [n=1] FALSE
[10:58:38.549]  - until=1
[10:58:38.549]  - relaying element #1
[10:58:38.549] - relayed: [n=1] TRUE
[10:58:38.549] - queued futures: [n=1] TRUE
[10:58:38.549] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.549]  length: 0 (resolved future 1)
[10:58:38.549] Relaying remaining futures
[10:58:38.549] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.549] - nx: 1
[10:58:38.549] - relay: TRUE
[10:58:38.550] - stdout: TRUE
[10:58:38.550] - signal: TRUE
[10:58:38.550] - resignal: FALSE
[10:58:38.550] - force: TRUE
[10:58:38.550] - relayed: [n=1] TRUE
[10:58:38.550] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.550] - relayed: [n=1] TRUE
[10:58:38.550] - queued futures: [n=1] TRUE
[10:58:38.550] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.550] resolve() on list ... DONE
[10:58:38.550]  - Number of value chunks collected: 1
[10:58:38.550] Resolving 1 futures (chunks) ... DONE
[10:58:38.551] Reducing values from 1 chunks ...
[10:58:38.551]  - Number of values collected after concatenation: 2
[10:58:38.551]  - Number of values expected: 2
[10:58:38.551] Reducing values from 1 chunks ... DONE
[10:58:38.551] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:58:38.551] getGlobalsAndPackagesXApply() ...
[10:58:38.551]  - future.globals: TRUE
[10:58:38.551] getGlobalsAndPackages() ...
[10:58:38.551] Searching for globals...
[10:58:38.552] - globals found: [1] ‘FUN’
[10:58:38.552] Searching for globals ... DONE
[10:58:38.552] Resolving globals: FALSE
[10:58:38.553] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:38.553] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:38.553] - globals: [1] ‘FUN’
[10:58:38.553] 
[10:58:38.553] getGlobalsAndPackages() ... DONE
[10:58:38.553]  - globals found/used: [n=1] ‘FUN’
[10:58:38.553]  - needed namespaces: [n=0] 
[10:58:38.554] Finding globals ... DONE
[10:58:38.554]  - use_args: TRUE
[10:58:38.554]  - Getting '...' globals ...
[10:58:38.554] resolve() on list ...
[10:58:38.554]  recursive: 0
[10:58:38.554]  length: 1
[10:58:38.554]  elements: ‘...’
[10:58:38.554]  length: 0 (resolved future 1)
[10:58:38.554] resolve() on list ... DONE
[10:58:38.555]    - '...' content: [n=0] 
[10:58:38.555] List of 1
[10:58:38.555]  $ ...: list()
[10:58:38.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.555]  - attr(*, "where")=List of 1
[10:58:38.555]   ..$ ...:<environment: 0x5635bdbed6f0> 
[10:58:38.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.555]  - attr(*, "resolved")= logi TRUE
[10:58:38.555]  - attr(*, "total_size")= num NA
[10:58:38.557]  - Getting '...' globals ... DONE
[10:58:38.557] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.557] List of 2
[10:58:38.557]  $ ...future.FUN:function (x)  
[10:58:38.557]  $ ...          : list()
[10:58:38.557]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.557]  - attr(*, "where")=List of 2
[10:58:38.557]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.557]   ..$ ...          :<environment: 0x5635bdbed6f0> 
[10:58:38.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.557]  - attr(*, "resolved")= logi FALSE
[10:58:38.557]  - attr(*, "total_size")= num 3563
[10:58:38.559] Packages to be attached in all futures: [n=0] 
[10:58:38.559] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.560] future_lapply() ...
[10:58:38.560] Number of chunks: 1
[10:58:38.560] getGlobalsAndPackagesXApply() ...
[10:58:38.560]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.560]  - use_args: TRUE
[10:58:38.561] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.561] List of 2
[10:58:38.561]  $ ...          : list()
[10:58:38.561]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.561]  $ ...future.FUN:function (x)  
[10:58:38.561]  - attr(*, "where")=List of 2
[10:58:38.561]   ..$ ...          :<environment: 0x5635bdbed6f0> 
[10:58:38.561]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:38.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.561]  - attr(*, "resolved")= logi FALSE
[10:58:38.561]  - attr(*, "total_size")= num NA
[10:58:38.563] Packages to be attached in all futures: [n=0] 
[10:58:38.564] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.564] Number of futures (= number of chunks): 1
[10:58:38.564] Launching 1 futures (chunks) ...
[10:58:38.564] Chunk #1 of 1 ...
[10:58:38.565]  - seeds: <none>
[10:58:38.565]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.565] getGlobalsAndPackages() ...
[10:58:38.565] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.565] Resolving globals: FALSE
[10:58:38.565] Tweak future expression to call with '...' arguments ...
[10:58:38.565] {
[10:58:38.565]     do.call(function(...) {
[10:58:38.565]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.565]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.565]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.565]             on.exit(options(oopts), add = TRUE)
[10:58:38.565]         }
[10:58:38.565]         {
[10:58:38.565]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.565]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.565]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.565]             })
[10:58:38.565]         }
[10:58:38.565]     }, args = future.call.arguments)
[10:58:38.565] }
[10:58:38.566] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.566] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.566] 
[10:58:38.566] getGlobalsAndPackages() ... DONE
[10:58:38.566] run() for ‘Future’ ...
[10:58:38.566] - state: ‘created’
[10:58:38.567] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.567] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.567] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.567]   - Field: ‘label’
[10:58:38.567]   - Field: ‘local’
[10:58:38.567]   - Field: ‘owner’
[10:58:38.567]   - Field: ‘envir’
[10:58:38.567]   - Field: ‘packages’
[10:58:38.567]   - Field: ‘gc’
[10:58:38.568]   - Field: ‘conditions’
[10:58:38.568]   - Field: ‘expr’
[10:58:38.568]   - Field: ‘uuid’
[10:58:38.568]   - Field: ‘seed’
[10:58:38.568]   - Field: ‘version’
[10:58:38.568]   - Field: ‘result’
[10:58:38.568]   - Field: ‘asynchronous’
[10:58:38.568]   - Field: ‘calls’
[10:58:38.568]   - Field: ‘globals’
[10:58:38.568]   - Field: ‘stdout’
[10:58:38.568]   - Field: ‘earlySignal’
[10:58:38.568]   - Field: ‘lazy’
[10:58:38.569]   - Field: ‘state’
[10:58:38.569] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.569] - Launch lazy future ...
[10:58:38.569] Packages needed by the future expression (n = 0): <none>
[10:58:38.569] Packages needed by future strategies (n = 0): <none>
[10:58:38.569] {
[10:58:38.569]     {
[10:58:38.569]         {
[10:58:38.569]             ...future.startTime <- base::Sys.time()
[10:58:38.569]             {
[10:58:38.569]                 {
[10:58:38.569]                   {
[10:58:38.569]                     base::local({
[10:58:38.569]                       has_future <- base::requireNamespace("future", 
[10:58:38.569]                         quietly = TRUE)
[10:58:38.569]                       if (has_future) {
[10:58:38.569]                         ns <- base::getNamespace("future")
[10:58:38.569]                         version <- ns[[".package"]][["version"]]
[10:58:38.569]                         if (is.null(version)) 
[10:58:38.569]                           version <- utils::packageVersion("future")
[10:58:38.569]                       }
[10:58:38.569]                       else {
[10:58:38.569]                         version <- NULL
[10:58:38.569]                       }
[10:58:38.569]                       if (!has_future || version < "1.8.0") {
[10:58:38.569]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.569]                           "", base::R.version$version.string), 
[10:58:38.569]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:38.569]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.569]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.569]                             "release", "version")], collapse = " "), 
[10:58:38.569]                           hostname = base::Sys.info()[["nodename"]])
[10:58:38.569]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.569]                           info)
[10:58:38.569]                         info <- base::paste(info, collapse = "; ")
[10:58:38.569]                         if (!has_future) {
[10:58:38.569]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.569]                             info)
[10:58:38.569]                         }
[10:58:38.569]                         else {
[10:58:38.569]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.569]                             info, version)
[10:58:38.569]                         }
[10:58:38.569]                         base::stop(msg)
[10:58:38.569]                       }
[10:58:38.569]                     })
[10:58:38.569]                   }
[10:58:38.569]                   ...future.strategy.old <- future::plan("list")
[10:58:38.569]                   options(future.plan = NULL)
[10:58:38.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.569]                 }
[10:58:38.569]                 ...future.workdir <- getwd()
[10:58:38.569]             }
[10:58:38.569]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.569]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.569]         }
[10:58:38.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.569]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.569]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.569]             base::names(...future.oldOptions))
[10:58:38.569]     }
[10:58:38.569]     if (FALSE) {
[10:58:38.569]     }
[10:58:38.569]     else {
[10:58:38.569]         if (TRUE) {
[10:58:38.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.569]                 open = "w")
[10:58:38.569]         }
[10:58:38.569]         else {
[10:58:38.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.569]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.569]         }
[10:58:38.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.569]             base::sink(type = "output", split = FALSE)
[10:58:38.569]             base::close(...future.stdout)
[10:58:38.569]         }, add = TRUE)
[10:58:38.569]     }
[10:58:38.569]     ...future.frame <- base::sys.nframe()
[10:58:38.569]     ...future.conditions <- base::list()
[10:58:38.569]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.569]     if (FALSE) {
[10:58:38.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.569]     }
[10:58:38.569]     ...future.result <- base::tryCatch({
[10:58:38.569]         base::withCallingHandlers({
[10:58:38.569]             ...future.value <- base::withVisible(base::local({
[10:58:38.569]                 do.call(function(...) {
[10:58:38.569]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.569]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.569]                     ...future.globals.maxSize)) {
[10:58:38.569]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.569]                     on.exit(options(oopts), add = TRUE)
[10:58:38.569]                   }
[10:58:38.569]                   {
[10:58:38.569]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.569]                       FUN = function(jj) {
[10:58:38.569]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.569]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.569]                       })
[10:58:38.569]                   }
[10:58:38.569]                 }, args = future.call.arguments)
[10:58:38.569]             }))
[10:58:38.569]             future::FutureResult(value = ...future.value$value, 
[10:58:38.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.569]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.569]                     ...future.globalenv.names))
[10:58:38.569]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.569]         }, condition = base::local({
[10:58:38.569]             c <- base::c
[10:58:38.569]             inherits <- base::inherits
[10:58:38.569]             invokeRestart <- base::invokeRestart
[10:58:38.569]             length <- base::length
[10:58:38.569]             list <- base::list
[10:58:38.569]             seq.int <- base::seq.int
[10:58:38.569]             signalCondition <- base::signalCondition
[10:58:38.569]             sys.calls <- base::sys.calls
[10:58:38.569]             `[[` <- base::`[[`
[10:58:38.569]             `+` <- base::`+`
[10:58:38.569]             `<<-` <- base::`<<-`
[10:58:38.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.569]                   3L)]
[10:58:38.569]             }
[10:58:38.569]             function(cond) {
[10:58:38.569]                 is_error <- inherits(cond, "error")
[10:58:38.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.569]                   NULL)
[10:58:38.569]                 if (is_error) {
[10:58:38.569]                   sessionInformation <- function() {
[10:58:38.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.569]                       search = base::search(), system = base::Sys.info())
[10:58:38.569]                   }
[10:58:38.569]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.569]                     cond$call), session = sessionInformation(), 
[10:58:38.569]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.569]                   signalCondition(cond)
[10:58:38.569]                 }
[10:58:38.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.569]                 "immediateCondition"))) {
[10:58:38.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.569]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.569]                   if (TRUE && !signal) {
[10:58:38.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.569]                     {
[10:58:38.569]                       inherits <- base::inherits
[10:58:38.569]                       invokeRestart <- base::invokeRestart
[10:58:38.569]                       is.null <- base::is.null
[10:58:38.569]                       muffled <- FALSE
[10:58:38.569]                       if (inherits(cond, "message")) {
[10:58:38.569]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.569]                         if (muffled) 
[10:58:38.569]                           invokeRestart("muffleMessage")
[10:58:38.569]                       }
[10:58:38.569]                       else if (inherits(cond, "warning")) {
[10:58:38.569]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.569]                         if (muffled) 
[10:58:38.569]                           invokeRestart("muffleWarning")
[10:58:38.569]                       }
[10:58:38.569]                       else if (inherits(cond, "condition")) {
[10:58:38.569]                         if (!is.null(pattern)) {
[10:58:38.569]                           computeRestarts <- base::computeRestarts
[10:58:38.569]                           grepl <- base::grepl
[10:58:38.569]                           restarts <- computeRestarts(cond)
[10:58:38.569]                           for (restart in restarts) {
[10:58:38.569]                             name <- restart$name
[10:58:38.569]                             if (is.null(name)) 
[10:58:38.569]                               next
[10:58:38.569]                             if (!grepl(pattern, name)) 
[10:58:38.569]                               next
[10:58:38.569]                             invokeRestart(restart)
[10:58:38.569]                             muffled <- TRUE
[10:58:38.569]                             break
[10:58:38.569]                           }
[10:58:38.569]                         }
[10:58:38.569]                       }
[10:58:38.569]                       invisible(muffled)
[10:58:38.569]                     }
[10:58:38.569]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.569]                   }
[10:58:38.569]                 }
[10:58:38.569]                 else {
[10:58:38.569]                   if (TRUE) {
[10:58:38.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.569]                     {
[10:58:38.569]                       inherits <- base::inherits
[10:58:38.569]                       invokeRestart <- base::invokeRestart
[10:58:38.569]                       is.null <- base::is.null
[10:58:38.569]                       muffled <- FALSE
[10:58:38.569]                       if (inherits(cond, "message")) {
[10:58:38.569]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.569]                         if (muffled) 
[10:58:38.569]                           invokeRestart("muffleMessage")
[10:58:38.569]                       }
[10:58:38.569]                       else if (inherits(cond, "warning")) {
[10:58:38.569]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.569]                         if (muffled) 
[10:58:38.569]                           invokeRestart("muffleWarning")
[10:58:38.569]                       }
[10:58:38.569]                       else if (inherits(cond, "condition")) {
[10:58:38.569]                         if (!is.null(pattern)) {
[10:58:38.569]                           computeRestarts <- base::computeRestarts
[10:58:38.569]                           grepl <- base::grepl
[10:58:38.569]                           restarts <- computeRestarts(cond)
[10:58:38.569]                           for (restart in restarts) {
[10:58:38.569]                             name <- restart$name
[10:58:38.569]                             if (is.null(name)) 
[10:58:38.569]                               next
[10:58:38.569]                             if (!grepl(pattern, name)) 
[10:58:38.569]                               next
[10:58:38.569]                             invokeRestart(restart)
[10:58:38.569]                             muffled <- TRUE
[10:58:38.569]                             break
[10:58:38.569]                           }
[10:58:38.569]                         }
[10:58:38.569]                       }
[10:58:38.569]                       invisible(muffled)
[10:58:38.569]                     }
[10:58:38.569]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.569]                   }
[10:58:38.569]                 }
[10:58:38.569]             }
[10:58:38.569]         }))
[10:58:38.569]     }, error = function(ex) {
[10:58:38.569]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.569]                 ...future.rng), started = ...future.startTime, 
[10:58:38.569]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.569]             version = "1.8"), class = "FutureResult")
[10:58:38.569]     }, finally = {
[10:58:38.569]         if (!identical(...future.workdir, getwd())) 
[10:58:38.569]             setwd(...future.workdir)
[10:58:38.569]         {
[10:58:38.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.569]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.569]             }
[10:58:38.569]             base::options(...future.oldOptions)
[10:58:38.569]             if (.Platform$OS.type == "windows") {
[10:58:38.569]                 old_names <- names(...future.oldEnvVars)
[10:58:38.569]                 envs <- base::Sys.getenv()
[10:58:38.569]                 names <- names(envs)
[10:58:38.569]                 common <- intersect(names, old_names)
[10:58:38.569]                 added <- setdiff(names, old_names)
[10:58:38.569]                 removed <- setdiff(old_names, names)
[10:58:38.569]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.569]                   envs[common]]
[10:58:38.569]                 NAMES <- toupper(changed)
[10:58:38.569]                 args <- list()
[10:58:38.569]                 for (kk in seq_along(NAMES)) {
[10:58:38.569]                   name <- changed[[kk]]
[10:58:38.569]                   NAME <- NAMES[[kk]]
[10:58:38.569]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.569]                     next
[10:58:38.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.569]                 }
[10:58:38.569]                 NAMES <- toupper(added)
[10:58:38.569]                 for (kk in seq_along(NAMES)) {
[10:58:38.569]                   name <- added[[kk]]
[10:58:38.569]                   NAME <- NAMES[[kk]]
[10:58:38.569]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.569]                     next
[10:58:38.569]                   args[[name]] <- ""
[10:58:38.569]                 }
[10:58:38.569]                 NAMES <- toupper(removed)
[10:58:38.569]                 for (kk in seq_along(NAMES)) {
[10:58:38.569]                   name <- removed[[kk]]
[10:58:38.569]                   NAME <- NAMES[[kk]]
[10:58:38.569]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.569]                     next
[10:58:38.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.569]                 }
[10:58:38.569]                 if (length(args) > 0) 
[10:58:38.569]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.569]             }
[10:58:38.569]             else {
[10:58:38.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.569]             }
[10:58:38.569]             {
[10:58:38.569]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.569]                   0L) {
[10:58:38.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.569]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.569]                   base::options(opts)
[10:58:38.569]                 }
[10:58:38.569]                 {
[10:58:38.569]                   {
[10:58:38.569]                     NULL
[10:58:38.569]                     RNGkind("Mersenne-Twister")
[10:58:38.569]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:38.569]                       inherits = FALSE)
[10:58:38.569]                   }
[10:58:38.569]                   options(future.plan = NULL)
[10:58:38.569]                   if (is.na(NA_character_)) 
[10:58:38.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.569]                     .init = FALSE)
[10:58:38.569]                 }
[10:58:38.569]             }
[10:58:38.569]         }
[10:58:38.569]     })
[10:58:38.569]     if (TRUE) {
[10:58:38.569]         base::sink(type = "output", split = FALSE)
[10:58:38.569]         if (TRUE) {
[10:58:38.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.569]         }
[10:58:38.569]         else {
[10:58:38.569]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.569]         }
[10:58:38.569]         base::close(...future.stdout)
[10:58:38.569]         ...future.stdout <- NULL
[10:58:38.569]     }
[10:58:38.569]     ...future.result$conditions <- ...future.conditions
[10:58:38.569]     ...future.result$finished <- base::Sys.time()
[10:58:38.569]     ...future.result
[10:58:38.569] }
[10:58:38.571] assign_globals() ...
[10:58:38.571] List of 5
[10:58:38.571]  $ future.call.arguments    : list()
[10:58:38.571]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.571]  $ ...future.FUN            :function (x)  
[10:58:38.571]  $ ...future.elements_ii    :List of 6
[10:58:38.571]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:58:38.571]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:58:38.571]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:58:38.571]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:58:38.571]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:58:38.571]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:58:38.571]  $ ...future.seeds_ii       : NULL
[10:58:38.571]  $ ...future.globals.maxSize: num Inf
[10:58:38.571]  - attr(*, "resolved")= logi FALSE
[10:58:38.571]  - attr(*, "total_size")= num NA
[10:58:38.571]  - attr(*, "where")=List of 5
[10:58:38.571]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.571]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.571]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.571]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.571]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.571]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.571]  - attr(*, "already-done")= logi TRUE
[10:58:38.577] - copied ‘future.call.arguments’ to environment
[10:58:38.577] - copied ‘...future.FUN’ to environment
[10:58:38.577] - copied ‘...future.elements_ii’ to environment
[10:58:38.577] - copied ‘...future.seeds_ii’ to environment
[10:58:38.577] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.577] assign_globals() ... done
[10:58:38.578] plan(): Setting new future strategy stack:
[10:58:38.578] List of future strategies:
[10:58:38.578] 1. sequential:
[10:58:38.578]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.578]    - tweaked: FALSE
[10:58:38.578]    - call: NULL
[10:58:38.578] plan(): nbrOfWorkers() = 1
[10:58:38.579] plan(): Setting new future strategy stack:
[10:58:38.579] List of future strategies:
[10:58:38.579] 1. sequential:
[10:58:38.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.579]    - tweaked: FALSE
[10:58:38.579]    - call: plan(strategy)
[10:58:38.579] plan(): nbrOfWorkers() = 1
[10:58:38.579] SequentialFuture started (and completed)
[10:58:38.579] - Launch lazy future ... done
[10:58:38.580] run() for ‘SequentialFuture’ ... done
[10:58:38.580] Created future:
[10:58:38.580] SequentialFuture:
[10:58:38.580] Label: ‘future_apply-1’
[10:58:38.580] Expression:
[10:58:38.580] {
[10:58:38.580]     do.call(function(...) {
[10:58:38.580]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.580]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.580]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.580]             on.exit(options(oopts), add = TRUE)
[10:58:38.580]         }
[10:58:38.580]         {
[10:58:38.580]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.580]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.580]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.580]             })
[10:58:38.580]         }
[10:58:38.580]     }, args = future.call.arguments)
[10:58:38.580] }
[10:58:38.580] Lazy evaluation: FALSE
[10:58:38.580] Asynchronous evaluation: FALSE
[10:58:38.580] Local evaluation: TRUE
[10:58:38.580] Environment: R_GlobalEnv
[10:58:38.580] Capture standard output: TRUE
[10:58:38.580] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.580] Globals: 5 objects totaling 811 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 463 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.580] Packages: <none>
[10:58:38.580] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.580] Resolved: TRUE
[10:58:38.580] Value: 463 bytes of class ‘list’
[10:58:38.580] Early signaling: FALSE
[10:58:38.580] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.580] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.580] Chunk #1 of 1 ... DONE
[10:58:38.581] Launching 1 futures (chunks) ... DONE
[10:58:38.581] Resolving 1 futures (chunks) ...
[10:58:38.581] resolve() on list ...
[10:58:38.581]  recursive: 0
[10:58:38.581]  length: 1
[10:58:38.581] 
[10:58:38.581] resolved() for ‘SequentialFuture’ ...
[10:58:38.581] - state: ‘finished’
[10:58:38.581] - run: TRUE
[10:58:38.581] - result: ‘FutureResult’
[10:58:38.581] resolved() for ‘SequentialFuture’ ... done
[10:58:38.582] Future #1
[10:58:38.582] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.582] - nx: 1
[10:58:38.582] - relay: TRUE
[10:58:38.582] - stdout: TRUE
[10:58:38.582] - signal: TRUE
[10:58:38.582] - resignal: FALSE
[10:58:38.582] - force: TRUE
[10:58:38.582] - relayed: [n=1] FALSE
[10:58:38.582] - queued futures: [n=1] FALSE
[10:58:38.582]  - until=1
[10:58:38.582]  - relaying element #1
[10:58:38.583] - relayed: [n=1] TRUE
[10:58:38.583] - queued futures: [n=1] TRUE
[10:58:38.583] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.583]  length: 0 (resolved future 1)
[10:58:38.583] Relaying remaining futures
[10:58:38.583] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.583] - nx: 1
[10:58:38.583] - relay: TRUE
[10:58:38.583] - stdout: TRUE
[10:58:38.583] - signal: TRUE
[10:58:38.583] - resignal: FALSE
[10:58:38.583] - force: TRUE
[10:58:38.584] - relayed: [n=1] TRUE
[10:58:38.584] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.584] - relayed: [n=1] TRUE
[10:58:38.584] - queued futures: [n=1] TRUE
[10:58:38.584] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.584] resolve() on list ... DONE
[10:58:38.584]  - Number of value chunks collected: 1
[10:58:38.584] Resolving 1 futures (chunks) ... DONE
[10:58:38.584] Reducing values from 1 chunks ...
[10:58:38.584]  - Number of values collected after concatenation: 6
[10:58:38.584]  - Number of values expected: 6
[10:58:38.585] Reducing values from 1 chunks ... DONE
[10:58:38.585] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:58:38.585] getGlobalsAndPackagesXApply() ...
[10:58:38.585]  - future.globals: TRUE
[10:58:38.585] getGlobalsAndPackages() ...
[10:58:38.586] Searching for globals...
[10:58:38.587] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:58:38.587] Searching for globals ... DONE
[10:58:38.588] Resolving globals: FALSE
[10:58:38.588] The total size of the 1 globals is 411 bytes (411 bytes)
[10:58:38.588] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 411 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (411 bytes of class ‘function’)
[10:58:38.588] - globals: [1] ‘FUN’
[10:58:38.588] 
[10:58:38.588] getGlobalsAndPackages() ... DONE
[10:58:38.589]  - globals found/used: [n=1] ‘FUN’
[10:58:38.589]  - needed namespaces: [n=0] 
[10:58:38.589] Finding globals ... DONE
[10:58:38.589]  - use_args: TRUE
[10:58:38.589]  - Getting '...' globals ...
[10:58:38.589] resolve() on list ...
[10:58:38.589]  recursive: 0
[10:58:38.589]  length: 1
[10:58:38.589]  elements: ‘...’
[10:58:38.590]  length: 0 (resolved future 1)
[10:58:38.590] resolve() on list ... DONE
[10:58:38.590]    - '...' content: [n=0] 
[10:58:38.590] List of 1
[10:58:38.590]  $ ...: list()
[10:58:38.590]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.590]  - attr(*, "where")=List of 1
[10:58:38.590]   ..$ ...:<environment: 0x5635bfb84020> 
[10:58:38.590]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.590]  - attr(*, "resolved")= logi TRUE
[10:58:38.590]  - attr(*, "total_size")= num NA
[10:58:38.592]  - Getting '...' globals ... DONE
[10:58:38.592] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.592] List of 2
[10:58:38.592]  $ ...future.FUN:function (x)  
[10:58:38.592]  $ ...          : list()
[10:58:38.592]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.592]  - attr(*, "where")=List of 2
[10:58:38.592]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.592]   ..$ ...          :<environment: 0x5635bfb84020> 
[10:58:38.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.592]  - attr(*, "resolved")= logi FALSE
[10:58:38.592]  - attr(*, "total_size")= num 3672
[10:58:38.595] Packages to be attached in all futures: [n=0] 
[10:58:38.595] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.595] future_lapply() ...
[10:58:38.596] Number of chunks: 1
[10:58:38.596] getGlobalsAndPackagesXApply() ...
[10:58:38.596]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.596]  - use_args: TRUE
[10:58:38.596] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.596] List of 2
[10:58:38.596]  $ ...          : list()
[10:58:38.596]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.596]  $ ...future.FUN:function (x)  
[10:58:38.596]  - attr(*, "where")=List of 2
[10:58:38.596]   ..$ ...          :<environment: 0x5635bfb84020> 
[10:58:38.596]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:58:38.596]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.596]  - attr(*, "resolved")= logi FALSE
[10:58:38.596]  - attr(*, "total_size")= num NA
[10:58:38.599] Packages to be attached in all futures: [n=0] 
[10:58:38.599] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.599] Number of futures (= number of chunks): 1
[10:58:38.599] Launching 1 futures (chunks) ...
[10:58:38.599] Chunk #1 of 1 ...
[10:58:38.599]  - seeds: <none>
[10:58:38.599]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.599] getGlobalsAndPackages() ...
[10:58:38.599] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.600] Resolving globals: FALSE
[10:58:38.600] Tweak future expression to call with '...' arguments ...
[10:58:38.600] {
[10:58:38.600]     do.call(function(...) {
[10:58:38.600]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.600]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.600]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.600]             on.exit(options(oopts), add = TRUE)
[10:58:38.600]         }
[10:58:38.600]         {
[10:58:38.600]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.600]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.600]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.600]             })
[10:58:38.600]         }
[10:58:38.600]     }, args = future.call.arguments)
[10:58:38.600] }
[10:58:38.600] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.600] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.600] 
[10:58:38.600] getGlobalsAndPackages() ... DONE
[10:58:38.601] run() for ‘Future’ ...
[10:58:38.601] - state: ‘created’
[10:58:38.601] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.601] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.601] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.601]   - Field: ‘label’
[10:58:38.602]   - Field: ‘local’
[10:58:38.602]   - Field: ‘owner’
[10:58:38.602]   - Field: ‘envir’
[10:58:38.602]   - Field: ‘packages’
[10:58:38.602]   - Field: ‘gc’
[10:58:38.602]   - Field: ‘conditions’
[10:58:38.602]   - Field: ‘expr’
[10:58:38.602]   - Field: ‘uuid’
[10:58:38.602]   - Field: ‘seed’
[10:58:38.602]   - Field: ‘version’
[10:58:38.602]   - Field: ‘result’
[10:58:38.602]   - Field: ‘asynchronous’
[10:58:38.602]   - Field: ‘calls’
[10:58:38.603]   - Field: ‘globals’
[10:58:38.603]   - Field: ‘stdout’
[10:58:38.603]   - Field: ‘earlySignal’
[10:58:38.603]   - Field: ‘lazy’
[10:58:38.603]   - Field: ‘state’
[10:58:38.603] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.603] - Launch lazy future ...
[10:58:38.603] Packages needed by the future expression (n = 0): <none>
[10:58:38.603] Packages needed by future strategies (n = 0): <none>
[10:58:38.604] {
[10:58:38.604]     {
[10:58:38.604]         {
[10:58:38.604]             ...future.startTime <- base::Sys.time()
[10:58:38.604]             {
[10:58:38.604]                 {
[10:58:38.604]                   {
[10:58:38.604]                     base::local({
[10:58:38.604]                       has_future <- base::requireNamespace("future", 
[10:58:38.604]                         quietly = TRUE)
[10:58:38.604]                       if (has_future) {
[10:58:38.604]                         ns <- base::getNamespace("future")
[10:58:38.604]                         version <- ns[[".package"]][["version"]]
[10:58:38.604]                         if (is.null(version)) 
[10:58:38.604]                           version <- utils::packageVersion("future")
[10:58:38.604]                       }
[10:58:38.604]                       else {
[10:58:38.604]                         version <- NULL
[10:58:38.604]                       }
[10:58:38.604]                       if (!has_future || version < "1.8.0") {
[10:58:38.604]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.604]                           "", base::R.version$version.string), 
[10:58:38.604]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:38.604]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.604]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.604]                             "release", "version")], collapse = " "), 
[10:58:38.604]                           hostname = base::Sys.info()[["nodename"]])
[10:58:38.604]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.604]                           info)
[10:58:38.604]                         info <- base::paste(info, collapse = "; ")
[10:58:38.604]                         if (!has_future) {
[10:58:38.604]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.604]                             info)
[10:58:38.604]                         }
[10:58:38.604]                         else {
[10:58:38.604]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.604]                             info, version)
[10:58:38.604]                         }
[10:58:38.604]                         base::stop(msg)
[10:58:38.604]                       }
[10:58:38.604]                     })
[10:58:38.604]                   }
[10:58:38.604]                   ...future.strategy.old <- future::plan("list")
[10:58:38.604]                   options(future.plan = NULL)
[10:58:38.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.604]                 }
[10:58:38.604]                 ...future.workdir <- getwd()
[10:58:38.604]             }
[10:58:38.604]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.604]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.604]         }
[10:58:38.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.604]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.604]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.604]             base::names(...future.oldOptions))
[10:58:38.604]     }
[10:58:38.604]     if (FALSE) {
[10:58:38.604]     }
[10:58:38.604]     else {
[10:58:38.604]         if (TRUE) {
[10:58:38.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.604]                 open = "w")
[10:58:38.604]         }
[10:58:38.604]         else {
[10:58:38.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.604]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.604]         }
[10:58:38.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.604]             base::sink(type = "output", split = FALSE)
[10:58:38.604]             base::close(...future.stdout)
[10:58:38.604]         }, add = TRUE)
[10:58:38.604]     }
[10:58:38.604]     ...future.frame <- base::sys.nframe()
[10:58:38.604]     ...future.conditions <- base::list()
[10:58:38.604]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.604]     if (FALSE) {
[10:58:38.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.604]     }
[10:58:38.604]     ...future.result <- base::tryCatch({
[10:58:38.604]         base::withCallingHandlers({
[10:58:38.604]             ...future.value <- base::withVisible(base::local({
[10:58:38.604]                 do.call(function(...) {
[10:58:38.604]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.604]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.604]                     ...future.globals.maxSize)) {
[10:58:38.604]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.604]                     on.exit(options(oopts), add = TRUE)
[10:58:38.604]                   }
[10:58:38.604]                   {
[10:58:38.604]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.604]                       FUN = function(jj) {
[10:58:38.604]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.604]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.604]                       })
[10:58:38.604]                   }
[10:58:38.604]                 }, args = future.call.arguments)
[10:58:38.604]             }))
[10:58:38.604]             future::FutureResult(value = ...future.value$value, 
[10:58:38.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.604]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.604]                     ...future.globalenv.names))
[10:58:38.604]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.604]         }, condition = base::local({
[10:58:38.604]             c <- base::c
[10:58:38.604]             inherits <- base::inherits
[10:58:38.604]             invokeRestart <- base::invokeRestart
[10:58:38.604]             length <- base::length
[10:58:38.604]             list <- base::list
[10:58:38.604]             seq.int <- base::seq.int
[10:58:38.604]             signalCondition <- base::signalCondition
[10:58:38.604]             sys.calls <- base::sys.calls
[10:58:38.604]             `[[` <- base::`[[`
[10:58:38.604]             `+` <- base::`+`
[10:58:38.604]             `<<-` <- base::`<<-`
[10:58:38.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.604]                   3L)]
[10:58:38.604]             }
[10:58:38.604]             function(cond) {
[10:58:38.604]                 is_error <- inherits(cond, "error")
[10:58:38.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.604]                   NULL)
[10:58:38.604]                 if (is_error) {
[10:58:38.604]                   sessionInformation <- function() {
[10:58:38.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.604]                       search = base::search(), system = base::Sys.info())
[10:58:38.604]                   }
[10:58:38.604]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.604]                     cond$call), session = sessionInformation(), 
[10:58:38.604]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.604]                   signalCondition(cond)
[10:58:38.604]                 }
[10:58:38.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.604]                 "immediateCondition"))) {
[10:58:38.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.604]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.604]                   if (TRUE && !signal) {
[10:58:38.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.604]                     {
[10:58:38.604]                       inherits <- base::inherits
[10:58:38.604]                       invokeRestart <- base::invokeRestart
[10:58:38.604]                       is.null <- base::is.null
[10:58:38.604]                       muffled <- FALSE
[10:58:38.604]                       if (inherits(cond, "message")) {
[10:58:38.604]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.604]                         if (muffled) 
[10:58:38.604]                           invokeRestart("muffleMessage")
[10:58:38.604]                       }
[10:58:38.604]                       else if (inherits(cond, "warning")) {
[10:58:38.604]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.604]                         if (muffled) 
[10:58:38.604]                           invokeRestart("muffleWarning")
[10:58:38.604]                       }
[10:58:38.604]                       else if (inherits(cond, "condition")) {
[10:58:38.604]                         if (!is.null(pattern)) {
[10:58:38.604]                           computeRestarts <- base::computeRestarts
[10:58:38.604]                           grepl <- base::grepl
[10:58:38.604]                           restarts <- computeRestarts(cond)
[10:58:38.604]                           for (restart in restarts) {
[10:58:38.604]                             name <- restart$name
[10:58:38.604]                             if (is.null(name)) 
[10:58:38.604]                               next
[10:58:38.604]                             if (!grepl(pattern, name)) 
[10:58:38.604]                               next
[10:58:38.604]                             invokeRestart(restart)
[10:58:38.604]                             muffled <- TRUE
[10:58:38.604]                             break
[10:58:38.604]                           }
[10:58:38.604]                         }
[10:58:38.604]                       }
[10:58:38.604]                       invisible(muffled)
[10:58:38.604]                     }
[10:58:38.604]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.604]                   }
[10:58:38.604]                 }
[10:58:38.604]                 else {
[10:58:38.604]                   if (TRUE) {
[10:58:38.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.604]                     {
[10:58:38.604]                       inherits <- base::inherits
[10:58:38.604]                       invokeRestart <- base::invokeRestart
[10:58:38.604]                       is.null <- base::is.null
[10:58:38.604]                       muffled <- FALSE
[10:58:38.604]                       if (inherits(cond, "message")) {
[10:58:38.604]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.604]                         if (muffled) 
[10:58:38.604]                           invokeRestart("muffleMessage")
[10:58:38.604]                       }
[10:58:38.604]                       else if (inherits(cond, "warning")) {
[10:58:38.604]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.604]                         if (muffled) 
[10:58:38.604]                           invokeRestart("muffleWarning")
[10:58:38.604]                       }
[10:58:38.604]                       else if (inherits(cond, "condition")) {
[10:58:38.604]                         if (!is.null(pattern)) {
[10:58:38.604]                           computeRestarts <- base::computeRestarts
[10:58:38.604]                           grepl <- base::grepl
[10:58:38.604]                           restarts <- computeRestarts(cond)
[10:58:38.604]                           for (restart in restarts) {
[10:58:38.604]                             name <- restart$name
[10:58:38.604]                             if (is.null(name)) 
[10:58:38.604]                               next
[10:58:38.604]                             if (!grepl(pattern, name)) 
[10:58:38.604]                               next
[10:58:38.604]                             invokeRestart(restart)
[10:58:38.604]                             muffled <- TRUE
[10:58:38.604]                             break
[10:58:38.604]                           }
[10:58:38.604]                         }
[10:58:38.604]                       }
[10:58:38.604]                       invisible(muffled)
[10:58:38.604]                     }
[10:58:38.604]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.604]                   }
[10:58:38.604]                 }
[10:58:38.604]             }
[10:58:38.604]         }))
[10:58:38.604]     }, error = function(ex) {
[10:58:38.604]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.604]                 ...future.rng), started = ...future.startTime, 
[10:58:38.604]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.604]             version = "1.8"), class = "FutureResult")
[10:58:38.604]     }, finally = {
[10:58:38.604]         if (!identical(...future.workdir, getwd())) 
[10:58:38.604]             setwd(...future.workdir)
[10:58:38.604]         {
[10:58:38.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.604]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.604]             }
[10:58:38.604]             base::options(...future.oldOptions)
[10:58:38.604]             if (.Platform$OS.type == "windows") {
[10:58:38.604]                 old_names <- names(...future.oldEnvVars)
[10:58:38.604]                 envs <- base::Sys.getenv()
[10:58:38.604]                 names <- names(envs)
[10:58:38.604]                 common <- intersect(names, old_names)
[10:58:38.604]                 added <- setdiff(names, old_names)
[10:58:38.604]                 removed <- setdiff(old_names, names)
[10:58:38.604]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.604]                   envs[common]]
[10:58:38.604]                 NAMES <- toupper(changed)
[10:58:38.604]                 args <- list()
[10:58:38.604]                 for (kk in seq_along(NAMES)) {
[10:58:38.604]                   name <- changed[[kk]]
[10:58:38.604]                   NAME <- NAMES[[kk]]
[10:58:38.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.604]                     next
[10:58:38.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.604]                 }
[10:58:38.604]                 NAMES <- toupper(added)
[10:58:38.604]                 for (kk in seq_along(NAMES)) {
[10:58:38.604]                   name <- added[[kk]]
[10:58:38.604]                   NAME <- NAMES[[kk]]
[10:58:38.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.604]                     next
[10:58:38.604]                   args[[name]] <- ""
[10:58:38.604]                 }
[10:58:38.604]                 NAMES <- toupper(removed)
[10:58:38.604]                 for (kk in seq_along(NAMES)) {
[10:58:38.604]                   name <- removed[[kk]]
[10:58:38.604]                   NAME <- NAMES[[kk]]
[10:58:38.604]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.604]                     next
[10:58:38.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.604]                 }
[10:58:38.604]                 if (length(args) > 0) 
[10:58:38.604]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.604]             }
[10:58:38.604]             else {
[10:58:38.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.604]             }
[10:58:38.604]             {
[10:58:38.604]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.604]                   0L) {
[10:58:38.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.604]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.604]                   base::options(opts)
[10:58:38.604]                 }
[10:58:38.604]                 {
[10:58:38.604]                   {
[10:58:38.604]                     NULL
[10:58:38.604]                     RNGkind("Mersenne-Twister")
[10:58:38.604]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:38.604]                       inherits = FALSE)
[10:58:38.604]                   }
[10:58:38.604]                   options(future.plan = NULL)
[10:58:38.604]                   if (is.na(NA_character_)) 
[10:58:38.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.604]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.604]                     .init = FALSE)
[10:58:38.604]                 }
[10:58:38.604]             }
[10:58:38.604]         }
[10:58:38.604]     })
[10:58:38.604]     if (TRUE) {
[10:58:38.604]         base::sink(type = "output", split = FALSE)
[10:58:38.604]         if (TRUE) {
[10:58:38.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.604]         }
[10:58:38.604]         else {
[10:58:38.604]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.604]         }
[10:58:38.604]         base::close(...future.stdout)
[10:58:38.604]         ...future.stdout <- NULL
[10:58:38.604]     }
[10:58:38.604]     ...future.result$conditions <- ...future.conditions
[10:58:38.604]     ...future.result$finished <- base::Sys.time()
[10:58:38.604]     ...future.result
[10:58:38.604] }
[10:58:38.605] assign_globals() ...
[10:58:38.605] List of 5
[10:58:38.605]  $ future.call.arguments    : list()
[10:58:38.605]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.605]  $ ...future.FUN            :function (x)  
[10:58:38.605]  $ ...future.elements_ii    :List of 6
[10:58:38.605]   ..$ : int [1:4] 1 7 13 19
[10:58:38.605]   ..$ : int [1:4] 2 8 14 20
[10:58:38.605]   ..$ : int [1:4] 3 9 15 21
[10:58:38.605]   ..$ : int [1:4] 4 10 16 22
[10:58:38.605]   ..$ : int [1:4] 5 11 17 23
[10:58:38.605]   ..$ : int [1:4] 6 12 18 24
[10:58:38.605]  $ ...future.seeds_ii       : NULL
[10:58:38.605]  $ ...future.globals.maxSize: num Inf
[10:58:38.605]  - attr(*, "resolved")= logi FALSE
[10:58:38.605]  - attr(*, "total_size")= num NA
[10:58:38.605]  - attr(*, "where")=List of 5
[10:58:38.605]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.605]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.605]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.605]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.605]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.605]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.605]  - attr(*, "already-done")= logi TRUE
[10:58:38.612] - copied ‘future.call.arguments’ to environment
[10:58:38.612] - reassign environment for ‘...future.FUN’
[10:58:38.612] - copied ‘...future.FUN’ to environment
[10:58:38.612] - copied ‘...future.elements_ii’ to environment
[10:58:38.612] - copied ‘...future.seeds_ii’ to environment
[10:58:38.613] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.613] assign_globals() ... done
[10:58:38.613] plan(): Setting new future strategy stack:
[10:58:38.613] List of future strategies:
[10:58:38.613] 1. sequential:
[10:58:38.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.613]    - tweaked: FALSE
[10:58:38.613]    - call: NULL
[10:58:38.613] plan(): nbrOfWorkers() = 1
[10:58:38.614] plan(): Setting new future strategy stack:
[10:58:38.614] List of future strategies:
[10:58:38.614] 1. sequential:
[10:58:38.614]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.614]    - tweaked: FALSE
[10:58:38.614]    - call: plan(strategy)
[10:58:38.615] plan(): nbrOfWorkers() = 1
[10:58:38.615] SequentialFuture started (and completed)
[10:58:38.615] - Launch lazy future ... done
[10:58:38.615] run() for ‘SequentialFuture’ ... done
[10:58:38.615] Created future:
[10:58:38.615] SequentialFuture:
[10:58:38.615] Label: ‘future_apply-1’
[10:58:38.615] Expression:
[10:58:38.615] {
[10:58:38.615]     do.call(function(...) {
[10:58:38.615]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.615]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.615]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.615]             on.exit(options(oopts), add = TRUE)
[10:58:38.615]         }
[10:58:38.615]         {
[10:58:38.615]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.615]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.615]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.615]             })
[10:58:38.615]         }
[10:58:38.615]     }, args = future.call.arguments)
[10:58:38.615] }
[10:58:38.615] Lazy evaluation: FALSE
[10:58:38.615] Asynchronous evaluation: FALSE
[10:58:38.615] Local evaluation: TRUE
[10:58:38.615] Environment: R_GlobalEnv
[10:58:38.615] Capture standard output: TRUE
[10:58:38.615] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.615] Globals: 5 objects totaling 749 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 175 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.615] Packages: <none>
[10:58:38.615] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.615] Resolved: TRUE
[10:58:38.615] Value: 521 bytes of class ‘list’
[10:58:38.615] Early signaling: FALSE
[10:58:38.615] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.615] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.616] Chunk #1 of 1 ... DONE
[10:58:38.616] Launching 1 futures (chunks) ... DONE
[10:58:38.616] Resolving 1 futures (chunks) ...
[10:58:38.616] resolve() on list ...
[10:58:38.616]  recursive: 0
[10:58:38.616]  length: 1
[10:58:38.616] 
[10:58:38.616] resolved() for ‘SequentialFuture’ ...
[10:58:38.616] - state: ‘finished’
[10:58:38.617] - run: TRUE
[10:58:38.617] - result: ‘FutureResult’
[10:58:38.617] resolved() for ‘SequentialFuture’ ... done
[10:58:38.617] Future #1
[10:58:38.617] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.617] - nx: 1
[10:58:38.617] - relay: TRUE
[10:58:38.617] - stdout: TRUE
[10:58:38.617] - signal: TRUE
[10:58:38.617] - resignal: FALSE
[10:58:38.617] - force: TRUE
[10:58:38.617] - relayed: [n=1] FALSE
[10:58:38.617] - queued futures: [n=1] FALSE
[10:58:38.618]  - until=1
[10:58:38.618]  - relaying element #1
[10:58:38.618] - relayed: [n=1] TRUE
[10:58:38.618] - queued futures: [n=1] TRUE
[10:58:38.618] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.618]  length: 0 (resolved future 1)
[10:58:38.618] Relaying remaining futures
[10:58:38.618] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.618] - nx: 1
[10:58:38.618] - relay: TRUE
[10:58:38.618] - stdout: TRUE
[10:58:38.618] - signal: TRUE
[10:58:38.619] - resignal: FALSE
[10:58:38.619] - force: TRUE
[10:58:38.619] - relayed: [n=1] TRUE
[10:58:38.619] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.619] - relayed: [n=1] TRUE
[10:58:38.619] - queued futures: [n=1] TRUE
[10:58:38.619] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.619] resolve() on list ... DONE
[10:58:38.619]  - Number of value chunks collected: 1
[10:58:38.619] Resolving 1 futures (chunks) ... DONE
[10:58:38.619] Reducing values from 1 chunks ...
[10:58:38.619]  - Number of values collected after concatenation: 6
[10:58:38.620]  - Number of values expected: 6
[10:58:38.620] Reducing values from 1 chunks ... DONE
[10:58:38.620] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:58:38.620] getGlobalsAndPackagesXApply() ...
[10:58:38.620]  - future.globals: TRUE
[10:58:38.620] getGlobalsAndPackages() ...
[10:58:38.620] Searching for globals...
[10:58:38.621] - globals found: [1] ‘FUN’
[10:58:38.621] Searching for globals ... DONE
[10:58:38.621] Resolving globals: FALSE
[10:58:38.621] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:38.622] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:38.622] - globals: [1] ‘FUN’
[10:58:38.622] 
[10:58:38.622] getGlobalsAndPackages() ... DONE
[10:58:38.622]  - globals found/used: [n=1] ‘FUN’
[10:58:38.622]  - needed namespaces: [n=0] 
[10:58:38.622] Finding globals ... DONE
[10:58:38.622]  - use_args: TRUE
[10:58:38.622]  - Getting '...' globals ...
[10:58:38.623] resolve() on list ...
[10:58:38.623]  recursive: 0
[10:58:38.623]  length: 1
[10:58:38.623]  elements: ‘...’
[10:58:38.623]  length: 0 (resolved future 1)
[10:58:38.623] resolve() on list ... DONE
[10:58:38.623]    - '...' content: [n=0] 
[10:58:38.623] List of 1
[10:58:38.623]  $ ...: list()
[10:58:38.623]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.623]  - attr(*, "where")=List of 1
[10:58:38.623]   ..$ ...:<environment: 0x5635bf4d7dd0> 
[10:58:38.623]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.623]  - attr(*, "resolved")= logi TRUE
[10:58:38.623]  - attr(*, "total_size")= num NA
[10:58:38.625]  - Getting '...' globals ... DONE
[10:58:38.626] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.626] List of 2
[10:58:38.626]  $ ...future.FUN:function (x)  
[10:58:38.626]  $ ...          : list()
[10:58:38.626]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.626]  - attr(*, "where")=List of 2
[10:58:38.626]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.626]   ..$ ...          :<environment: 0x5635bf4d7dd0> 
[10:58:38.626]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.626]  - attr(*, "resolved")= logi FALSE
[10:58:38.626]  - attr(*, "total_size")= num 2547
[10:58:38.651] Packages to be attached in all futures: [n=0] 
[10:58:38.651] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.652] future_lapply() ...
[10:58:38.652] Number of chunks: 1
[10:58:38.652] getGlobalsAndPackagesXApply() ...
[10:58:38.652]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.652]  - use_args: TRUE
[10:58:38.652] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.653] List of 2
[10:58:38.653]  $ ...          : list()
[10:58:38.653]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.653]  $ ...future.FUN:function (x)  
[10:58:38.653]  - attr(*, "where")=List of 2
[10:58:38.653]   ..$ ...          :<environment: 0x5635bf4d7dd0> 
[10:58:38.653]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:38.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.653]  - attr(*, "resolved")= logi FALSE
[10:58:38.653]  - attr(*, "total_size")= num NA
[10:58:38.655] Packages to be attached in all futures: [n=0] 
[10:58:38.656] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.656] Number of futures (= number of chunks): 1
[10:58:38.656] Launching 1 futures (chunks) ...
[10:58:38.656] Chunk #1 of 1 ...
[10:58:38.656]  - seeds: <none>
[10:58:38.656]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.656] getGlobalsAndPackages() ...
[10:58:38.656] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.656] Resolving globals: FALSE
[10:58:38.657] Tweak future expression to call with '...' arguments ...
[10:58:38.657] {
[10:58:38.657]     do.call(function(...) {
[10:58:38.657]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.657]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.657]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.657]             on.exit(options(oopts), add = TRUE)
[10:58:38.657]         }
[10:58:38.657]         {
[10:58:38.657]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.657]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.657]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.657]             })
[10:58:38.657]         }
[10:58:38.657]     }, args = future.call.arguments)
[10:58:38.657] }
[10:58:38.657] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.657] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.657] 
[10:58:38.657] getGlobalsAndPackages() ... DONE
[10:58:38.658] run() for ‘Future’ ...
[10:58:38.658] - state: ‘created’
[10:58:38.658] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.658] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.658] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.658]   - Field: ‘label’
[10:58:38.658]   - Field: ‘local’
[10:58:38.659]   - Field: ‘owner’
[10:58:38.659]   - Field: ‘envir’
[10:58:38.659]   - Field: ‘packages’
[10:58:38.659]   - Field: ‘gc’
[10:58:38.659]   - Field: ‘conditions’
[10:58:38.659]   - Field: ‘expr’
[10:58:38.659]   - Field: ‘uuid’
[10:58:38.659]   - Field: ‘seed’
[10:58:38.659]   - Field: ‘version’
[10:58:38.659]   - Field: ‘result’
[10:58:38.659]   - Field: ‘asynchronous’
[10:58:38.659]   - Field: ‘calls’
[10:58:38.660]   - Field: ‘globals’
[10:58:38.660]   - Field: ‘stdout’
[10:58:38.660]   - Field: ‘earlySignal’
[10:58:38.660]   - Field: ‘lazy’
[10:58:38.660]   - Field: ‘state’
[10:58:38.660] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.660] - Launch lazy future ...
[10:58:38.660] Packages needed by the future expression (n = 0): <none>
[10:58:38.660] Packages needed by future strategies (n = 0): <none>
[10:58:38.661] {
[10:58:38.661]     {
[10:58:38.661]         {
[10:58:38.661]             ...future.startTime <- base::Sys.time()
[10:58:38.661]             {
[10:58:38.661]                 {
[10:58:38.661]                   {
[10:58:38.661]                     base::local({
[10:58:38.661]                       has_future <- base::requireNamespace("future", 
[10:58:38.661]                         quietly = TRUE)
[10:58:38.661]                       if (has_future) {
[10:58:38.661]                         ns <- base::getNamespace("future")
[10:58:38.661]                         version <- ns[[".package"]][["version"]]
[10:58:38.661]                         if (is.null(version)) 
[10:58:38.661]                           version <- utils::packageVersion("future")
[10:58:38.661]                       }
[10:58:38.661]                       else {
[10:58:38.661]                         version <- NULL
[10:58:38.661]                       }
[10:58:38.661]                       if (!has_future || version < "1.8.0") {
[10:58:38.661]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.661]                           "", base::R.version$version.string), 
[10:58:38.661]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:38.661]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.661]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.661]                             "release", "version")], collapse = " "), 
[10:58:38.661]                           hostname = base::Sys.info()[["nodename"]])
[10:58:38.661]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.661]                           info)
[10:58:38.661]                         info <- base::paste(info, collapse = "; ")
[10:58:38.661]                         if (!has_future) {
[10:58:38.661]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.661]                             info)
[10:58:38.661]                         }
[10:58:38.661]                         else {
[10:58:38.661]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.661]                             info, version)
[10:58:38.661]                         }
[10:58:38.661]                         base::stop(msg)
[10:58:38.661]                       }
[10:58:38.661]                     })
[10:58:38.661]                   }
[10:58:38.661]                   ...future.strategy.old <- future::plan("list")
[10:58:38.661]                   options(future.plan = NULL)
[10:58:38.661]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.661]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.661]                 }
[10:58:38.661]                 ...future.workdir <- getwd()
[10:58:38.661]             }
[10:58:38.661]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.661]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.661]         }
[10:58:38.661]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.661]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.661]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.661]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.661]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.661]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.661]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.661]             base::names(...future.oldOptions))
[10:58:38.661]     }
[10:58:38.661]     if (FALSE) {
[10:58:38.661]     }
[10:58:38.661]     else {
[10:58:38.661]         if (TRUE) {
[10:58:38.661]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.661]                 open = "w")
[10:58:38.661]         }
[10:58:38.661]         else {
[10:58:38.661]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.661]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.661]         }
[10:58:38.661]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.661]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.661]             base::sink(type = "output", split = FALSE)
[10:58:38.661]             base::close(...future.stdout)
[10:58:38.661]         }, add = TRUE)
[10:58:38.661]     }
[10:58:38.661]     ...future.frame <- base::sys.nframe()
[10:58:38.661]     ...future.conditions <- base::list()
[10:58:38.661]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.661]     if (FALSE) {
[10:58:38.661]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.661]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.661]     }
[10:58:38.661]     ...future.result <- base::tryCatch({
[10:58:38.661]         base::withCallingHandlers({
[10:58:38.661]             ...future.value <- base::withVisible(base::local({
[10:58:38.661]                 do.call(function(...) {
[10:58:38.661]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.661]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.661]                     ...future.globals.maxSize)) {
[10:58:38.661]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.661]                     on.exit(options(oopts), add = TRUE)
[10:58:38.661]                   }
[10:58:38.661]                   {
[10:58:38.661]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.661]                       FUN = function(jj) {
[10:58:38.661]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.661]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.661]                       })
[10:58:38.661]                   }
[10:58:38.661]                 }, args = future.call.arguments)
[10:58:38.661]             }))
[10:58:38.661]             future::FutureResult(value = ...future.value$value, 
[10:58:38.661]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.661]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.661]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.661]                     ...future.globalenv.names))
[10:58:38.661]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.661]         }, condition = base::local({
[10:58:38.661]             c <- base::c
[10:58:38.661]             inherits <- base::inherits
[10:58:38.661]             invokeRestart <- base::invokeRestart
[10:58:38.661]             length <- base::length
[10:58:38.661]             list <- base::list
[10:58:38.661]             seq.int <- base::seq.int
[10:58:38.661]             signalCondition <- base::signalCondition
[10:58:38.661]             sys.calls <- base::sys.calls
[10:58:38.661]             `[[` <- base::`[[`
[10:58:38.661]             `+` <- base::`+`
[10:58:38.661]             `<<-` <- base::`<<-`
[10:58:38.661]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.661]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.661]                   3L)]
[10:58:38.661]             }
[10:58:38.661]             function(cond) {
[10:58:38.661]                 is_error <- inherits(cond, "error")
[10:58:38.661]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.661]                   NULL)
[10:58:38.661]                 if (is_error) {
[10:58:38.661]                   sessionInformation <- function() {
[10:58:38.661]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.661]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.661]                       search = base::search(), system = base::Sys.info())
[10:58:38.661]                   }
[10:58:38.661]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.661]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.661]                     cond$call), session = sessionInformation(), 
[10:58:38.661]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.661]                   signalCondition(cond)
[10:58:38.661]                 }
[10:58:38.661]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.661]                 "immediateCondition"))) {
[10:58:38.661]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.661]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.661]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.661]                   if (TRUE && !signal) {
[10:58:38.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.661]                     {
[10:58:38.661]                       inherits <- base::inherits
[10:58:38.661]                       invokeRestart <- base::invokeRestart
[10:58:38.661]                       is.null <- base::is.null
[10:58:38.661]                       muffled <- FALSE
[10:58:38.661]                       if (inherits(cond, "message")) {
[10:58:38.661]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.661]                         if (muffled) 
[10:58:38.661]                           invokeRestart("muffleMessage")
[10:58:38.661]                       }
[10:58:38.661]                       else if (inherits(cond, "warning")) {
[10:58:38.661]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.661]                         if (muffled) 
[10:58:38.661]                           invokeRestart("muffleWarning")
[10:58:38.661]                       }
[10:58:38.661]                       else if (inherits(cond, "condition")) {
[10:58:38.661]                         if (!is.null(pattern)) {
[10:58:38.661]                           computeRestarts <- base::computeRestarts
[10:58:38.661]                           grepl <- base::grepl
[10:58:38.661]                           restarts <- computeRestarts(cond)
[10:58:38.661]                           for (restart in restarts) {
[10:58:38.661]                             name <- restart$name
[10:58:38.661]                             if (is.null(name)) 
[10:58:38.661]                               next
[10:58:38.661]                             if (!grepl(pattern, name)) 
[10:58:38.661]                               next
[10:58:38.661]                             invokeRestart(restart)
[10:58:38.661]                             muffled <- TRUE
[10:58:38.661]                             break
[10:58:38.661]                           }
[10:58:38.661]                         }
[10:58:38.661]                       }
[10:58:38.661]                       invisible(muffled)
[10:58:38.661]                     }
[10:58:38.661]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.661]                   }
[10:58:38.661]                 }
[10:58:38.661]                 else {
[10:58:38.661]                   if (TRUE) {
[10:58:38.661]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.661]                     {
[10:58:38.661]                       inherits <- base::inherits
[10:58:38.661]                       invokeRestart <- base::invokeRestart
[10:58:38.661]                       is.null <- base::is.null
[10:58:38.661]                       muffled <- FALSE
[10:58:38.661]                       if (inherits(cond, "message")) {
[10:58:38.661]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.661]                         if (muffled) 
[10:58:38.661]                           invokeRestart("muffleMessage")
[10:58:38.661]                       }
[10:58:38.661]                       else if (inherits(cond, "warning")) {
[10:58:38.661]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.661]                         if (muffled) 
[10:58:38.661]                           invokeRestart("muffleWarning")
[10:58:38.661]                       }
[10:58:38.661]                       else if (inherits(cond, "condition")) {
[10:58:38.661]                         if (!is.null(pattern)) {
[10:58:38.661]                           computeRestarts <- base::computeRestarts
[10:58:38.661]                           grepl <- base::grepl
[10:58:38.661]                           restarts <- computeRestarts(cond)
[10:58:38.661]                           for (restart in restarts) {
[10:58:38.661]                             name <- restart$name
[10:58:38.661]                             if (is.null(name)) 
[10:58:38.661]                               next
[10:58:38.661]                             if (!grepl(pattern, name)) 
[10:58:38.661]                               next
[10:58:38.661]                             invokeRestart(restart)
[10:58:38.661]                             muffled <- TRUE
[10:58:38.661]                             break
[10:58:38.661]                           }
[10:58:38.661]                         }
[10:58:38.661]                       }
[10:58:38.661]                       invisible(muffled)
[10:58:38.661]                     }
[10:58:38.661]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.661]                   }
[10:58:38.661]                 }
[10:58:38.661]             }
[10:58:38.661]         }))
[10:58:38.661]     }, error = function(ex) {
[10:58:38.661]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.661]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.661]                 ...future.rng), started = ...future.startTime, 
[10:58:38.661]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.661]             version = "1.8"), class = "FutureResult")
[10:58:38.661]     }, finally = {
[10:58:38.661]         if (!identical(...future.workdir, getwd())) 
[10:58:38.661]             setwd(...future.workdir)
[10:58:38.661]         {
[10:58:38.661]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.661]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.661]             }
[10:58:38.661]             base::options(...future.oldOptions)
[10:58:38.661]             if (.Platform$OS.type == "windows") {
[10:58:38.661]                 old_names <- names(...future.oldEnvVars)
[10:58:38.661]                 envs <- base::Sys.getenv()
[10:58:38.661]                 names <- names(envs)
[10:58:38.661]                 common <- intersect(names, old_names)
[10:58:38.661]                 added <- setdiff(names, old_names)
[10:58:38.661]                 removed <- setdiff(old_names, names)
[10:58:38.661]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.661]                   envs[common]]
[10:58:38.661]                 NAMES <- toupper(changed)
[10:58:38.661]                 args <- list()
[10:58:38.661]                 for (kk in seq_along(NAMES)) {
[10:58:38.661]                   name <- changed[[kk]]
[10:58:38.661]                   NAME <- NAMES[[kk]]
[10:58:38.661]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.661]                     next
[10:58:38.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.661]                 }
[10:58:38.661]                 NAMES <- toupper(added)
[10:58:38.661]                 for (kk in seq_along(NAMES)) {
[10:58:38.661]                   name <- added[[kk]]
[10:58:38.661]                   NAME <- NAMES[[kk]]
[10:58:38.661]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.661]                     next
[10:58:38.661]                   args[[name]] <- ""
[10:58:38.661]                 }
[10:58:38.661]                 NAMES <- toupper(removed)
[10:58:38.661]                 for (kk in seq_along(NAMES)) {
[10:58:38.661]                   name <- removed[[kk]]
[10:58:38.661]                   NAME <- NAMES[[kk]]
[10:58:38.661]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.661]                     next
[10:58:38.661]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.661]                 }
[10:58:38.661]                 if (length(args) > 0) 
[10:58:38.661]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.661]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.661]             }
[10:58:38.661]             else {
[10:58:38.661]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.661]             }
[10:58:38.661]             {
[10:58:38.661]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.661]                   0L) {
[10:58:38.661]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.661]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.661]                   base::options(opts)
[10:58:38.661]                 }
[10:58:38.661]                 {
[10:58:38.661]                   {
[10:58:38.661]                     NULL
[10:58:38.661]                     RNGkind("Mersenne-Twister")
[10:58:38.661]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:38.661]                       inherits = FALSE)
[10:58:38.661]                   }
[10:58:38.661]                   options(future.plan = NULL)
[10:58:38.661]                   if (is.na(NA_character_)) 
[10:58:38.661]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.661]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.661]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.661]                     .init = FALSE)
[10:58:38.661]                 }
[10:58:38.661]             }
[10:58:38.661]         }
[10:58:38.661]     })
[10:58:38.661]     if (TRUE) {
[10:58:38.661]         base::sink(type = "output", split = FALSE)
[10:58:38.661]         if (TRUE) {
[10:58:38.661]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.661]         }
[10:58:38.661]         else {
[10:58:38.661]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.661]         }
[10:58:38.661]         base::close(...future.stdout)
[10:58:38.661]         ...future.stdout <- NULL
[10:58:38.661]     }
[10:58:38.661]     ...future.result$conditions <- ...future.conditions
[10:58:38.661]     ...future.result$finished <- base::Sys.time()
[10:58:38.661]     ...future.result
[10:58:38.661] }
[10:58:38.663] assign_globals() ...
[10:58:38.663] List of 5
[10:58:38.663]  $ future.call.arguments    : list()
[10:58:38.663]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.663]  $ ...future.FUN            :function (x)  
[10:58:38.663]  $ ...future.elements_ii    :List of 2
[10:58:38.663]   ..$ : int 1
[10:58:38.663]   ..$ : int 2
[10:58:38.663]  $ ...future.seeds_ii       : NULL
[10:58:38.663]  $ ...future.globals.maxSize: num Inf
[10:58:38.663]  - attr(*, "resolved")= logi FALSE
[10:58:38.663]  - attr(*, "total_size")= num NA
[10:58:38.663]  - attr(*, "where")=List of 5
[10:58:38.663]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.663]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.663]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.663]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.663]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.663]  - attr(*, "already-done")= logi TRUE
[10:58:38.667] - copied ‘future.call.arguments’ to environment
[10:58:38.667] - copied ‘...future.FUN’ to environment
[10:58:38.668] - copied ‘...future.elements_ii’ to environment
[10:58:38.668] - copied ‘...future.seeds_ii’ to environment
[10:58:38.668] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.668] assign_globals() ... done
[10:58:38.668] plan(): Setting new future strategy stack:
[10:58:38.668] List of future strategies:
[10:58:38.668] 1. sequential:
[10:58:38.668]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.668]    - tweaked: FALSE
[10:58:38.668]    - call: NULL
[10:58:38.669] plan(): nbrOfWorkers() = 1
[10:58:38.669] plan(): Setting new future strategy stack:
[10:58:38.669] List of future strategies:
[10:58:38.669] 1. sequential:
[10:58:38.669]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.669]    - tweaked: FALSE
[10:58:38.669]    - call: plan(strategy)
[10:58:38.670] plan(): nbrOfWorkers() = 1
[10:58:38.670] SequentialFuture started (and completed)
[10:58:38.670] - Launch lazy future ... done
[10:58:38.670] run() for ‘SequentialFuture’ ... done
[10:58:38.670] Created future:
[10:58:38.670] SequentialFuture:
[10:58:38.670] Label: ‘future_apply-1’
[10:58:38.670] Expression:
[10:58:38.670] {
[10:58:38.670]     do.call(function(...) {
[10:58:38.670]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.670]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.670]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.670]             on.exit(options(oopts), add = TRUE)
[10:58:38.670]         }
[10:58:38.670]         {
[10:58:38.670]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.670]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.670]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.670]             })
[10:58:38.670]         }
[10:58:38.670]     }, args = future.call.arguments)
[10:58:38.670] }
[10:58:38.670] Lazy evaluation: FALSE
[10:58:38.670] Asynchronous evaluation: FALSE
[10:58:38.670] Local evaluation: TRUE
[10:58:38.670] Environment: R_GlobalEnv
[10:58:38.670] Capture standard output: TRUE
[10:58:38.670] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.670] Globals: 5 objects totaling 403 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.670] Packages: <none>
[10:58:38.670] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.670] Resolved: TRUE
[10:58:38.670] Value: 55 bytes of class ‘list’
[10:58:38.670] Early signaling: FALSE
[10:58:38.670] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.670] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.671] Chunk #1 of 1 ... DONE
[10:58:38.671] Launching 1 futures (chunks) ... DONE
[10:58:38.671] Resolving 1 futures (chunks) ...
[10:58:38.671] resolve() on list ...
[10:58:38.671]  recursive: 0
[10:58:38.672]  length: 1
[10:58:38.672] 
[10:58:38.672] resolved() for ‘SequentialFuture’ ...
[10:58:38.672] - state: ‘finished’
[10:58:38.672] - run: TRUE
[10:58:38.672] - result: ‘FutureResult’
[10:58:38.672] resolved() for ‘SequentialFuture’ ... done
[10:58:38.672] Future #1
[10:58:38.673] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.673] - nx: 1
[10:58:38.673] - relay: TRUE
[10:58:38.673] - stdout: TRUE
[10:58:38.673] - signal: TRUE
[10:58:38.673] - resignal: FALSE
[10:58:38.673] - force: TRUE
[10:58:38.674] - relayed: [n=1] FALSE
[10:58:38.674] - queued futures: [n=1] FALSE
[10:58:38.674]  - until=1
[10:58:38.674]  - relaying element #1
[10:58:38.674] - relayed: [n=1] TRUE
[10:58:38.674] - queued futures: [n=1] TRUE
[10:58:38.674] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.674]  length: 0 (resolved future 1)
[10:58:38.674] Relaying remaining futures
[10:58:38.674] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.674] - nx: 1
[10:58:38.675] - relay: TRUE
[10:58:38.675] - stdout: TRUE
[10:58:38.675] - signal: TRUE
[10:58:38.675] - resignal: FALSE
[10:58:38.675] - force: TRUE
[10:58:38.675] - relayed: [n=1] TRUE
[10:58:38.675] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.675] - relayed: [n=1] TRUE
[10:58:38.675] - queued futures: [n=1] TRUE
[10:58:38.675] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.675] resolve() on list ... DONE
[10:58:38.675]  - Number of value chunks collected: 1
[10:58:38.676] Resolving 1 futures (chunks) ... DONE
[10:58:38.676] Reducing values from 1 chunks ...
[10:58:38.676]  - Number of values collected after concatenation: 2
[10:58:38.676]  - Number of values expected: 2
[10:58:38.676] Reducing values from 1 chunks ... DONE
[10:58:38.676] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:58:38.676] getGlobalsAndPackagesXApply() ...
[10:58:38.676]  - future.globals: TRUE
[10:58:38.676] getGlobalsAndPackages() ...
[10:58:38.676] Searching for globals...
[10:58:38.677] - globals found: [1] ‘FUN’
[10:58:38.678] Searching for globals ... DONE
[10:58:38.678] Resolving globals: FALSE
[10:58:38.678] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:38.678] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:38.678] - globals: [1] ‘FUN’
[10:58:38.678] 
[10:58:38.678] getGlobalsAndPackages() ... DONE
[10:58:38.679]  - globals found/used: [n=1] ‘FUN’
[10:58:38.679]  - needed namespaces: [n=0] 
[10:58:38.679] Finding globals ... DONE
[10:58:38.679]  - use_args: TRUE
[10:58:38.679]  - Getting '...' globals ...
[10:58:38.679] resolve() on list ...
[10:58:38.679]  recursive: 0
[10:58:38.679]  length: 1
[10:58:38.679]  elements: ‘...’
[10:58:38.679]  length: 0 (resolved future 1)
[10:58:38.680] resolve() on list ... DONE
[10:58:38.680]    - '...' content: [n=0] 
[10:58:38.680] List of 1
[10:58:38.680]  $ ...: list()
[10:58:38.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.680]  - attr(*, "where")=List of 1
[10:58:38.680]   ..$ ...:<environment: 0x5635bddbf910> 
[10:58:38.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.680]  - attr(*, "resolved")= logi TRUE
[10:58:38.680]  - attr(*, "total_size")= num NA
[10:58:38.682]  - Getting '...' globals ... DONE
[10:58:38.682] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.682] List of 2
[10:58:38.682]  $ ...future.FUN:function (x)  
[10:58:38.682]  $ ...          : list()
[10:58:38.682]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.682]  - attr(*, "where")=List of 2
[10:58:38.682]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.682]   ..$ ...          :<environment: 0x5635bddbf910> 
[10:58:38.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.682]  - attr(*, "resolved")= logi FALSE
[10:58:38.682]  - attr(*, "total_size")= num 2274
[10:58:38.685] Packages to be attached in all futures: [n=0] 
[10:58:38.685] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.685] future_lapply() ...
[10:58:38.685] Number of chunks: 1
[10:58:38.685] getGlobalsAndPackagesXApply() ...
[10:58:38.685]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.686]  - use_args: TRUE
[10:58:38.686] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.686] List of 2
[10:58:38.686]  $ ...          : list()
[10:58:38.686]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.686]  $ ...future.FUN:function (x)  
[10:58:38.686]  - attr(*, "where")=List of 2
[10:58:38.686]   ..$ ...          :<environment: 0x5635bddbf910> 
[10:58:38.686]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:38.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.686]  - attr(*, "resolved")= logi FALSE
[10:58:38.686]  - attr(*, "total_size")= num NA
[10:58:38.689] Packages to be attached in all futures: [n=0] 
[10:58:38.689] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.689] Number of futures (= number of chunks): 1
[10:58:38.689] Launching 1 futures (chunks) ...
[10:58:38.689] Chunk #1 of 1 ...
[10:58:38.689]  - seeds: <none>
[10:58:38.689]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.690] getGlobalsAndPackages() ...
[10:58:38.690] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.690] Resolving globals: FALSE
[10:58:38.690] Tweak future expression to call with '...' arguments ...
[10:58:38.690] {
[10:58:38.690]     do.call(function(...) {
[10:58:38.690]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.690]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.690]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.690]             on.exit(options(oopts), add = TRUE)
[10:58:38.690]         }
[10:58:38.690]         {
[10:58:38.690]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.690]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.690]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.690]             })
[10:58:38.690]         }
[10:58:38.690]     }, args = future.call.arguments)
[10:58:38.690] }
[10:58:38.690] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.690] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.691] 
[10:58:38.691] getGlobalsAndPackages() ... DONE
[10:58:38.691] run() for ‘Future’ ...
[10:58:38.691] - state: ‘created’
[10:58:38.691] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.691] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.691] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.692]   - Field: ‘label’
[10:58:38.692]   - Field: ‘local’
[10:58:38.692]   - Field: ‘owner’
[10:58:38.692]   - Field: ‘envir’
[10:58:38.692]   - Field: ‘packages’
[10:58:38.692]   - Field: ‘gc’
[10:58:38.692]   - Field: ‘conditions’
[10:58:38.692]   - Field: ‘expr’
[10:58:38.692]   - Field: ‘uuid’
[10:58:38.692]   - Field: ‘seed’
[10:58:38.692]   - Field: ‘version’
[10:58:38.693]   - Field: ‘result’
[10:58:38.693]   - Field: ‘asynchronous’
[10:58:38.693]   - Field: ‘calls’
[10:58:38.693]   - Field: ‘globals’
[10:58:38.693]   - Field: ‘stdout’
[10:58:38.693]   - Field: ‘earlySignal’
[10:58:38.693]   - Field: ‘lazy’
[10:58:38.693]   - Field: ‘state’
[10:58:38.693] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.693] - Launch lazy future ...
[10:58:38.693] Packages needed by the future expression (n = 0): <none>
[10:58:38.693] Packages needed by future strategies (n = 0): <none>
[10:58:38.694] {
[10:58:38.694]     {
[10:58:38.694]         {
[10:58:38.694]             ...future.startTime <- base::Sys.time()
[10:58:38.694]             {
[10:58:38.694]                 {
[10:58:38.694]                   {
[10:58:38.694]                     base::local({
[10:58:38.694]                       has_future <- base::requireNamespace("future", 
[10:58:38.694]                         quietly = TRUE)
[10:58:38.694]                       if (has_future) {
[10:58:38.694]                         ns <- base::getNamespace("future")
[10:58:38.694]                         version <- ns[[".package"]][["version"]]
[10:58:38.694]                         if (is.null(version)) 
[10:58:38.694]                           version <- utils::packageVersion("future")
[10:58:38.694]                       }
[10:58:38.694]                       else {
[10:58:38.694]                         version <- NULL
[10:58:38.694]                       }
[10:58:38.694]                       if (!has_future || version < "1.8.0") {
[10:58:38.694]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.694]                           "", base::R.version$version.string), 
[10:58:38.694]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:38.694]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.694]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.694]                             "release", "version")], collapse = " "), 
[10:58:38.694]                           hostname = base::Sys.info()[["nodename"]])
[10:58:38.694]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.694]                           info)
[10:58:38.694]                         info <- base::paste(info, collapse = "; ")
[10:58:38.694]                         if (!has_future) {
[10:58:38.694]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.694]                             info)
[10:58:38.694]                         }
[10:58:38.694]                         else {
[10:58:38.694]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.694]                             info, version)
[10:58:38.694]                         }
[10:58:38.694]                         base::stop(msg)
[10:58:38.694]                       }
[10:58:38.694]                     })
[10:58:38.694]                   }
[10:58:38.694]                   ...future.strategy.old <- future::plan("list")
[10:58:38.694]                   options(future.plan = NULL)
[10:58:38.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.694]                 }
[10:58:38.694]                 ...future.workdir <- getwd()
[10:58:38.694]             }
[10:58:38.694]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.694]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.694]         }
[10:58:38.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.694]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.694]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.694]             base::names(...future.oldOptions))
[10:58:38.694]     }
[10:58:38.694]     if (FALSE) {
[10:58:38.694]     }
[10:58:38.694]     else {
[10:58:38.694]         if (TRUE) {
[10:58:38.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.694]                 open = "w")
[10:58:38.694]         }
[10:58:38.694]         else {
[10:58:38.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.694]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.694]         }
[10:58:38.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.694]             base::sink(type = "output", split = FALSE)
[10:58:38.694]             base::close(...future.stdout)
[10:58:38.694]         }, add = TRUE)
[10:58:38.694]     }
[10:58:38.694]     ...future.frame <- base::sys.nframe()
[10:58:38.694]     ...future.conditions <- base::list()
[10:58:38.694]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.694]     if (FALSE) {
[10:58:38.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.694]     }
[10:58:38.694]     ...future.result <- base::tryCatch({
[10:58:38.694]         base::withCallingHandlers({
[10:58:38.694]             ...future.value <- base::withVisible(base::local({
[10:58:38.694]                 do.call(function(...) {
[10:58:38.694]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.694]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.694]                     ...future.globals.maxSize)) {
[10:58:38.694]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.694]                     on.exit(options(oopts), add = TRUE)
[10:58:38.694]                   }
[10:58:38.694]                   {
[10:58:38.694]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.694]                       FUN = function(jj) {
[10:58:38.694]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.694]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.694]                       })
[10:58:38.694]                   }
[10:58:38.694]                 }, args = future.call.arguments)
[10:58:38.694]             }))
[10:58:38.694]             future::FutureResult(value = ...future.value$value, 
[10:58:38.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.694]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.694]                     ...future.globalenv.names))
[10:58:38.694]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.694]         }, condition = base::local({
[10:58:38.694]             c <- base::c
[10:58:38.694]             inherits <- base::inherits
[10:58:38.694]             invokeRestart <- base::invokeRestart
[10:58:38.694]             length <- base::length
[10:58:38.694]             list <- base::list
[10:58:38.694]             seq.int <- base::seq.int
[10:58:38.694]             signalCondition <- base::signalCondition
[10:58:38.694]             sys.calls <- base::sys.calls
[10:58:38.694]             `[[` <- base::`[[`
[10:58:38.694]             `+` <- base::`+`
[10:58:38.694]             `<<-` <- base::`<<-`
[10:58:38.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.694]                   3L)]
[10:58:38.694]             }
[10:58:38.694]             function(cond) {
[10:58:38.694]                 is_error <- inherits(cond, "error")
[10:58:38.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.694]                   NULL)
[10:58:38.694]                 if (is_error) {
[10:58:38.694]                   sessionInformation <- function() {
[10:58:38.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.694]                       search = base::search(), system = base::Sys.info())
[10:58:38.694]                   }
[10:58:38.694]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.694]                     cond$call), session = sessionInformation(), 
[10:58:38.694]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.694]                   signalCondition(cond)
[10:58:38.694]                 }
[10:58:38.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.694]                 "immediateCondition"))) {
[10:58:38.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.694]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.694]                   if (TRUE && !signal) {
[10:58:38.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.694]                     {
[10:58:38.694]                       inherits <- base::inherits
[10:58:38.694]                       invokeRestart <- base::invokeRestart
[10:58:38.694]                       is.null <- base::is.null
[10:58:38.694]                       muffled <- FALSE
[10:58:38.694]                       if (inherits(cond, "message")) {
[10:58:38.694]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.694]                         if (muffled) 
[10:58:38.694]                           invokeRestart("muffleMessage")
[10:58:38.694]                       }
[10:58:38.694]                       else if (inherits(cond, "warning")) {
[10:58:38.694]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.694]                         if (muffled) 
[10:58:38.694]                           invokeRestart("muffleWarning")
[10:58:38.694]                       }
[10:58:38.694]                       else if (inherits(cond, "condition")) {
[10:58:38.694]                         if (!is.null(pattern)) {
[10:58:38.694]                           computeRestarts <- base::computeRestarts
[10:58:38.694]                           grepl <- base::grepl
[10:58:38.694]                           restarts <- computeRestarts(cond)
[10:58:38.694]                           for (restart in restarts) {
[10:58:38.694]                             name <- restart$name
[10:58:38.694]                             if (is.null(name)) 
[10:58:38.694]                               next
[10:58:38.694]                             if (!grepl(pattern, name)) 
[10:58:38.694]                               next
[10:58:38.694]                             invokeRestart(restart)
[10:58:38.694]                             muffled <- TRUE
[10:58:38.694]                             break
[10:58:38.694]                           }
[10:58:38.694]                         }
[10:58:38.694]                       }
[10:58:38.694]                       invisible(muffled)
[10:58:38.694]                     }
[10:58:38.694]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.694]                   }
[10:58:38.694]                 }
[10:58:38.694]                 else {
[10:58:38.694]                   if (TRUE) {
[10:58:38.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.694]                     {
[10:58:38.694]                       inherits <- base::inherits
[10:58:38.694]                       invokeRestart <- base::invokeRestart
[10:58:38.694]                       is.null <- base::is.null
[10:58:38.694]                       muffled <- FALSE
[10:58:38.694]                       if (inherits(cond, "message")) {
[10:58:38.694]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.694]                         if (muffled) 
[10:58:38.694]                           invokeRestart("muffleMessage")
[10:58:38.694]                       }
[10:58:38.694]                       else if (inherits(cond, "warning")) {
[10:58:38.694]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.694]                         if (muffled) 
[10:58:38.694]                           invokeRestart("muffleWarning")
[10:58:38.694]                       }
[10:58:38.694]                       else if (inherits(cond, "condition")) {
[10:58:38.694]                         if (!is.null(pattern)) {
[10:58:38.694]                           computeRestarts <- base::computeRestarts
[10:58:38.694]                           grepl <- base::grepl
[10:58:38.694]                           restarts <- computeRestarts(cond)
[10:58:38.694]                           for (restart in restarts) {
[10:58:38.694]                             name <- restart$name
[10:58:38.694]                             if (is.null(name)) 
[10:58:38.694]                               next
[10:58:38.694]                             if (!grepl(pattern, name)) 
[10:58:38.694]                               next
[10:58:38.694]                             invokeRestart(restart)
[10:58:38.694]                             muffled <- TRUE
[10:58:38.694]                             break
[10:58:38.694]                           }
[10:58:38.694]                         }
[10:58:38.694]                       }
[10:58:38.694]                       invisible(muffled)
[10:58:38.694]                     }
[10:58:38.694]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.694]                   }
[10:58:38.694]                 }
[10:58:38.694]             }
[10:58:38.694]         }))
[10:58:38.694]     }, error = function(ex) {
[10:58:38.694]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.694]                 ...future.rng), started = ...future.startTime, 
[10:58:38.694]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.694]             version = "1.8"), class = "FutureResult")
[10:58:38.694]     }, finally = {
[10:58:38.694]         if (!identical(...future.workdir, getwd())) 
[10:58:38.694]             setwd(...future.workdir)
[10:58:38.694]         {
[10:58:38.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.694]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.694]             }
[10:58:38.694]             base::options(...future.oldOptions)
[10:58:38.694]             if (.Platform$OS.type == "windows") {
[10:58:38.694]                 old_names <- names(...future.oldEnvVars)
[10:58:38.694]                 envs <- base::Sys.getenv()
[10:58:38.694]                 names <- names(envs)
[10:58:38.694]                 common <- intersect(names, old_names)
[10:58:38.694]                 added <- setdiff(names, old_names)
[10:58:38.694]                 removed <- setdiff(old_names, names)
[10:58:38.694]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.694]                   envs[common]]
[10:58:38.694]                 NAMES <- toupper(changed)
[10:58:38.694]                 args <- list()
[10:58:38.694]                 for (kk in seq_along(NAMES)) {
[10:58:38.694]                   name <- changed[[kk]]
[10:58:38.694]                   NAME <- NAMES[[kk]]
[10:58:38.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.694]                     next
[10:58:38.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.694]                 }
[10:58:38.694]                 NAMES <- toupper(added)
[10:58:38.694]                 for (kk in seq_along(NAMES)) {
[10:58:38.694]                   name <- added[[kk]]
[10:58:38.694]                   NAME <- NAMES[[kk]]
[10:58:38.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.694]                     next
[10:58:38.694]                   args[[name]] <- ""
[10:58:38.694]                 }
[10:58:38.694]                 NAMES <- toupper(removed)
[10:58:38.694]                 for (kk in seq_along(NAMES)) {
[10:58:38.694]                   name <- removed[[kk]]
[10:58:38.694]                   NAME <- NAMES[[kk]]
[10:58:38.694]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.694]                     next
[10:58:38.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.694]                 }
[10:58:38.694]                 if (length(args) > 0) 
[10:58:38.694]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.694]             }
[10:58:38.694]             else {
[10:58:38.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.694]             }
[10:58:38.694]             {
[10:58:38.694]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.694]                   0L) {
[10:58:38.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.694]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.694]                   base::options(opts)
[10:58:38.694]                 }
[10:58:38.694]                 {
[10:58:38.694]                   {
[10:58:38.694]                     NULL
[10:58:38.694]                     RNGkind("Mersenne-Twister")
[10:58:38.694]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:38.694]                       inherits = FALSE)
[10:58:38.694]                   }
[10:58:38.694]                   options(future.plan = NULL)
[10:58:38.694]                   if (is.na(NA_character_)) 
[10:58:38.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.694]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.694]                     .init = FALSE)
[10:58:38.694]                 }
[10:58:38.694]             }
[10:58:38.694]         }
[10:58:38.694]     })
[10:58:38.694]     if (TRUE) {
[10:58:38.694]         base::sink(type = "output", split = FALSE)
[10:58:38.694]         if (TRUE) {
[10:58:38.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.694]         }
[10:58:38.694]         else {
[10:58:38.694]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.694]         }
[10:58:38.694]         base::close(...future.stdout)
[10:58:38.694]         ...future.stdout <- NULL
[10:58:38.694]     }
[10:58:38.694]     ...future.result$conditions <- ...future.conditions
[10:58:38.694]     ...future.result$finished <- base::Sys.time()
[10:58:38.694]     ...future.result
[10:58:38.694] }
[10:58:38.696] assign_globals() ...
[10:58:38.696] List of 5
[10:58:38.696]  $ future.call.arguments    : list()
[10:58:38.696]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.696]  $ ...future.FUN            :function (x)  
[10:58:38.696]  $ ...future.elements_ii    :List of 2
[10:58:38.696]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[10:58:38.696]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[10:58:38.696]  $ ...future.seeds_ii       : NULL
[10:58:38.696]  $ ...future.globals.maxSize: num Inf
[10:58:38.696]  - attr(*, "resolved")= logi FALSE
[10:58:38.696]  - attr(*, "total_size")= num NA
[10:58:38.696]  - attr(*, "where")=List of 5
[10:58:38.696]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.696]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.696]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.696]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.696]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.696]  - attr(*, "already-done")= logi TRUE
[10:58:38.701] - copied ‘future.call.arguments’ to environment
[10:58:38.701] - copied ‘...future.FUN’ to environment
[10:58:38.701] - copied ‘...future.elements_ii’ to environment
[10:58:38.702] - copied ‘...future.seeds_ii’ to environment
[10:58:38.702] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.702] assign_globals() ... done
[10:58:38.702] plan(): Setting new future strategy stack:
[10:58:38.702] List of future strategies:
[10:58:38.702] 1. sequential:
[10:58:38.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.702]    - tweaked: FALSE
[10:58:38.702]    - call: NULL
[10:58:38.702] plan(): nbrOfWorkers() = 1
[10:58:38.703] plan(): Setting new future strategy stack:
[10:58:38.703] List of future strategies:
[10:58:38.703] 1. sequential:
[10:58:38.703]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.703]    - tweaked: FALSE
[10:58:38.703]    - call: plan(strategy)
[10:58:38.704] plan(): nbrOfWorkers() = 1
[10:58:38.704] SequentialFuture started (and completed)
[10:58:38.704] - Launch lazy future ... done
[10:58:38.704] run() for ‘SequentialFuture’ ... done
[10:58:38.704] Created future:
[10:58:38.704] SequentialFuture:
[10:58:38.704] Label: ‘future_apply-1’
[10:58:38.704] Expression:
[10:58:38.704] {
[10:58:38.704]     do.call(function(...) {
[10:58:38.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.704]             on.exit(options(oopts), add = TRUE)
[10:58:38.704]         }
[10:58:38.704]         {
[10:58:38.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.704]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.704]             })
[10:58:38.704]         }
[10:58:38.704]     }, args = future.call.arguments)
[10:58:38.704] }
[10:58:38.704] Lazy evaluation: FALSE
[10:58:38.704] Asynchronous evaluation: FALSE
[10:58:38.704] Local evaluation: TRUE
[10:58:38.704] Environment: R_GlobalEnv
[10:58:38.704] Capture standard output: TRUE
[10:58:38.704] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.704] Globals: 5 objects totaling 510 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 162 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.704] Packages: <none>
[10:58:38.704] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.704] Resolved: TRUE
[10:58:38.704] Value: 162 bytes of class ‘list’
[10:58:38.704] Early signaling: FALSE
[10:58:38.704] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.704] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.705] Chunk #1 of 1 ... DONE
[10:58:38.705] Launching 1 futures (chunks) ... DONE
[10:58:38.705] Resolving 1 futures (chunks) ...
[10:58:38.705] resolve() on list ...
[10:58:38.705]  recursive: 0
[10:58:38.705]  length: 1
[10:58:38.705] 
[10:58:38.705] resolved() for ‘SequentialFuture’ ...
[10:58:38.706] - state: ‘finished’
[10:58:38.706] - run: TRUE
[10:58:38.706] - result: ‘FutureResult’
[10:58:38.706] resolved() for ‘SequentialFuture’ ... done
[10:58:38.706] Future #1
[10:58:38.706] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.706] - nx: 1
[10:58:38.706] - relay: TRUE
[10:58:38.706] - stdout: TRUE
[10:58:38.706] - signal: TRUE
[10:58:38.706] - resignal: FALSE
[10:58:38.706] - force: TRUE
[10:58:38.706] - relayed: [n=1] FALSE
[10:58:38.707] - queued futures: [n=1] FALSE
[10:58:38.707]  - until=1
[10:58:38.707]  - relaying element #1
[10:58:38.707] - relayed: [n=1] TRUE
[10:58:38.707] - queued futures: [n=1] TRUE
[10:58:38.707] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.707]  length: 0 (resolved future 1)
[10:58:38.707] Relaying remaining futures
[10:58:38.707] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.707] - nx: 1
[10:58:38.707] - relay: TRUE
[10:58:38.708] - stdout: TRUE
[10:58:38.708] - signal: TRUE
[10:58:38.708] - resignal: FALSE
[10:58:38.708] - force: TRUE
[10:58:38.708] - relayed: [n=1] TRUE
[10:58:38.708] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.708] - relayed: [n=1] TRUE
[10:58:38.708] - queued futures: [n=1] TRUE
[10:58:38.708] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.708] resolve() on list ... DONE
[10:58:38.708]  - Number of value chunks collected: 1
[10:58:38.708] Resolving 1 futures (chunks) ... DONE
[10:58:38.709] Reducing values from 1 chunks ...
[10:58:38.709]  - Number of values collected after concatenation: 2
[10:58:38.709]  - Number of values expected: 2
[10:58:38.709] Reducing values from 1 chunks ... DONE
[10:58:38.709] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:58:38.709] getGlobalsAndPackagesXApply() ...
[10:58:38.709]  - future.globals: TRUE
[10:58:38.709] getGlobalsAndPackages() ...
[10:58:38.709] Searching for globals...
[10:58:38.712] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:58:38.712] Searching for globals ... DONE
[10:58:38.712] Resolving globals: FALSE
[10:58:38.712] The total size of the 1 globals is 1.28 KiB (1311 bytes)
[10:58:38.713] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 1.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.28 KiB of class ‘function’)
[10:58:38.713] - globals: [1] ‘FUN’
[10:58:38.713] 
[10:58:38.713] getGlobalsAndPackages() ... DONE
[10:58:38.713]  - globals found/used: [n=1] ‘FUN’
[10:58:38.713]  - needed namespaces: [n=0] 
[10:58:38.713] Finding globals ... DONE
[10:58:38.713]  - use_args: TRUE
[10:58:38.713]  - Getting '...' globals ...
[10:58:38.713] resolve() on list ...
[10:58:38.714]  recursive: 0
[10:58:38.714]  length: 1
[10:58:38.714]  elements: ‘...’
[10:58:38.714]  length: 0 (resolved future 1)
[10:58:38.714] resolve() on list ... DONE
[10:58:38.714]    - '...' content: [n=0] 
[10:58:38.714] List of 1
[10:58:38.714]  $ ...: list()
[10:58:38.714]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.714]  - attr(*, "where")=List of 1
[10:58:38.714]   ..$ ...:<environment: 0x5635bf3bed08> 
[10:58:38.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.714]  - attr(*, "resolved")= logi TRUE
[10:58:38.714]  - attr(*, "total_size")= num NA
[10:58:38.717]  - Getting '...' globals ... DONE
[10:58:38.717] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.717] List of 2
[10:58:38.717]  $ ...future.FUN:function (x)  
[10:58:38.717]  $ ...          : list()
[10:58:38.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.717]  - attr(*, "where")=List of 2
[10:58:38.717]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.717]   ..$ ...          :<environment: 0x5635bf3bed08> 
[10:58:38.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.717]  - attr(*, "resolved")= logi FALSE
[10:58:38.717]  - attr(*, "total_size")= num 4449
[10:58:38.720] Packages to be attached in all futures: [n=0] 
[10:58:38.720] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.720] future_lapply() ...
[10:58:38.721] Number of chunks: 1
[10:58:38.721] getGlobalsAndPackagesXApply() ...
[10:58:38.722]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.722]  - use_args: TRUE
[10:58:38.722] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.722] List of 2
[10:58:38.722]  $ ...          : list()
[10:58:38.722]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.722]  $ ...future.FUN:function (x)  
[10:58:38.722]  - attr(*, "where")=List of 2
[10:58:38.722]   ..$ ...          :<environment: 0x5635bf3bed08> 
[10:58:38.722]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:58:38.722]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.722]  - attr(*, "resolved")= logi FALSE
[10:58:38.722]  - attr(*, "total_size")= num NA
[10:58:38.724] Packages to be attached in all futures: [n=0] 
[10:58:38.725] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.725] Number of futures (= number of chunks): 1
[10:58:38.725] Launching 1 futures (chunks) ...
[10:58:38.725] Chunk #1 of 1 ...
[10:58:38.725]  - seeds: <none>
[10:58:38.725]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.725] getGlobalsAndPackages() ...
[10:58:38.725] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.725] Resolving globals: FALSE
[10:58:38.725] Tweak future expression to call with '...' arguments ...
[10:58:38.726] {
[10:58:38.726]     do.call(function(...) {
[10:58:38.726]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.726]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.726]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.726]             on.exit(options(oopts), add = TRUE)
[10:58:38.726]         }
[10:58:38.726]         {
[10:58:38.726]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.726]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.726]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.726]             })
[10:58:38.726]         }
[10:58:38.726]     }, args = future.call.arguments)
[10:58:38.726] }
[10:58:38.726] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.726] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.726] 
[10:58:38.726] getGlobalsAndPackages() ... DONE
[10:58:38.727] run() for ‘Future’ ...
[10:58:38.727] - state: ‘created’
[10:58:38.727] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.727] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.727]   - Field: ‘label’
[10:58:38.727]   - Field: ‘local’
[10:58:38.727]   - Field: ‘owner’
[10:58:38.727]   - Field: ‘envir’
[10:58:38.727]   - Field: ‘packages’
[10:58:38.728]   - Field: ‘gc’
[10:58:38.728]   - Field: ‘conditions’
[10:58:38.728]   - Field: ‘expr’
[10:58:38.728]   - Field: ‘uuid’
[10:58:38.728]   - Field: ‘seed’
[10:58:38.728]   - Field: ‘version’
[10:58:38.728]   - Field: ‘result’
[10:58:38.728]   - Field: ‘asynchronous’
[10:58:38.728]   - Field: ‘calls’
[10:58:38.728]   - Field: ‘globals’
[10:58:38.728]   - Field: ‘stdout’
[10:58:38.728]   - Field: ‘earlySignal’
[10:58:38.729]   - Field: ‘lazy’
[10:58:38.729]   - Field: ‘state’
[10:58:38.729] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.729] - Launch lazy future ...
[10:58:38.729] Packages needed by the future expression (n = 0): <none>
[10:58:38.729] Packages needed by future strategies (n = 0): <none>
[10:58:38.729] {
[10:58:38.729]     {
[10:58:38.729]         {
[10:58:38.729]             ...future.startTime <- base::Sys.time()
[10:58:38.729]             {
[10:58:38.729]                 {
[10:58:38.729]                   {
[10:58:38.729]                     base::local({
[10:58:38.729]                       has_future <- base::requireNamespace("future", 
[10:58:38.729]                         quietly = TRUE)
[10:58:38.729]                       if (has_future) {
[10:58:38.729]                         ns <- base::getNamespace("future")
[10:58:38.729]                         version <- ns[[".package"]][["version"]]
[10:58:38.729]                         if (is.null(version)) 
[10:58:38.729]                           version <- utils::packageVersion("future")
[10:58:38.729]                       }
[10:58:38.729]                       else {
[10:58:38.729]                         version <- NULL
[10:58:38.729]                       }
[10:58:38.729]                       if (!has_future || version < "1.8.0") {
[10:58:38.729]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.729]                           "", base::R.version$version.string), 
[10:58:38.729]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:38.729]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.729]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.729]                             "release", "version")], collapse = " "), 
[10:58:38.729]                           hostname = base::Sys.info()[["nodename"]])
[10:58:38.729]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.729]                           info)
[10:58:38.729]                         info <- base::paste(info, collapse = "; ")
[10:58:38.729]                         if (!has_future) {
[10:58:38.729]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.729]                             info)
[10:58:38.729]                         }
[10:58:38.729]                         else {
[10:58:38.729]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.729]                             info, version)
[10:58:38.729]                         }
[10:58:38.729]                         base::stop(msg)
[10:58:38.729]                       }
[10:58:38.729]                     })
[10:58:38.729]                   }
[10:58:38.729]                   ...future.strategy.old <- future::plan("list")
[10:58:38.729]                   options(future.plan = NULL)
[10:58:38.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.729]                 }
[10:58:38.729]                 ...future.workdir <- getwd()
[10:58:38.729]             }
[10:58:38.729]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.729]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.729]         }
[10:58:38.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.729]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.729]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.729]             base::names(...future.oldOptions))
[10:58:38.729]     }
[10:58:38.729]     if (FALSE) {
[10:58:38.729]     }
[10:58:38.729]     else {
[10:58:38.729]         if (TRUE) {
[10:58:38.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.729]                 open = "w")
[10:58:38.729]         }
[10:58:38.729]         else {
[10:58:38.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.729]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.729]         }
[10:58:38.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.729]             base::sink(type = "output", split = FALSE)
[10:58:38.729]             base::close(...future.stdout)
[10:58:38.729]         }, add = TRUE)
[10:58:38.729]     }
[10:58:38.729]     ...future.frame <- base::sys.nframe()
[10:58:38.729]     ...future.conditions <- base::list()
[10:58:38.729]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.729]     if (FALSE) {
[10:58:38.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.729]     }
[10:58:38.729]     ...future.result <- base::tryCatch({
[10:58:38.729]         base::withCallingHandlers({
[10:58:38.729]             ...future.value <- base::withVisible(base::local({
[10:58:38.729]                 do.call(function(...) {
[10:58:38.729]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.729]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.729]                     ...future.globals.maxSize)) {
[10:58:38.729]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.729]                     on.exit(options(oopts), add = TRUE)
[10:58:38.729]                   }
[10:58:38.729]                   {
[10:58:38.729]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.729]                       FUN = function(jj) {
[10:58:38.729]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.729]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.729]                       })
[10:58:38.729]                   }
[10:58:38.729]                 }, args = future.call.arguments)
[10:58:38.729]             }))
[10:58:38.729]             future::FutureResult(value = ...future.value$value, 
[10:58:38.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.729]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.729]                     ...future.globalenv.names))
[10:58:38.729]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.729]         }, condition = base::local({
[10:58:38.729]             c <- base::c
[10:58:38.729]             inherits <- base::inherits
[10:58:38.729]             invokeRestart <- base::invokeRestart
[10:58:38.729]             length <- base::length
[10:58:38.729]             list <- base::list
[10:58:38.729]             seq.int <- base::seq.int
[10:58:38.729]             signalCondition <- base::signalCondition
[10:58:38.729]             sys.calls <- base::sys.calls
[10:58:38.729]             `[[` <- base::`[[`
[10:58:38.729]             `+` <- base::`+`
[10:58:38.729]             `<<-` <- base::`<<-`
[10:58:38.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.729]                   3L)]
[10:58:38.729]             }
[10:58:38.729]             function(cond) {
[10:58:38.729]                 is_error <- inherits(cond, "error")
[10:58:38.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.729]                   NULL)
[10:58:38.729]                 if (is_error) {
[10:58:38.729]                   sessionInformation <- function() {
[10:58:38.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.729]                       search = base::search(), system = base::Sys.info())
[10:58:38.729]                   }
[10:58:38.729]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.729]                     cond$call), session = sessionInformation(), 
[10:58:38.729]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.729]                   signalCondition(cond)
[10:58:38.729]                 }
[10:58:38.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.729]                 "immediateCondition"))) {
[10:58:38.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.729]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.729]                   if (TRUE && !signal) {
[10:58:38.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.729]                     {
[10:58:38.729]                       inherits <- base::inherits
[10:58:38.729]                       invokeRestart <- base::invokeRestart
[10:58:38.729]                       is.null <- base::is.null
[10:58:38.729]                       muffled <- FALSE
[10:58:38.729]                       if (inherits(cond, "message")) {
[10:58:38.729]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.729]                         if (muffled) 
[10:58:38.729]                           invokeRestart("muffleMessage")
[10:58:38.729]                       }
[10:58:38.729]                       else if (inherits(cond, "warning")) {
[10:58:38.729]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.729]                         if (muffled) 
[10:58:38.729]                           invokeRestart("muffleWarning")
[10:58:38.729]                       }
[10:58:38.729]                       else if (inherits(cond, "condition")) {
[10:58:38.729]                         if (!is.null(pattern)) {
[10:58:38.729]                           computeRestarts <- base::computeRestarts
[10:58:38.729]                           grepl <- base::grepl
[10:58:38.729]                           restarts <- computeRestarts(cond)
[10:58:38.729]                           for (restart in restarts) {
[10:58:38.729]                             name <- restart$name
[10:58:38.729]                             if (is.null(name)) 
[10:58:38.729]                               next
[10:58:38.729]                             if (!grepl(pattern, name)) 
[10:58:38.729]                               next
[10:58:38.729]                             invokeRestart(restart)
[10:58:38.729]                             muffled <- TRUE
[10:58:38.729]                             break
[10:58:38.729]                           }
[10:58:38.729]                         }
[10:58:38.729]                       }
[10:58:38.729]                       invisible(muffled)
[10:58:38.729]                     }
[10:58:38.729]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.729]                   }
[10:58:38.729]                 }
[10:58:38.729]                 else {
[10:58:38.729]                   if (TRUE) {
[10:58:38.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.729]                     {
[10:58:38.729]                       inherits <- base::inherits
[10:58:38.729]                       invokeRestart <- base::invokeRestart
[10:58:38.729]                       is.null <- base::is.null
[10:58:38.729]                       muffled <- FALSE
[10:58:38.729]                       if (inherits(cond, "message")) {
[10:58:38.729]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.729]                         if (muffled) 
[10:58:38.729]                           invokeRestart("muffleMessage")
[10:58:38.729]                       }
[10:58:38.729]                       else if (inherits(cond, "warning")) {
[10:58:38.729]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.729]                         if (muffled) 
[10:58:38.729]                           invokeRestart("muffleWarning")
[10:58:38.729]                       }
[10:58:38.729]                       else if (inherits(cond, "condition")) {
[10:58:38.729]                         if (!is.null(pattern)) {
[10:58:38.729]                           computeRestarts <- base::computeRestarts
[10:58:38.729]                           grepl <- base::grepl
[10:58:38.729]                           restarts <- computeRestarts(cond)
[10:58:38.729]                           for (restart in restarts) {
[10:58:38.729]                             name <- restart$name
[10:58:38.729]                             if (is.null(name)) 
[10:58:38.729]                               next
[10:58:38.729]                             if (!grepl(pattern, name)) 
[10:58:38.729]                               next
[10:58:38.729]                             invokeRestart(restart)
[10:58:38.729]                             muffled <- TRUE
[10:58:38.729]                             break
[10:58:38.729]                           }
[10:58:38.729]                         }
[10:58:38.729]                       }
[10:58:38.729]                       invisible(muffled)
[10:58:38.729]                     }
[10:58:38.729]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.729]                   }
[10:58:38.729]                 }
[10:58:38.729]             }
[10:58:38.729]         }))
[10:58:38.729]     }, error = function(ex) {
[10:58:38.729]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.729]                 ...future.rng), started = ...future.startTime, 
[10:58:38.729]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.729]             version = "1.8"), class = "FutureResult")
[10:58:38.729]     }, finally = {
[10:58:38.729]         if (!identical(...future.workdir, getwd())) 
[10:58:38.729]             setwd(...future.workdir)
[10:58:38.729]         {
[10:58:38.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.729]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.729]             }
[10:58:38.729]             base::options(...future.oldOptions)
[10:58:38.729]             if (.Platform$OS.type == "windows") {
[10:58:38.729]                 old_names <- names(...future.oldEnvVars)
[10:58:38.729]                 envs <- base::Sys.getenv()
[10:58:38.729]                 names <- names(envs)
[10:58:38.729]                 common <- intersect(names, old_names)
[10:58:38.729]                 added <- setdiff(names, old_names)
[10:58:38.729]                 removed <- setdiff(old_names, names)
[10:58:38.729]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.729]                   envs[common]]
[10:58:38.729]                 NAMES <- toupper(changed)
[10:58:38.729]                 args <- list()
[10:58:38.729]                 for (kk in seq_along(NAMES)) {
[10:58:38.729]                   name <- changed[[kk]]
[10:58:38.729]                   NAME <- NAMES[[kk]]
[10:58:38.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.729]                     next
[10:58:38.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.729]                 }
[10:58:38.729]                 NAMES <- toupper(added)
[10:58:38.729]                 for (kk in seq_along(NAMES)) {
[10:58:38.729]                   name <- added[[kk]]
[10:58:38.729]                   NAME <- NAMES[[kk]]
[10:58:38.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.729]                     next
[10:58:38.729]                   args[[name]] <- ""
[10:58:38.729]                 }
[10:58:38.729]                 NAMES <- toupper(removed)
[10:58:38.729]                 for (kk in seq_along(NAMES)) {
[10:58:38.729]                   name <- removed[[kk]]
[10:58:38.729]                   NAME <- NAMES[[kk]]
[10:58:38.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.729]                     next
[10:58:38.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.729]                 }
[10:58:38.729]                 if (length(args) > 0) 
[10:58:38.729]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.729]             }
[10:58:38.729]             else {
[10:58:38.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.729]             }
[10:58:38.729]             {
[10:58:38.729]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.729]                   0L) {
[10:58:38.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.729]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.729]                   base::options(opts)
[10:58:38.729]                 }
[10:58:38.729]                 {
[10:58:38.729]                   {
[10:58:38.729]                     NULL
[10:58:38.729]                     RNGkind("Mersenne-Twister")
[10:58:38.729]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:58:38.729]                       inherits = FALSE)
[10:58:38.729]                   }
[10:58:38.729]                   options(future.plan = NULL)
[10:58:38.729]                   if (is.na(NA_character_)) 
[10:58:38.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.729]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.729]                     .init = FALSE)
[10:58:38.729]                 }
[10:58:38.729]             }
[10:58:38.729]         }
[10:58:38.729]     })
[10:58:38.729]     if (TRUE) {
[10:58:38.729]         base::sink(type = "output", split = FALSE)
[10:58:38.729]         if (TRUE) {
[10:58:38.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.729]         }
[10:58:38.729]         else {
[10:58:38.729]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.729]         }
[10:58:38.729]         base::close(...future.stdout)
[10:58:38.729]         ...future.stdout <- NULL
[10:58:38.729]     }
[10:58:38.729]     ...future.result$conditions <- ...future.conditions
[10:58:38.729]     ...future.result$finished <- base::Sys.time()
[10:58:38.729]     ...future.result
[10:58:38.729] }
[10:58:38.731] assign_globals() ...
[10:58:38.731] List of 5
[10:58:38.731]  $ future.call.arguments    : list()
[10:58:38.731]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.731]  $ ...future.FUN            :function (x)  
[10:58:38.731]  $ ...future.elements_ii    :List of 2
[10:58:38.731]   ..$ : int [1:2] 1 3
[10:58:38.731]   ..$ : int [1:2] 2 4
[10:58:38.731]  $ ...future.seeds_ii       : NULL
[10:58:38.731]  $ ...future.globals.maxSize: num Inf
[10:58:38.731]  - attr(*, "resolved")= logi FALSE
[10:58:38.731]  - attr(*, "total_size")= num NA
[10:58:38.731]  - attr(*, "where")=List of 5
[10:58:38.731]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.731]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.731]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.731]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.731]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.731]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.731]  - attr(*, "already-done")= logi TRUE
[10:58:38.736] - copied ‘future.call.arguments’ to environment
[10:58:38.736] - reassign environment for ‘...future.FUN’
[10:58:38.736] - copied ‘...future.FUN’ to environment
[10:58:38.736] - copied ‘...future.elements_ii’ to environment
[10:58:38.736] - copied ‘...future.seeds_ii’ to environment
[10:58:38.736] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.736] assign_globals() ... done
[10:58:38.736] plan(): Setting new future strategy stack:
[10:58:38.737] List of future strategies:
[10:58:38.737] 1. sequential:
[10:58:38.737]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.737]    - tweaked: FALSE
[10:58:38.737]    - call: NULL
[10:58:38.737] plan(): nbrOfWorkers() = 1
[10:58:38.738] plan(): Setting new future strategy stack:
[10:58:38.738] List of future strategies:
[10:58:38.738] 1. sequential:
[10:58:38.738]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.738]    - tweaked: FALSE
[10:58:38.738]    - call: plan(strategy)
[10:58:38.738] plan(): nbrOfWorkers() = 1
[10:58:38.738] SequentialFuture started (and completed)
[10:58:38.739] - Launch lazy future ... done
[10:58:38.739] run() for ‘SequentialFuture’ ... done
[10:58:38.739] Created future:
[10:58:38.739] SequentialFuture:
[10:58:38.739] Label: ‘future_apply-1’
[10:58:38.739] Expression:
[10:58:38.739] {
[10:58:38.739]     do.call(function(...) {
[10:58:38.739]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.739]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.739]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.739]             on.exit(options(oopts), add = TRUE)
[10:58:38.739]         }
[10:58:38.739]         {
[10:58:38.739]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.739]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.739]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.739]             })
[10:58:38.739]         }
[10:58:38.739]     }, args = future.call.arguments)
[10:58:38.739] }
[10:58:38.739] Lazy evaluation: FALSE
[10:58:38.739] Asynchronous evaluation: FALSE
[10:58:38.739] Local evaluation: TRUE
[10:58:38.739] Environment: R_GlobalEnv
[10:58:38.739] Capture standard output: TRUE
[10:58:38.739] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.739] Globals: 5 objects totaling 1.50 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 63 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.739] Packages: <none>
[10:58:38.739] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.739] Resolved: TRUE
[10:58:38.739] Value: 114 bytes of class ‘list’
[10:58:38.739] Early signaling: FALSE
[10:58:38.739] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.739] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.740] Chunk #1 of 1 ... DONE
[10:58:38.740] Launching 1 futures (chunks) ... DONE
[10:58:38.740] Resolving 1 futures (chunks) ...
[10:58:38.740] resolve() on list ...
[10:58:38.740]  recursive: 0
[10:58:38.741]  length: 1
[10:58:38.741] 
[10:58:38.741] resolved() for ‘SequentialFuture’ ...
[10:58:38.741] - state: ‘finished’
[10:58:38.741] - run: TRUE
[10:58:38.741] - result: ‘FutureResult’
[10:58:38.741] resolved() for ‘SequentialFuture’ ... done
[10:58:38.741] Future #1
[10:58:38.741] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.741] - nx: 1
[10:58:38.741] - relay: TRUE
[10:58:38.742] - stdout: TRUE
[10:58:38.742] - signal: TRUE
[10:58:38.742] - resignal: FALSE
[10:58:38.742] - force: TRUE
[10:58:38.742] - relayed: [n=1] FALSE
[10:58:38.742] - queued futures: [n=1] FALSE
[10:58:38.742]  - until=1
[10:58:38.742]  - relaying element #1
[10:58:38.742] - relayed: [n=1] TRUE
[10:58:38.742] - queued futures: [n=1] TRUE
[10:58:38.742] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.742]  length: 0 (resolved future 1)
[10:58:38.743] Relaying remaining futures
[10:58:38.743] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.743] - nx: 1
[10:58:38.743] - relay: TRUE
[10:58:38.743] - stdout: TRUE
[10:58:38.743] - signal: TRUE
[10:58:38.743] - resignal: FALSE
[10:58:38.743] - force: TRUE
[10:58:38.743] - relayed: [n=1] TRUE
[10:58:38.743] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.743] - relayed: [n=1] TRUE
[10:58:38.743] - queued futures: [n=1] TRUE
[10:58:38.743] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.744] resolve() on list ... DONE
[10:58:38.744]  - Number of value chunks collected: 1
[10:58:38.744] Resolving 1 futures (chunks) ... DONE
[10:58:38.744] Reducing values from 1 chunks ...
[10:58:38.744]  - Number of values collected after concatenation: 2
[10:58:38.744]  - Number of values expected: 2
[10:58:38.744] Reducing values from 1 chunks ... DONE
[10:58:38.744] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:58:38.744] getGlobalsAndPackagesXApply() ...
[10:58:38.744]  - future.globals: TRUE
[10:58:38.745] getGlobalsAndPackages() ...
[10:58:38.745] Searching for globals...
[10:58:38.747] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:58:38.747] Searching for globals ... DONE
[10:58:38.747] Resolving globals: FALSE
[10:58:38.748] The total size of the 1 globals is 3.66 KiB (3746 bytes)
[10:58:38.748] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 3.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.66 KiB of class ‘function’)
[10:58:38.748] - globals: [1] ‘FUN’
[10:58:38.748] 
[10:58:38.748] getGlobalsAndPackages() ... DONE
[10:58:38.749]  - globals found/used: [n=1] ‘FUN’
[10:58:38.749]  - needed namespaces: [n=0] 
[10:58:38.749] Finding globals ... DONE
[10:58:38.749]  - use_args: TRUE
[10:58:38.749]  - Getting '...' globals ...
[10:58:38.749] resolve() on list ...
[10:58:38.749]  recursive: 0
[10:58:38.749]  length: 1
[10:58:38.749]  elements: ‘...’
[10:58:38.749]  length: 0 (resolved future 1)
[10:58:38.750] resolve() on list ... DONE
[10:58:38.750]    - '...' content: [n=0] 
[10:58:38.750] List of 1
[10:58:38.750]  $ ...: list()
[10:58:38.750]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.750]  - attr(*, "where")=List of 1
[10:58:38.750]   ..$ ...:<environment: 0x5635bd019230> 
[10:58:38.750]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.750]  - attr(*, "resolved")= logi TRUE
[10:58:38.750]  - attr(*, "total_size")= num NA
[10:58:38.752]  - Getting '...' globals ... DONE
[10:58:38.752] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.752] List of 2
[10:58:38.752]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:58:38.752]  $ ...          : list()
[10:58:38.752]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.752]  - attr(*, "where")=List of 2
[10:58:38.752]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.752]   ..$ ...          :<environment: 0x5635bd019230> 
[10:58:38.752]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.752]  - attr(*, "resolved")= logi FALSE
[10:58:38.752]  - attr(*, "total_size")= num 9424
[10:58:38.755] Packages to be attached in all futures: [n=0] 
[10:58:38.755] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.755] future_lapply() ...
[10:58:38.757] Generating random seeds ...
[10:58:38.757] Generating random seed streams for 2 elements ...
[10:58:38.757] Generating random seed streams for 2 elements ... DONE
[10:58:38.757] Generating random seeds ... DONE
[10:58:38.757] Will set RNG state on exit: 10407, 276542291, -1159627650, -1251496766, -1017790202, 572781291, 777118461
[10:58:38.757] Number of chunks: 1
[10:58:38.757] getGlobalsAndPackagesXApply() ...
[10:58:38.757]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.758]  - use_args: TRUE
[10:58:38.758] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.758] List of 2
[10:58:38.758]  $ ...          : list()
[10:58:38.758]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.758]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:58:38.758]  - attr(*, "where")=List of 2
[10:58:38.758]   ..$ ...          :<environment: 0x5635bd019230> 
[10:58:38.758]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:38.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.758]  - attr(*, "resolved")= logi FALSE
[10:58:38.758]  - attr(*, "total_size")= num NA
[10:58:38.761] Packages to be attached in all futures: [n=0] 
[10:58:38.762] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.762] Number of futures (= number of chunks): 1
[10:58:38.762] Launching 1 futures (chunks) ...
[10:58:38.762] Chunk #1 of 1 ...
[10:58:38.762]  - seeds: [2] <seeds>
[10:58:38.762]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.762] getGlobalsAndPackages() ...
[10:58:38.762] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.762] Resolving globals: FALSE
[10:58:38.762] Tweak future expression to call with '...' arguments ...
[10:58:38.763] {
[10:58:38.763]     do.call(function(...) {
[10:58:38.763]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.763]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.763]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.763]             on.exit(options(oopts), add = TRUE)
[10:58:38.763]         }
[10:58:38.763]         {
[10:58:38.763]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.763]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.763]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:38.763]                   envir = globalenv(), inherits = FALSE)
[10:58:38.763]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.763]             })
[10:58:38.763]         }
[10:58:38.763]     }, args = future.call.arguments)
[10:58:38.763] }
[10:58:38.763] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.763] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.763] 
[10:58:38.763] getGlobalsAndPackages() ... DONE
[10:58:38.764] run() for ‘Future’ ...
[10:58:38.764] - state: ‘created’
[10:58:38.764] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:58:38.764] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.764] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:58:38.764]   - Field: ‘label’
[10:58:38.764]   - Field: ‘local’
[10:58:38.764]   - Field: ‘owner’
[10:58:38.764]   - Field: ‘envir’
[10:58:38.765]   - Field: ‘packages’
[10:58:38.765]   - Field: ‘gc’
[10:58:38.765]   - Field: ‘conditions’
[10:58:38.765]   - Field: ‘expr’
[10:58:38.765]   - Field: ‘uuid’
[10:58:38.765]   - Field: ‘seed’
[10:58:38.765]   - Field: ‘version’
[10:58:38.765]   - Field: ‘result’
[10:58:38.765]   - Field: ‘asynchronous’
[10:58:38.765]   - Field: ‘calls’
[10:58:38.765]   - Field: ‘globals’
[10:58:38.765]   - Field: ‘stdout’
[10:58:38.765]   - Field: ‘earlySignal’
[10:58:38.766]   - Field: ‘lazy’
[10:58:38.766]   - Field: ‘state’
[10:58:38.766] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:58:38.766] - Launch lazy future ...
[10:58:38.766] Packages needed by the future expression (n = 0): <none>
[10:58:38.766] Packages needed by future strategies (n = 0): <none>
[10:58:38.766] {
[10:58:38.766]     {
[10:58:38.766]         {
[10:58:38.766]             ...future.startTime <- base::Sys.time()
[10:58:38.766]             {
[10:58:38.766]                 {
[10:58:38.766]                   {
[10:58:38.766]                     base::local({
[10:58:38.766]                       has_future <- base::requireNamespace("future", 
[10:58:38.766]                         quietly = TRUE)
[10:58:38.766]                       if (has_future) {
[10:58:38.766]                         ns <- base::getNamespace("future")
[10:58:38.766]                         version <- ns[[".package"]][["version"]]
[10:58:38.766]                         if (is.null(version)) 
[10:58:38.766]                           version <- utils::packageVersion("future")
[10:58:38.766]                       }
[10:58:38.766]                       else {
[10:58:38.766]                         version <- NULL
[10:58:38.766]                       }
[10:58:38.766]                       if (!has_future || version < "1.8.0") {
[10:58:38.766]                         info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.766]                           "", base::R.version$version.string), 
[10:58:38.766]                           platform = base::sprintf("%s (%s-bit)", 
[10:58:38.766]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.766]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.766]                             "release", "version")], collapse = " "), 
[10:58:38.766]                           hostname = base::Sys.info()[["nodename"]])
[10:58:38.766]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.766]                           info)
[10:58:38.766]                         info <- base::paste(info, collapse = "; ")
[10:58:38.766]                         if (!has_future) {
[10:58:38.766]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.766]                             info)
[10:58:38.766]                         }
[10:58:38.766]                         else {
[10:58:38.766]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.766]                             info, version)
[10:58:38.766]                         }
[10:58:38.766]                         base::stop(msg)
[10:58:38.766]                       }
[10:58:38.766]                     })
[10:58:38.766]                   }
[10:58:38.766]                   ...future.strategy.old <- future::plan("list")
[10:58:38.766]                   options(future.plan = NULL)
[10:58:38.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.766]                 }
[10:58:38.766]                 ...future.workdir <- getwd()
[10:58:38.766]             }
[10:58:38.766]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.766]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.766]         }
[10:58:38.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.766]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.766]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.766]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.766]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.766]             base::names(...future.oldOptions))
[10:58:38.766]     }
[10:58:38.766]     if (FALSE) {
[10:58:38.766]     }
[10:58:38.766]     else {
[10:58:38.766]         if (TRUE) {
[10:58:38.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.766]                 open = "w")
[10:58:38.766]         }
[10:58:38.766]         else {
[10:58:38.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.766]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.766]         }
[10:58:38.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.766]             base::sink(type = "output", split = FALSE)
[10:58:38.766]             base::close(...future.stdout)
[10:58:38.766]         }, add = TRUE)
[10:58:38.766]     }
[10:58:38.766]     ...future.frame <- base::sys.nframe()
[10:58:38.766]     ...future.conditions <- base::list()
[10:58:38.766]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.766]     if (FALSE) {
[10:58:38.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.766]     }
[10:58:38.766]     ...future.result <- base::tryCatch({
[10:58:38.766]         base::withCallingHandlers({
[10:58:38.766]             ...future.value <- base::withVisible(base::local({
[10:58:38.766]                 do.call(function(...) {
[10:58:38.766]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.766]                   if (!identical(...future.globals.maxSize.org, 
[10:58:38.766]                     ...future.globals.maxSize)) {
[10:58:38.766]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.766]                     on.exit(options(oopts), add = TRUE)
[10:58:38.766]                   }
[10:58:38.766]                   {
[10:58:38.766]                     lapply(seq_along(...future.elements_ii), 
[10:58:38.766]                       FUN = function(jj) {
[10:58:38.766]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.766]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:38.766]                           envir = globalenv(), inherits = FALSE)
[10:58:38.766]                         ...future.FUN(...future.X_jj, ...)
[10:58:38.766]                       })
[10:58:38.766]                   }
[10:58:38.766]                 }, args = future.call.arguments)
[10:58:38.766]             }))
[10:58:38.766]             future::FutureResult(value = ...future.value$value, 
[10:58:38.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.766]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.766]                     ...future.globalenv.names))
[10:58:38.766]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.766]         }, condition = base::local({
[10:58:38.766]             c <- base::c
[10:58:38.766]             inherits <- base::inherits
[10:58:38.766]             invokeRestart <- base::invokeRestart
[10:58:38.766]             length <- base::length
[10:58:38.766]             list <- base::list
[10:58:38.766]             seq.int <- base::seq.int
[10:58:38.766]             signalCondition <- base::signalCondition
[10:58:38.766]             sys.calls <- base::sys.calls
[10:58:38.766]             `[[` <- base::`[[`
[10:58:38.766]             `+` <- base::`+`
[10:58:38.766]             `<<-` <- base::`<<-`
[10:58:38.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.766]                   3L)]
[10:58:38.766]             }
[10:58:38.766]             function(cond) {
[10:58:38.766]                 is_error <- inherits(cond, "error")
[10:58:38.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.766]                   NULL)
[10:58:38.766]                 if (is_error) {
[10:58:38.766]                   sessionInformation <- function() {
[10:58:38.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.766]                       search = base::search(), system = base::Sys.info())
[10:58:38.766]                   }
[10:58:38.766]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.766]                     cond$call), session = sessionInformation(), 
[10:58:38.766]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.766]                   signalCondition(cond)
[10:58:38.766]                 }
[10:58:38.766]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[10:58:38.766]                   signal <- TRUE && inherits(cond, character(0))
[10:58:38.766]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.766]                   if (TRUE && !signal) {
[10:58:38.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.766]                     {
[10:58:38.766]                       inherits <- base::inherits
[10:58:38.766]                       invokeRestart <- base::invokeRestart
[10:58:38.766]                       is.null <- base::is.null
[10:58:38.766]                       muffled <- FALSE
[10:58:38.766]                       if (inherits(cond, "message")) {
[10:58:38.766]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.766]                         if (muffled) 
[10:58:38.766]                           invokeRestart("muffleMessage")
[10:58:38.766]                       }
[10:58:38.766]                       else if (inherits(cond, "warning")) {
[10:58:38.766]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.766]                         if (muffled) 
[10:58:38.766]                           invokeRestart("muffleWarning")
[10:58:38.766]                       }
[10:58:38.766]                       else if (inherits(cond, "condition")) {
[10:58:38.766]                         if (!is.null(pattern)) {
[10:58:38.766]                           computeRestarts <- base::computeRestarts
[10:58:38.766]                           grepl <- base::grepl
[10:58:38.766]                           restarts <- computeRestarts(cond)
[10:58:38.766]                           for (restart in restarts) {
[10:58:38.766]                             name <- restart$name
[10:58:38.766]                             if (is.null(name)) 
[10:58:38.766]                               next
[10:58:38.766]                             if (!grepl(pattern, name)) 
[10:58:38.766]                               next
[10:58:38.766]                             invokeRestart(restart)
[10:58:38.766]                             muffled <- TRUE
[10:58:38.766]                             break
[10:58:38.766]                           }
[10:58:38.766]                         }
[10:58:38.766]                       }
[10:58:38.766]                       invisible(muffled)
[10:58:38.766]                     }
[10:58:38.766]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.766]                   }
[10:58:38.766]                 }
[10:58:38.766]                 else {
[10:58:38.766]                   if (FALSE) {
[10:58:38.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.766]                     {
[10:58:38.766]                       inherits <- base::inherits
[10:58:38.766]                       invokeRestart <- base::invokeRestart
[10:58:38.766]                       is.null <- base::is.null
[10:58:38.766]                       muffled <- FALSE
[10:58:38.766]                       if (inherits(cond, "message")) {
[10:58:38.766]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.766]                         if (muffled) 
[10:58:38.766]                           invokeRestart("muffleMessage")
[10:58:38.766]                       }
[10:58:38.766]                       else if (inherits(cond, "warning")) {
[10:58:38.766]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.766]                         if (muffled) 
[10:58:38.766]                           invokeRestart("muffleWarning")
[10:58:38.766]                       }
[10:58:38.766]                       else if (inherits(cond, "condition")) {
[10:58:38.766]                         if (!is.null(pattern)) {
[10:58:38.766]                           computeRestarts <- base::computeRestarts
[10:58:38.766]                           grepl <- base::grepl
[10:58:38.766]                           restarts <- computeRestarts(cond)
[10:58:38.766]                           for (restart in restarts) {
[10:58:38.766]                             name <- restart$name
[10:58:38.766]                             if (is.null(name)) 
[10:58:38.766]                               next
[10:58:38.766]                             if (!grepl(pattern, name)) 
[10:58:38.766]                               next
[10:58:38.766]                             invokeRestart(restart)
[10:58:38.766]                             muffled <- TRUE
[10:58:38.766]                             break
[10:58:38.766]                           }
[10:58:38.766]                         }
[10:58:38.766]                       }
[10:58:38.766]                       invisible(muffled)
[10:58:38.766]                     }
[10:58:38.766]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.766]                   }
[10:58:38.766]                 }
[10:58:38.766]             }
[10:58:38.766]         }))
[10:58:38.766]     }, error = function(ex) {
[10:58:38.766]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.766]                 ...future.rng), started = ...future.startTime, 
[10:58:38.766]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.766]             version = "1.8"), class = "FutureResult")
[10:58:38.766]     }, finally = {
[10:58:38.766]         if (!identical(...future.workdir, getwd())) 
[10:58:38.766]             setwd(...future.workdir)
[10:58:38.766]         {
[10:58:38.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.766]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.766]             }
[10:58:38.766]             base::options(...future.oldOptions)
[10:58:38.766]             if (.Platform$OS.type == "windows") {
[10:58:38.766]                 old_names <- names(...future.oldEnvVars)
[10:58:38.766]                 envs <- base::Sys.getenv()
[10:58:38.766]                 names <- names(envs)
[10:58:38.766]                 common <- intersect(names, old_names)
[10:58:38.766]                 added <- setdiff(names, old_names)
[10:58:38.766]                 removed <- setdiff(old_names, names)
[10:58:38.766]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.766]                   envs[common]]
[10:58:38.766]                 NAMES <- toupper(changed)
[10:58:38.766]                 args <- list()
[10:58:38.766]                 for (kk in seq_along(NAMES)) {
[10:58:38.766]                   name <- changed[[kk]]
[10:58:38.766]                   NAME <- NAMES[[kk]]
[10:58:38.766]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.766]                     next
[10:58:38.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.766]                 }
[10:58:38.766]                 NAMES <- toupper(added)
[10:58:38.766]                 for (kk in seq_along(NAMES)) {
[10:58:38.766]                   name <- added[[kk]]
[10:58:38.766]                   NAME <- NAMES[[kk]]
[10:58:38.766]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.766]                     next
[10:58:38.766]                   args[[name]] <- ""
[10:58:38.766]                 }
[10:58:38.766]                 NAMES <- toupper(removed)
[10:58:38.766]                 for (kk in seq_along(NAMES)) {
[10:58:38.766]                   name <- removed[[kk]]
[10:58:38.766]                   NAME <- NAMES[[kk]]
[10:58:38.766]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.766]                     next
[10:58:38.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.766]                 }
[10:58:38.766]                 if (length(args) > 0) 
[10:58:38.766]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.766]             }
[10:58:38.766]             else {
[10:58:38.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.766]             }
[10:58:38.766]             {
[10:58:38.766]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.766]                   0L) {
[10:58:38.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.766]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.766]                   base::options(opts)
[10:58:38.766]                 }
[10:58:38.766]                 {
[10:58:38.766]                   {
[10:58:38.766]                     base::assign(".Random.seed", c(10407L, 276542291L, 
[10:58:38.766]                     -1159627650L, -1251496766L, -1017790202L, 
[10:58:38.766]                     572781291L, 777118461L), envir = base::globalenv(), 
[10:58:38.766]                       inherits = FALSE)
[10:58:38.766]                     NULL
[10:58:38.766]                   }
[10:58:38.766]                   options(future.plan = NULL)
[10:58:38.766]                   if (is.na(NA_character_)) 
[10:58:38.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.766]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.766]                     .init = FALSE)
[10:58:38.766]                 }
[10:58:38.766]             }
[10:58:38.766]         }
[10:58:38.766]     })
[10:58:38.766]     if (TRUE) {
[10:58:38.766]         base::sink(type = "output", split = FALSE)
[10:58:38.766]         if (TRUE) {
[10:58:38.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.766]         }
[10:58:38.766]         else {
[10:58:38.766]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.766]         }
[10:58:38.766]         base::close(...future.stdout)
[10:58:38.766]         ...future.stdout <- NULL
[10:58:38.766]     }
[10:58:38.766]     ...future.result$conditions <- ...future.conditions
[10:58:38.766]     ...future.result$finished <- base::Sys.time()
[10:58:38.766]     ...future.result
[10:58:38.766] }
[10:58:38.768] assign_globals() ...
[10:58:38.768] List of 5
[10:58:38.768]  $ future.call.arguments    : list()
[10:58:38.768]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.768]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:58:38.768]  $ ...future.elements_ii    :List of 2
[10:58:38.768]   ..$ : int [1:2] 1 3
[10:58:38.768]   ..$ : int [1:2] 2 4
[10:58:38.768]  $ ...future.seeds_ii       :List of 2
[10:58:38.768]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:58:38.768]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:58:38.768]  $ ...future.globals.maxSize: num Inf
[10:58:38.768]  - attr(*, "resolved")= logi FALSE
[10:58:38.768]  - attr(*, "total_size")= num NA
[10:58:38.768]  - attr(*, "where")=List of 5
[10:58:38.768]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.768]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.768]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.768]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.768]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.768]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.768]  - attr(*, "already-done")= logi TRUE
[10:58:38.773] - copied ‘future.call.arguments’ to environment
[10:58:38.774] - copied ‘...future.FUN’ to environment
[10:58:38.774] - copied ‘...future.elements_ii’ to environment
[10:58:38.774] - copied ‘...future.seeds_ii’ to environment
[10:58:38.774] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.774] assign_globals() ... done
[10:58:38.774] plan(): Setting new future strategy stack:
[10:58:38.774] List of future strategies:
[10:58:38.774] 1. sequential:
[10:58:38.774]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.774]    - tweaked: FALSE
[10:58:38.774]    - call: NULL
[10:58:38.775] plan(): nbrOfWorkers() = 1
[10:58:38.775] plan(): Setting new future strategy stack:
[10:58:38.775] List of future strategies:
[10:58:38.775] 1. sequential:
[10:58:38.775]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.775]    - tweaked: FALSE
[10:58:38.775]    - call: plan(strategy)
[10:58:38.776] plan(): nbrOfWorkers() = 1
[10:58:38.776] SequentialFuture started (and completed)
[10:58:38.776] - Launch lazy future ... done
[10:58:38.776] run() for ‘SequentialFuture’ ... done
[10:58:38.776] Created future:
[10:58:38.776] SequentialFuture:
[10:58:38.776] Label: ‘future_apply-1’
[10:58:38.776] Expression:
[10:58:38.776] {
[10:58:38.776]     do.call(function(...) {
[10:58:38.776]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.776]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.776]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.776]             on.exit(options(oopts), add = TRUE)
[10:58:38.776]         }
[10:58:38.776]         {
[10:58:38.776]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.776]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.776]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:38.776]                   envir = globalenv(), inherits = FALSE)
[10:58:38.776]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.776]             })
[10:58:38.776]         }
[10:58:38.776]     }, args = future.call.arguments)
[10:58:38.776] }
[10:58:38.776] Lazy evaluation: FALSE
[10:58:38.776] Asynchronous evaluation: FALSE
[10:58:38.776] Local evaluation: TRUE
[10:58:38.776] Environment: R_GlobalEnv
[10:58:38.776] Capture standard output: TRUE
[10:58:38.776] Capture condition classes: <none>
[10:58:38.776] Globals: 5 objects totaling 3.95 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 63 bytes, list ‘...future.seeds_ii’ of 103 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.776] Packages: <none>
[10:58:38.776] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:58:38.776] Resolved: TRUE
[10:58:38.776] Value: 63 bytes of class ‘list’
[10:58:38.776] Early signaling: FALSE
[10:58:38.776] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.776] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:58:38.777] Chunk #1 of 1 ... DONE
[10:58:38.777] Launching 1 futures (chunks) ... DONE
[10:58:38.777] Resolving 1 futures (chunks) ...
[10:58:38.777] resolve() on list ...
[10:58:38.777]  recursive: 0
[10:58:38.777]  length: 1
[10:58:38.777] 
[10:58:38.778] resolved() for ‘SequentialFuture’ ...
[10:58:38.778] - state: ‘finished’
[10:58:38.778] - run: TRUE
[10:58:38.778] - result: ‘FutureResult’
[10:58:38.778] resolved() for ‘SequentialFuture’ ... done
[10:58:38.778] Future #1
[10:58:38.778] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:58:38.778] - nx: 1
[10:58:38.778] - relay: TRUE
[10:58:38.778] - stdout: TRUE
[10:58:38.778] - signal: TRUE
[10:58:38.779] - resignal: FALSE
[10:58:38.779] - force: TRUE
[10:58:38.779] - relayed: [n=1] FALSE
[10:58:38.779] - queued futures: [n=1] FALSE
[10:58:38.779]  - until=1
[10:58:38.779]  - relaying element #1
[10:58:38.779] - relayed: [n=1] TRUE
[10:58:38.779] - queued futures: [n=1] TRUE
[10:58:38.779] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:58:38.779]  length: 0 (resolved future 1)
[10:58:38.779] Relaying remaining futures
[10:58:38.779] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.780] - nx: 1
[10:58:38.780] - relay: TRUE
[10:58:38.780] - stdout: TRUE
[10:58:38.780] - signal: TRUE
[10:58:38.780] - resignal: FALSE
[10:58:38.780] - force: TRUE
[10:58:38.780] - relayed: [n=1] TRUE
[10:58:38.780] - queued futures: [n=1] TRUE
 - flush all
[10:58:38.780] - relayed: [n=1] TRUE
[10:58:38.780] - queued futures: [n=1] TRUE
[10:58:38.780] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.780] resolve() on list ... DONE
[10:58:38.781]  - Number of value chunks collected: 1
[10:58:38.781] Resolving 1 futures (chunks) ... DONE
[10:58:38.781] Reducing values from 1 chunks ...
[10:58:38.781]  - Number of values collected after concatenation: 2
[10:58:38.782]  - Number of values expected: 2
[10:58:38.782] Reducing values from 1 chunks ... DONE
[10:58:38.782] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:58:38.782] plan(): Setting new future strategy stack:
[10:58:38.782] List of future strategies:
[10:58:38.782] 1. sequential:
[10:58:38.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.782]    - tweaked: FALSE
[10:58:38.782]    - call: plan(sequential)
[10:58:38.782] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:58:38.783] plan(): Setting new future strategy stack:
[10:58:38.783] List of future strategies:
[10:58:38.783] 1. multicore:
[10:58:38.783]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:38.783]    - tweaked: FALSE
[10:58:38.783]    - call: plan(strategy)
[10:58:38.785] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[10:58:38.785] getGlobalsAndPackagesXApply() ...
[10:58:38.785]  - future.globals: TRUE
[10:58:38.785] getGlobalsAndPackages() ...
[10:58:38.785] Searching for globals...
[10:58:38.816] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:58:38.816] Searching for globals ... DONE
[10:58:38.816] Resolving globals: FALSE
[10:58:38.818] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:58:38.818] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:58:38.818] - globals: [1] ‘FUN’
[10:58:38.818] 
[10:58:38.818] getGlobalsAndPackages() ... DONE
[10:58:38.819]  - globals found/used: [n=1] ‘FUN’
[10:58:38.819]  - needed namespaces: [n=0] 
[10:58:38.819] Finding globals ... DONE
[10:58:38.819]  - use_args: TRUE
[10:58:38.819]  - Getting '...' globals ...
[10:58:38.819] resolve() on list ...
[10:58:38.819]  recursive: 0
[10:58:38.819]  length: 1
[10:58:38.819]  elements: ‘...’
[10:58:38.819]  length: 0 (resolved future 1)
[10:58:38.820] resolve() on list ... DONE
[10:58:38.820]    - '...' content: [n=0] 
[10:58:38.820] List of 1
[10:58:38.820]  $ ...: list()
[10:58:38.820]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.820]  - attr(*, "where")=List of 1
[10:58:38.820]   ..$ ...:<environment: 0x5635be2768e0> 
[10:58:38.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.820]  - attr(*, "resolved")= logi TRUE
[10:58:38.820]  - attr(*, "total_size")= num NA
[10:58:38.822]  - Getting '...' globals ... DONE
[10:58:38.822] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.822] List of 2
[10:58:38.822]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.822]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.822]  $ ...          : list()
[10:58:38.822]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.822]  - attr(*, "where")=List of 2
[10:58:38.822]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.822]   ..$ ...          :<environment: 0x5635be2768e0> 
[10:58:38.822]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.822]  - attr(*, "resolved")= logi FALSE
[10:58:38.822]  - attr(*, "total_size")= num 65963
[10:58:38.825] Packages to be attached in all futures: [n=0] 
[10:58:38.825] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.826] future_lapply() ...
[10:58:38.857] Number of chunks: 2
[10:58:38.857] getGlobalsAndPackagesXApply() ...
[10:58:38.857]  - future.globals: <name-value list> with names ‘list()’
[10:58:38.857]  - use_args: TRUE
[10:58:38.857] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:38.857] List of 2
[10:58:38.857]  $ ...          : list()
[10:58:38.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.857]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.857]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.857]  - attr(*, "where")=List of 2
[10:58:38.857]   ..$ ...          :<environment: 0x5635be2768e0> 
[10:58:38.857]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:38.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.857]  - attr(*, "resolved")= logi FALSE
[10:58:38.857]  - attr(*, "total_size")= num NA
[10:58:38.860] Packages to be attached in all futures: [n=0] 
[10:58:38.860] getGlobalsAndPackagesXApply() ... DONE
[10:58:38.860] Number of futures (= number of chunks): 2
[10:58:38.861] Launching 2 futures (chunks) ...
[10:58:38.861] Chunk #1 of 2 ...
[10:58:38.861]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:38.861]  - seeds: <none>
[10:58:38.861]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.861] getGlobalsAndPackages() ...
[10:58:38.861] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.861] Resolving globals: FALSE
[10:58:38.861] Tweak future expression to call with '...' arguments ...
[10:58:38.861] {
[10:58:38.861]     do.call(function(...) {
[10:58:38.861]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.861]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.861]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.861]             on.exit(options(oopts), add = TRUE)
[10:58:38.861]         }
[10:58:38.861]         {
[10:58:38.861]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.861]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.861]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.861]             })
[10:58:38.861]         }
[10:58:38.861]     }, args = future.call.arguments)
[10:58:38.861] }
[10:58:38.862] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.862] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.862] 
[10:58:38.862] getGlobalsAndPackages() ... DONE
[10:58:38.862] run() for ‘Future’ ...
[10:58:38.862] - state: ‘created’
[10:58:38.863] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:38.864] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:38.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:38.864]   - Field: ‘label’
[10:58:38.864]   - Field: ‘local’
[10:58:38.865]   - Field: ‘owner’
[10:58:38.865]   - Field: ‘envir’
[10:58:38.865]   - Field: ‘workers’
[10:58:38.865]   - Field: ‘packages’
[10:58:38.865]   - Field: ‘gc’
[10:58:38.865]   - Field: ‘job’
[10:58:38.865]   - Field: ‘conditions’
[10:58:38.865]   - Field: ‘expr’
[10:58:38.865]   - Field: ‘uuid’
[10:58:38.865]   - Field: ‘seed’
[10:58:38.865]   - Field: ‘version’
[10:58:38.865]   - Field: ‘result’
[10:58:38.866]   - Field: ‘asynchronous’
[10:58:38.866]   - Field: ‘calls’
[10:58:38.866]   - Field: ‘globals’
[10:58:38.866]   - Field: ‘stdout’
[10:58:38.866]   - Field: ‘earlySignal’
[10:58:38.866]   - Field: ‘lazy’
[10:58:38.866]   - Field: ‘state’
[10:58:38.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:38.866] - Launch lazy future ...
[10:58:38.867] Packages needed by the future expression (n = 0): <none>
[10:58:38.867] Packages needed by future strategies (n = 0): <none>
[10:58:38.868] {
[10:58:38.868]     {
[10:58:38.868]         {
[10:58:38.868]             ...future.startTime <- base::Sys.time()
[10:58:38.868]             {
[10:58:38.868]                 {
[10:58:38.868]                   {
[10:58:38.868]                     {
[10:58:38.868]                       base::local({
[10:58:38.868]                         has_future <- base::requireNamespace("future", 
[10:58:38.868]                           quietly = TRUE)
[10:58:38.868]                         if (has_future) {
[10:58:38.868]                           ns <- base::getNamespace("future")
[10:58:38.868]                           version <- ns[[".package"]][["version"]]
[10:58:38.868]                           if (is.null(version)) 
[10:58:38.868]                             version <- utils::packageVersion("future")
[10:58:38.868]                         }
[10:58:38.868]                         else {
[10:58:38.868]                           version <- NULL
[10:58:38.868]                         }
[10:58:38.868]                         if (!has_future || version < "1.8.0") {
[10:58:38.868]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.868]                             "", base::R.version$version.string), 
[10:58:38.868]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:38.868]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.868]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.868]                               "release", "version")], collapse = " "), 
[10:58:38.868]                             hostname = base::Sys.info()[["nodename"]])
[10:58:38.868]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.868]                             info)
[10:58:38.868]                           info <- base::paste(info, collapse = "; ")
[10:58:38.868]                           if (!has_future) {
[10:58:38.868]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.868]                               info)
[10:58:38.868]                           }
[10:58:38.868]                           else {
[10:58:38.868]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.868]                               info, version)
[10:58:38.868]                           }
[10:58:38.868]                           base::stop(msg)
[10:58:38.868]                         }
[10:58:38.868]                       })
[10:58:38.868]                     }
[10:58:38.868]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:38.868]                     base::options(mc.cores = 1L)
[10:58:38.868]                   }
[10:58:38.868]                   ...future.strategy.old <- future::plan("list")
[10:58:38.868]                   options(future.plan = NULL)
[10:58:38.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.868]                 }
[10:58:38.868]                 ...future.workdir <- getwd()
[10:58:38.868]             }
[10:58:38.868]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.868]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.868]         }
[10:58:38.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.868]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.868]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.868]             base::names(...future.oldOptions))
[10:58:38.868]     }
[10:58:38.868]     if (FALSE) {
[10:58:38.868]     }
[10:58:38.868]     else {
[10:58:38.868]         if (TRUE) {
[10:58:38.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.868]                 open = "w")
[10:58:38.868]         }
[10:58:38.868]         else {
[10:58:38.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.868]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.868]         }
[10:58:38.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.868]             base::sink(type = "output", split = FALSE)
[10:58:38.868]             base::close(...future.stdout)
[10:58:38.868]         }, add = TRUE)
[10:58:38.868]     }
[10:58:38.868]     ...future.frame <- base::sys.nframe()
[10:58:38.868]     ...future.conditions <- base::list()
[10:58:38.868]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.868]     if (FALSE) {
[10:58:38.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.868]     }
[10:58:38.868]     ...future.result <- base::tryCatch({
[10:58:38.868]         base::withCallingHandlers({
[10:58:38.868]             ...future.value <- base::withVisible(base::local({
[10:58:38.868]                 withCallingHandlers({
[10:58:38.868]                   {
[10:58:38.868]                     do.call(function(...) {
[10:58:38.868]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.868]                       if (!identical(...future.globals.maxSize.org, 
[10:58:38.868]                         ...future.globals.maxSize)) {
[10:58:38.868]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.868]                         on.exit(options(oopts), add = TRUE)
[10:58:38.868]                       }
[10:58:38.868]                       {
[10:58:38.868]                         lapply(seq_along(...future.elements_ii), 
[10:58:38.868]                           FUN = function(jj) {
[10:58:38.868]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.868]                             ...future.FUN(...future.X_jj, ...)
[10:58:38.868]                           })
[10:58:38.868]                       }
[10:58:38.868]                     }, args = future.call.arguments)
[10:58:38.868]                   }
[10:58:38.868]                 }, immediateCondition = function(cond) {
[10:58:38.868]                   save_rds <- function (object, pathname, ...) 
[10:58:38.868]                   {
[10:58:38.868]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:38.868]                     if (file_test("-f", pathname_tmp)) {
[10:58:38.868]                       fi_tmp <- file.info(pathname_tmp)
[10:58:38.868]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:38.868]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:38.868]                         fi_tmp[["mtime"]])
[10:58:38.868]                     }
[10:58:38.868]                     tryCatch({
[10:58:38.868]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:38.868]                     }, error = function(ex) {
[10:58:38.868]                       msg <- conditionMessage(ex)
[10:58:38.868]                       fi_tmp <- file.info(pathname_tmp)
[10:58:38.868]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:38.868]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:38.868]                         fi_tmp[["mtime"]], msg)
[10:58:38.868]                       ex$message <- msg
[10:58:38.868]                       stop(ex)
[10:58:38.868]                     })
[10:58:38.868]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:38.868]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:38.868]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:38.868]                       fi_tmp <- file.info(pathname_tmp)
[10:58:38.868]                       fi <- file.info(pathname)
[10:58:38.868]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:38.868]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:38.868]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:38.868]                         fi[["size"]], fi[["mtime"]])
[10:58:38.868]                       stop(msg)
[10:58:38.868]                     }
[10:58:38.868]                     invisible(pathname)
[10:58:38.868]                   }
[10:58:38.868]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:38.868]                     rootPath = tempdir()) 
[10:58:38.868]                   {
[10:58:38.868]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:38.868]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:38.868]                       tmpdir = path, fileext = ".rds")
[10:58:38.868]                     save_rds(obj, file)
[10:58:38.868]                   }
[10:58:38.868]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:38.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.868]                   {
[10:58:38.868]                     inherits <- base::inherits
[10:58:38.868]                     invokeRestart <- base::invokeRestart
[10:58:38.868]                     is.null <- base::is.null
[10:58:38.868]                     muffled <- FALSE
[10:58:38.868]                     if (inherits(cond, "message")) {
[10:58:38.868]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:38.868]                       if (muffled) 
[10:58:38.868]                         invokeRestart("muffleMessage")
[10:58:38.868]                     }
[10:58:38.868]                     else if (inherits(cond, "warning")) {
[10:58:38.868]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:38.868]                       if (muffled) 
[10:58:38.868]                         invokeRestart("muffleWarning")
[10:58:38.868]                     }
[10:58:38.868]                     else if (inherits(cond, "condition")) {
[10:58:38.868]                       if (!is.null(pattern)) {
[10:58:38.868]                         computeRestarts <- base::computeRestarts
[10:58:38.868]                         grepl <- base::grepl
[10:58:38.868]                         restarts <- computeRestarts(cond)
[10:58:38.868]                         for (restart in restarts) {
[10:58:38.868]                           name <- restart$name
[10:58:38.868]                           if (is.null(name)) 
[10:58:38.868]                             next
[10:58:38.868]                           if (!grepl(pattern, name)) 
[10:58:38.868]                             next
[10:58:38.868]                           invokeRestart(restart)
[10:58:38.868]                           muffled <- TRUE
[10:58:38.868]                           break
[10:58:38.868]                         }
[10:58:38.868]                       }
[10:58:38.868]                     }
[10:58:38.868]                     invisible(muffled)
[10:58:38.868]                   }
[10:58:38.868]                   muffleCondition(cond)
[10:58:38.868]                 })
[10:58:38.868]             }))
[10:58:38.868]             future::FutureResult(value = ...future.value$value, 
[10:58:38.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.868]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.868]                     ...future.globalenv.names))
[10:58:38.868]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.868]         }, condition = base::local({
[10:58:38.868]             c <- base::c
[10:58:38.868]             inherits <- base::inherits
[10:58:38.868]             invokeRestart <- base::invokeRestart
[10:58:38.868]             length <- base::length
[10:58:38.868]             list <- base::list
[10:58:38.868]             seq.int <- base::seq.int
[10:58:38.868]             signalCondition <- base::signalCondition
[10:58:38.868]             sys.calls <- base::sys.calls
[10:58:38.868]             `[[` <- base::`[[`
[10:58:38.868]             `+` <- base::`+`
[10:58:38.868]             `<<-` <- base::`<<-`
[10:58:38.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.868]                   3L)]
[10:58:38.868]             }
[10:58:38.868]             function(cond) {
[10:58:38.868]                 is_error <- inherits(cond, "error")
[10:58:38.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.868]                   NULL)
[10:58:38.868]                 if (is_error) {
[10:58:38.868]                   sessionInformation <- function() {
[10:58:38.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.868]                       search = base::search(), system = base::Sys.info())
[10:58:38.868]                   }
[10:58:38.868]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.868]                     cond$call), session = sessionInformation(), 
[10:58:38.868]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.868]                   signalCondition(cond)
[10:58:38.868]                 }
[10:58:38.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.868]                 "immediateCondition"))) {
[10:58:38.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.868]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.868]                   if (TRUE && !signal) {
[10:58:38.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.868]                     {
[10:58:38.868]                       inherits <- base::inherits
[10:58:38.868]                       invokeRestart <- base::invokeRestart
[10:58:38.868]                       is.null <- base::is.null
[10:58:38.868]                       muffled <- FALSE
[10:58:38.868]                       if (inherits(cond, "message")) {
[10:58:38.868]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.868]                         if (muffled) 
[10:58:38.868]                           invokeRestart("muffleMessage")
[10:58:38.868]                       }
[10:58:38.868]                       else if (inherits(cond, "warning")) {
[10:58:38.868]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.868]                         if (muffled) 
[10:58:38.868]                           invokeRestart("muffleWarning")
[10:58:38.868]                       }
[10:58:38.868]                       else if (inherits(cond, "condition")) {
[10:58:38.868]                         if (!is.null(pattern)) {
[10:58:38.868]                           computeRestarts <- base::computeRestarts
[10:58:38.868]                           grepl <- base::grepl
[10:58:38.868]                           restarts <- computeRestarts(cond)
[10:58:38.868]                           for (restart in restarts) {
[10:58:38.868]                             name <- restart$name
[10:58:38.868]                             if (is.null(name)) 
[10:58:38.868]                               next
[10:58:38.868]                             if (!grepl(pattern, name)) 
[10:58:38.868]                               next
[10:58:38.868]                             invokeRestart(restart)
[10:58:38.868]                             muffled <- TRUE
[10:58:38.868]                             break
[10:58:38.868]                           }
[10:58:38.868]                         }
[10:58:38.868]                       }
[10:58:38.868]                       invisible(muffled)
[10:58:38.868]                     }
[10:58:38.868]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.868]                   }
[10:58:38.868]                 }
[10:58:38.868]                 else {
[10:58:38.868]                   if (TRUE) {
[10:58:38.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.868]                     {
[10:58:38.868]                       inherits <- base::inherits
[10:58:38.868]                       invokeRestart <- base::invokeRestart
[10:58:38.868]                       is.null <- base::is.null
[10:58:38.868]                       muffled <- FALSE
[10:58:38.868]                       if (inherits(cond, "message")) {
[10:58:38.868]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.868]                         if (muffled) 
[10:58:38.868]                           invokeRestart("muffleMessage")
[10:58:38.868]                       }
[10:58:38.868]                       else if (inherits(cond, "warning")) {
[10:58:38.868]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.868]                         if (muffled) 
[10:58:38.868]                           invokeRestart("muffleWarning")
[10:58:38.868]                       }
[10:58:38.868]                       else if (inherits(cond, "condition")) {
[10:58:38.868]                         if (!is.null(pattern)) {
[10:58:38.868]                           computeRestarts <- base::computeRestarts
[10:58:38.868]                           grepl <- base::grepl
[10:58:38.868]                           restarts <- computeRestarts(cond)
[10:58:38.868]                           for (restart in restarts) {
[10:58:38.868]                             name <- restart$name
[10:58:38.868]                             if (is.null(name)) 
[10:58:38.868]                               next
[10:58:38.868]                             if (!grepl(pattern, name)) 
[10:58:38.868]                               next
[10:58:38.868]                             invokeRestart(restart)
[10:58:38.868]                             muffled <- TRUE
[10:58:38.868]                             break
[10:58:38.868]                           }
[10:58:38.868]                         }
[10:58:38.868]                       }
[10:58:38.868]                       invisible(muffled)
[10:58:38.868]                     }
[10:58:38.868]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.868]                   }
[10:58:38.868]                 }
[10:58:38.868]             }
[10:58:38.868]         }))
[10:58:38.868]     }, error = function(ex) {
[10:58:38.868]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.868]                 ...future.rng), started = ...future.startTime, 
[10:58:38.868]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.868]             version = "1.8"), class = "FutureResult")
[10:58:38.868]     }, finally = {
[10:58:38.868]         if (!identical(...future.workdir, getwd())) 
[10:58:38.868]             setwd(...future.workdir)
[10:58:38.868]         {
[10:58:38.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.868]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.868]             }
[10:58:38.868]             base::options(...future.oldOptions)
[10:58:38.868]             if (.Platform$OS.type == "windows") {
[10:58:38.868]                 old_names <- names(...future.oldEnvVars)
[10:58:38.868]                 envs <- base::Sys.getenv()
[10:58:38.868]                 names <- names(envs)
[10:58:38.868]                 common <- intersect(names, old_names)
[10:58:38.868]                 added <- setdiff(names, old_names)
[10:58:38.868]                 removed <- setdiff(old_names, names)
[10:58:38.868]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.868]                   envs[common]]
[10:58:38.868]                 NAMES <- toupper(changed)
[10:58:38.868]                 args <- list()
[10:58:38.868]                 for (kk in seq_along(NAMES)) {
[10:58:38.868]                   name <- changed[[kk]]
[10:58:38.868]                   NAME <- NAMES[[kk]]
[10:58:38.868]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.868]                     next
[10:58:38.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.868]                 }
[10:58:38.868]                 NAMES <- toupper(added)
[10:58:38.868]                 for (kk in seq_along(NAMES)) {
[10:58:38.868]                   name <- added[[kk]]
[10:58:38.868]                   NAME <- NAMES[[kk]]
[10:58:38.868]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.868]                     next
[10:58:38.868]                   args[[name]] <- ""
[10:58:38.868]                 }
[10:58:38.868]                 NAMES <- toupper(removed)
[10:58:38.868]                 for (kk in seq_along(NAMES)) {
[10:58:38.868]                   name <- removed[[kk]]
[10:58:38.868]                   NAME <- NAMES[[kk]]
[10:58:38.868]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.868]                     next
[10:58:38.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.868]                 }
[10:58:38.868]                 if (length(args) > 0) 
[10:58:38.868]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.868]             }
[10:58:38.868]             else {
[10:58:38.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.868]             }
[10:58:38.868]             {
[10:58:38.868]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.868]                   0L) {
[10:58:38.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.868]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.868]                   base::options(opts)
[10:58:38.868]                 }
[10:58:38.868]                 {
[10:58:38.868]                   {
[10:58:38.868]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:38.868]                     NULL
[10:58:38.868]                   }
[10:58:38.868]                   options(future.plan = NULL)
[10:58:38.868]                   if (is.na(NA_character_)) 
[10:58:38.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.868]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.868]                     .init = FALSE)
[10:58:38.868]                 }
[10:58:38.868]             }
[10:58:38.868]         }
[10:58:38.868]     })
[10:58:38.868]     if (TRUE) {
[10:58:38.868]         base::sink(type = "output", split = FALSE)
[10:58:38.868]         if (TRUE) {
[10:58:38.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.868]         }
[10:58:38.868]         else {
[10:58:38.868]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.868]         }
[10:58:38.868]         base::close(...future.stdout)
[10:58:38.868]         ...future.stdout <- NULL
[10:58:38.868]     }
[10:58:38.868]     ...future.result$conditions <- ...future.conditions
[10:58:38.868]     ...future.result$finished <- base::Sys.time()
[10:58:38.868]     ...future.result
[10:58:38.868] }
[10:58:38.870] assign_globals() ...
[10:58:38.870] List of 5
[10:58:38.870]  $ future.call.arguments    : list()
[10:58:38.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.870]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.870]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.870]  $ ...future.elements_ii    :List of 1
[10:58:38.870]   ..$ : num [1:4] 1 3 1 7
[10:58:38.870]  $ ...future.seeds_ii       : NULL
[10:58:38.870]  $ ...future.globals.maxSize: num Inf
[10:58:38.870]  - attr(*, "resolved")= logi FALSE
[10:58:38.870]  - attr(*, "total_size")= num NA
[10:58:38.870]  - attr(*, "where")=List of 5
[10:58:38.870]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.870]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.870]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.870]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.870]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.870]  - attr(*, "already-done")= logi TRUE
[10:58:38.875] - copied ‘future.call.arguments’ to environment
[10:58:38.875] - copied ‘...future.FUN’ to environment
[10:58:38.876] - copied ‘...future.elements_ii’ to environment
[10:58:38.876] - copied ‘...future.seeds_ii’ to environment
[10:58:38.876] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.876] assign_globals() ... done
[10:58:38.876] requestCore(): workers = 2
[10:58:38.879] MulticoreFuture started
[10:58:38.880] - Launch lazy future ... done
[10:58:38.880] plan(): Setting new future strategy stack:
[10:58:38.880] run() for ‘MulticoreFuture’ ... done
[10:58:38.880] Created future:
[10:58:38.880] List of future strategies:
[10:58:38.880] 1. sequential:
[10:58:38.880]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.880]    - tweaked: FALSE
[10:58:38.880]    - call: NULL
[10:58:38.881] plan(): nbrOfWorkers() = 1
[10:58:38.884] plan(): Setting new future strategy stack:
[10:58:38.884] List of future strategies:
[10:58:38.884] 1. multicore:
[10:58:38.884]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:38.884]    - tweaked: FALSE
[10:58:38.884]    - call: plan(strategy)
[10:58:38.887] plan(): nbrOfWorkers() = 2
[10:58:38.880] MulticoreFuture:
[10:58:38.880] Label: ‘future_apply-1’
[10:58:38.880] Expression:
[10:58:38.880] {
[10:58:38.880]     do.call(function(...) {
[10:58:38.880]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.880]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.880]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.880]             on.exit(options(oopts), add = TRUE)
[10:58:38.880]         }
[10:58:38.880]         {
[10:58:38.880]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.880]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.880]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.880]             })
[10:58:38.880]         }
[10:58:38.880]     }, args = future.call.arguments)
[10:58:38.880] }
[10:58:38.880] Lazy evaluation: FALSE
[10:58:38.880] Asynchronous evaluation: TRUE
[10:58:38.880] Local evaluation: TRUE
[10:58:38.880] Environment: R_GlobalEnv
[10:58:38.880] Capture standard output: TRUE
[10:58:38.880] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.880] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.880] Packages: <none>
[10:58:38.880] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.880] Resolved: TRUE
[10:58:38.880] Value: <not collected>
[10:58:38.880] Conditions captured: <none>
[10:58:38.880] Early signaling: FALSE
[10:58:38.880] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.880] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:38.889] Chunk #1 of 2 ... DONE
[10:58:38.889] Chunk #2 of 2 ...
[10:58:38.889]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:38.889]  - seeds: <none>
[10:58:38.890]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.890] getGlobalsAndPackages() ...
[10:58:38.890] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.890] Resolving globals: FALSE
[10:58:38.890] Tweak future expression to call with '...' arguments ...
[10:58:38.891] {
[10:58:38.891]     do.call(function(...) {
[10:58:38.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.891]             on.exit(options(oopts), add = TRUE)
[10:58:38.891]         }
[10:58:38.891]         {
[10:58:38.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.891]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.891]             })
[10:58:38.891]         }
[10:58:38.891]     }, args = future.call.arguments)
[10:58:38.891] }
[10:58:38.891] Tweak future expression to call with '...' arguments ... DONE
[10:58:38.892] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:38.892] 
[10:58:38.892] getGlobalsAndPackages() ... DONE
[10:58:38.893] run() for ‘Future’ ...
[10:58:38.893] - state: ‘created’
[10:58:38.893] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:38.896] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:38.897] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:38.897]   - Field: ‘label’
[10:58:38.897]   - Field: ‘local’
[10:58:38.897]   - Field: ‘owner’
[10:58:38.898]   - Field: ‘envir’
[10:58:38.898]   - Field: ‘workers’
[10:58:38.898]   - Field: ‘packages’
[10:58:38.898]   - Field: ‘gc’
[10:58:38.898]   - Field: ‘job’
[10:58:38.899]   - Field: ‘conditions’
[10:58:38.899]   - Field: ‘expr’
[10:58:38.899]   - Field: ‘uuid’
[10:58:38.899]   - Field: ‘seed’
[10:58:38.899]   - Field: ‘version’
[10:58:38.899]   - Field: ‘result’
[10:58:38.900]   - Field: ‘asynchronous’
[10:58:38.900]   - Field: ‘calls’
[10:58:38.900]   - Field: ‘globals’
[10:58:38.900]   - Field: ‘stdout’
[10:58:38.900]   - Field: ‘earlySignal’
[10:58:38.900]   - Field: ‘lazy’
[10:58:38.900]   - Field: ‘state’
[10:58:38.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:38.901] - Launch lazy future ...
[10:58:38.901] Packages needed by the future expression (n = 0): <none>
[10:58:38.902] Packages needed by future strategies (n = 0): <none>
[10:58:38.902] {
[10:58:38.902]     {
[10:58:38.902]         {
[10:58:38.902]             ...future.startTime <- base::Sys.time()
[10:58:38.902]             {
[10:58:38.902]                 {
[10:58:38.902]                   {
[10:58:38.902]                     {
[10:58:38.902]                       base::local({
[10:58:38.902]                         has_future <- base::requireNamespace("future", 
[10:58:38.902]                           quietly = TRUE)
[10:58:38.902]                         if (has_future) {
[10:58:38.902]                           ns <- base::getNamespace("future")
[10:58:38.902]                           version <- ns[[".package"]][["version"]]
[10:58:38.902]                           if (is.null(version)) 
[10:58:38.902]                             version <- utils::packageVersion("future")
[10:58:38.902]                         }
[10:58:38.902]                         else {
[10:58:38.902]                           version <- NULL
[10:58:38.902]                         }
[10:58:38.902]                         if (!has_future || version < "1.8.0") {
[10:58:38.902]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:38.902]                             "", base::R.version$version.string), 
[10:58:38.902]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:38.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:38.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:38.902]                               "release", "version")], collapse = " "), 
[10:58:38.902]                             hostname = base::Sys.info()[["nodename"]])
[10:58:38.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:38.902]                             info)
[10:58:38.902]                           info <- base::paste(info, collapse = "; ")
[10:58:38.902]                           if (!has_future) {
[10:58:38.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:38.902]                               info)
[10:58:38.902]                           }
[10:58:38.902]                           else {
[10:58:38.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:38.902]                               info, version)
[10:58:38.902]                           }
[10:58:38.902]                           base::stop(msg)
[10:58:38.902]                         }
[10:58:38.902]                       })
[10:58:38.902]                     }
[10:58:38.902]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:38.902]                     base::options(mc.cores = 1L)
[10:58:38.902]                   }
[10:58:38.902]                   ...future.strategy.old <- future::plan("list")
[10:58:38.902]                   options(future.plan = NULL)
[10:58:38.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:38.902]                 }
[10:58:38.902]                 ...future.workdir <- getwd()
[10:58:38.902]             }
[10:58:38.902]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:38.902]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:38.902]         }
[10:58:38.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:38.902]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:38.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:38.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:38.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:38.902]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:38.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:38.902]             base::names(...future.oldOptions))
[10:58:38.902]     }
[10:58:38.902]     if (FALSE) {
[10:58:38.902]     }
[10:58:38.902]     else {
[10:58:38.902]         if (TRUE) {
[10:58:38.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:38.902]                 open = "w")
[10:58:38.902]         }
[10:58:38.902]         else {
[10:58:38.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:38.902]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:38.902]         }
[10:58:38.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:38.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:38.902]             base::sink(type = "output", split = FALSE)
[10:58:38.902]             base::close(...future.stdout)
[10:58:38.902]         }, add = TRUE)
[10:58:38.902]     }
[10:58:38.902]     ...future.frame <- base::sys.nframe()
[10:58:38.902]     ...future.conditions <- base::list()
[10:58:38.902]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:38.902]     if (FALSE) {
[10:58:38.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:38.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:38.902]     }
[10:58:38.902]     ...future.result <- base::tryCatch({
[10:58:38.902]         base::withCallingHandlers({
[10:58:38.902]             ...future.value <- base::withVisible(base::local({
[10:58:38.902]                 withCallingHandlers({
[10:58:38.902]                   {
[10:58:38.902]                     do.call(function(...) {
[10:58:38.902]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.902]                       if (!identical(...future.globals.maxSize.org, 
[10:58:38.902]                         ...future.globals.maxSize)) {
[10:58:38.902]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.902]                         on.exit(options(oopts), add = TRUE)
[10:58:38.902]                       }
[10:58:38.902]                       {
[10:58:38.902]                         lapply(seq_along(...future.elements_ii), 
[10:58:38.902]                           FUN = function(jj) {
[10:58:38.902]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.902]                             ...future.FUN(...future.X_jj, ...)
[10:58:38.902]                           })
[10:58:38.902]                       }
[10:58:38.902]                     }, args = future.call.arguments)
[10:58:38.902]                   }
[10:58:38.902]                 }, immediateCondition = function(cond) {
[10:58:38.902]                   save_rds <- function (object, pathname, ...) 
[10:58:38.902]                   {
[10:58:38.902]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:38.902]                     if (file_test("-f", pathname_tmp)) {
[10:58:38.902]                       fi_tmp <- file.info(pathname_tmp)
[10:58:38.902]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:38.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:38.902]                         fi_tmp[["mtime"]])
[10:58:38.902]                     }
[10:58:38.902]                     tryCatch({
[10:58:38.902]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:38.902]                     }, error = function(ex) {
[10:58:38.902]                       msg <- conditionMessage(ex)
[10:58:38.902]                       fi_tmp <- file.info(pathname_tmp)
[10:58:38.902]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:38.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:38.902]                         fi_tmp[["mtime"]], msg)
[10:58:38.902]                       ex$message <- msg
[10:58:38.902]                       stop(ex)
[10:58:38.902]                     })
[10:58:38.902]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:38.902]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:38.902]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:38.902]                       fi_tmp <- file.info(pathname_tmp)
[10:58:38.902]                       fi <- file.info(pathname)
[10:58:38.902]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:38.902]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:38.902]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:38.902]                         fi[["size"]], fi[["mtime"]])
[10:58:38.902]                       stop(msg)
[10:58:38.902]                     }
[10:58:38.902]                     invisible(pathname)
[10:58:38.902]                   }
[10:58:38.902]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:38.902]                     rootPath = tempdir()) 
[10:58:38.902]                   {
[10:58:38.902]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:38.902]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:38.902]                       tmpdir = path, fileext = ".rds")
[10:58:38.902]                     save_rds(obj, file)
[10:58:38.902]                   }
[10:58:38.902]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:38.902]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.902]                   {
[10:58:38.902]                     inherits <- base::inherits
[10:58:38.902]                     invokeRestart <- base::invokeRestart
[10:58:38.902]                     is.null <- base::is.null
[10:58:38.902]                     muffled <- FALSE
[10:58:38.902]                     if (inherits(cond, "message")) {
[10:58:38.902]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:38.902]                       if (muffled) 
[10:58:38.902]                         invokeRestart("muffleMessage")
[10:58:38.902]                     }
[10:58:38.902]                     else if (inherits(cond, "warning")) {
[10:58:38.902]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:38.902]                       if (muffled) 
[10:58:38.902]                         invokeRestart("muffleWarning")
[10:58:38.902]                     }
[10:58:38.902]                     else if (inherits(cond, "condition")) {
[10:58:38.902]                       if (!is.null(pattern)) {
[10:58:38.902]                         computeRestarts <- base::computeRestarts
[10:58:38.902]                         grepl <- base::grepl
[10:58:38.902]                         restarts <- computeRestarts(cond)
[10:58:38.902]                         for (restart in restarts) {
[10:58:38.902]                           name <- restart$name
[10:58:38.902]                           if (is.null(name)) 
[10:58:38.902]                             next
[10:58:38.902]                           if (!grepl(pattern, name)) 
[10:58:38.902]                             next
[10:58:38.902]                           invokeRestart(restart)
[10:58:38.902]                           muffled <- TRUE
[10:58:38.902]                           break
[10:58:38.902]                         }
[10:58:38.902]                       }
[10:58:38.902]                     }
[10:58:38.902]                     invisible(muffled)
[10:58:38.902]                   }
[10:58:38.902]                   muffleCondition(cond)
[10:58:38.902]                 })
[10:58:38.902]             }))
[10:58:38.902]             future::FutureResult(value = ...future.value$value, 
[10:58:38.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.902]                   ...future.rng), globalenv = if (FALSE) 
[10:58:38.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:38.902]                     ...future.globalenv.names))
[10:58:38.902]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:38.902]         }, condition = base::local({
[10:58:38.902]             c <- base::c
[10:58:38.902]             inherits <- base::inherits
[10:58:38.902]             invokeRestart <- base::invokeRestart
[10:58:38.902]             length <- base::length
[10:58:38.902]             list <- base::list
[10:58:38.902]             seq.int <- base::seq.int
[10:58:38.902]             signalCondition <- base::signalCondition
[10:58:38.902]             sys.calls <- base::sys.calls
[10:58:38.902]             `[[` <- base::`[[`
[10:58:38.902]             `+` <- base::`+`
[10:58:38.902]             `<<-` <- base::`<<-`
[10:58:38.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:38.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:38.902]                   3L)]
[10:58:38.902]             }
[10:58:38.902]             function(cond) {
[10:58:38.902]                 is_error <- inherits(cond, "error")
[10:58:38.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:38.902]                   NULL)
[10:58:38.902]                 if (is_error) {
[10:58:38.902]                   sessionInformation <- function() {
[10:58:38.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:38.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:38.902]                       search = base::search(), system = base::Sys.info())
[10:58:38.902]                   }
[10:58:38.902]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:38.902]                     cond$call), session = sessionInformation(), 
[10:58:38.902]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:38.902]                   signalCondition(cond)
[10:58:38.902]                 }
[10:58:38.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:38.902]                 "immediateCondition"))) {
[10:58:38.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:38.902]                   ...future.conditions[[length(...future.conditions) + 
[10:58:38.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:38.902]                   if (TRUE && !signal) {
[10:58:38.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.902]                     {
[10:58:38.902]                       inherits <- base::inherits
[10:58:38.902]                       invokeRestart <- base::invokeRestart
[10:58:38.902]                       is.null <- base::is.null
[10:58:38.902]                       muffled <- FALSE
[10:58:38.902]                       if (inherits(cond, "message")) {
[10:58:38.902]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.902]                         if (muffled) 
[10:58:38.902]                           invokeRestart("muffleMessage")
[10:58:38.902]                       }
[10:58:38.902]                       else if (inherits(cond, "warning")) {
[10:58:38.902]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.902]                         if (muffled) 
[10:58:38.902]                           invokeRestart("muffleWarning")
[10:58:38.902]                       }
[10:58:38.902]                       else if (inherits(cond, "condition")) {
[10:58:38.902]                         if (!is.null(pattern)) {
[10:58:38.902]                           computeRestarts <- base::computeRestarts
[10:58:38.902]                           grepl <- base::grepl
[10:58:38.902]                           restarts <- computeRestarts(cond)
[10:58:38.902]                           for (restart in restarts) {
[10:58:38.902]                             name <- restart$name
[10:58:38.902]                             if (is.null(name)) 
[10:58:38.902]                               next
[10:58:38.902]                             if (!grepl(pattern, name)) 
[10:58:38.902]                               next
[10:58:38.902]                             invokeRestart(restart)
[10:58:38.902]                             muffled <- TRUE
[10:58:38.902]                             break
[10:58:38.902]                           }
[10:58:38.902]                         }
[10:58:38.902]                       }
[10:58:38.902]                       invisible(muffled)
[10:58:38.902]                     }
[10:58:38.902]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.902]                   }
[10:58:38.902]                 }
[10:58:38.902]                 else {
[10:58:38.902]                   if (TRUE) {
[10:58:38.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:38.902]                     {
[10:58:38.902]                       inherits <- base::inherits
[10:58:38.902]                       invokeRestart <- base::invokeRestart
[10:58:38.902]                       is.null <- base::is.null
[10:58:38.902]                       muffled <- FALSE
[10:58:38.902]                       if (inherits(cond, "message")) {
[10:58:38.902]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:38.902]                         if (muffled) 
[10:58:38.902]                           invokeRestart("muffleMessage")
[10:58:38.902]                       }
[10:58:38.902]                       else if (inherits(cond, "warning")) {
[10:58:38.902]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:38.902]                         if (muffled) 
[10:58:38.902]                           invokeRestart("muffleWarning")
[10:58:38.902]                       }
[10:58:38.902]                       else if (inherits(cond, "condition")) {
[10:58:38.902]                         if (!is.null(pattern)) {
[10:58:38.902]                           computeRestarts <- base::computeRestarts
[10:58:38.902]                           grepl <- base::grepl
[10:58:38.902]                           restarts <- computeRestarts(cond)
[10:58:38.902]                           for (restart in restarts) {
[10:58:38.902]                             name <- restart$name
[10:58:38.902]                             if (is.null(name)) 
[10:58:38.902]                               next
[10:58:38.902]                             if (!grepl(pattern, name)) 
[10:58:38.902]                               next
[10:58:38.902]                             invokeRestart(restart)
[10:58:38.902]                             muffled <- TRUE
[10:58:38.902]                             break
[10:58:38.902]                           }
[10:58:38.902]                         }
[10:58:38.902]                       }
[10:58:38.902]                       invisible(muffled)
[10:58:38.902]                     }
[10:58:38.902]                     muffleCondition(cond, pattern = "^muffle")
[10:58:38.902]                   }
[10:58:38.902]                 }
[10:58:38.902]             }
[10:58:38.902]         }))
[10:58:38.902]     }, error = function(ex) {
[10:58:38.902]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:38.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:38.902]                 ...future.rng), started = ...future.startTime, 
[10:58:38.902]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:38.902]             version = "1.8"), class = "FutureResult")
[10:58:38.902]     }, finally = {
[10:58:38.902]         if (!identical(...future.workdir, getwd())) 
[10:58:38.902]             setwd(...future.workdir)
[10:58:38.902]         {
[10:58:38.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:38.902]                 ...future.oldOptions$nwarnings <- NULL
[10:58:38.902]             }
[10:58:38.902]             base::options(...future.oldOptions)
[10:58:38.902]             if (.Platform$OS.type == "windows") {
[10:58:38.902]                 old_names <- names(...future.oldEnvVars)
[10:58:38.902]                 envs <- base::Sys.getenv()
[10:58:38.902]                 names <- names(envs)
[10:58:38.902]                 common <- intersect(names, old_names)
[10:58:38.902]                 added <- setdiff(names, old_names)
[10:58:38.902]                 removed <- setdiff(old_names, names)
[10:58:38.902]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:38.902]                   envs[common]]
[10:58:38.902]                 NAMES <- toupper(changed)
[10:58:38.902]                 args <- list()
[10:58:38.902]                 for (kk in seq_along(NAMES)) {
[10:58:38.902]                   name <- changed[[kk]]
[10:58:38.902]                   NAME <- NAMES[[kk]]
[10:58:38.902]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.902]                     next
[10:58:38.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.902]                 }
[10:58:38.902]                 NAMES <- toupper(added)
[10:58:38.902]                 for (kk in seq_along(NAMES)) {
[10:58:38.902]                   name <- added[[kk]]
[10:58:38.902]                   NAME <- NAMES[[kk]]
[10:58:38.902]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.902]                     next
[10:58:38.902]                   args[[name]] <- ""
[10:58:38.902]                 }
[10:58:38.902]                 NAMES <- toupper(removed)
[10:58:38.902]                 for (kk in seq_along(NAMES)) {
[10:58:38.902]                   name <- removed[[kk]]
[10:58:38.902]                   NAME <- NAMES[[kk]]
[10:58:38.902]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:38.902]                     next
[10:58:38.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:38.902]                 }
[10:58:38.902]                 if (length(args) > 0) 
[10:58:38.902]                   base::do.call(base::Sys.setenv, args = args)
[10:58:38.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:38.902]             }
[10:58:38.902]             else {
[10:58:38.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:38.902]             }
[10:58:38.902]             {
[10:58:38.902]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:38.902]                   0L) {
[10:58:38.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:38.902]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:38.902]                   base::options(opts)
[10:58:38.902]                 }
[10:58:38.902]                 {
[10:58:38.902]                   {
[10:58:38.902]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:38.902]                     NULL
[10:58:38.902]                   }
[10:58:38.902]                   options(future.plan = NULL)
[10:58:38.902]                   if (is.na(NA_character_)) 
[10:58:38.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:38.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:38.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:38.902]                     .init = FALSE)
[10:58:38.902]                 }
[10:58:38.902]             }
[10:58:38.902]         }
[10:58:38.902]     })
[10:58:38.902]     if (TRUE) {
[10:58:38.902]         base::sink(type = "output", split = FALSE)
[10:58:38.902]         if (TRUE) {
[10:58:38.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:38.902]         }
[10:58:38.902]         else {
[10:58:38.902]             ...future.result["stdout"] <- base::list(NULL)
[10:58:38.902]         }
[10:58:38.902]         base::close(...future.stdout)
[10:58:38.902]         ...future.stdout <- NULL
[10:58:38.902]     }
[10:58:38.902]     ...future.result$conditions <- ...future.conditions
[10:58:38.902]     ...future.result$finished <- base::Sys.time()
[10:58:38.902]     ...future.result
[10:58:38.902] }
[10:58:38.906] assign_globals() ...
[10:58:38.906] List of 5
[10:58:38.906]  $ future.call.arguments    : list()
[10:58:38.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.906]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.906]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.906]  $ ...future.elements_ii    :List of 1
[10:58:38.906]   ..$ : num [1:4] 2 4 6 8
[10:58:38.906]  $ ...future.seeds_ii       : NULL
[10:58:38.906]  $ ...future.globals.maxSize: num Inf
[10:58:38.906]  - attr(*, "resolved")= logi FALSE
[10:58:38.906]  - attr(*, "total_size")= num NA
[10:58:38.906]  - attr(*, "where")=List of 5
[10:58:38.906]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:38.906]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:38.906]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:38.906]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:38.906]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:38.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.906]  - attr(*, "already-done")= logi TRUE
[10:58:38.915] - copied ‘future.call.arguments’ to environment
[10:58:38.915] - copied ‘...future.FUN’ to environment
[10:58:38.915] - copied ‘...future.elements_ii’ to environment
[10:58:38.915] - copied ‘...future.seeds_ii’ to environment
[10:58:38.916] - copied ‘...future.globals.maxSize’ to environment
[10:58:38.916] assign_globals() ... done
[10:58:38.916] requestCore(): workers = 2
[10:58:38.923] MulticoreFuture started
[10:58:38.923] - Launch lazy future ... done
[10:58:38.923] run() for ‘MulticoreFuture’ ... done
[10:58:38.924] plan(): Setting new future strategy stack:
[10:58:38.924] Created future:
[10:58:38.924] List of future strategies:
[10:58:38.924] 1. sequential:
[10:58:38.924]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:38.924]    - tweaked: FALSE
[10:58:38.924]    - call: NULL
[10:58:38.929] plan(): nbrOfWorkers() = 1
[10:58:38.933] plan(): Setting new future strategy stack:
[10:58:38.933] List of future strategies:
[10:58:38.933] 1. multicore:
[10:58:38.933]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:38.933]    - tweaked: FALSE
[10:58:38.933]    - call: plan(strategy)
[10:58:38.937] plan(): nbrOfWorkers() = 2
[10:58:38.924] MulticoreFuture:
[10:58:38.924] Label: ‘future_apply-2’
[10:58:38.924] Expression:
[10:58:38.924] {
[10:58:38.924]     do.call(function(...) {
[10:58:38.924]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:38.924]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:38.924]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:38.924]             on.exit(options(oopts), add = TRUE)
[10:58:38.924]         }
[10:58:38.924]         {
[10:58:38.924]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:38.924]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:38.924]                 ...future.FUN(...future.X_jj, ...)
[10:58:38.924]             })
[10:58:38.924]         }
[10:58:38.924]     }, args = future.call.arguments)
[10:58:38.924] }
[10:58:38.924] Lazy evaluation: FALSE
[10:58:38.924] Asynchronous evaluation: TRUE
[10:58:38.924] Local evaluation: TRUE
[10:58:38.924] Environment: R_GlobalEnv
[10:58:38.924] Capture standard output: TRUE
[10:58:38.924] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:38.924] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:38.924] Packages: <none>
[10:58:38.924] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:38.924] Resolved: TRUE
[10:58:38.924] Value: <not collected>
[10:58:38.924] Conditions captured: <none>
[10:58:38.924] Early signaling: FALSE
[10:58:38.924] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:38.924] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:38.939] Chunk #2 of 2 ... DONE
[10:58:38.939] Launching 2 futures (chunks) ... DONE
[10:58:38.939] Resolving 2 futures (chunks) ...
[10:58:38.940] resolve() on list ...
[10:58:38.940]  recursive: 0
[10:58:38.940]  length: 2
[10:58:38.940] 
[10:58:38.941] Future #1
[10:58:38.942] result() for MulticoreFuture ...
[10:58:38.943] result() for MulticoreFuture ...
[10:58:38.944] result() for MulticoreFuture ... done
[10:58:38.944] result() for MulticoreFuture ... done
[10:58:38.944] result() for MulticoreFuture ...
[10:58:38.944] result() for MulticoreFuture ... done
[10:58:38.944] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:38.944] - nx: 2
[10:58:38.944] - relay: TRUE
[10:58:38.945] - stdout: TRUE
[10:58:38.945] - signal: TRUE
[10:58:38.945] - resignal: FALSE
[10:58:38.945] - force: TRUE
[10:58:38.945] - relayed: [n=2] FALSE, FALSE
[10:58:38.945] - queued futures: [n=2] FALSE, FALSE
[10:58:38.945]  - until=1
[10:58:38.946]  - relaying element #1
[10:58:38.946] result() for MulticoreFuture ...
[10:58:38.946] result() for MulticoreFuture ... done
[10:58:38.946] result() for MulticoreFuture ...
[10:58:38.946] result() for MulticoreFuture ... done
[10:58:38.946] result() for MulticoreFuture ...
[10:58:38.947] result() for MulticoreFuture ... done
[10:58:38.947] result() for MulticoreFuture ...
[10:58:38.947] result() for MulticoreFuture ... done
[10:58:38.947] - relayed: [n=2] TRUE, FALSE
[10:58:38.947] - queued futures: [n=2] TRUE, FALSE
[10:58:38.947] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:38.947]  length: 1 (resolved future 1)
[10:58:38.948] Future #2
[10:58:38.948] result() for MulticoreFuture ...
[10:58:38.948] result() for MulticoreFuture ...
[10:58:38.949] result() for MulticoreFuture ... done
[10:58:38.949] result() for MulticoreFuture ... done
[10:58:38.949] result() for MulticoreFuture ...
[10:58:38.949] result() for MulticoreFuture ... done
[10:58:38.949] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:38.949] - nx: 2
[10:58:38.949] - relay: TRUE
[10:58:38.949] - stdout: TRUE
[10:58:38.950] - signal: TRUE
[10:58:38.950] - resignal: FALSE
[10:58:38.950] - force: TRUE
[10:58:38.950] - relayed: [n=2] TRUE, FALSE
[10:58:38.950] - queued futures: [n=2] TRUE, FALSE
[10:58:38.950]  - until=2
[10:58:38.950]  - relaying element #2
[10:58:38.950] result() for MulticoreFuture ...
[10:58:38.950] result() for MulticoreFuture ... done
[10:58:38.950] result() for MulticoreFuture ...
[10:58:38.951] result() for MulticoreFuture ... done
[10:58:38.951] result() for MulticoreFuture ...
[10:58:38.951] result() for MulticoreFuture ... done
[10:58:38.951] result() for MulticoreFuture ...
[10:58:38.951] result() for MulticoreFuture ... done
[10:58:38.951] - relayed: [n=2] TRUE, TRUE
[10:58:38.951] - queued futures: [n=2] TRUE, TRUE
[10:58:38.951] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:38.952]  length: 0 (resolved future 2)
[10:58:38.952] Relaying remaining futures
[10:58:38.952] signalConditionsASAP(NULL, pos=0) ...
[10:58:38.952] - nx: 2
[10:58:38.952] - relay: TRUE
[10:58:38.952] - stdout: TRUE
[10:58:38.952] - signal: TRUE
[10:58:38.952] - resignal: FALSE
[10:58:38.952] - force: TRUE
[10:58:38.952] - relayed: [n=2] TRUE, TRUE
[10:58:38.952] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:38.953] - relayed: [n=2] TRUE, TRUE
[10:58:38.953] - queued futures: [n=2] TRUE, TRUE
[10:58:38.953] signalConditionsASAP(NULL, pos=0) ... done
[10:58:38.953] resolve() on list ... DONE
[10:58:38.953] result() for MulticoreFuture ...
[10:58:38.953] result() for MulticoreFuture ... done
[10:58:38.953] result() for MulticoreFuture ...
[10:58:38.953] result() for MulticoreFuture ... done
[10:58:38.953] result() for MulticoreFuture ...
[10:58:38.954] result() for MulticoreFuture ... done
[10:58:38.954] result() for MulticoreFuture ...
[10:58:38.954] result() for MulticoreFuture ... done
[10:58:38.954]  - Number of value chunks collected: 2
[10:58:38.954] Resolving 2 futures (chunks) ... DONE
[10:58:38.954] Reducing values from 2 chunks ...
[10:58:38.954]  - Number of values collected after concatenation: 2
[10:58:38.954]  - Number of values expected: 2
[10:58:38.955] Reducing values from 2 chunks ... DONE
[10:58:38.955] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:58:38.955] getGlobalsAndPackagesXApply() ...
[10:58:38.955]  - future.globals: TRUE
[10:58:38.955] getGlobalsAndPackages() ...
[10:58:38.955] Searching for globals...
[10:58:38.990] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:58:38.990] Searching for globals ... DONE
[10:58:38.990] Resolving globals: FALSE
[10:58:38.992] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:58:38.992] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:58:38.992] - globals: [1] ‘FUN’
[10:58:38.993] 
[10:58:38.993] getGlobalsAndPackages() ... DONE
[10:58:38.993]  - globals found/used: [n=1] ‘FUN’
[10:58:38.993]  - needed namespaces: [n=0] 
[10:58:38.993] Finding globals ... DONE
[10:58:38.993]  - use_args: TRUE
[10:58:38.993]  - Getting '...' globals ...
[10:58:38.993] resolve() on list ...
[10:58:38.993]  recursive: 0
[10:58:38.994]  length: 1
[10:58:38.994]  elements: ‘...’
[10:58:38.994]  length: 0 (resolved future 1)
[10:58:38.994] resolve() on list ... DONE
[10:58:38.994]    - '...' content: [n=0] 
[10:58:38.994] List of 1
[10:58:38.994]  $ ...: list()
[10:58:38.994]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.994]  - attr(*, "where")=List of 1
[10:58:38.994]   ..$ ...:<environment: 0x5635bf0f75d0> 
[10:58:38.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.994]  - attr(*, "resolved")= logi TRUE
[10:58:38.994]  - attr(*, "total_size")= num NA
[10:58:38.997]  - Getting '...' globals ... DONE
[10:58:38.997] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:38.997] List of 2
[10:58:38.997]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:38.997]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:38.997]  $ ...          : list()
[10:58:38.997]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:38.997]  - attr(*, "where")=List of 2
[10:58:38.997]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:38.997]   ..$ ...          :<environment: 0x5635bf0f75d0> 
[10:58:38.997]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:38.997]  - attr(*, "resolved")= logi FALSE
[10:58:38.997]  - attr(*, "total_size")= num 65967
[10:58:39.000] Packages to be attached in all futures: [n=0] 
[10:58:39.000] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.002] future_lapply() ...
[10:58:39.033] Number of chunks: 2
[10:58:39.033] getGlobalsAndPackagesXApply() ...
[10:58:39.033]  - future.globals: <name-value list> with names ‘list()’
[10:58:39.033]  - use_args: TRUE
[10:58:39.033] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:39.033] List of 2
[10:58:39.033]  $ ...          : list()
[10:58:39.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.033]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:39.033]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:39.033]  - attr(*, "where")=List of 2
[10:58:39.033]   ..$ ...          :<environment: 0x5635bf0f75d0> 
[10:58:39.033]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:39.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.033]  - attr(*, "resolved")= logi FALSE
[10:58:39.033]  - attr(*, "total_size")= num NA
[10:58:39.036] Packages to be attached in all futures: [n=0] 
[10:58:39.036] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.037] Number of futures (= number of chunks): 2
[10:58:39.037] Launching 2 futures (chunks) ...
[10:58:39.037] Chunk #1 of 2 ...
[10:58:39.037]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.037]  - seeds: <none>
[10:58:39.037]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.037] getGlobalsAndPackages() ...
[10:58:39.037] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.037] Resolving globals: FALSE
[10:58:39.037] Tweak future expression to call with '...' arguments ...
[10:58:39.038] {
[10:58:39.038]     do.call(function(...) {
[10:58:39.038]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.038]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.038]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.038]             on.exit(options(oopts), add = TRUE)
[10:58:39.038]         }
[10:58:39.038]         {
[10:58:39.038]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.038]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.038]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.038]             })
[10:58:39.038]         }
[10:58:39.038]     }, args = future.call.arguments)
[10:58:39.038] }
[10:58:39.038] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.038] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.038] 
[10:58:39.038] getGlobalsAndPackages() ... DONE
[10:58:39.039] run() for ‘Future’ ...
[10:58:39.039] - state: ‘created’
[10:58:39.039] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.040] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.040] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.041]   - Field: ‘label’
[10:58:39.041]   - Field: ‘local’
[10:58:39.041]   - Field: ‘owner’
[10:58:39.041]   - Field: ‘envir’
[10:58:39.041]   - Field: ‘workers’
[10:58:39.041]   - Field: ‘packages’
[10:58:39.041]   - Field: ‘gc’
[10:58:39.041]   - Field: ‘job’
[10:58:39.041]   - Field: ‘conditions’
[10:58:39.041]   - Field: ‘expr’
[10:58:39.041]   - Field: ‘uuid’
[10:58:39.042]   - Field: ‘seed’
[10:58:39.042]   - Field: ‘version’
[10:58:39.042]   - Field: ‘result’
[10:58:39.042]   - Field: ‘asynchronous’
[10:58:39.042]   - Field: ‘calls’
[10:58:39.042]   - Field: ‘globals’
[10:58:39.042]   - Field: ‘stdout’
[10:58:39.042]   - Field: ‘earlySignal’
[10:58:39.042]   - Field: ‘lazy’
[10:58:39.042]   - Field: ‘state’
[10:58:39.042] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.042] - Launch lazy future ...
[10:58:39.043] Packages needed by the future expression (n = 0): <none>
[10:58:39.043] Packages needed by future strategies (n = 0): <none>
[10:58:39.043] {
[10:58:39.043]     {
[10:58:39.043]         {
[10:58:39.043]             ...future.startTime <- base::Sys.time()
[10:58:39.043]             {
[10:58:39.043]                 {
[10:58:39.043]                   {
[10:58:39.043]                     {
[10:58:39.043]                       base::local({
[10:58:39.043]                         has_future <- base::requireNamespace("future", 
[10:58:39.043]                           quietly = TRUE)
[10:58:39.043]                         if (has_future) {
[10:58:39.043]                           ns <- base::getNamespace("future")
[10:58:39.043]                           version <- ns[[".package"]][["version"]]
[10:58:39.043]                           if (is.null(version)) 
[10:58:39.043]                             version <- utils::packageVersion("future")
[10:58:39.043]                         }
[10:58:39.043]                         else {
[10:58:39.043]                           version <- NULL
[10:58:39.043]                         }
[10:58:39.043]                         if (!has_future || version < "1.8.0") {
[10:58:39.043]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.043]                             "", base::R.version$version.string), 
[10:58:39.043]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.043]                               "release", "version")], collapse = " "), 
[10:58:39.043]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.043]                             info)
[10:58:39.043]                           info <- base::paste(info, collapse = "; ")
[10:58:39.043]                           if (!has_future) {
[10:58:39.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.043]                               info)
[10:58:39.043]                           }
[10:58:39.043]                           else {
[10:58:39.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.043]                               info, version)
[10:58:39.043]                           }
[10:58:39.043]                           base::stop(msg)
[10:58:39.043]                         }
[10:58:39.043]                       })
[10:58:39.043]                     }
[10:58:39.043]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.043]                     base::options(mc.cores = 1L)
[10:58:39.043]                   }
[10:58:39.043]                   ...future.strategy.old <- future::plan("list")
[10:58:39.043]                   options(future.plan = NULL)
[10:58:39.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.043]                 }
[10:58:39.043]                 ...future.workdir <- getwd()
[10:58:39.043]             }
[10:58:39.043]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.043]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.043]         }
[10:58:39.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.043]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.043]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.043]             base::names(...future.oldOptions))
[10:58:39.043]     }
[10:58:39.043]     if (FALSE) {
[10:58:39.043]     }
[10:58:39.043]     else {
[10:58:39.043]         if (TRUE) {
[10:58:39.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.043]                 open = "w")
[10:58:39.043]         }
[10:58:39.043]         else {
[10:58:39.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.043]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.043]         }
[10:58:39.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.043]             base::sink(type = "output", split = FALSE)
[10:58:39.043]             base::close(...future.stdout)
[10:58:39.043]         }, add = TRUE)
[10:58:39.043]     }
[10:58:39.043]     ...future.frame <- base::sys.nframe()
[10:58:39.043]     ...future.conditions <- base::list()
[10:58:39.043]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.043]     if (FALSE) {
[10:58:39.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.043]     }
[10:58:39.043]     ...future.result <- base::tryCatch({
[10:58:39.043]         base::withCallingHandlers({
[10:58:39.043]             ...future.value <- base::withVisible(base::local({
[10:58:39.043]                 withCallingHandlers({
[10:58:39.043]                   {
[10:58:39.043]                     do.call(function(...) {
[10:58:39.043]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.043]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.043]                         ...future.globals.maxSize)) {
[10:58:39.043]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.043]                         on.exit(options(oopts), add = TRUE)
[10:58:39.043]                       }
[10:58:39.043]                       {
[10:58:39.043]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.043]                           FUN = function(jj) {
[10:58:39.043]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.043]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.043]                           })
[10:58:39.043]                       }
[10:58:39.043]                     }, args = future.call.arguments)
[10:58:39.043]                   }
[10:58:39.043]                 }, immediateCondition = function(cond) {
[10:58:39.043]                   save_rds <- function (object, pathname, ...) 
[10:58:39.043]                   {
[10:58:39.043]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.043]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.043]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.043]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.043]                         fi_tmp[["mtime"]])
[10:58:39.043]                     }
[10:58:39.043]                     tryCatch({
[10:58:39.043]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.043]                     }, error = function(ex) {
[10:58:39.043]                       msg <- conditionMessage(ex)
[10:58:39.043]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.043]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.043]                         fi_tmp[["mtime"]], msg)
[10:58:39.043]                       ex$message <- msg
[10:58:39.043]                       stop(ex)
[10:58:39.043]                     })
[10:58:39.043]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.043]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.043]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.043]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.043]                       fi <- file.info(pathname)
[10:58:39.043]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.043]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.043]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.043]                         fi[["size"]], fi[["mtime"]])
[10:58:39.043]                       stop(msg)
[10:58:39.043]                     }
[10:58:39.043]                     invisible(pathname)
[10:58:39.043]                   }
[10:58:39.043]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.043]                     rootPath = tempdir()) 
[10:58:39.043]                   {
[10:58:39.043]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.043]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.043]                       tmpdir = path, fileext = ".rds")
[10:58:39.043]                     save_rds(obj, file)
[10:58:39.043]                   }
[10:58:39.043]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.043]                   {
[10:58:39.043]                     inherits <- base::inherits
[10:58:39.043]                     invokeRestart <- base::invokeRestart
[10:58:39.043]                     is.null <- base::is.null
[10:58:39.043]                     muffled <- FALSE
[10:58:39.043]                     if (inherits(cond, "message")) {
[10:58:39.043]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.043]                       if (muffled) 
[10:58:39.043]                         invokeRestart("muffleMessage")
[10:58:39.043]                     }
[10:58:39.043]                     else if (inherits(cond, "warning")) {
[10:58:39.043]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.043]                       if (muffled) 
[10:58:39.043]                         invokeRestart("muffleWarning")
[10:58:39.043]                     }
[10:58:39.043]                     else if (inherits(cond, "condition")) {
[10:58:39.043]                       if (!is.null(pattern)) {
[10:58:39.043]                         computeRestarts <- base::computeRestarts
[10:58:39.043]                         grepl <- base::grepl
[10:58:39.043]                         restarts <- computeRestarts(cond)
[10:58:39.043]                         for (restart in restarts) {
[10:58:39.043]                           name <- restart$name
[10:58:39.043]                           if (is.null(name)) 
[10:58:39.043]                             next
[10:58:39.043]                           if (!grepl(pattern, name)) 
[10:58:39.043]                             next
[10:58:39.043]                           invokeRestart(restart)
[10:58:39.043]                           muffled <- TRUE
[10:58:39.043]                           break
[10:58:39.043]                         }
[10:58:39.043]                       }
[10:58:39.043]                     }
[10:58:39.043]                     invisible(muffled)
[10:58:39.043]                   }
[10:58:39.043]                   muffleCondition(cond)
[10:58:39.043]                 })
[10:58:39.043]             }))
[10:58:39.043]             future::FutureResult(value = ...future.value$value, 
[10:58:39.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.043]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.043]                     ...future.globalenv.names))
[10:58:39.043]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.043]         }, condition = base::local({
[10:58:39.043]             c <- base::c
[10:58:39.043]             inherits <- base::inherits
[10:58:39.043]             invokeRestart <- base::invokeRestart
[10:58:39.043]             length <- base::length
[10:58:39.043]             list <- base::list
[10:58:39.043]             seq.int <- base::seq.int
[10:58:39.043]             signalCondition <- base::signalCondition
[10:58:39.043]             sys.calls <- base::sys.calls
[10:58:39.043]             `[[` <- base::`[[`
[10:58:39.043]             `+` <- base::`+`
[10:58:39.043]             `<<-` <- base::`<<-`
[10:58:39.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.043]                   3L)]
[10:58:39.043]             }
[10:58:39.043]             function(cond) {
[10:58:39.043]                 is_error <- inherits(cond, "error")
[10:58:39.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.043]                   NULL)
[10:58:39.043]                 if (is_error) {
[10:58:39.043]                   sessionInformation <- function() {
[10:58:39.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.043]                       search = base::search(), system = base::Sys.info())
[10:58:39.043]                   }
[10:58:39.043]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.043]                     cond$call), session = sessionInformation(), 
[10:58:39.043]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.043]                   signalCondition(cond)
[10:58:39.043]                 }
[10:58:39.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.043]                 "immediateCondition"))) {
[10:58:39.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.043]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.043]                   if (TRUE && !signal) {
[10:58:39.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.043]                     {
[10:58:39.043]                       inherits <- base::inherits
[10:58:39.043]                       invokeRestart <- base::invokeRestart
[10:58:39.043]                       is.null <- base::is.null
[10:58:39.043]                       muffled <- FALSE
[10:58:39.043]                       if (inherits(cond, "message")) {
[10:58:39.043]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.043]                         if (muffled) 
[10:58:39.043]                           invokeRestart("muffleMessage")
[10:58:39.043]                       }
[10:58:39.043]                       else if (inherits(cond, "warning")) {
[10:58:39.043]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.043]                         if (muffled) 
[10:58:39.043]                           invokeRestart("muffleWarning")
[10:58:39.043]                       }
[10:58:39.043]                       else if (inherits(cond, "condition")) {
[10:58:39.043]                         if (!is.null(pattern)) {
[10:58:39.043]                           computeRestarts <- base::computeRestarts
[10:58:39.043]                           grepl <- base::grepl
[10:58:39.043]                           restarts <- computeRestarts(cond)
[10:58:39.043]                           for (restart in restarts) {
[10:58:39.043]                             name <- restart$name
[10:58:39.043]                             if (is.null(name)) 
[10:58:39.043]                               next
[10:58:39.043]                             if (!grepl(pattern, name)) 
[10:58:39.043]                               next
[10:58:39.043]                             invokeRestart(restart)
[10:58:39.043]                             muffled <- TRUE
[10:58:39.043]                             break
[10:58:39.043]                           }
[10:58:39.043]                         }
[10:58:39.043]                       }
[10:58:39.043]                       invisible(muffled)
[10:58:39.043]                     }
[10:58:39.043]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.043]                   }
[10:58:39.043]                 }
[10:58:39.043]                 else {
[10:58:39.043]                   if (TRUE) {
[10:58:39.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.043]                     {
[10:58:39.043]                       inherits <- base::inherits
[10:58:39.043]                       invokeRestart <- base::invokeRestart
[10:58:39.043]                       is.null <- base::is.null
[10:58:39.043]                       muffled <- FALSE
[10:58:39.043]                       if (inherits(cond, "message")) {
[10:58:39.043]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.043]                         if (muffled) 
[10:58:39.043]                           invokeRestart("muffleMessage")
[10:58:39.043]                       }
[10:58:39.043]                       else if (inherits(cond, "warning")) {
[10:58:39.043]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.043]                         if (muffled) 
[10:58:39.043]                           invokeRestart("muffleWarning")
[10:58:39.043]                       }
[10:58:39.043]                       else if (inherits(cond, "condition")) {
[10:58:39.043]                         if (!is.null(pattern)) {
[10:58:39.043]                           computeRestarts <- base::computeRestarts
[10:58:39.043]                           grepl <- base::grepl
[10:58:39.043]                           restarts <- computeRestarts(cond)
[10:58:39.043]                           for (restart in restarts) {
[10:58:39.043]                             name <- restart$name
[10:58:39.043]                             if (is.null(name)) 
[10:58:39.043]                               next
[10:58:39.043]                             if (!grepl(pattern, name)) 
[10:58:39.043]                               next
[10:58:39.043]                             invokeRestart(restart)
[10:58:39.043]                             muffled <- TRUE
[10:58:39.043]                             break
[10:58:39.043]                           }
[10:58:39.043]                         }
[10:58:39.043]                       }
[10:58:39.043]                       invisible(muffled)
[10:58:39.043]                     }
[10:58:39.043]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.043]                   }
[10:58:39.043]                 }
[10:58:39.043]             }
[10:58:39.043]         }))
[10:58:39.043]     }, error = function(ex) {
[10:58:39.043]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.043]                 ...future.rng), started = ...future.startTime, 
[10:58:39.043]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.043]             version = "1.8"), class = "FutureResult")
[10:58:39.043]     }, finally = {
[10:58:39.043]         if (!identical(...future.workdir, getwd())) 
[10:58:39.043]             setwd(...future.workdir)
[10:58:39.043]         {
[10:58:39.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.043]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.043]             }
[10:58:39.043]             base::options(...future.oldOptions)
[10:58:39.043]             if (.Platform$OS.type == "windows") {
[10:58:39.043]                 old_names <- names(...future.oldEnvVars)
[10:58:39.043]                 envs <- base::Sys.getenv()
[10:58:39.043]                 names <- names(envs)
[10:58:39.043]                 common <- intersect(names, old_names)
[10:58:39.043]                 added <- setdiff(names, old_names)
[10:58:39.043]                 removed <- setdiff(old_names, names)
[10:58:39.043]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.043]                   envs[common]]
[10:58:39.043]                 NAMES <- toupper(changed)
[10:58:39.043]                 args <- list()
[10:58:39.043]                 for (kk in seq_along(NAMES)) {
[10:58:39.043]                   name <- changed[[kk]]
[10:58:39.043]                   NAME <- NAMES[[kk]]
[10:58:39.043]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.043]                     next
[10:58:39.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.043]                 }
[10:58:39.043]                 NAMES <- toupper(added)
[10:58:39.043]                 for (kk in seq_along(NAMES)) {
[10:58:39.043]                   name <- added[[kk]]
[10:58:39.043]                   NAME <- NAMES[[kk]]
[10:58:39.043]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.043]                     next
[10:58:39.043]                   args[[name]] <- ""
[10:58:39.043]                 }
[10:58:39.043]                 NAMES <- toupper(removed)
[10:58:39.043]                 for (kk in seq_along(NAMES)) {
[10:58:39.043]                   name <- removed[[kk]]
[10:58:39.043]                   NAME <- NAMES[[kk]]
[10:58:39.043]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.043]                     next
[10:58:39.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.043]                 }
[10:58:39.043]                 if (length(args) > 0) 
[10:58:39.043]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.043]             }
[10:58:39.043]             else {
[10:58:39.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.043]             }
[10:58:39.043]             {
[10:58:39.043]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.043]                   0L) {
[10:58:39.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.043]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.043]                   base::options(opts)
[10:58:39.043]                 }
[10:58:39.043]                 {
[10:58:39.043]                   {
[10:58:39.043]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.043]                     NULL
[10:58:39.043]                   }
[10:58:39.043]                   options(future.plan = NULL)
[10:58:39.043]                   if (is.na(NA_character_)) 
[10:58:39.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.043]                     .init = FALSE)
[10:58:39.043]                 }
[10:58:39.043]             }
[10:58:39.043]         }
[10:58:39.043]     })
[10:58:39.043]     if (TRUE) {
[10:58:39.043]         base::sink(type = "output", split = FALSE)
[10:58:39.043]         if (TRUE) {
[10:58:39.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.043]         }
[10:58:39.043]         else {
[10:58:39.043]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.043]         }
[10:58:39.043]         base::close(...future.stdout)
[10:58:39.043]         ...future.stdout <- NULL
[10:58:39.043]     }
[10:58:39.043]     ...future.result$conditions <- ...future.conditions
[10:58:39.043]     ...future.result$finished <- base::Sys.time()
[10:58:39.043]     ...future.result
[10:58:39.043] }
[10:58:39.045] assign_globals() ...
[10:58:39.045] List of 5
[10:58:39.045]  $ future.call.arguments    : list()
[10:58:39.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.045]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:39.045]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:39.045]  $ ...future.elements_ii    :List of 1
[10:58:39.045]   ..$ : num [1:4] 1 3 1 7
[10:58:39.045]  $ ...future.seeds_ii       : NULL
[10:58:39.045]  $ ...future.globals.maxSize: num Inf
[10:58:39.045]  - attr(*, "resolved")= logi FALSE
[10:58:39.045]  - attr(*, "total_size")= num NA
[10:58:39.045]  - attr(*, "where")=List of 5
[10:58:39.045]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.045]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.045]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.045]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.045]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.045]  - attr(*, "already-done")= logi TRUE
[10:58:39.050] - copied ‘future.call.arguments’ to environment
[10:58:39.050] - copied ‘...future.FUN’ to environment
[10:58:39.050] - copied ‘...future.elements_ii’ to environment
[10:58:39.050] - copied ‘...future.seeds_ii’ to environment
[10:58:39.050] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.050] assign_globals() ... done
[10:58:39.050] requestCore(): workers = 2
[10:58:39.052] MulticoreFuture started
[10:58:39.053] - Launch lazy future ... done
[10:58:39.053] run() for ‘MulticoreFuture’ ... done
[10:58:39.053] Created future:
[10:58:39.054] plan(): Setting new future strategy stack:
[10:58:39.054] List of future strategies:
[10:58:39.054] 1. sequential:
[10:58:39.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.054]    - tweaked: FALSE
[10:58:39.054]    - call: NULL
[10:58:39.055] plan(): nbrOfWorkers() = 1
[10:58:39.060] plan(): Setting new future strategy stack:
[10:58:39.060] List of future strategies:
[10:58:39.060] 1. multicore:
[10:58:39.060]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.060]    - tweaked: FALSE
[10:58:39.060]    - call: plan(strategy)
[10:58:39.065] plan(): nbrOfWorkers() = 2
[10:58:39.053] MulticoreFuture:
[10:58:39.053] Label: ‘future_apply-1’
[10:58:39.053] Expression:
[10:58:39.053] {
[10:58:39.053]     do.call(function(...) {
[10:58:39.053]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.053]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.053]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.053]             on.exit(options(oopts), add = TRUE)
[10:58:39.053]         }
[10:58:39.053]         {
[10:58:39.053]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.053]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.053]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.053]             })
[10:58:39.053]         }
[10:58:39.053]     }, args = future.call.arguments)
[10:58:39.053] }
[10:58:39.053] Lazy evaluation: FALSE
[10:58:39.053] Asynchronous evaluation: TRUE
[10:58:39.053] Local evaluation: TRUE
[10:58:39.053] Environment: R_GlobalEnv
[10:58:39.053] Capture standard output: TRUE
[10:58:39.053] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.053] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.053] Packages: <none>
[10:58:39.053] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.053] Resolved: FALSE
[10:58:39.053] Value: <not collected>
[10:58:39.053] Conditions captured: <none>
[10:58:39.053] Early signaling: FALSE
[10:58:39.053] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.053] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.066] Chunk #1 of 2 ... DONE
[10:58:39.068] Chunk #2 of 2 ...
[10:58:39.069]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.069]  - seeds: <none>
[10:58:39.069]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.070] getGlobalsAndPackages() ...
[10:58:39.070] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.070] Resolving globals: FALSE
[10:58:39.071] Tweak future expression to call with '...' arguments ...
[10:58:39.071] {
[10:58:39.071]     do.call(function(...) {
[10:58:39.071]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.071]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.071]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.071]             on.exit(options(oopts), add = TRUE)
[10:58:39.071]         }
[10:58:39.071]         {
[10:58:39.071]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.071]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.071]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.071]             })
[10:58:39.071]         }
[10:58:39.071]     }, args = future.call.arguments)
[10:58:39.071] }
[10:58:39.071] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.072] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.073] 
[10:58:39.073] getGlobalsAndPackages() ... DONE
[10:58:39.073] run() for ‘Future’ ...
[10:58:39.073] - state: ‘created’
[10:58:39.074] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.076] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.077]   - Field: ‘label’
[10:58:39.077]   - Field: ‘local’
[10:58:39.077]   - Field: ‘owner’
[10:58:39.077]   - Field: ‘envir’
[10:58:39.077]   - Field: ‘workers’
[10:58:39.077]   - Field: ‘packages’
[10:58:39.078]   - Field: ‘gc’
[10:58:39.078]   - Field: ‘job’
[10:58:39.078]   - Field: ‘conditions’
[10:58:39.078]   - Field: ‘expr’
[10:58:39.078]   - Field: ‘uuid’
[10:58:39.078]   - Field: ‘seed’
[10:58:39.078]   - Field: ‘version’
[10:58:39.079]   - Field: ‘result’
[10:58:39.079]   - Field: ‘asynchronous’
[10:58:39.079]   - Field: ‘calls’
[10:58:39.079]   - Field: ‘globals’
[10:58:39.079]   - Field: ‘stdout’
[10:58:39.079]   - Field: ‘earlySignal’
[10:58:39.079]   - Field: ‘lazy’
[10:58:39.079]   - Field: ‘state’
[10:58:39.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.080] - Launch lazy future ...
[10:58:39.080] Packages needed by the future expression (n = 0): <none>
[10:58:39.080] Packages needed by future strategies (n = 0): <none>
[10:58:39.081] {
[10:58:39.081]     {
[10:58:39.081]         {
[10:58:39.081]             ...future.startTime <- base::Sys.time()
[10:58:39.081]             {
[10:58:39.081]                 {
[10:58:39.081]                   {
[10:58:39.081]                     {
[10:58:39.081]                       base::local({
[10:58:39.081]                         has_future <- base::requireNamespace("future", 
[10:58:39.081]                           quietly = TRUE)
[10:58:39.081]                         if (has_future) {
[10:58:39.081]                           ns <- base::getNamespace("future")
[10:58:39.081]                           version <- ns[[".package"]][["version"]]
[10:58:39.081]                           if (is.null(version)) 
[10:58:39.081]                             version <- utils::packageVersion("future")
[10:58:39.081]                         }
[10:58:39.081]                         else {
[10:58:39.081]                           version <- NULL
[10:58:39.081]                         }
[10:58:39.081]                         if (!has_future || version < "1.8.0") {
[10:58:39.081]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.081]                             "", base::R.version$version.string), 
[10:58:39.081]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.081]                               "release", "version")], collapse = " "), 
[10:58:39.081]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.081]                             info)
[10:58:39.081]                           info <- base::paste(info, collapse = "; ")
[10:58:39.081]                           if (!has_future) {
[10:58:39.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.081]                               info)
[10:58:39.081]                           }
[10:58:39.081]                           else {
[10:58:39.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.081]                               info, version)
[10:58:39.081]                           }
[10:58:39.081]                           base::stop(msg)
[10:58:39.081]                         }
[10:58:39.081]                       })
[10:58:39.081]                     }
[10:58:39.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.081]                     base::options(mc.cores = 1L)
[10:58:39.081]                   }
[10:58:39.081]                   ...future.strategy.old <- future::plan("list")
[10:58:39.081]                   options(future.plan = NULL)
[10:58:39.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.081]                 }
[10:58:39.081]                 ...future.workdir <- getwd()
[10:58:39.081]             }
[10:58:39.081]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.081]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.081]         }
[10:58:39.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.081]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.081]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.081]             base::names(...future.oldOptions))
[10:58:39.081]     }
[10:58:39.081]     if (FALSE) {
[10:58:39.081]     }
[10:58:39.081]     else {
[10:58:39.081]         if (TRUE) {
[10:58:39.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.081]                 open = "w")
[10:58:39.081]         }
[10:58:39.081]         else {
[10:58:39.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.081]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.081]         }
[10:58:39.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.081]             base::sink(type = "output", split = FALSE)
[10:58:39.081]             base::close(...future.stdout)
[10:58:39.081]         }, add = TRUE)
[10:58:39.081]     }
[10:58:39.081]     ...future.frame <- base::sys.nframe()
[10:58:39.081]     ...future.conditions <- base::list()
[10:58:39.081]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.081]     if (FALSE) {
[10:58:39.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.081]     }
[10:58:39.081]     ...future.result <- base::tryCatch({
[10:58:39.081]         base::withCallingHandlers({
[10:58:39.081]             ...future.value <- base::withVisible(base::local({
[10:58:39.081]                 withCallingHandlers({
[10:58:39.081]                   {
[10:58:39.081]                     do.call(function(...) {
[10:58:39.081]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.081]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.081]                         ...future.globals.maxSize)) {
[10:58:39.081]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.081]                         on.exit(options(oopts), add = TRUE)
[10:58:39.081]                       }
[10:58:39.081]                       {
[10:58:39.081]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.081]                           FUN = function(jj) {
[10:58:39.081]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.081]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.081]                           })
[10:58:39.081]                       }
[10:58:39.081]                     }, args = future.call.arguments)
[10:58:39.081]                   }
[10:58:39.081]                 }, immediateCondition = function(cond) {
[10:58:39.081]                   save_rds <- function (object, pathname, ...) 
[10:58:39.081]                   {
[10:58:39.081]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.081]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.081]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.081]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.081]                         fi_tmp[["mtime"]])
[10:58:39.081]                     }
[10:58:39.081]                     tryCatch({
[10:58:39.081]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.081]                     }, error = function(ex) {
[10:58:39.081]                       msg <- conditionMessage(ex)
[10:58:39.081]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.081]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.081]                         fi_tmp[["mtime"]], msg)
[10:58:39.081]                       ex$message <- msg
[10:58:39.081]                       stop(ex)
[10:58:39.081]                     })
[10:58:39.081]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.081]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.081]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.081]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.081]                       fi <- file.info(pathname)
[10:58:39.081]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.081]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.081]                         fi[["size"]], fi[["mtime"]])
[10:58:39.081]                       stop(msg)
[10:58:39.081]                     }
[10:58:39.081]                     invisible(pathname)
[10:58:39.081]                   }
[10:58:39.081]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.081]                     rootPath = tempdir()) 
[10:58:39.081]                   {
[10:58:39.081]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.081]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.081]                       tmpdir = path, fileext = ".rds")
[10:58:39.081]                     save_rds(obj, file)
[10:58:39.081]                   }
[10:58:39.081]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.081]                   {
[10:58:39.081]                     inherits <- base::inherits
[10:58:39.081]                     invokeRestart <- base::invokeRestart
[10:58:39.081]                     is.null <- base::is.null
[10:58:39.081]                     muffled <- FALSE
[10:58:39.081]                     if (inherits(cond, "message")) {
[10:58:39.081]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.081]                       if (muffled) 
[10:58:39.081]                         invokeRestart("muffleMessage")
[10:58:39.081]                     }
[10:58:39.081]                     else if (inherits(cond, "warning")) {
[10:58:39.081]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.081]                       if (muffled) 
[10:58:39.081]                         invokeRestart("muffleWarning")
[10:58:39.081]                     }
[10:58:39.081]                     else if (inherits(cond, "condition")) {
[10:58:39.081]                       if (!is.null(pattern)) {
[10:58:39.081]                         computeRestarts <- base::computeRestarts
[10:58:39.081]                         grepl <- base::grepl
[10:58:39.081]                         restarts <- computeRestarts(cond)
[10:58:39.081]                         for (restart in restarts) {
[10:58:39.081]                           name <- restart$name
[10:58:39.081]                           if (is.null(name)) 
[10:58:39.081]                             next
[10:58:39.081]                           if (!grepl(pattern, name)) 
[10:58:39.081]                             next
[10:58:39.081]                           invokeRestart(restart)
[10:58:39.081]                           muffled <- TRUE
[10:58:39.081]                           break
[10:58:39.081]                         }
[10:58:39.081]                       }
[10:58:39.081]                     }
[10:58:39.081]                     invisible(muffled)
[10:58:39.081]                   }
[10:58:39.081]                   muffleCondition(cond)
[10:58:39.081]                 })
[10:58:39.081]             }))
[10:58:39.081]             future::FutureResult(value = ...future.value$value, 
[10:58:39.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.081]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.081]                     ...future.globalenv.names))
[10:58:39.081]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.081]         }, condition = base::local({
[10:58:39.081]             c <- base::c
[10:58:39.081]             inherits <- base::inherits
[10:58:39.081]             invokeRestart <- base::invokeRestart
[10:58:39.081]             length <- base::length
[10:58:39.081]             list <- base::list
[10:58:39.081]             seq.int <- base::seq.int
[10:58:39.081]             signalCondition <- base::signalCondition
[10:58:39.081]             sys.calls <- base::sys.calls
[10:58:39.081]             `[[` <- base::`[[`
[10:58:39.081]             `+` <- base::`+`
[10:58:39.081]             `<<-` <- base::`<<-`
[10:58:39.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.081]                   3L)]
[10:58:39.081]             }
[10:58:39.081]             function(cond) {
[10:58:39.081]                 is_error <- inherits(cond, "error")
[10:58:39.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.081]                   NULL)
[10:58:39.081]                 if (is_error) {
[10:58:39.081]                   sessionInformation <- function() {
[10:58:39.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.081]                       search = base::search(), system = base::Sys.info())
[10:58:39.081]                   }
[10:58:39.081]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.081]                     cond$call), session = sessionInformation(), 
[10:58:39.081]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.081]                   signalCondition(cond)
[10:58:39.081]                 }
[10:58:39.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.081]                 "immediateCondition"))) {
[10:58:39.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.081]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.081]                   if (TRUE && !signal) {
[10:58:39.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.081]                     {
[10:58:39.081]                       inherits <- base::inherits
[10:58:39.081]                       invokeRestart <- base::invokeRestart
[10:58:39.081]                       is.null <- base::is.null
[10:58:39.081]                       muffled <- FALSE
[10:58:39.081]                       if (inherits(cond, "message")) {
[10:58:39.081]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.081]                         if (muffled) 
[10:58:39.081]                           invokeRestart("muffleMessage")
[10:58:39.081]                       }
[10:58:39.081]                       else if (inherits(cond, "warning")) {
[10:58:39.081]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.081]                         if (muffled) 
[10:58:39.081]                           invokeRestart("muffleWarning")
[10:58:39.081]                       }
[10:58:39.081]                       else if (inherits(cond, "condition")) {
[10:58:39.081]                         if (!is.null(pattern)) {
[10:58:39.081]                           computeRestarts <- base::computeRestarts
[10:58:39.081]                           grepl <- base::grepl
[10:58:39.081]                           restarts <- computeRestarts(cond)
[10:58:39.081]                           for (restart in restarts) {
[10:58:39.081]                             name <- restart$name
[10:58:39.081]                             if (is.null(name)) 
[10:58:39.081]                               next
[10:58:39.081]                             if (!grepl(pattern, name)) 
[10:58:39.081]                               next
[10:58:39.081]                             invokeRestart(restart)
[10:58:39.081]                             muffled <- TRUE
[10:58:39.081]                             break
[10:58:39.081]                           }
[10:58:39.081]                         }
[10:58:39.081]                       }
[10:58:39.081]                       invisible(muffled)
[10:58:39.081]                     }
[10:58:39.081]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.081]                   }
[10:58:39.081]                 }
[10:58:39.081]                 else {
[10:58:39.081]                   if (TRUE) {
[10:58:39.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.081]                     {
[10:58:39.081]                       inherits <- base::inherits
[10:58:39.081]                       invokeRestart <- base::invokeRestart
[10:58:39.081]                       is.null <- base::is.null
[10:58:39.081]                       muffled <- FALSE
[10:58:39.081]                       if (inherits(cond, "message")) {
[10:58:39.081]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.081]                         if (muffled) 
[10:58:39.081]                           invokeRestart("muffleMessage")
[10:58:39.081]                       }
[10:58:39.081]                       else if (inherits(cond, "warning")) {
[10:58:39.081]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.081]                         if (muffled) 
[10:58:39.081]                           invokeRestart("muffleWarning")
[10:58:39.081]                       }
[10:58:39.081]                       else if (inherits(cond, "condition")) {
[10:58:39.081]                         if (!is.null(pattern)) {
[10:58:39.081]                           computeRestarts <- base::computeRestarts
[10:58:39.081]                           grepl <- base::grepl
[10:58:39.081]                           restarts <- computeRestarts(cond)
[10:58:39.081]                           for (restart in restarts) {
[10:58:39.081]                             name <- restart$name
[10:58:39.081]                             if (is.null(name)) 
[10:58:39.081]                               next
[10:58:39.081]                             if (!grepl(pattern, name)) 
[10:58:39.081]                               next
[10:58:39.081]                             invokeRestart(restart)
[10:58:39.081]                             muffled <- TRUE
[10:58:39.081]                             break
[10:58:39.081]                           }
[10:58:39.081]                         }
[10:58:39.081]                       }
[10:58:39.081]                       invisible(muffled)
[10:58:39.081]                     }
[10:58:39.081]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.081]                   }
[10:58:39.081]                 }
[10:58:39.081]             }
[10:58:39.081]         }))
[10:58:39.081]     }, error = function(ex) {
[10:58:39.081]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.081]                 ...future.rng), started = ...future.startTime, 
[10:58:39.081]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.081]             version = "1.8"), class = "FutureResult")
[10:58:39.081]     }, finally = {
[10:58:39.081]         if (!identical(...future.workdir, getwd())) 
[10:58:39.081]             setwd(...future.workdir)
[10:58:39.081]         {
[10:58:39.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.081]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.081]             }
[10:58:39.081]             base::options(...future.oldOptions)
[10:58:39.081]             if (.Platform$OS.type == "windows") {
[10:58:39.081]                 old_names <- names(...future.oldEnvVars)
[10:58:39.081]                 envs <- base::Sys.getenv()
[10:58:39.081]                 names <- names(envs)
[10:58:39.081]                 common <- intersect(names, old_names)
[10:58:39.081]                 added <- setdiff(names, old_names)
[10:58:39.081]                 removed <- setdiff(old_names, names)
[10:58:39.081]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.081]                   envs[common]]
[10:58:39.081]                 NAMES <- toupper(changed)
[10:58:39.081]                 args <- list()
[10:58:39.081]                 for (kk in seq_along(NAMES)) {
[10:58:39.081]                   name <- changed[[kk]]
[10:58:39.081]                   NAME <- NAMES[[kk]]
[10:58:39.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.081]                     next
[10:58:39.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.081]                 }
[10:58:39.081]                 NAMES <- toupper(added)
[10:58:39.081]                 for (kk in seq_along(NAMES)) {
[10:58:39.081]                   name <- added[[kk]]
[10:58:39.081]                   NAME <- NAMES[[kk]]
[10:58:39.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.081]                     next
[10:58:39.081]                   args[[name]] <- ""
[10:58:39.081]                 }
[10:58:39.081]                 NAMES <- toupper(removed)
[10:58:39.081]                 for (kk in seq_along(NAMES)) {
[10:58:39.081]                   name <- removed[[kk]]
[10:58:39.081]                   NAME <- NAMES[[kk]]
[10:58:39.081]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.081]                     next
[10:58:39.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.081]                 }
[10:58:39.081]                 if (length(args) > 0) 
[10:58:39.081]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.081]             }
[10:58:39.081]             else {
[10:58:39.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.081]             }
[10:58:39.081]             {
[10:58:39.081]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.081]                   0L) {
[10:58:39.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.081]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.081]                   base::options(opts)
[10:58:39.081]                 }
[10:58:39.081]                 {
[10:58:39.081]                   {
[10:58:39.081]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.081]                     NULL
[10:58:39.081]                   }
[10:58:39.081]                   options(future.plan = NULL)
[10:58:39.081]                   if (is.na(NA_character_)) 
[10:58:39.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.081]                     .init = FALSE)
[10:58:39.081]                 }
[10:58:39.081]             }
[10:58:39.081]         }
[10:58:39.081]     })
[10:58:39.081]     if (TRUE) {
[10:58:39.081]         base::sink(type = "output", split = FALSE)
[10:58:39.081]         if (TRUE) {
[10:58:39.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.081]         }
[10:58:39.081]         else {
[10:58:39.081]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.081]         }
[10:58:39.081]         base::close(...future.stdout)
[10:58:39.081]         ...future.stdout <- NULL
[10:58:39.081]     }
[10:58:39.081]     ...future.result$conditions <- ...future.conditions
[10:58:39.081]     ...future.result$finished <- base::Sys.time()
[10:58:39.081]     ...future.result
[10:58:39.081] }
[10:58:39.084] assign_globals() ...
[10:58:39.084] List of 5
[10:58:39.084]  $ future.call.arguments    : list()
[10:58:39.084]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.084]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:39.084]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:39.084]  $ ...future.elements_ii    :List of 1
[10:58:39.084]   ..$ : num [1:4] 2 4 6 8
[10:58:39.084]  $ ...future.seeds_ii       : NULL
[10:58:39.084]  $ ...future.globals.maxSize: num Inf
[10:58:39.084]  - attr(*, "resolved")= logi FALSE
[10:58:39.084]  - attr(*, "total_size")= num NA
[10:58:39.084]  - attr(*, "where")=List of 5
[10:58:39.084]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.084]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.084]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.084]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.084]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.084]  - attr(*, "already-done")= logi TRUE
[10:58:39.090] - copied ‘future.call.arguments’ to environment
[10:58:39.090] - copied ‘...future.FUN’ to environment
[10:58:39.090] - copied ‘...future.elements_ii’ to environment
[10:58:39.091] - copied ‘...future.seeds_ii’ to environment
[10:58:39.091] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.091] assign_globals() ... done
[10:58:39.091] requestCore(): workers = 2
[10:58:39.093] MulticoreFuture started
[10:58:39.094] - Launch lazy future ... done
[10:58:39.094] run() for ‘MulticoreFuture’ ... done
[10:58:39.094] Created future:
[10:58:39.094] plan(): Setting new future strategy stack:
[10:58:39.095] List of future strategies:
[10:58:39.095] 1. sequential:
[10:58:39.095]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.095]    - tweaked: FALSE
[10:58:39.095]    - call: NULL
[10:58:39.096] plan(): nbrOfWorkers() = 1
[10:58:39.098] plan(): Setting new future strategy stack:
[10:58:39.098] List of future strategies:
[10:58:39.098] 1. multicore:
[10:58:39.098]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.098]    - tweaked: FALSE
[10:58:39.098]    - call: plan(strategy)
[10:58:39.101] plan(): nbrOfWorkers() = 2
[10:58:39.094] MulticoreFuture:
[10:58:39.094] Label: ‘future_apply-2’
[10:58:39.094] Expression:
[10:58:39.094] {
[10:58:39.094]     do.call(function(...) {
[10:58:39.094]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.094]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.094]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.094]             on.exit(options(oopts), add = TRUE)
[10:58:39.094]         }
[10:58:39.094]         {
[10:58:39.094]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.094]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.094]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.094]             })
[10:58:39.094]         }
[10:58:39.094]     }, args = future.call.arguments)
[10:58:39.094] }
[10:58:39.094] Lazy evaluation: FALSE
[10:58:39.094] Asynchronous evaluation: TRUE
[10:58:39.094] Local evaluation: TRUE
[10:58:39.094] Environment: R_GlobalEnv
[10:58:39.094] Capture standard output: TRUE
[10:58:39.094] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.094] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.094] Packages: <none>
[10:58:39.094] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.094] Resolved: TRUE
[10:58:39.094] Value: <not collected>
[10:58:39.094] Conditions captured: <none>
[10:58:39.094] Early signaling: FALSE
[10:58:39.094] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.094] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.102] Chunk #2 of 2 ... DONE
[10:58:39.102] Launching 2 futures (chunks) ... DONE
[10:58:39.102] Resolving 2 futures (chunks) ...
[10:58:39.102] resolve() on list ...
[10:58:39.103]  recursive: 0
[10:58:39.103]  length: 2
[10:58:39.103] 
[10:58:39.103] Future #1
[10:58:39.103] result() for MulticoreFuture ...
[10:58:39.104] result() for MulticoreFuture ...
[10:58:39.104] result() for MulticoreFuture ... done
[10:58:39.105] result() for MulticoreFuture ... done
[10:58:39.105] result() for MulticoreFuture ...
[10:58:39.105] result() for MulticoreFuture ... done
[10:58:39.105] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:39.105] - nx: 2
[10:58:39.105] - relay: TRUE
[10:58:39.105] - stdout: TRUE
[10:58:39.105] - signal: TRUE
[10:58:39.106] - resignal: FALSE
[10:58:39.106] - force: TRUE
[10:58:39.106] - relayed: [n=2] FALSE, FALSE
[10:58:39.106] - queued futures: [n=2] FALSE, FALSE
[10:58:39.106]  - until=1
[10:58:39.106]  - relaying element #1
[10:58:39.106] result() for MulticoreFuture ...
[10:58:39.106] result() for MulticoreFuture ... done
[10:58:39.107] result() for MulticoreFuture ...
[10:58:39.107] result() for MulticoreFuture ... done
[10:58:39.107] result() for MulticoreFuture ...
[10:58:39.107] result() for MulticoreFuture ... done
[10:58:39.107] result() for MulticoreFuture ...
[10:58:39.107] result() for MulticoreFuture ... done
[10:58:39.107] - relayed: [n=2] TRUE, FALSE
[10:58:39.108] - queued futures: [n=2] TRUE, FALSE
[10:58:39.108] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:39.108]  length: 1 (resolved future 1)
[10:58:39.108] Future #2
[10:58:39.108] result() for MulticoreFuture ...
[10:58:39.109] result() for MulticoreFuture ...
[10:58:39.109] result() for MulticoreFuture ... done
[10:58:39.109] result() for MulticoreFuture ... done
[10:58:39.109] result() for MulticoreFuture ...
[10:58:39.110] result() for MulticoreFuture ... done
[10:58:39.110] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:39.110] - nx: 2
[10:58:39.110] - relay: TRUE
[10:58:39.110] - stdout: TRUE
[10:58:39.110] - signal: TRUE
[10:58:39.110] - resignal: FALSE
[10:58:39.110] - force: TRUE
[10:58:39.111] - relayed: [n=2] TRUE, FALSE
[10:58:39.111] - queued futures: [n=2] TRUE, FALSE
[10:58:39.111]  - until=2
[10:58:39.111]  - relaying element #2
[10:58:39.113] result() for MulticoreFuture ...
[10:58:39.113] result() for MulticoreFuture ... done
[10:58:39.113] result() for MulticoreFuture ...
[10:58:39.113] result() for MulticoreFuture ... done
[10:58:39.114] result() for MulticoreFuture ...
[10:58:39.114] result() for MulticoreFuture ... done
[10:58:39.114] result() for MulticoreFuture ...
[10:58:39.114] result() for MulticoreFuture ... done
[10:58:39.115] - relayed: [n=2] TRUE, TRUE
[10:58:39.115] - queued futures: [n=2] TRUE, TRUE
[10:58:39.115] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:39.115]  length: 0 (resolved future 2)
[10:58:39.115] Relaying remaining futures
[10:58:39.115] signalConditionsASAP(NULL, pos=0) ...
[10:58:39.116] - nx: 2
[10:58:39.116] - relay: TRUE
[10:58:39.116] - stdout: TRUE
[10:58:39.116] - signal: TRUE
[10:58:39.116] - resignal: FALSE
[10:58:39.116] - force: TRUE
[10:58:39.116] - relayed: [n=2] TRUE, TRUE
[10:58:39.116] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:39.116] - relayed: [n=2] TRUE, TRUE
[10:58:39.117] - queued futures: [n=2] TRUE, TRUE
[10:58:39.117] signalConditionsASAP(NULL, pos=0) ... done
[10:58:39.117] resolve() on list ... DONE
[10:58:39.117] result() for MulticoreFuture ...
[10:58:39.117] result() for MulticoreFuture ... done
[10:58:39.117] result() for MulticoreFuture ...
[10:58:39.117] result() for MulticoreFuture ... done
[10:58:39.117] result() for MulticoreFuture ...
[10:58:39.117] result() for MulticoreFuture ... done
[10:58:39.118] result() for MulticoreFuture ...
[10:58:39.118] result() for MulticoreFuture ... done
[10:58:39.118]  - Number of value chunks collected: 2
[10:58:39.118] Resolving 2 futures (chunks) ... DONE
[10:58:39.118] Reducing values from 2 chunks ...
[10:58:39.118]  - Number of values collected after concatenation: 2
[10:58:39.118]  - Number of values expected: 2
[10:58:39.118] Reducing values from 2 chunks ... DONE
[10:58:39.119] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:58:39.120] getGlobalsAndPackagesXApply() ...
[10:58:39.120]  - future.globals: TRUE
[10:58:39.120] getGlobalsAndPackages() ...
[10:58:39.120] Searching for globals...
[10:58:39.121] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:39.121] Searching for globals ... DONE
[10:58:39.122] Resolving globals: FALSE
[10:58:39.122] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:39.122] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:39.122] - globals: [1] ‘FUN’
[10:58:39.123] - packages: [1] ‘stats’
[10:58:39.123] getGlobalsAndPackages() ... DONE
[10:58:39.123]  - globals found/used: [n=1] ‘FUN’
[10:58:39.123]  - needed namespaces: [n=1] ‘stats’
[10:58:39.123] Finding globals ... DONE
[10:58:39.123]  - use_args: TRUE
[10:58:39.123]  - Getting '...' globals ...
[10:58:39.124] resolve() on list ...
[10:58:39.124]  recursive: 0
[10:58:39.124]  length: 1
[10:58:39.124]  elements: ‘...’
[10:58:39.124]  length: 0 (resolved future 1)
[10:58:39.124] resolve() on list ... DONE
[10:58:39.124]    - '...' content: [n=0] 
[10:58:39.124] List of 1
[10:58:39.124]  $ ...: list()
[10:58:39.124]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.124]  - attr(*, "where")=List of 1
[10:58:39.124]   ..$ ...:<environment: 0x5635bd119e50> 
[10:58:39.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.124]  - attr(*, "resolved")= logi TRUE
[10:58:39.124]  - attr(*, "total_size")= num NA
[10:58:39.127]  - Getting '...' globals ... DONE
[10:58:39.127] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:39.127] List of 2
[10:58:39.127]  $ ...future.FUN:function (x, ...)  
[10:58:39.127]  $ ...          : list()
[10:58:39.127]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.127]  - attr(*, "where")=List of 2
[10:58:39.127]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:39.127]   ..$ ...          :<environment: 0x5635bd119e50> 
[10:58:39.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.127]  - attr(*, "resolved")= logi FALSE
[10:58:39.127]  - attr(*, "total_size")= num 2586
[10:58:39.130] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:39.130] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.132] future_lapply() ...
[10:58:39.134] Number of chunks: 2
[10:58:39.134] getGlobalsAndPackagesXApply() ...
[10:58:39.134]  - future.globals: <name-value list> with names ‘list()’
[10:58:39.134]  - use_args: TRUE
[10:58:39.134] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:39.134] List of 2
[10:58:39.134]  $ ...          : list()
[10:58:39.134]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.134]  $ ...future.FUN:function (x, ...)  
[10:58:39.134]  - attr(*, "where")=List of 2
[10:58:39.134]   ..$ ...          :<environment: 0x5635bd119e50> 
[10:58:39.134]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:58:39.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.134]  - attr(*, "resolved")= logi FALSE
[10:58:39.134]  - attr(*, "total_size")= num NA
[10:58:39.138] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:39.138] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.138] Number of futures (= number of chunks): 2
[10:58:39.138] Launching 2 futures (chunks) ...
[10:58:39.138] Chunk #1 of 2 ...
[10:58:39.139]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.139]  - seeds: <none>
[10:58:39.139]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.139] getGlobalsAndPackages() ...
[10:58:39.139] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.139] Resolving globals: FALSE
[10:58:39.139] Tweak future expression to call with '...' arguments ...
[10:58:39.139] {
[10:58:39.139]     do.call(function(...) {
[10:58:39.139]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.139]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.139]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.139]             on.exit(options(oopts), add = TRUE)
[10:58:39.139]         }
[10:58:39.139]         {
[10:58:39.139]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.139]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.139]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.139]             })
[10:58:39.139]         }
[10:58:39.139]     }, args = future.call.arguments)
[10:58:39.139] }
[10:58:39.140] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.140] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.140] - packages: [1] ‘stats’
[10:58:39.140] getGlobalsAndPackages() ... DONE
[10:58:39.140] run() for ‘Future’ ...
[10:58:39.141] - state: ‘created’
[10:58:39.141] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.142] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.142]   - Field: ‘label’
[10:58:39.143]   - Field: ‘local’
[10:58:39.143]   - Field: ‘owner’
[10:58:39.143]   - Field: ‘envir’
[10:58:39.143]   - Field: ‘workers’
[10:58:39.143]   - Field: ‘packages’
[10:58:39.143]   - Field: ‘gc’
[10:58:39.143]   - Field: ‘job’
[10:58:39.143]   - Field: ‘conditions’
[10:58:39.143]   - Field: ‘expr’
[10:58:39.143]   - Field: ‘uuid’
[10:58:39.143]   - Field: ‘seed’
[10:58:39.143]   - Field: ‘version’
[10:58:39.144]   - Field: ‘result’
[10:58:39.144]   - Field: ‘asynchronous’
[10:58:39.144]   - Field: ‘calls’
[10:58:39.144]   - Field: ‘globals’
[10:58:39.144]   - Field: ‘stdout’
[10:58:39.144]   - Field: ‘earlySignal’
[10:58:39.144]   - Field: ‘lazy’
[10:58:39.144]   - Field: ‘state’
[10:58:39.144] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.144] - Launch lazy future ...
[10:58:39.145] Packages needed by the future expression (n = 1): ‘stats’
[10:58:39.145] Packages needed by future strategies (n = 0): <none>
[10:58:39.145] {
[10:58:39.145]     {
[10:58:39.145]         {
[10:58:39.145]             ...future.startTime <- base::Sys.time()
[10:58:39.145]             {
[10:58:39.145]                 {
[10:58:39.145]                   {
[10:58:39.145]                     {
[10:58:39.145]                       {
[10:58:39.145]                         base::local({
[10:58:39.145]                           has_future <- base::requireNamespace("future", 
[10:58:39.145]                             quietly = TRUE)
[10:58:39.145]                           if (has_future) {
[10:58:39.145]                             ns <- base::getNamespace("future")
[10:58:39.145]                             version <- ns[[".package"]][["version"]]
[10:58:39.145]                             if (is.null(version)) 
[10:58:39.145]                               version <- utils::packageVersion("future")
[10:58:39.145]                           }
[10:58:39.145]                           else {
[10:58:39.145]                             version <- NULL
[10:58:39.145]                           }
[10:58:39.145]                           if (!has_future || version < "1.8.0") {
[10:58:39.145]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.145]                               "", base::R.version$version.string), 
[10:58:39.145]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:39.145]                                 base::R.version$platform, 8 * 
[10:58:39.145]                                   base::.Machine$sizeof.pointer), 
[10:58:39.145]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.145]                                 "release", "version")], collapse = " "), 
[10:58:39.145]                               hostname = base::Sys.info()[["nodename"]])
[10:58:39.145]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.145]                               info)
[10:58:39.145]                             info <- base::paste(info, collapse = "; ")
[10:58:39.145]                             if (!has_future) {
[10:58:39.145]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.145]                                 info)
[10:58:39.145]                             }
[10:58:39.145]                             else {
[10:58:39.145]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.145]                                 info, version)
[10:58:39.145]                             }
[10:58:39.145]                             base::stop(msg)
[10:58:39.145]                           }
[10:58:39.145]                         })
[10:58:39.145]                       }
[10:58:39.145]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.145]                       base::options(mc.cores = 1L)
[10:58:39.145]                     }
[10:58:39.145]                     base::local({
[10:58:39.145]                       for (pkg in "stats") {
[10:58:39.145]                         base::loadNamespace(pkg)
[10:58:39.145]                         base::library(pkg, character.only = TRUE)
[10:58:39.145]                       }
[10:58:39.145]                     })
[10:58:39.145]                   }
[10:58:39.145]                   ...future.strategy.old <- future::plan("list")
[10:58:39.145]                   options(future.plan = NULL)
[10:58:39.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.145]                 }
[10:58:39.145]                 ...future.workdir <- getwd()
[10:58:39.145]             }
[10:58:39.145]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.145]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.145]         }
[10:58:39.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.145]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.145]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.145]             base::names(...future.oldOptions))
[10:58:39.145]     }
[10:58:39.145]     if (FALSE) {
[10:58:39.145]     }
[10:58:39.145]     else {
[10:58:39.145]         if (TRUE) {
[10:58:39.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.145]                 open = "w")
[10:58:39.145]         }
[10:58:39.145]         else {
[10:58:39.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.145]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.145]         }
[10:58:39.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.145]             base::sink(type = "output", split = FALSE)
[10:58:39.145]             base::close(...future.stdout)
[10:58:39.145]         }, add = TRUE)
[10:58:39.145]     }
[10:58:39.145]     ...future.frame <- base::sys.nframe()
[10:58:39.145]     ...future.conditions <- base::list()
[10:58:39.145]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.145]     if (FALSE) {
[10:58:39.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.145]     }
[10:58:39.145]     ...future.result <- base::tryCatch({
[10:58:39.145]         base::withCallingHandlers({
[10:58:39.145]             ...future.value <- base::withVisible(base::local({
[10:58:39.145]                 withCallingHandlers({
[10:58:39.145]                   {
[10:58:39.145]                     do.call(function(...) {
[10:58:39.145]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.145]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.145]                         ...future.globals.maxSize)) {
[10:58:39.145]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.145]                         on.exit(options(oopts), add = TRUE)
[10:58:39.145]                       }
[10:58:39.145]                       {
[10:58:39.145]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.145]                           FUN = function(jj) {
[10:58:39.145]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.145]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.145]                           })
[10:58:39.145]                       }
[10:58:39.145]                     }, args = future.call.arguments)
[10:58:39.145]                   }
[10:58:39.145]                 }, immediateCondition = function(cond) {
[10:58:39.145]                   save_rds <- function (object, pathname, ...) 
[10:58:39.145]                   {
[10:58:39.145]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.145]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.145]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.145]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.145]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.145]                         fi_tmp[["mtime"]])
[10:58:39.145]                     }
[10:58:39.145]                     tryCatch({
[10:58:39.145]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.145]                     }, error = function(ex) {
[10:58:39.145]                       msg <- conditionMessage(ex)
[10:58:39.145]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.145]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.145]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.145]                         fi_tmp[["mtime"]], msg)
[10:58:39.145]                       ex$message <- msg
[10:58:39.145]                       stop(ex)
[10:58:39.145]                     })
[10:58:39.145]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.145]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.145]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.145]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.145]                       fi <- file.info(pathname)
[10:58:39.145]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.145]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.145]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.145]                         fi[["size"]], fi[["mtime"]])
[10:58:39.145]                       stop(msg)
[10:58:39.145]                     }
[10:58:39.145]                     invisible(pathname)
[10:58:39.145]                   }
[10:58:39.145]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.145]                     rootPath = tempdir()) 
[10:58:39.145]                   {
[10:58:39.145]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.145]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.145]                       tmpdir = path, fileext = ".rds")
[10:58:39.145]                     save_rds(obj, file)
[10:58:39.145]                   }
[10:58:39.145]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.145]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.145]                   {
[10:58:39.145]                     inherits <- base::inherits
[10:58:39.145]                     invokeRestart <- base::invokeRestart
[10:58:39.145]                     is.null <- base::is.null
[10:58:39.145]                     muffled <- FALSE
[10:58:39.145]                     if (inherits(cond, "message")) {
[10:58:39.145]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.145]                       if (muffled) 
[10:58:39.145]                         invokeRestart("muffleMessage")
[10:58:39.145]                     }
[10:58:39.145]                     else if (inherits(cond, "warning")) {
[10:58:39.145]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.145]                       if (muffled) 
[10:58:39.145]                         invokeRestart("muffleWarning")
[10:58:39.145]                     }
[10:58:39.145]                     else if (inherits(cond, "condition")) {
[10:58:39.145]                       if (!is.null(pattern)) {
[10:58:39.145]                         computeRestarts <- base::computeRestarts
[10:58:39.145]                         grepl <- base::grepl
[10:58:39.145]                         restarts <- computeRestarts(cond)
[10:58:39.145]                         for (restart in restarts) {
[10:58:39.145]                           name <- restart$name
[10:58:39.145]                           if (is.null(name)) 
[10:58:39.145]                             next
[10:58:39.145]                           if (!grepl(pattern, name)) 
[10:58:39.145]                             next
[10:58:39.145]                           invokeRestart(restart)
[10:58:39.145]                           muffled <- TRUE
[10:58:39.145]                           break
[10:58:39.145]                         }
[10:58:39.145]                       }
[10:58:39.145]                     }
[10:58:39.145]                     invisible(muffled)
[10:58:39.145]                   }
[10:58:39.145]                   muffleCondition(cond)
[10:58:39.145]                 })
[10:58:39.145]             }))
[10:58:39.145]             future::FutureResult(value = ...future.value$value, 
[10:58:39.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.145]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.145]                     ...future.globalenv.names))
[10:58:39.145]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.145]         }, condition = base::local({
[10:58:39.145]             c <- base::c
[10:58:39.145]             inherits <- base::inherits
[10:58:39.145]             invokeRestart <- base::invokeRestart
[10:58:39.145]             length <- base::length
[10:58:39.145]             list <- base::list
[10:58:39.145]             seq.int <- base::seq.int
[10:58:39.145]             signalCondition <- base::signalCondition
[10:58:39.145]             sys.calls <- base::sys.calls
[10:58:39.145]             `[[` <- base::`[[`
[10:58:39.145]             `+` <- base::`+`
[10:58:39.145]             `<<-` <- base::`<<-`
[10:58:39.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.145]                   3L)]
[10:58:39.145]             }
[10:58:39.145]             function(cond) {
[10:58:39.145]                 is_error <- inherits(cond, "error")
[10:58:39.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.145]                   NULL)
[10:58:39.145]                 if (is_error) {
[10:58:39.145]                   sessionInformation <- function() {
[10:58:39.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.145]                       search = base::search(), system = base::Sys.info())
[10:58:39.145]                   }
[10:58:39.145]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.145]                     cond$call), session = sessionInformation(), 
[10:58:39.145]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.145]                   signalCondition(cond)
[10:58:39.145]                 }
[10:58:39.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.145]                 "immediateCondition"))) {
[10:58:39.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.145]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.145]                   if (TRUE && !signal) {
[10:58:39.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.145]                     {
[10:58:39.145]                       inherits <- base::inherits
[10:58:39.145]                       invokeRestart <- base::invokeRestart
[10:58:39.145]                       is.null <- base::is.null
[10:58:39.145]                       muffled <- FALSE
[10:58:39.145]                       if (inherits(cond, "message")) {
[10:58:39.145]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.145]                         if (muffled) 
[10:58:39.145]                           invokeRestart("muffleMessage")
[10:58:39.145]                       }
[10:58:39.145]                       else if (inherits(cond, "warning")) {
[10:58:39.145]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.145]                         if (muffled) 
[10:58:39.145]                           invokeRestart("muffleWarning")
[10:58:39.145]                       }
[10:58:39.145]                       else if (inherits(cond, "condition")) {
[10:58:39.145]                         if (!is.null(pattern)) {
[10:58:39.145]                           computeRestarts <- base::computeRestarts
[10:58:39.145]                           grepl <- base::grepl
[10:58:39.145]                           restarts <- computeRestarts(cond)
[10:58:39.145]                           for (restart in restarts) {
[10:58:39.145]                             name <- restart$name
[10:58:39.145]                             if (is.null(name)) 
[10:58:39.145]                               next
[10:58:39.145]                             if (!grepl(pattern, name)) 
[10:58:39.145]                               next
[10:58:39.145]                             invokeRestart(restart)
[10:58:39.145]                             muffled <- TRUE
[10:58:39.145]                             break
[10:58:39.145]                           }
[10:58:39.145]                         }
[10:58:39.145]                       }
[10:58:39.145]                       invisible(muffled)
[10:58:39.145]                     }
[10:58:39.145]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.145]                   }
[10:58:39.145]                 }
[10:58:39.145]                 else {
[10:58:39.145]                   if (TRUE) {
[10:58:39.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.145]                     {
[10:58:39.145]                       inherits <- base::inherits
[10:58:39.145]                       invokeRestart <- base::invokeRestart
[10:58:39.145]                       is.null <- base::is.null
[10:58:39.145]                       muffled <- FALSE
[10:58:39.145]                       if (inherits(cond, "message")) {
[10:58:39.145]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.145]                         if (muffled) 
[10:58:39.145]                           invokeRestart("muffleMessage")
[10:58:39.145]                       }
[10:58:39.145]                       else if (inherits(cond, "warning")) {
[10:58:39.145]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.145]                         if (muffled) 
[10:58:39.145]                           invokeRestart("muffleWarning")
[10:58:39.145]                       }
[10:58:39.145]                       else if (inherits(cond, "condition")) {
[10:58:39.145]                         if (!is.null(pattern)) {
[10:58:39.145]                           computeRestarts <- base::computeRestarts
[10:58:39.145]                           grepl <- base::grepl
[10:58:39.145]                           restarts <- computeRestarts(cond)
[10:58:39.145]                           for (restart in restarts) {
[10:58:39.145]                             name <- restart$name
[10:58:39.145]                             if (is.null(name)) 
[10:58:39.145]                               next
[10:58:39.145]                             if (!grepl(pattern, name)) 
[10:58:39.145]                               next
[10:58:39.145]                             invokeRestart(restart)
[10:58:39.145]                             muffled <- TRUE
[10:58:39.145]                             break
[10:58:39.145]                           }
[10:58:39.145]                         }
[10:58:39.145]                       }
[10:58:39.145]                       invisible(muffled)
[10:58:39.145]                     }
[10:58:39.145]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.145]                   }
[10:58:39.145]                 }
[10:58:39.145]             }
[10:58:39.145]         }))
[10:58:39.145]     }, error = function(ex) {
[10:58:39.145]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.145]                 ...future.rng), started = ...future.startTime, 
[10:58:39.145]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.145]             version = "1.8"), class = "FutureResult")
[10:58:39.145]     }, finally = {
[10:58:39.145]         if (!identical(...future.workdir, getwd())) 
[10:58:39.145]             setwd(...future.workdir)
[10:58:39.145]         {
[10:58:39.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.145]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.145]             }
[10:58:39.145]             base::options(...future.oldOptions)
[10:58:39.145]             if (.Platform$OS.type == "windows") {
[10:58:39.145]                 old_names <- names(...future.oldEnvVars)
[10:58:39.145]                 envs <- base::Sys.getenv()
[10:58:39.145]                 names <- names(envs)
[10:58:39.145]                 common <- intersect(names, old_names)
[10:58:39.145]                 added <- setdiff(names, old_names)
[10:58:39.145]                 removed <- setdiff(old_names, names)
[10:58:39.145]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.145]                   envs[common]]
[10:58:39.145]                 NAMES <- toupper(changed)
[10:58:39.145]                 args <- list()
[10:58:39.145]                 for (kk in seq_along(NAMES)) {
[10:58:39.145]                   name <- changed[[kk]]
[10:58:39.145]                   NAME <- NAMES[[kk]]
[10:58:39.145]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.145]                     next
[10:58:39.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.145]                 }
[10:58:39.145]                 NAMES <- toupper(added)
[10:58:39.145]                 for (kk in seq_along(NAMES)) {
[10:58:39.145]                   name <- added[[kk]]
[10:58:39.145]                   NAME <- NAMES[[kk]]
[10:58:39.145]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.145]                     next
[10:58:39.145]                   args[[name]] <- ""
[10:58:39.145]                 }
[10:58:39.145]                 NAMES <- toupper(removed)
[10:58:39.145]                 for (kk in seq_along(NAMES)) {
[10:58:39.145]                   name <- removed[[kk]]
[10:58:39.145]                   NAME <- NAMES[[kk]]
[10:58:39.145]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.145]                     next
[10:58:39.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.145]                 }
[10:58:39.145]                 if (length(args) > 0) 
[10:58:39.145]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.145]             }
[10:58:39.145]             else {
[10:58:39.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.145]             }
[10:58:39.145]             {
[10:58:39.145]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.145]                   0L) {
[10:58:39.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.145]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.145]                   base::options(opts)
[10:58:39.145]                 }
[10:58:39.145]                 {
[10:58:39.145]                   {
[10:58:39.145]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.145]                     NULL
[10:58:39.145]                   }
[10:58:39.145]                   options(future.plan = NULL)
[10:58:39.145]                   if (is.na(NA_character_)) 
[10:58:39.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.145]                     .init = FALSE)
[10:58:39.145]                 }
[10:58:39.145]             }
[10:58:39.145]         }
[10:58:39.145]     })
[10:58:39.145]     if (TRUE) {
[10:58:39.145]         base::sink(type = "output", split = FALSE)
[10:58:39.145]         if (TRUE) {
[10:58:39.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.145]         }
[10:58:39.145]         else {
[10:58:39.145]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.145]         }
[10:58:39.145]         base::close(...future.stdout)
[10:58:39.145]         ...future.stdout <- NULL
[10:58:39.145]     }
[10:58:39.145]     ...future.result$conditions <- ...future.conditions
[10:58:39.145]     ...future.result$finished <- base::Sys.time()
[10:58:39.145]     ...future.result
[10:58:39.145] }
[10:58:39.148] assign_globals() ...
[10:58:39.148] List of 5
[10:58:39.148]  $ future.call.arguments    : list()
[10:58:39.148]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.148]  $ ...future.FUN            :function (x, ...)  
[10:58:39.148]  $ ...future.elements_ii    :List of 1
[10:58:39.148]   ..$ : num [1:4] 1 3 1 7
[10:58:39.148]  $ ...future.seeds_ii       : NULL
[10:58:39.148]  $ ...future.globals.maxSize: num Inf
[10:58:39.148]  - attr(*, "resolved")= logi FALSE
[10:58:39.148]  - attr(*, "total_size")= num NA
[10:58:39.148]  - attr(*, "where")=List of 5
[10:58:39.148]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.148]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.148]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.148]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.148]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.148]  - attr(*, "already-done")= logi TRUE
[10:58:39.152] - copied ‘future.call.arguments’ to environment
[10:58:39.152] - copied ‘...future.FUN’ to environment
[10:58:39.152] - copied ‘...future.elements_ii’ to environment
[10:58:39.152] - copied ‘...future.seeds_ii’ to environment
[10:58:39.152] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.153] assign_globals() ... done
[10:58:39.153] requestCore(): workers = 2
[10:58:39.154] MulticoreFuture started
[10:58:39.155] - Launch lazy future ... done
[10:58:39.155] run() for ‘MulticoreFuture’ ... done
[10:58:39.155] Created future:
[10:58:39.156] plan(): Setting new future strategy stack:
[10:58:39.156] List of future strategies:
[10:58:39.156] 1. sequential:
[10:58:39.156]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.156]    - tweaked: FALSE
[10:58:39.156]    - call: NULL
[10:58:39.157] plan(): nbrOfWorkers() = 1
[10:58:39.159] plan(): Setting new future strategy stack:
[10:58:39.159] List of future strategies:
[10:58:39.159] 1. multicore:
[10:58:39.159]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.159]    - tweaked: FALSE
[10:58:39.159]    - call: plan(strategy)
[10:58:39.162] plan(): nbrOfWorkers() = 2
[10:58:39.155] MulticoreFuture:
[10:58:39.155] Label: ‘future_apply-1’
[10:58:39.155] Expression:
[10:58:39.155] {
[10:58:39.155]     do.call(function(...) {
[10:58:39.155]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.155]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.155]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.155]             on.exit(options(oopts), add = TRUE)
[10:58:39.155]         }
[10:58:39.155]         {
[10:58:39.155]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.155]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.155]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.155]             })
[10:58:39.155]         }
[10:58:39.155]     }, args = future.call.arguments)
[10:58:39.155] }
[10:58:39.155] Lazy evaluation: FALSE
[10:58:39.155] Asynchronous evaluation: TRUE
[10:58:39.155] Local evaluation: TRUE
[10:58:39.155] Environment: R_GlobalEnv
[10:58:39.155] Capture standard output: TRUE
[10:58:39.155] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.155] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.155] Packages: 1 packages (‘stats’)
[10:58:39.155] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.155] Resolved: TRUE
[10:58:39.155] Value: <not collected>
[10:58:39.155] Conditions captured: <none>
[10:58:39.155] Early signaling: FALSE
[10:58:39.155] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.155] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.163] Chunk #1 of 2 ... DONE
[10:58:39.163] Chunk #2 of 2 ...
[10:58:39.164]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.164]  - seeds: <none>
[10:58:39.164]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.164] getGlobalsAndPackages() ...
[10:58:39.164] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.164] Resolving globals: FALSE
[10:58:39.164] Tweak future expression to call with '...' arguments ...
[10:58:39.165] {
[10:58:39.165]     do.call(function(...) {
[10:58:39.165]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.165]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.165]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.165]             on.exit(options(oopts), add = TRUE)
[10:58:39.165]         }
[10:58:39.165]         {
[10:58:39.165]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.165]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.165]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.165]             })
[10:58:39.165]         }
[10:58:39.165]     }, args = future.call.arguments)
[10:58:39.165] }
[10:58:39.165] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.166] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.166] - packages: [1] ‘stats’
[10:58:39.166] getGlobalsAndPackages() ... DONE
[10:58:39.166] run() for ‘Future’ ...
[10:58:39.167] - state: ‘created’
[10:58:39.167] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.169] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.169] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.170]   - Field: ‘label’
[10:58:39.170]   - Field: ‘local’
[10:58:39.170]   - Field: ‘owner’
[10:58:39.170]   - Field: ‘envir’
[10:58:39.170]   - Field: ‘workers’
[10:58:39.170]   - Field: ‘packages’
[10:58:39.170]   - Field: ‘gc’
[10:58:39.171]   - Field: ‘job’
[10:58:39.171]   - Field: ‘conditions’
[10:58:39.171]   - Field: ‘expr’
[10:58:39.171]   - Field: ‘uuid’
[10:58:39.171]   - Field: ‘seed’
[10:58:39.171]   - Field: ‘version’
[10:58:39.171]   - Field: ‘result’
[10:58:39.171]   - Field: ‘asynchronous’
[10:58:39.172]   - Field: ‘calls’
[10:58:39.179]   - Field: ‘globals’
[10:58:39.179]   - Field: ‘stdout’
[10:58:39.179]   - Field: ‘earlySignal’
[10:58:39.179]   - Field: ‘lazy’
[10:58:39.180]   - Field: ‘state’
[10:58:39.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.180] - Launch lazy future ...
[10:58:39.180] Packages needed by the future expression (n = 1): ‘stats’
[10:58:39.180] Packages needed by future strategies (n = 0): <none>
[10:58:39.181] {
[10:58:39.181]     {
[10:58:39.181]         {
[10:58:39.181]             ...future.startTime <- base::Sys.time()
[10:58:39.181]             {
[10:58:39.181]                 {
[10:58:39.181]                   {
[10:58:39.181]                     {
[10:58:39.181]                       {
[10:58:39.181]                         base::local({
[10:58:39.181]                           has_future <- base::requireNamespace("future", 
[10:58:39.181]                             quietly = TRUE)
[10:58:39.181]                           if (has_future) {
[10:58:39.181]                             ns <- base::getNamespace("future")
[10:58:39.181]                             version <- ns[[".package"]][["version"]]
[10:58:39.181]                             if (is.null(version)) 
[10:58:39.181]                               version <- utils::packageVersion("future")
[10:58:39.181]                           }
[10:58:39.181]                           else {
[10:58:39.181]                             version <- NULL
[10:58:39.181]                           }
[10:58:39.181]                           if (!has_future || version < "1.8.0") {
[10:58:39.181]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.181]                               "", base::R.version$version.string), 
[10:58:39.181]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:39.181]                                 base::R.version$platform, 8 * 
[10:58:39.181]                                   base::.Machine$sizeof.pointer), 
[10:58:39.181]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.181]                                 "release", "version")], collapse = " "), 
[10:58:39.181]                               hostname = base::Sys.info()[["nodename"]])
[10:58:39.181]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.181]                               info)
[10:58:39.181]                             info <- base::paste(info, collapse = "; ")
[10:58:39.181]                             if (!has_future) {
[10:58:39.181]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.181]                                 info)
[10:58:39.181]                             }
[10:58:39.181]                             else {
[10:58:39.181]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.181]                                 info, version)
[10:58:39.181]                             }
[10:58:39.181]                             base::stop(msg)
[10:58:39.181]                           }
[10:58:39.181]                         })
[10:58:39.181]                       }
[10:58:39.181]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.181]                       base::options(mc.cores = 1L)
[10:58:39.181]                     }
[10:58:39.181]                     base::local({
[10:58:39.181]                       for (pkg in "stats") {
[10:58:39.181]                         base::loadNamespace(pkg)
[10:58:39.181]                         base::library(pkg, character.only = TRUE)
[10:58:39.181]                       }
[10:58:39.181]                     })
[10:58:39.181]                   }
[10:58:39.181]                   ...future.strategy.old <- future::plan("list")
[10:58:39.181]                   options(future.plan = NULL)
[10:58:39.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.181]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.181]                 }
[10:58:39.181]                 ...future.workdir <- getwd()
[10:58:39.181]             }
[10:58:39.181]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.181]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.181]         }
[10:58:39.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.181]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.181]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.181]             base::names(...future.oldOptions))
[10:58:39.181]     }
[10:58:39.181]     if (FALSE) {
[10:58:39.181]     }
[10:58:39.181]     else {
[10:58:39.181]         if (TRUE) {
[10:58:39.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.181]                 open = "w")
[10:58:39.181]         }
[10:58:39.181]         else {
[10:58:39.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.181]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.181]         }
[10:58:39.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.181]             base::sink(type = "output", split = FALSE)
[10:58:39.181]             base::close(...future.stdout)
[10:58:39.181]         }, add = TRUE)
[10:58:39.181]     }
[10:58:39.181]     ...future.frame <- base::sys.nframe()
[10:58:39.181]     ...future.conditions <- base::list()
[10:58:39.181]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.181]     if (FALSE) {
[10:58:39.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.181]     }
[10:58:39.181]     ...future.result <- base::tryCatch({
[10:58:39.181]         base::withCallingHandlers({
[10:58:39.181]             ...future.value <- base::withVisible(base::local({
[10:58:39.181]                 withCallingHandlers({
[10:58:39.181]                   {
[10:58:39.181]                     do.call(function(...) {
[10:58:39.181]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.181]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.181]                         ...future.globals.maxSize)) {
[10:58:39.181]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.181]                         on.exit(options(oopts), add = TRUE)
[10:58:39.181]                       }
[10:58:39.181]                       {
[10:58:39.181]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.181]                           FUN = function(jj) {
[10:58:39.181]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.181]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.181]                           })
[10:58:39.181]                       }
[10:58:39.181]                     }, args = future.call.arguments)
[10:58:39.181]                   }
[10:58:39.181]                 }, immediateCondition = function(cond) {
[10:58:39.181]                   save_rds <- function (object, pathname, ...) 
[10:58:39.181]                   {
[10:58:39.181]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.181]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.181]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.181]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.181]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.181]                         fi_tmp[["mtime"]])
[10:58:39.181]                     }
[10:58:39.181]                     tryCatch({
[10:58:39.181]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.181]                     }, error = function(ex) {
[10:58:39.181]                       msg <- conditionMessage(ex)
[10:58:39.181]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.181]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.181]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.181]                         fi_tmp[["mtime"]], msg)
[10:58:39.181]                       ex$message <- msg
[10:58:39.181]                       stop(ex)
[10:58:39.181]                     })
[10:58:39.181]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.181]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.181]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.181]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.181]                       fi <- file.info(pathname)
[10:58:39.181]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.181]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.181]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.181]                         fi[["size"]], fi[["mtime"]])
[10:58:39.181]                       stop(msg)
[10:58:39.181]                     }
[10:58:39.181]                     invisible(pathname)
[10:58:39.181]                   }
[10:58:39.181]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.181]                     rootPath = tempdir()) 
[10:58:39.181]                   {
[10:58:39.181]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.181]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.181]                       tmpdir = path, fileext = ".rds")
[10:58:39.181]                     save_rds(obj, file)
[10:58:39.181]                   }
[10:58:39.181]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.181]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.181]                   {
[10:58:39.181]                     inherits <- base::inherits
[10:58:39.181]                     invokeRestart <- base::invokeRestart
[10:58:39.181]                     is.null <- base::is.null
[10:58:39.181]                     muffled <- FALSE
[10:58:39.181]                     if (inherits(cond, "message")) {
[10:58:39.181]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.181]                       if (muffled) 
[10:58:39.181]                         invokeRestart("muffleMessage")
[10:58:39.181]                     }
[10:58:39.181]                     else if (inherits(cond, "warning")) {
[10:58:39.181]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.181]                       if (muffled) 
[10:58:39.181]                         invokeRestart("muffleWarning")
[10:58:39.181]                     }
[10:58:39.181]                     else if (inherits(cond, "condition")) {
[10:58:39.181]                       if (!is.null(pattern)) {
[10:58:39.181]                         computeRestarts <- base::computeRestarts
[10:58:39.181]                         grepl <- base::grepl
[10:58:39.181]                         restarts <- computeRestarts(cond)
[10:58:39.181]                         for (restart in restarts) {
[10:58:39.181]                           name <- restart$name
[10:58:39.181]                           if (is.null(name)) 
[10:58:39.181]                             next
[10:58:39.181]                           if (!grepl(pattern, name)) 
[10:58:39.181]                             next
[10:58:39.181]                           invokeRestart(restart)
[10:58:39.181]                           muffled <- TRUE
[10:58:39.181]                           break
[10:58:39.181]                         }
[10:58:39.181]                       }
[10:58:39.181]                     }
[10:58:39.181]                     invisible(muffled)
[10:58:39.181]                   }
[10:58:39.181]                   muffleCondition(cond)
[10:58:39.181]                 })
[10:58:39.181]             }))
[10:58:39.181]             future::FutureResult(value = ...future.value$value, 
[10:58:39.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.181]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.181]                     ...future.globalenv.names))
[10:58:39.181]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.181]         }, condition = base::local({
[10:58:39.181]             c <- base::c
[10:58:39.181]             inherits <- base::inherits
[10:58:39.181]             invokeRestart <- base::invokeRestart
[10:58:39.181]             length <- base::length
[10:58:39.181]             list <- base::list
[10:58:39.181]             seq.int <- base::seq.int
[10:58:39.181]             signalCondition <- base::signalCondition
[10:58:39.181]             sys.calls <- base::sys.calls
[10:58:39.181]             `[[` <- base::`[[`
[10:58:39.181]             `+` <- base::`+`
[10:58:39.181]             `<<-` <- base::`<<-`
[10:58:39.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.181]                   3L)]
[10:58:39.181]             }
[10:58:39.181]             function(cond) {
[10:58:39.181]                 is_error <- inherits(cond, "error")
[10:58:39.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.181]                   NULL)
[10:58:39.181]                 if (is_error) {
[10:58:39.181]                   sessionInformation <- function() {
[10:58:39.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.181]                       search = base::search(), system = base::Sys.info())
[10:58:39.181]                   }
[10:58:39.181]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.181]                     cond$call), session = sessionInformation(), 
[10:58:39.181]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.181]                   signalCondition(cond)
[10:58:39.181]                 }
[10:58:39.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.181]                 "immediateCondition"))) {
[10:58:39.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.181]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.181]                   if (TRUE && !signal) {
[10:58:39.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.181]                     {
[10:58:39.181]                       inherits <- base::inherits
[10:58:39.181]                       invokeRestart <- base::invokeRestart
[10:58:39.181]                       is.null <- base::is.null
[10:58:39.181]                       muffled <- FALSE
[10:58:39.181]                       if (inherits(cond, "message")) {
[10:58:39.181]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.181]                         if (muffled) 
[10:58:39.181]                           invokeRestart("muffleMessage")
[10:58:39.181]                       }
[10:58:39.181]                       else if (inherits(cond, "warning")) {
[10:58:39.181]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.181]                         if (muffled) 
[10:58:39.181]                           invokeRestart("muffleWarning")
[10:58:39.181]                       }
[10:58:39.181]                       else if (inherits(cond, "condition")) {
[10:58:39.181]                         if (!is.null(pattern)) {
[10:58:39.181]                           computeRestarts <- base::computeRestarts
[10:58:39.181]                           grepl <- base::grepl
[10:58:39.181]                           restarts <- computeRestarts(cond)
[10:58:39.181]                           for (restart in restarts) {
[10:58:39.181]                             name <- restart$name
[10:58:39.181]                             if (is.null(name)) 
[10:58:39.181]                               next
[10:58:39.181]                             if (!grepl(pattern, name)) 
[10:58:39.181]                               next
[10:58:39.181]                             invokeRestart(restart)
[10:58:39.181]                             muffled <- TRUE
[10:58:39.181]                             break
[10:58:39.181]                           }
[10:58:39.181]                         }
[10:58:39.181]                       }
[10:58:39.181]                       invisible(muffled)
[10:58:39.181]                     }
[10:58:39.181]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.181]                   }
[10:58:39.181]                 }
[10:58:39.181]                 else {
[10:58:39.181]                   if (TRUE) {
[10:58:39.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.181]                     {
[10:58:39.181]                       inherits <- base::inherits
[10:58:39.181]                       invokeRestart <- base::invokeRestart
[10:58:39.181]                       is.null <- base::is.null
[10:58:39.181]                       muffled <- FALSE
[10:58:39.181]                       if (inherits(cond, "message")) {
[10:58:39.181]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.181]                         if (muffled) 
[10:58:39.181]                           invokeRestart("muffleMessage")
[10:58:39.181]                       }
[10:58:39.181]                       else if (inherits(cond, "warning")) {
[10:58:39.181]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.181]                         if (muffled) 
[10:58:39.181]                           invokeRestart("muffleWarning")
[10:58:39.181]                       }
[10:58:39.181]                       else if (inherits(cond, "condition")) {
[10:58:39.181]                         if (!is.null(pattern)) {
[10:58:39.181]                           computeRestarts <- base::computeRestarts
[10:58:39.181]                           grepl <- base::grepl
[10:58:39.181]                           restarts <- computeRestarts(cond)
[10:58:39.181]                           for (restart in restarts) {
[10:58:39.181]                             name <- restart$name
[10:58:39.181]                             if (is.null(name)) 
[10:58:39.181]                               next
[10:58:39.181]                             if (!grepl(pattern, name)) 
[10:58:39.181]                               next
[10:58:39.181]                             invokeRestart(restart)
[10:58:39.181]                             muffled <- TRUE
[10:58:39.181]                             break
[10:58:39.181]                           }
[10:58:39.181]                         }
[10:58:39.181]                       }
[10:58:39.181]                       invisible(muffled)
[10:58:39.181]                     }
[10:58:39.181]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.181]                   }
[10:58:39.181]                 }
[10:58:39.181]             }
[10:58:39.181]         }))
[10:58:39.181]     }, error = function(ex) {
[10:58:39.181]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.181]                 ...future.rng), started = ...future.startTime, 
[10:58:39.181]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.181]             version = "1.8"), class = "FutureResult")
[10:58:39.181]     }, finally = {
[10:58:39.181]         if (!identical(...future.workdir, getwd())) 
[10:58:39.181]             setwd(...future.workdir)
[10:58:39.181]         {
[10:58:39.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.181]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.181]             }
[10:58:39.181]             base::options(...future.oldOptions)
[10:58:39.181]             if (.Platform$OS.type == "windows") {
[10:58:39.181]                 old_names <- names(...future.oldEnvVars)
[10:58:39.181]                 envs <- base::Sys.getenv()
[10:58:39.181]                 names <- names(envs)
[10:58:39.181]                 common <- intersect(names, old_names)
[10:58:39.181]                 added <- setdiff(names, old_names)
[10:58:39.181]                 removed <- setdiff(old_names, names)
[10:58:39.181]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.181]                   envs[common]]
[10:58:39.181]                 NAMES <- toupper(changed)
[10:58:39.181]                 args <- list()
[10:58:39.181]                 for (kk in seq_along(NAMES)) {
[10:58:39.181]                   name <- changed[[kk]]
[10:58:39.181]                   NAME <- NAMES[[kk]]
[10:58:39.181]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.181]                     next
[10:58:39.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.181]                 }
[10:58:39.181]                 NAMES <- toupper(added)
[10:58:39.181]                 for (kk in seq_along(NAMES)) {
[10:58:39.181]                   name <- added[[kk]]
[10:58:39.181]                   NAME <- NAMES[[kk]]
[10:58:39.181]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.181]                     next
[10:58:39.181]                   args[[name]] <- ""
[10:58:39.181]                 }
[10:58:39.181]                 NAMES <- toupper(removed)
[10:58:39.181]                 for (kk in seq_along(NAMES)) {
[10:58:39.181]                   name <- removed[[kk]]
[10:58:39.181]                   NAME <- NAMES[[kk]]
[10:58:39.181]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.181]                     next
[10:58:39.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.181]                 }
[10:58:39.181]                 if (length(args) > 0) 
[10:58:39.181]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.181]             }
[10:58:39.181]             else {
[10:58:39.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.181]             }
[10:58:39.181]             {
[10:58:39.181]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.181]                   0L) {
[10:58:39.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.181]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.181]                   base::options(opts)
[10:58:39.181]                 }
[10:58:39.181]                 {
[10:58:39.181]                   {
[10:58:39.181]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.181]                     NULL
[10:58:39.181]                   }
[10:58:39.181]                   options(future.plan = NULL)
[10:58:39.181]                   if (is.na(NA_character_)) 
[10:58:39.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.181]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.181]                     .init = FALSE)
[10:58:39.181]                 }
[10:58:39.181]             }
[10:58:39.181]         }
[10:58:39.181]     })
[10:58:39.181]     if (TRUE) {
[10:58:39.181]         base::sink(type = "output", split = FALSE)
[10:58:39.181]         if (TRUE) {
[10:58:39.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.181]         }
[10:58:39.181]         else {
[10:58:39.181]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.181]         }
[10:58:39.181]         base::close(...future.stdout)
[10:58:39.181]         ...future.stdout <- NULL
[10:58:39.181]     }
[10:58:39.181]     ...future.result$conditions <- ...future.conditions
[10:58:39.181]     ...future.result$finished <- base::Sys.time()
[10:58:39.181]     ...future.result
[10:58:39.181] }
[10:58:39.184] assign_globals() ...
[10:58:39.184] List of 5
[10:58:39.184]  $ future.call.arguments    : list()
[10:58:39.184]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.184]  $ ...future.FUN            :function (x, ...)  
[10:58:39.184]  $ ...future.elements_ii    :List of 1
[10:58:39.184]   ..$ : num [1:4] 2 4 6 8
[10:58:39.184]  $ ...future.seeds_ii       : NULL
[10:58:39.184]  $ ...future.globals.maxSize: num Inf
[10:58:39.184]  - attr(*, "resolved")= logi FALSE
[10:58:39.184]  - attr(*, "total_size")= num NA
[10:58:39.184]  - attr(*, "where")=List of 5
[10:58:39.184]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.184]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.184]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.184]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.184]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.184]  - attr(*, "already-done")= logi TRUE
[10:58:39.191] - copied ‘future.call.arguments’ to environment
[10:58:39.191] - copied ‘...future.FUN’ to environment
[10:58:39.191] - copied ‘...future.elements_ii’ to environment
[10:58:39.191] - copied ‘...future.seeds_ii’ to environment
[10:58:39.192] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.192] assign_globals() ... done
[10:58:39.192] requestCore(): workers = 2
[10:58:39.194] MulticoreFuture started
[10:58:39.194] - Launch lazy future ... done
[10:58:39.194] run() for ‘MulticoreFuture’ ... done
[10:58:39.195] Created future:
[10:58:39.195] plan(): Setting new future strategy stack:
[10:58:39.196] List of future strategies:
[10:58:39.196] 1. sequential:
[10:58:39.196]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.196]    - tweaked: FALSE
[10:58:39.196]    - call: NULL
[10:58:39.197] plan(): nbrOfWorkers() = 1
[10:58:39.199] plan(): Setting new future strategy stack:
[10:58:39.199] List of future strategies:
[10:58:39.199] 1. multicore:
[10:58:39.199]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.199]    - tweaked: FALSE
[10:58:39.199]    - call: plan(strategy)
[10:58:39.202] plan(): nbrOfWorkers() = 2
[10:58:39.195] MulticoreFuture:
[10:58:39.195] Label: ‘future_apply-2’
[10:58:39.195] Expression:
[10:58:39.195] {
[10:58:39.195]     do.call(function(...) {
[10:58:39.195]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.195]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.195]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.195]             on.exit(options(oopts), add = TRUE)
[10:58:39.195]         }
[10:58:39.195]         {
[10:58:39.195]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.195]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.195]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.195]             })
[10:58:39.195]         }
[10:58:39.195]     }, args = future.call.arguments)
[10:58:39.195] }
[10:58:39.195] Lazy evaluation: FALSE
[10:58:39.195] Asynchronous evaluation: TRUE
[10:58:39.195] Local evaluation: TRUE
[10:58:39.195] Environment: R_GlobalEnv
[10:58:39.195] Capture standard output: TRUE
[10:58:39.195] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.195] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.195] Packages: 1 packages (‘stats’)
[10:58:39.195] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.195] Resolved: TRUE
[10:58:39.195] Value: <not collected>
[10:58:39.195] Conditions captured: <none>
[10:58:39.195] Early signaling: FALSE
[10:58:39.195] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.195] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.203] Chunk #2 of 2 ... DONE
[10:58:39.204] Launching 2 futures (chunks) ... DONE
[10:58:39.204] Resolving 2 futures (chunks) ...
[10:58:39.204] resolve() on list ...
[10:58:39.204]  recursive: 0
[10:58:39.204]  length: 2
[10:58:39.204] 
[10:58:39.205] Future #1
[10:58:39.205] result() for MulticoreFuture ...
[10:58:39.206] result() for MulticoreFuture ...
[10:58:39.206] result() for MulticoreFuture ... done
[10:58:39.206] result() for MulticoreFuture ... done
[10:58:39.206] result() for MulticoreFuture ...
[10:58:39.206] result() for MulticoreFuture ... done
[10:58:39.206] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:39.207] - nx: 2
[10:58:39.207] - relay: TRUE
[10:58:39.207] - stdout: TRUE
[10:58:39.207] - signal: TRUE
[10:58:39.207] - resignal: FALSE
[10:58:39.207] - force: TRUE
[10:58:39.207] - relayed: [n=2] FALSE, FALSE
[10:58:39.207] - queued futures: [n=2] FALSE, FALSE
[10:58:39.208]  - until=1
[10:58:39.208]  - relaying element #1
[10:58:39.208] result() for MulticoreFuture ...
[10:58:39.208] result() for MulticoreFuture ... done
[10:58:39.208] result() for MulticoreFuture ...
[10:58:39.208] result() for MulticoreFuture ... done
[10:58:39.209] result() for MulticoreFuture ...
[10:58:39.209] result() for MulticoreFuture ... done
[10:58:39.209] result() for MulticoreFuture ...
[10:58:39.209] result() for MulticoreFuture ... done
[10:58:39.209] - relayed: [n=2] TRUE, FALSE
[10:58:39.209] - queued futures: [n=2] TRUE, FALSE
[10:58:39.209] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:39.210]  length: 1 (resolved future 1)
[10:58:39.210] Future #2
[10:58:39.210] result() for MulticoreFuture ...
[10:58:39.211] result() for MulticoreFuture ...
[10:58:39.211] result() for MulticoreFuture ... done
[10:58:39.211] result() for MulticoreFuture ... done
[10:58:39.211] result() for MulticoreFuture ...
[10:58:39.211] result() for MulticoreFuture ... done
[10:58:39.211] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:39.212] - nx: 2
[10:58:39.212] - relay: TRUE
[10:58:39.212] - stdout: TRUE
[10:58:39.212] - signal: TRUE
[10:58:39.212] - resignal: FALSE
[10:58:39.212] - force: TRUE
[10:58:39.212] - relayed: [n=2] TRUE, FALSE
[10:58:39.212] - queued futures: [n=2] TRUE, FALSE
[10:58:39.213]  - until=2
[10:58:39.213]  - relaying element #2
[10:58:39.213] result() for MulticoreFuture ...
[10:58:39.213] result() for MulticoreFuture ... done
[10:58:39.213] result() for MulticoreFuture ...
[10:58:39.213] result() for MulticoreFuture ... done
[10:58:39.213] result() for MulticoreFuture ...
[10:58:39.213] result() for MulticoreFuture ... done
[10:58:39.214] result() for MulticoreFuture ...
[10:58:39.214] result() for MulticoreFuture ... done
[10:58:39.214] - relayed: [n=2] TRUE, TRUE
[10:58:39.214] - queued futures: [n=2] TRUE, TRUE
[10:58:39.214] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:39.214]  length: 0 (resolved future 2)
[10:58:39.214] Relaying remaining futures
[10:58:39.214] signalConditionsASAP(NULL, pos=0) ...
[10:58:39.214] - nx: 2
[10:58:39.214] - relay: TRUE
[10:58:39.215] - stdout: TRUE
[10:58:39.215] - signal: TRUE
[10:58:39.215] - resignal: FALSE
[10:58:39.215] - force: TRUE
[10:58:39.215] - relayed: [n=2] TRUE, TRUE
[10:58:39.215] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:39.215] - relayed: [n=2] TRUE, TRUE
[10:58:39.215] - queued futures: [n=2] TRUE, TRUE
[10:58:39.215] signalConditionsASAP(NULL, pos=0) ... done
[10:58:39.215] resolve() on list ... DONE
[10:58:39.216] result() for MulticoreFuture ...
[10:58:39.216] result() for MulticoreFuture ... done
[10:58:39.216] result() for MulticoreFuture ...
[10:58:39.216] result() for MulticoreFuture ... done
[10:58:39.216] result() for MulticoreFuture ...
[10:58:39.216] result() for MulticoreFuture ... done
[10:58:39.216] result() for MulticoreFuture ...
[10:58:39.216] result() for MulticoreFuture ... done
[10:58:39.216]  - Number of value chunks collected: 2
[10:58:39.217] Resolving 2 futures (chunks) ... DONE
[10:58:39.217] Reducing values from 2 chunks ...
[10:58:39.217]  - Number of values collected after concatenation: 2
[10:58:39.217]  - Number of values expected: 2
[10:58:39.217] Reducing values from 2 chunks ... DONE
[10:58:39.217] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:58:39.218] getGlobalsAndPackagesXApply() ...
[10:58:39.218]  - future.globals: TRUE
[10:58:39.218] getGlobalsAndPackages() ...
[10:58:39.218] Searching for globals...
[10:58:39.219] - globals found: [1] ‘FUN’
[10:58:39.220] Searching for globals ... DONE
[10:58:39.220] Resolving globals: FALSE
[10:58:39.222] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:39.222] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:39.223] - globals: [1] ‘FUN’
[10:58:39.223] 
[10:58:39.223] getGlobalsAndPackages() ... DONE
[10:58:39.223]  - globals found/used: [n=1] ‘FUN’
[10:58:39.223]  - needed namespaces: [n=0] 
[10:58:39.224] Finding globals ... DONE
[10:58:39.224]  - use_args: TRUE
[10:58:39.224]  - Getting '...' globals ...
[10:58:39.224] resolve() on list ...
[10:58:39.224]  recursive: 0
[10:58:39.225]  length: 1
[10:58:39.225]  elements: ‘...’
[10:58:39.225]  length: 0 (resolved future 1)
[10:58:39.225] resolve() on list ... DONE
[10:58:39.225]    - '...' content: [n=0] 
[10:58:39.225] List of 1
[10:58:39.225]  $ ...: list()
[10:58:39.225]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.225]  - attr(*, "where")=List of 1
[10:58:39.225]   ..$ ...:<environment: 0x5635bf735a60> 
[10:58:39.225]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.225]  - attr(*, "resolved")= logi TRUE
[10:58:39.225]  - attr(*, "total_size")= num NA
[10:58:39.228]  - Getting '...' globals ... DONE
[10:58:39.228] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:39.229] List of 2
[10:58:39.229]  $ ...future.FUN:function (x)  
[10:58:39.229]  $ ...          : list()
[10:58:39.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.229]  - attr(*, "where")=List of 2
[10:58:39.229]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:39.229]   ..$ ...          :<environment: 0x5635bf735a60> 
[10:58:39.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.229]  - attr(*, "resolved")= logi FALSE
[10:58:39.229]  - attr(*, "total_size")= num 2624
[10:58:39.232] Packages to be attached in all futures: [n=0] 
[10:58:39.232] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.233] future_lapply() ...
[10:58:39.235] Number of chunks: 2
[10:58:39.235] getGlobalsAndPackagesXApply() ...
[10:58:39.236]  - future.globals: <name-value list> with names ‘list()’
[10:58:39.236]  - use_args: TRUE
[10:58:39.236] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:39.236] List of 2
[10:58:39.236]  $ ...          : list()
[10:58:39.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.236]  $ ...future.FUN:function (x)  
[10:58:39.236]  - attr(*, "where")=List of 2
[10:58:39.236]   ..$ ...          :<environment: 0x5635bf735a60> 
[10:58:39.236]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:39.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.236]  - attr(*, "resolved")= logi FALSE
[10:58:39.236]  - attr(*, "total_size")= num NA
[10:58:39.239] Packages to be attached in all futures: [n=0] 
[10:58:39.239] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.239] Number of futures (= number of chunks): 2
[10:58:39.240] Launching 2 futures (chunks) ...
[10:58:39.240] Chunk #1 of 2 ...
[10:58:39.240]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.240]  - seeds: <none>
[10:58:39.240]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.240] getGlobalsAndPackages() ...
[10:58:39.240] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.240] Resolving globals: FALSE
[10:58:39.240] Tweak future expression to call with '...' arguments ...
[10:58:39.240] {
[10:58:39.240]     do.call(function(...) {
[10:58:39.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.240]             on.exit(options(oopts), add = TRUE)
[10:58:39.240]         }
[10:58:39.240]         {
[10:58:39.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.240]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.240]             })
[10:58:39.240]         }
[10:58:39.240]     }, args = future.call.arguments)
[10:58:39.240] }
[10:58:39.241] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.241] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.241] 
[10:58:39.241] getGlobalsAndPackages() ... DONE
[10:58:39.242] run() for ‘Future’ ...
[10:58:39.242] - state: ‘created’
[10:58:39.242] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.243] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.244]   - Field: ‘label’
[10:58:39.244]   - Field: ‘local’
[10:58:39.244]   - Field: ‘owner’
[10:58:39.244]   - Field: ‘envir’
[10:58:39.244]   - Field: ‘workers’
[10:58:39.244]   - Field: ‘packages’
[10:58:39.244]   - Field: ‘gc’
[10:58:39.244]   - Field: ‘job’
[10:58:39.244]   - Field: ‘conditions’
[10:58:39.244]   - Field: ‘expr’
[10:58:39.244]   - Field: ‘uuid’
[10:58:39.244]   - Field: ‘seed’
[10:58:39.245]   - Field: ‘version’
[10:58:39.245]   - Field: ‘result’
[10:58:39.245]   - Field: ‘asynchronous’
[10:58:39.245]   - Field: ‘calls’
[10:58:39.245]   - Field: ‘globals’
[10:58:39.245]   - Field: ‘stdout’
[10:58:39.245]   - Field: ‘earlySignal’
[10:58:39.245]   - Field: ‘lazy’
[10:58:39.245]   - Field: ‘state’
[10:58:39.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.245] - Launch lazy future ...
[10:58:39.246] Packages needed by the future expression (n = 0): <none>
[10:58:39.246] Packages needed by future strategies (n = 0): <none>
[10:58:39.246] {
[10:58:39.246]     {
[10:58:39.246]         {
[10:58:39.246]             ...future.startTime <- base::Sys.time()
[10:58:39.246]             {
[10:58:39.246]                 {
[10:58:39.246]                   {
[10:58:39.246]                     {
[10:58:39.246]                       base::local({
[10:58:39.246]                         has_future <- base::requireNamespace("future", 
[10:58:39.246]                           quietly = TRUE)
[10:58:39.246]                         if (has_future) {
[10:58:39.246]                           ns <- base::getNamespace("future")
[10:58:39.246]                           version <- ns[[".package"]][["version"]]
[10:58:39.246]                           if (is.null(version)) 
[10:58:39.246]                             version <- utils::packageVersion("future")
[10:58:39.246]                         }
[10:58:39.246]                         else {
[10:58:39.246]                           version <- NULL
[10:58:39.246]                         }
[10:58:39.246]                         if (!has_future || version < "1.8.0") {
[10:58:39.246]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.246]                             "", base::R.version$version.string), 
[10:58:39.246]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.246]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.246]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.246]                               "release", "version")], collapse = " "), 
[10:58:39.246]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.246]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.246]                             info)
[10:58:39.246]                           info <- base::paste(info, collapse = "; ")
[10:58:39.246]                           if (!has_future) {
[10:58:39.246]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.246]                               info)
[10:58:39.246]                           }
[10:58:39.246]                           else {
[10:58:39.246]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.246]                               info, version)
[10:58:39.246]                           }
[10:58:39.246]                           base::stop(msg)
[10:58:39.246]                         }
[10:58:39.246]                       })
[10:58:39.246]                     }
[10:58:39.246]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.246]                     base::options(mc.cores = 1L)
[10:58:39.246]                   }
[10:58:39.246]                   ...future.strategy.old <- future::plan("list")
[10:58:39.246]                   options(future.plan = NULL)
[10:58:39.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.246]                 }
[10:58:39.246]                 ...future.workdir <- getwd()
[10:58:39.246]             }
[10:58:39.246]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.246]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.246]         }
[10:58:39.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.246]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.246]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.246]             base::names(...future.oldOptions))
[10:58:39.246]     }
[10:58:39.246]     if (FALSE) {
[10:58:39.246]     }
[10:58:39.246]     else {
[10:58:39.246]         if (TRUE) {
[10:58:39.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.246]                 open = "w")
[10:58:39.246]         }
[10:58:39.246]         else {
[10:58:39.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.246]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.246]         }
[10:58:39.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.246]             base::sink(type = "output", split = FALSE)
[10:58:39.246]             base::close(...future.stdout)
[10:58:39.246]         }, add = TRUE)
[10:58:39.246]     }
[10:58:39.246]     ...future.frame <- base::sys.nframe()
[10:58:39.246]     ...future.conditions <- base::list()
[10:58:39.246]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.246]     if (FALSE) {
[10:58:39.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.246]     }
[10:58:39.246]     ...future.result <- base::tryCatch({
[10:58:39.246]         base::withCallingHandlers({
[10:58:39.246]             ...future.value <- base::withVisible(base::local({
[10:58:39.246]                 withCallingHandlers({
[10:58:39.246]                   {
[10:58:39.246]                     do.call(function(...) {
[10:58:39.246]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.246]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.246]                         ...future.globals.maxSize)) {
[10:58:39.246]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.246]                         on.exit(options(oopts), add = TRUE)
[10:58:39.246]                       }
[10:58:39.246]                       {
[10:58:39.246]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.246]                           FUN = function(jj) {
[10:58:39.246]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.246]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.246]                           })
[10:58:39.246]                       }
[10:58:39.246]                     }, args = future.call.arguments)
[10:58:39.246]                   }
[10:58:39.246]                 }, immediateCondition = function(cond) {
[10:58:39.246]                   save_rds <- function (object, pathname, ...) 
[10:58:39.246]                   {
[10:58:39.246]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.246]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.246]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.246]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.246]                         fi_tmp[["mtime"]])
[10:58:39.246]                     }
[10:58:39.246]                     tryCatch({
[10:58:39.246]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.246]                     }, error = function(ex) {
[10:58:39.246]                       msg <- conditionMessage(ex)
[10:58:39.246]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.246]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.246]                         fi_tmp[["mtime"]], msg)
[10:58:39.246]                       ex$message <- msg
[10:58:39.246]                       stop(ex)
[10:58:39.246]                     })
[10:58:39.246]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.246]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.246]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.246]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.246]                       fi <- file.info(pathname)
[10:58:39.246]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.246]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.246]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.246]                         fi[["size"]], fi[["mtime"]])
[10:58:39.246]                       stop(msg)
[10:58:39.246]                     }
[10:58:39.246]                     invisible(pathname)
[10:58:39.246]                   }
[10:58:39.246]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.246]                     rootPath = tempdir()) 
[10:58:39.246]                   {
[10:58:39.246]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.246]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.246]                       tmpdir = path, fileext = ".rds")
[10:58:39.246]                     save_rds(obj, file)
[10:58:39.246]                   }
[10:58:39.246]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.246]                   {
[10:58:39.246]                     inherits <- base::inherits
[10:58:39.246]                     invokeRestart <- base::invokeRestart
[10:58:39.246]                     is.null <- base::is.null
[10:58:39.246]                     muffled <- FALSE
[10:58:39.246]                     if (inherits(cond, "message")) {
[10:58:39.246]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.246]                       if (muffled) 
[10:58:39.246]                         invokeRestart("muffleMessage")
[10:58:39.246]                     }
[10:58:39.246]                     else if (inherits(cond, "warning")) {
[10:58:39.246]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.246]                       if (muffled) 
[10:58:39.246]                         invokeRestart("muffleWarning")
[10:58:39.246]                     }
[10:58:39.246]                     else if (inherits(cond, "condition")) {
[10:58:39.246]                       if (!is.null(pattern)) {
[10:58:39.246]                         computeRestarts <- base::computeRestarts
[10:58:39.246]                         grepl <- base::grepl
[10:58:39.246]                         restarts <- computeRestarts(cond)
[10:58:39.246]                         for (restart in restarts) {
[10:58:39.246]                           name <- restart$name
[10:58:39.246]                           if (is.null(name)) 
[10:58:39.246]                             next
[10:58:39.246]                           if (!grepl(pattern, name)) 
[10:58:39.246]                             next
[10:58:39.246]                           invokeRestart(restart)
[10:58:39.246]                           muffled <- TRUE
[10:58:39.246]                           break
[10:58:39.246]                         }
[10:58:39.246]                       }
[10:58:39.246]                     }
[10:58:39.246]                     invisible(muffled)
[10:58:39.246]                   }
[10:58:39.246]                   muffleCondition(cond)
[10:58:39.246]                 })
[10:58:39.246]             }))
[10:58:39.246]             future::FutureResult(value = ...future.value$value, 
[10:58:39.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.246]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.246]                     ...future.globalenv.names))
[10:58:39.246]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.246]         }, condition = base::local({
[10:58:39.246]             c <- base::c
[10:58:39.246]             inherits <- base::inherits
[10:58:39.246]             invokeRestart <- base::invokeRestart
[10:58:39.246]             length <- base::length
[10:58:39.246]             list <- base::list
[10:58:39.246]             seq.int <- base::seq.int
[10:58:39.246]             signalCondition <- base::signalCondition
[10:58:39.246]             sys.calls <- base::sys.calls
[10:58:39.246]             `[[` <- base::`[[`
[10:58:39.246]             `+` <- base::`+`
[10:58:39.246]             `<<-` <- base::`<<-`
[10:58:39.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.246]                   3L)]
[10:58:39.246]             }
[10:58:39.246]             function(cond) {
[10:58:39.246]                 is_error <- inherits(cond, "error")
[10:58:39.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.246]                   NULL)
[10:58:39.246]                 if (is_error) {
[10:58:39.246]                   sessionInformation <- function() {
[10:58:39.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.246]                       search = base::search(), system = base::Sys.info())
[10:58:39.246]                   }
[10:58:39.246]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.246]                     cond$call), session = sessionInformation(), 
[10:58:39.246]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.246]                   signalCondition(cond)
[10:58:39.246]                 }
[10:58:39.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.246]                 "immediateCondition"))) {
[10:58:39.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.246]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.246]                   if (TRUE && !signal) {
[10:58:39.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.246]                     {
[10:58:39.246]                       inherits <- base::inherits
[10:58:39.246]                       invokeRestart <- base::invokeRestart
[10:58:39.246]                       is.null <- base::is.null
[10:58:39.246]                       muffled <- FALSE
[10:58:39.246]                       if (inherits(cond, "message")) {
[10:58:39.246]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.246]                         if (muffled) 
[10:58:39.246]                           invokeRestart("muffleMessage")
[10:58:39.246]                       }
[10:58:39.246]                       else if (inherits(cond, "warning")) {
[10:58:39.246]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.246]                         if (muffled) 
[10:58:39.246]                           invokeRestart("muffleWarning")
[10:58:39.246]                       }
[10:58:39.246]                       else if (inherits(cond, "condition")) {
[10:58:39.246]                         if (!is.null(pattern)) {
[10:58:39.246]                           computeRestarts <- base::computeRestarts
[10:58:39.246]                           grepl <- base::grepl
[10:58:39.246]                           restarts <- computeRestarts(cond)
[10:58:39.246]                           for (restart in restarts) {
[10:58:39.246]                             name <- restart$name
[10:58:39.246]                             if (is.null(name)) 
[10:58:39.246]                               next
[10:58:39.246]                             if (!grepl(pattern, name)) 
[10:58:39.246]                               next
[10:58:39.246]                             invokeRestart(restart)
[10:58:39.246]                             muffled <- TRUE
[10:58:39.246]                             break
[10:58:39.246]                           }
[10:58:39.246]                         }
[10:58:39.246]                       }
[10:58:39.246]                       invisible(muffled)
[10:58:39.246]                     }
[10:58:39.246]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.246]                   }
[10:58:39.246]                 }
[10:58:39.246]                 else {
[10:58:39.246]                   if (TRUE) {
[10:58:39.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.246]                     {
[10:58:39.246]                       inherits <- base::inherits
[10:58:39.246]                       invokeRestart <- base::invokeRestart
[10:58:39.246]                       is.null <- base::is.null
[10:58:39.246]                       muffled <- FALSE
[10:58:39.246]                       if (inherits(cond, "message")) {
[10:58:39.246]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.246]                         if (muffled) 
[10:58:39.246]                           invokeRestart("muffleMessage")
[10:58:39.246]                       }
[10:58:39.246]                       else if (inherits(cond, "warning")) {
[10:58:39.246]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.246]                         if (muffled) 
[10:58:39.246]                           invokeRestart("muffleWarning")
[10:58:39.246]                       }
[10:58:39.246]                       else if (inherits(cond, "condition")) {
[10:58:39.246]                         if (!is.null(pattern)) {
[10:58:39.246]                           computeRestarts <- base::computeRestarts
[10:58:39.246]                           grepl <- base::grepl
[10:58:39.246]                           restarts <- computeRestarts(cond)
[10:58:39.246]                           for (restart in restarts) {
[10:58:39.246]                             name <- restart$name
[10:58:39.246]                             if (is.null(name)) 
[10:58:39.246]                               next
[10:58:39.246]                             if (!grepl(pattern, name)) 
[10:58:39.246]                               next
[10:58:39.246]                             invokeRestart(restart)
[10:58:39.246]                             muffled <- TRUE
[10:58:39.246]                             break
[10:58:39.246]                           }
[10:58:39.246]                         }
[10:58:39.246]                       }
[10:58:39.246]                       invisible(muffled)
[10:58:39.246]                     }
[10:58:39.246]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.246]                   }
[10:58:39.246]                 }
[10:58:39.246]             }
[10:58:39.246]         }))
[10:58:39.246]     }, error = function(ex) {
[10:58:39.246]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.246]                 ...future.rng), started = ...future.startTime, 
[10:58:39.246]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.246]             version = "1.8"), class = "FutureResult")
[10:58:39.246]     }, finally = {
[10:58:39.246]         if (!identical(...future.workdir, getwd())) 
[10:58:39.246]             setwd(...future.workdir)
[10:58:39.246]         {
[10:58:39.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.246]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.246]             }
[10:58:39.246]             base::options(...future.oldOptions)
[10:58:39.246]             if (.Platform$OS.type == "windows") {
[10:58:39.246]                 old_names <- names(...future.oldEnvVars)
[10:58:39.246]                 envs <- base::Sys.getenv()
[10:58:39.246]                 names <- names(envs)
[10:58:39.246]                 common <- intersect(names, old_names)
[10:58:39.246]                 added <- setdiff(names, old_names)
[10:58:39.246]                 removed <- setdiff(old_names, names)
[10:58:39.246]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.246]                   envs[common]]
[10:58:39.246]                 NAMES <- toupper(changed)
[10:58:39.246]                 args <- list()
[10:58:39.246]                 for (kk in seq_along(NAMES)) {
[10:58:39.246]                   name <- changed[[kk]]
[10:58:39.246]                   NAME <- NAMES[[kk]]
[10:58:39.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.246]                     next
[10:58:39.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.246]                 }
[10:58:39.246]                 NAMES <- toupper(added)
[10:58:39.246]                 for (kk in seq_along(NAMES)) {
[10:58:39.246]                   name <- added[[kk]]
[10:58:39.246]                   NAME <- NAMES[[kk]]
[10:58:39.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.246]                     next
[10:58:39.246]                   args[[name]] <- ""
[10:58:39.246]                 }
[10:58:39.246]                 NAMES <- toupper(removed)
[10:58:39.246]                 for (kk in seq_along(NAMES)) {
[10:58:39.246]                   name <- removed[[kk]]
[10:58:39.246]                   NAME <- NAMES[[kk]]
[10:58:39.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.246]                     next
[10:58:39.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.246]                 }
[10:58:39.246]                 if (length(args) > 0) 
[10:58:39.246]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.246]             }
[10:58:39.246]             else {
[10:58:39.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.246]             }
[10:58:39.246]             {
[10:58:39.246]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.246]                   0L) {
[10:58:39.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.246]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.246]                   base::options(opts)
[10:58:39.246]                 }
[10:58:39.246]                 {
[10:58:39.246]                   {
[10:58:39.246]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.246]                     NULL
[10:58:39.246]                   }
[10:58:39.246]                   options(future.plan = NULL)
[10:58:39.246]                   if (is.na(NA_character_)) 
[10:58:39.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.246]                     .init = FALSE)
[10:58:39.246]                 }
[10:58:39.246]             }
[10:58:39.246]         }
[10:58:39.246]     })
[10:58:39.246]     if (TRUE) {
[10:58:39.246]         base::sink(type = "output", split = FALSE)
[10:58:39.246]         if (TRUE) {
[10:58:39.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.246]         }
[10:58:39.246]         else {
[10:58:39.246]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.246]         }
[10:58:39.246]         base::close(...future.stdout)
[10:58:39.246]         ...future.stdout <- NULL
[10:58:39.246]     }
[10:58:39.246]     ...future.result$conditions <- ...future.conditions
[10:58:39.246]     ...future.result$finished <- base::Sys.time()
[10:58:39.246]     ...future.result
[10:58:39.246] }
[10:58:39.248] assign_globals() ...
[10:58:39.249] List of 5
[10:58:39.249]  $ future.call.arguments    : list()
[10:58:39.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.249]  $ ...future.FUN            :function (x)  
[10:58:39.249]  $ ...future.elements_ii    :List of 1
[10:58:39.249]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:58:39.249]  $ ...future.seeds_ii       : NULL
[10:58:39.249]  $ ...future.globals.maxSize: num Inf
[10:58:39.249]  - attr(*, "resolved")= logi FALSE
[10:58:39.249]  - attr(*, "total_size")= num NA
[10:58:39.249]  - attr(*, "where")=List of 5
[10:58:39.249]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.249]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.249]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.249]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.249]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.249]  - attr(*, "already-done")= logi TRUE
[10:58:39.254] - copied ‘future.call.arguments’ to environment
[10:58:39.254] - copied ‘...future.FUN’ to environment
[10:58:39.254] - copied ‘...future.elements_ii’ to environment
[10:58:39.254] - copied ‘...future.seeds_ii’ to environment
[10:58:39.255] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.255] assign_globals() ... done
[10:58:39.255] requestCore(): workers = 2
[10:58:39.257] MulticoreFuture started
[10:58:39.257] - Launch lazy future ... done
[10:58:39.257] run() for ‘MulticoreFuture’ ... done
[10:58:39.258] Created future:
[10:58:39.258] plan(): Setting new future strategy stack:
[10:58:39.258] List of future strategies:
[10:58:39.258] 1. sequential:
[10:58:39.258]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.258]    - tweaked: FALSE
[10:58:39.258]    - call: NULL
[10:58:39.259] plan(): nbrOfWorkers() = 1
[10:58:39.261] plan(): Setting new future strategy stack:
[10:58:39.261] List of future strategies:
[10:58:39.261] 1. multicore:
[10:58:39.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.261]    - tweaked: FALSE
[10:58:39.261]    - call: plan(strategy)
[10:58:39.264] plan(): nbrOfWorkers() = 2
[10:58:39.258] MulticoreFuture:
[10:58:39.258] Label: ‘future_apply-1’
[10:58:39.258] Expression:
[10:58:39.258] {
[10:58:39.258]     do.call(function(...) {
[10:58:39.258]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.258]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.258]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.258]             on.exit(options(oopts), add = TRUE)
[10:58:39.258]         }
[10:58:39.258]         {
[10:58:39.258]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.258]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.258]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.258]             })
[10:58:39.258]         }
[10:58:39.258]     }, args = future.call.arguments)
[10:58:39.258] }
[10:58:39.258] Lazy evaluation: FALSE
[10:58:39.258] Asynchronous evaluation: TRUE
[10:58:39.258] Local evaluation: TRUE
[10:58:39.258] Environment: R_GlobalEnv
[10:58:39.258] Capture standard output: TRUE
[10:58:39.258] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.258] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.258] Packages: <none>
[10:58:39.258] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.258] Resolved: TRUE
[10:58:39.258] Value: <not collected>
[10:58:39.258] Conditions captured: <none>
[10:58:39.258] Early signaling: FALSE
[10:58:39.258] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.258] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.265] Chunk #1 of 2 ... DONE
[10:58:39.265] Chunk #2 of 2 ...
[10:58:39.266]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.266]  - seeds: <none>
[10:58:39.266]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.266] getGlobalsAndPackages() ...
[10:58:39.266] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.266] Resolving globals: FALSE
[10:58:39.266] Tweak future expression to call with '...' arguments ...
[10:58:39.267] {
[10:58:39.267]     do.call(function(...) {
[10:58:39.267]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.267]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.267]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.267]             on.exit(options(oopts), add = TRUE)
[10:58:39.267]         }
[10:58:39.267]         {
[10:58:39.267]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.267]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.267]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.267]             })
[10:58:39.267]         }
[10:58:39.267]     }, args = future.call.arguments)
[10:58:39.267] }
[10:58:39.267] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.268] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.268] 
[10:58:39.268] getGlobalsAndPackages() ... DONE
[10:58:39.269] run() for ‘Future’ ...
[10:58:39.269] - state: ‘created’
[10:58:39.269] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.272] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.272] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.272]   - Field: ‘label’
[10:58:39.272]   - Field: ‘local’
[10:58:39.272]   - Field: ‘owner’
[10:58:39.272]   - Field: ‘envir’
[10:58:39.273]   - Field: ‘workers’
[10:58:39.273]   - Field: ‘packages’
[10:58:39.273]   - Field: ‘gc’
[10:58:39.273]   - Field: ‘job’
[10:58:39.273]   - Field: ‘conditions’
[10:58:39.273]   - Field: ‘expr’
[10:58:39.274]   - Field: ‘uuid’
[10:58:39.274]   - Field: ‘seed’
[10:58:39.274]   - Field: ‘version’
[10:58:39.274]   - Field: ‘result’
[10:58:39.274]   - Field: ‘asynchronous’
[10:58:39.274]   - Field: ‘calls’
[10:58:39.274]   - Field: ‘globals’
[10:58:39.274]   - Field: ‘stdout’
[10:58:39.275]   - Field: ‘earlySignal’
[10:58:39.275]   - Field: ‘lazy’
[10:58:39.275]   - Field: ‘state’
[10:58:39.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.275] - Launch lazy future ...
[10:58:39.276] Packages needed by the future expression (n = 0): <none>
[10:58:39.276] Packages needed by future strategies (n = 0): <none>
[10:58:39.276] {
[10:58:39.276]     {
[10:58:39.276]         {
[10:58:39.276]             ...future.startTime <- base::Sys.time()
[10:58:39.276]             {
[10:58:39.276]                 {
[10:58:39.276]                   {
[10:58:39.276]                     {
[10:58:39.276]                       base::local({
[10:58:39.276]                         has_future <- base::requireNamespace("future", 
[10:58:39.276]                           quietly = TRUE)
[10:58:39.276]                         if (has_future) {
[10:58:39.276]                           ns <- base::getNamespace("future")
[10:58:39.276]                           version <- ns[[".package"]][["version"]]
[10:58:39.276]                           if (is.null(version)) 
[10:58:39.276]                             version <- utils::packageVersion("future")
[10:58:39.276]                         }
[10:58:39.276]                         else {
[10:58:39.276]                           version <- NULL
[10:58:39.276]                         }
[10:58:39.276]                         if (!has_future || version < "1.8.0") {
[10:58:39.276]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.276]                             "", base::R.version$version.string), 
[10:58:39.276]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.276]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.276]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.276]                               "release", "version")], collapse = " "), 
[10:58:39.276]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.276]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.276]                             info)
[10:58:39.276]                           info <- base::paste(info, collapse = "; ")
[10:58:39.276]                           if (!has_future) {
[10:58:39.276]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.276]                               info)
[10:58:39.276]                           }
[10:58:39.276]                           else {
[10:58:39.276]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.276]                               info, version)
[10:58:39.276]                           }
[10:58:39.276]                           base::stop(msg)
[10:58:39.276]                         }
[10:58:39.276]                       })
[10:58:39.276]                     }
[10:58:39.276]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.276]                     base::options(mc.cores = 1L)
[10:58:39.276]                   }
[10:58:39.276]                   ...future.strategy.old <- future::plan("list")
[10:58:39.276]                   options(future.plan = NULL)
[10:58:39.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.276]                 }
[10:58:39.276]                 ...future.workdir <- getwd()
[10:58:39.276]             }
[10:58:39.276]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.276]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.276]         }
[10:58:39.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.276]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.276]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.276]             base::names(...future.oldOptions))
[10:58:39.276]     }
[10:58:39.276]     if (FALSE) {
[10:58:39.276]     }
[10:58:39.276]     else {
[10:58:39.276]         if (TRUE) {
[10:58:39.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.276]                 open = "w")
[10:58:39.276]         }
[10:58:39.276]         else {
[10:58:39.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.276]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.276]         }
[10:58:39.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.276]             base::sink(type = "output", split = FALSE)
[10:58:39.276]             base::close(...future.stdout)
[10:58:39.276]         }, add = TRUE)
[10:58:39.276]     }
[10:58:39.276]     ...future.frame <- base::sys.nframe()
[10:58:39.276]     ...future.conditions <- base::list()
[10:58:39.276]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.276]     if (FALSE) {
[10:58:39.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.276]     }
[10:58:39.276]     ...future.result <- base::tryCatch({
[10:58:39.276]         base::withCallingHandlers({
[10:58:39.276]             ...future.value <- base::withVisible(base::local({
[10:58:39.276]                 withCallingHandlers({
[10:58:39.276]                   {
[10:58:39.276]                     do.call(function(...) {
[10:58:39.276]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.276]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.276]                         ...future.globals.maxSize)) {
[10:58:39.276]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.276]                         on.exit(options(oopts), add = TRUE)
[10:58:39.276]                       }
[10:58:39.276]                       {
[10:58:39.276]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.276]                           FUN = function(jj) {
[10:58:39.276]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.276]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.276]                           })
[10:58:39.276]                       }
[10:58:39.276]                     }, args = future.call.arguments)
[10:58:39.276]                   }
[10:58:39.276]                 }, immediateCondition = function(cond) {
[10:58:39.276]                   save_rds <- function (object, pathname, ...) 
[10:58:39.276]                   {
[10:58:39.276]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.276]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.276]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.276]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.276]                         fi_tmp[["mtime"]])
[10:58:39.276]                     }
[10:58:39.276]                     tryCatch({
[10:58:39.276]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.276]                     }, error = function(ex) {
[10:58:39.276]                       msg <- conditionMessage(ex)
[10:58:39.276]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.276]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.276]                         fi_tmp[["mtime"]], msg)
[10:58:39.276]                       ex$message <- msg
[10:58:39.276]                       stop(ex)
[10:58:39.276]                     })
[10:58:39.276]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.276]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.276]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.276]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.276]                       fi <- file.info(pathname)
[10:58:39.276]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.276]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.276]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.276]                         fi[["size"]], fi[["mtime"]])
[10:58:39.276]                       stop(msg)
[10:58:39.276]                     }
[10:58:39.276]                     invisible(pathname)
[10:58:39.276]                   }
[10:58:39.276]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.276]                     rootPath = tempdir()) 
[10:58:39.276]                   {
[10:58:39.276]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.276]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.276]                       tmpdir = path, fileext = ".rds")
[10:58:39.276]                     save_rds(obj, file)
[10:58:39.276]                   }
[10:58:39.276]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.276]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.276]                   {
[10:58:39.276]                     inherits <- base::inherits
[10:58:39.276]                     invokeRestart <- base::invokeRestart
[10:58:39.276]                     is.null <- base::is.null
[10:58:39.276]                     muffled <- FALSE
[10:58:39.276]                     if (inherits(cond, "message")) {
[10:58:39.276]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.276]                       if (muffled) 
[10:58:39.276]                         invokeRestart("muffleMessage")
[10:58:39.276]                     }
[10:58:39.276]                     else if (inherits(cond, "warning")) {
[10:58:39.276]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.276]                       if (muffled) 
[10:58:39.276]                         invokeRestart("muffleWarning")
[10:58:39.276]                     }
[10:58:39.276]                     else if (inherits(cond, "condition")) {
[10:58:39.276]                       if (!is.null(pattern)) {
[10:58:39.276]                         computeRestarts <- base::computeRestarts
[10:58:39.276]                         grepl <- base::grepl
[10:58:39.276]                         restarts <- computeRestarts(cond)
[10:58:39.276]                         for (restart in restarts) {
[10:58:39.276]                           name <- restart$name
[10:58:39.276]                           if (is.null(name)) 
[10:58:39.276]                             next
[10:58:39.276]                           if (!grepl(pattern, name)) 
[10:58:39.276]                             next
[10:58:39.276]                           invokeRestart(restart)
[10:58:39.276]                           muffled <- TRUE
[10:58:39.276]                           break
[10:58:39.276]                         }
[10:58:39.276]                       }
[10:58:39.276]                     }
[10:58:39.276]                     invisible(muffled)
[10:58:39.276]                   }
[10:58:39.276]                   muffleCondition(cond)
[10:58:39.276]                 })
[10:58:39.276]             }))
[10:58:39.276]             future::FutureResult(value = ...future.value$value, 
[10:58:39.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.276]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.276]                     ...future.globalenv.names))
[10:58:39.276]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.276]         }, condition = base::local({
[10:58:39.276]             c <- base::c
[10:58:39.276]             inherits <- base::inherits
[10:58:39.276]             invokeRestart <- base::invokeRestart
[10:58:39.276]             length <- base::length
[10:58:39.276]             list <- base::list
[10:58:39.276]             seq.int <- base::seq.int
[10:58:39.276]             signalCondition <- base::signalCondition
[10:58:39.276]             sys.calls <- base::sys.calls
[10:58:39.276]             `[[` <- base::`[[`
[10:58:39.276]             `+` <- base::`+`
[10:58:39.276]             `<<-` <- base::`<<-`
[10:58:39.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.276]                   3L)]
[10:58:39.276]             }
[10:58:39.276]             function(cond) {
[10:58:39.276]                 is_error <- inherits(cond, "error")
[10:58:39.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.276]                   NULL)
[10:58:39.276]                 if (is_error) {
[10:58:39.276]                   sessionInformation <- function() {
[10:58:39.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.276]                       search = base::search(), system = base::Sys.info())
[10:58:39.276]                   }
[10:58:39.276]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.276]                     cond$call), session = sessionInformation(), 
[10:58:39.276]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.276]                   signalCondition(cond)
[10:58:39.276]                 }
[10:58:39.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.276]                 "immediateCondition"))) {
[10:58:39.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.276]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.276]                   if (TRUE && !signal) {
[10:58:39.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.276]                     {
[10:58:39.276]                       inherits <- base::inherits
[10:58:39.276]                       invokeRestart <- base::invokeRestart
[10:58:39.276]                       is.null <- base::is.null
[10:58:39.276]                       muffled <- FALSE
[10:58:39.276]                       if (inherits(cond, "message")) {
[10:58:39.276]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.276]                         if (muffled) 
[10:58:39.276]                           invokeRestart("muffleMessage")
[10:58:39.276]                       }
[10:58:39.276]                       else if (inherits(cond, "warning")) {
[10:58:39.276]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.276]                         if (muffled) 
[10:58:39.276]                           invokeRestart("muffleWarning")
[10:58:39.276]                       }
[10:58:39.276]                       else if (inherits(cond, "condition")) {
[10:58:39.276]                         if (!is.null(pattern)) {
[10:58:39.276]                           computeRestarts <- base::computeRestarts
[10:58:39.276]                           grepl <- base::grepl
[10:58:39.276]                           restarts <- computeRestarts(cond)
[10:58:39.276]                           for (restart in restarts) {
[10:58:39.276]                             name <- restart$name
[10:58:39.276]                             if (is.null(name)) 
[10:58:39.276]                               next
[10:58:39.276]                             if (!grepl(pattern, name)) 
[10:58:39.276]                               next
[10:58:39.276]                             invokeRestart(restart)
[10:58:39.276]                             muffled <- TRUE
[10:58:39.276]                             break
[10:58:39.276]                           }
[10:58:39.276]                         }
[10:58:39.276]                       }
[10:58:39.276]                       invisible(muffled)
[10:58:39.276]                     }
[10:58:39.276]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.276]                   }
[10:58:39.276]                 }
[10:58:39.276]                 else {
[10:58:39.276]                   if (TRUE) {
[10:58:39.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.276]                     {
[10:58:39.276]                       inherits <- base::inherits
[10:58:39.276]                       invokeRestart <- base::invokeRestart
[10:58:39.276]                       is.null <- base::is.null
[10:58:39.276]                       muffled <- FALSE
[10:58:39.276]                       if (inherits(cond, "message")) {
[10:58:39.276]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.276]                         if (muffled) 
[10:58:39.276]                           invokeRestart("muffleMessage")
[10:58:39.276]                       }
[10:58:39.276]                       else if (inherits(cond, "warning")) {
[10:58:39.276]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.276]                         if (muffled) 
[10:58:39.276]                           invokeRestart("muffleWarning")
[10:58:39.276]                       }
[10:58:39.276]                       else if (inherits(cond, "condition")) {
[10:58:39.276]                         if (!is.null(pattern)) {
[10:58:39.276]                           computeRestarts <- base::computeRestarts
[10:58:39.276]                           grepl <- base::grepl
[10:58:39.276]                           restarts <- computeRestarts(cond)
[10:58:39.276]                           for (restart in restarts) {
[10:58:39.276]                             name <- restart$name
[10:58:39.276]                             if (is.null(name)) 
[10:58:39.276]                               next
[10:58:39.276]                             if (!grepl(pattern, name)) 
[10:58:39.276]                               next
[10:58:39.276]                             invokeRestart(restart)
[10:58:39.276]                             muffled <- TRUE
[10:58:39.276]                             break
[10:58:39.276]                           }
[10:58:39.276]                         }
[10:58:39.276]                       }
[10:58:39.276]                       invisible(muffled)
[10:58:39.276]                     }
[10:58:39.276]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.276]                   }
[10:58:39.276]                 }
[10:58:39.276]             }
[10:58:39.276]         }))
[10:58:39.276]     }, error = function(ex) {
[10:58:39.276]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.276]                 ...future.rng), started = ...future.startTime, 
[10:58:39.276]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.276]             version = "1.8"), class = "FutureResult")
[10:58:39.276]     }, finally = {
[10:58:39.276]         if (!identical(...future.workdir, getwd())) 
[10:58:39.276]             setwd(...future.workdir)
[10:58:39.276]         {
[10:58:39.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.276]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.276]             }
[10:58:39.276]             base::options(...future.oldOptions)
[10:58:39.276]             if (.Platform$OS.type == "windows") {
[10:58:39.276]                 old_names <- names(...future.oldEnvVars)
[10:58:39.276]                 envs <- base::Sys.getenv()
[10:58:39.276]                 names <- names(envs)
[10:58:39.276]                 common <- intersect(names, old_names)
[10:58:39.276]                 added <- setdiff(names, old_names)
[10:58:39.276]                 removed <- setdiff(old_names, names)
[10:58:39.276]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.276]                   envs[common]]
[10:58:39.276]                 NAMES <- toupper(changed)
[10:58:39.276]                 args <- list()
[10:58:39.276]                 for (kk in seq_along(NAMES)) {
[10:58:39.276]                   name <- changed[[kk]]
[10:58:39.276]                   NAME <- NAMES[[kk]]
[10:58:39.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.276]                     next
[10:58:39.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.276]                 }
[10:58:39.276]                 NAMES <- toupper(added)
[10:58:39.276]                 for (kk in seq_along(NAMES)) {
[10:58:39.276]                   name <- added[[kk]]
[10:58:39.276]                   NAME <- NAMES[[kk]]
[10:58:39.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.276]                     next
[10:58:39.276]                   args[[name]] <- ""
[10:58:39.276]                 }
[10:58:39.276]                 NAMES <- toupper(removed)
[10:58:39.276]                 for (kk in seq_along(NAMES)) {
[10:58:39.276]                   name <- removed[[kk]]
[10:58:39.276]                   NAME <- NAMES[[kk]]
[10:58:39.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.276]                     next
[10:58:39.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.276]                 }
[10:58:39.276]                 if (length(args) > 0) 
[10:58:39.276]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.276]             }
[10:58:39.276]             else {
[10:58:39.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.276]             }
[10:58:39.276]             {
[10:58:39.276]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.276]                   0L) {
[10:58:39.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.276]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.276]                   base::options(opts)
[10:58:39.276]                 }
[10:58:39.276]                 {
[10:58:39.276]                   {
[10:58:39.276]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.276]                     NULL
[10:58:39.276]                   }
[10:58:39.276]                   options(future.plan = NULL)
[10:58:39.276]                   if (is.na(NA_character_)) 
[10:58:39.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.276]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.276]                     .init = FALSE)
[10:58:39.276]                 }
[10:58:39.276]             }
[10:58:39.276]         }
[10:58:39.276]     })
[10:58:39.276]     if (TRUE) {
[10:58:39.276]         base::sink(type = "output", split = FALSE)
[10:58:39.276]         if (TRUE) {
[10:58:39.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.276]         }
[10:58:39.276]         else {
[10:58:39.276]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.276]         }
[10:58:39.276]         base::close(...future.stdout)
[10:58:39.276]         ...future.stdout <- NULL
[10:58:39.276]     }
[10:58:39.276]     ...future.result$conditions <- ...future.conditions
[10:58:39.276]     ...future.result$finished <- base::Sys.time()
[10:58:39.276]     ...future.result
[10:58:39.276] }
[10:58:39.280] assign_globals() ...
[10:58:39.280] List of 5
[10:58:39.280]  $ future.call.arguments    : list()
[10:58:39.280]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.280]  $ ...future.FUN            :function (x)  
[10:58:39.280]  $ ...future.elements_ii    :List of 1
[10:58:39.280]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:58:39.280]  $ ...future.seeds_ii       : NULL
[10:58:39.280]  $ ...future.globals.maxSize: num Inf
[10:58:39.280]  - attr(*, "resolved")= logi FALSE
[10:58:39.280]  - attr(*, "total_size")= num NA
[10:58:39.280]  - attr(*, "where")=List of 5
[10:58:39.280]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.280]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.280]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.280]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.280]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.280]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.280]  - attr(*, "already-done")= logi TRUE
[10:58:39.288] - copied ‘future.call.arguments’ to environment
[10:58:39.288] - copied ‘...future.FUN’ to environment
[10:58:39.288] - copied ‘...future.elements_ii’ to environment
[10:58:39.288] - copied ‘...future.seeds_ii’ to environment
[10:58:39.288] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.288] assign_globals() ... done
[10:58:39.288] requestCore(): workers = 2
[10:58:39.290] MulticoreFuture started
[10:58:39.291] - Launch lazy future ... done
[10:58:39.291] run() for ‘MulticoreFuture’ ... done
[10:58:39.291] Created future:
[10:58:39.291] plan(): Setting new future strategy stack:
[10:58:39.292] List of future strategies:
[10:58:39.292] 1. sequential:
[10:58:39.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.292]    - tweaked: FALSE
[10:58:39.292]    - call: NULL
[10:58:39.293] plan(): nbrOfWorkers() = 1
[10:58:39.298] plan(): Setting new future strategy stack:
[10:58:39.299] List of future strategies:
[10:58:39.299] 1. multicore:
[10:58:39.299]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.299]    - tweaked: FALSE
[10:58:39.299]    - call: plan(strategy)
[10:58:39.303] plan(): nbrOfWorkers() = 2
[10:58:39.291] MulticoreFuture:
[10:58:39.291] Label: ‘future_apply-2’
[10:58:39.291] Expression:
[10:58:39.291] {
[10:58:39.291]     do.call(function(...) {
[10:58:39.291]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.291]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.291]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.291]             on.exit(options(oopts), add = TRUE)
[10:58:39.291]         }
[10:58:39.291]         {
[10:58:39.291]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.291]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.291]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.291]             })
[10:58:39.291]         }
[10:58:39.291]     }, args = future.call.arguments)
[10:58:39.291] }
[10:58:39.291] Lazy evaluation: FALSE
[10:58:39.291] Asynchronous evaluation: TRUE
[10:58:39.291] Local evaluation: TRUE
[10:58:39.291] Environment: R_GlobalEnv
[10:58:39.291] Capture standard output: TRUE
[10:58:39.291] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.291] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.291] Packages: <none>
[10:58:39.291] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.291] Resolved: TRUE
[10:58:39.291] Value: <not collected>
[10:58:39.291] Conditions captured: <none>
[10:58:39.291] Early signaling: FALSE
[10:58:39.291] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.291] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.305] Chunk #2 of 2 ... DONE
[10:58:39.305] Launching 2 futures (chunks) ... DONE
[10:58:39.305] Resolving 2 futures (chunks) ...
[10:58:39.306] resolve() on list ...
[10:58:39.306]  recursive: 0
[10:58:39.306]  length: 2
[10:58:39.307] 
[10:58:39.307] Future #1
[10:58:39.307] result() for MulticoreFuture ...
[10:58:39.309] result() for MulticoreFuture ...
[10:58:39.309] result() for MulticoreFuture ... done
[10:58:39.309] result() for MulticoreFuture ... done
[10:58:39.309] result() for MulticoreFuture ...
[10:58:39.310] result() for MulticoreFuture ... done
[10:58:39.310] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:39.310] - nx: 2
[10:58:39.310] - relay: TRUE
[10:58:39.311] - stdout: TRUE
[10:58:39.311] - signal: TRUE
[10:58:39.311] - resignal: FALSE
[10:58:39.311] - force: TRUE
[10:58:39.312] - relayed: [n=2] FALSE, FALSE
[10:58:39.312] - queued futures: [n=2] FALSE, FALSE
[10:58:39.312]  - until=1
[10:58:39.312]  - relaying element #1
[10:58:39.312] result() for MulticoreFuture ...
[10:58:39.313] result() for MulticoreFuture ... done
[10:58:39.313] result() for MulticoreFuture ...
[10:58:39.313] result() for MulticoreFuture ... done
[10:58:39.313] result() for MulticoreFuture ...
[10:58:39.313] result() for MulticoreFuture ... done
[10:58:39.313] result() for MulticoreFuture ...
[10:58:39.313] result() for MulticoreFuture ... done
[10:58:39.313] - relayed: [n=2] TRUE, FALSE
[10:58:39.314] - queued futures: [n=2] TRUE, FALSE
[10:58:39.314] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:39.314]  length: 1 (resolved future 1)
[10:58:39.314] Future #2
[10:58:39.314] result() for MulticoreFuture ...
[10:58:39.315] result() for MulticoreFuture ...
[10:58:39.315] result() for MulticoreFuture ... done
[10:58:39.315] result() for MulticoreFuture ... done
[10:58:39.315] result() for MulticoreFuture ...
[10:58:39.316] result() for MulticoreFuture ... done
[10:58:39.316] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:39.316] - nx: 2
[10:58:39.316] - relay: TRUE
[10:58:39.316] - stdout: TRUE
[10:58:39.316] - signal: TRUE
[10:58:39.316] - resignal: FALSE
[10:58:39.316] - force: TRUE
[10:58:39.317] - relayed: [n=2] TRUE, FALSE
[10:58:39.317] - queued futures: [n=2] TRUE, FALSE
[10:58:39.317]  - until=2
[10:58:39.317]  - relaying element #2
[10:58:39.317] result() for MulticoreFuture ...
[10:58:39.317] result() for MulticoreFuture ... done
[10:58:39.317] result() for MulticoreFuture ...
[10:58:39.317] result() for MulticoreFuture ... done
[10:58:39.317] result() for MulticoreFuture ...
[10:58:39.318] result() for MulticoreFuture ... done
[10:58:39.318] result() for MulticoreFuture ...
[10:58:39.318] result() for MulticoreFuture ... done
[10:58:39.318] - relayed: [n=2] TRUE, TRUE
[10:58:39.318] - queued futures: [n=2] TRUE, TRUE
[10:58:39.318] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:39.318]  length: 0 (resolved future 2)
[10:58:39.318] Relaying remaining futures
[10:58:39.318] signalConditionsASAP(NULL, pos=0) ...
[10:58:39.318] - nx: 2
[10:58:39.319] - relay: TRUE
[10:58:39.319] - stdout: TRUE
[10:58:39.319] - signal: TRUE
[10:58:39.319] - resignal: FALSE
[10:58:39.319] - force: TRUE
[10:58:39.319] - relayed: [n=2] TRUE, TRUE
[10:58:39.319] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:39.319] - relayed: [n=2] TRUE, TRUE
[10:58:39.319] - queued futures: [n=2] TRUE, TRUE
[10:58:39.319] signalConditionsASAP(NULL, pos=0) ... done
[10:58:39.320] resolve() on list ... DONE
[10:58:39.320] result() for MulticoreFuture ...
[10:58:39.320] result() for MulticoreFuture ... done
[10:58:39.320] result() for MulticoreFuture ...
[10:58:39.320] result() for MulticoreFuture ... done
[10:58:39.320] result() for MulticoreFuture ...
[10:58:39.320] result() for MulticoreFuture ... done
[10:58:39.320] result() for MulticoreFuture ...
[10:58:39.320] result() for MulticoreFuture ... done
[10:58:39.321]  - Number of value chunks collected: 2
[10:58:39.321] Resolving 2 futures (chunks) ... DONE
[10:58:39.321] Reducing values from 2 chunks ...
[10:58:39.321]  - Number of values collected after concatenation: 2
[10:58:39.321]  - Number of values expected: 2
[10:58:39.321] Reducing values from 2 chunks ... DONE
[10:58:39.321] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:58:39.321] getGlobalsAndPackagesXApply() ...
[10:58:39.322]  - future.globals: TRUE
[10:58:39.322] getGlobalsAndPackages() ...
[10:58:39.322] Searching for globals...
[10:58:39.323] - globals found: [1] ‘FUN’
[10:58:39.323] Searching for globals ... DONE
[10:58:39.323] Resolving globals: FALSE
[10:58:39.324] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:39.324] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:39.324] - globals: [1] ‘FUN’
[10:58:39.324] 
[10:58:39.324] getGlobalsAndPackages() ... DONE
[10:58:39.325]  - globals found/used: [n=1] ‘FUN’
[10:58:39.325]  - needed namespaces: [n=0] 
[10:58:39.325] Finding globals ... DONE
[10:58:39.325]  - use_args: TRUE
[10:58:39.325]  - Getting '...' globals ...
[10:58:39.325] resolve() on list ...
[10:58:39.325]  recursive: 0
[10:58:39.325]  length: 1
[10:58:39.326]  elements: ‘...’
[10:58:39.326]  length: 0 (resolved future 1)
[10:58:39.326] resolve() on list ... DONE
[10:58:39.326]    - '...' content: [n=0] 
[10:58:39.326] List of 1
[10:58:39.326]  $ ...: list()
[10:58:39.326]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.326]  - attr(*, "where")=List of 1
[10:58:39.326]   ..$ ...:<environment: 0x5635beba7ba0> 
[10:58:39.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.326]  - attr(*, "resolved")= logi TRUE
[10:58:39.326]  - attr(*, "total_size")= num NA
[10:58:39.329]  - Getting '...' globals ... DONE
[10:58:39.329] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:39.329] List of 2
[10:58:39.329]  $ ...future.FUN:function (x)  
[10:58:39.329]  $ ...          : list()
[10:58:39.329]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.329]  - attr(*, "where")=List of 2
[10:58:39.329]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:39.329]   ..$ ...          :<environment: 0x5635beba7ba0> 
[10:58:39.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.329]  - attr(*, "resolved")= logi FALSE
[10:58:39.329]  - attr(*, "total_size")= num 3563
[10:58:39.332] Packages to be attached in all futures: [n=0] 
[10:58:39.332] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.335] future_lapply() ...
[10:58:39.337] Number of chunks: 2
[10:58:39.337] getGlobalsAndPackagesXApply() ...
[10:58:39.337]  - future.globals: <name-value list> with names ‘list()’
[10:58:39.337]  - use_args: TRUE
[10:58:39.338] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:39.338] List of 2
[10:58:39.338]  $ ...          : list()
[10:58:39.338]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.338]  $ ...future.FUN:function (x)  
[10:58:39.338]  - attr(*, "where")=List of 2
[10:58:39.338]   ..$ ...          :<environment: 0x5635beba7ba0> 
[10:58:39.338]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:39.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.338]  - attr(*, "resolved")= logi FALSE
[10:58:39.338]  - attr(*, "total_size")= num NA
[10:58:39.341] Packages to be attached in all futures: [n=0] 
[10:58:39.341] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.341] Number of futures (= number of chunks): 2
[10:58:39.341] Launching 2 futures (chunks) ...
[10:58:39.341] Chunk #1 of 2 ...
[10:58:39.341]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.341]  - seeds: <none>
[10:58:39.341]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.342] getGlobalsAndPackages() ...
[10:58:39.342] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.342] Resolving globals: FALSE
[10:58:39.342] Tweak future expression to call with '...' arguments ...
[10:58:39.342] {
[10:58:39.342]     do.call(function(...) {
[10:58:39.342]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.342]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.342]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.342]             on.exit(options(oopts), add = TRUE)
[10:58:39.342]         }
[10:58:39.342]         {
[10:58:39.342]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.342]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.342]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.342]             })
[10:58:39.342]         }
[10:58:39.342]     }, args = future.call.arguments)
[10:58:39.342] }
[10:58:39.342] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.343] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.343] 
[10:58:39.343] getGlobalsAndPackages() ... DONE
[10:58:39.343] run() for ‘Future’ ...
[10:58:39.343] - state: ‘created’
[10:58:39.343] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.345] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.345]   - Field: ‘label’
[10:58:39.345]   - Field: ‘local’
[10:58:39.345]   - Field: ‘owner’
[10:58:39.345]   - Field: ‘envir’
[10:58:39.345]   - Field: ‘workers’
[10:58:39.346]   - Field: ‘packages’
[10:58:39.346]   - Field: ‘gc’
[10:58:39.346]   - Field: ‘job’
[10:58:39.346]   - Field: ‘conditions’
[10:58:39.346]   - Field: ‘expr’
[10:58:39.346]   - Field: ‘uuid’
[10:58:39.346]   - Field: ‘seed’
[10:58:39.346]   - Field: ‘version’
[10:58:39.346]   - Field: ‘result’
[10:58:39.346]   - Field: ‘asynchronous’
[10:58:39.346]   - Field: ‘calls’
[10:58:39.346]   - Field: ‘globals’
[10:58:39.347]   - Field: ‘stdout’
[10:58:39.347]   - Field: ‘earlySignal’
[10:58:39.347]   - Field: ‘lazy’
[10:58:39.347]   - Field: ‘state’
[10:58:39.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.347] - Launch lazy future ...
[10:58:39.347] Packages needed by the future expression (n = 0): <none>
[10:58:39.347] Packages needed by future strategies (n = 0): <none>
[10:58:39.348] {
[10:58:39.348]     {
[10:58:39.348]         {
[10:58:39.348]             ...future.startTime <- base::Sys.time()
[10:58:39.348]             {
[10:58:39.348]                 {
[10:58:39.348]                   {
[10:58:39.348]                     {
[10:58:39.348]                       base::local({
[10:58:39.348]                         has_future <- base::requireNamespace("future", 
[10:58:39.348]                           quietly = TRUE)
[10:58:39.348]                         if (has_future) {
[10:58:39.348]                           ns <- base::getNamespace("future")
[10:58:39.348]                           version <- ns[[".package"]][["version"]]
[10:58:39.348]                           if (is.null(version)) 
[10:58:39.348]                             version <- utils::packageVersion("future")
[10:58:39.348]                         }
[10:58:39.348]                         else {
[10:58:39.348]                           version <- NULL
[10:58:39.348]                         }
[10:58:39.348]                         if (!has_future || version < "1.8.0") {
[10:58:39.348]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.348]                             "", base::R.version$version.string), 
[10:58:39.348]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.348]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.348]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.348]                               "release", "version")], collapse = " "), 
[10:58:39.348]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.348]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.348]                             info)
[10:58:39.348]                           info <- base::paste(info, collapse = "; ")
[10:58:39.348]                           if (!has_future) {
[10:58:39.348]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.348]                               info)
[10:58:39.348]                           }
[10:58:39.348]                           else {
[10:58:39.348]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.348]                               info, version)
[10:58:39.348]                           }
[10:58:39.348]                           base::stop(msg)
[10:58:39.348]                         }
[10:58:39.348]                       })
[10:58:39.348]                     }
[10:58:39.348]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.348]                     base::options(mc.cores = 1L)
[10:58:39.348]                   }
[10:58:39.348]                   ...future.strategy.old <- future::plan("list")
[10:58:39.348]                   options(future.plan = NULL)
[10:58:39.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.348]                 }
[10:58:39.348]                 ...future.workdir <- getwd()
[10:58:39.348]             }
[10:58:39.348]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.348]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.348]         }
[10:58:39.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.348]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.348]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.348]             base::names(...future.oldOptions))
[10:58:39.348]     }
[10:58:39.348]     if (FALSE) {
[10:58:39.348]     }
[10:58:39.348]     else {
[10:58:39.348]         if (TRUE) {
[10:58:39.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.348]                 open = "w")
[10:58:39.348]         }
[10:58:39.348]         else {
[10:58:39.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.348]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.348]         }
[10:58:39.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.348]             base::sink(type = "output", split = FALSE)
[10:58:39.348]             base::close(...future.stdout)
[10:58:39.348]         }, add = TRUE)
[10:58:39.348]     }
[10:58:39.348]     ...future.frame <- base::sys.nframe()
[10:58:39.348]     ...future.conditions <- base::list()
[10:58:39.348]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.348]     if (FALSE) {
[10:58:39.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.348]     }
[10:58:39.348]     ...future.result <- base::tryCatch({
[10:58:39.348]         base::withCallingHandlers({
[10:58:39.348]             ...future.value <- base::withVisible(base::local({
[10:58:39.348]                 withCallingHandlers({
[10:58:39.348]                   {
[10:58:39.348]                     do.call(function(...) {
[10:58:39.348]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.348]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.348]                         ...future.globals.maxSize)) {
[10:58:39.348]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.348]                         on.exit(options(oopts), add = TRUE)
[10:58:39.348]                       }
[10:58:39.348]                       {
[10:58:39.348]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.348]                           FUN = function(jj) {
[10:58:39.348]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.348]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.348]                           })
[10:58:39.348]                       }
[10:58:39.348]                     }, args = future.call.arguments)
[10:58:39.348]                   }
[10:58:39.348]                 }, immediateCondition = function(cond) {
[10:58:39.348]                   save_rds <- function (object, pathname, ...) 
[10:58:39.348]                   {
[10:58:39.348]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.348]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.348]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.348]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.348]                         fi_tmp[["mtime"]])
[10:58:39.348]                     }
[10:58:39.348]                     tryCatch({
[10:58:39.348]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.348]                     }, error = function(ex) {
[10:58:39.348]                       msg <- conditionMessage(ex)
[10:58:39.348]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.348]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.348]                         fi_tmp[["mtime"]], msg)
[10:58:39.348]                       ex$message <- msg
[10:58:39.348]                       stop(ex)
[10:58:39.348]                     })
[10:58:39.348]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.348]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.348]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.348]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.348]                       fi <- file.info(pathname)
[10:58:39.348]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.348]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.348]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.348]                         fi[["size"]], fi[["mtime"]])
[10:58:39.348]                       stop(msg)
[10:58:39.348]                     }
[10:58:39.348]                     invisible(pathname)
[10:58:39.348]                   }
[10:58:39.348]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.348]                     rootPath = tempdir()) 
[10:58:39.348]                   {
[10:58:39.348]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.348]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.348]                       tmpdir = path, fileext = ".rds")
[10:58:39.348]                     save_rds(obj, file)
[10:58:39.348]                   }
[10:58:39.348]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.348]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.348]                   {
[10:58:39.348]                     inherits <- base::inherits
[10:58:39.348]                     invokeRestart <- base::invokeRestart
[10:58:39.348]                     is.null <- base::is.null
[10:58:39.348]                     muffled <- FALSE
[10:58:39.348]                     if (inherits(cond, "message")) {
[10:58:39.348]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.348]                       if (muffled) 
[10:58:39.348]                         invokeRestart("muffleMessage")
[10:58:39.348]                     }
[10:58:39.348]                     else if (inherits(cond, "warning")) {
[10:58:39.348]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.348]                       if (muffled) 
[10:58:39.348]                         invokeRestart("muffleWarning")
[10:58:39.348]                     }
[10:58:39.348]                     else if (inherits(cond, "condition")) {
[10:58:39.348]                       if (!is.null(pattern)) {
[10:58:39.348]                         computeRestarts <- base::computeRestarts
[10:58:39.348]                         grepl <- base::grepl
[10:58:39.348]                         restarts <- computeRestarts(cond)
[10:58:39.348]                         for (restart in restarts) {
[10:58:39.348]                           name <- restart$name
[10:58:39.348]                           if (is.null(name)) 
[10:58:39.348]                             next
[10:58:39.348]                           if (!grepl(pattern, name)) 
[10:58:39.348]                             next
[10:58:39.348]                           invokeRestart(restart)
[10:58:39.348]                           muffled <- TRUE
[10:58:39.348]                           break
[10:58:39.348]                         }
[10:58:39.348]                       }
[10:58:39.348]                     }
[10:58:39.348]                     invisible(muffled)
[10:58:39.348]                   }
[10:58:39.348]                   muffleCondition(cond)
[10:58:39.348]                 })
[10:58:39.348]             }))
[10:58:39.348]             future::FutureResult(value = ...future.value$value, 
[10:58:39.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.348]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.348]                     ...future.globalenv.names))
[10:58:39.348]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.348]         }, condition = base::local({
[10:58:39.348]             c <- base::c
[10:58:39.348]             inherits <- base::inherits
[10:58:39.348]             invokeRestart <- base::invokeRestart
[10:58:39.348]             length <- base::length
[10:58:39.348]             list <- base::list
[10:58:39.348]             seq.int <- base::seq.int
[10:58:39.348]             signalCondition <- base::signalCondition
[10:58:39.348]             sys.calls <- base::sys.calls
[10:58:39.348]             `[[` <- base::`[[`
[10:58:39.348]             `+` <- base::`+`
[10:58:39.348]             `<<-` <- base::`<<-`
[10:58:39.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.348]                   3L)]
[10:58:39.348]             }
[10:58:39.348]             function(cond) {
[10:58:39.348]                 is_error <- inherits(cond, "error")
[10:58:39.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.348]                   NULL)
[10:58:39.348]                 if (is_error) {
[10:58:39.348]                   sessionInformation <- function() {
[10:58:39.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.348]                       search = base::search(), system = base::Sys.info())
[10:58:39.348]                   }
[10:58:39.348]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.348]                     cond$call), session = sessionInformation(), 
[10:58:39.348]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.348]                   signalCondition(cond)
[10:58:39.348]                 }
[10:58:39.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.348]                 "immediateCondition"))) {
[10:58:39.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.348]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.348]                   if (TRUE && !signal) {
[10:58:39.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.348]                     {
[10:58:39.348]                       inherits <- base::inherits
[10:58:39.348]                       invokeRestart <- base::invokeRestart
[10:58:39.348]                       is.null <- base::is.null
[10:58:39.348]                       muffled <- FALSE
[10:58:39.348]                       if (inherits(cond, "message")) {
[10:58:39.348]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.348]                         if (muffled) 
[10:58:39.348]                           invokeRestart("muffleMessage")
[10:58:39.348]                       }
[10:58:39.348]                       else if (inherits(cond, "warning")) {
[10:58:39.348]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.348]                         if (muffled) 
[10:58:39.348]                           invokeRestart("muffleWarning")
[10:58:39.348]                       }
[10:58:39.348]                       else if (inherits(cond, "condition")) {
[10:58:39.348]                         if (!is.null(pattern)) {
[10:58:39.348]                           computeRestarts <- base::computeRestarts
[10:58:39.348]                           grepl <- base::grepl
[10:58:39.348]                           restarts <- computeRestarts(cond)
[10:58:39.348]                           for (restart in restarts) {
[10:58:39.348]                             name <- restart$name
[10:58:39.348]                             if (is.null(name)) 
[10:58:39.348]                               next
[10:58:39.348]                             if (!grepl(pattern, name)) 
[10:58:39.348]                               next
[10:58:39.348]                             invokeRestart(restart)
[10:58:39.348]                             muffled <- TRUE
[10:58:39.348]                             break
[10:58:39.348]                           }
[10:58:39.348]                         }
[10:58:39.348]                       }
[10:58:39.348]                       invisible(muffled)
[10:58:39.348]                     }
[10:58:39.348]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.348]                   }
[10:58:39.348]                 }
[10:58:39.348]                 else {
[10:58:39.348]                   if (TRUE) {
[10:58:39.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.348]                     {
[10:58:39.348]                       inherits <- base::inherits
[10:58:39.348]                       invokeRestart <- base::invokeRestart
[10:58:39.348]                       is.null <- base::is.null
[10:58:39.348]                       muffled <- FALSE
[10:58:39.348]                       if (inherits(cond, "message")) {
[10:58:39.348]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.348]                         if (muffled) 
[10:58:39.348]                           invokeRestart("muffleMessage")
[10:58:39.348]                       }
[10:58:39.348]                       else if (inherits(cond, "warning")) {
[10:58:39.348]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.348]                         if (muffled) 
[10:58:39.348]                           invokeRestart("muffleWarning")
[10:58:39.348]                       }
[10:58:39.348]                       else if (inherits(cond, "condition")) {
[10:58:39.348]                         if (!is.null(pattern)) {
[10:58:39.348]                           computeRestarts <- base::computeRestarts
[10:58:39.348]                           grepl <- base::grepl
[10:58:39.348]                           restarts <- computeRestarts(cond)
[10:58:39.348]                           for (restart in restarts) {
[10:58:39.348]                             name <- restart$name
[10:58:39.348]                             if (is.null(name)) 
[10:58:39.348]                               next
[10:58:39.348]                             if (!grepl(pattern, name)) 
[10:58:39.348]                               next
[10:58:39.348]                             invokeRestart(restart)
[10:58:39.348]                             muffled <- TRUE
[10:58:39.348]                             break
[10:58:39.348]                           }
[10:58:39.348]                         }
[10:58:39.348]                       }
[10:58:39.348]                       invisible(muffled)
[10:58:39.348]                     }
[10:58:39.348]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.348]                   }
[10:58:39.348]                 }
[10:58:39.348]             }
[10:58:39.348]         }))
[10:58:39.348]     }, error = function(ex) {
[10:58:39.348]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.348]                 ...future.rng), started = ...future.startTime, 
[10:58:39.348]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.348]             version = "1.8"), class = "FutureResult")
[10:58:39.348]     }, finally = {
[10:58:39.348]         if (!identical(...future.workdir, getwd())) 
[10:58:39.348]             setwd(...future.workdir)
[10:58:39.348]         {
[10:58:39.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.348]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.348]             }
[10:58:39.348]             base::options(...future.oldOptions)
[10:58:39.348]             if (.Platform$OS.type == "windows") {
[10:58:39.348]                 old_names <- names(...future.oldEnvVars)
[10:58:39.348]                 envs <- base::Sys.getenv()
[10:58:39.348]                 names <- names(envs)
[10:58:39.348]                 common <- intersect(names, old_names)
[10:58:39.348]                 added <- setdiff(names, old_names)
[10:58:39.348]                 removed <- setdiff(old_names, names)
[10:58:39.348]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.348]                   envs[common]]
[10:58:39.348]                 NAMES <- toupper(changed)
[10:58:39.348]                 args <- list()
[10:58:39.348]                 for (kk in seq_along(NAMES)) {
[10:58:39.348]                   name <- changed[[kk]]
[10:58:39.348]                   NAME <- NAMES[[kk]]
[10:58:39.348]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.348]                     next
[10:58:39.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.348]                 }
[10:58:39.348]                 NAMES <- toupper(added)
[10:58:39.348]                 for (kk in seq_along(NAMES)) {
[10:58:39.348]                   name <- added[[kk]]
[10:58:39.348]                   NAME <- NAMES[[kk]]
[10:58:39.348]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.348]                     next
[10:58:39.348]                   args[[name]] <- ""
[10:58:39.348]                 }
[10:58:39.348]                 NAMES <- toupper(removed)
[10:58:39.348]                 for (kk in seq_along(NAMES)) {
[10:58:39.348]                   name <- removed[[kk]]
[10:58:39.348]                   NAME <- NAMES[[kk]]
[10:58:39.348]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.348]                     next
[10:58:39.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.348]                 }
[10:58:39.348]                 if (length(args) > 0) 
[10:58:39.348]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.348]             }
[10:58:39.348]             else {
[10:58:39.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.348]             }
[10:58:39.348]             {
[10:58:39.348]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.348]                   0L) {
[10:58:39.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.348]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.348]                   base::options(opts)
[10:58:39.348]                 }
[10:58:39.348]                 {
[10:58:39.348]                   {
[10:58:39.348]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.348]                     NULL
[10:58:39.348]                   }
[10:58:39.348]                   options(future.plan = NULL)
[10:58:39.348]                   if (is.na(NA_character_)) 
[10:58:39.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.348]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.348]                     .init = FALSE)
[10:58:39.348]                 }
[10:58:39.348]             }
[10:58:39.348]         }
[10:58:39.348]     })
[10:58:39.348]     if (TRUE) {
[10:58:39.348]         base::sink(type = "output", split = FALSE)
[10:58:39.348]         if (TRUE) {
[10:58:39.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.348]         }
[10:58:39.348]         else {
[10:58:39.348]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.348]         }
[10:58:39.348]         base::close(...future.stdout)
[10:58:39.348]         ...future.stdout <- NULL
[10:58:39.348]     }
[10:58:39.348]     ...future.result$conditions <- ...future.conditions
[10:58:39.348]     ...future.result$finished <- base::Sys.time()
[10:58:39.348]     ...future.result
[10:58:39.348] }
[10:58:39.350] assign_globals() ...
[10:58:39.350] List of 5
[10:58:39.350]  $ future.call.arguments    : list()
[10:58:39.350]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.350]  $ ...future.FUN            :function (x)  
[10:58:39.350]  $ ...future.elements_ii    :List of 3
[10:58:39.350]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:58:39.350]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:58:39.350]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:58:39.350]  $ ...future.seeds_ii       : NULL
[10:58:39.350]  $ ...future.globals.maxSize: num Inf
[10:58:39.350]  - attr(*, "resolved")= logi FALSE
[10:58:39.350]  - attr(*, "total_size")= num NA
[10:58:39.350]  - attr(*, "where")=List of 5
[10:58:39.350]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.350]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.350]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.350]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.350]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.350]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.350]  - attr(*, "already-done")= logi TRUE
[10:58:39.355] - copied ‘future.call.arguments’ to environment
[10:58:39.355] - copied ‘...future.FUN’ to environment
[10:58:39.355] - copied ‘...future.elements_ii’ to environment
[10:58:39.356] - copied ‘...future.seeds_ii’ to environment
[10:58:39.356] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.356] assign_globals() ... done
[10:58:39.356] requestCore(): workers = 2
[10:58:39.358] MulticoreFuture started
[10:58:39.358] - Launch lazy future ... done
[10:58:39.358] run() for ‘MulticoreFuture’ ... done
[10:58:39.358] Created future:
[10:58:39.359] plan(): Setting new future strategy stack:
[10:58:39.359] List of future strategies:
[10:58:39.359] 1. sequential:
[10:58:39.359]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.359]    - tweaked: FALSE
[10:58:39.359]    - call: NULL
[10:58:39.360] plan(): nbrOfWorkers() = 1
[10:58:39.361] plan(): Setting new future strategy stack:
[10:58:39.362] List of future strategies:
[10:58:39.362] 1. multicore:
[10:58:39.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.362]    - tweaked: FALSE
[10:58:39.362]    - call: plan(strategy)
[10:58:39.369] plan(): nbrOfWorkers() = 2
[10:58:39.359] MulticoreFuture:
[10:58:39.359] Label: ‘future_apply-1’
[10:58:39.359] Expression:
[10:58:39.359] {
[10:58:39.359]     do.call(function(...) {
[10:58:39.359]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.359]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.359]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.359]             on.exit(options(oopts), add = TRUE)
[10:58:39.359]         }
[10:58:39.359]         {
[10:58:39.359]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.359]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.359]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.359]             })
[10:58:39.359]         }
[10:58:39.359]     }, args = future.call.arguments)
[10:58:39.359] }
[10:58:39.359] Lazy evaluation: FALSE
[10:58:39.359] Asynchronous evaluation: TRUE
[10:58:39.359] Local evaluation: TRUE
[10:58:39.359] Environment: R_GlobalEnv
[10:58:39.359] Capture standard output: TRUE
[10:58:39.359] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.359] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.359] Packages: <none>
[10:58:39.359] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.359] Resolved: TRUE
[10:58:39.359] Value: <not collected>
[10:58:39.359] Conditions captured: <none>
[10:58:39.359] Early signaling: FALSE
[10:58:39.359] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.359] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.371] Chunk #1 of 2 ... DONE
[10:58:39.371] Chunk #2 of 2 ...
[10:58:39.371]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.371]  - seeds: <none>
[10:58:39.373]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.373] getGlobalsAndPackages() ...
[10:58:39.374] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.374] Resolving globals: FALSE
[10:58:39.374] Tweak future expression to call with '...' arguments ...
[10:58:39.374] {
[10:58:39.374]     do.call(function(...) {
[10:58:39.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.374]             on.exit(options(oopts), add = TRUE)
[10:58:39.374]         }
[10:58:39.374]         {
[10:58:39.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.374]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.374]             })
[10:58:39.374]         }
[10:58:39.374]     }, args = future.call.arguments)
[10:58:39.374] }
[10:58:39.375] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.376] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.376] 
[10:58:39.376] getGlobalsAndPackages() ... DONE
[10:58:39.377] run() for ‘Future’ ...
[10:58:39.377] - state: ‘created’
[10:58:39.378] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.381] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.382]   - Field: ‘label’
[10:58:39.382]   - Field: ‘local’
[10:58:39.382]   - Field: ‘owner’
[10:58:39.382]   - Field: ‘envir’
[10:58:39.382]   - Field: ‘workers’
[10:58:39.383]   - Field: ‘packages’
[10:58:39.383]   - Field: ‘gc’
[10:58:39.383]   - Field: ‘job’
[10:58:39.383]   - Field: ‘conditions’
[10:58:39.383]   - Field: ‘expr’
[10:58:39.383]   - Field: ‘uuid’
[10:58:39.383]   - Field: ‘seed’
[10:58:39.384]   - Field: ‘version’
[10:58:39.384]   - Field: ‘result’
[10:58:39.384]   - Field: ‘asynchronous’
[10:58:39.384]   - Field: ‘calls’
[10:58:39.384]   - Field: ‘globals’
[10:58:39.384]   - Field: ‘stdout’
[10:58:39.384]   - Field: ‘earlySignal’
[10:58:39.385]   - Field: ‘lazy’
[10:58:39.385]   - Field: ‘state’
[10:58:39.385] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.385] - Launch lazy future ...
[10:58:39.385] Packages needed by the future expression (n = 0): <none>
[10:58:39.386] Packages needed by future strategies (n = 0): <none>
[10:58:39.386] {
[10:58:39.386]     {
[10:58:39.386]         {
[10:58:39.386]             ...future.startTime <- base::Sys.time()
[10:58:39.386]             {
[10:58:39.386]                 {
[10:58:39.386]                   {
[10:58:39.386]                     {
[10:58:39.386]                       base::local({
[10:58:39.386]                         has_future <- base::requireNamespace("future", 
[10:58:39.386]                           quietly = TRUE)
[10:58:39.386]                         if (has_future) {
[10:58:39.386]                           ns <- base::getNamespace("future")
[10:58:39.386]                           version <- ns[[".package"]][["version"]]
[10:58:39.386]                           if (is.null(version)) 
[10:58:39.386]                             version <- utils::packageVersion("future")
[10:58:39.386]                         }
[10:58:39.386]                         else {
[10:58:39.386]                           version <- NULL
[10:58:39.386]                         }
[10:58:39.386]                         if (!has_future || version < "1.8.0") {
[10:58:39.386]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.386]                             "", base::R.version$version.string), 
[10:58:39.386]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.386]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.386]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.386]                               "release", "version")], collapse = " "), 
[10:58:39.386]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.386]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.386]                             info)
[10:58:39.386]                           info <- base::paste(info, collapse = "; ")
[10:58:39.386]                           if (!has_future) {
[10:58:39.386]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.386]                               info)
[10:58:39.386]                           }
[10:58:39.386]                           else {
[10:58:39.386]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.386]                               info, version)
[10:58:39.386]                           }
[10:58:39.386]                           base::stop(msg)
[10:58:39.386]                         }
[10:58:39.386]                       })
[10:58:39.386]                     }
[10:58:39.386]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.386]                     base::options(mc.cores = 1L)
[10:58:39.386]                   }
[10:58:39.386]                   ...future.strategy.old <- future::plan("list")
[10:58:39.386]                   options(future.plan = NULL)
[10:58:39.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.386]                 }
[10:58:39.386]                 ...future.workdir <- getwd()
[10:58:39.386]             }
[10:58:39.386]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.386]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.386]         }
[10:58:39.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.386]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.386]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.386]             base::names(...future.oldOptions))
[10:58:39.386]     }
[10:58:39.386]     if (FALSE) {
[10:58:39.386]     }
[10:58:39.386]     else {
[10:58:39.386]         if (TRUE) {
[10:58:39.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.386]                 open = "w")
[10:58:39.386]         }
[10:58:39.386]         else {
[10:58:39.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.386]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.386]         }
[10:58:39.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.386]             base::sink(type = "output", split = FALSE)
[10:58:39.386]             base::close(...future.stdout)
[10:58:39.386]         }, add = TRUE)
[10:58:39.386]     }
[10:58:39.386]     ...future.frame <- base::sys.nframe()
[10:58:39.386]     ...future.conditions <- base::list()
[10:58:39.386]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.386]     if (FALSE) {
[10:58:39.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.386]     }
[10:58:39.386]     ...future.result <- base::tryCatch({
[10:58:39.386]         base::withCallingHandlers({
[10:58:39.386]             ...future.value <- base::withVisible(base::local({
[10:58:39.386]                 withCallingHandlers({
[10:58:39.386]                   {
[10:58:39.386]                     do.call(function(...) {
[10:58:39.386]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.386]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.386]                         ...future.globals.maxSize)) {
[10:58:39.386]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.386]                         on.exit(options(oopts), add = TRUE)
[10:58:39.386]                       }
[10:58:39.386]                       {
[10:58:39.386]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.386]                           FUN = function(jj) {
[10:58:39.386]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.386]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.386]                           })
[10:58:39.386]                       }
[10:58:39.386]                     }, args = future.call.arguments)
[10:58:39.386]                   }
[10:58:39.386]                 }, immediateCondition = function(cond) {
[10:58:39.386]                   save_rds <- function (object, pathname, ...) 
[10:58:39.386]                   {
[10:58:39.386]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.386]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.386]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.386]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.386]                         fi_tmp[["mtime"]])
[10:58:39.386]                     }
[10:58:39.386]                     tryCatch({
[10:58:39.386]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.386]                     }, error = function(ex) {
[10:58:39.386]                       msg <- conditionMessage(ex)
[10:58:39.386]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.386]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.386]                         fi_tmp[["mtime"]], msg)
[10:58:39.386]                       ex$message <- msg
[10:58:39.386]                       stop(ex)
[10:58:39.386]                     })
[10:58:39.386]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.386]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.386]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.386]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.386]                       fi <- file.info(pathname)
[10:58:39.386]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.386]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.386]                         fi[["size"]], fi[["mtime"]])
[10:58:39.386]                       stop(msg)
[10:58:39.386]                     }
[10:58:39.386]                     invisible(pathname)
[10:58:39.386]                   }
[10:58:39.386]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.386]                     rootPath = tempdir()) 
[10:58:39.386]                   {
[10:58:39.386]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.386]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.386]                       tmpdir = path, fileext = ".rds")
[10:58:39.386]                     save_rds(obj, file)
[10:58:39.386]                   }
[10:58:39.386]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.386]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.386]                   {
[10:58:39.386]                     inherits <- base::inherits
[10:58:39.386]                     invokeRestart <- base::invokeRestart
[10:58:39.386]                     is.null <- base::is.null
[10:58:39.386]                     muffled <- FALSE
[10:58:39.386]                     if (inherits(cond, "message")) {
[10:58:39.386]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.386]                       if (muffled) 
[10:58:39.386]                         invokeRestart("muffleMessage")
[10:58:39.386]                     }
[10:58:39.386]                     else if (inherits(cond, "warning")) {
[10:58:39.386]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.386]                       if (muffled) 
[10:58:39.386]                         invokeRestart("muffleWarning")
[10:58:39.386]                     }
[10:58:39.386]                     else if (inherits(cond, "condition")) {
[10:58:39.386]                       if (!is.null(pattern)) {
[10:58:39.386]                         computeRestarts <- base::computeRestarts
[10:58:39.386]                         grepl <- base::grepl
[10:58:39.386]                         restarts <- computeRestarts(cond)
[10:58:39.386]                         for (restart in restarts) {
[10:58:39.386]                           name <- restart$name
[10:58:39.386]                           if (is.null(name)) 
[10:58:39.386]                             next
[10:58:39.386]                           if (!grepl(pattern, name)) 
[10:58:39.386]                             next
[10:58:39.386]                           invokeRestart(restart)
[10:58:39.386]                           muffled <- TRUE
[10:58:39.386]                           break
[10:58:39.386]                         }
[10:58:39.386]                       }
[10:58:39.386]                     }
[10:58:39.386]                     invisible(muffled)
[10:58:39.386]                   }
[10:58:39.386]                   muffleCondition(cond)
[10:58:39.386]                 })
[10:58:39.386]             }))
[10:58:39.386]             future::FutureResult(value = ...future.value$value, 
[10:58:39.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.386]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.386]                     ...future.globalenv.names))
[10:58:39.386]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.386]         }, condition = base::local({
[10:58:39.386]             c <- base::c
[10:58:39.386]             inherits <- base::inherits
[10:58:39.386]             invokeRestart <- base::invokeRestart
[10:58:39.386]             length <- base::length
[10:58:39.386]             list <- base::list
[10:58:39.386]             seq.int <- base::seq.int
[10:58:39.386]             signalCondition <- base::signalCondition
[10:58:39.386]             sys.calls <- base::sys.calls
[10:58:39.386]             `[[` <- base::`[[`
[10:58:39.386]             `+` <- base::`+`
[10:58:39.386]             `<<-` <- base::`<<-`
[10:58:39.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.386]                   3L)]
[10:58:39.386]             }
[10:58:39.386]             function(cond) {
[10:58:39.386]                 is_error <- inherits(cond, "error")
[10:58:39.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.386]                   NULL)
[10:58:39.386]                 if (is_error) {
[10:58:39.386]                   sessionInformation <- function() {
[10:58:39.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.386]                       search = base::search(), system = base::Sys.info())
[10:58:39.386]                   }
[10:58:39.386]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.386]                     cond$call), session = sessionInformation(), 
[10:58:39.386]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.386]                   signalCondition(cond)
[10:58:39.386]                 }
[10:58:39.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.386]                 "immediateCondition"))) {
[10:58:39.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.386]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.386]                   if (TRUE && !signal) {
[10:58:39.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.386]                     {
[10:58:39.386]                       inherits <- base::inherits
[10:58:39.386]                       invokeRestart <- base::invokeRestart
[10:58:39.386]                       is.null <- base::is.null
[10:58:39.386]                       muffled <- FALSE
[10:58:39.386]                       if (inherits(cond, "message")) {
[10:58:39.386]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.386]                         if (muffled) 
[10:58:39.386]                           invokeRestart("muffleMessage")
[10:58:39.386]                       }
[10:58:39.386]                       else if (inherits(cond, "warning")) {
[10:58:39.386]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.386]                         if (muffled) 
[10:58:39.386]                           invokeRestart("muffleWarning")
[10:58:39.386]                       }
[10:58:39.386]                       else if (inherits(cond, "condition")) {
[10:58:39.386]                         if (!is.null(pattern)) {
[10:58:39.386]                           computeRestarts <- base::computeRestarts
[10:58:39.386]                           grepl <- base::grepl
[10:58:39.386]                           restarts <- computeRestarts(cond)
[10:58:39.386]                           for (restart in restarts) {
[10:58:39.386]                             name <- restart$name
[10:58:39.386]                             if (is.null(name)) 
[10:58:39.386]                               next
[10:58:39.386]                             if (!grepl(pattern, name)) 
[10:58:39.386]                               next
[10:58:39.386]                             invokeRestart(restart)
[10:58:39.386]                             muffled <- TRUE
[10:58:39.386]                             break
[10:58:39.386]                           }
[10:58:39.386]                         }
[10:58:39.386]                       }
[10:58:39.386]                       invisible(muffled)
[10:58:39.386]                     }
[10:58:39.386]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.386]                   }
[10:58:39.386]                 }
[10:58:39.386]                 else {
[10:58:39.386]                   if (TRUE) {
[10:58:39.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.386]                     {
[10:58:39.386]                       inherits <- base::inherits
[10:58:39.386]                       invokeRestart <- base::invokeRestart
[10:58:39.386]                       is.null <- base::is.null
[10:58:39.386]                       muffled <- FALSE
[10:58:39.386]                       if (inherits(cond, "message")) {
[10:58:39.386]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.386]                         if (muffled) 
[10:58:39.386]                           invokeRestart("muffleMessage")
[10:58:39.386]                       }
[10:58:39.386]                       else if (inherits(cond, "warning")) {
[10:58:39.386]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.386]                         if (muffled) 
[10:58:39.386]                           invokeRestart("muffleWarning")
[10:58:39.386]                       }
[10:58:39.386]                       else if (inherits(cond, "condition")) {
[10:58:39.386]                         if (!is.null(pattern)) {
[10:58:39.386]                           computeRestarts <- base::computeRestarts
[10:58:39.386]                           grepl <- base::grepl
[10:58:39.386]                           restarts <- computeRestarts(cond)
[10:58:39.386]                           for (restart in restarts) {
[10:58:39.386]                             name <- restart$name
[10:58:39.386]                             if (is.null(name)) 
[10:58:39.386]                               next
[10:58:39.386]                             if (!grepl(pattern, name)) 
[10:58:39.386]                               next
[10:58:39.386]                             invokeRestart(restart)
[10:58:39.386]                             muffled <- TRUE
[10:58:39.386]                             break
[10:58:39.386]                           }
[10:58:39.386]                         }
[10:58:39.386]                       }
[10:58:39.386]                       invisible(muffled)
[10:58:39.386]                     }
[10:58:39.386]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.386]                   }
[10:58:39.386]                 }
[10:58:39.386]             }
[10:58:39.386]         }))
[10:58:39.386]     }, error = function(ex) {
[10:58:39.386]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.386]                 ...future.rng), started = ...future.startTime, 
[10:58:39.386]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.386]             version = "1.8"), class = "FutureResult")
[10:58:39.386]     }, finally = {
[10:58:39.386]         if (!identical(...future.workdir, getwd())) 
[10:58:39.386]             setwd(...future.workdir)
[10:58:39.386]         {
[10:58:39.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.386]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.386]             }
[10:58:39.386]             base::options(...future.oldOptions)
[10:58:39.386]             if (.Platform$OS.type == "windows") {
[10:58:39.386]                 old_names <- names(...future.oldEnvVars)
[10:58:39.386]                 envs <- base::Sys.getenv()
[10:58:39.386]                 names <- names(envs)
[10:58:39.386]                 common <- intersect(names, old_names)
[10:58:39.386]                 added <- setdiff(names, old_names)
[10:58:39.386]                 removed <- setdiff(old_names, names)
[10:58:39.386]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.386]                   envs[common]]
[10:58:39.386]                 NAMES <- toupper(changed)
[10:58:39.386]                 args <- list()
[10:58:39.386]                 for (kk in seq_along(NAMES)) {
[10:58:39.386]                   name <- changed[[kk]]
[10:58:39.386]                   NAME <- NAMES[[kk]]
[10:58:39.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.386]                     next
[10:58:39.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.386]                 }
[10:58:39.386]                 NAMES <- toupper(added)
[10:58:39.386]                 for (kk in seq_along(NAMES)) {
[10:58:39.386]                   name <- added[[kk]]
[10:58:39.386]                   NAME <- NAMES[[kk]]
[10:58:39.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.386]                     next
[10:58:39.386]                   args[[name]] <- ""
[10:58:39.386]                 }
[10:58:39.386]                 NAMES <- toupper(removed)
[10:58:39.386]                 for (kk in seq_along(NAMES)) {
[10:58:39.386]                   name <- removed[[kk]]
[10:58:39.386]                   NAME <- NAMES[[kk]]
[10:58:39.386]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.386]                     next
[10:58:39.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.386]                 }
[10:58:39.386]                 if (length(args) > 0) 
[10:58:39.386]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.386]             }
[10:58:39.386]             else {
[10:58:39.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.386]             }
[10:58:39.386]             {
[10:58:39.386]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.386]                   0L) {
[10:58:39.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.386]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.386]                   base::options(opts)
[10:58:39.386]                 }
[10:58:39.386]                 {
[10:58:39.386]                   {
[10:58:39.386]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.386]                     NULL
[10:58:39.386]                   }
[10:58:39.386]                   options(future.plan = NULL)
[10:58:39.386]                   if (is.na(NA_character_)) 
[10:58:39.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.386]                     .init = FALSE)
[10:58:39.386]                 }
[10:58:39.386]             }
[10:58:39.386]         }
[10:58:39.386]     })
[10:58:39.386]     if (TRUE) {
[10:58:39.386]         base::sink(type = "output", split = FALSE)
[10:58:39.386]         if (TRUE) {
[10:58:39.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.386]         }
[10:58:39.386]         else {
[10:58:39.386]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.386]         }
[10:58:39.386]         base::close(...future.stdout)
[10:58:39.386]         ...future.stdout <- NULL
[10:58:39.386]     }
[10:58:39.386]     ...future.result$conditions <- ...future.conditions
[10:58:39.386]     ...future.result$finished <- base::Sys.time()
[10:58:39.386]     ...future.result
[10:58:39.386] }
[10:58:39.389] assign_globals() ...
[10:58:39.389] List of 5
[10:58:39.389]  $ future.call.arguments    : list()
[10:58:39.389]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.389]  $ ...future.FUN            :function (x)  
[10:58:39.389]  $ ...future.elements_ii    :List of 3
[10:58:39.389]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:58:39.389]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:58:39.389]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:58:39.389]  $ ...future.seeds_ii       : NULL
[10:58:39.389]  $ ...future.globals.maxSize: num Inf
[10:58:39.389]  - attr(*, "resolved")= logi FALSE
[10:58:39.389]  - attr(*, "total_size")= num NA
[10:58:39.389]  - attr(*, "where")=List of 5
[10:58:39.389]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.389]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.389]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.389]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.389]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.389]  - attr(*, "already-done")= logi TRUE
[10:58:39.396] - copied ‘future.call.arguments’ to environment
[10:58:39.396] - copied ‘...future.FUN’ to environment
[10:58:39.396] - copied ‘...future.elements_ii’ to environment
[10:58:39.397] - copied ‘...future.seeds_ii’ to environment
[10:58:39.397] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.397] assign_globals() ... done
[10:58:39.397] requestCore(): workers = 2
[10:58:39.399] MulticoreFuture started
[10:58:39.399] - Launch lazy future ... done
[10:58:39.400] run() for ‘MulticoreFuture’ ... done
[10:58:39.400] Created future:
[10:58:39.400] plan(): Setting new future strategy stack:
[10:58:39.400] List of future strategies:
[10:58:39.400] 1. sequential:
[10:58:39.400]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.400]    - tweaked: FALSE
[10:58:39.400]    - call: NULL
[10:58:39.401] plan(): nbrOfWorkers() = 1
[10:58:39.403] plan(): Setting new future strategy stack:
[10:58:39.404] List of future strategies:
[10:58:39.404] 1. multicore:
[10:58:39.404]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.404]    - tweaked: FALSE
[10:58:39.404]    - call: plan(strategy)
[10:58:39.407] plan(): nbrOfWorkers() = 2
[10:58:39.400] MulticoreFuture:
[10:58:39.400] Label: ‘future_apply-2’
[10:58:39.400] Expression:
[10:58:39.400] {
[10:58:39.400]     do.call(function(...) {
[10:58:39.400]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.400]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.400]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.400]             on.exit(options(oopts), add = TRUE)
[10:58:39.400]         }
[10:58:39.400]         {
[10:58:39.400]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.400]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.400]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.400]             })
[10:58:39.400]         }
[10:58:39.400]     }, args = future.call.arguments)
[10:58:39.400] }
[10:58:39.400] Lazy evaluation: FALSE
[10:58:39.400] Asynchronous evaluation: TRUE
[10:58:39.400] Local evaluation: TRUE
[10:58:39.400] Environment: R_GlobalEnv
[10:58:39.400] Capture standard output: TRUE
[10:58:39.400] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.400] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.400] Packages: <none>
[10:58:39.400] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.400] Resolved: TRUE
[10:58:39.400] Value: <not collected>
[10:58:39.400] Conditions captured: <none>
[10:58:39.400] Early signaling: FALSE
[10:58:39.400] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.400] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.408] Chunk #2 of 2 ... DONE
[10:58:39.408] Launching 2 futures (chunks) ... DONE
[10:58:39.408] Resolving 2 futures (chunks) ...
[10:58:39.408] resolve() on list ...
[10:58:39.409]  recursive: 0
[10:58:39.409]  length: 2
[10:58:39.409] 
[10:58:39.409] Future #1
[10:58:39.409] result() for MulticoreFuture ...
[10:58:39.410] result() for MulticoreFuture ...
[10:58:39.410] result() for MulticoreFuture ... done
[10:58:39.410] result() for MulticoreFuture ... done
[10:58:39.411] result() for MulticoreFuture ...
[10:58:39.411] result() for MulticoreFuture ... done
[10:58:39.411] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:39.411] - nx: 2
[10:58:39.411] - relay: TRUE
[10:58:39.411] - stdout: TRUE
[10:58:39.411] - signal: TRUE
[10:58:39.412] - resignal: FALSE
[10:58:39.412] - force: TRUE
[10:58:39.412] - relayed: [n=2] FALSE, FALSE
[10:58:39.412] - queued futures: [n=2] FALSE, FALSE
[10:58:39.412]  - until=1
[10:58:39.412]  - relaying element #1
[10:58:39.412] result() for MulticoreFuture ...
[10:58:39.412] result() for MulticoreFuture ... done
[10:58:39.413] result() for MulticoreFuture ...
[10:58:39.413] result() for MulticoreFuture ... done
[10:58:39.413] result() for MulticoreFuture ...
[10:58:39.413] result() for MulticoreFuture ... done
[10:58:39.413] result() for MulticoreFuture ...
[10:58:39.413] result() for MulticoreFuture ... done
[10:58:39.413] - relayed: [n=2] TRUE, FALSE
[10:58:39.414] - queued futures: [n=2] TRUE, FALSE
[10:58:39.414] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:39.414]  length: 1 (resolved future 1)
[10:58:39.414] Future #2
[10:58:39.414] result() for MulticoreFuture ...
[10:58:39.415] result() for MulticoreFuture ...
[10:58:39.415] result() for MulticoreFuture ... done
[10:58:39.415] result() for MulticoreFuture ... done
[10:58:39.415] result() for MulticoreFuture ...
[10:58:39.416] result() for MulticoreFuture ... done
[10:58:39.416] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:39.416] - nx: 2
[10:58:39.416] - relay: TRUE
[10:58:39.416] - stdout: TRUE
[10:58:39.416] - signal: TRUE
[10:58:39.416] - resignal: FALSE
[10:58:39.416] - force: TRUE
[10:58:39.416] - relayed: [n=2] TRUE, FALSE
[10:58:39.417] - queued futures: [n=2] TRUE, FALSE
[10:58:39.417]  - until=2
[10:58:39.417]  - relaying element #2
[10:58:39.417] result() for MulticoreFuture ...
[10:58:39.417] result() for MulticoreFuture ... done
[10:58:39.417] result() for MulticoreFuture ...
[10:58:39.419] result() for MulticoreFuture ... done
[10:58:39.420] result() for MulticoreFuture ...
[10:58:39.420] result() for MulticoreFuture ... done
[10:58:39.420] result() for MulticoreFuture ...
[10:58:39.420] result() for MulticoreFuture ... done
[10:58:39.420] - relayed: [n=2] TRUE, TRUE
[10:58:39.421] - queued futures: [n=2] TRUE, TRUE
[10:58:39.421] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:39.421]  length: 0 (resolved future 2)
[10:58:39.421] Relaying remaining futures
[10:58:39.421] signalConditionsASAP(NULL, pos=0) ...
[10:58:39.421] - nx: 2
[10:58:39.421] - relay: TRUE
[10:58:39.422] - stdout: TRUE
[10:58:39.422] - signal: TRUE
[10:58:39.422] - resignal: FALSE
[10:58:39.422] - force: TRUE
[10:58:39.422] - relayed: [n=2] TRUE, TRUE
[10:58:39.422] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:39.423] - relayed: [n=2] TRUE, TRUE
[10:58:39.423] - queued futures: [n=2] TRUE, TRUE
[10:58:39.423] signalConditionsASAP(NULL, pos=0) ... done
[10:58:39.423] resolve() on list ... DONE
[10:58:39.423] result() for MulticoreFuture ...
[10:58:39.423] result() for MulticoreFuture ... done
[10:58:39.424] result() for MulticoreFuture ...
[10:58:39.424] result() for MulticoreFuture ... done
[10:58:39.424] result() for MulticoreFuture ...
[10:58:39.424] result() for MulticoreFuture ... done
[10:58:39.424] result() for MulticoreFuture ...
[10:58:39.424] result() for MulticoreFuture ... done
[10:58:39.424]  - Number of value chunks collected: 2
[10:58:39.424] Resolving 2 futures (chunks) ... DONE
[10:58:39.424] Reducing values from 2 chunks ...
[10:58:39.425]  - Number of values collected after concatenation: 6
[10:58:39.425]  - Number of values expected: 6
[10:58:39.425] Reducing values from 2 chunks ... DONE
[10:58:39.425] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:58:39.425] getGlobalsAndPackagesXApply() ...
[10:58:39.425]  - future.globals: TRUE
[10:58:39.426] getGlobalsAndPackages() ...
[10:58:39.426] Searching for globals...
[10:58:39.427] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:58:39.428] Searching for globals ... DONE
[10:58:39.428] Resolving globals: FALSE
[10:58:39.428] The total size of the 1 globals is 411 bytes (411 bytes)
[10:58:39.428] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 411 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (411 bytes of class ‘function’)
[10:58:39.429] - globals: [1] ‘FUN’
[10:58:39.429] 
[10:58:39.429] getGlobalsAndPackages() ... DONE
[10:58:39.429]  - globals found/used: [n=1] ‘FUN’
[10:58:39.429]  - needed namespaces: [n=0] 
[10:58:39.429] Finding globals ... DONE
[10:58:39.429]  - use_args: TRUE
[10:58:39.429]  - Getting '...' globals ...
[10:58:39.430] resolve() on list ...
[10:58:39.430]  recursive: 0
[10:58:39.430]  length: 1
[10:58:39.430]  elements: ‘...’
[10:58:39.430]  length: 0 (resolved future 1)
[10:58:39.430] resolve() on list ... DONE
[10:58:39.430]    - '...' content: [n=0] 
[10:58:39.430] List of 1
[10:58:39.430]  $ ...: list()
[10:58:39.430]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.430]  - attr(*, "where")=List of 1
[10:58:39.430]   ..$ ...:<environment: 0x5635be76b2f0> 
[10:58:39.430]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.430]  - attr(*, "resolved")= logi TRUE
[10:58:39.430]  - attr(*, "total_size")= num NA
[10:58:39.433]  - Getting '...' globals ... DONE
[10:58:39.433] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:39.433] List of 2
[10:58:39.433]  $ ...future.FUN:function (x)  
[10:58:39.433]  $ ...          : list()
[10:58:39.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.433]  - attr(*, "where")=List of 2
[10:58:39.433]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:39.433]   ..$ ...          :<environment: 0x5635be76b2f0> 
[10:58:39.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.433]  - attr(*, "resolved")= logi FALSE
[10:58:39.433]  - attr(*, "total_size")= num 3672
[10:58:39.436] Packages to be attached in all futures: [n=0] 
[10:58:39.436] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.438] future_lapply() ...
[10:58:39.440] Number of chunks: 2
[10:58:39.440] getGlobalsAndPackagesXApply() ...
[10:58:39.440]  - future.globals: <name-value list> with names ‘list()’
[10:58:39.440]  - use_args: TRUE
[10:58:39.440] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:39.440] List of 2
[10:58:39.440]  $ ...          : list()
[10:58:39.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.440]  $ ...future.FUN:function (x)  
[10:58:39.440]  - attr(*, "where")=List of 2
[10:58:39.440]   ..$ ...          :<environment: 0x5635be76b2f0> 
[10:58:39.440]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:58:39.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.440]  - attr(*, "resolved")= logi FALSE
[10:58:39.440]  - attr(*, "total_size")= num NA
[10:58:39.443] Packages to be attached in all futures: [n=0] 
[10:58:39.443] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.443] Number of futures (= number of chunks): 2
[10:58:39.443] Launching 2 futures (chunks) ...
[10:58:39.444] Chunk #1 of 2 ...
[10:58:39.445]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.445]  - seeds: <none>
[10:58:39.445]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.445] getGlobalsAndPackages() ...
[10:58:39.445] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.445] Resolving globals: FALSE
[10:58:39.445] Tweak future expression to call with '...' arguments ...
[10:58:39.445] {
[10:58:39.445]     do.call(function(...) {
[10:58:39.445]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.445]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.445]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.445]             on.exit(options(oopts), add = TRUE)
[10:58:39.445]         }
[10:58:39.445]         {
[10:58:39.445]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.445]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.445]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.445]             })
[10:58:39.445]         }
[10:58:39.445]     }, args = future.call.arguments)
[10:58:39.445] }
[10:58:39.446] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.446] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.446] 
[10:58:39.446] getGlobalsAndPackages() ... DONE
[10:58:39.447] run() for ‘Future’ ...
[10:58:39.447] - state: ‘created’
[10:58:39.447] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.448] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.449] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.449]   - Field: ‘label’
[10:58:39.449]   - Field: ‘local’
[10:58:39.449]   - Field: ‘owner’
[10:58:39.449]   - Field: ‘envir’
[10:58:39.449]   - Field: ‘workers’
[10:58:39.449]   - Field: ‘packages’
[10:58:39.449]   - Field: ‘gc’
[10:58:39.449]   - Field: ‘job’
[10:58:39.449]   - Field: ‘conditions’
[10:58:39.449]   - Field: ‘expr’
[10:58:39.449]   - Field: ‘uuid’
[10:58:39.450]   - Field: ‘seed’
[10:58:39.450]   - Field: ‘version’
[10:58:39.450]   - Field: ‘result’
[10:58:39.450]   - Field: ‘asynchronous’
[10:58:39.450]   - Field: ‘calls’
[10:58:39.450]   - Field: ‘globals’
[10:58:39.450]   - Field: ‘stdout’
[10:58:39.450]   - Field: ‘earlySignal’
[10:58:39.450]   - Field: ‘lazy’
[10:58:39.450]   - Field: ‘state’
[10:58:39.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.450] - Launch lazy future ...
[10:58:39.451] Packages needed by the future expression (n = 0): <none>
[10:58:39.451] Packages needed by future strategies (n = 0): <none>
[10:58:39.451] {
[10:58:39.451]     {
[10:58:39.451]         {
[10:58:39.451]             ...future.startTime <- base::Sys.time()
[10:58:39.451]             {
[10:58:39.451]                 {
[10:58:39.451]                   {
[10:58:39.451]                     {
[10:58:39.451]                       base::local({
[10:58:39.451]                         has_future <- base::requireNamespace("future", 
[10:58:39.451]                           quietly = TRUE)
[10:58:39.451]                         if (has_future) {
[10:58:39.451]                           ns <- base::getNamespace("future")
[10:58:39.451]                           version <- ns[[".package"]][["version"]]
[10:58:39.451]                           if (is.null(version)) 
[10:58:39.451]                             version <- utils::packageVersion("future")
[10:58:39.451]                         }
[10:58:39.451]                         else {
[10:58:39.451]                           version <- NULL
[10:58:39.451]                         }
[10:58:39.451]                         if (!has_future || version < "1.8.0") {
[10:58:39.451]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.451]                             "", base::R.version$version.string), 
[10:58:39.451]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.451]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.451]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.451]                               "release", "version")], collapse = " "), 
[10:58:39.451]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.451]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.451]                             info)
[10:58:39.451]                           info <- base::paste(info, collapse = "; ")
[10:58:39.451]                           if (!has_future) {
[10:58:39.451]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.451]                               info)
[10:58:39.451]                           }
[10:58:39.451]                           else {
[10:58:39.451]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.451]                               info, version)
[10:58:39.451]                           }
[10:58:39.451]                           base::stop(msg)
[10:58:39.451]                         }
[10:58:39.451]                       })
[10:58:39.451]                     }
[10:58:39.451]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.451]                     base::options(mc.cores = 1L)
[10:58:39.451]                   }
[10:58:39.451]                   ...future.strategy.old <- future::plan("list")
[10:58:39.451]                   options(future.plan = NULL)
[10:58:39.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.451]                 }
[10:58:39.451]                 ...future.workdir <- getwd()
[10:58:39.451]             }
[10:58:39.451]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.451]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.451]         }
[10:58:39.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.451]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.451]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.451]             base::names(...future.oldOptions))
[10:58:39.451]     }
[10:58:39.451]     if (FALSE) {
[10:58:39.451]     }
[10:58:39.451]     else {
[10:58:39.451]         if (TRUE) {
[10:58:39.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.451]                 open = "w")
[10:58:39.451]         }
[10:58:39.451]         else {
[10:58:39.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.451]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.451]         }
[10:58:39.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.451]             base::sink(type = "output", split = FALSE)
[10:58:39.451]             base::close(...future.stdout)
[10:58:39.451]         }, add = TRUE)
[10:58:39.451]     }
[10:58:39.451]     ...future.frame <- base::sys.nframe()
[10:58:39.451]     ...future.conditions <- base::list()
[10:58:39.451]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.451]     if (FALSE) {
[10:58:39.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.451]     }
[10:58:39.451]     ...future.result <- base::tryCatch({
[10:58:39.451]         base::withCallingHandlers({
[10:58:39.451]             ...future.value <- base::withVisible(base::local({
[10:58:39.451]                 withCallingHandlers({
[10:58:39.451]                   {
[10:58:39.451]                     do.call(function(...) {
[10:58:39.451]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.451]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.451]                         ...future.globals.maxSize)) {
[10:58:39.451]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.451]                         on.exit(options(oopts), add = TRUE)
[10:58:39.451]                       }
[10:58:39.451]                       {
[10:58:39.451]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.451]                           FUN = function(jj) {
[10:58:39.451]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.451]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.451]                           })
[10:58:39.451]                       }
[10:58:39.451]                     }, args = future.call.arguments)
[10:58:39.451]                   }
[10:58:39.451]                 }, immediateCondition = function(cond) {
[10:58:39.451]                   save_rds <- function (object, pathname, ...) 
[10:58:39.451]                   {
[10:58:39.451]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.451]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.451]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.451]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.451]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.451]                         fi_tmp[["mtime"]])
[10:58:39.451]                     }
[10:58:39.451]                     tryCatch({
[10:58:39.451]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.451]                     }, error = function(ex) {
[10:58:39.451]                       msg <- conditionMessage(ex)
[10:58:39.451]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.451]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.451]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.451]                         fi_tmp[["mtime"]], msg)
[10:58:39.451]                       ex$message <- msg
[10:58:39.451]                       stop(ex)
[10:58:39.451]                     })
[10:58:39.451]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.451]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.451]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.451]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.451]                       fi <- file.info(pathname)
[10:58:39.451]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.451]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.451]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.451]                         fi[["size"]], fi[["mtime"]])
[10:58:39.451]                       stop(msg)
[10:58:39.451]                     }
[10:58:39.451]                     invisible(pathname)
[10:58:39.451]                   }
[10:58:39.451]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.451]                     rootPath = tempdir()) 
[10:58:39.451]                   {
[10:58:39.451]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.451]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.451]                       tmpdir = path, fileext = ".rds")
[10:58:39.451]                     save_rds(obj, file)
[10:58:39.451]                   }
[10:58:39.451]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.451]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.451]                   {
[10:58:39.451]                     inherits <- base::inherits
[10:58:39.451]                     invokeRestart <- base::invokeRestart
[10:58:39.451]                     is.null <- base::is.null
[10:58:39.451]                     muffled <- FALSE
[10:58:39.451]                     if (inherits(cond, "message")) {
[10:58:39.451]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.451]                       if (muffled) 
[10:58:39.451]                         invokeRestart("muffleMessage")
[10:58:39.451]                     }
[10:58:39.451]                     else if (inherits(cond, "warning")) {
[10:58:39.451]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.451]                       if (muffled) 
[10:58:39.451]                         invokeRestart("muffleWarning")
[10:58:39.451]                     }
[10:58:39.451]                     else if (inherits(cond, "condition")) {
[10:58:39.451]                       if (!is.null(pattern)) {
[10:58:39.451]                         computeRestarts <- base::computeRestarts
[10:58:39.451]                         grepl <- base::grepl
[10:58:39.451]                         restarts <- computeRestarts(cond)
[10:58:39.451]                         for (restart in restarts) {
[10:58:39.451]                           name <- restart$name
[10:58:39.451]                           if (is.null(name)) 
[10:58:39.451]                             next
[10:58:39.451]                           if (!grepl(pattern, name)) 
[10:58:39.451]                             next
[10:58:39.451]                           invokeRestart(restart)
[10:58:39.451]                           muffled <- TRUE
[10:58:39.451]                           break
[10:58:39.451]                         }
[10:58:39.451]                       }
[10:58:39.451]                     }
[10:58:39.451]                     invisible(muffled)
[10:58:39.451]                   }
[10:58:39.451]                   muffleCondition(cond)
[10:58:39.451]                 })
[10:58:39.451]             }))
[10:58:39.451]             future::FutureResult(value = ...future.value$value, 
[10:58:39.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.451]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.451]                     ...future.globalenv.names))
[10:58:39.451]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.451]         }, condition = base::local({
[10:58:39.451]             c <- base::c
[10:58:39.451]             inherits <- base::inherits
[10:58:39.451]             invokeRestart <- base::invokeRestart
[10:58:39.451]             length <- base::length
[10:58:39.451]             list <- base::list
[10:58:39.451]             seq.int <- base::seq.int
[10:58:39.451]             signalCondition <- base::signalCondition
[10:58:39.451]             sys.calls <- base::sys.calls
[10:58:39.451]             `[[` <- base::`[[`
[10:58:39.451]             `+` <- base::`+`
[10:58:39.451]             `<<-` <- base::`<<-`
[10:58:39.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.451]                   3L)]
[10:58:39.451]             }
[10:58:39.451]             function(cond) {
[10:58:39.451]                 is_error <- inherits(cond, "error")
[10:58:39.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.451]                   NULL)
[10:58:39.451]                 if (is_error) {
[10:58:39.451]                   sessionInformation <- function() {
[10:58:39.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.451]                       search = base::search(), system = base::Sys.info())
[10:58:39.451]                   }
[10:58:39.451]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.451]                     cond$call), session = sessionInformation(), 
[10:58:39.451]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.451]                   signalCondition(cond)
[10:58:39.451]                 }
[10:58:39.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.451]                 "immediateCondition"))) {
[10:58:39.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.451]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.451]                   if (TRUE && !signal) {
[10:58:39.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.451]                     {
[10:58:39.451]                       inherits <- base::inherits
[10:58:39.451]                       invokeRestart <- base::invokeRestart
[10:58:39.451]                       is.null <- base::is.null
[10:58:39.451]                       muffled <- FALSE
[10:58:39.451]                       if (inherits(cond, "message")) {
[10:58:39.451]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.451]                         if (muffled) 
[10:58:39.451]                           invokeRestart("muffleMessage")
[10:58:39.451]                       }
[10:58:39.451]                       else if (inherits(cond, "warning")) {
[10:58:39.451]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.451]                         if (muffled) 
[10:58:39.451]                           invokeRestart("muffleWarning")
[10:58:39.451]                       }
[10:58:39.451]                       else if (inherits(cond, "condition")) {
[10:58:39.451]                         if (!is.null(pattern)) {
[10:58:39.451]                           computeRestarts <- base::computeRestarts
[10:58:39.451]                           grepl <- base::grepl
[10:58:39.451]                           restarts <- computeRestarts(cond)
[10:58:39.451]                           for (restart in restarts) {
[10:58:39.451]                             name <- restart$name
[10:58:39.451]                             if (is.null(name)) 
[10:58:39.451]                               next
[10:58:39.451]                             if (!grepl(pattern, name)) 
[10:58:39.451]                               next
[10:58:39.451]                             invokeRestart(restart)
[10:58:39.451]                             muffled <- TRUE
[10:58:39.451]                             break
[10:58:39.451]                           }
[10:58:39.451]                         }
[10:58:39.451]                       }
[10:58:39.451]                       invisible(muffled)
[10:58:39.451]                     }
[10:58:39.451]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.451]                   }
[10:58:39.451]                 }
[10:58:39.451]                 else {
[10:58:39.451]                   if (TRUE) {
[10:58:39.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.451]                     {
[10:58:39.451]                       inherits <- base::inherits
[10:58:39.451]                       invokeRestart <- base::invokeRestart
[10:58:39.451]                       is.null <- base::is.null
[10:58:39.451]                       muffled <- FALSE
[10:58:39.451]                       if (inherits(cond, "message")) {
[10:58:39.451]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.451]                         if (muffled) 
[10:58:39.451]                           invokeRestart("muffleMessage")
[10:58:39.451]                       }
[10:58:39.451]                       else if (inherits(cond, "warning")) {
[10:58:39.451]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.451]                         if (muffled) 
[10:58:39.451]                           invokeRestart("muffleWarning")
[10:58:39.451]                       }
[10:58:39.451]                       else if (inherits(cond, "condition")) {
[10:58:39.451]                         if (!is.null(pattern)) {
[10:58:39.451]                           computeRestarts <- base::computeRestarts
[10:58:39.451]                           grepl <- base::grepl
[10:58:39.451]                           restarts <- computeRestarts(cond)
[10:58:39.451]                           for (restart in restarts) {
[10:58:39.451]                             name <- restart$name
[10:58:39.451]                             if (is.null(name)) 
[10:58:39.451]                               next
[10:58:39.451]                             if (!grepl(pattern, name)) 
[10:58:39.451]                               next
[10:58:39.451]                             invokeRestart(restart)
[10:58:39.451]                             muffled <- TRUE
[10:58:39.451]                             break
[10:58:39.451]                           }
[10:58:39.451]                         }
[10:58:39.451]                       }
[10:58:39.451]                       invisible(muffled)
[10:58:39.451]                     }
[10:58:39.451]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.451]                   }
[10:58:39.451]                 }
[10:58:39.451]             }
[10:58:39.451]         }))
[10:58:39.451]     }, error = function(ex) {
[10:58:39.451]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.451]                 ...future.rng), started = ...future.startTime, 
[10:58:39.451]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.451]             version = "1.8"), class = "FutureResult")
[10:58:39.451]     }, finally = {
[10:58:39.451]         if (!identical(...future.workdir, getwd())) 
[10:58:39.451]             setwd(...future.workdir)
[10:58:39.451]         {
[10:58:39.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.451]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.451]             }
[10:58:39.451]             base::options(...future.oldOptions)
[10:58:39.451]             if (.Platform$OS.type == "windows") {
[10:58:39.451]                 old_names <- names(...future.oldEnvVars)
[10:58:39.451]                 envs <- base::Sys.getenv()
[10:58:39.451]                 names <- names(envs)
[10:58:39.451]                 common <- intersect(names, old_names)
[10:58:39.451]                 added <- setdiff(names, old_names)
[10:58:39.451]                 removed <- setdiff(old_names, names)
[10:58:39.451]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.451]                   envs[common]]
[10:58:39.451]                 NAMES <- toupper(changed)
[10:58:39.451]                 args <- list()
[10:58:39.451]                 for (kk in seq_along(NAMES)) {
[10:58:39.451]                   name <- changed[[kk]]
[10:58:39.451]                   NAME <- NAMES[[kk]]
[10:58:39.451]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.451]                     next
[10:58:39.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.451]                 }
[10:58:39.451]                 NAMES <- toupper(added)
[10:58:39.451]                 for (kk in seq_along(NAMES)) {
[10:58:39.451]                   name <- added[[kk]]
[10:58:39.451]                   NAME <- NAMES[[kk]]
[10:58:39.451]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.451]                     next
[10:58:39.451]                   args[[name]] <- ""
[10:58:39.451]                 }
[10:58:39.451]                 NAMES <- toupper(removed)
[10:58:39.451]                 for (kk in seq_along(NAMES)) {
[10:58:39.451]                   name <- removed[[kk]]
[10:58:39.451]                   NAME <- NAMES[[kk]]
[10:58:39.451]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.451]                     next
[10:58:39.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.451]                 }
[10:58:39.451]                 if (length(args) > 0) 
[10:58:39.451]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.451]             }
[10:58:39.451]             else {
[10:58:39.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.451]             }
[10:58:39.451]             {
[10:58:39.451]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.451]                   0L) {
[10:58:39.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.451]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.451]                   base::options(opts)
[10:58:39.451]                 }
[10:58:39.451]                 {
[10:58:39.451]                   {
[10:58:39.451]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.451]                     NULL
[10:58:39.451]                   }
[10:58:39.451]                   options(future.plan = NULL)
[10:58:39.451]                   if (is.na(NA_character_)) 
[10:58:39.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.451]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.451]                     .init = FALSE)
[10:58:39.451]                 }
[10:58:39.451]             }
[10:58:39.451]         }
[10:58:39.451]     })
[10:58:39.451]     if (TRUE) {
[10:58:39.451]         base::sink(type = "output", split = FALSE)
[10:58:39.451]         if (TRUE) {
[10:58:39.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.451]         }
[10:58:39.451]         else {
[10:58:39.451]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.451]         }
[10:58:39.451]         base::close(...future.stdout)
[10:58:39.451]         ...future.stdout <- NULL
[10:58:39.451]     }
[10:58:39.451]     ...future.result$conditions <- ...future.conditions
[10:58:39.451]     ...future.result$finished <- base::Sys.time()
[10:58:39.451]     ...future.result
[10:58:39.451] }
[10:58:39.454] assign_globals() ...
[10:58:39.454] List of 5
[10:58:39.454]  $ future.call.arguments    : list()
[10:58:39.454]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.454]  $ ...future.FUN            :function (x)  
[10:58:39.454]  $ ...future.elements_ii    :List of 3
[10:58:39.454]   ..$ : int [1:4] 1 7 13 19
[10:58:39.454]   ..$ : int [1:4] 2 8 14 20
[10:58:39.454]   ..$ : int [1:4] 3 9 15 21
[10:58:39.454]  $ ...future.seeds_ii       : NULL
[10:58:39.454]  $ ...future.globals.maxSize: num Inf
[10:58:39.454]  - attr(*, "resolved")= logi FALSE
[10:58:39.454]  - attr(*, "total_size")= num NA
[10:58:39.454]  - attr(*, "where")=List of 5
[10:58:39.454]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.454]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.454]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.454]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.454]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.454]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.454]  - attr(*, "already-done")= logi TRUE
[10:58:39.459] - copied ‘future.call.arguments’ to environment
[10:58:39.459] - reassign environment for ‘...future.FUN’
[10:58:39.459] - copied ‘...future.FUN’ to environment
[10:58:39.459] - copied ‘...future.elements_ii’ to environment
[10:58:39.459] - copied ‘...future.seeds_ii’ to environment
[10:58:39.459] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.459] assign_globals() ... done
[10:58:39.459] requestCore(): workers = 2
[10:58:39.461] MulticoreFuture started
[10:58:39.461] - Launch lazy future ... done
[10:58:39.461] run() for ‘MulticoreFuture’ ... done
[10:58:39.462] Created future:
[10:58:39.462] plan(): Setting new future strategy stack:
[10:58:39.462] List of future strategies:
[10:58:39.462] 1. sequential:
[10:58:39.462]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.462]    - tweaked: FALSE
[10:58:39.462]    - call: NULL
[10:58:39.463] plan(): nbrOfWorkers() = 1
[10:58:39.465] plan(): Setting new future strategy stack:
[10:58:39.465] List of future strategies:
[10:58:39.465] 1. multicore:
[10:58:39.465]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.465]    - tweaked: FALSE
[10:58:39.465]    - call: plan(strategy)
[10:58:39.468] plan(): nbrOfWorkers() = 2
[10:58:39.462] MulticoreFuture:
[10:58:39.462] Label: ‘future_apply-1’
[10:58:39.462] Expression:
[10:58:39.462] {
[10:58:39.462]     do.call(function(...) {
[10:58:39.462]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.462]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.462]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.462]             on.exit(options(oopts), add = TRUE)
[10:58:39.462]         }
[10:58:39.462]         {
[10:58:39.462]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.462]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.462]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.462]             })
[10:58:39.462]         }
[10:58:39.462]     }, args = future.call.arguments)
[10:58:39.462] }
[10:58:39.462] Lazy evaluation: FALSE
[10:58:39.462] Asynchronous evaluation: TRUE
[10:58:39.462] Local evaluation: TRUE
[10:58:39.462] Environment: R_GlobalEnv
[10:58:39.462] Capture standard output: TRUE
[10:58:39.462] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.462] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.462] Packages: <none>
[10:58:39.462] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.462] Resolved: TRUE
[10:58:39.462] Value: <not collected>
[10:58:39.462] Conditions captured: <none>
[10:58:39.462] Early signaling: FALSE
[10:58:39.462] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.462] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.469] Chunk #1 of 2 ... DONE
[10:58:39.469] Chunk #2 of 2 ...
[10:58:39.470]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.470]  - seeds: <none>
[10:58:39.470]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.470] getGlobalsAndPackages() ...
[10:58:39.470] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.470] Resolving globals: FALSE
[10:58:39.470] Tweak future expression to call with '...' arguments ...
[10:58:39.471] {
[10:58:39.471]     do.call(function(...) {
[10:58:39.471]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.471]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.471]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.471]             on.exit(options(oopts), add = TRUE)
[10:58:39.471]         }
[10:58:39.471]         {
[10:58:39.471]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.471]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.471]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.471]             })
[10:58:39.471]         }
[10:58:39.471]     }, args = future.call.arguments)
[10:58:39.471] }
[10:58:39.471] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.471] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.472] 
[10:58:39.472] getGlobalsAndPackages() ... DONE
[10:58:39.472] run() for ‘Future’ ...
[10:58:39.472] - state: ‘created’
[10:58:39.473] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.475] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.475] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.475]   - Field: ‘label’
[10:58:39.476]   - Field: ‘local’
[10:58:39.476]   - Field: ‘owner’
[10:58:39.476]   - Field: ‘envir’
[10:58:39.476]   - Field: ‘workers’
[10:58:39.476]   - Field: ‘packages’
[10:58:39.476]   - Field: ‘gc’
[10:58:39.476]   - Field: ‘job’
[10:58:39.477]   - Field: ‘conditions’
[10:58:39.477]   - Field: ‘expr’
[10:58:39.477]   - Field: ‘uuid’
[10:58:39.477]   - Field: ‘seed’
[10:58:39.477]   - Field: ‘version’
[10:58:39.477]   - Field: ‘result’
[10:58:39.477]   - Field: ‘asynchronous’
[10:58:39.478]   - Field: ‘calls’
[10:58:39.478]   - Field: ‘globals’
[10:58:39.478]   - Field: ‘stdout’
[10:58:39.478]   - Field: ‘earlySignal’
[10:58:39.478]   - Field: ‘lazy’
[10:58:39.478]   - Field: ‘state’
[10:58:39.478] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.481] - Launch lazy future ...
[10:58:39.482] Packages needed by the future expression (n = 0): <none>
[10:58:39.482] Packages needed by future strategies (n = 0): <none>
[10:58:39.483] {
[10:58:39.483]     {
[10:58:39.483]         {
[10:58:39.483]             ...future.startTime <- base::Sys.time()
[10:58:39.483]             {
[10:58:39.483]                 {
[10:58:39.483]                   {
[10:58:39.483]                     {
[10:58:39.483]                       base::local({
[10:58:39.483]                         has_future <- base::requireNamespace("future", 
[10:58:39.483]                           quietly = TRUE)
[10:58:39.483]                         if (has_future) {
[10:58:39.483]                           ns <- base::getNamespace("future")
[10:58:39.483]                           version <- ns[[".package"]][["version"]]
[10:58:39.483]                           if (is.null(version)) 
[10:58:39.483]                             version <- utils::packageVersion("future")
[10:58:39.483]                         }
[10:58:39.483]                         else {
[10:58:39.483]                           version <- NULL
[10:58:39.483]                         }
[10:58:39.483]                         if (!has_future || version < "1.8.0") {
[10:58:39.483]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.483]                             "", base::R.version$version.string), 
[10:58:39.483]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.483]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.483]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.483]                               "release", "version")], collapse = " "), 
[10:58:39.483]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.483]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.483]                             info)
[10:58:39.483]                           info <- base::paste(info, collapse = "; ")
[10:58:39.483]                           if (!has_future) {
[10:58:39.483]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.483]                               info)
[10:58:39.483]                           }
[10:58:39.483]                           else {
[10:58:39.483]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.483]                               info, version)
[10:58:39.483]                           }
[10:58:39.483]                           base::stop(msg)
[10:58:39.483]                         }
[10:58:39.483]                       })
[10:58:39.483]                     }
[10:58:39.483]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.483]                     base::options(mc.cores = 1L)
[10:58:39.483]                   }
[10:58:39.483]                   ...future.strategy.old <- future::plan("list")
[10:58:39.483]                   options(future.plan = NULL)
[10:58:39.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.483]                 }
[10:58:39.483]                 ...future.workdir <- getwd()
[10:58:39.483]             }
[10:58:39.483]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.483]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.483]         }
[10:58:39.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.483]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.483]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.483]             base::names(...future.oldOptions))
[10:58:39.483]     }
[10:58:39.483]     if (FALSE) {
[10:58:39.483]     }
[10:58:39.483]     else {
[10:58:39.483]         if (TRUE) {
[10:58:39.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.483]                 open = "w")
[10:58:39.483]         }
[10:58:39.483]         else {
[10:58:39.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.483]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.483]         }
[10:58:39.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.483]             base::sink(type = "output", split = FALSE)
[10:58:39.483]             base::close(...future.stdout)
[10:58:39.483]         }, add = TRUE)
[10:58:39.483]     }
[10:58:39.483]     ...future.frame <- base::sys.nframe()
[10:58:39.483]     ...future.conditions <- base::list()
[10:58:39.483]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.483]     if (FALSE) {
[10:58:39.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.483]     }
[10:58:39.483]     ...future.result <- base::tryCatch({
[10:58:39.483]         base::withCallingHandlers({
[10:58:39.483]             ...future.value <- base::withVisible(base::local({
[10:58:39.483]                 withCallingHandlers({
[10:58:39.483]                   {
[10:58:39.483]                     do.call(function(...) {
[10:58:39.483]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.483]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.483]                         ...future.globals.maxSize)) {
[10:58:39.483]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.483]                         on.exit(options(oopts), add = TRUE)
[10:58:39.483]                       }
[10:58:39.483]                       {
[10:58:39.483]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.483]                           FUN = function(jj) {
[10:58:39.483]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.483]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.483]                           })
[10:58:39.483]                       }
[10:58:39.483]                     }, args = future.call.arguments)
[10:58:39.483]                   }
[10:58:39.483]                 }, immediateCondition = function(cond) {
[10:58:39.483]                   save_rds <- function (object, pathname, ...) 
[10:58:39.483]                   {
[10:58:39.483]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.483]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.483]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.483]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.483]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.483]                         fi_tmp[["mtime"]])
[10:58:39.483]                     }
[10:58:39.483]                     tryCatch({
[10:58:39.483]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.483]                     }, error = function(ex) {
[10:58:39.483]                       msg <- conditionMessage(ex)
[10:58:39.483]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.483]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.483]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.483]                         fi_tmp[["mtime"]], msg)
[10:58:39.483]                       ex$message <- msg
[10:58:39.483]                       stop(ex)
[10:58:39.483]                     })
[10:58:39.483]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.483]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.483]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.483]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.483]                       fi <- file.info(pathname)
[10:58:39.483]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.483]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.483]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.483]                         fi[["size"]], fi[["mtime"]])
[10:58:39.483]                       stop(msg)
[10:58:39.483]                     }
[10:58:39.483]                     invisible(pathname)
[10:58:39.483]                   }
[10:58:39.483]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.483]                     rootPath = tempdir()) 
[10:58:39.483]                   {
[10:58:39.483]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.483]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.483]                       tmpdir = path, fileext = ".rds")
[10:58:39.483]                     save_rds(obj, file)
[10:58:39.483]                   }
[10:58:39.483]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.483]                   {
[10:58:39.483]                     inherits <- base::inherits
[10:58:39.483]                     invokeRestart <- base::invokeRestart
[10:58:39.483]                     is.null <- base::is.null
[10:58:39.483]                     muffled <- FALSE
[10:58:39.483]                     if (inherits(cond, "message")) {
[10:58:39.483]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.483]                       if (muffled) 
[10:58:39.483]                         invokeRestart("muffleMessage")
[10:58:39.483]                     }
[10:58:39.483]                     else if (inherits(cond, "warning")) {
[10:58:39.483]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.483]                       if (muffled) 
[10:58:39.483]                         invokeRestart("muffleWarning")
[10:58:39.483]                     }
[10:58:39.483]                     else if (inherits(cond, "condition")) {
[10:58:39.483]                       if (!is.null(pattern)) {
[10:58:39.483]                         computeRestarts <- base::computeRestarts
[10:58:39.483]                         grepl <- base::grepl
[10:58:39.483]                         restarts <- computeRestarts(cond)
[10:58:39.483]                         for (restart in restarts) {
[10:58:39.483]                           name <- restart$name
[10:58:39.483]                           if (is.null(name)) 
[10:58:39.483]                             next
[10:58:39.483]                           if (!grepl(pattern, name)) 
[10:58:39.483]                             next
[10:58:39.483]                           invokeRestart(restart)
[10:58:39.483]                           muffled <- TRUE
[10:58:39.483]                           break
[10:58:39.483]                         }
[10:58:39.483]                       }
[10:58:39.483]                     }
[10:58:39.483]                     invisible(muffled)
[10:58:39.483]                   }
[10:58:39.483]                   muffleCondition(cond)
[10:58:39.483]                 })
[10:58:39.483]             }))
[10:58:39.483]             future::FutureResult(value = ...future.value$value, 
[10:58:39.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.483]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.483]                     ...future.globalenv.names))
[10:58:39.483]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.483]         }, condition = base::local({
[10:58:39.483]             c <- base::c
[10:58:39.483]             inherits <- base::inherits
[10:58:39.483]             invokeRestart <- base::invokeRestart
[10:58:39.483]             length <- base::length
[10:58:39.483]             list <- base::list
[10:58:39.483]             seq.int <- base::seq.int
[10:58:39.483]             signalCondition <- base::signalCondition
[10:58:39.483]             sys.calls <- base::sys.calls
[10:58:39.483]             `[[` <- base::`[[`
[10:58:39.483]             `+` <- base::`+`
[10:58:39.483]             `<<-` <- base::`<<-`
[10:58:39.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.483]                   3L)]
[10:58:39.483]             }
[10:58:39.483]             function(cond) {
[10:58:39.483]                 is_error <- inherits(cond, "error")
[10:58:39.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.483]                   NULL)
[10:58:39.483]                 if (is_error) {
[10:58:39.483]                   sessionInformation <- function() {
[10:58:39.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.483]                       search = base::search(), system = base::Sys.info())
[10:58:39.483]                   }
[10:58:39.483]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.483]                     cond$call), session = sessionInformation(), 
[10:58:39.483]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.483]                   signalCondition(cond)
[10:58:39.483]                 }
[10:58:39.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.483]                 "immediateCondition"))) {
[10:58:39.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.483]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.483]                   if (TRUE && !signal) {
[10:58:39.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.483]                     {
[10:58:39.483]                       inherits <- base::inherits
[10:58:39.483]                       invokeRestart <- base::invokeRestart
[10:58:39.483]                       is.null <- base::is.null
[10:58:39.483]                       muffled <- FALSE
[10:58:39.483]                       if (inherits(cond, "message")) {
[10:58:39.483]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.483]                         if (muffled) 
[10:58:39.483]                           invokeRestart("muffleMessage")
[10:58:39.483]                       }
[10:58:39.483]                       else if (inherits(cond, "warning")) {
[10:58:39.483]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.483]                         if (muffled) 
[10:58:39.483]                           invokeRestart("muffleWarning")
[10:58:39.483]                       }
[10:58:39.483]                       else if (inherits(cond, "condition")) {
[10:58:39.483]                         if (!is.null(pattern)) {
[10:58:39.483]                           computeRestarts <- base::computeRestarts
[10:58:39.483]                           grepl <- base::grepl
[10:58:39.483]                           restarts <- computeRestarts(cond)
[10:58:39.483]                           for (restart in restarts) {
[10:58:39.483]                             name <- restart$name
[10:58:39.483]                             if (is.null(name)) 
[10:58:39.483]                               next
[10:58:39.483]                             if (!grepl(pattern, name)) 
[10:58:39.483]                               next
[10:58:39.483]                             invokeRestart(restart)
[10:58:39.483]                             muffled <- TRUE
[10:58:39.483]                             break
[10:58:39.483]                           }
[10:58:39.483]                         }
[10:58:39.483]                       }
[10:58:39.483]                       invisible(muffled)
[10:58:39.483]                     }
[10:58:39.483]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.483]                   }
[10:58:39.483]                 }
[10:58:39.483]                 else {
[10:58:39.483]                   if (TRUE) {
[10:58:39.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.483]                     {
[10:58:39.483]                       inherits <- base::inherits
[10:58:39.483]                       invokeRestart <- base::invokeRestart
[10:58:39.483]                       is.null <- base::is.null
[10:58:39.483]                       muffled <- FALSE
[10:58:39.483]                       if (inherits(cond, "message")) {
[10:58:39.483]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.483]                         if (muffled) 
[10:58:39.483]                           invokeRestart("muffleMessage")
[10:58:39.483]                       }
[10:58:39.483]                       else if (inherits(cond, "warning")) {
[10:58:39.483]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.483]                         if (muffled) 
[10:58:39.483]                           invokeRestart("muffleWarning")
[10:58:39.483]                       }
[10:58:39.483]                       else if (inherits(cond, "condition")) {
[10:58:39.483]                         if (!is.null(pattern)) {
[10:58:39.483]                           computeRestarts <- base::computeRestarts
[10:58:39.483]                           grepl <- base::grepl
[10:58:39.483]                           restarts <- computeRestarts(cond)
[10:58:39.483]                           for (restart in restarts) {
[10:58:39.483]                             name <- restart$name
[10:58:39.483]                             if (is.null(name)) 
[10:58:39.483]                               next
[10:58:39.483]                             if (!grepl(pattern, name)) 
[10:58:39.483]                               next
[10:58:39.483]                             invokeRestart(restart)
[10:58:39.483]                             muffled <- TRUE
[10:58:39.483]                             break
[10:58:39.483]                           }
[10:58:39.483]                         }
[10:58:39.483]                       }
[10:58:39.483]                       invisible(muffled)
[10:58:39.483]                     }
[10:58:39.483]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.483]                   }
[10:58:39.483]                 }
[10:58:39.483]             }
[10:58:39.483]         }))
[10:58:39.483]     }, error = function(ex) {
[10:58:39.483]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.483]                 ...future.rng), started = ...future.startTime, 
[10:58:39.483]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.483]             version = "1.8"), class = "FutureResult")
[10:58:39.483]     }, finally = {
[10:58:39.483]         if (!identical(...future.workdir, getwd())) 
[10:58:39.483]             setwd(...future.workdir)
[10:58:39.483]         {
[10:58:39.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.483]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.483]             }
[10:58:39.483]             base::options(...future.oldOptions)
[10:58:39.483]             if (.Platform$OS.type == "windows") {
[10:58:39.483]                 old_names <- names(...future.oldEnvVars)
[10:58:39.483]                 envs <- base::Sys.getenv()
[10:58:39.483]                 names <- names(envs)
[10:58:39.483]                 common <- intersect(names, old_names)
[10:58:39.483]                 added <- setdiff(names, old_names)
[10:58:39.483]                 removed <- setdiff(old_names, names)
[10:58:39.483]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.483]                   envs[common]]
[10:58:39.483]                 NAMES <- toupper(changed)
[10:58:39.483]                 args <- list()
[10:58:39.483]                 for (kk in seq_along(NAMES)) {
[10:58:39.483]                   name <- changed[[kk]]
[10:58:39.483]                   NAME <- NAMES[[kk]]
[10:58:39.483]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.483]                     next
[10:58:39.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.483]                 }
[10:58:39.483]                 NAMES <- toupper(added)
[10:58:39.483]                 for (kk in seq_along(NAMES)) {
[10:58:39.483]                   name <- added[[kk]]
[10:58:39.483]                   NAME <- NAMES[[kk]]
[10:58:39.483]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.483]                     next
[10:58:39.483]                   args[[name]] <- ""
[10:58:39.483]                 }
[10:58:39.483]                 NAMES <- toupper(removed)
[10:58:39.483]                 for (kk in seq_along(NAMES)) {
[10:58:39.483]                   name <- removed[[kk]]
[10:58:39.483]                   NAME <- NAMES[[kk]]
[10:58:39.483]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.483]                     next
[10:58:39.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.483]                 }
[10:58:39.483]                 if (length(args) > 0) 
[10:58:39.483]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.483]             }
[10:58:39.483]             else {
[10:58:39.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.483]             }
[10:58:39.483]             {
[10:58:39.483]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.483]                   0L) {
[10:58:39.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.483]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.483]                   base::options(opts)
[10:58:39.483]                 }
[10:58:39.483]                 {
[10:58:39.483]                   {
[10:58:39.483]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.483]                     NULL
[10:58:39.483]                   }
[10:58:39.483]                   options(future.plan = NULL)
[10:58:39.483]                   if (is.na(NA_character_)) 
[10:58:39.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.483]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.483]                     .init = FALSE)
[10:58:39.483]                 }
[10:58:39.483]             }
[10:58:39.483]         }
[10:58:39.483]     })
[10:58:39.483]     if (TRUE) {
[10:58:39.483]         base::sink(type = "output", split = FALSE)
[10:58:39.483]         if (TRUE) {
[10:58:39.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.483]         }
[10:58:39.483]         else {
[10:58:39.483]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.483]         }
[10:58:39.483]         base::close(...future.stdout)
[10:58:39.483]         ...future.stdout <- NULL
[10:58:39.483]     }
[10:58:39.483]     ...future.result$conditions <- ...future.conditions
[10:58:39.483]     ...future.result$finished <- base::Sys.time()
[10:58:39.483]     ...future.result
[10:58:39.483] }
[10:58:39.487] assign_globals() ...
[10:58:39.487] List of 5
[10:58:39.487]  $ future.call.arguments    : list()
[10:58:39.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.487]  $ ...future.FUN            :function (x)  
[10:58:39.487]  $ ...future.elements_ii    :List of 3
[10:58:39.487]   ..$ : int [1:4] 4 10 16 22
[10:58:39.487]   ..$ : int [1:4] 5 11 17 23
[10:58:39.487]   ..$ : int [1:4] 6 12 18 24
[10:58:39.487]  $ ...future.seeds_ii       : NULL
[10:58:39.487]  $ ...future.globals.maxSize: num Inf
[10:58:39.487]  - attr(*, "resolved")= logi FALSE
[10:58:39.487]  - attr(*, "total_size")= num NA
[10:58:39.487]  - attr(*, "where")=List of 5
[10:58:39.487]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.487]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.487]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.487]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.487]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.487]  - attr(*, "already-done")= logi TRUE
[10:58:39.496] - copied ‘future.call.arguments’ to environment
[10:58:39.496] - reassign environment for ‘...future.FUN’
[10:58:39.497] - copied ‘...future.FUN’ to environment
[10:58:39.497] - copied ‘...future.elements_ii’ to environment
[10:58:39.497] - copied ‘...future.seeds_ii’ to environment
[10:58:39.497] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.497] assign_globals() ... done
[10:58:39.497] requestCore(): workers = 2
[10:58:39.499] MulticoreFuture started
[10:58:39.500] - Launch lazy future ... done
[10:58:39.500] run() for ‘MulticoreFuture’ ... done
[10:58:39.500] Created future:
[10:58:39.500] plan(): Setting new future strategy stack:
[10:58:39.501] List of future strategies:
[10:58:39.501] 1. sequential:
[10:58:39.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.501]    - tweaked: FALSE
[10:58:39.501]    - call: NULL
[10:58:39.502] plan(): nbrOfWorkers() = 1
[10:58:39.504] plan(): Setting new future strategy stack:
[10:58:39.504] List of future strategies:
[10:58:39.504] 1. multicore:
[10:58:39.504]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.504]    - tweaked: FALSE
[10:58:39.504]    - call: plan(strategy)
[10:58:39.507] plan(): nbrOfWorkers() = 2
[10:58:39.501] MulticoreFuture:
[10:58:39.501] Label: ‘future_apply-2’
[10:58:39.501] Expression:
[10:58:39.501] {
[10:58:39.501]     do.call(function(...) {
[10:58:39.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.501]             on.exit(options(oopts), add = TRUE)
[10:58:39.501]         }
[10:58:39.501]         {
[10:58:39.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.501]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.501]             })
[10:58:39.501]         }
[10:58:39.501]     }, args = future.call.arguments)
[10:58:39.501] }
[10:58:39.501] Lazy evaluation: FALSE
[10:58:39.501] Asynchronous evaluation: TRUE
[10:58:39.501] Local evaluation: TRUE
[10:58:39.501] Environment: R_GlobalEnv
[10:58:39.501] Capture standard output: TRUE
[10:58:39.501] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.501] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.501] Packages: <none>
[10:58:39.501] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.501] Resolved: TRUE
[10:58:39.501] Value: <not collected>
[10:58:39.501] Conditions captured: <none>
[10:58:39.501] Early signaling: FALSE
[10:58:39.501] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.501] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.508] Chunk #2 of 2 ... DONE
[10:58:39.508] Launching 2 futures (chunks) ... DONE
[10:58:39.508] Resolving 2 futures (chunks) ...
[10:58:39.509] resolve() on list ...
[10:58:39.509]  recursive: 0
[10:58:39.509]  length: 2
[10:58:39.509] 
[10:58:39.509] Future #1
[10:58:39.509] result() for MulticoreFuture ...
[10:58:39.510] result() for MulticoreFuture ...
[10:58:39.511] result() for MulticoreFuture ... done
[10:58:39.511] result() for MulticoreFuture ... done
[10:58:39.511] result() for MulticoreFuture ...
[10:58:39.511] result() for MulticoreFuture ... done
[10:58:39.511] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:39.511] - nx: 2
[10:58:39.511] - relay: TRUE
[10:58:39.512] - stdout: TRUE
[10:58:39.512] - signal: TRUE
[10:58:39.512] - resignal: FALSE
[10:58:39.512] - force: TRUE
[10:58:39.512] - relayed: [n=2] FALSE, FALSE
[10:58:39.512] - queued futures: [n=2] FALSE, FALSE
[10:58:39.512]  - until=1
[10:58:39.512]  - relaying element #1
[10:58:39.513] result() for MulticoreFuture ...
[10:58:39.513] result() for MulticoreFuture ... done
[10:58:39.513] result() for MulticoreFuture ...
[10:58:39.513] result() for MulticoreFuture ... done
[10:58:39.513] result() for MulticoreFuture ...
[10:58:39.513] result() for MulticoreFuture ... done
[10:58:39.514] result() for MulticoreFuture ...
[10:58:39.514] result() for MulticoreFuture ... done
[10:58:39.514] - relayed: [n=2] TRUE, FALSE
[10:58:39.514] - queued futures: [n=2] TRUE, FALSE
[10:58:39.514] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:39.514]  length: 1 (resolved future 1)
[10:58:39.515] Future #2
[10:58:39.515] result() for MulticoreFuture ...
[10:58:39.515] result() for MulticoreFuture ...
[10:58:39.516] result() for MulticoreFuture ... done
[10:58:39.516] result() for MulticoreFuture ... done
[10:58:39.516] result() for MulticoreFuture ...
[10:58:39.516] result() for MulticoreFuture ... done
[10:58:39.516] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:39.516] - nx: 2
[10:58:39.516] - relay: TRUE
[10:58:39.517] - stdout: TRUE
[10:58:39.517] - signal: TRUE
[10:58:39.517] - resignal: FALSE
[10:58:39.517] - force: TRUE
[10:58:39.517] - relayed: [n=2] TRUE, FALSE
[10:58:39.517] - queued futures: [n=2] TRUE, FALSE
[10:58:39.517]  - until=2
[10:58:39.518]  - relaying element #2
[10:58:39.518] result() for MulticoreFuture ...
[10:58:39.518] result() for MulticoreFuture ... done
[10:58:39.518] result() for MulticoreFuture ...
[10:58:39.518] result() for MulticoreFuture ... done
[10:58:39.518] result() for MulticoreFuture ...
[10:58:39.518] result() for MulticoreFuture ... done
[10:58:39.518] result() for MulticoreFuture ...
[10:58:39.518] result() for MulticoreFuture ... done
[10:58:39.519] - relayed: [n=2] TRUE, TRUE
[10:58:39.519] - queued futures: [n=2] TRUE, TRUE
[10:58:39.519] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:39.519]  length: 0 (resolved future 2)
[10:58:39.519] Relaying remaining futures
[10:58:39.519] signalConditionsASAP(NULL, pos=0) ...
[10:58:39.519] - nx: 2
[10:58:39.519] - relay: TRUE
[10:58:39.519] - stdout: TRUE
[10:58:39.520] - signal: TRUE
[10:58:39.520] - resignal: FALSE
[10:58:39.520] - force: TRUE
[10:58:39.520] - relayed: [n=2] TRUE, TRUE
[10:58:39.520] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:39.520] - relayed: [n=2] TRUE, TRUE
[10:58:39.520] - queued futures: [n=2] TRUE, TRUE
[10:58:39.520] signalConditionsASAP(NULL, pos=0) ... done
[10:58:39.520] resolve() on list ... DONE
[10:58:39.521] result() for MulticoreFuture ...
[10:58:39.521] result() for MulticoreFuture ... done
[10:58:39.521] result() for MulticoreFuture ...
[10:58:39.521] result() for MulticoreFuture ... done
[10:58:39.521] result() for MulticoreFuture ...
[10:58:39.521] result() for MulticoreFuture ... done
[10:58:39.521] result() for MulticoreFuture ...
[10:58:39.521] result() for MulticoreFuture ... done
[10:58:39.521]  - Number of value chunks collected: 2
[10:58:39.522] Resolving 2 futures (chunks) ... DONE
[10:58:39.522] Reducing values from 2 chunks ...
[10:58:39.522]  - Number of values collected after concatenation: 6
[10:58:39.522]  - Number of values expected: 6
[10:58:39.522] Reducing values from 2 chunks ... DONE
[10:58:39.522] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:58:39.522] getGlobalsAndPackagesXApply() ...
[10:58:39.523]  - future.globals: TRUE
[10:58:39.523] getGlobalsAndPackages() ...
[10:58:39.523] Searching for globals...
[10:58:39.526] - globals found: [1] ‘FUN’
[10:58:39.527] Searching for globals ... DONE
[10:58:39.527] Resolving globals: FALSE
[10:58:39.527] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:39.528] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:39.528] - globals: [1] ‘FUN’
[10:58:39.528] 
[10:58:39.528] getGlobalsAndPackages() ... DONE
[10:58:39.528]  - globals found/used: [n=1] ‘FUN’
[10:58:39.529]  - needed namespaces: [n=0] 
[10:58:39.529] Finding globals ... DONE
[10:58:39.529]  - use_args: TRUE
[10:58:39.529]  - Getting '...' globals ...
[10:58:39.530] resolve() on list ...
[10:58:39.530]  recursive: 0
[10:58:39.530]  length: 1
[10:58:39.530]  elements: ‘...’
[10:58:39.530]  length: 0 (resolved future 1)
[10:58:39.530] resolve() on list ... DONE
[10:58:39.530]    - '...' content: [n=0] 
[10:58:39.531] List of 1
[10:58:39.531]  $ ...: list()
[10:58:39.531]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.531]  - attr(*, "where")=List of 1
[10:58:39.531]   ..$ ...:<environment: 0x5635bf755800> 
[10:58:39.531]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.531]  - attr(*, "resolved")= logi TRUE
[10:58:39.531]  - attr(*, "total_size")= num NA
[10:58:39.533]  - Getting '...' globals ... DONE
[10:58:39.534] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:39.534] List of 2
[10:58:39.534]  $ ...future.FUN:function (x)  
[10:58:39.534]  $ ...          : list()
[10:58:39.534]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.534]  - attr(*, "where")=List of 2
[10:58:39.534]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:39.534]   ..$ ...          :<environment: 0x5635bf755800> 
[10:58:39.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.534]  - attr(*, "resolved")= logi FALSE
[10:58:39.534]  - attr(*, "total_size")= num 2547
[10:58:39.537] Packages to be attached in all futures: [n=0] 
[10:58:39.537] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.538] future_lapply() ...
[10:58:39.540] Number of chunks: 2
[10:58:39.540] getGlobalsAndPackagesXApply() ...
[10:58:39.540]  - future.globals: <name-value list> with names ‘list()’
[10:58:39.541]  - use_args: TRUE
[10:58:39.541] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:39.541] List of 2
[10:58:39.541]  $ ...          : list()
[10:58:39.541]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.541]  $ ...future.FUN:function (x)  
[10:58:39.541]  - attr(*, "where")=List of 2
[10:58:39.541]   ..$ ...          :<environment: 0x5635bf755800> 
[10:58:39.541]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:39.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.541]  - attr(*, "resolved")= logi FALSE
[10:58:39.541]  - attr(*, "total_size")= num NA
[10:58:39.544] Packages to be attached in all futures: [n=0] 
[10:58:39.544] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.544] Number of futures (= number of chunks): 2
[10:58:39.544] Launching 2 futures (chunks) ...
[10:58:39.544] Chunk #1 of 2 ...
[10:58:39.545]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.545]  - seeds: <none>
[10:58:39.545]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.545] getGlobalsAndPackages() ...
[10:58:39.545] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.545] Resolving globals: FALSE
[10:58:39.545] Tweak future expression to call with '...' arguments ...
[10:58:39.545] {
[10:58:39.545]     do.call(function(...) {
[10:58:39.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.545]             on.exit(options(oopts), add = TRUE)
[10:58:39.545]         }
[10:58:39.545]         {
[10:58:39.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.545]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.545]             })
[10:58:39.545]         }
[10:58:39.545]     }, args = future.call.arguments)
[10:58:39.545] }
[10:58:39.546] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.546] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.546] 
[10:58:39.546] getGlobalsAndPackages() ... DONE
[10:58:39.546] run() for ‘Future’ ...
[10:58:39.546] - state: ‘created’
[10:58:39.547] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.548] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.548] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.548]   - Field: ‘label’
[10:58:39.549]   - Field: ‘local’
[10:58:39.549]   - Field: ‘owner’
[10:58:39.549]   - Field: ‘envir’
[10:58:39.549]   - Field: ‘workers’
[10:58:39.549]   - Field: ‘packages’
[10:58:39.549]   - Field: ‘gc’
[10:58:39.549]   - Field: ‘job’
[10:58:39.549]   - Field: ‘conditions’
[10:58:39.549]   - Field: ‘expr’
[10:58:39.549]   - Field: ‘uuid’
[10:58:39.549]   - Field: ‘seed’
[10:58:39.549]   - Field: ‘version’
[10:58:39.550]   - Field: ‘result’
[10:58:39.550]   - Field: ‘asynchronous’
[10:58:39.550]   - Field: ‘calls’
[10:58:39.551]   - Field: ‘globals’
[10:58:39.551]   - Field: ‘stdout’
[10:58:39.551]   - Field: ‘earlySignal’
[10:58:39.551]   - Field: ‘lazy’
[10:58:39.551]   - Field: ‘state’
[10:58:39.551] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.551] - Launch lazy future ...
[10:58:39.552] Packages needed by the future expression (n = 0): <none>
[10:58:39.552] Packages needed by future strategies (n = 0): <none>
[10:58:39.552] {
[10:58:39.552]     {
[10:58:39.552]         {
[10:58:39.552]             ...future.startTime <- base::Sys.time()
[10:58:39.552]             {
[10:58:39.552]                 {
[10:58:39.552]                   {
[10:58:39.552]                     {
[10:58:39.552]                       base::local({
[10:58:39.552]                         has_future <- base::requireNamespace("future", 
[10:58:39.552]                           quietly = TRUE)
[10:58:39.552]                         if (has_future) {
[10:58:39.552]                           ns <- base::getNamespace("future")
[10:58:39.552]                           version <- ns[[".package"]][["version"]]
[10:58:39.552]                           if (is.null(version)) 
[10:58:39.552]                             version <- utils::packageVersion("future")
[10:58:39.552]                         }
[10:58:39.552]                         else {
[10:58:39.552]                           version <- NULL
[10:58:39.552]                         }
[10:58:39.552]                         if (!has_future || version < "1.8.0") {
[10:58:39.552]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.552]                             "", base::R.version$version.string), 
[10:58:39.552]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.552]                               "release", "version")], collapse = " "), 
[10:58:39.552]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.552]                             info)
[10:58:39.552]                           info <- base::paste(info, collapse = "; ")
[10:58:39.552]                           if (!has_future) {
[10:58:39.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.552]                               info)
[10:58:39.552]                           }
[10:58:39.552]                           else {
[10:58:39.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.552]                               info, version)
[10:58:39.552]                           }
[10:58:39.552]                           base::stop(msg)
[10:58:39.552]                         }
[10:58:39.552]                       })
[10:58:39.552]                     }
[10:58:39.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.552]                     base::options(mc.cores = 1L)
[10:58:39.552]                   }
[10:58:39.552]                   ...future.strategy.old <- future::plan("list")
[10:58:39.552]                   options(future.plan = NULL)
[10:58:39.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.552]                 }
[10:58:39.552]                 ...future.workdir <- getwd()
[10:58:39.552]             }
[10:58:39.552]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.552]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.552]         }
[10:58:39.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.552]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.552]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.552]             base::names(...future.oldOptions))
[10:58:39.552]     }
[10:58:39.552]     if (FALSE) {
[10:58:39.552]     }
[10:58:39.552]     else {
[10:58:39.552]         if (TRUE) {
[10:58:39.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.552]                 open = "w")
[10:58:39.552]         }
[10:58:39.552]         else {
[10:58:39.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.552]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.552]         }
[10:58:39.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.552]             base::sink(type = "output", split = FALSE)
[10:58:39.552]             base::close(...future.stdout)
[10:58:39.552]         }, add = TRUE)
[10:58:39.552]     }
[10:58:39.552]     ...future.frame <- base::sys.nframe()
[10:58:39.552]     ...future.conditions <- base::list()
[10:58:39.552]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.552]     if (FALSE) {
[10:58:39.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.552]     }
[10:58:39.552]     ...future.result <- base::tryCatch({
[10:58:39.552]         base::withCallingHandlers({
[10:58:39.552]             ...future.value <- base::withVisible(base::local({
[10:58:39.552]                 withCallingHandlers({
[10:58:39.552]                   {
[10:58:39.552]                     do.call(function(...) {
[10:58:39.552]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.552]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.552]                         ...future.globals.maxSize)) {
[10:58:39.552]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.552]                         on.exit(options(oopts), add = TRUE)
[10:58:39.552]                       }
[10:58:39.552]                       {
[10:58:39.552]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.552]                           FUN = function(jj) {
[10:58:39.552]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.552]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.552]                           })
[10:58:39.552]                       }
[10:58:39.552]                     }, args = future.call.arguments)
[10:58:39.552]                   }
[10:58:39.552]                 }, immediateCondition = function(cond) {
[10:58:39.552]                   save_rds <- function (object, pathname, ...) 
[10:58:39.552]                   {
[10:58:39.552]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.552]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.552]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.552]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.552]                         fi_tmp[["mtime"]])
[10:58:39.552]                     }
[10:58:39.552]                     tryCatch({
[10:58:39.552]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.552]                     }, error = function(ex) {
[10:58:39.552]                       msg <- conditionMessage(ex)
[10:58:39.552]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.552]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.552]                         fi_tmp[["mtime"]], msg)
[10:58:39.552]                       ex$message <- msg
[10:58:39.552]                       stop(ex)
[10:58:39.552]                     })
[10:58:39.552]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.552]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.552]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.552]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.552]                       fi <- file.info(pathname)
[10:58:39.552]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.552]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.552]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.552]                         fi[["size"]], fi[["mtime"]])
[10:58:39.552]                       stop(msg)
[10:58:39.552]                     }
[10:58:39.552]                     invisible(pathname)
[10:58:39.552]                   }
[10:58:39.552]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.552]                     rootPath = tempdir()) 
[10:58:39.552]                   {
[10:58:39.552]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.552]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.552]                       tmpdir = path, fileext = ".rds")
[10:58:39.552]                     save_rds(obj, file)
[10:58:39.552]                   }
[10:58:39.552]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.552]                   {
[10:58:39.552]                     inherits <- base::inherits
[10:58:39.552]                     invokeRestart <- base::invokeRestart
[10:58:39.552]                     is.null <- base::is.null
[10:58:39.552]                     muffled <- FALSE
[10:58:39.552]                     if (inherits(cond, "message")) {
[10:58:39.552]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.552]                       if (muffled) 
[10:58:39.552]                         invokeRestart("muffleMessage")
[10:58:39.552]                     }
[10:58:39.552]                     else if (inherits(cond, "warning")) {
[10:58:39.552]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.552]                       if (muffled) 
[10:58:39.552]                         invokeRestart("muffleWarning")
[10:58:39.552]                     }
[10:58:39.552]                     else if (inherits(cond, "condition")) {
[10:58:39.552]                       if (!is.null(pattern)) {
[10:58:39.552]                         computeRestarts <- base::computeRestarts
[10:58:39.552]                         grepl <- base::grepl
[10:58:39.552]                         restarts <- computeRestarts(cond)
[10:58:39.552]                         for (restart in restarts) {
[10:58:39.552]                           name <- restart$name
[10:58:39.552]                           if (is.null(name)) 
[10:58:39.552]                             next
[10:58:39.552]                           if (!grepl(pattern, name)) 
[10:58:39.552]                             next
[10:58:39.552]                           invokeRestart(restart)
[10:58:39.552]                           muffled <- TRUE
[10:58:39.552]                           break
[10:58:39.552]                         }
[10:58:39.552]                       }
[10:58:39.552]                     }
[10:58:39.552]                     invisible(muffled)
[10:58:39.552]                   }
[10:58:39.552]                   muffleCondition(cond)
[10:58:39.552]                 })
[10:58:39.552]             }))
[10:58:39.552]             future::FutureResult(value = ...future.value$value, 
[10:58:39.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.552]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.552]                     ...future.globalenv.names))
[10:58:39.552]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.552]         }, condition = base::local({
[10:58:39.552]             c <- base::c
[10:58:39.552]             inherits <- base::inherits
[10:58:39.552]             invokeRestart <- base::invokeRestart
[10:58:39.552]             length <- base::length
[10:58:39.552]             list <- base::list
[10:58:39.552]             seq.int <- base::seq.int
[10:58:39.552]             signalCondition <- base::signalCondition
[10:58:39.552]             sys.calls <- base::sys.calls
[10:58:39.552]             `[[` <- base::`[[`
[10:58:39.552]             `+` <- base::`+`
[10:58:39.552]             `<<-` <- base::`<<-`
[10:58:39.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.552]                   3L)]
[10:58:39.552]             }
[10:58:39.552]             function(cond) {
[10:58:39.552]                 is_error <- inherits(cond, "error")
[10:58:39.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.552]                   NULL)
[10:58:39.552]                 if (is_error) {
[10:58:39.552]                   sessionInformation <- function() {
[10:58:39.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.552]                       search = base::search(), system = base::Sys.info())
[10:58:39.552]                   }
[10:58:39.552]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.552]                     cond$call), session = sessionInformation(), 
[10:58:39.552]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.552]                   signalCondition(cond)
[10:58:39.552]                 }
[10:58:39.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.552]                 "immediateCondition"))) {
[10:58:39.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.552]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.552]                   if (TRUE && !signal) {
[10:58:39.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.552]                     {
[10:58:39.552]                       inherits <- base::inherits
[10:58:39.552]                       invokeRestart <- base::invokeRestart
[10:58:39.552]                       is.null <- base::is.null
[10:58:39.552]                       muffled <- FALSE
[10:58:39.552]                       if (inherits(cond, "message")) {
[10:58:39.552]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.552]                         if (muffled) 
[10:58:39.552]                           invokeRestart("muffleMessage")
[10:58:39.552]                       }
[10:58:39.552]                       else if (inherits(cond, "warning")) {
[10:58:39.552]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.552]                         if (muffled) 
[10:58:39.552]                           invokeRestart("muffleWarning")
[10:58:39.552]                       }
[10:58:39.552]                       else if (inherits(cond, "condition")) {
[10:58:39.552]                         if (!is.null(pattern)) {
[10:58:39.552]                           computeRestarts <- base::computeRestarts
[10:58:39.552]                           grepl <- base::grepl
[10:58:39.552]                           restarts <- computeRestarts(cond)
[10:58:39.552]                           for (restart in restarts) {
[10:58:39.552]                             name <- restart$name
[10:58:39.552]                             if (is.null(name)) 
[10:58:39.552]                               next
[10:58:39.552]                             if (!grepl(pattern, name)) 
[10:58:39.552]                               next
[10:58:39.552]                             invokeRestart(restart)
[10:58:39.552]                             muffled <- TRUE
[10:58:39.552]                             break
[10:58:39.552]                           }
[10:58:39.552]                         }
[10:58:39.552]                       }
[10:58:39.552]                       invisible(muffled)
[10:58:39.552]                     }
[10:58:39.552]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.552]                   }
[10:58:39.552]                 }
[10:58:39.552]                 else {
[10:58:39.552]                   if (TRUE) {
[10:58:39.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.552]                     {
[10:58:39.552]                       inherits <- base::inherits
[10:58:39.552]                       invokeRestart <- base::invokeRestart
[10:58:39.552]                       is.null <- base::is.null
[10:58:39.552]                       muffled <- FALSE
[10:58:39.552]                       if (inherits(cond, "message")) {
[10:58:39.552]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.552]                         if (muffled) 
[10:58:39.552]                           invokeRestart("muffleMessage")
[10:58:39.552]                       }
[10:58:39.552]                       else if (inherits(cond, "warning")) {
[10:58:39.552]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.552]                         if (muffled) 
[10:58:39.552]                           invokeRestart("muffleWarning")
[10:58:39.552]                       }
[10:58:39.552]                       else if (inherits(cond, "condition")) {
[10:58:39.552]                         if (!is.null(pattern)) {
[10:58:39.552]                           computeRestarts <- base::computeRestarts
[10:58:39.552]                           grepl <- base::grepl
[10:58:39.552]                           restarts <- computeRestarts(cond)
[10:58:39.552]                           for (restart in restarts) {
[10:58:39.552]                             name <- restart$name
[10:58:39.552]                             if (is.null(name)) 
[10:58:39.552]                               next
[10:58:39.552]                             if (!grepl(pattern, name)) 
[10:58:39.552]                               next
[10:58:39.552]                             invokeRestart(restart)
[10:58:39.552]                             muffled <- TRUE
[10:58:39.552]                             break
[10:58:39.552]                           }
[10:58:39.552]                         }
[10:58:39.552]                       }
[10:58:39.552]                       invisible(muffled)
[10:58:39.552]                     }
[10:58:39.552]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.552]                   }
[10:58:39.552]                 }
[10:58:39.552]             }
[10:58:39.552]         }))
[10:58:39.552]     }, error = function(ex) {
[10:58:39.552]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.552]                 ...future.rng), started = ...future.startTime, 
[10:58:39.552]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.552]             version = "1.8"), class = "FutureResult")
[10:58:39.552]     }, finally = {
[10:58:39.552]         if (!identical(...future.workdir, getwd())) 
[10:58:39.552]             setwd(...future.workdir)
[10:58:39.552]         {
[10:58:39.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.552]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.552]             }
[10:58:39.552]             base::options(...future.oldOptions)
[10:58:39.552]             if (.Platform$OS.type == "windows") {
[10:58:39.552]                 old_names <- names(...future.oldEnvVars)
[10:58:39.552]                 envs <- base::Sys.getenv()
[10:58:39.552]                 names <- names(envs)
[10:58:39.552]                 common <- intersect(names, old_names)
[10:58:39.552]                 added <- setdiff(names, old_names)
[10:58:39.552]                 removed <- setdiff(old_names, names)
[10:58:39.552]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.552]                   envs[common]]
[10:58:39.552]                 NAMES <- toupper(changed)
[10:58:39.552]                 args <- list()
[10:58:39.552]                 for (kk in seq_along(NAMES)) {
[10:58:39.552]                   name <- changed[[kk]]
[10:58:39.552]                   NAME <- NAMES[[kk]]
[10:58:39.552]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.552]                     next
[10:58:39.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.552]                 }
[10:58:39.552]                 NAMES <- toupper(added)
[10:58:39.552]                 for (kk in seq_along(NAMES)) {
[10:58:39.552]                   name <- added[[kk]]
[10:58:39.552]                   NAME <- NAMES[[kk]]
[10:58:39.552]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.552]                     next
[10:58:39.552]                   args[[name]] <- ""
[10:58:39.552]                 }
[10:58:39.552]                 NAMES <- toupper(removed)
[10:58:39.552]                 for (kk in seq_along(NAMES)) {
[10:58:39.552]                   name <- removed[[kk]]
[10:58:39.552]                   NAME <- NAMES[[kk]]
[10:58:39.552]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.552]                     next
[10:58:39.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.552]                 }
[10:58:39.552]                 if (length(args) > 0) 
[10:58:39.552]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.552]             }
[10:58:39.552]             else {
[10:58:39.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.552]             }
[10:58:39.552]             {
[10:58:39.552]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.552]                   0L) {
[10:58:39.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.552]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.552]                   base::options(opts)
[10:58:39.552]                 }
[10:58:39.552]                 {
[10:58:39.552]                   {
[10:58:39.552]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.552]                     NULL
[10:58:39.552]                   }
[10:58:39.552]                   options(future.plan = NULL)
[10:58:39.552]                   if (is.na(NA_character_)) 
[10:58:39.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.552]                     .init = FALSE)
[10:58:39.552]                 }
[10:58:39.552]             }
[10:58:39.552]         }
[10:58:39.552]     })
[10:58:39.552]     if (TRUE) {
[10:58:39.552]         base::sink(type = "output", split = FALSE)
[10:58:39.552]         if (TRUE) {
[10:58:39.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.552]         }
[10:58:39.552]         else {
[10:58:39.552]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.552]         }
[10:58:39.552]         base::close(...future.stdout)
[10:58:39.552]         ...future.stdout <- NULL
[10:58:39.552]     }
[10:58:39.552]     ...future.result$conditions <- ...future.conditions
[10:58:39.552]     ...future.result$finished <- base::Sys.time()
[10:58:39.552]     ...future.result
[10:58:39.552] }
[10:58:39.555] assign_globals() ...
[10:58:39.555] List of 5
[10:58:39.555]  $ future.call.arguments    : list()
[10:58:39.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.555]  $ ...future.FUN            :function (x)  
[10:58:39.555]  $ ...future.elements_ii    :List of 1
[10:58:39.555]   ..$ : int 1
[10:58:39.555]  $ ...future.seeds_ii       : NULL
[10:58:39.555]  $ ...future.globals.maxSize: num Inf
[10:58:39.555]  - attr(*, "resolved")= logi FALSE
[10:58:39.555]  - attr(*, "total_size")= num NA
[10:58:39.555]  - attr(*, "where")=List of 5
[10:58:39.555]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.555]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.555]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.555]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.555]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.555]  - attr(*, "already-done")= logi TRUE
[10:58:39.559] - copied ‘future.call.arguments’ to environment
[10:58:39.559] - copied ‘...future.FUN’ to environment
[10:58:39.559] - copied ‘...future.elements_ii’ to environment
[10:58:39.559] - copied ‘...future.seeds_ii’ to environment
[10:58:39.560] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.560] assign_globals() ... done
[10:58:39.560] requestCore(): workers = 2
[10:58:39.562] MulticoreFuture started
[10:58:39.562] - Launch lazy future ... done
[10:58:39.562] run() for ‘MulticoreFuture’ ... done
[10:58:39.562] Created future:
[10:58:39.563] plan(): Setting new future strategy stack:
[10:58:39.563] List of future strategies:
[10:58:39.563] 1. sequential:
[10:58:39.563]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.563]    - tweaked: FALSE
[10:58:39.563]    - call: NULL
[10:58:39.564] plan(): nbrOfWorkers() = 1
[10:58:39.566] plan(): Setting new future strategy stack:
[10:58:39.566] List of future strategies:
[10:58:39.566] 1. multicore:
[10:58:39.566]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.566]    - tweaked: FALSE
[10:58:39.566]    - call: plan(strategy)
[10:58:39.569] plan(): nbrOfWorkers() = 2
[10:58:39.563] MulticoreFuture:
[10:58:39.563] Label: ‘future_apply-1’
[10:58:39.563] Expression:
[10:58:39.563] {
[10:58:39.563]     do.call(function(...) {
[10:58:39.563]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.563]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.563]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.563]             on.exit(options(oopts), add = TRUE)
[10:58:39.563]         }
[10:58:39.563]         {
[10:58:39.563]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.563]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.563]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.563]             })
[10:58:39.563]         }
[10:58:39.563]     }, args = future.call.arguments)
[10:58:39.563] }
[10:58:39.563] Lazy evaluation: FALSE
[10:58:39.563] Asynchronous evaluation: TRUE
[10:58:39.563] Local evaluation: TRUE
[10:58:39.563] Environment: R_GlobalEnv
[10:58:39.563] Capture standard output: TRUE
[10:58:39.563] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.563] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.563] Packages: <none>
[10:58:39.563] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.563] Resolved: TRUE
[10:58:39.563] Value: <not collected>
[10:58:39.563] Conditions captured: <none>
[10:58:39.563] Early signaling: FALSE
[10:58:39.563] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.563] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.570] Chunk #1 of 2 ... DONE
[10:58:39.570] Chunk #2 of 2 ...
[10:58:39.571]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.571]  - seeds: <none>
[10:58:39.571]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.571] getGlobalsAndPackages() ...
[10:58:39.571] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.571] Resolving globals: FALSE
[10:58:39.571] Tweak future expression to call with '...' arguments ...
[10:58:39.572] {
[10:58:39.572]     do.call(function(...) {
[10:58:39.572]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.572]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.572]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.572]             on.exit(options(oopts), add = TRUE)
[10:58:39.572]         }
[10:58:39.572]         {
[10:58:39.572]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.572]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.572]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.572]             })
[10:58:39.572]         }
[10:58:39.572]     }, args = future.call.arguments)
[10:58:39.572] }
[10:58:39.572] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.573] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.573] 
[10:58:39.573] getGlobalsAndPackages() ... DONE
[10:58:39.573] run() for ‘Future’ ...
[10:58:39.573] - state: ‘created’
[10:58:39.574] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.576] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.576] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.577]   - Field: ‘label’
[10:58:39.577]   - Field: ‘local’
[10:58:39.577]   - Field: ‘owner’
[10:58:39.577]   - Field: ‘envir’
[10:58:39.577]   - Field: ‘workers’
[10:58:39.577]   - Field: ‘packages’
[10:58:39.577]   - Field: ‘gc’
[10:58:39.578]   - Field: ‘job’
[10:58:39.578]   - Field: ‘conditions’
[10:58:39.578]   - Field: ‘expr’
[10:58:39.578]   - Field: ‘uuid’
[10:58:39.578]   - Field: ‘seed’
[10:58:39.578]   - Field: ‘version’
[10:58:39.578]   - Field: ‘result’
[10:58:39.579]   - Field: ‘asynchronous’
[10:58:39.579]   - Field: ‘calls’
[10:58:39.579]   - Field: ‘globals’
[10:58:39.579]   - Field: ‘stdout’
[10:58:39.579]   - Field: ‘earlySignal’
[10:58:39.579]   - Field: ‘lazy’
[10:58:39.580]   - Field: ‘state’
[10:58:39.580] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.580] - Launch lazy future ...
[10:58:39.580] Packages needed by the future expression (n = 0): <none>
[10:58:39.581] Packages needed by future strategies (n = 0): <none>
[10:58:39.581] {
[10:58:39.581]     {
[10:58:39.581]         {
[10:58:39.581]             ...future.startTime <- base::Sys.time()
[10:58:39.581]             {
[10:58:39.581]                 {
[10:58:39.581]                   {
[10:58:39.581]                     {
[10:58:39.581]                       base::local({
[10:58:39.581]                         has_future <- base::requireNamespace("future", 
[10:58:39.581]                           quietly = TRUE)
[10:58:39.581]                         if (has_future) {
[10:58:39.581]                           ns <- base::getNamespace("future")
[10:58:39.581]                           version <- ns[[".package"]][["version"]]
[10:58:39.581]                           if (is.null(version)) 
[10:58:39.581]                             version <- utils::packageVersion("future")
[10:58:39.581]                         }
[10:58:39.581]                         else {
[10:58:39.581]                           version <- NULL
[10:58:39.581]                         }
[10:58:39.581]                         if (!has_future || version < "1.8.0") {
[10:58:39.581]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.581]                             "", base::R.version$version.string), 
[10:58:39.581]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.581]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.581]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.581]                               "release", "version")], collapse = " "), 
[10:58:39.581]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.581]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.581]                             info)
[10:58:39.581]                           info <- base::paste(info, collapse = "; ")
[10:58:39.581]                           if (!has_future) {
[10:58:39.581]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.581]                               info)
[10:58:39.581]                           }
[10:58:39.581]                           else {
[10:58:39.581]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.581]                               info, version)
[10:58:39.581]                           }
[10:58:39.581]                           base::stop(msg)
[10:58:39.581]                         }
[10:58:39.581]                       })
[10:58:39.581]                     }
[10:58:39.581]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.581]                     base::options(mc.cores = 1L)
[10:58:39.581]                   }
[10:58:39.581]                   ...future.strategy.old <- future::plan("list")
[10:58:39.581]                   options(future.plan = NULL)
[10:58:39.581]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.581]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.581]                 }
[10:58:39.581]                 ...future.workdir <- getwd()
[10:58:39.581]             }
[10:58:39.581]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.581]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.581]         }
[10:58:39.581]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.581]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.581]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.581]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.581]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.581]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.581]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.581]             base::names(...future.oldOptions))
[10:58:39.581]     }
[10:58:39.581]     if (FALSE) {
[10:58:39.581]     }
[10:58:39.581]     else {
[10:58:39.581]         if (TRUE) {
[10:58:39.581]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.581]                 open = "w")
[10:58:39.581]         }
[10:58:39.581]         else {
[10:58:39.581]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.581]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.581]         }
[10:58:39.581]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.581]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.581]             base::sink(type = "output", split = FALSE)
[10:58:39.581]             base::close(...future.stdout)
[10:58:39.581]         }, add = TRUE)
[10:58:39.581]     }
[10:58:39.581]     ...future.frame <- base::sys.nframe()
[10:58:39.581]     ...future.conditions <- base::list()
[10:58:39.581]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.581]     if (FALSE) {
[10:58:39.581]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.581]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.581]     }
[10:58:39.581]     ...future.result <- base::tryCatch({
[10:58:39.581]         base::withCallingHandlers({
[10:58:39.581]             ...future.value <- base::withVisible(base::local({
[10:58:39.581]                 withCallingHandlers({
[10:58:39.581]                   {
[10:58:39.581]                     do.call(function(...) {
[10:58:39.581]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.581]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.581]                         ...future.globals.maxSize)) {
[10:58:39.581]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.581]                         on.exit(options(oopts), add = TRUE)
[10:58:39.581]                       }
[10:58:39.581]                       {
[10:58:39.581]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.581]                           FUN = function(jj) {
[10:58:39.581]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.581]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.581]                           })
[10:58:39.581]                       }
[10:58:39.581]                     }, args = future.call.arguments)
[10:58:39.581]                   }
[10:58:39.581]                 }, immediateCondition = function(cond) {
[10:58:39.581]                   save_rds <- function (object, pathname, ...) 
[10:58:39.581]                   {
[10:58:39.581]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.581]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.581]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.581]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.581]                         fi_tmp[["mtime"]])
[10:58:39.581]                     }
[10:58:39.581]                     tryCatch({
[10:58:39.581]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.581]                     }, error = function(ex) {
[10:58:39.581]                       msg <- conditionMessage(ex)
[10:58:39.581]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.581]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.581]                         fi_tmp[["mtime"]], msg)
[10:58:39.581]                       ex$message <- msg
[10:58:39.581]                       stop(ex)
[10:58:39.581]                     })
[10:58:39.581]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.581]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.581]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.581]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.581]                       fi <- file.info(pathname)
[10:58:39.581]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.581]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.581]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.581]                         fi[["size"]], fi[["mtime"]])
[10:58:39.581]                       stop(msg)
[10:58:39.581]                     }
[10:58:39.581]                     invisible(pathname)
[10:58:39.581]                   }
[10:58:39.581]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.581]                     rootPath = tempdir()) 
[10:58:39.581]                   {
[10:58:39.581]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.581]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.581]                       tmpdir = path, fileext = ".rds")
[10:58:39.581]                     save_rds(obj, file)
[10:58:39.581]                   }
[10:58:39.581]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.581]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.581]                   {
[10:58:39.581]                     inherits <- base::inherits
[10:58:39.581]                     invokeRestart <- base::invokeRestart
[10:58:39.581]                     is.null <- base::is.null
[10:58:39.581]                     muffled <- FALSE
[10:58:39.581]                     if (inherits(cond, "message")) {
[10:58:39.581]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.581]                       if (muffled) 
[10:58:39.581]                         invokeRestart("muffleMessage")
[10:58:39.581]                     }
[10:58:39.581]                     else if (inherits(cond, "warning")) {
[10:58:39.581]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.581]                       if (muffled) 
[10:58:39.581]                         invokeRestart("muffleWarning")
[10:58:39.581]                     }
[10:58:39.581]                     else if (inherits(cond, "condition")) {
[10:58:39.581]                       if (!is.null(pattern)) {
[10:58:39.581]                         computeRestarts <- base::computeRestarts
[10:58:39.581]                         grepl <- base::grepl
[10:58:39.581]                         restarts <- computeRestarts(cond)
[10:58:39.581]                         for (restart in restarts) {
[10:58:39.581]                           name <- restart$name
[10:58:39.581]                           if (is.null(name)) 
[10:58:39.581]                             next
[10:58:39.581]                           if (!grepl(pattern, name)) 
[10:58:39.581]                             next
[10:58:39.581]                           invokeRestart(restart)
[10:58:39.581]                           muffled <- TRUE
[10:58:39.581]                           break
[10:58:39.581]                         }
[10:58:39.581]                       }
[10:58:39.581]                     }
[10:58:39.581]                     invisible(muffled)
[10:58:39.581]                   }
[10:58:39.581]                   muffleCondition(cond)
[10:58:39.581]                 })
[10:58:39.581]             }))
[10:58:39.581]             future::FutureResult(value = ...future.value$value, 
[10:58:39.581]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.581]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.581]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.581]                     ...future.globalenv.names))
[10:58:39.581]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.581]         }, condition = base::local({
[10:58:39.581]             c <- base::c
[10:58:39.581]             inherits <- base::inherits
[10:58:39.581]             invokeRestart <- base::invokeRestart
[10:58:39.581]             length <- base::length
[10:58:39.581]             list <- base::list
[10:58:39.581]             seq.int <- base::seq.int
[10:58:39.581]             signalCondition <- base::signalCondition
[10:58:39.581]             sys.calls <- base::sys.calls
[10:58:39.581]             `[[` <- base::`[[`
[10:58:39.581]             `+` <- base::`+`
[10:58:39.581]             `<<-` <- base::`<<-`
[10:58:39.581]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.581]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.581]                   3L)]
[10:58:39.581]             }
[10:58:39.581]             function(cond) {
[10:58:39.581]                 is_error <- inherits(cond, "error")
[10:58:39.581]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.581]                   NULL)
[10:58:39.581]                 if (is_error) {
[10:58:39.581]                   sessionInformation <- function() {
[10:58:39.581]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.581]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.581]                       search = base::search(), system = base::Sys.info())
[10:58:39.581]                   }
[10:58:39.581]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.581]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.581]                     cond$call), session = sessionInformation(), 
[10:58:39.581]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.581]                   signalCondition(cond)
[10:58:39.581]                 }
[10:58:39.581]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.581]                 "immediateCondition"))) {
[10:58:39.581]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.581]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.581]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.581]                   if (TRUE && !signal) {
[10:58:39.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.581]                     {
[10:58:39.581]                       inherits <- base::inherits
[10:58:39.581]                       invokeRestart <- base::invokeRestart
[10:58:39.581]                       is.null <- base::is.null
[10:58:39.581]                       muffled <- FALSE
[10:58:39.581]                       if (inherits(cond, "message")) {
[10:58:39.581]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.581]                         if (muffled) 
[10:58:39.581]                           invokeRestart("muffleMessage")
[10:58:39.581]                       }
[10:58:39.581]                       else if (inherits(cond, "warning")) {
[10:58:39.581]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.581]                         if (muffled) 
[10:58:39.581]                           invokeRestart("muffleWarning")
[10:58:39.581]                       }
[10:58:39.581]                       else if (inherits(cond, "condition")) {
[10:58:39.581]                         if (!is.null(pattern)) {
[10:58:39.581]                           computeRestarts <- base::computeRestarts
[10:58:39.581]                           grepl <- base::grepl
[10:58:39.581]                           restarts <- computeRestarts(cond)
[10:58:39.581]                           for (restart in restarts) {
[10:58:39.581]                             name <- restart$name
[10:58:39.581]                             if (is.null(name)) 
[10:58:39.581]                               next
[10:58:39.581]                             if (!grepl(pattern, name)) 
[10:58:39.581]                               next
[10:58:39.581]                             invokeRestart(restart)
[10:58:39.581]                             muffled <- TRUE
[10:58:39.581]                             break
[10:58:39.581]                           }
[10:58:39.581]                         }
[10:58:39.581]                       }
[10:58:39.581]                       invisible(muffled)
[10:58:39.581]                     }
[10:58:39.581]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.581]                   }
[10:58:39.581]                 }
[10:58:39.581]                 else {
[10:58:39.581]                   if (TRUE) {
[10:58:39.581]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.581]                     {
[10:58:39.581]                       inherits <- base::inherits
[10:58:39.581]                       invokeRestart <- base::invokeRestart
[10:58:39.581]                       is.null <- base::is.null
[10:58:39.581]                       muffled <- FALSE
[10:58:39.581]                       if (inherits(cond, "message")) {
[10:58:39.581]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.581]                         if (muffled) 
[10:58:39.581]                           invokeRestart("muffleMessage")
[10:58:39.581]                       }
[10:58:39.581]                       else if (inherits(cond, "warning")) {
[10:58:39.581]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.581]                         if (muffled) 
[10:58:39.581]                           invokeRestart("muffleWarning")
[10:58:39.581]                       }
[10:58:39.581]                       else if (inherits(cond, "condition")) {
[10:58:39.581]                         if (!is.null(pattern)) {
[10:58:39.581]                           computeRestarts <- base::computeRestarts
[10:58:39.581]                           grepl <- base::grepl
[10:58:39.581]                           restarts <- computeRestarts(cond)
[10:58:39.581]                           for (restart in restarts) {
[10:58:39.581]                             name <- restart$name
[10:58:39.581]                             if (is.null(name)) 
[10:58:39.581]                               next
[10:58:39.581]                             if (!grepl(pattern, name)) 
[10:58:39.581]                               next
[10:58:39.581]                             invokeRestart(restart)
[10:58:39.581]                             muffled <- TRUE
[10:58:39.581]                             break
[10:58:39.581]                           }
[10:58:39.581]                         }
[10:58:39.581]                       }
[10:58:39.581]                       invisible(muffled)
[10:58:39.581]                     }
[10:58:39.581]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.581]                   }
[10:58:39.581]                 }
[10:58:39.581]             }
[10:58:39.581]         }))
[10:58:39.581]     }, error = function(ex) {
[10:58:39.581]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.581]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.581]                 ...future.rng), started = ...future.startTime, 
[10:58:39.581]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.581]             version = "1.8"), class = "FutureResult")
[10:58:39.581]     }, finally = {
[10:58:39.581]         if (!identical(...future.workdir, getwd())) 
[10:58:39.581]             setwd(...future.workdir)
[10:58:39.581]         {
[10:58:39.581]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.581]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.581]             }
[10:58:39.581]             base::options(...future.oldOptions)
[10:58:39.581]             if (.Platform$OS.type == "windows") {
[10:58:39.581]                 old_names <- names(...future.oldEnvVars)
[10:58:39.581]                 envs <- base::Sys.getenv()
[10:58:39.581]                 names <- names(envs)
[10:58:39.581]                 common <- intersect(names, old_names)
[10:58:39.581]                 added <- setdiff(names, old_names)
[10:58:39.581]                 removed <- setdiff(old_names, names)
[10:58:39.581]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.581]                   envs[common]]
[10:58:39.581]                 NAMES <- toupper(changed)
[10:58:39.581]                 args <- list()
[10:58:39.581]                 for (kk in seq_along(NAMES)) {
[10:58:39.581]                   name <- changed[[kk]]
[10:58:39.581]                   NAME <- NAMES[[kk]]
[10:58:39.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.581]                     next
[10:58:39.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.581]                 }
[10:58:39.581]                 NAMES <- toupper(added)
[10:58:39.581]                 for (kk in seq_along(NAMES)) {
[10:58:39.581]                   name <- added[[kk]]
[10:58:39.581]                   NAME <- NAMES[[kk]]
[10:58:39.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.581]                     next
[10:58:39.581]                   args[[name]] <- ""
[10:58:39.581]                 }
[10:58:39.581]                 NAMES <- toupper(removed)
[10:58:39.581]                 for (kk in seq_along(NAMES)) {
[10:58:39.581]                   name <- removed[[kk]]
[10:58:39.581]                   NAME <- NAMES[[kk]]
[10:58:39.581]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.581]                     next
[10:58:39.581]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.581]                 }
[10:58:39.581]                 if (length(args) > 0) 
[10:58:39.581]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.581]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.581]             }
[10:58:39.581]             else {
[10:58:39.581]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.581]             }
[10:58:39.581]             {
[10:58:39.581]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.581]                   0L) {
[10:58:39.581]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.581]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.581]                   base::options(opts)
[10:58:39.581]                 }
[10:58:39.581]                 {
[10:58:39.581]                   {
[10:58:39.581]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.581]                     NULL
[10:58:39.581]                   }
[10:58:39.581]                   options(future.plan = NULL)
[10:58:39.581]                   if (is.na(NA_character_)) 
[10:58:39.581]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.581]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.581]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.581]                     .init = FALSE)
[10:58:39.581]                 }
[10:58:39.581]             }
[10:58:39.581]         }
[10:58:39.581]     })
[10:58:39.581]     if (TRUE) {
[10:58:39.581]         base::sink(type = "output", split = FALSE)
[10:58:39.581]         if (TRUE) {
[10:58:39.581]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.581]         }
[10:58:39.581]         else {
[10:58:39.581]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.581]         }
[10:58:39.581]         base::close(...future.stdout)
[10:58:39.581]         ...future.stdout <- NULL
[10:58:39.581]     }
[10:58:39.581]     ...future.result$conditions <- ...future.conditions
[10:58:39.581]     ...future.result$finished <- base::Sys.time()
[10:58:39.581]     ...future.result
[10:58:39.581] }
[10:58:39.585] assign_globals() ...
[10:58:39.585] List of 5
[10:58:39.585]  $ future.call.arguments    : list()
[10:58:39.585]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.585]  $ ...future.FUN            :function (x)  
[10:58:39.585]  $ ...future.elements_ii    :List of 1
[10:58:39.585]   ..$ : int 2
[10:58:39.585]  $ ...future.seeds_ii       : NULL
[10:58:39.585]  $ ...future.globals.maxSize: num Inf
[10:58:39.585]  - attr(*, "resolved")= logi FALSE
[10:58:39.585]  - attr(*, "total_size")= num NA
[10:58:39.585]  - attr(*, "where")=List of 5
[10:58:39.585]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.585]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.585]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.585]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.585]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.585]  - attr(*, "already-done")= logi TRUE
[10:58:39.596] - copied ‘future.call.arguments’ to environment
[10:58:39.596] - copied ‘...future.FUN’ to environment
[10:58:39.596] - copied ‘...future.elements_ii’ to environment
[10:58:39.596] - copied ‘...future.seeds_ii’ to environment
[10:58:39.597] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.597] assign_globals() ... done
[10:58:39.597] requestCore(): workers = 2
[10:58:39.600] MulticoreFuture started
[10:58:39.600] - Launch lazy future ... done
[10:58:39.601] run() for ‘MulticoreFuture’ ... done
[10:58:39.601] plan(): Setting new future strategy stack:
[10:58:39.601] Created future:
[10:58:39.601] List of future strategies:
[10:58:39.601] 1. sequential:
[10:58:39.601]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.601]    - tweaked: FALSE
[10:58:39.601]    - call: NULL
[10:58:39.603] plan(): nbrOfWorkers() = 1
[10:58:39.605] plan(): Setting new future strategy stack:
[10:58:39.606] List of future strategies:
[10:58:39.606] 1. multicore:
[10:58:39.606]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.606]    - tweaked: FALSE
[10:58:39.606]    - call: plan(strategy)
[10:58:39.609] plan(): nbrOfWorkers() = 2
[10:58:39.602] MulticoreFuture:
[10:58:39.602] Label: ‘future_apply-2’
[10:58:39.602] Expression:
[10:58:39.602] {
[10:58:39.602]     do.call(function(...) {
[10:58:39.602]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.602]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.602]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.602]             on.exit(options(oopts), add = TRUE)
[10:58:39.602]         }
[10:58:39.602]         {
[10:58:39.602]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.602]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.602]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.602]             })
[10:58:39.602]         }
[10:58:39.602]     }, args = future.call.arguments)
[10:58:39.602] }
[10:58:39.602] Lazy evaluation: FALSE
[10:58:39.602] Asynchronous evaluation: TRUE
[10:58:39.602] Local evaluation: TRUE
[10:58:39.602] Environment: R_GlobalEnv
[10:58:39.602] Capture standard output: TRUE
[10:58:39.602] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.602] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.602] Packages: <none>
[10:58:39.602] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.602] Resolved: TRUE
[10:58:39.602] Value: <not collected>
[10:58:39.602] Conditions captured: <none>
[10:58:39.602] Early signaling: FALSE
[10:58:39.602] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.602] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.610] Chunk #2 of 2 ... DONE
[10:58:39.610] Launching 2 futures (chunks) ... DONE
[10:58:39.610] Resolving 2 futures (chunks) ...
[10:58:39.611] resolve() on list ...
[10:58:39.611]  recursive: 0
[10:58:39.611]  length: 2
[10:58:39.611] 
[10:58:39.611] Future #1
[10:58:39.611] result() for MulticoreFuture ...
[10:58:39.612] result() for MulticoreFuture ...
[10:58:39.613] result() for MulticoreFuture ... done
[10:58:39.613] result() for MulticoreFuture ... done
[10:58:39.613] result() for MulticoreFuture ...
[10:58:39.613] result() for MulticoreFuture ... done
[10:58:39.613] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:39.613] - nx: 2
[10:58:39.614] - relay: TRUE
[10:58:39.614] - stdout: TRUE
[10:58:39.614] - signal: TRUE
[10:58:39.614] - resignal: FALSE
[10:58:39.614] - force: TRUE
[10:58:39.614] - relayed: [n=2] FALSE, FALSE
[10:58:39.615] - queued futures: [n=2] FALSE, FALSE
[10:58:39.615]  - until=1
[10:58:39.615]  - relaying element #1
[10:58:39.615] result() for MulticoreFuture ...
[10:58:39.615] result() for MulticoreFuture ... done
[10:58:39.615] result() for MulticoreFuture ...
[10:58:39.616] result() for MulticoreFuture ... done
[10:58:39.616] result() for MulticoreFuture ...
[10:58:39.616] result() for MulticoreFuture ... done
[10:58:39.616] result() for MulticoreFuture ...
[10:58:39.616] result() for MulticoreFuture ... done
[10:58:39.616] - relayed: [n=2] TRUE, FALSE
[10:58:39.616] - queued futures: [n=2] TRUE, FALSE
[10:58:39.617] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:39.617]  length: 1 (resolved future 1)
[10:58:39.617] Future #2
[10:58:39.617] result() for MulticoreFuture ...
[10:58:39.618] result() for MulticoreFuture ...
[10:58:39.618] result() for MulticoreFuture ... done
[10:58:39.618] result() for MulticoreFuture ... done
[10:58:39.618] result() for MulticoreFuture ...
[10:58:39.618] result() for MulticoreFuture ... done
[10:58:39.618] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:39.619] - nx: 2
[10:58:39.619] - relay: TRUE
[10:58:39.619] - stdout: TRUE
[10:58:39.619] - signal: TRUE
[10:58:39.619] - resignal: FALSE
[10:58:39.619] - force: TRUE
[10:58:39.619] - relayed: [n=2] TRUE, FALSE
[10:58:39.619] - queued futures: [n=2] TRUE, FALSE
[10:58:39.619]  - until=2
[10:58:39.620]  - relaying element #2
[10:58:39.620] result() for MulticoreFuture ...
[10:58:39.620] result() for MulticoreFuture ... done
[10:58:39.620] result() for MulticoreFuture ...
[10:58:39.620] result() for MulticoreFuture ... done
[10:58:39.620] result() for MulticoreFuture ...
[10:58:39.620] result() for MulticoreFuture ... done
[10:58:39.620] result() for MulticoreFuture ...
[10:58:39.621] result() for MulticoreFuture ... done
[10:58:39.621] - relayed: [n=2] TRUE, TRUE
[10:58:39.621] - queued futures: [n=2] TRUE, TRUE
[10:58:39.621] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:39.621]  length: 0 (resolved future 2)
[10:58:39.621] Relaying remaining futures
[10:58:39.621] signalConditionsASAP(NULL, pos=0) ...
[10:58:39.621] - nx: 2
[10:58:39.621] - relay: TRUE
[10:58:39.621] - stdout: TRUE
[10:58:39.622] - signal: TRUE
[10:58:39.622] - resignal: FALSE
[10:58:39.622] - force: TRUE
[10:58:39.622] - relayed: [n=2] TRUE, TRUE
[10:58:39.622] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:39.622] - relayed: [n=2] TRUE, TRUE
[10:58:39.622] - queued futures: [n=2] TRUE, TRUE
[10:58:39.622] signalConditionsASAP(NULL, pos=0) ... done
[10:58:39.622] resolve() on list ... DONE
[10:58:39.622] result() for MulticoreFuture ...
[10:58:39.623] result() for MulticoreFuture ... done
[10:58:39.623] result() for MulticoreFuture ...
[10:58:39.623] result() for MulticoreFuture ... done
[10:58:39.623] result() for MulticoreFuture ...
[10:58:39.623] result() for MulticoreFuture ... done
[10:58:39.623] result() for MulticoreFuture ...
[10:58:39.623] result() for MulticoreFuture ... done
[10:58:39.623]  - Number of value chunks collected: 2
[10:58:39.623] Resolving 2 futures (chunks) ... DONE
[10:58:39.624] Reducing values from 2 chunks ...
[10:58:39.624]  - Number of values collected after concatenation: 2
[10:58:39.624]  - Number of values expected: 2
[10:58:39.624] Reducing values from 2 chunks ... DONE
[10:58:39.624] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:58:39.624] getGlobalsAndPackagesXApply() ...
[10:58:39.624]  - future.globals: TRUE
[10:58:39.625] getGlobalsAndPackages() ...
[10:58:39.625] Searching for globals...
[10:58:39.626] - globals found: [1] ‘FUN’
[10:58:39.626] Searching for globals ... DONE
[10:58:39.626] Resolving globals: FALSE
[10:58:39.626] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:39.627] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:39.627] - globals: [1] ‘FUN’
[10:58:39.627] 
[10:58:39.627] getGlobalsAndPackages() ... DONE
[10:58:39.627]  - globals found/used: [n=1] ‘FUN’
[10:58:39.627]  - needed namespaces: [n=0] 
[10:58:39.628] Finding globals ... DONE
[10:58:39.628]  - use_args: TRUE
[10:58:39.628]  - Getting '...' globals ...
[10:58:39.628] resolve() on list ...
[10:58:39.628]  recursive: 0
[10:58:39.628]  length: 1
[10:58:39.628]  elements: ‘...’
[10:58:39.629]  length: 0 (resolved future 1)
[10:58:39.629] resolve() on list ... DONE
[10:58:39.629]    - '...' content: [n=0] 
[10:58:39.629] List of 1
[10:58:39.629]  $ ...: list()
[10:58:39.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.629]  - attr(*, "where")=List of 1
[10:58:39.629]   ..$ ...:<environment: 0x5635bf1c3cf0> 
[10:58:39.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.629]  - attr(*, "resolved")= logi TRUE
[10:58:39.629]  - attr(*, "total_size")= num NA
[10:58:39.632]  - Getting '...' globals ... DONE
[10:58:39.632] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:39.634] List of 2
[10:58:39.634]  $ ...future.FUN:function (x)  
[10:58:39.634]  $ ...          : list()
[10:58:39.634]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.634]  - attr(*, "where")=List of 2
[10:58:39.634]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:39.634]   ..$ ...          :<environment: 0x5635bf1c3cf0> 
[10:58:39.634]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.634]  - attr(*, "resolved")= logi FALSE
[10:58:39.634]  - attr(*, "total_size")= num 2274
[10:58:39.637] Packages to be attached in all futures: [n=0] 
[10:58:39.637] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.639] future_lapply() ...
[10:58:39.641] Number of chunks: 2
[10:58:39.641] getGlobalsAndPackagesXApply() ...
[10:58:39.641]  - future.globals: <name-value list> with names ‘list()’
[10:58:39.641]  - use_args: TRUE
[10:58:39.641] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:39.641] List of 2
[10:58:39.641]  $ ...          : list()
[10:58:39.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.641]  $ ...future.FUN:function (x)  
[10:58:39.641]  - attr(*, "where")=List of 2
[10:58:39.641]   ..$ ...          :<environment: 0x5635bf1c3cf0> 
[10:58:39.641]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:39.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.641]  - attr(*, "resolved")= logi FALSE
[10:58:39.641]  - attr(*, "total_size")= num NA
[10:58:39.644] Packages to be attached in all futures: [n=0] 
[10:58:39.644] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.644] Number of futures (= number of chunks): 2
[10:58:39.645] Launching 2 futures (chunks) ...
[10:58:39.645] Chunk #1 of 2 ...
[10:58:39.645]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.645]  - seeds: <none>
[10:58:39.645]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.645] getGlobalsAndPackages() ...
[10:58:39.645] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.645] Resolving globals: FALSE
[10:58:39.645] Tweak future expression to call with '...' arguments ...
[10:58:39.646] {
[10:58:39.646]     do.call(function(...) {
[10:58:39.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.646]             on.exit(options(oopts), add = TRUE)
[10:58:39.646]         }
[10:58:39.646]         {
[10:58:39.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.646]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.646]             })
[10:58:39.646]         }
[10:58:39.646]     }, args = future.call.arguments)
[10:58:39.646] }
[10:58:39.646] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.646] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.646] 
[10:58:39.646] getGlobalsAndPackages() ... DONE
[10:58:39.647] run() for ‘Future’ ...
[10:58:39.647] - state: ‘created’
[10:58:39.647] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.648] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.649] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.649]   - Field: ‘label’
[10:58:39.649]   - Field: ‘local’
[10:58:39.649]   - Field: ‘owner’
[10:58:39.649]   - Field: ‘envir’
[10:58:39.649]   - Field: ‘workers’
[10:58:39.649]   - Field: ‘packages’
[10:58:39.649]   - Field: ‘gc’
[10:58:39.649]   - Field: ‘job’
[10:58:39.649]   - Field: ‘conditions’
[10:58:39.649]   - Field: ‘expr’
[10:58:39.650]   - Field: ‘uuid’
[10:58:39.650]   - Field: ‘seed’
[10:58:39.650]   - Field: ‘version’
[10:58:39.650]   - Field: ‘result’
[10:58:39.650]   - Field: ‘asynchronous’
[10:58:39.650]   - Field: ‘calls’
[10:58:39.650]   - Field: ‘globals’
[10:58:39.650]   - Field: ‘stdout’
[10:58:39.650]   - Field: ‘earlySignal’
[10:58:39.650]   - Field: ‘lazy’
[10:58:39.650]   - Field: ‘state’
[10:58:39.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.651] - Launch lazy future ...
[10:58:39.651] Packages needed by the future expression (n = 0): <none>
[10:58:39.651] Packages needed by future strategies (n = 0): <none>
[10:58:39.651] {
[10:58:39.651]     {
[10:58:39.651]         {
[10:58:39.651]             ...future.startTime <- base::Sys.time()
[10:58:39.651]             {
[10:58:39.651]                 {
[10:58:39.651]                   {
[10:58:39.651]                     {
[10:58:39.651]                       base::local({
[10:58:39.651]                         has_future <- base::requireNamespace("future", 
[10:58:39.651]                           quietly = TRUE)
[10:58:39.651]                         if (has_future) {
[10:58:39.651]                           ns <- base::getNamespace("future")
[10:58:39.651]                           version <- ns[[".package"]][["version"]]
[10:58:39.651]                           if (is.null(version)) 
[10:58:39.651]                             version <- utils::packageVersion("future")
[10:58:39.651]                         }
[10:58:39.651]                         else {
[10:58:39.651]                           version <- NULL
[10:58:39.651]                         }
[10:58:39.651]                         if (!has_future || version < "1.8.0") {
[10:58:39.651]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.651]                             "", base::R.version$version.string), 
[10:58:39.651]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.651]                               "release", "version")], collapse = " "), 
[10:58:39.651]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.651]                             info)
[10:58:39.651]                           info <- base::paste(info, collapse = "; ")
[10:58:39.651]                           if (!has_future) {
[10:58:39.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.651]                               info)
[10:58:39.651]                           }
[10:58:39.651]                           else {
[10:58:39.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.651]                               info, version)
[10:58:39.651]                           }
[10:58:39.651]                           base::stop(msg)
[10:58:39.651]                         }
[10:58:39.651]                       })
[10:58:39.651]                     }
[10:58:39.651]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.651]                     base::options(mc.cores = 1L)
[10:58:39.651]                   }
[10:58:39.651]                   ...future.strategy.old <- future::plan("list")
[10:58:39.651]                   options(future.plan = NULL)
[10:58:39.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.651]                 }
[10:58:39.651]                 ...future.workdir <- getwd()
[10:58:39.651]             }
[10:58:39.651]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.651]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.651]         }
[10:58:39.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.651]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.651]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.651]             base::names(...future.oldOptions))
[10:58:39.651]     }
[10:58:39.651]     if (FALSE) {
[10:58:39.651]     }
[10:58:39.651]     else {
[10:58:39.651]         if (TRUE) {
[10:58:39.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.651]                 open = "w")
[10:58:39.651]         }
[10:58:39.651]         else {
[10:58:39.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.651]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.651]         }
[10:58:39.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.651]             base::sink(type = "output", split = FALSE)
[10:58:39.651]             base::close(...future.stdout)
[10:58:39.651]         }, add = TRUE)
[10:58:39.651]     }
[10:58:39.651]     ...future.frame <- base::sys.nframe()
[10:58:39.651]     ...future.conditions <- base::list()
[10:58:39.651]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.651]     if (FALSE) {
[10:58:39.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.651]     }
[10:58:39.651]     ...future.result <- base::tryCatch({
[10:58:39.651]         base::withCallingHandlers({
[10:58:39.651]             ...future.value <- base::withVisible(base::local({
[10:58:39.651]                 withCallingHandlers({
[10:58:39.651]                   {
[10:58:39.651]                     do.call(function(...) {
[10:58:39.651]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.651]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.651]                         ...future.globals.maxSize)) {
[10:58:39.651]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.651]                         on.exit(options(oopts), add = TRUE)
[10:58:39.651]                       }
[10:58:39.651]                       {
[10:58:39.651]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.651]                           FUN = function(jj) {
[10:58:39.651]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.651]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.651]                           })
[10:58:39.651]                       }
[10:58:39.651]                     }, args = future.call.arguments)
[10:58:39.651]                   }
[10:58:39.651]                 }, immediateCondition = function(cond) {
[10:58:39.651]                   save_rds <- function (object, pathname, ...) 
[10:58:39.651]                   {
[10:58:39.651]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.651]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.651]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.651]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.651]                         fi_tmp[["mtime"]])
[10:58:39.651]                     }
[10:58:39.651]                     tryCatch({
[10:58:39.651]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.651]                     }, error = function(ex) {
[10:58:39.651]                       msg <- conditionMessage(ex)
[10:58:39.651]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.651]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.651]                         fi_tmp[["mtime"]], msg)
[10:58:39.651]                       ex$message <- msg
[10:58:39.651]                       stop(ex)
[10:58:39.651]                     })
[10:58:39.651]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.651]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.651]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.651]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.651]                       fi <- file.info(pathname)
[10:58:39.651]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.651]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.651]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.651]                         fi[["size"]], fi[["mtime"]])
[10:58:39.651]                       stop(msg)
[10:58:39.651]                     }
[10:58:39.651]                     invisible(pathname)
[10:58:39.651]                   }
[10:58:39.651]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.651]                     rootPath = tempdir()) 
[10:58:39.651]                   {
[10:58:39.651]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.651]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.651]                       tmpdir = path, fileext = ".rds")
[10:58:39.651]                     save_rds(obj, file)
[10:58:39.651]                   }
[10:58:39.651]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.651]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.651]                   {
[10:58:39.651]                     inherits <- base::inherits
[10:58:39.651]                     invokeRestart <- base::invokeRestart
[10:58:39.651]                     is.null <- base::is.null
[10:58:39.651]                     muffled <- FALSE
[10:58:39.651]                     if (inherits(cond, "message")) {
[10:58:39.651]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.651]                       if (muffled) 
[10:58:39.651]                         invokeRestart("muffleMessage")
[10:58:39.651]                     }
[10:58:39.651]                     else if (inherits(cond, "warning")) {
[10:58:39.651]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.651]                       if (muffled) 
[10:58:39.651]                         invokeRestart("muffleWarning")
[10:58:39.651]                     }
[10:58:39.651]                     else if (inherits(cond, "condition")) {
[10:58:39.651]                       if (!is.null(pattern)) {
[10:58:39.651]                         computeRestarts <- base::computeRestarts
[10:58:39.651]                         grepl <- base::grepl
[10:58:39.651]                         restarts <- computeRestarts(cond)
[10:58:39.651]                         for (restart in restarts) {
[10:58:39.651]                           name <- restart$name
[10:58:39.651]                           if (is.null(name)) 
[10:58:39.651]                             next
[10:58:39.651]                           if (!grepl(pattern, name)) 
[10:58:39.651]                             next
[10:58:39.651]                           invokeRestart(restart)
[10:58:39.651]                           muffled <- TRUE
[10:58:39.651]                           break
[10:58:39.651]                         }
[10:58:39.651]                       }
[10:58:39.651]                     }
[10:58:39.651]                     invisible(muffled)
[10:58:39.651]                   }
[10:58:39.651]                   muffleCondition(cond)
[10:58:39.651]                 })
[10:58:39.651]             }))
[10:58:39.651]             future::FutureResult(value = ...future.value$value, 
[10:58:39.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.651]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.651]                     ...future.globalenv.names))
[10:58:39.651]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.651]         }, condition = base::local({
[10:58:39.651]             c <- base::c
[10:58:39.651]             inherits <- base::inherits
[10:58:39.651]             invokeRestart <- base::invokeRestart
[10:58:39.651]             length <- base::length
[10:58:39.651]             list <- base::list
[10:58:39.651]             seq.int <- base::seq.int
[10:58:39.651]             signalCondition <- base::signalCondition
[10:58:39.651]             sys.calls <- base::sys.calls
[10:58:39.651]             `[[` <- base::`[[`
[10:58:39.651]             `+` <- base::`+`
[10:58:39.651]             `<<-` <- base::`<<-`
[10:58:39.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.651]                   3L)]
[10:58:39.651]             }
[10:58:39.651]             function(cond) {
[10:58:39.651]                 is_error <- inherits(cond, "error")
[10:58:39.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.651]                   NULL)
[10:58:39.651]                 if (is_error) {
[10:58:39.651]                   sessionInformation <- function() {
[10:58:39.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.651]                       search = base::search(), system = base::Sys.info())
[10:58:39.651]                   }
[10:58:39.651]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.651]                     cond$call), session = sessionInformation(), 
[10:58:39.651]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.651]                   signalCondition(cond)
[10:58:39.651]                 }
[10:58:39.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.651]                 "immediateCondition"))) {
[10:58:39.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.651]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.651]                   if (TRUE && !signal) {
[10:58:39.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.651]                     {
[10:58:39.651]                       inherits <- base::inherits
[10:58:39.651]                       invokeRestart <- base::invokeRestart
[10:58:39.651]                       is.null <- base::is.null
[10:58:39.651]                       muffled <- FALSE
[10:58:39.651]                       if (inherits(cond, "message")) {
[10:58:39.651]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.651]                         if (muffled) 
[10:58:39.651]                           invokeRestart("muffleMessage")
[10:58:39.651]                       }
[10:58:39.651]                       else if (inherits(cond, "warning")) {
[10:58:39.651]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.651]                         if (muffled) 
[10:58:39.651]                           invokeRestart("muffleWarning")
[10:58:39.651]                       }
[10:58:39.651]                       else if (inherits(cond, "condition")) {
[10:58:39.651]                         if (!is.null(pattern)) {
[10:58:39.651]                           computeRestarts <- base::computeRestarts
[10:58:39.651]                           grepl <- base::grepl
[10:58:39.651]                           restarts <- computeRestarts(cond)
[10:58:39.651]                           for (restart in restarts) {
[10:58:39.651]                             name <- restart$name
[10:58:39.651]                             if (is.null(name)) 
[10:58:39.651]                               next
[10:58:39.651]                             if (!grepl(pattern, name)) 
[10:58:39.651]                               next
[10:58:39.651]                             invokeRestart(restart)
[10:58:39.651]                             muffled <- TRUE
[10:58:39.651]                             break
[10:58:39.651]                           }
[10:58:39.651]                         }
[10:58:39.651]                       }
[10:58:39.651]                       invisible(muffled)
[10:58:39.651]                     }
[10:58:39.651]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.651]                   }
[10:58:39.651]                 }
[10:58:39.651]                 else {
[10:58:39.651]                   if (TRUE) {
[10:58:39.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.651]                     {
[10:58:39.651]                       inherits <- base::inherits
[10:58:39.651]                       invokeRestart <- base::invokeRestart
[10:58:39.651]                       is.null <- base::is.null
[10:58:39.651]                       muffled <- FALSE
[10:58:39.651]                       if (inherits(cond, "message")) {
[10:58:39.651]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.651]                         if (muffled) 
[10:58:39.651]                           invokeRestart("muffleMessage")
[10:58:39.651]                       }
[10:58:39.651]                       else if (inherits(cond, "warning")) {
[10:58:39.651]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.651]                         if (muffled) 
[10:58:39.651]                           invokeRestart("muffleWarning")
[10:58:39.651]                       }
[10:58:39.651]                       else if (inherits(cond, "condition")) {
[10:58:39.651]                         if (!is.null(pattern)) {
[10:58:39.651]                           computeRestarts <- base::computeRestarts
[10:58:39.651]                           grepl <- base::grepl
[10:58:39.651]                           restarts <- computeRestarts(cond)
[10:58:39.651]                           for (restart in restarts) {
[10:58:39.651]                             name <- restart$name
[10:58:39.651]                             if (is.null(name)) 
[10:58:39.651]                               next
[10:58:39.651]                             if (!grepl(pattern, name)) 
[10:58:39.651]                               next
[10:58:39.651]                             invokeRestart(restart)
[10:58:39.651]                             muffled <- TRUE
[10:58:39.651]                             break
[10:58:39.651]                           }
[10:58:39.651]                         }
[10:58:39.651]                       }
[10:58:39.651]                       invisible(muffled)
[10:58:39.651]                     }
[10:58:39.651]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.651]                   }
[10:58:39.651]                 }
[10:58:39.651]             }
[10:58:39.651]         }))
[10:58:39.651]     }, error = function(ex) {
[10:58:39.651]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.651]                 ...future.rng), started = ...future.startTime, 
[10:58:39.651]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.651]             version = "1.8"), class = "FutureResult")
[10:58:39.651]     }, finally = {
[10:58:39.651]         if (!identical(...future.workdir, getwd())) 
[10:58:39.651]             setwd(...future.workdir)
[10:58:39.651]         {
[10:58:39.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.651]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.651]             }
[10:58:39.651]             base::options(...future.oldOptions)
[10:58:39.651]             if (.Platform$OS.type == "windows") {
[10:58:39.651]                 old_names <- names(...future.oldEnvVars)
[10:58:39.651]                 envs <- base::Sys.getenv()
[10:58:39.651]                 names <- names(envs)
[10:58:39.651]                 common <- intersect(names, old_names)
[10:58:39.651]                 added <- setdiff(names, old_names)
[10:58:39.651]                 removed <- setdiff(old_names, names)
[10:58:39.651]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.651]                   envs[common]]
[10:58:39.651]                 NAMES <- toupper(changed)
[10:58:39.651]                 args <- list()
[10:58:39.651]                 for (kk in seq_along(NAMES)) {
[10:58:39.651]                   name <- changed[[kk]]
[10:58:39.651]                   NAME <- NAMES[[kk]]
[10:58:39.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.651]                     next
[10:58:39.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.651]                 }
[10:58:39.651]                 NAMES <- toupper(added)
[10:58:39.651]                 for (kk in seq_along(NAMES)) {
[10:58:39.651]                   name <- added[[kk]]
[10:58:39.651]                   NAME <- NAMES[[kk]]
[10:58:39.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.651]                     next
[10:58:39.651]                   args[[name]] <- ""
[10:58:39.651]                 }
[10:58:39.651]                 NAMES <- toupper(removed)
[10:58:39.651]                 for (kk in seq_along(NAMES)) {
[10:58:39.651]                   name <- removed[[kk]]
[10:58:39.651]                   NAME <- NAMES[[kk]]
[10:58:39.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.651]                     next
[10:58:39.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.651]                 }
[10:58:39.651]                 if (length(args) > 0) 
[10:58:39.651]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.651]             }
[10:58:39.651]             else {
[10:58:39.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.651]             }
[10:58:39.651]             {
[10:58:39.651]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.651]                   0L) {
[10:58:39.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.651]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.651]                   base::options(opts)
[10:58:39.651]                 }
[10:58:39.651]                 {
[10:58:39.651]                   {
[10:58:39.651]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.651]                     NULL
[10:58:39.651]                   }
[10:58:39.651]                   options(future.plan = NULL)
[10:58:39.651]                   if (is.na(NA_character_)) 
[10:58:39.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.651]                     .init = FALSE)
[10:58:39.651]                 }
[10:58:39.651]             }
[10:58:39.651]         }
[10:58:39.651]     })
[10:58:39.651]     if (TRUE) {
[10:58:39.651]         base::sink(type = "output", split = FALSE)
[10:58:39.651]         if (TRUE) {
[10:58:39.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.651]         }
[10:58:39.651]         else {
[10:58:39.651]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.651]         }
[10:58:39.651]         base::close(...future.stdout)
[10:58:39.651]         ...future.stdout <- NULL
[10:58:39.651]     }
[10:58:39.651]     ...future.result$conditions <- ...future.conditions
[10:58:39.651]     ...future.result$finished <- base::Sys.time()
[10:58:39.651]     ...future.result
[10:58:39.651] }
[10:58:39.654] assign_globals() ...
[10:58:39.654] List of 5
[10:58:39.654]  $ future.call.arguments    : list()
[10:58:39.654]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.654]  $ ...future.FUN            :function (x)  
[10:58:39.654]  $ ...future.elements_ii    :List of 1
[10:58:39.654]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[10:58:39.654]  $ ...future.seeds_ii       : NULL
[10:58:39.654]  $ ...future.globals.maxSize: num Inf
[10:58:39.654]  - attr(*, "resolved")= logi FALSE
[10:58:39.654]  - attr(*, "total_size")= num NA
[10:58:39.654]  - attr(*, "where")=List of 5
[10:58:39.654]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.654]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.654]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.654]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.654]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.654]  - attr(*, "already-done")= logi TRUE
[10:58:39.660] - copied ‘future.call.arguments’ to environment
[10:58:39.660] - copied ‘...future.FUN’ to environment
[10:58:39.660] - copied ‘...future.elements_ii’ to environment
[10:58:39.660] - copied ‘...future.seeds_ii’ to environment
[10:58:39.660] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.660] assign_globals() ... done
[10:58:39.660] requestCore(): workers = 2
[10:58:39.662] MulticoreFuture started
[10:58:39.663] - Launch lazy future ... done
[10:58:39.663] run() for ‘MulticoreFuture’ ... done
[10:58:39.663] plan(): Setting new future strategy stack:
[10:58:39.664] Created future:
[10:58:39.664] List of future strategies:
[10:58:39.664] 1. sequential:
[10:58:39.664]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.664]    - tweaked: FALSE
[10:58:39.664]    - call: NULL
[10:58:39.665] plan(): nbrOfWorkers() = 1
[10:58:39.667] plan(): Setting new future strategy stack:
[10:58:39.667] List of future strategies:
[10:58:39.667] 1. multicore:
[10:58:39.667]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.667]    - tweaked: FALSE
[10:58:39.667]    - call: plan(strategy)
[10:58:39.671] plan(): nbrOfWorkers() = 2
[10:58:39.664] MulticoreFuture:
[10:58:39.664] Label: ‘future_apply-1’
[10:58:39.664] Expression:
[10:58:39.664] {
[10:58:39.664]     do.call(function(...) {
[10:58:39.664]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.664]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.664]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.664]             on.exit(options(oopts), add = TRUE)
[10:58:39.664]         }
[10:58:39.664]         {
[10:58:39.664]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.664]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.664]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.664]             })
[10:58:39.664]         }
[10:58:39.664]     }, args = future.call.arguments)
[10:58:39.664] }
[10:58:39.664] Lazy evaluation: FALSE
[10:58:39.664] Asynchronous evaluation: TRUE
[10:58:39.664] Local evaluation: TRUE
[10:58:39.664] Environment: R_GlobalEnv
[10:58:39.664] Capture standard output: TRUE
[10:58:39.664] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.664] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.664] Packages: <none>
[10:58:39.664] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.664] Resolved: TRUE
[10:58:39.664] Value: <not collected>
[10:58:39.664] Conditions captured: <none>
[10:58:39.664] Early signaling: FALSE
[10:58:39.664] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.664] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.672] Chunk #1 of 2 ... DONE
[10:58:39.672] Chunk #2 of 2 ...
[10:58:39.672]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.672]  - seeds: <none>
[10:58:39.672]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.672] getGlobalsAndPackages() ...
[10:58:39.673] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.673] Resolving globals: FALSE
[10:58:39.673] Tweak future expression to call with '...' arguments ...
[10:58:39.673] {
[10:58:39.673]     do.call(function(...) {
[10:58:39.673]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.673]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.673]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.673]             on.exit(options(oopts), add = TRUE)
[10:58:39.673]         }
[10:58:39.673]         {
[10:58:39.673]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.673]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.673]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.673]             })
[10:58:39.673]         }
[10:58:39.673]     }, args = future.call.arguments)
[10:58:39.673] }
[10:58:39.673] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.674] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.674] 
[10:58:39.675] getGlobalsAndPackages() ... DONE
[10:58:39.675] run() for ‘Future’ ...
[10:58:39.675] - state: ‘created’
[10:58:39.675] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.678] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.678]   - Field: ‘label’
[10:58:39.679]   - Field: ‘local’
[10:58:39.679]   - Field: ‘owner’
[10:58:39.679]   - Field: ‘envir’
[10:58:39.679]   - Field: ‘workers’
[10:58:39.679]   - Field: ‘packages’
[10:58:39.679]   - Field: ‘gc’
[10:58:39.679]   - Field: ‘job’
[10:58:39.680]   - Field: ‘conditions’
[10:58:39.680]   - Field: ‘expr’
[10:58:39.680]   - Field: ‘uuid’
[10:58:39.680]   - Field: ‘seed’
[10:58:39.680]   - Field: ‘version’
[10:58:39.680]   - Field: ‘result’
[10:58:39.681]   - Field: ‘asynchronous’
[10:58:39.681]   - Field: ‘calls’
[10:58:39.681]   - Field: ‘globals’
[10:58:39.681]   - Field: ‘stdout’
[10:58:39.681]   - Field: ‘earlySignal’
[10:58:39.681]   - Field: ‘lazy’
[10:58:39.681]   - Field: ‘state’
[10:58:39.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.682] - Launch lazy future ...
[10:58:39.682] Packages needed by the future expression (n = 0): <none>
[10:58:39.682] Packages needed by future strategies (n = 0): <none>
[10:58:39.683] {
[10:58:39.683]     {
[10:58:39.683]         {
[10:58:39.683]             ...future.startTime <- base::Sys.time()
[10:58:39.683]             {
[10:58:39.683]                 {
[10:58:39.683]                   {
[10:58:39.683]                     {
[10:58:39.683]                       base::local({
[10:58:39.683]                         has_future <- base::requireNamespace("future", 
[10:58:39.683]                           quietly = TRUE)
[10:58:39.683]                         if (has_future) {
[10:58:39.683]                           ns <- base::getNamespace("future")
[10:58:39.683]                           version <- ns[[".package"]][["version"]]
[10:58:39.683]                           if (is.null(version)) 
[10:58:39.683]                             version <- utils::packageVersion("future")
[10:58:39.683]                         }
[10:58:39.683]                         else {
[10:58:39.683]                           version <- NULL
[10:58:39.683]                         }
[10:58:39.683]                         if (!has_future || version < "1.8.0") {
[10:58:39.683]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.683]                             "", base::R.version$version.string), 
[10:58:39.683]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.683]                               "release", "version")], collapse = " "), 
[10:58:39.683]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.683]                             info)
[10:58:39.683]                           info <- base::paste(info, collapse = "; ")
[10:58:39.683]                           if (!has_future) {
[10:58:39.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.683]                               info)
[10:58:39.683]                           }
[10:58:39.683]                           else {
[10:58:39.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.683]                               info, version)
[10:58:39.683]                           }
[10:58:39.683]                           base::stop(msg)
[10:58:39.683]                         }
[10:58:39.683]                       })
[10:58:39.683]                     }
[10:58:39.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.683]                     base::options(mc.cores = 1L)
[10:58:39.683]                   }
[10:58:39.683]                   ...future.strategy.old <- future::plan("list")
[10:58:39.683]                   options(future.plan = NULL)
[10:58:39.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.683]                 }
[10:58:39.683]                 ...future.workdir <- getwd()
[10:58:39.683]             }
[10:58:39.683]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.683]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.683]         }
[10:58:39.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.683]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.683]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.683]             base::names(...future.oldOptions))
[10:58:39.683]     }
[10:58:39.683]     if (FALSE) {
[10:58:39.683]     }
[10:58:39.683]     else {
[10:58:39.683]         if (TRUE) {
[10:58:39.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.683]                 open = "w")
[10:58:39.683]         }
[10:58:39.683]         else {
[10:58:39.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.683]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.683]         }
[10:58:39.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.683]             base::sink(type = "output", split = FALSE)
[10:58:39.683]             base::close(...future.stdout)
[10:58:39.683]         }, add = TRUE)
[10:58:39.683]     }
[10:58:39.683]     ...future.frame <- base::sys.nframe()
[10:58:39.683]     ...future.conditions <- base::list()
[10:58:39.683]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.683]     if (FALSE) {
[10:58:39.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.683]     }
[10:58:39.683]     ...future.result <- base::tryCatch({
[10:58:39.683]         base::withCallingHandlers({
[10:58:39.683]             ...future.value <- base::withVisible(base::local({
[10:58:39.683]                 withCallingHandlers({
[10:58:39.683]                   {
[10:58:39.683]                     do.call(function(...) {
[10:58:39.683]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.683]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.683]                         ...future.globals.maxSize)) {
[10:58:39.683]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.683]                         on.exit(options(oopts), add = TRUE)
[10:58:39.683]                       }
[10:58:39.683]                       {
[10:58:39.683]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.683]                           FUN = function(jj) {
[10:58:39.683]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.683]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.683]                           })
[10:58:39.683]                       }
[10:58:39.683]                     }, args = future.call.arguments)
[10:58:39.683]                   }
[10:58:39.683]                 }, immediateCondition = function(cond) {
[10:58:39.683]                   save_rds <- function (object, pathname, ...) 
[10:58:39.683]                   {
[10:58:39.683]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.683]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.683]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.683]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.683]                         fi_tmp[["mtime"]])
[10:58:39.683]                     }
[10:58:39.683]                     tryCatch({
[10:58:39.683]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.683]                     }, error = function(ex) {
[10:58:39.683]                       msg <- conditionMessage(ex)
[10:58:39.683]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.683]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.683]                         fi_tmp[["mtime"]], msg)
[10:58:39.683]                       ex$message <- msg
[10:58:39.683]                       stop(ex)
[10:58:39.683]                     })
[10:58:39.683]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.683]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.683]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.683]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.683]                       fi <- file.info(pathname)
[10:58:39.683]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.683]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.683]                         fi[["size"]], fi[["mtime"]])
[10:58:39.683]                       stop(msg)
[10:58:39.683]                     }
[10:58:39.683]                     invisible(pathname)
[10:58:39.683]                   }
[10:58:39.683]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.683]                     rootPath = tempdir()) 
[10:58:39.683]                   {
[10:58:39.683]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.683]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.683]                       tmpdir = path, fileext = ".rds")
[10:58:39.683]                     save_rds(obj, file)
[10:58:39.683]                   }
[10:58:39.683]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.683]                   {
[10:58:39.683]                     inherits <- base::inherits
[10:58:39.683]                     invokeRestart <- base::invokeRestart
[10:58:39.683]                     is.null <- base::is.null
[10:58:39.683]                     muffled <- FALSE
[10:58:39.683]                     if (inherits(cond, "message")) {
[10:58:39.683]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.683]                       if (muffled) 
[10:58:39.683]                         invokeRestart("muffleMessage")
[10:58:39.683]                     }
[10:58:39.683]                     else if (inherits(cond, "warning")) {
[10:58:39.683]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.683]                       if (muffled) 
[10:58:39.683]                         invokeRestart("muffleWarning")
[10:58:39.683]                     }
[10:58:39.683]                     else if (inherits(cond, "condition")) {
[10:58:39.683]                       if (!is.null(pattern)) {
[10:58:39.683]                         computeRestarts <- base::computeRestarts
[10:58:39.683]                         grepl <- base::grepl
[10:58:39.683]                         restarts <- computeRestarts(cond)
[10:58:39.683]                         for (restart in restarts) {
[10:58:39.683]                           name <- restart$name
[10:58:39.683]                           if (is.null(name)) 
[10:58:39.683]                             next
[10:58:39.683]                           if (!grepl(pattern, name)) 
[10:58:39.683]                             next
[10:58:39.683]                           invokeRestart(restart)
[10:58:39.683]                           muffled <- TRUE
[10:58:39.683]                           break
[10:58:39.683]                         }
[10:58:39.683]                       }
[10:58:39.683]                     }
[10:58:39.683]                     invisible(muffled)
[10:58:39.683]                   }
[10:58:39.683]                   muffleCondition(cond)
[10:58:39.683]                 })
[10:58:39.683]             }))
[10:58:39.683]             future::FutureResult(value = ...future.value$value, 
[10:58:39.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.683]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.683]                     ...future.globalenv.names))
[10:58:39.683]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.683]         }, condition = base::local({
[10:58:39.683]             c <- base::c
[10:58:39.683]             inherits <- base::inherits
[10:58:39.683]             invokeRestart <- base::invokeRestart
[10:58:39.683]             length <- base::length
[10:58:39.683]             list <- base::list
[10:58:39.683]             seq.int <- base::seq.int
[10:58:39.683]             signalCondition <- base::signalCondition
[10:58:39.683]             sys.calls <- base::sys.calls
[10:58:39.683]             `[[` <- base::`[[`
[10:58:39.683]             `+` <- base::`+`
[10:58:39.683]             `<<-` <- base::`<<-`
[10:58:39.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.683]                   3L)]
[10:58:39.683]             }
[10:58:39.683]             function(cond) {
[10:58:39.683]                 is_error <- inherits(cond, "error")
[10:58:39.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.683]                   NULL)
[10:58:39.683]                 if (is_error) {
[10:58:39.683]                   sessionInformation <- function() {
[10:58:39.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.683]                       search = base::search(), system = base::Sys.info())
[10:58:39.683]                   }
[10:58:39.683]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.683]                     cond$call), session = sessionInformation(), 
[10:58:39.683]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.683]                   signalCondition(cond)
[10:58:39.683]                 }
[10:58:39.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.683]                 "immediateCondition"))) {
[10:58:39.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.683]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.683]                   if (TRUE && !signal) {
[10:58:39.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.683]                     {
[10:58:39.683]                       inherits <- base::inherits
[10:58:39.683]                       invokeRestart <- base::invokeRestart
[10:58:39.683]                       is.null <- base::is.null
[10:58:39.683]                       muffled <- FALSE
[10:58:39.683]                       if (inherits(cond, "message")) {
[10:58:39.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.683]                         if (muffled) 
[10:58:39.683]                           invokeRestart("muffleMessage")
[10:58:39.683]                       }
[10:58:39.683]                       else if (inherits(cond, "warning")) {
[10:58:39.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.683]                         if (muffled) 
[10:58:39.683]                           invokeRestart("muffleWarning")
[10:58:39.683]                       }
[10:58:39.683]                       else if (inherits(cond, "condition")) {
[10:58:39.683]                         if (!is.null(pattern)) {
[10:58:39.683]                           computeRestarts <- base::computeRestarts
[10:58:39.683]                           grepl <- base::grepl
[10:58:39.683]                           restarts <- computeRestarts(cond)
[10:58:39.683]                           for (restart in restarts) {
[10:58:39.683]                             name <- restart$name
[10:58:39.683]                             if (is.null(name)) 
[10:58:39.683]                               next
[10:58:39.683]                             if (!grepl(pattern, name)) 
[10:58:39.683]                               next
[10:58:39.683]                             invokeRestart(restart)
[10:58:39.683]                             muffled <- TRUE
[10:58:39.683]                             break
[10:58:39.683]                           }
[10:58:39.683]                         }
[10:58:39.683]                       }
[10:58:39.683]                       invisible(muffled)
[10:58:39.683]                     }
[10:58:39.683]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.683]                   }
[10:58:39.683]                 }
[10:58:39.683]                 else {
[10:58:39.683]                   if (TRUE) {
[10:58:39.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.683]                     {
[10:58:39.683]                       inherits <- base::inherits
[10:58:39.683]                       invokeRestart <- base::invokeRestart
[10:58:39.683]                       is.null <- base::is.null
[10:58:39.683]                       muffled <- FALSE
[10:58:39.683]                       if (inherits(cond, "message")) {
[10:58:39.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.683]                         if (muffled) 
[10:58:39.683]                           invokeRestart("muffleMessage")
[10:58:39.683]                       }
[10:58:39.683]                       else if (inherits(cond, "warning")) {
[10:58:39.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.683]                         if (muffled) 
[10:58:39.683]                           invokeRestart("muffleWarning")
[10:58:39.683]                       }
[10:58:39.683]                       else if (inherits(cond, "condition")) {
[10:58:39.683]                         if (!is.null(pattern)) {
[10:58:39.683]                           computeRestarts <- base::computeRestarts
[10:58:39.683]                           grepl <- base::grepl
[10:58:39.683]                           restarts <- computeRestarts(cond)
[10:58:39.683]                           for (restart in restarts) {
[10:58:39.683]                             name <- restart$name
[10:58:39.683]                             if (is.null(name)) 
[10:58:39.683]                               next
[10:58:39.683]                             if (!grepl(pattern, name)) 
[10:58:39.683]                               next
[10:58:39.683]                             invokeRestart(restart)
[10:58:39.683]                             muffled <- TRUE
[10:58:39.683]                             break
[10:58:39.683]                           }
[10:58:39.683]                         }
[10:58:39.683]                       }
[10:58:39.683]                       invisible(muffled)
[10:58:39.683]                     }
[10:58:39.683]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.683]                   }
[10:58:39.683]                 }
[10:58:39.683]             }
[10:58:39.683]         }))
[10:58:39.683]     }, error = function(ex) {
[10:58:39.683]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.683]                 ...future.rng), started = ...future.startTime, 
[10:58:39.683]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.683]             version = "1.8"), class = "FutureResult")
[10:58:39.683]     }, finally = {
[10:58:39.683]         if (!identical(...future.workdir, getwd())) 
[10:58:39.683]             setwd(...future.workdir)
[10:58:39.683]         {
[10:58:39.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.683]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.683]             }
[10:58:39.683]             base::options(...future.oldOptions)
[10:58:39.683]             if (.Platform$OS.type == "windows") {
[10:58:39.683]                 old_names <- names(...future.oldEnvVars)
[10:58:39.683]                 envs <- base::Sys.getenv()
[10:58:39.683]                 names <- names(envs)
[10:58:39.683]                 common <- intersect(names, old_names)
[10:58:39.683]                 added <- setdiff(names, old_names)
[10:58:39.683]                 removed <- setdiff(old_names, names)
[10:58:39.683]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.683]                   envs[common]]
[10:58:39.683]                 NAMES <- toupper(changed)
[10:58:39.683]                 args <- list()
[10:58:39.683]                 for (kk in seq_along(NAMES)) {
[10:58:39.683]                   name <- changed[[kk]]
[10:58:39.683]                   NAME <- NAMES[[kk]]
[10:58:39.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.683]                     next
[10:58:39.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.683]                 }
[10:58:39.683]                 NAMES <- toupper(added)
[10:58:39.683]                 for (kk in seq_along(NAMES)) {
[10:58:39.683]                   name <- added[[kk]]
[10:58:39.683]                   NAME <- NAMES[[kk]]
[10:58:39.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.683]                     next
[10:58:39.683]                   args[[name]] <- ""
[10:58:39.683]                 }
[10:58:39.683]                 NAMES <- toupper(removed)
[10:58:39.683]                 for (kk in seq_along(NAMES)) {
[10:58:39.683]                   name <- removed[[kk]]
[10:58:39.683]                   NAME <- NAMES[[kk]]
[10:58:39.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.683]                     next
[10:58:39.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.683]                 }
[10:58:39.683]                 if (length(args) > 0) 
[10:58:39.683]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.683]             }
[10:58:39.683]             else {
[10:58:39.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.683]             }
[10:58:39.683]             {
[10:58:39.683]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.683]                   0L) {
[10:58:39.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.683]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.683]                   base::options(opts)
[10:58:39.683]                 }
[10:58:39.683]                 {
[10:58:39.683]                   {
[10:58:39.683]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.683]                     NULL
[10:58:39.683]                   }
[10:58:39.683]                   options(future.plan = NULL)
[10:58:39.683]                   if (is.na(NA_character_)) 
[10:58:39.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.683]                     .init = FALSE)
[10:58:39.683]                 }
[10:58:39.683]             }
[10:58:39.683]         }
[10:58:39.683]     })
[10:58:39.683]     if (TRUE) {
[10:58:39.683]         base::sink(type = "output", split = FALSE)
[10:58:39.683]         if (TRUE) {
[10:58:39.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.683]         }
[10:58:39.683]         else {
[10:58:39.683]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.683]         }
[10:58:39.683]         base::close(...future.stdout)
[10:58:39.683]         ...future.stdout <- NULL
[10:58:39.683]     }
[10:58:39.683]     ...future.result$conditions <- ...future.conditions
[10:58:39.683]     ...future.result$finished <- base::Sys.time()
[10:58:39.683]     ...future.result
[10:58:39.683] }
[10:58:39.686] assign_globals() ...
[10:58:39.686] List of 5
[10:58:39.686]  $ future.call.arguments    : list()
[10:58:39.686]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.686]  $ ...future.FUN            :function (x)  
[10:58:39.686]  $ ...future.elements_ii    :List of 1
[10:58:39.686]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[10:58:39.686]  $ ...future.seeds_ii       : NULL
[10:58:39.686]  $ ...future.globals.maxSize: num Inf
[10:58:39.686]  - attr(*, "resolved")= logi FALSE
[10:58:39.686]  - attr(*, "total_size")= num NA
[10:58:39.686]  - attr(*, "where")=List of 5
[10:58:39.686]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.686]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.686]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.686]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.686]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.686]  - attr(*, "already-done")= logi TRUE
[10:58:39.694] - copied ‘future.call.arguments’ to environment
[10:58:39.694] - copied ‘...future.FUN’ to environment
[10:58:39.694] - copied ‘...future.elements_ii’ to environment
[10:58:39.694] - copied ‘...future.seeds_ii’ to environment
[10:58:39.694] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.694] assign_globals() ... done
[10:58:39.694] requestCore(): workers = 2
[10:58:39.696] MulticoreFuture started
[10:58:39.697] - Launch lazy future ... done
[10:58:39.697] run() for ‘MulticoreFuture’ ... done
[10:58:39.698] Created future:
[10:58:39.698] plan(): Setting new future strategy stack:
[10:58:39.698] List of future strategies:
[10:58:39.698] 1. sequential:
[10:58:39.698]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.698]    - tweaked: FALSE
[10:58:39.698]    - call: NULL
[10:58:39.699] plan(): nbrOfWorkers() = 1
[10:58:39.701] plan(): Setting new future strategy stack:
[10:58:39.701] List of future strategies:
[10:58:39.701] 1. multicore:
[10:58:39.701]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.701]    - tweaked: FALSE
[10:58:39.701]    - call: plan(strategy)
[10:58:39.707] plan(): nbrOfWorkers() = 2
[10:58:39.698] MulticoreFuture:
[10:58:39.698] Label: ‘future_apply-2’
[10:58:39.698] Expression:
[10:58:39.698] {
[10:58:39.698]     do.call(function(...) {
[10:58:39.698]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.698]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.698]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.698]             on.exit(options(oopts), add = TRUE)
[10:58:39.698]         }
[10:58:39.698]         {
[10:58:39.698]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.698]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.698]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.698]             })
[10:58:39.698]         }
[10:58:39.698]     }, args = future.call.arguments)
[10:58:39.698] }
[10:58:39.698] Lazy evaluation: FALSE
[10:58:39.698] Asynchronous evaluation: TRUE
[10:58:39.698] Local evaluation: TRUE
[10:58:39.698] Environment: R_GlobalEnv
[10:58:39.698] Capture standard output: TRUE
[10:58:39.698] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.698] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.698] Packages: <none>
[10:58:39.698] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.698] Resolved: TRUE
[10:58:39.698] Value: <not collected>
[10:58:39.698] Conditions captured: <none>
[10:58:39.698] Early signaling: FALSE
[10:58:39.698] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.698] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.709] Chunk #2 of 2 ... DONE
[10:58:39.709] Launching 2 futures (chunks) ... DONE
[10:58:39.709] Resolving 2 futures (chunks) ...
[10:58:39.709] resolve() on list ...
[10:58:39.709]  recursive: 0
[10:58:39.709]  length: 2
[10:58:39.710] 
[10:58:39.710] Future #1
[10:58:39.710] result() for MulticoreFuture ...
[10:58:39.711] result() for MulticoreFuture ...
[10:58:39.711] result() for MulticoreFuture ... done
[10:58:39.713] result() for MulticoreFuture ... done
[10:58:39.713] result() for MulticoreFuture ...
[10:58:39.714] result() for MulticoreFuture ... done
[10:58:39.714] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:39.715] - nx: 2
[10:58:39.715] - relay: TRUE
[10:58:39.715] - stdout: TRUE
[10:58:39.716] - signal: TRUE
[10:58:39.716] - resignal: FALSE
[10:58:39.716] - force: TRUE
[10:58:39.716] - relayed: [n=2] FALSE, FALSE
[10:58:39.717] - queued futures: [n=2] FALSE, FALSE
[10:58:39.717]  - until=1
[10:58:39.717]  - relaying element #1
[10:58:39.717] result() for MulticoreFuture ...
[10:58:39.718] result() for MulticoreFuture ... done
[10:58:39.718] result() for MulticoreFuture ...
[10:58:39.718] result() for MulticoreFuture ... done
[10:58:39.719] result() for MulticoreFuture ...
[10:58:39.719] result() for MulticoreFuture ... done
[10:58:39.719] result() for MulticoreFuture ...
[10:58:39.719] result() for MulticoreFuture ... done
[10:58:39.720] - relayed: [n=2] TRUE, FALSE
[10:58:39.720] - queued futures: [n=2] TRUE, FALSE
[10:58:39.720] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:39.721]  length: 1 (resolved future 1)
[10:58:39.721] Future #2
[10:58:39.721] result() for MulticoreFuture ...
[10:58:39.722] result() for MulticoreFuture ...
[10:58:39.722] result() for MulticoreFuture ... done
[10:58:39.722] result() for MulticoreFuture ... done
[10:58:39.722] result() for MulticoreFuture ...
[10:58:39.722] result() for MulticoreFuture ... done
[10:58:39.723] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:39.723] - nx: 2
[10:58:39.723] - relay: TRUE
[10:58:39.723] - stdout: TRUE
[10:58:39.723] - signal: TRUE
[10:58:39.723] - resignal: FALSE
[10:58:39.723] - force: TRUE
[10:58:39.723] - relayed: [n=2] TRUE, FALSE
[10:58:39.723] - queued futures: [n=2] TRUE, FALSE
[10:58:39.724]  - until=2
[10:58:39.724]  - relaying element #2
[10:58:39.724] result() for MulticoreFuture ...
[10:58:39.724] result() for MulticoreFuture ... done
[10:58:39.724] result() for MulticoreFuture ...
[10:58:39.724] result() for MulticoreFuture ... done
[10:58:39.724] result() for MulticoreFuture ...
[10:58:39.724] result() for MulticoreFuture ... done
[10:58:39.725] result() for MulticoreFuture ...
[10:58:39.725] result() for MulticoreFuture ... done
[10:58:39.725] - relayed: [n=2] TRUE, TRUE
[10:58:39.725] - queued futures: [n=2] TRUE, TRUE
[10:58:39.725] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:39.725]  length: 0 (resolved future 2)
[10:58:39.725] Relaying remaining futures
[10:58:39.725] signalConditionsASAP(NULL, pos=0) ...
[10:58:39.725] - nx: 2
[10:58:39.725] - relay: TRUE
[10:58:39.726] - stdout: TRUE
[10:58:39.726] - signal: TRUE
[10:58:39.726] - resignal: FALSE
[10:58:39.726] - force: TRUE
[10:58:39.726] - relayed: [n=2] TRUE, TRUE
[10:58:39.726] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:39.726] - relayed: [n=2] TRUE, TRUE
[10:58:39.726] - queued futures: [n=2] TRUE, TRUE
[10:58:39.726] signalConditionsASAP(NULL, pos=0) ... done
[10:58:39.726] resolve() on list ... DONE
[10:58:39.727] result() for MulticoreFuture ...
[10:58:39.727] result() for MulticoreFuture ... done
[10:58:39.727] result() for MulticoreFuture ...
[10:58:39.727] result() for MulticoreFuture ... done
[10:58:39.727] result() for MulticoreFuture ...
[10:58:39.727] result() for MulticoreFuture ... done
[10:58:39.727] result() for MulticoreFuture ...
[10:58:39.727] result() for MulticoreFuture ... done
[10:58:39.727]  - Number of value chunks collected: 2
[10:58:39.728] Resolving 2 futures (chunks) ... DONE
[10:58:39.728] Reducing values from 2 chunks ...
[10:58:39.728]  - Number of values collected after concatenation: 2
[10:58:39.728]  - Number of values expected: 2
[10:58:39.728] Reducing values from 2 chunks ... DONE
[10:58:39.728] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:58:39.728] getGlobalsAndPackagesXApply() ...
[10:58:39.729]  - future.globals: TRUE
[10:58:39.729] getGlobalsAndPackages() ...
[10:58:39.729] Searching for globals...
[10:58:39.732] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:58:39.732] Searching for globals ... DONE
[10:58:39.732] Resolving globals: FALSE
[10:58:39.732] The total size of the 1 globals is 1.28 KiB (1311 bytes)
[10:58:39.733] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 1.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.28 KiB of class ‘function’)
[10:58:39.733] - globals: [1] ‘FUN’
[10:58:39.733] 
[10:58:39.733] getGlobalsAndPackages() ... DONE
[10:58:39.733]  - globals found/used: [n=1] ‘FUN’
[10:58:39.733]  - needed namespaces: [n=0] 
[10:58:39.733] Finding globals ... DONE
[10:58:39.734]  - use_args: TRUE
[10:58:39.734]  - Getting '...' globals ...
[10:58:39.734] resolve() on list ...
[10:58:39.734]  recursive: 0
[10:58:39.734]  length: 1
[10:58:39.734]  elements: ‘...’
[10:58:39.734]  length: 0 (resolved future 1)
[10:58:39.734] resolve() on list ... DONE
[10:58:39.735]    - '...' content: [n=0] 
[10:58:39.735] List of 1
[10:58:39.735]  $ ...: list()
[10:58:39.735]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.735]  - attr(*, "where")=List of 1
[10:58:39.735]   ..$ ...:<environment: 0x5635bdbe9920> 
[10:58:39.735]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.735]  - attr(*, "resolved")= logi TRUE
[10:58:39.735]  - attr(*, "total_size")= num NA
[10:58:39.737]  - Getting '...' globals ... DONE
[10:58:39.737] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:39.738] List of 2
[10:58:39.738]  $ ...future.FUN:function (x)  
[10:58:39.738]  $ ...          : list()
[10:58:39.738]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.738]  - attr(*, "where")=List of 2
[10:58:39.738]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:39.738]   ..$ ...          :<environment: 0x5635bdbe9920> 
[10:58:39.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.738]  - attr(*, "resolved")= logi FALSE
[10:58:39.738]  - attr(*, "total_size")= num 4449
[10:58:39.742] Packages to be attached in all futures: [n=0] 
[10:58:39.742] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.743] future_lapply() ...
[10:58:39.746] Number of chunks: 2
[10:58:39.746] getGlobalsAndPackagesXApply() ...
[10:58:39.746]  - future.globals: <name-value list> with names ‘list()’
[10:58:39.747]  - use_args: TRUE
[10:58:39.747] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:39.747] List of 2
[10:58:39.747]  $ ...          : list()
[10:58:39.747]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.747]  $ ...future.FUN:function (x)  
[10:58:39.747]  - attr(*, "where")=List of 2
[10:58:39.747]   ..$ ...          :<environment: 0x5635bdbe9920> 
[10:58:39.747]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:58:39.747]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.747]  - attr(*, "resolved")= logi FALSE
[10:58:39.747]  - attr(*, "total_size")= num NA
[10:58:39.749] Packages to be attached in all futures: [n=0] 
[10:58:39.749] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.750] Number of futures (= number of chunks): 2
[10:58:39.750] Launching 2 futures (chunks) ...
[10:58:39.750] Chunk #1 of 2 ...
[10:58:39.750]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.750]  - seeds: <none>
[10:58:39.750]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.750] getGlobalsAndPackages() ...
[10:58:39.750] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.750] Resolving globals: FALSE
[10:58:39.751] Tweak future expression to call with '...' arguments ...
[10:58:39.751] {
[10:58:39.751]     do.call(function(...) {
[10:58:39.751]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.751]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.751]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.751]             on.exit(options(oopts), add = TRUE)
[10:58:39.751]         }
[10:58:39.751]         {
[10:58:39.751]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.751]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.751]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.751]             })
[10:58:39.751]         }
[10:58:39.751]     }, args = future.call.arguments)
[10:58:39.751] }
[10:58:39.751] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.751] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.751] 
[10:58:39.751] getGlobalsAndPackages() ... DONE
[10:58:39.752] run() for ‘Future’ ...
[10:58:39.752] - state: ‘created’
[10:58:39.752] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.753] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.754]   - Field: ‘label’
[10:58:39.754]   - Field: ‘local’
[10:58:39.754]   - Field: ‘owner’
[10:58:39.754]   - Field: ‘envir’
[10:58:39.754]   - Field: ‘workers’
[10:58:39.754]   - Field: ‘packages’
[10:58:39.754]   - Field: ‘gc’
[10:58:39.754]   - Field: ‘job’
[10:58:39.754]   - Field: ‘conditions’
[10:58:39.754]   - Field: ‘expr’
[10:58:39.755]   - Field: ‘uuid’
[10:58:39.755]   - Field: ‘seed’
[10:58:39.755]   - Field: ‘version’
[10:58:39.755]   - Field: ‘result’
[10:58:39.755]   - Field: ‘asynchronous’
[10:58:39.755]   - Field: ‘calls’
[10:58:39.755]   - Field: ‘globals’
[10:58:39.755]   - Field: ‘stdout’
[10:58:39.755]   - Field: ‘earlySignal’
[10:58:39.755]   - Field: ‘lazy’
[10:58:39.755]   - Field: ‘state’
[10:58:39.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.756] - Launch lazy future ...
[10:58:39.756] Packages needed by the future expression (n = 0): <none>
[10:58:39.756] Packages needed by future strategies (n = 0): <none>
[10:58:39.756] {
[10:58:39.756]     {
[10:58:39.756]         {
[10:58:39.756]             ...future.startTime <- base::Sys.time()
[10:58:39.756]             {
[10:58:39.756]                 {
[10:58:39.756]                   {
[10:58:39.756]                     {
[10:58:39.756]                       base::local({
[10:58:39.756]                         has_future <- base::requireNamespace("future", 
[10:58:39.756]                           quietly = TRUE)
[10:58:39.756]                         if (has_future) {
[10:58:39.756]                           ns <- base::getNamespace("future")
[10:58:39.756]                           version <- ns[[".package"]][["version"]]
[10:58:39.756]                           if (is.null(version)) 
[10:58:39.756]                             version <- utils::packageVersion("future")
[10:58:39.756]                         }
[10:58:39.756]                         else {
[10:58:39.756]                           version <- NULL
[10:58:39.756]                         }
[10:58:39.756]                         if (!has_future || version < "1.8.0") {
[10:58:39.756]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.756]                             "", base::R.version$version.string), 
[10:58:39.756]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.756]                               "release", "version")], collapse = " "), 
[10:58:39.756]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.756]                             info)
[10:58:39.756]                           info <- base::paste(info, collapse = "; ")
[10:58:39.756]                           if (!has_future) {
[10:58:39.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.756]                               info)
[10:58:39.756]                           }
[10:58:39.756]                           else {
[10:58:39.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.756]                               info, version)
[10:58:39.756]                           }
[10:58:39.756]                           base::stop(msg)
[10:58:39.756]                         }
[10:58:39.756]                       })
[10:58:39.756]                     }
[10:58:39.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.756]                     base::options(mc.cores = 1L)
[10:58:39.756]                   }
[10:58:39.756]                   ...future.strategy.old <- future::plan("list")
[10:58:39.756]                   options(future.plan = NULL)
[10:58:39.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.756]                 }
[10:58:39.756]                 ...future.workdir <- getwd()
[10:58:39.756]             }
[10:58:39.756]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.756]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.756]         }
[10:58:39.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.756]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.756]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.756]             base::names(...future.oldOptions))
[10:58:39.756]     }
[10:58:39.756]     if (FALSE) {
[10:58:39.756]     }
[10:58:39.756]     else {
[10:58:39.756]         if (TRUE) {
[10:58:39.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.756]                 open = "w")
[10:58:39.756]         }
[10:58:39.756]         else {
[10:58:39.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.756]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.756]         }
[10:58:39.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.756]             base::sink(type = "output", split = FALSE)
[10:58:39.756]             base::close(...future.stdout)
[10:58:39.756]         }, add = TRUE)
[10:58:39.756]     }
[10:58:39.756]     ...future.frame <- base::sys.nframe()
[10:58:39.756]     ...future.conditions <- base::list()
[10:58:39.756]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.756]     if (FALSE) {
[10:58:39.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.756]     }
[10:58:39.756]     ...future.result <- base::tryCatch({
[10:58:39.756]         base::withCallingHandlers({
[10:58:39.756]             ...future.value <- base::withVisible(base::local({
[10:58:39.756]                 withCallingHandlers({
[10:58:39.756]                   {
[10:58:39.756]                     do.call(function(...) {
[10:58:39.756]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.756]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.756]                         ...future.globals.maxSize)) {
[10:58:39.756]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.756]                         on.exit(options(oopts), add = TRUE)
[10:58:39.756]                       }
[10:58:39.756]                       {
[10:58:39.756]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.756]                           FUN = function(jj) {
[10:58:39.756]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.756]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.756]                           })
[10:58:39.756]                       }
[10:58:39.756]                     }, args = future.call.arguments)
[10:58:39.756]                   }
[10:58:39.756]                 }, immediateCondition = function(cond) {
[10:58:39.756]                   save_rds <- function (object, pathname, ...) 
[10:58:39.756]                   {
[10:58:39.756]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.756]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.756]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.756]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.756]                         fi_tmp[["mtime"]])
[10:58:39.756]                     }
[10:58:39.756]                     tryCatch({
[10:58:39.756]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.756]                     }, error = function(ex) {
[10:58:39.756]                       msg <- conditionMessage(ex)
[10:58:39.756]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.756]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.756]                         fi_tmp[["mtime"]], msg)
[10:58:39.756]                       ex$message <- msg
[10:58:39.756]                       stop(ex)
[10:58:39.756]                     })
[10:58:39.756]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.756]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.756]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.756]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.756]                       fi <- file.info(pathname)
[10:58:39.756]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.756]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.756]                         fi[["size"]], fi[["mtime"]])
[10:58:39.756]                       stop(msg)
[10:58:39.756]                     }
[10:58:39.756]                     invisible(pathname)
[10:58:39.756]                   }
[10:58:39.756]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.756]                     rootPath = tempdir()) 
[10:58:39.756]                   {
[10:58:39.756]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.756]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.756]                       tmpdir = path, fileext = ".rds")
[10:58:39.756]                     save_rds(obj, file)
[10:58:39.756]                   }
[10:58:39.756]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.756]                   {
[10:58:39.756]                     inherits <- base::inherits
[10:58:39.756]                     invokeRestart <- base::invokeRestart
[10:58:39.756]                     is.null <- base::is.null
[10:58:39.756]                     muffled <- FALSE
[10:58:39.756]                     if (inherits(cond, "message")) {
[10:58:39.756]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.756]                       if (muffled) 
[10:58:39.756]                         invokeRestart("muffleMessage")
[10:58:39.756]                     }
[10:58:39.756]                     else if (inherits(cond, "warning")) {
[10:58:39.756]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.756]                       if (muffled) 
[10:58:39.756]                         invokeRestart("muffleWarning")
[10:58:39.756]                     }
[10:58:39.756]                     else if (inherits(cond, "condition")) {
[10:58:39.756]                       if (!is.null(pattern)) {
[10:58:39.756]                         computeRestarts <- base::computeRestarts
[10:58:39.756]                         grepl <- base::grepl
[10:58:39.756]                         restarts <- computeRestarts(cond)
[10:58:39.756]                         for (restart in restarts) {
[10:58:39.756]                           name <- restart$name
[10:58:39.756]                           if (is.null(name)) 
[10:58:39.756]                             next
[10:58:39.756]                           if (!grepl(pattern, name)) 
[10:58:39.756]                             next
[10:58:39.756]                           invokeRestart(restart)
[10:58:39.756]                           muffled <- TRUE
[10:58:39.756]                           break
[10:58:39.756]                         }
[10:58:39.756]                       }
[10:58:39.756]                     }
[10:58:39.756]                     invisible(muffled)
[10:58:39.756]                   }
[10:58:39.756]                   muffleCondition(cond)
[10:58:39.756]                 })
[10:58:39.756]             }))
[10:58:39.756]             future::FutureResult(value = ...future.value$value, 
[10:58:39.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.756]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.756]                     ...future.globalenv.names))
[10:58:39.756]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.756]         }, condition = base::local({
[10:58:39.756]             c <- base::c
[10:58:39.756]             inherits <- base::inherits
[10:58:39.756]             invokeRestart <- base::invokeRestart
[10:58:39.756]             length <- base::length
[10:58:39.756]             list <- base::list
[10:58:39.756]             seq.int <- base::seq.int
[10:58:39.756]             signalCondition <- base::signalCondition
[10:58:39.756]             sys.calls <- base::sys.calls
[10:58:39.756]             `[[` <- base::`[[`
[10:58:39.756]             `+` <- base::`+`
[10:58:39.756]             `<<-` <- base::`<<-`
[10:58:39.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.756]                   3L)]
[10:58:39.756]             }
[10:58:39.756]             function(cond) {
[10:58:39.756]                 is_error <- inherits(cond, "error")
[10:58:39.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.756]                   NULL)
[10:58:39.756]                 if (is_error) {
[10:58:39.756]                   sessionInformation <- function() {
[10:58:39.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.756]                       search = base::search(), system = base::Sys.info())
[10:58:39.756]                   }
[10:58:39.756]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.756]                     cond$call), session = sessionInformation(), 
[10:58:39.756]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.756]                   signalCondition(cond)
[10:58:39.756]                 }
[10:58:39.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.756]                 "immediateCondition"))) {
[10:58:39.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.756]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.756]                   if (TRUE && !signal) {
[10:58:39.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.756]                     {
[10:58:39.756]                       inherits <- base::inherits
[10:58:39.756]                       invokeRestart <- base::invokeRestart
[10:58:39.756]                       is.null <- base::is.null
[10:58:39.756]                       muffled <- FALSE
[10:58:39.756]                       if (inherits(cond, "message")) {
[10:58:39.756]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.756]                         if (muffled) 
[10:58:39.756]                           invokeRestart("muffleMessage")
[10:58:39.756]                       }
[10:58:39.756]                       else if (inherits(cond, "warning")) {
[10:58:39.756]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.756]                         if (muffled) 
[10:58:39.756]                           invokeRestart("muffleWarning")
[10:58:39.756]                       }
[10:58:39.756]                       else if (inherits(cond, "condition")) {
[10:58:39.756]                         if (!is.null(pattern)) {
[10:58:39.756]                           computeRestarts <- base::computeRestarts
[10:58:39.756]                           grepl <- base::grepl
[10:58:39.756]                           restarts <- computeRestarts(cond)
[10:58:39.756]                           for (restart in restarts) {
[10:58:39.756]                             name <- restart$name
[10:58:39.756]                             if (is.null(name)) 
[10:58:39.756]                               next
[10:58:39.756]                             if (!grepl(pattern, name)) 
[10:58:39.756]                               next
[10:58:39.756]                             invokeRestart(restart)
[10:58:39.756]                             muffled <- TRUE
[10:58:39.756]                             break
[10:58:39.756]                           }
[10:58:39.756]                         }
[10:58:39.756]                       }
[10:58:39.756]                       invisible(muffled)
[10:58:39.756]                     }
[10:58:39.756]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.756]                   }
[10:58:39.756]                 }
[10:58:39.756]                 else {
[10:58:39.756]                   if (TRUE) {
[10:58:39.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.756]                     {
[10:58:39.756]                       inherits <- base::inherits
[10:58:39.756]                       invokeRestart <- base::invokeRestart
[10:58:39.756]                       is.null <- base::is.null
[10:58:39.756]                       muffled <- FALSE
[10:58:39.756]                       if (inherits(cond, "message")) {
[10:58:39.756]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.756]                         if (muffled) 
[10:58:39.756]                           invokeRestart("muffleMessage")
[10:58:39.756]                       }
[10:58:39.756]                       else if (inherits(cond, "warning")) {
[10:58:39.756]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.756]                         if (muffled) 
[10:58:39.756]                           invokeRestart("muffleWarning")
[10:58:39.756]                       }
[10:58:39.756]                       else if (inherits(cond, "condition")) {
[10:58:39.756]                         if (!is.null(pattern)) {
[10:58:39.756]                           computeRestarts <- base::computeRestarts
[10:58:39.756]                           grepl <- base::grepl
[10:58:39.756]                           restarts <- computeRestarts(cond)
[10:58:39.756]                           for (restart in restarts) {
[10:58:39.756]                             name <- restart$name
[10:58:39.756]                             if (is.null(name)) 
[10:58:39.756]                               next
[10:58:39.756]                             if (!grepl(pattern, name)) 
[10:58:39.756]                               next
[10:58:39.756]                             invokeRestart(restart)
[10:58:39.756]                             muffled <- TRUE
[10:58:39.756]                             break
[10:58:39.756]                           }
[10:58:39.756]                         }
[10:58:39.756]                       }
[10:58:39.756]                       invisible(muffled)
[10:58:39.756]                     }
[10:58:39.756]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.756]                   }
[10:58:39.756]                 }
[10:58:39.756]             }
[10:58:39.756]         }))
[10:58:39.756]     }, error = function(ex) {
[10:58:39.756]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.756]                 ...future.rng), started = ...future.startTime, 
[10:58:39.756]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.756]             version = "1.8"), class = "FutureResult")
[10:58:39.756]     }, finally = {
[10:58:39.756]         if (!identical(...future.workdir, getwd())) 
[10:58:39.756]             setwd(...future.workdir)
[10:58:39.756]         {
[10:58:39.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.756]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.756]             }
[10:58:39.756]             base::options(...future.oldOptions)
[10:58:39.756]             if (.Platform$OS.type == "windows") {
[10:58:39.756]                 old_names <- names(...future.oldEnvVars)
[10:58:39.756]                 envs <- base::Sys.getenv()
[10:58:39.756]                 names <- names(envs)
[10:58:39.756]                 common <- intersect(names, old_names)
[10:58:39.756]                 added <- setdiff(names, old_names)
[10:58:39.756]                 removed <- setdiff(old_names, names)
[10:58:39.756]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.756]                   envs[common]]
[10:58:39.756]                 NAMES <- toupper(changed)
[10:58:39.756]                 args <- list()
[10:58:39.756]                 for (kk in seq_along(NAMES)) {
[10:58:39.756]                   name <- changed[[kk]]
[10:58:39.756]                   NAME <- NAMES[[kk]]
[10:58:39.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.756]                     next
[10:58:39.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.756]                 }
[10:58:39.756]                 NAMES <- toupper(added)
[10:58:39.756]                 for (kk in seq_along(NAMES)) {
[10:58:39.756]                   name <- added[[kk]]
[10:58:39.756]                   NAME <- NAMES[[kk]]
[10:58:39.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.756]                     next
[10:58:39.756]                   args[[name]] <- ""
[10:58:39.756]                 }
[10:58:39.756]                 NAMES <- toupper(removed)
[10:58:39.756]                 for (kk in seq_along(NAMES)) {
[10:58:39.756]                   name <- removed[[kk]]
[10:58:39.756]                   NAME <- NAMES[[kk]]
[10:58:39.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.756]                     next
[10:58:39.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.756]                 }
[10:58:39.756]                 if (length(args) > 0) 
[10:58:39.756]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.756]             }
[10:58:39.756]             else {
[10:58:39.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.756]             }
[10:58:39.756]             {
[10:58:39.756]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.756]                   0L) {
[10:58:39.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.756]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.756]                   base::options(opts)
[10:58:39.756]                 }
[10:58:39.756]                 {
[10:58:39.756]                   {
[10:58:39.756]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.756]                     NULL
[10:58:39.756]                   }
[10:58:39.756]                   options(future.plan = NULL)
[10:58:39.756]                   if (is.na(NA_character_)) 
[10:58:39.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.756]                     .init = FALSE)
[10:58:39.756]                 }
[10:58:39.756]             }
[10:58:39.756]         }
[10:58:39.756]     })
[10:58:39.756]     if (TRUE) {
[10:58:39.756]         base::sink(type = "output", split = FALSE)
[10:58:39.756]         if (TRUE) {
[10:58:39.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.756]         }
[10:58:39.756]         else {
[10:58:39.756]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.756]         }
[10:58:39.756]         base::close(...future.stdout)
[10:58:39.756]         ...future.stdout <- NULL
[10:58:39.756]     }
[10:58:39.756]     ...future.result$conditions <- ...future.conditions
[10:58:39.756]     ...future.result$finished <- base::Sys.time()
[10:58:39.756]     ...future.result
[10:58:39.756] }
[10:58:39.759] assign_globals() ...
[10:58:39.759] List of 5
[10:58:39.759]  $ future.call.arguments    : list()
[10:58:39.759]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.759]  $ ...future.FUN            :function (x)  
[10:58:39.759]  $ ...future.elements_ii    :List of 1
[10:58:39.759]   ..$ : int [1:2] 1 3
[10:58:39.759]  $ ...future.seeds_ii       : NULL
[10:58:39.759]  $ ...future.globals.maxSize: num Inf
[10:58:39.759]  - attr(*, "resolved")= logi FALSE
[10:58:39.759]  - attr(*, "total_size")= num NA
[10:58:39.759]  - attr(*, "where")=List of 5
[10:58:39.759]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.759]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.759]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.759]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.759]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.759]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.759]  - attr(*, "already-done")= logi TRUE
[10:58:39.764] - copied ‘future.call.arguments’ to environment
[10:58:39.764] - reassign environment for ‘...future.FUN’
[10:58:39.765] - copied ‘...future.FUN’ to environment
[10:58:39.765] - copied ‘...future.elements_ii’ to environment
[10:58:39.765] - copied ‘...future.seeds_ii’ to environment
[10:58:39.765] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.765] assign_globals() ... done
[10:58:39.765] requestCore(): workers = 2
[10:58:39.767] MulticoreFuture started
[10:58:39.767] - Launch lazy future ... done
[10:58:39.768] run() for ‘MulticoreFuture’ ... done
[10:58:39.768] plan(): Setting new future strategy stack:
[10:58:39.768] Created future:
[10:58:39.768] List of future strategies:
[10:58:39.768] 1. sequential:
[10:58:39.768]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.768]    - tweaked: FALSE
[10:58:39.768]    - call: NULL
[10:58:39.769] plan(): nbrOfWorkers() = 1
[10:58:39.772] plan(): Setting new future strategy stack:
[10:58:39.772] List of future strategies:
[10:58:39.772] 1. multicore:
[10:58:39.772]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.772]    - tweaked: FALSE
[10:58:39.772]    - call: plan(strategy)
[10:58:39.775] plan(): nbrOfWorkers() = 2
[10:58:39.768] MulticoreFuture:
[10:58:39.768] Label: ‘future_apply-1’
[10:58:39.768] Expression:
[10:58:39.768] {
[10:58:39.768]     do.call(function(...) {
[10:58:39.768]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.768]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.768]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.768]             on.exit(options(oopts), add = TRUE)
[10:58:39.768]         }
[10:58:39.768]         {
[10:58:39.768]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.768]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.768]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.768]             })
[10:58:39.768]         }
[10:58:39.768]     }, args = future.call.arguments)
[10:58:39.768] }
[10:58:39.768] Lazy evaluation: FALSE
[10:58:39.768] Asynchronous evaluation: TRUE
[10:58:39.768] Local evaluation: TRUE
[10:58:39.768] Environment: R_GlobalEnv
[10:58:39.768] Capture standard output: TRUE
[10:58:39.768] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.768] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.768] Packages: <none>
[10:58:39.768] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.768] Resolved: TRUE
[10:58:39.768] Value: <not collected>
[10:58:39.768] Conditions captured: <none>
[10:58:39.768] Early signaling: FALSE
[10:58:39.768] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.768] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.776] Chunk #1 of 2 ... DONE
[10:58:39.776] Chunk #2 of 2 ...
[10:58:39.777]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.777]  - seeds: <none>
[10:58:39.777]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.777] getGlobalsAndPackages() ...
[10:58:39.777] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.778] Resolving globals: FALSE
[10:58:39.778] Tweak future expression to call with '...' arguments ...
[10:58:39.778] {
[10:58:39.778]     do.call(function(...) {
[10:58:39.778]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.778]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.778]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.778]             on.exit(options(oopts), add = TRUE)
[10:58:39.778]         }
[10:58:39.778]         {
[10:58:39.778]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.778]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.778]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.778]             })
[10:58:39.778]         }
[10:58:39.778]     }, args = future.call.arguments)
[10:58:39.778] }
[10:58:39.778] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.779] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.779] 
[10:58:39.779] getGlobalsAndPackages() ... DONE
[10:58:39.780] run() for ‘Future’ ...
[10:58:39.780] - state: ‘created’
[10:58:39.780] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.783] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.783] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.783]   - Field: ‘label’
[10:58:39.783]   - Field: ‘local’
[10:58:39.783]   - Field: ‘owner’
[10:58:39.784]   - Field: ‘envir’
[10:58:39.784]   - Field: ‘workers’
[10:58:39.784]   - Field: ‘packages’
[10:58:39.784]   - Field: ‘gc’
[10:58:39.784]   - Field: ‘job’
[10:58:39.784]   - Field: ‘conditions’
[10:58:39.784]   - Field: ‘expr’
[10:58:39.785]   - Field: ‘uuid’
[10:58:39.785]   - Field: ‘seed’
[10:58:39.785]   - Field: ‘version’
[10:58:39.785]   - Field: ‘result’
[10:58:39.785]   - Field: ‘asynchronous’
[10:58:39.785]   - Field: ‘calls’
[10:58:39.785]   - Field: ‘globals’
[10:58:39.786]   - Field: ‘stdout’
[10:58:39.786]   - Field: ‘earlySignal’
[10:58:39.786]   - Field: ‘lazy’
[10:58:39.786]   - Field: ‘state’
[10:58:39.786] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.786] - Launch lazy future ...
[10:58:39.787] Packages needed by the future expression (n = 0): <none>
[10:58:39.787] Packages needed by future strategies (n = 0): <none>
[10:58:39.788] {
[10:58:39.788]     {
[10:58:39.788]         {
[10:58:39.788]             ...future.startTime <- base::Sys.time()
[10:58:39.788]             {
[10:58:39.788]                 {
[10:58:39.788]                   {
[10:58:39.788]                     {
[10:58:39.788]                       base::local({
[10:58:39.788]                         has_future <- base::requireNamespace("future", 
[10:58:39.788]                           quietly = TRUE)
[10:58:39.788]                         if (has_future) {
[10:58:39.788]                           ns <- base::getNamespace("future")
[10:58:39.788]                           version <- ns[[".package"]][["version"]]
[10:58:39.788]                           if (is.null(version)) 
[10:58:39.788]                             version <- utils::packageVersion("future")
[10:58:39.788]                         }
[10:58:39.788]                         else {
[10:58:39.788]                           version <- NULL
[10:58:39.788]                         }
[10:58:39.788]                         if (!has_future || version < "1.8.0") {
[10:58:39.788]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.788]                             "", base::R.version$version.string), 
[10:58:39.788]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.788]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.788]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.788]                               "release", "version")], collapse = " "), 
[10:58:39.788]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.788]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.788]                             info)
[10:58:39.788]                           info <- base::paste(info, collapse = "; ")
[10:58:39.788]                           if (!has_future) {
[10:58:39.788]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.788]                               info)
[10:58:39.788]                           }
[10:58:39.788]                           else {
[10:58:39.788]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.788]                               info, version)
[10:58:39.788]                           }
[10:58:39.788]                           base::stop(msg)
[10:58:39.788]                         }
[10:58:39.788]                       })
[10:58:39.788]                     }
[10:58:39.788]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.788]                     base::options(mc.cores = 1L)
[10:58:39.788]                   }
[10:58:39.788]                   ...future.strategy.old <- future::plan("list")
[10:58:39.788]                   options(future.plan = NULL)
[10:58:39.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.788]                 }
[10:58:39.788]                 ...future.workdir <- getwd()
[10:58:39.788]             }
[10:58:39.788]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.788]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.788]         }
[10:58:39.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.788]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.788]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.788]             base::names(...future.oldOptions))
[10:58:39.788]     }
[10:58:39.788]     if (FALSE) {
[10:58:39.788]     }
[10:58:39.788]     else {
[10:58:39.788]         if (TRUE) {
[10:58:39.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.788]                 open = "w")
[10:58:39.788]         }
[10:58:39.788]         else {
[10:58:39.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.788]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.788]         }
[10:58:39.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.788]             base::sink(type = "output", split = FALSE)
[10:58:39.788]             base::close(...future.stdout)
[10:58:39.788]         }, add = TRUE)
[10:58:39.788]     }
[10:58:39.788]     ...future.frame <- base::sys.nframe()
[10:58:39.788]     ...future.conditions <- base::list()
[10:58:39.788]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.788]     if (FALSE) {
[10:58:39.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.788]     }
[10:58:39.788]     ...future.result <- base::tryCatch({
[10:58:39.788]         base::withCallingHandlers({
[10:58:39.788]             ...future.value <- base::withVisible(base::local({
[10:58:39.788]                 withCallingHandlers({
[10:58:39.788]                   {
[10:58:39.788]                     do.call(function(...) {
[10:58:39.788]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.788]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.788]                         ...future.globals.maxSize)) {
[10:58:39.788]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.788]                         on.exit(options(oopts), add = TRUE)
[10:58:39.788]                       }
[10:58:39.788]                       {
[10:58:39.788]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.788]                           FUN = function(jj) {
[10:58:39.788]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.788]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.788]                           })
[10:58:39.788]                       }
[10:58:39.788]                     }, args = future.call.arguments)
[10:58:39.788]                   }
[10:58:39.788]                 }, immediateCondition = function(cond) {
[10:58:39.788]                   save_rds <- function (object, pathname, ...) 
[10:58:39.788]                   {
[10:58:39.788]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.788]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.788]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.788]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.788]                         fi_tmp[["mtime"]])
[10:58:39.788]                     }
[10:58:39.788]                     tryCatch({
[10:58:39.788]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.788]                     }, error = function(ex) {
[10:58:39.788]                       msg <- conditionMessage(ex)
[10:58:39.788]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.788]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.788]                         fi_tmp[["mtime"]], msg)
[10:58:39.788]                       ex$message <- msg
[10:58:39.788]                       stop(ex)
[10:58:39.788]                     })
[10:58:39.788]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.788]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.788]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.788]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.788]                       fi <- file.info(pathname)
[10:58:39.788]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.788]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.788]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.788]                         fi[["size"]], fi[["mtime"]])
[10:58:39.788]                       stop(msg)
[10:58:39.788]                     }
[10:58:39.788]                     invisible(pathname)
[10:58:39.788]                   }
[10:58:39.788]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.788]                     rootPath = tempdir()) 
[10:58:39.788]                   {
[10:58:39.788]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.788]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.788]                       tmpdir = path, fileext = ".rds")
[10:58:39.788]                     save_rds(obj, file)
[10:58:39.788]                   }
[10:58:39.788]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.788]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.788]                   {
[10:58:39.788]                     inherits <- base::inherits
[10:58:39.788]                     invokeRestart <- base::invokeRestart
[10:58:39.788]                     is.null <- base::is.null
[10:58:39.788]                     muffled <- FALSE
[10:58:39.788]                     if (inherits(cond, "message")) {
[10:58:39.788]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.788]                       if (muffled) 
[10:58:39.788]                         invokeRestart("muffleMessage")
[10:58:39.788]                     }
[10:58:39.788]                     else if (inherits(cond, "warning")) {
[10:58:39.788]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.788]                       if (muffled) 
[10:58:39.788]                         invokeRestart("muffleWarning")
[10:58:39.788]                     }
[10:58:39.788]                     else if (inherits(cond, "condition")) {
[10:58:39.788]                       if (!is.null(pattern)) {
[10:58:39.788]                         computeRestarts <- base::computeRestarts
[10:58:39.788]                         grepl <- base::grepl
[10:58:39.788]                         restarts <- computeRestarts(cond)
[10:58:39.788]                         for (restart in restarts) {
[10:58:39.788]                           name <- restart$name
[10:58:39.788]                           if (is.null(name)) 
[10:58:39.788]                             next
[10:58:39.788]                           if (!grepl(pattern, name)) 
[10:58:39.788]                             next
[10:58:39.788]                           invokeRestart(restart)
[10:58:39.788]                           muffled <- TRUE
[10:58:39.788]                           break
[10:58:39.788]                         }
[10:58:39.788]                       }
[10:58:39.788]                     }
[10:58:39.788]                     invisible(muffled)
[10:58:39.788]                   }
[10:58:39.788]                   muffleCondition(cond)
[10:58:39.788]                 })
[10:58:39.788]             }))
[10:58:39.788]             future::FutureResult(value = ...future.value$value, 
[10:58:39.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.788]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.788]                     ...future.globalenv.names))
[10:58:39.788]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.788]         }, condition = base::local({
[10:58:39.788]             c <- base::c
[10:58:39.788]             inherits <- base::inherits
[10:58:39.788]             invokeRestart <- base::invokeRestart
[10:58:39.788]             length <- base::length
[10:58:39.788]             list <- base::list
[10:58:39.788]             seq.int <- base::seq.int
[10:58:39.788]             signalCondition <- base::signalCondition
[10:58:39.788]             sys.calls <- base::sys.calls
[10:58:39.788]             `[[` <- base::`[[`
[10:58:39.788]             `+` <- base::`+`
[10:58:39.788]             `<<-` <- base::`<<-`
[10:58:39.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.788]                   3L)]
[10:58:39.788]             }
[10:58:39.788]             function(cond) {
[10:58:39.788]                 is_error <- inherits(cond, "error")
[10:58:39.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.788]                   NULL)
[10:58:39.788]                 if (is_error) {
[10:58:39.788]                   sessionInformation <- function() {
[10:58:39.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.788]                       search = base::search(), system = base::Sys.info())
[10:58:39.788]                   }
[10:58:39.788]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.788]                     cond$call), session = sessionInformation(), 
[10:58:39.788]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.788]                   signalCondition(cond)
[10:58:39.788]                 }
[10:58:39.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:39.788]                 "immediateCondition"))) {
[10:58:39.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.788]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.788]                   if (TRUE && !signal) {
[10:58:39.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.788]                     {
[10:58:39.788]                       inherits <- base::inherits
[10:58:39.788]                       invokeRestart <- base::invokeRestart
[10:58:39.788]                       is.null <- base::is.null
[10:58:39.788]                       muffled <- FALSE
[10:58:39.788]                       if (inherits(cond, "message")) {
[10:58:39.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.788]                         if (muffled) 
[10:58:39.788]                           invokeRestart("muffleMessage")
[10:58:39.788]                       }
[10:58:39.788]                       else if (inherits(cond, "warning")) {
[10:58:39.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.788]                         if (muffled) 
[10:58:39.788]                           invokeRestart("muffleWarning")
[10:58:39.788]                       }
[10:58:39.788]                       else if (inherits(cond, "condition")) {
[10:58:39.788]                         if (!is.null(pattern)) {
[10:58:39.788]                           computeRestarts <- base::computeRestarts
[10:58:39.788]                           grepl <- base::grepl
[10:58:39.788]                           restarts <- computeRestarts(cond)
[10:58:39.788]                           for (restart in restarts) {
[10:58:39.788]                             name <- restart$name
[10:58:39.788]                             if (is.null(name)) 
[10:58:39.788]                               next
[10:58:39.788]                             if (!grepl(pattern, name)) 
[10:58:39.788]                               next
[10:58:39.788]                             invokeRestart(restart)
[10:58:39.788]                             muffled <- TRUE
[10:58:39.788]                             break
[10:58:39.788]                           }
[10:58:39.788]                         }
[10:58:39.788]                       }
[10:58:39.788]                       invisible(muffled)
[10:58:39.788]                     }
[10:58:39.788]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.788]                   }
[10:58:39.788]                 }
[10:58:39.788]                 else {
[10:58:39.788]                   if (TRUE) {
[10:58:39.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.788]                     {
[10:58:39.788]                       inherits <- base::inherits
[10:58:39.788]                       invokeRestart <- base::invokeRestart
[10:58:39.788]                       is.null <- base::is.null
[10:58:39.788]                       muffled <- FALSE
[10:58:39.788]                       if (inherits(cond, "message")) {
[10:58:39.788]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.788]                         if (muffled) 
[10:58:39.788]                           invokeRestart("muffleMessage")
[10:58:39.788]                       }
[10:58:39.788]                       else if (inherits(cond, "warning")) {
[10:58:39.788]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.788]                         if (muffled) 
[10:58:39.788]                           invokeRestart("muffleWarning")
[10:58:39.788]                       }
[10:58:39.788]                       else if (inherits(cond, "condition")) {
[10:58:39.788]                         if (!is.null(pattern)) {
[10:58:39.788]                           computeRestarts <- base::computeRestarts
[10:58:39.788]                           grepl <- base::grepl
[10:58:39.788]                           restarts <- computeRestarts(cond)
[10:58:39.788]                           for (restart in restarts) {
[10:58:39.788]                             name <- restart$name
[10:58:39.788]                             if (is.null(name)) 
[10:58:39.788]                               next
[10:58:39.788]                             if (!grepl(pattern, name)) 
[10:58:39.788]                               next
[10:58:39.788]                             invokeRestart(restart)
[10:58:39.788]                             muffled <- TRUE
[10:58:39.788]                             break
[10:58:39.788]                           }
[10:58:39.788]                         }
[10:58:39.788]                       }
[10:58:39.788]                       invisible(muffled)
[10:58:39.788]                     }
[10:58:39.788]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.788]                   }
[10:58:39.788]                 }
[10:58:39.788]             }
[10:58:39.788]         }))
[10:58:39.788]     }, error = function(ex) {
[10:58:39.788]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.788]                 ...future.rng), started = ...future.startTime, 
[10:58:39.788]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.788]             version = "1.8"), class = "FutureResult")
[10:58:39.788]     }, finally = {
[10:58:39.788]         if (!identical(...future.workdir, getwd())) 
[10:58:39.788]             setwd(...future.workdir)
[10:58:39.788]         {
[10:58:39.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.788]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.788]             }
[10:58:39.788]             base::options(...future.oldOptions)
[10:58:39.788]             if (.Platform$OS.type == "windows") {
[10:58:39.788]                 old_names <- names(...future.oldEnvVars)
[10:58:39.788]                 envs <- base::Sys.getenv()
[10:58:39.788]                 names <- names(envs)
[10:58:39.788]                 common <- intersect(names, old_names)
[10:58:39.788]                 added <- setdiff(names, old_names)
[10:58:39.788]                 removed <- setdiff(old_names, names)
[10:58:39.788]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.788]                   envs[common]]
[10:58:39.788]                 NAMES <- toupper(changed)
[10:58:39.788]                 args <- list()
[10:58:39.788]                 for (kk in seq_along(NAMES)) {
[10:58:39.788]                   name <- changed[[kk]]
[10:58:39.788]                   NAME <- NAMES[[kk]]
[10:58:39.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.788]                     next
[10:58:39.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.788]                 }
[10:58:39.788]                 NAMES <- toupper(added)
[10:58:39.788]                 for (kk in seq_along(NAMES)) {
[10:58:39.788]                   name <- added[[kk]]
[10:58:39.788]                   NAME <- NAMES[[kk]]
[10:58:39.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.788]                     next
[10:58:39.788]                   args[[name]] <- ""
[10:58:39.788]                 }
[10:58:39.788]                 NAMES <- toupper(removed)
[10:58:39.788]                 for (kk in seq_along(NAMES)) {
[10:58:39.788]                   name <- removed[[kk]]
[10:58:39.788]                   NAME <- NAMES[[kk]]
[10:58:39.788]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.788]                     next
[10:58:39.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.788]                 }
[10:58:39.788]                 if (length(args) > 0) 
[10:58:39.788]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.788]             }
[10:58:39.788]             else {
[10:58:39.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.788]             }
[10:58:39.788]             {
[10:58:39.788]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.788]                   0L) {
[10:58:39.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.788]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.788]                   base::options(opts)
[10:58:39.788]                 }
[10:58:39.788]                 {
[10:58:39.788]                   {
[10:58:39.788]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.788]                     NULL
[10:58:39.788]                   }
[10:58:39.788]                   options(future.plan = NULL)
[10:58:39.788]                   if (is.na(NA_character_)) 
[10:58:39.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.788]                     .init = FALSE)
[10:58:39.788]                 }
[10:58:39.788]             }
[10:58:39.788]         }
[10:58:39.788]     })
[10:58:39.788]     if (TRUE) {
[10:58:39.788]         base::sink(type = "output", split = FALSE)
[10:58:39.788]         if (TRUE) {
[10:58:39.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.788]         }
[10:58:39.788]         else {
[10:58:39.788]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.788]         }
[10:58:39.788]         base::close(...future.stdout)
[10:58:39.788]         ...future.stdout <- NULL
[10:58:39.788]     }
[10:58:39.788]     ...future.result$conditions <- ...future.conditions
[10:58:39.788]     ...future.result$finished <- base::Sys.time()
[10:58:39.788]     ...future.result
[10:58:39.788] }
[10:58:39.791] assign_globals() ...
[10:58:39.791] List of 5
[10:58:39.791]  $ future.call.arguments    : list()
[10:58:39.791]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.791]  $ ...future.FUN            :function (x)  
[10:58:39.791]  $ ...future.elements_ii    :List of 1
[10:58:39.791]   ..$ : int [1:2] 2 4
[10:58:39.791]  $ ...future.seeds_ii       : NULL
[10:58:39.791]  $ ...future.globals.maxSize: num Inf
[10:58:39.791]  - attr(*, "resolved")= logi FALSE
[10:58:39.791]  - attr(*, "total_size")= num NA
[10:58:39.791]  - attr(*, "where")=List of 5
[10:58:39.791]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.791]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.791]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.791]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.791]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.791]  - attr(*, "already-done")= logi TRUE
[10:58:39.799] - copied ‘future.call.arguments’ to environment
[10:58:39.799] - reassign environment for ‘...future.FUN’
[10:58:39.799] - copied ‘...future.FUN’ to environment
[10:58:39.799] - copied ‘...future.elements_ii’ to environment
[10:58:39.799] - copied ‘...future.seeds_ii’ to environment
[10:58:39.799] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.799] assign_globals() ... done
[10:58:39.799] requestCore(): workers = 2
[10:58:39.802] MulticoreFuture started
[10:58:39.802] - Launch lazy future ... done
[10:58:39.802] run() for ‘MulticoreFuture’ ... done
[10:58:39.803] Created future:
[10:58:39.803] plan(): Setting new future strategy stack:
[10:58:39.803] List of future strategies:
[10:58:39.803] 1. sequential:
[10:58:39.803]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.803]    - tweaked: FALSE
[10:58:39.803]    - call: NULL
[10:58:39.804] plan(): nbrOfWorkers() = 1
[10:58:39.806] plan(): Setting new future strategy stack:
[10:58:39.806] List of future strategies:
[10:58:39.806] 1. multicore:
[10:58:39.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.806]    - tweaked: FALSE
[10:58:39.806]    - call: plan(strategy)
[10:58:39.814] plan(): nbrOfWorkers() = 2
[10:58:39.803] MulticoreFuture:
[10:58:39.803] Label: ‘future_apply-2’
[10:58:39.803] Expression:
[10:58:39.803] {
[10:58:39.803]     do.call(function(...) {
[10:58:39.803]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.803]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.803]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.803]             on.exit(options(oopts), add = TRUE)
[10:58:39.803]         }
[10:58:39.803]         {
[10:58:39.803]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.803]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.803]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.803]             })
[10:58:39.803]         }
[10:58:39.803]     }, args = future.call.arguments)
[10:58:39.803] }
[10:58:39.803] Lazy evaluation: FALSE
[10:58:39.803] Asynchronous evaluation: TRUE
[10:58:39.803] Local evaluation: TRUE
[10:58:39.803] Environment: R_GlobalEnv
[10:58:39.803] Capture standard output: TRUE
[10:58:39.803] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:39.803] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.803] Packages: <none>
[10:58:39.803] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:39.803] Resolved: FALSE
[10:58:39.803] Value: <not collected>
[10:58:39.803] Conditions captured: <none>
[10:58:39.803] Early signaling: FALSE
[10:58:39.803] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.803] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.815] Chunk #2 of 2 ... DONE
[10:58:39.815] Launching 2 futures (chunks) ... DONE
[10:58:39.816] Resolving 2 futures (chunks) ...
[10:58:39.816] resolve() on list ...
[10:58:39.816]  recursive: 0
[10:58:39.816]  length: 2
[10:58:39.816] 
[10:58:39.817] Future #1
[10:58:39.819] result() for MulticoreFuture ...
[10:58:39.820] result() for MulticoreFuture ...
[10:58:39.820] result() for MulticoreFuture ... done
[10:58:39.821] result() for MulticoreFuture ... done
[10:58:39.821] result() for MulticoreFuture ...
[10:58:39.821] result() for MulticoreFuture ... done
[10:58:39.822] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:39.822] - nx: 2
[10:58:39.822] - relay: TRUE
[10:58:39.822] - stdout: TRUE
[10:58:39.823] - signal: TRUE
[10:58:39.823] - resignal: FALSE
[10:58:39.823] - force: TRUE
[10:58:39.823] - relayed: [n=2] FALSE, FALSE
[10:58:39.824] - queued futures: [n=2] FALSE, FALSE
[10:58:39.824]  - until=1
[10:58:39.824]  - relaying element #1
[10:58:39.824] result() for MulticoreFuture ...
[10:58:39.825] result() for MulticoreFuture ... done
[10:58:39.825] result() for MulticoreFuture ...
[10:58:39.825] result() for MulticoreFuture ... done
[10:58:39.826] result() for MulticoreFuture ...
[10:58:39.826] result() for MulticoreFuture ... done
[10:58:39.826] result() for MulticoreFuture ...
[10:58:39.826] result() for MulticoreFuture ... done
[10:58:39.826] - relayed: [n=2] TRUE, FALSE
[10:58:39.827] - queued futures: [n=2] TRUE, FALSE
[10:58:39.827] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:39.827]  length: 1 (resolved future 1)
[10:58:39.827] Future #2
[10:58:39.827] result() for MulticoreFuture ...
[10:58:39.828] result() for MulticoreFuture ...
[10:58:39.828] result() for MulticoreFuture ... done
[10:58:39.828] result() for MulticoreFuture ... done
[10:58:39.828] result() for MulticoreFuture ...
[10:58:39.828] result() for MulticoreFuture ... done
[10:58:39.829] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:39.829] - nx: 2
[10:58:39.829] - relay: TRUE
[10:58:39.829] - stdout: TRUE
[10:58:39.829] - signal: TRUE
[10:58:39.829] - resignal: FALSE
[10:58:39.829] - force: TRUE
[10:58:39.829] - relayed: [n=2] TRUE, FALSE
[10:58:39.830] - queued futures: [n=2] TRUE, FALSE
[10:58:39.830]  - until=2
[10:58:39.830]  - relaying element #2
[10:58:39.830] result() for MulticoreFuture ...
[10:58:39.830] result() for MulticoreFuture ... done
[10:58:39.830] result() for MulticoreFuture ...
[10:58:39.830] result() for MulticoreFuture ... done
[10:58:39.830] result() for MulticoreFuture ...
[10:58:39.830] result() for MulticoreFuture ... done
[10:58:39.831] result() for MulticoreFuture ...
[10:58:39.831] result() for MulticoreFuture ... done
[10:58:39.831] - relayed: [n=2] TRUE, TRUE
[10:58:39.831] - queued futures: [n=2] TRUE, TRUE
[10:58:39.831] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:39.831]  length: 0 (resolved future 2)
[10:58:39.831] Relaying remaining futures
[10:58:39.831] signalConditionsASAP(NULL, pos=0) ...
[10:58:39.831] - nx: 2
[10:58:39.832] - relay: TRUE
[10:58:39.832] - stdout: TRUE
[10:58:39.832] - signal: TRUE
[10:58:39.832] - resignal: FALSE
[10:58:39.832] - force: TRUE
[10:58:39.832] - relayed: [n=2] TRUE, TRUE
[10:58:39.832] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:39.832] - relayed: [n=2] TRUE, TRUE
[10:58:39.832] - queued futures: [n=2] TRUE, TRUE
[10:58:39.832] signalConditionsASAP(NULL, pos=0) ... done
[10:58:39.833] resolve() on list ... DONE
[10:58:39.833] result() for MulticoreFuture ...
[10:58:39.833] result() for MulticoreFuture ... done
[10:58:39.833] result() for MulticoreFuture ...
[10:58:39.833] result() for MulticoreFuture ... done
[10:58:39.833] result() for MulticoreFuture ...
[10:58:39.833] result() for MulticoreFuture ... done
[10:58:39.833] result() for MulticoreFuture ...
[10:58:39.833] result() for MulticoreFuture ... done
[10:58:39.834]  - Number of value chunks collected: 2
[10:58:39.834] Resolving 2 futures (chunks) ... DONE
[10:58:39.834] Reducing values from 2 chunks ...
[10:58:39.834]  - Number of values collected after concatenation: 2
[10:58:39.834]  - Number of values expected: 2
[10:58:39.834] Reducing values from 2 chunks ... DONE
[10:58:39.834] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:58:39.834] getGlobalsAndPackagesXApply() ...
[10:58:39.835]  - future.globals: TRUE
[10:58:39.835] getGlobalsAndPackages() ...
[10:58:39.835] Searching for globals...
[10:58:39.838] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:58:39.838] Searching for globals ... DONE
[10:58:39.838] Resolving globals: FALSE
[10:58:39.839] The total size of the 1 globals is 3.66 KiB (3746 bytes)
[10:58:39.839] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 3.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.66 KiB of class ‘function’)
[10:58:39.840] - globals: [1] ‘FUN’
[10:58:39.840] 
[10:58:39.840] getGlobalsAndPackages() ... DONE
[10:58:39.840]  - globals found/used: [n=1] ‘FUN’
[10:58:39.840]  - needed namespaces: [n=0] 
[10:58:39.840] Finding globals ... DONE
[10:58:39.840]  - use_args: TRUE
[10:58:39.840]  - Getting '...' globals ...
[10:58:39.841] resolve() on list ...
[10:58:39.841]  recursive: 0
[10:58:39.841]  length: 1
[10:58:39.841]  elements: ‘...’
[10:58:39.841]  length: 0 (resolved future 1)
[10:58:39.841] resolve() on list ... DONE
[10:58:39.841]    - '...' content: [n=0] 
[10:58:39.841] List of 1
[10:58:39.841]  $ ...: list()
[10:58:39.841]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.841]  - attr(*, "where")=List of 1
[10:58:39.841]   ..$ ...:<environment: 0x5635beaf9610> 
[10:58:39.841]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.841]  - attr(*, "resolved")= logi TRUE
[10:58:39.841]  - attr(*, "total_size")= num NA
[10:58:39.844]  - Getting '...' globals ... DONE
[10:58:39.844] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:39.844] List of 2
[10:58:39.844]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:58:39.844]  $ ...          : list()
[10:58:39.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.844]  - attr(*, "where")=List of 2
[10:58:39.844]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:39.844]   ..$ ...          :<environment: 0x5635beaf9610> 
[10:58:39.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.844]  - attr(*, "resolved")= logi FALSE
[10:58:39.844]  - attr(*, "total_size")= num 9424
[10:58:39.848] Packages to be attached in all futures: [n=0] 
[10:58:39.848] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.850] future_lapply() ...
[10:58:39.852] Generating random seeds ...
[10:58:39.852] Generating random seed streams for 2 elements ...
[10:58:39.852] Generating random seed streams for 2 elements ... DONE
[10:58:39.852] Generating random seeds ... DONE
[10:58:39.852] Will set RNG state on exit: 10407, -1251496766, 431995553, 1487047905, 777118461, -1233538796, -1199129823
[10:58:39.854] Number of chunks: 2
[10:58:39.854] getGlobalsAndPackagesXApply() ...
[10:58:39.854]  - future.globals: <name-value list> with names ‘list()’
[10:58:39.854]  - use_args: TRUE
[10:58:39.854] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:39.854] List of 2
[10:58:39.854]  $ ...          : list()
[10:58:39.854]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.854]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:58:39.854]  - attr(*, "where")=List of 2
[10:58:39.854]   ..$ ...          :<environment: 0x5635beaf9610> 
[10:58:39.854]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:39.854]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.854]  - attr(*, "resolved")= logi FALSE
[10:58:39.854]  - attr(*, "total_size")= num NA
[10:58:39.857] Packages to be attached in all futures: [n=0] 
[10:58:39.857] getGlobalsAndPackagesXApply() ... DONE
[10:58:39.858] Number of futures (= number of chunks): 2
[10:58:39.858] Launching 2 futures (chunks) ...
[10:58:39.858] Chunk #1 of 2 ...
[10:58:39.858]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.858]  - seeds: [1] <seeds>
[10:58:39.858]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.858] getGlobalsAndPackages() ...
[10:58:39.858] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.858] Resolving globals: FALSE
[10:58:39.859] Tweak future expression to call with '...' arguments ...
[10:58:39.859] {
[10:58:39.859]     do.call(function(...) {
[10:58:39.859]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.859]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.859]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.859]             on.exit(options(oopts), add = TRUE)
[10:58:39.859]         }
[10:58:39.859]         {
[10:58:39.859]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.859]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.859]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:39.859]                   envir = globalenv(), inherits = FALSE)
[10:58:39.859]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.859]             })
[10:58:39.859]         }
[10:58:39.859]     }, args = future.call.arguments)
[10:58:39.859] }
[10:58:39.859] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.859] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.859] 
[10:58:39.859] getGlobalsAndPackages() ... DONE
[10:58:39.860] run() for ‘Future’ ...
[10:58:39.860] - state: ‘created’
[10:58:39.860] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.861] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.862] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.862]   - Field: ‘label’
[10:58:39.862]   - Field: ‘local’
[10:58:39.862]   - Field: ‘owner’
[10:58:39.862]   - Field: ‘envir’
[10:58:39.862]   - Field: ‘workers’
[10:58:39.862]   - Field: ‘packages’
[10:58:39.862]   - Field: ‘gc’
[10:58:39.862]   - Field: ‘job’
[10:58:39.862]   - Field: ‘conditions’
[10:58:39.862]   - Field: ‘expr’
[10:58:39.863]   - Field: ‘uuid’
[10:58:39.863]   - Field: ‘seed’
[10:58:39.863]   - Field: ‘version’
[10:58:39.863]   - Field: ‘result’
[10:58:39.863]   - Field: ‘asynchronous’
[10:58:39.863]   - Field: ‘calls’
[10:58:39.863]   - Field: ‘globals’
[10:58:39.863]   - Field: ‘stdout’
[10:58:39.863]   - Field: ‘earlySignal’
[10:58:39.863]   - Field: ‘lazy’
[10:58:39.863]   - Field: ‘state’
[10:58:39.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.864] - Launch lazy future ...
[10:58:39.864] Packages needed by the future expression (n = 0): <none>
[10:58:39.864] Packages needed by future strategies (n = 0): <none>
[10:58:39.865] {
[10:58:39.865]     {
[10:58:39.865]         {
[10:58:39.865]             ...future.startTime <- base::Sys.time()
[10:58:39.865]             {
[10:58:39.865]                 {
[10:58:39.865]                   {
[10:58:39.865]                     {
[10:58:39.865]                       base::local({
[10:58:39.865]                         has_future <- base::requireNamespace("future", 
[10:58:39.865]                           quietly = TRUE)
[10:58:39.865]                         if (has_future) {
[10:58:39.865]                           ns <- base::getNamespace("future")
[10:58:39.865]                           version <- ns[[".package"]][["version"]]
[10:58:39.865]                           if (is.null(version)) 
[10:58:39.865]                             version <- utils::packageVersion("future")
[10:58:39.865]                         }
[10:58:39.865]                         else {
[10:58:39.865]                           version <- NULL
[10:58:39.865]                         }
[10:58:39.865]                         if (!has_future || version < "1.8.0") {
[10:58:39.865]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.865]                             "", base::R.version$version.string), 
[10:58:39.865]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.865]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.865]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.865]                               "release", "version")], collapse = " "), 
[10:58:39.865]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.865]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.865]                             info)
[10:58:39.865]                           info <- base::paste(info, collapse = "; ")
[10:58:39.865]                           if (!has_future) {
[10:58:39.865]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.865]                               info)
[10:58:39.865]                           }
[10:58:39.865]                           else {
[10:58:39.865]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.865]                               info, version)
[10:58:39.865]                           }
[10:58:39.865]                           base::stop(msg)
[10:58:39.865]                         }
[10:58:39.865]                       })
[10:58:39.865]                     }
[10:58:39.865]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.865]                     base::options(mc.cores = 1L)
[10:58:39.865]                   }
[10:58:39.865]                   ...future.strategy.old <- future::plan("list")
[10:58:39.865]                   options(future.plan = NULL)
[10:58:39.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.865]                 }
[10:58:39.865]                 ...future.workdir <- getwd()
[10:58:39.865]             }
[10:58:39.865]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.865]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.865]         }
[10:58:39.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.865]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.865]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.865]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.865]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.865]             base::names(...future.oldOptions))
[10:58:39.865]     }
[10:58:39.865]     if (FALSE) {
[10:58:39.865]     }
[10:58:39.865]     else {
[10:58:39.865]         if (TRUE) {
[10:58:39.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.865]                 open = "w")
[10:58:39.865]         }
[10:58:39.865]         else {
[10:58:39.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.865]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.865]         }
[10:58:39.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.865]             base::sink(type = "output", split = FALSE)
[10:58:39.865]             base::close(...future.stdout)
[10:58:39.865]         }, add = TRUE)
[10:58:39.865]     }
[10:58:39.865]     ...future.frame <- base::sys.nframe()
[10:58:39.865]     ...future.conditions <- base::list()
[10:58:39.865]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.865]     if (FALSE) {
[10:58:39.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.865]     }
[10:58:39.865]     ...future.result <- base::tryCatch({
[10:58:39.865]         base::withCallingHandlers({
[10:58:39.865]             ...future.value <- base::withVisible(base::local({
[10:58:39.865]                 withCallingHandlers({
[10:58:39.865]                   {
[10:58:39.865]                     do.call(function(...) {
[10:58:39.865]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.865]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.865]                         ...future.globals.maxSize)) {
[10:58:39.865]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.865]                         on.exit(options(oopts), add = TRUE)
[10:58:39.865]                       }
[10:58:39.865]                       {
[10:58:39.865]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.865]                           FUN = function(jj) {
[10:58:39.865]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.865]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:39.865]                               envir = globalenv(), inherits = FALSE)
[10:58:39.865]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.865]                           })
[10:58:39.865]                       }
[10:58:39.865]                     }, args = future.call.arguments)
[10:58:39.865]                   }
[10:58:39.865]                 }, immediateCondition = function(cond) {
[10:58:39.865]                   save_rds <- function (object, pathname, ...) 
[10:58:39.865]                   {
[10:58:39.865]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.865]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.865]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.865]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.865]                         fi_tmp[["mtime"]])
[10:58:39.865]                     }
[10:58:39.865]                     tryCatch({
[10:58:39.865]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.865]                     }, error = function(ex) {
[10:58:39.865]                       msg <- conditionMessage(ex)
[10:58:39.865]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.865]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.865]                         fi_tmp[["mtime"]], msg)
[10:58:39.865]                       ex$message <- msg
[10:58:39.865]                       stop(ex)
[10:58:39.865]                     })
[10:58:39.865]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.865]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.865]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.865]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.865]                       fi <- file.info(pathname)
[10:58:39.865]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.865]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.865]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.865]                         fi[["size"]], fi[["mtime"]])
[10:58:39.865]                       stop(msg)
[10:58:39.865]                     }
[10:58:39.865]                     invisible(pathname)
[10:58:39.865]                   }
[10:58:39.865]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.865]                     rootPath = tempdir()) 
[10:58:39.865]                   {
[10:58:39.865]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.865]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.865]                       tmpdir = path, fileext = ".rds")
[10:58:39.865]                     save_rds(obj, file)
[10:58:39.865]                   }
[10:58:39.865]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.865]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.865]                   {
[10:58:39.865]                     inherits <- base::inherits
[10:58:39.865]                     invokeRestart <- base::invokeRestart
[10:58:39.865]                     is.null <- base::is.null
[10:58:39.865]                     muffled <- FALSE
[10:58:39.865]                     if (inherits(cond, "message")) {
[10:58:39.865]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.865]                       if (muffled) 
[10:58:39.865]                         invokeRestart("muffleMessage")
[10:58:39.865]                     }
[10:58:39.865]                     else if (inherits(cond, "warning")) {
[10:58:39.865]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.865]                       if (muffled) 
[10:58:39.865]                         invokeRestart("muffleWarning")
[10:58:39.865]                     }
[10:58:39.865]                     else if (inherits(cond, "condition")) {
[10:58:39.865]                       if (!is.null(pattern)) {
[10:58:39.865]                         computeRestarts <- base::computeRestarts
[10:58:39.865]                         grepl <- base::grepl
[10:58:39.865]                         restarts <- computeRestarts(cond)
[10:58:39.865]                         for (restart in restarts) {
[10:58:39.865]                           name <- restart$name
[10:58:39.865]                           if (is.null(name)) 
[10:58:39.865]                             next
[10:58:39.865]                           if (!grepl(pattern, name)) 
[10:58:39.865]                             next
[10:58:39.865]                           invokeRestart(restart)
[10:58:39.865]                           muffled <- TRUE
[10:58:39.865]                           break
[10:58:39.865]                         }
[10:58:39.865]                       }
[10:58:39.865]                     }
[10:58:39.865]                     invisible(muffled)
[10:58:39.865]                   }
[10:58:39.865]                   muffleCondition(cond)
[10:58:39.865]                 })
[10:58:39.865]             }))
[10:58:39.865]             future::FutureResult(value = ...future.value$value, 
[10:58:39.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.865]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.865]                     ...future.globalenv.names))
[10:58:39.865]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.865]         }, condition = base::local({
[10:58:39.865]             c <- base::c
[10:58:39.865]             inherits <- base::inherits
[10:58:39.865]             invokeRestart <- base::invokeRestart
[10:58:39.865]             length <- base::length
[10:58:39.865]             list <- base::list
[10:58:39.865]             seq.int <- base::seq.int
[10:58:39.865]             signalCondition <- base::signalCondition
[10:58:39.865]             sys.calls <- base::sys.calls
[10:58:39.865]             `[[` <- base::`[[`
[10:58:39.865]             `+` <- base::`+`
[10:58:39.865]             `<<-` <- base::`<<-`
[10:58:39.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.865]                   3L)]
[10:58:39.865]             }
[10:58:39.865]             function(cond) {
[10:58:39.865]                 is_error <- inherits(cond, "error")
[10:58:39.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.865]                   NULL)
[10:58:39.865]                 if (is_error) {
[10:58:39.865]                   sessionInformation <- function() {
[10:58:39.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.865]                       search = base::search(), system = base::Sys.info())
[10:58:39.865]                   }
[10:58:39.865]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.865]                     cond$call), session = sessionInformation(), 
[10:58:39.865]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.865]                   signalCondition(cond)
[10:58:39.865]                 }
[10:58:39.865]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:58:39.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.865]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.865]                   if (TRUE && !signal) {
[10:58:39.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.865]                     {
[10:58:39.865]                       inherits <- base::inherits
[10:58:39.865]                       invokeRestart <- base::invokeRestart
[10:58:39.865]                       is.null <- base::is.null
[10:58:39.865]                       muffled <- FALSE
[10:58:39.865]                       if (inherits(cond, "message")) {
[10:58:39.865]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.865]                         if (muffled) 
[10:58:39.865]                           invokeRestart("muffleMessage")
[10:58:39.865]                       }
[10:58:39.865]                       else if (inherits(cond, "warning")) {
[10:58:39.865]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.865]                         if (muffled) 
[10:58:39.865]                           invokeRestart("muffleWarning")
[10:58:39.865]                       }
[10:58:39.865]                       else if (inherits(cond, "condition")) {
[10:58:39.865]                         if (!is.null(pattern)) {
[10:58:39.865]                           computeRestarts <- base::computeRestarts
[10:58:39.865]                           grepl <- base::grepl
[10:58:39.865]                           restarts <- computeRestarts(cond)
[10:58:39.865]                           for (restart in restarts) {
[10:58:39.865]                             name <- restart$name
[10:58:39.865]                             if (is.null(name)) 
[10:58:39.865]                               next
[10:58:39.865]                             if (!grepl(pattern, name)) 
[10:58:39.865]                               next
[10:58:39.865]                             invokeRestart(restart)
[10:58:39.865]                             muffled <- TRUE
[10:58:39.865]                             break
[10:58:39.865]                           }
[10:58:39.865]                         }
[10:58:39.865]                       }
[10:58:39.865]                       invisible(muffled)
[10:58:39.865]                     }
[10:58:39.865]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.865]                   }
[10:58:39.865]                 }
[10:58:39.865]                 else {
[10:58:39.865]                   if (TRUE) {
[10:58:39.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.865]                     {
[10:58:39.865]                       inherits <- base::inherits
[10:58:39.865]                       invokeRestart <- base::invokeRestart
[10:58:39.865]                       is.null <- base::is.null
[10:58:39.865]                       muffled <- FALSE
[10:58:39.865]                       if (inherits(cond, "message")) {
[10:58:39.865]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.865]                         if (muffled) 
[10:58:39.865]                           invokeRestart("muffleMessage")
[10:58:39.865]                       }
[10:58:39.865]                       else if (inherits(cond, "warning")) {
[10:58:39.865]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.865]                         if (muffled) 
[10:58:39.865]                           invokeRestart("muffleWarning")
[10:58:39.865]                       }
[10:58:39.865]                       else if (inherits(cond, "condition")) {
[10:58:39.865]                         if (!is.null(pattern)) {
[10:58:39.865]                           computeRestarts <- base::computeRestarts
[10:58:39.865]                           grepl <- base::grepl
[10:58:39.865]                           restarts <- computeRestarts(cond)
[10:58:39.865]                           for (restart in restarts) {
[10:58:39.865]                             name <- restart$name
[10:58:39.865]                             if (is.null(name)) 
[10:58:39.865]                               next
[10:58:39.865]                             if (!grepl(pattern, name)) 
[10:58:39.865]                               next
[10:58:39.865]                             invokeRestart(restart)
[10:58:39.865]                             muffled <- TRUE
[10:58:39.865]                             break
[10:58:39.865]                           }
[10:58:39.865]                         }
[10:58:39.865]                       }
[10:58:39.865]                       invisible(muffled)
[10:58:39.865]                     }
[10:58:39.865]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.865]                   }
[10:58:39.865]                 }
[10:58:39.865]             }
[10:58:39.865]         }))
[10:58:39.865]     }, error = function(ex) {
[10:58:39.865]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.865]                 ...future.rng), started = ...future.startTime, 
[10:58:39.865]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.865]             version = "1.8"), class = "FutureResult")
[10:58:39.865]     }, finally = {
[10:58:39.865]         if (!identical(...future.workdir, getwd())) 
[10:58:39.865]             setwd(...future.workdir)
[10:58:39.865]         {
[10:58:39.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.865]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.865]             }
[10:58:39.865]             base::options(...future.oldOptions)
[10:58:39.865]             if (.Platform$OS.type == "windows") {
[10:58:39.865]                 old_names <- names(...future.oldEnvVars)
[10:58:39.865]                 envs <- base::Sys.getenv()
[10:58:39.865]                 names <- names(envs)
[10:58:39.865]                 common <- intersect(names, old_names)
[10:58:39.865]                 added <- setdiff(names, old_names)
[10:58:39.865]                 removed <- setdiff(old_names, names)
[10:58:39.865]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.865]                   envs[common]]
[10:58:39.865]                 NAMES <- toupper(changed)
[10:58:39.865]                 args <- list()
[10:58:39.865]                 for (kk in seq_along(NAMES)) {
[10:58:39.865]                   name <- changed[[kk]]
[10:58:39.865]                   NAME <- NAMES[[kk]]
[10:58:39.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.865]                     next
[10:58:39.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.865]                 }
[10:58:39.865]                 NAMES <- toupper(added)
[10:58:39.865]                 for (kk in seq_along(NAMES)) {
[10:58:39.865]                   name <- added[[kk]]
[10:58:39.865]                   NAME <- NAMES[[kk]]
[10:58:39.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.865]                     next
[10:58:39.865]                   args[[name]] <- ""
[10:58:39.865]                 }
[10:58:39.865]                 NAMES <- toupper(removed)
[10:58:39.865]                 for (kk in seq_along(NAMES)) {
[10:58:39.865]                   name <- removed[[kk]]
[10:58:39.865]                   NAME <- NAMES[[kk]]
[10:58:39.865]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.865]                     next
[10:58:39.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.865]                 }
[10:58:39.865]                 if (length(args) > 0) 
[10:58:39.865]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.865]             }
[10:58:39.865]             else {
[10:58:39.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.865]             }
[10:58:39.865]             {
[10:58:39.865]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.865]                   0L) {
[10:58:39.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.865]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.865]                   base::options(opts)
[10:58:39.865]                 }
[10:58:39.865]                 {
[10:58:39.865]                   {
[10:58:39.865]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.865]                     NULL
[10:58:39.865]                   }
[10:58:39.865]                   options(future.plan = NULL)
[10:58:39.865]                   if (is.na(NA_character_)) 
[10:58:39.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.865]                     .init = FALSE)
[10:58:39.865]                 }
[10:58:39.865]             }
[10:58:39.865]         }
[10:58:39.865]     })
[10:58:39.865]     if (TRUE) {
[10:58:39.865]         base::sink(type = "output", split = FALSE)
[10:58:39.865]         if (TRUE) {
[10:58:39.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.865]         }
[10:58:39.865]         else {
[10:58:39.865]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.865]         }
[10:58:39.865]         base::close(...future.stdout)
[10:58:39.865]         ...future.stdout <- NULL
[10:58:39.865]     }
[10:58:39.865]     ...future.result$conditions <- ...future.conditions
[10:58:39.865]     ...future.result$finished <- base::Sys.time()
[10:58:39.865]     ...future.result
[10:58:39.865] }
[10:58:39.867] assign_globals() ...
[10:58:39.867] List of 5
[10:58:39.867]  $ future.call.arguments    : list()
[10:58:39.867]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.867]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:58:39.867]  $ ...future.elements_ii    :List of 1
[10:58:39.867]   ..$ : int [1:2] 1 3
[10:58:39.867]  $ ...future.seeds_ii       :List of 1
[10:58:39.867]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:58:39.867]  $ ...future.globals.maxSize: num Inf
[10:58:39.867]  - attr(*, "resolved")= logi FALSE
[10:58:39.867]  - attr(*, "total_size")= num NA
[10:58:39.867]  - attr(*, "where")=List of 5
[10:58:39.867]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.867]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.867]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.867]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.867]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.867]  - attr(*, "already-done")= logi TRUE
[10:58:39.873] - copied ‘future.call.arguments’ to environment
[10:58:39.873] - copied ‘...future.FUN’ to environment
[10:58:39.873] - copied ‘...future.elements_ii’ to environment
[10:58:39.873] - copied ‘...future.seeds_ii’ to environment
[10:58:39.873] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.873] assign_globals() ... done
[10:58:39.873] requestCore(): workers = 2
[10:58:39.875] MulticoreFuture started
[10:58:39.876] - Launch lazy future ... done
[10:58:39.876] run() for ‘MulticoreFuture’ ... done
[10:58:39.876] Created future:
[10:58:39.876] plan(): Setting new future strategy stack:
[10:58:39.876] List of future strategies:
[10:58:39.876] 1. sequential:
[10:58:39.876]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.876]    - tweaked: FALSE
[10:58:39.876]    - call: NULL
[10:58:39.877] plan(): nbrOfWorkers() = 1
[10:58:39.879] plan(): Setting new future strategy stack:
[10:58:39.880] List of future strategies:
[10:58:39.880] 1. multicore:
[10:58:39.880]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.880]    - tweaked: FALSE
[10:58:39.880]    - call: plan(strategy)
[10:58:39.883] plan(): nbrOfWorkers() = 2
[10:58:39.876] MulticoreFuture:
[10:58:39.876] Label: ‘future_apply-1’
[10:58:39.876] Expression:
[10:58:39.876] {
[10:58:39.876]     do.call(function(...) {
[10:58:39.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.876]             on.exit(options(oopts), add = TRUE)
[10:58:39.876]         }
[10:58:39.876]         {
[10:58:39.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.876]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:39.876]                   envir = globalenv(), inherits = FALSE)
[10:58:39.876]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.876]             })
[10:58:39.876]         }
[10:58:39.876]     }, args = future.call.arguments)
[10:58:39.876] }
[10:58:39.876] Lazy evaluation: FALSE
[10:58:39.876] Asynchronous evaluation: TRUE
[10:58:39.876] Local evaluation: TRUE
[10:58:39.876] Environment: R_GlobalEnv
[10:58:39.876] Capture standard output: TRUE
[10:58:39.876] Capture condition classes: <none>
[10:58:39.876] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.876] Packages: <none>
[10:58:39.876] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:58:39.876] Resolved: TRUE
[10:58:39.876] Value: <not collected>
[10:58:39.876] Conditions captured: <none>
[10:58:39.876] Early signaling: FALSE
[10:58:39.876] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.876] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.884] Chunk #1 of 2 ... DONE
[10:58:39.884] Chunk #2 of 2 ...
[10:58:39.884]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:39.884]  - seeds: [1] <seeds>
[10:58:39.885]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.885] getGlobalsAndPackages() ...
[10:58:39.885] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.885] Resolving globals: FALSE
[10:58:39.885] Tweak future expression to call with '...' arguments ...
[10:58:39.885] {
[10:58:39.885]     do.call(function(...) {
[10:58:39.885]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.885]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.885]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.885]             on.exit(options(oopts), add = TRUE)
[10:58:39.885]         }
[10:58:39.885]         {
[10:58:39.885]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.885]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.885]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:39.885]                   envir = globalenv(), inherits = FALSE)
[10:58:39.885]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.885]             })
[10:58:39.885]         }
[10:58:39.885]     }, args = future.call.arguments)
[10:58:39.885] }
[10:58:39.886] Tweak future expression to call with '...' arguments ... DONE
[10:58:39.886] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:39.887] 
[10:58:39.887] getGlobalsAndPackages() ... DONE
[10:58:39.887] run() for ‘Future’ ...
[10:58:39.887] - state: ‘created’
[10:58:39.888] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:58:39.890] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:58:39.890]   - Field: ‘label’
[10:58:39.891]   - Field: ‘local’
[10:58:39.891]   - Field: ‘owner’
[10:58:39.891]   - Field: ‘envir’
[10:58:39.891]   - Field: ‘workers’
[10:58:39.891]   - Field: ‘packages’
[10:58:39.891]   - Field: ‘gc’
[10:58:39.892]   - Field: ‘job’
[10:58:39.892]   - Field: ‘conditions’
[10:58:39.892]   - Field: ‘expr’
[10:58:39.892]   - Field: ‘uuid’
[10:58:39.892]   - Field: ‘seed’
[10:58:39.892]   - Field: ‘version’
[10:58:39.892]   - Field: ‘result’
[10:58:39.893]   - Field: ‘asynchronous’
[10:58:39.893]   - Field: ‘calls’
[10:58:39.893]   - Field: ‘globals’
[10:58:39.893]   - Field: ‘stdout’
[10:58:39.893]   - Field: ‘earlySignal’
[10:58:39.893]   - Field: ‘lazy’
[10:58:39.893]   - Field: ‘state’
[10:58:39.893] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:58:39.894] - Launch lazy future ...
[10:58:39.894] Packages needed by the future expression (n = 0): <none>
[10:58:39.894] Packages needed by future strategies (n = 0): <none>
[10:58:39.895] {
[10:58:39.895]     {
[10:58:39.895]         {
[10:58:39.895]             ...future.startTime <- base::Sys.time()
[10:58:39.895]             {
[10:58:39.895]                 {
[10:58:39.895]                   {
[10:58:39.895]                     {
[10:58:39.895]                       base::local({
[10:58:39.895]                         has_future <- base::requireNamespace("future", 
[10:58:39.895]                           quietly = TRUE)
[10:58:39.895]                         if (has_future) {
[10:58:39.895]                           ns <- base::getNamespace("future")
[10:58:39.895]                           version <- ns[[".package"]][["version"]]
[10:58:39.895]                           if (is.null(version)) 
[10:58:39.895]                             version <- utils::packageVersion("future")
[10:58:39.895]                         }
[10:58:39.895]                         else {
[10:58:39.895]                           version <- NULL
[10:58:39.895]                         }
[10:58:39.895]                         if (!has_future || version < "1.8.0") {
[10:58:39.895]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:39.895]                             "", base::R.version$version.string), 
[10:58:39.895]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:39.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:39.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:39.895]                               "release", "version")], collapse = " "), 
[10:58:39.895]                             hostname = base::Sys.info()[["nodename"]])
[10:58:39.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:39.895]                             info)
[10:58:39.895]                           info <- base::paste(info, collapse = "; ")
[10:58:39.895]                           if (!has_future) {
[10:58:39.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:39.895]                               info)
[10:58:39.895]                           }
[10:58:39.895]                           else {
[10:58:39.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:39.895]                               info, version)
[10:58:39.895]                           }
[10:58:39.895]                           base::stop(msg)
[10:58:39.895]                         }
[10:58:39.895]                       })
[10:58:39.895]                     }
[10:58:39.895]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:39.895]                     base::options(mc.cores = 1L)
[10:58:39.895]                   }
[10:58:39.895]                   ...future.strategy.old <- future::plan("list")
[10:58:39.895]                   options(future.plan = NULL)
[10:58:39.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:39.895]                 }
[10:58:39.895]                 ...future.workdir <- getwd()
[10:58:39.895]             }
[10:58:39.895]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:39.895]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:39.895]         }
[10:58:39.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:39.895]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:39.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:39.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:39.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:39.895]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:39.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:39.895]             base::names(...future.oldOptions))
[10:58:39.895]     }
[10:58:39.895]     if (FALSE) {
[10:58:39.895]     }
[10:58:39.895]     else {
[10:58:39.895]         if (TRUE) {
[10:58:39.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:39.895]                 open = "w")
[10:58:39.895]         }
[10:58:39.895]         else {
[10:58:39.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:39.895]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:39.895]         }
[10:58:39.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:39.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:39.895]             base::sink(type = "output", split = FALSE)
[10:58:39.895]             base::close(...future.stdout)
[10:58:39.895]         }, add = TRUE)
[10:58:39.895]     }
[10:58:39.895]     ...future.frame <- base::sys.nframe()
[10:58:39.895]     ...future.conditions <- base::list()
[10:58:39.895]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:39.895]     if (FALSE) {
[10:58:39.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:39.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:39.895]     }
[10:58:39.895]     ...future.result <- base::tryCatch({
[10:58:39.895]         base::withCallingHandlers({
[10:58:39.895]             ...future.value <- base::withVisible(base::local({
[10:58:39.895]                 withCallingHandlers({
[10:58:39.895]                   {
[10:58:39.895]                     do.call(function(...) {
[10:58:39.895]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.895]                       if (!identical(...future.globals.maxSize.org, 
[10:58:39.895]                         ...future.globals.maxSize)) {
[10:58:39.895]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.895]                         on.exit(options(oopts), add = TRUE)
[10:58:39.895]                       }
[10:58:39.895]                       {
[10:58:39.895]                         lapply(seq_along(...future.elements_ii), 
[10:58:39.895]                           FUN = function(jj) {
[10:58:39.895]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.895]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:39.895]                               envir = globalenv(), inherits = FALSE)
[10:58:39.895]                             ...future.FUN(...future.X_jj, ...)
[10:58:39.895]                           })
[10:58:39.895]                       }
[10:58:39.895]                     }, args = future.call.arguments)
[10:58:39.895]                   }
[10:58:39.895]                 }, immediateCondition = function(cond) {
[10:58:39.895]                   save_rds <- function (object, pathname, ...) 
[10:58:39.895]                   {
[10:58:39.895]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:58:39.895]                     if (file_test("-f", pathname_tmp)) {
[10:58:39.895]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.895]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:58:39.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.895]                         fi_tmp[["mtime"]])
[10:58:39.895]                     }
[10:58:39.895]                     tryCatch({
[10:58:39.895]                       saveRDS(object, file = pathname_tmp, ...)
[10:58:39.895]                     }, error = function(ex) {
[10:58:39.895]                       msg <- conditionMessage(ex)
[10:58:39.895]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.895]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:58:39.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.895]                         fi_tmp[["mtime"]], msg)
[10:58:39.895]                       ex$message <- msg
[10:58:39.895]                       stop(ex)
[10:58:39.895]                     })
[10:58:39.895]                     stopifnot(file_test("-f", pathname_tmp))
[10:58:39.895]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:58:39.895]                     if (!res || file_test("-f", pathname_tmp)) {
[10:58:39.895]                       fi_tmp <- file.info(pathname_tmp)
[10:58:39.895]                       fi <- file.info(pathname)
[10:58:39.895]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:58:39.895]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:58:39.895]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:58:39.895]                         fi[["size"]], fi[["mtime"]])
[10:58:39.895]                       stop(msg)
[10:58:39.895]                     }
[10:58:39.895]                     invisible(pathname)
[10:58:39.895]                   }
[10:58:39.895]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:58:39.895]                     rootPath = tempdir()) 
[10:58:39.895]                   {
[10:58:39.895]                     obj <- list(time = Sys.time(), condition = cond)
[10:58:39.895]                     file <- tempfile(pattern = class(cond)[1], 
[10:58:39.895]                       tmpdir = path, fileext = ".rds")
[10:58:39.895]                     save_rds(obj, file)
[10:58:39.895]                   }
[10:58:39.895]                   saveImmediateCondition(cond, path = "/tmp/Rtmp1kP4x0/.future/immediateConditions")
[10:58:39.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.895]                   {
[10:58:39.895]                     inherits <- base::inherits
[10:58:39.895]                     invokeRestart <- base::invokeRestart
[10:58:39.895]                     is.null <- base::is.null
[10:58:39.895]                     muffled <- FALSE
[10:58:39.895]                     if (inherits(cond, "message")) {
[10:58:39.895]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:39.895]                       if (muffled) 
[10:58:39.895]                         invokeRestart("muffleMessage")
[10:58:39.895]                     }
[10:58:39.895]                     else if (inherits(cond, "warning")) {
[10:58:39.895]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:39.895]                       if (muffled) 
[10:58:39.895]                         invokeRestart("muffleWarning")
[10:58:39.895]                     }
[10:58:39.895]                     else if (inherits(cond, "condition")) {
[10:58:39.895]                       if (!is.null(pattern)) {
[10:58:39.895]                         computeRestarts <- base::computeRestarts
[10:58:39.895]                         grepl <- base::grepl
[10:58:39.895]                         restarts <- computeRestarts(cond)
[10:58:39.895]                         for (restart in restarts) {
[10:58:39.895]                           name <- restart$name
[10:58:39.895]                           if (is.null(name)) 
[10:58:39.895]                             next
[10:58:39.895]                           if (!grepl(pattern, name)) 
[10:58:39.895]                             next
[10:58:39.895]                           invokeRestart(restart)
[10:58:39.895]                           muffled <- TRUE
[10:58:39.895]                           break
[10:58:39.895]                         }
[10:58:39.895]                       }
[10:58:39.895]                     }
[10:58:39.895]                     invisible(muffled)
[10:58:39.895]                   }
[10:58:39.895]                   muffleCondition(cond)
[10:58:39.895]                 })
[10:58:39.895]             }))
[10:58:39.895]             future::FutureResult(value = ...future.value$value, 
[10:58:39.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.895]                   ...future.rng), globalenv = if (FALSE) 
[10:58:39.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:39.895]                     ...future.globalenv.names))
[10:58:39.895]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:39.895]         }, condition = base::local({
[10:58:39.895]             c <- base::c
[10:58:39.895]             inherits <- base::inherits
[10:58:39.895]             invokeRestart <- base::invokeRestart
[10:58:39.895]             length <- base::length
[10:58:39.895]             list <- base::list
[10:58:39.895]             seq.int <- base::seq.int
[10:58:39.895]             signalCondition <- base::signalCondition
[10:58:39.895]             sys.calls <- base::sys.calls
[10:58:39.895]             `[[` <- base::`[[`
[10:58:39.895]             `+` <- base::`+`
[10:58:39.895]             `<<-` <- base::`<<-`
[10:58:39.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:39.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:39.895]                   3L)]
[10:58:39.895]             }
[10:58:39.895]             function(cond) {
[10:58:39.895]                 is_error <- inherits(cond, "error")
[10:58:39.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:39.895]                   NULL)
[10:58:39.895]                 if (is_error) {
[10:58:39.895]                   sessionInformation <- function() {
[10:58:39.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:39.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:39.895]                       search = base::search(), system = base::Sys.info())
[10:58:39.895]                   }
[10:58:39.895]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:39.895]                     cond$call), session = sessionInformation(), 
[10:58:39.895]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:39.895]                   signalCondition(cond)
[10:58:39.895]                 }
[10:58:39.895]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:58:39.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:39.895]                   ...future.conditions[[length(...future.conditions) + 
[10:58:39.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:39.895]                   if (TRUE && !signal) {
[10:58:39.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.895]                     {
[10:58:39.895]                       inherits <- base::inherits
[10:58:39.895]                       invokeRestart <- base::invokeRestart
[10:58:39.895]                       is.null <- base::is.null
[10:58:39.895]                       muffled <- FALSE
[10:58:39.895]                       if (inherits(cond, "message")) {
[10:58:39.895]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.895]                         if (muffled) 
[10:58:39.895]                           invokeRestart("muffleMessage")
[10:58:39.895]                       }
[10:58:39.895]                       else if (inherits(cond, "warning")) {
[10:58:39.895]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.895]                         if (muffled) 
[10:58:39.895]                           invokeRestart("muffleWarning")
[10:58:39.895]                       }
[10:58:39.895]                       else if (inherits(cond, "condition")) {
[10:58:39.895]                         if (!is.null(pattern)) {
[10:58:39.895]                           computeRestarts <- base::computeRestarts
[10:58:39.895]                           grepl <- base::grepl
[10:58:39.895]                           restarts <- computeRestarts(cond)
[10:58:39.895]                           for (restart in restarts) {
[10:58:39.895]                             name <- restart$name
[10:58:39.895]                             if (is.null(name)) 
[10:58:39.895]                               next
[10:58:39.895]                             if (!grepl(pattern, name)) 
[10:58:39.895]                               next
[10:58:39.895]                             invokeRestart(restart)
[10:58:39.895]                             muffled <- TRUE
[10:58:39.895]                             break
[10:58:39.895]                           }
[10:58:39.895]                         }
[10:58:39.895]                       }
[10:58:39.895]                       invisible(muffled)
[10:58:39.895]                     }
[10:58:39.895]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.895]                   }
[10:58:39.895]                 }
[10:58:39.895]                 else {
[10:58:39.895]                   if (TRUE) {
[10:58:39.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:39.895]                     {
[10:58:39.895]                       inherits <- base::inherits
[10:58:39.895]                       invokeRestart <- base::invokeRestart
[10:58:39.895]                       is.null <- base::is.null
[10:58:39.895]                       muffled <- FALSE
[10:58:39.895]                       if (inherits(cond, "message")) {
[10:58:39.895]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:39.895]                         if (muffled) 
[10:58:39.895]                           invokeRestart("muffleMessage")
[10:58:39.895]                       }
[10:58:39.895]                       else if (inherits(cond, "warning")) {
[10:58:39.895]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:39.895]                         if (muffled) 
[10:58:39.895]                           invokeRestart("muffleWarning")
[10:58:39.895]                       }
[10:58:39.895]                       else if (inherits(cond, "condition")) {
[10:58:39.895]                         if (!is.null(pattern)) {
[10:58:39.895]                           computeRestarts <- base::computeRestarts
[10:58:39.895]                           grepl <- base::grepl
[10:58:39.895]                           restarts <- computeRestarts(cond)
[10:58:39.895]                           for (restart in restarts) {
[10:58:39.895]                             name <- restart$name
[10:58:39.895]                             if (is.null(name)) 
[10:58:39.895]                               next
[10:58:39.895]                             if (!grepl(pattern, name)) 
[10:58:39.895]                               next
[10:58:39.895]                             invokeRestart(restart)
[10:58:39.895]                             muffled <- TRUE
[10:58:39.895]                             break
[10:58:39.895]                           }
[10:58:39.895]                         }
[10:58:39.895]                       }
[10:58:39.895]                       invisible(muffled)
[10:58:39.895]                     }
[10:58:39.895]                     muffleCondition(cond, pattern = "^muffle")
[10:58:39.895]                   }
[10:58:39.895]                 }
[10:58:39.895]             }
[10:58:39.895]         }))
[10:58:39.895]     }, error = function(ex) {
[10:58:39.895]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:39.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:39.895]                 ...future.rng), started = ...future.startTime, 
[10:58:39.895]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:39.895]             version = "1.8"), class = "FutureResult")
[10:58:39.895]     }, finally = {
[10:58:39.895]         if (!identical(...future.workdir, getwd())) 
[10:58:39.895]             setwd(...future.workdir)
[10:58:39.895]         {
[10:58:39.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:39.895]                 ...future.oldOptions$nwarnings <- NULL
[10:58:39.895]             }
[10:58:39.895]             base::options(...future.oldOptions)
[10:58:39.895]             if (.Platform$OS.type == "windows") {
[10:58:39.895]                 old_names <- names(...future.oldEnvVars)
[10:58:39.895]                 envs <- base::Sys.getenv()
[10:58:39.895]                 names <- names(envs)
[10:58:39.895]                 common <- intersect(names, old_names)
[10:58:39.895]                 added <- setdiff(names, old_names)
[10:58:39.895]                 removed <- setdiff(old_names, names)
[10:58:39.895]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:39.895]                   envs[common]]
[10:58:39.895]                 NAMES <- toupper(changed)
[10:58:39.895]                 args <- list()
[10:58:39.895]                 for (kk in seq_along(NAMES)) {
[10:58:39.895]                   name <- changed[[kk]]
[10:58:39.895]                   NAME <- NAMES[[kk]]
[10:58:39.895]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.895]                     next
[10:58:39.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.895]                 }
[10:58:39.895]                 NAMES <- toupper(added)
[10:58:39.895]                 for (kk in seq_along(NAMES)) {
[10:58:39.895]                   name <- added[[kk]]
[10:58:39.895]                   NAME <- NAMES[[kk]]
[10:58:39.895]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.895]                     next
[10:58:39.895]                   args[[name]] <- ""
[10:58:39.895]                 }
[10:58:39.895]                 NAMES <- toupper(removed)
[10:58:39.895]                 for (kk in seq_along(NAMES)) {
[10:58:39.895]                   name <- removed[[kk]]
[10:58:39.895]                   NAME <- NAMES[[kk]]
[10:58:39.895]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:39.895]                     next
[10:58:39.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:39.895]                 }
[10:58:39.895]                 if (length(args) > 0) 
[10:58:39.895]                   base::do.call(base::Sys.setenv, args = args)
[10:58:39.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:39.895]             }
[10:58:39.895]             else {
[10:58:39.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:39.895]             }
[10:58:39.895]             {
[10:58:39.895]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:39.895]                   0L) {
[10:58:39.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:39.895]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:39.895]                   base::options(opts)
[10:58:39.895]                 }
[10:58:39.895]                 {
[10:58:39.895]                   {
[10:58:39.895]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:39.895]                     NULL
[10:58:39.895]                   }
[10:58:39.895]                   options(future.plan = NULL)
[10:58:39.895]                   if (is.na(NA_character_)) 
[10:58:39.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:39.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:39.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:39.895]                     .init = FALSE)
[10:58:39.895]                 }
[10:58:39.895]             }
[10:58:39.895]         }
[10:58:39.895]     })
[10:58:39.895]     if (TRUE) {
[10:58:39.895]         base::sink(type = "output", split = FALSE)
[10:58:39.895]         if (TRUE) {
[10:58:39.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:39.895]         }
[10:58:39.895]         else {
[10:58:39.895]             ...future.result["stdout"] <- base::list(NULL)
[10:58:39.895]         }
[10:58:39.895]         base::close(...future.stdout)
[10:58:39.895]         ...future.stdout <- NULL
[10:58:39.895]     }
[10:58:39.895]     ...future.result$conditions <- ...future.conditions
[10:58:39.895]     ...future.result$finished <- base::Sys.time()
[10:58:39.895]     ...future.result
[10:58:39.895] }
[10:58:39.899] assign_globals() ...
[10:58:39.899] List of 5
[10:58:39.899]  $ future.call.arguments    : list()
[10:58:39.899]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:39.899]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:58:39.899]  $ ...future.elements_ii    :List of 1
[10:58:39.899]   ..$ : int [1:2] 2 4
[10:58:39.899]  $ ...future.seeds_ii       :List of 1
[10:58:39.899]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:58:39.899]  $ ...future.globals.maxSize: num Inf
[10:58:39.899]  - attr(*, "resolved")= logi FALSE
[10:58:39.899]  - attr(*, "total_size")= num NA
[10:58:39.899]  - attr(*, "where")=List of 5
[10:58:39.899]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:58:39.899]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:58:39.899]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:58:39.899]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:58:39.899]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:58:39.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:39.899]  - attr(*, "already-done")= logi TRUE
[10:58:39.910] - copied ‘future.call.arguments’ to environment
[10:58:39.910] - copied ‘...future.FUN’ to environment
[10:58:39.910] - copied ‘...future.elements_ii’ to environment
[10:58:39.910] - copied ‘...future.seeds_ii’ to environment
[10:58:39.910] - copied ‘...future.globals.maxSize’ to environment
[10:58:39.911] assign_globals() ... done
[10:58:39.911] requestCore(): workers = 2
[10:58:39.914] MulticoreFuture started
[10:58:39.914] - Launch lazy future ... done
[10:58:39.915] plan(): Setting new future strategy stack:
[10:58:39.915] run() for ‘MulticoreFuture’ ... done
[10:58:39.916] Created future:
[10:58:39.915] List of future strategies:
[10:58:39.915] 1. sequential:
[10:58:39.915]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.915]    - tweaked: FALSE
[10:58:39.915]    - call: NULL
[10:58:39.917] plan(): nbrOfWorkers() = 1
[10:58:39.919] plan(): Setting new future strategy stack:
[10:58:39.919] List of future strategies:
[10:58:39.919] 1. multicore:
[10:58:39.919]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:58:39.919]    - tweaked: FALSE
[10:58:39.919]    - call: plan(strategy)
[10:58:39.923] plan(): nbrOfWorkers() = 2
[10:58:39.916] MulticoreFuture:
[10:58:39.916] Label: ‘future_apply-2’
[10:58:39.916] Expression:
[10:58:39.916] {
[10:58:39.916]     do.call(function(...) {
[10:58:39.916]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:39.916]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:39.916]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:39.916]             on.exit(options(oopts), add = TRUE)
[10:58:39.916]         }
[10:58:39.916]         {
[10:58:39.916]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:39.916]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:39.916]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:39.916]                   envir = globalenv(), inherits = FALSE)
[10:58:39.916]                 ...future.FUN(...future.X_jj, ...)
[10:58:39.916]             })
[10:58:39.916]         }
[10:58:39.916]     }, args = future.call.arguments)
[10:58:39.916] }
[10:58:39.916] Lazy evaluation: FALSE
[10:58:39.916] Asynchronous evaluation: TRUE
[10:58:39.916] Local evaluation: TRUE
[10:58:39.916] Environment: R_GlobalEnv
[10:58:39.916] Capture standard output: TRUE
[10:58:39.916] Capture condition classes: <none>
[10:58:39.916] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:39.916] Packages: <none>
[10:58:39.916] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:58:39.916] Resolved: TRUE
[10:58:39.916] Value: <not collected>
[10:58:39.916] Conditions captured: <none>
[10:58:39.916] Early signaling: FALSE
[10:58:39.916] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:39.916] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:39.924] Chunk #2 of 2 ... DONE
[10:58:39.924] Launching 2 futures (chunks) ... DONE
[10:58:39.924] Resolving 2 futures (chunks) ...
[10:58:39.924] resolve() on list ...
[10:58:39.924]  recursive: 0
[10:58:39.924]  length: 2
[10:58:39.925] 
[10:58:39.925] Future #1
[10:58:39.925] result() for MulticoreFuture ...
[10:58:39.926] result() for MulticoreFuture ...
[10:58:39.926] result() for MulticoreFuture ... done
[10:58:39.927] result() for MulticoreFuture ... done
[10:58:39.927] result() for MulticoreFuture ...
[10:58:39.927] result() for MulticoreFuture ... done
[10:58:39.927] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:58:39.927] - nx: 2
[10:58:39.927] - relay: TRUE
[10:58:39.928] - stdout: TRUE
[10:58:39.928] - signal: TRUE
[10:58:39.928] - resignal: FALSE
[10:58:39.928] - force: TRUE
[10:58:39.928] - relayed: [n=2] FALSE, FALSE
[10:58:39.928] - queued futures: [n=2] FALSE, FALSE
[10:58:39.928]  - until=1
[10:58:39.929]  - relaying element #1
[10:58:39.929] result() for MulticoreFuture ...
[10:58:39.929] result() for MulticoreFuture ... done
[10:58:39.929] result() for MulticoreFuture ...
[10:58:39.929] result() for MulticoreFuture ... done
[10:58:39.929] result() for MulticoreFuture ...
[10:58:39.929] result() for MulticoreFuture ... done
[10:58:39.930] result() for MulticoreFuture ...
[10:58:39.930] result() for MulticoreFuture ... done
[10:58:39.930] - relayed: [n=2] TRUE, FALSE
[10:58:39.930] - queued futures: [n=2] TRUE, FALSE
[10:58:39.930] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:58:39.930]  length: 1 (resolved future 1)
[10:58:39.931] Future #2
[10:58:39.931] result() for MulticoreFuture ...
[10:58:39.931] result() for MulticoreFuture ...
[10:58:39.932] result() for MulticoreFuture ... done
[10:58:39.932] result() for MulticoreFuture ... done
[10:58:39.932] result() for MulticoreFuture ...
[10:58:39.932] result() for MulticoreFuture ... done
[10:58:39.932] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:58:39.932] - nx: 2
[10:58:39.932] - relay: TRUE
[10:58:39.933] - stdout: TRUE
[10:58:39.933] - signal: TRUE
[10:58:39.933] - resignal: FALSE
[10:58:39.933] - force: TRUE
[10:58:39.933] - relayed: [n=2] TRUE, FALSE
[10:58:39.933] - queued futures: [n=2] TRUE, FALSE
[10:58:39.933]  - until=2
[10:58:39.933]  - relaying element #2
[10:58:39.933] result() for MulticoreFuture ...
[10:58:39.934] result() for MulticoreFuture ... done
[10:58:39.934] result() for MulticoreFuture ...
[10:58:39.934] result() for MulticoreFuture ... done
[10:58:39.934] result() for MulticoreFuture ...
[10:58:39.934] result() for MulticoreFuture ... done
[10:58:39.934] result() for MulticoreFuture ...
[10:58:39.934] result() for MulticoreFuture ... done
[10:58:39.934] - relayed: [n=2] TRUE, TRUE
[10:58:39.935] - queued futures: [n=2] TRUE, TRUE
[10:58:39.935] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:58:39.935]  length: 0 (resolved future 2)
[10:58:39.935] Relaying remaining futures
[10:58:39.935] signalConditionsASAP(NULL, pos=0) ...
[10:58:39.935] - nx: 2
[10:58:39.935] - relay: TRUE
[10:58:39.935] - stdout: TRUE
[10:58:39.935] - signal: TRUE
[10:58:39.935] - resignal: FALSE
[10:58:39.936] - force: TRUE
[10:58:39.936] - relayed: [n=2] TRUE, TRUE
[10:58:39.936] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:39.936] - relayed: [n=2] TRUE, TRUE
[10:58:39.936] - queued futures: [n=2] TRUE, TRUE
[10:58:39.936] signalConditionsASAP(NULL, pos=0) ... done
[10:58:39.936] resolve() on list ... DONE
[10:58:39.936] result() for MulticoreFuture ...
[10:58:39.936] result() for MulticoreFuture ... done
[10:58:39.937] result() for MulticoreFuture ...
[10:58:39.937] result() for MulticoreFuture ... done
[10:58:39.937] result() for MulticoreFuture ...
[10:58:39.937] result() for MulticoreFuture ... done
[10:58:39.937] result() for MulticoreFuture ...
[10:58:39.937] result() for MulticoreFuture ... done
[10:58:39.937]  - Number of value chunks collected: 2
[10:58:39.937] Resolving 2 futures (chunks) ... DONE
[10:58:39.938] Reducing values from 2 chunks ...
[10:58:39.938]  - Number of values collected after concatenation: 2
[10:58:39.938]  - Number of values expected: 2
[10:58:39.938] Reducing values from 2 chunks ... DONE
[10:58:39.938] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:58:39.938] plan(): Setting new future strategy stack:
[10:58:39.938] List of future strategies:
[10:58:39.938] 1. sequential:
[10:58:39.938]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:39.938]    - tweaked: FALSE
[10:58:39.938]    - call: plan(sequential)
[10:58:39.939] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:58:39.940] plan(): Setting new future strategy stack:
[10:58:39.940] List of future strategies:
[10:58:39.940] 1. multisession:
[10:58:39.940]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:39.940]    - tweaked: FALSE
[10:58:39.940]    - call: plan(strategy)
[10:58:39.940] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:58:39.940] multisession:
[10:58:39.940] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:58:39.940] - tweaked: FALSE
[10:58:39.940] - call: plan(strategy)
[10:58:39.944] getGlobalsAndPackages() ...
[10:58:39.945] Not searching for globals
[10:58:39.945] - globals: [0] <none>
[10:58:39.945] getGlobalsAndPackages() ... DONE
[10:58:40.435] Packages needed by the future expression (n = 0): <none>
[10:58:40.435] Packages needed by future strategies (n = 0): <none>
[10:58:40.436] {
[10:58:40.436]     {
[10:58:40.436]         {
[10:58:40.436]             ...future.startTime <- base::Sys.time()
[10:58:40.436]             {
[10:58:40.436]                 {
[10:58:40.436]                   {
[10:58:40.436]                     {
[10:58:40.436]                       base::local({
[10:58:40.436]                         has_future <- base::requireNamespace("future", 
[10:58:40.436]                           quietly = TRUE)
[10:58:40.436]                         if (has_future) {
[10:58:40.436]                           ns <- base::getNamespace("future")
[10:58:40.436]                           version <- ns[[".package"]][["version"]]
[10:58:40.436]                           if (is.null(version)) 
[10:58:40.436]                             version <- utils::packageVersion("future")
[10:58:40.436]                         }
[10:58:40.436]                         else {
[10:58:40.436]                           version <- NULL
[10:58:40.436]                         }
[10:58:40.436]                         if (!has_future || version < "1.8.0") {
[10:58:40.436]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:40.436]                             "", base::R.version$version.string), 
[10:58:40.436]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:40.436]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:40.436]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:40.436]                               "release", "version")], collapse = " "), 
[10:58:40.436]                             hostname = base::Sys.info()[["nodename"]])
[10:58:40.436]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:40.436]                             info)
[10:58:40.436]                           info <- base::paste(info, collapse = "; ")
[10:58:40.436]                           if (!has_future) {
[10:58:40.436]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:40.436]                               info)
[10:58:40.436]                           }
[10:58:40.436]                           else {
[10:58:40.436]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:40.436]                               info, version)
[10:58:40.436]                           }
[10:58:40.436]                           base::stop(msg)
[10:58:40.436]                         }
[10:58:40.436]                       })
[10:58:40.436]                     }
[10:58:40.436]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:40.436]                     base::options(mc.cores = 1L)
[10:58:40.436]                   }
[10:58:40.436]                   ...future.strategy.old <- future::plan("list")
[10:58:40.436]                   options(future.plan = NULL)
[10:58:40.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:40.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:40.436]                 }
[10:58:40.436]                 ...future.workdir <- getwd()
[10:58:40.436]             }
[10:58:40.436]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:40.436]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:40.436]         }
[10:58:40.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:40.436]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:58:40.436]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:40.436]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:40.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:40.436]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:40.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:40.436]             base::names(...future.oldOptions))
[10:58:40.436]     }
[10:58:40.436]     if (FALSE) {
[10:58:40.436]     }
[10:58:40.436]     else {
[10:58:40.436]         if (TRUE) {
[10:58:40.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:40.436]                 open = "w")
[10:58:40.436]         }
[10:58:40.436]         else {
[10:58:40.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:40.436]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:40.436]         }
[10:58:40.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:40.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:40.436]             base::sink(type = "output", split = FALSE)
[10:58:40.436]             base::close(...future.stdout)
[10:58:40.436]         }, add = TRUE)
[10:58:40.436]     }
[10:58:40.436]     ...future.frame <- base::sys.nframe()
[10:58:40.436]     ...future.conditions <- base::list()
[10:58:40.436]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:40.436]     if (FALSE) {
[10:58:40.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:40.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:40.436]     }
[10:58:40.436]     ...future.result <- base::tryCatch({
[10:58:40.436]         base::withCallingHandlers({
[10:58:40.436]             ...future.value <- base::withVisible(base::local({
[10:58:40.436]                 ...future.makeSendCondition <- base::local({
[10:58:40.436]                   sendCondition <- NULL
[10:58:40.436]                   function(frame = 1L) {
[10:58:40.436]                     if (is.function(sendCondition)) 
[10:58:40.436]                       return(sendCondition)
[10:58:40.436]                     ns <- getNamespace("parallel")
[10:58:40.436]                     if (exists("sendData", mode = "function", 
[10:58:40.436]                       envir = ns)) {
[10:58:40.436]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:40.436]                         envir = ns)
[10:58:40.436]                       envir <- sys.frame(frame)
[10:58:40.436]                       master <- NULL
[10:58:40.436]                       while (!identical(envir, .GlobalEnv) && 
[10:58:40.436]                         !identical(envir, emptyenv())) {
[10:58:40.436]                         if (exists("master", mode = "list", envir = envir, 
[10:58:40.436]                           inherits = FALSE)) {
[10:58:40.436]                           master <- get("master", mode = "list", 
[10:58:40.436]                             envir = envir, inherits = FALSE)
[10:58:40.436]                           if (inherits(master, c("SOCKnode", 
[10:58:40.436]                             "SOCK0node"))) {
[10:58:40.436]                             sendCondition <<- function(cond) {
[10:58:40.436]                               data <- list(type = "VALUE", value = cond, 
[10:58:40.436]                                 success = TRUE)
[10:58:40.436]                               parallel_sendData(master, data)
[10:58:40.436]                             }
[10:58:40.436]                             return(sendCondition)
[10:58:40.436]                           }
[10:58:40.436]                         }
[10:58:40.436]                         frame <- frame + 1L
[10:58:40.436]                         envir <- sys.frame(frame)
[10:58:40.436]                       }
[10:58:40.436]                     }
[10:58:40.436]                     sendCondition <<- function(cond) NULL
[10:58:40.436]                   }
[10:58:40.436]                 })
[10:58:40.436]                 withCallingHandlers({
[10:58:40.436]                   NA
[10:58:40.436]                 }, immediateCondition = function(cond) {
[10:58:40.436]                   sendCondition <- ...future.makeSendCondition()
[10:58:40.436]                   sendCondition(cond)
[10:58:40.436]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.436]                   {
[10:58:40.436]                     inherits <- base::inherits
[10:58:40.436]                     invokeRestart <- base::invokeRestart
[10:58:40.436]                     is.null <- base::is.null
[10:58:40.436]                     muffled <- FALSE
[10:58:40.436]                     if (inherits(cond, "message")) {
[10:58:40.436]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:40.436]                       if (muffled) 
[10:58:40.436]                         invokeRestart("muffleMessage")
[10:58:40.436]                     }
[10:58:40.436]                     else if (inherits(cond, "warning")) {
[10:58:40.436]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:40.436]                       if (muffled) 
[10:58:40.436]                         invokeRestart("muffleWarning")
[10:58:40.436]                     }
[10:58:40.436]                     else if (inherits(cond, "condition")) {
[10:58:40.436]                       if (!is.null(pattern)) {
[10:58:40.436]                         computeRestarts <- base::computeRestarts
[10:58:40.436]                         grepl <- base::grepl
[10:58:40.436]                         restarts <- computeRestarts(cond)
[10:58:40.436]                         for (restart in restarts) {
[10:58:40.436]                           name <- restart$name
[10:58:40.436]                           if (is.null(name)) 
[10:58:40.436]                             next
[10:58:40.436]                           if (!grepl(pattern, name)) 
[10:58:40.436]                             next
[10:58:40.436]                           invokeRestart(restart)
[10:58:40.436]                           muffled <- TRUE
[10:58:40.436]                           break
[10:58:40.436]                         }
[10:58:40.436]                       }
[10:58:40.436]                     }
[10:58:40.436]                     invisible(muffled)
[10:58:40.436]                   }
[10:58:40.436]                   muffleCondition(cond)
[10:58:40.436]                 })
[10:58:40.436]             }))
[10:58:40.436]             future::FutureResult(value = ...future.value$value, 
[10:58:40.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:40.436]                   ...future.rng), globalenv = if (FALSE) 
[10:58:40.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:40.436]                     ...future.globalenv.names))
[10:58:40.436]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:40.436]         }, condition = base::local({
[10:58:40.436]             c <- base::c
[10:58:40.436]             inherits <- base::inherits
[10:58:40.436]             invokeRestart <- base::invokeRestart
[10:58:40.436]             length <- base::length
[10:58:40.436]             list <- base::list
[10:58:40.436]             seq.int <- base::seq.int
[10:58:40.436]             signalCondition <- base::signalCondition
[10:58:40.436]             sys.calls <- base::sys.calls
[10:58:40.436]             `[[` <- base::`[[`
[10:58:40.436]             `+` <- base::`+`
[10:58:40.436]             `<<-` <- base::`<<-`
[10:58:40.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:40.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:40.436]                   3L)]
[10:58:40.436]             }
[10:58:40.436]             function(cond) {
[10:58:40.436]                 is_error <- inherits(cond, "error")
[10:58:40.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:40.436]                   NULL)
[10:58:40.436]                 if (is_error) {
[10:58:40.436]                   sessionInformation <- function() {
[10:58:40.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:40.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:40.436]                       search = base::search(), system = base::Sys.info())
[10:58:40.436]                   }
[10:58:40.436]                   ...future.conditions[[length(...future.conditions) + 
[10:58:40.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:40.436]                     cond$call), session = sessionInformation(), 
[10:58:40.436]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:40.436]                   signalCondition(cond)
[10:58:40.436]                 }
[10:58:40.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:40.436]                 "immediateCondition"))) {
[10:58:40.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:40.436]                   ...future.conditions[[length(...future.conditions) + 
[10:58:40.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:40.436]                   if (TRUE && !signal) {
[10:58:40.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.436]                     {
[10:58:40.436]                       inherits <- base::inherits
[10:58:40.436]                       invokeRestart <- base::invokeRestart
[10:58:40.436]                       is.null <- base::is.null
[10:58:40.436]                       muffled <- FALSE
[10:58:40.436]                       if (inherits(cond, "message")) {
[10:58:40.436]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:40.436]                         if (muffled) 
[10:58:40.436]                           invokeRestart("muffleMessage")
[10:58:40.436]                       }
[10:58:40.436]                       else if (inherits(cond, "warning")) {
[10:58:40.436]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:40.436]                         if (muffled) 
[10:58:40.436]                           invokeRestart("muffleWarning")
[10:58:40.436]                       }
[10:58:40.436]                       else if (inherits(cond, "condition")) {
[10:58:40.436]                         if (!is.null(pattern)) {
[10:58:40.436]                           computeRestarts <- base::computeRestarts
[10:58:40.436]                           grepl <- base::grepl
[10:58:40.436]                           restarts <- computeRestarts(cond)
[10:58:40.436]                           for (restart in restarts) {
[10:58:40.436]                             name <- restart$name
[10:58:40.436]                             if (is.null(name)) 
[10:58:40.436]                               next
[10:58:40.436]                             if (!grepl(pattern, name)) 
[10:58:40.436]                               next
[10:58:40.436]                             invokeRestart(restart)
[10:58:40.436]                             muffled <- TRUE
[10:58:40.436]                             break
[10:58:40.436]                           }
[10:58:40.436]                         }
[10:58:40.436]                       }
[10:58:40.436]                       invisible(muffled)
[10:58:40.436]                     }
[10:58:40.436]                     muffleCondition(cond, pattern = "^muffle")
[10:58:40.436]                   }
[10:58:40.436]                 }
[10:58:40.436]                 else {
[10:58:40.436]                   if (TRUE) {
[10:58:40.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.436]                     {
[10:58:40.436]                       inherits <- base::inherits
[10:58:40.436]                       invokeRestart <- base::invokeRestart
[10:58:40.436]                       is.null <- base::is.null
[10:58:40.436]                       muffled <- FALSE
[10:58:40.436]                       if (inherits(cond, "message")) {
[10:58:40.436]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:40.436]                         if (muffled) 
[10:58:40.436]                           invokeRestart("muffleMessage")
[10:58:40.436]                       }
[10:58:40.436]                       else if (inherits(cond, "warning")) {
[10:58:40.436]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:40.436]                         if (muffled) 
[10:58:40.436]                           invokeRestart("muffleWarning")
[10:58:40.436]                       }
[10:58:40.436]                       else if (inherits(cond, "condition")) {
[10:58:40.436]                         if (!is.null(pattern)) {
[10:58:40.436]                           computeRestarts <- base::computeRestarts
[10:58:40.436]                           grepl <- base::grepl
[10:58:40.436]                           restarts <- computeRestarts(cond)
[10:58:40.436]                           for (restart in restarts) {
[10:58:40.436]                             name <- restart$name
[10:58:40.436]                             if (is.null(name)) 
[10:58:40.436]                               next
[10:58:40.436]                             if (!grepl(pattern, name)) 
[10:58:40.436]                               next
[10:58:40.436]                             invokeRestart(restart)
[10:58:40.436]                             muffled <- TRUE
[10:58:40.436]                             break
[10:58:40.436]                           }
[10:58:40.436]                         }
[10:58:40.436]                       }
[10:58:40.436]                       invisible(muffled)
[10:58:40.436]                     }
[10:58:40.436]                     muffleCondition(cond, pattern = "^muffle")
[10:58:40.436]                   }
[10:58:40.436]                 }
[10:58:40.436]             }
[10:58:40.436]         }))
[10:58:40.436]     }, error = function(ex) {
[10:58:40.436]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:40.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:40.436]                 ...future.rng), started = ...future.startTime, 
[10:58:40.436]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:40.436]             version = "1.8"), class = "FutureResult")
[10:58:40.436]     }, finally = {
[10:58:40.436]         if (!identical(...future.workdir, getwd())) 
[10:58:40.436]             setwd(...future.workdir)
[10:58:40.436]         {
[10:58:40.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:40.436]                 ...future.oldOptions$nwarnings <- NULL
[10:58:40.436]             }
[10:58:40.436]             base::options(...future.oldOptions)
[10:58:40.436]             if (.Platform$OS.type == "windows") {
[10:58:40.436]                 old_names <- names(...future.oldEnvVars)
[10:58:40.436]                 envs <- base::Sys.getenv()
[10:58:40.436]                 names <- names(envs)
[10:58:40.436]                 common <- intersect(names, old_names)
[10:58:40.436]                 added <- setdiff(names, old_names)
[10:58:40.436]                 removed <- setdiff(old_names, names)
[10:58:40.436]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:40.436]                   envs[common]]
[10:58:40.436]                 NAMES <- toupper(changed)
[10:58:40.436]                 args <- list()
[10:58:40.436]                 for (kk in seq_along(NAMES)) {
[10:58:40.436]                   name <- changed[[kk]]
[10:58:40.436]                   NAME <- NAMES[[kk]]
[10:58:40.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.436]                     next
[10:58:40.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:40.436]                 }
[10:58:40.436]                 NAMES <- toupper(added)
[10:58:40.436]                 for (kk in seq_along(NAMES)) {
[10:58:40.436]                   name <- added[[kk]]
[10:58:40.436]                   NAME <- NAMES[[kk]]
[10:58:40.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.436]                     next
[10:58:40.436]                   args[[name]] <- ""
[10:58:40.436]                 }
[10:58:40.436]                 NAMES <- toupper(removed)
[10:58:40.436]                 for (kk in seq_along(NAMES)) {
[10:58:40.436]                   name <- removed[[kk]]
[10:58:40.436]                   NAME <- NAMES[[kk]]
[10:58:40.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.436]                     next
[10:58:40.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:40.436]                 }
[10:58:40.436]                 if (length(args) > 0) 
[10:58:40.436]                   base::do.call(base::Sys.setenv, args = args)
[10:58:40.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:40.436]             }
[10:58:40.436]             else {
[10:58:40.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:40.436]             }
[10:58:40.436]             {
[10:58:40.436]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:40.436]                   0L) {
[10:58:40.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:40.436]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:40.436]                   base::options(opts)
[10:58:40.436]                 }
[10:58:40.436]                 {
[10:58:40.436]                   {
[10:58:40.436]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:40.436]                     NULL
[10:58:40.436]                   }
[10:58:40.436]                   options(future.plan = NULL)
[10:58:40.436]                   if (is.na(NA_character_)) 
[10:58:40.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:40.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:40.436]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:40.436]                     .init = FALSE)
[10:58:40.436]                 }
[10:58:40.436]             }
[10:58:40.436]         }
[10:58:40.436]     })
[10:58:40.436]     if (TRUE) {
[10:58:40.436]         base::sink(type = "output", split = FALSE)
[10:58:40.436]         if (TRUE) {
[10:58:40.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:40.436]         }
[10:58:40.436]         else {
[10:58:40.436]             ...future.result["stdout"] <- base::list(NULL)
[10:58:40.436]         }
[10:58:40.436]         base::close(...future.stdout)
[10:58:40.436]         ...future.stdout <- NULL
[10:58:40.436]     }
[10:58:40.436]     ...future.result$conditions <- ...future.conditions
[10:58:40.436]     ...future.result$finished <- base::Sys.time()
[10:58:40.436]     ...future.result
[10:58:40.436] }
[10:58:40.487] MultisessionFuture started
[10:58:40.487] result() for ClusterFuture ...
[10:58:40.488] receiveMessageFromWorker() for ClusterFuture ...
[10:58:40.488] - Validating connection of MultisessionFuture
[10:58:40.518] - received message: FutureResult
[10:58:40.518] - Received FutureResult
[10:58:40.518] - Erased future from FutureRegistry
[10:58:40.518] result() for ClusterFuture ...
[10:58:40.518] - result already collected: FutureResult
[10:58:40.519] result() for ClusterFuture ... done
[10:58:40.519] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:40.519] result() for ClusterFuture ... done
[10:58:40.519] result() for ClusterFuture ...
[10:58:40.519] - result already collected: FutureResult
[10:58:40.519] result() for ClusterFuture ... done
[10:58:40.519] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:58:40.521] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[10:58:40.521] getGlobalsAndPackagesXApply() ...
[10:58:40.521]  - future.globals: TRUE
[10:58:40.521] getGlobalsAndPackages() ...
[10:58:40.522] Searching for globals...
[10:58:40.559] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:58:40.559] Searching for globals ... DONE
[10:58:40.559] Resolving globals: FALSE
[10:58:40.562] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:58:40.562] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:58:40.562] - globals: [1] ‘FUN’
[10:58:40.562] 
[10:58:40.563] getGlobalsAndPackages() ... DONE
[10:58:40.563]  - globals found/used: [n=1] ‘FUN’
[10:58:40.563]  - needed namespaces: [n=0] 
[10:58:40.563] Finding globals ... DONE
[10:58:40.563]  - use_args: TRUE
[10:58:40.563]  - Getting '...' globals ...
[10:58:40.564] resolve() on list ...
[10:58:40.564]  recursive: 0
[10:58:40.564]  length: 1
[10:58:40.564]  elements: ‘...’
[10:58:40.564]  length: 0 (resolved future 1)
[10:58:40.564] resolve() on list ... DONE
[10:58:40.564]    - '...' content: [n=0] 
[10:58:40.564] List of 1
[10:58:40.564]  $ ...: list()
[10:58:40.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:40.564]  - attr(*, "where")=List of 1
[10:58:40.564]   ..$ ...:<environment: 0x5635bf493de0> 
[10:58:40.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:40.564]  - attr(*, "resolved")= logi TRUE
[10:58:40.564]  - attr(*, "total_size")= num NA
[10:58:40.568]  - Getting '...' globals ... DONE
[10:58:40.568] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:40.568] List of 2
[10:58:40.568]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:40.568]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:40.568]  $ ...          : list()
[10:58:40.568]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:40.568]  - attr(*, "where")=List of 2
[10:58:40.568]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:40.568]   ..$ ...          :<environment: 0x5635bf493de0> 
[10:58:40.568]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:40.568]  - attr(*, "resolved")= logi FALSE
[10:58:40.568]  - attr(*, "total_size")= num 65963
[10:58:40.571] Packages to be attached in all futures: [n=0] 
[10:58:40.571] getGlobalsAndPackagesXApply() ... DONE
[10:58:40.573] future_lapply() ...
[10:58:40.609] Number of chunks: 2
[10:58:40.609] getGlobalsAndPackagesXApply() ...
[10:58:40.609]  - future.globals: <name-value list> with names ‘list()’
[10:58:40.609]  - use_args: TRUE
[10:58:40.609] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:40.609] List of 2
[10:58:40.609]  $ ...          : list()
[10:58:40.609]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:40.609]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:40.609]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:40.609]  - attr(*, "where")=List of 2
[10:58:40.609]   ..$ ...          :<environment: 0x5635bf493de0> 
[10:58:40.609]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:40.609]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:40.609]  - attr(*, "resolved")= logi FALSE
[10:58:40.609]  - attr(*, "total_size")= num NA
[10:58:40.613] Packages to be attached in all futures: [n=0] 
[10:58:40.613] getGlobalsAndPackagesXApply() ... DONE
[10:58:40.613] Number of futures (= number of chunks): 2
[10:58:40.613] Launching 2 futures (chunks) ...
[10:58:40.613] Chunk #1 of 2 ...
[10:58:40.613]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:40.613]  - seeds: <none>
[10:58:40.613]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:40.614] getGlobalsAndPackages() ...
[10:58:40.614] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:40.614] Resolving globals: FALSE
[10:58:40.614] Tweak future expression to call with '...' arguments ...
[10:58:40.614] {
[10:58:40.614]     do.call(function(...) {
[10:58:40.614]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:40.614]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:40.614]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:40.614]             on.exit(options(oopts), add = TRUE)
[10:58:40.614]         }
[10:58:40.614]         {
[10:58:40.614]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:40.614]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:40.614]                 ...future.FUN(...future.X_jj, ...)
[10:58:40.614]             })
[10:58:40.614]         }
[10:58:40.614]     }, args = future.call.arguments)
[10:58:40.614] }
[10:58:40.614] Tweak future expression to call with '...' arguments ... DONE
[10:58:40.615] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:40.615] 
[10:58:40.615] getGlobalsAndPackages() ... DONE
[10:58:40.615] run() for ‘Future’ ...
[10:58:40.615] - state: ‘created’
[10:58:40.615] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:40.629] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:40.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:40.629]   - Field: ‘node’
[10:58:40.629]   - Field: ‘label’
[10:58:40.630]   - Field: ‘local’
[10:58:40.630]   - Field: ‘owner’
[10:58:40.630]   - Field: ‘envir’
[10:58:40.630]   - Field: ‘workers’
[10:58:40.630]   - Field: ‘packages’
[10:58:40.630]   - Field: ‘gc’
[10:58:40.630]   - Field: ‘conditions’
[10:58:40.630]   - Field: ‘persistent’
[10:58:40.630]   - Field: ‘expr’
[10:58:40.630]   - Field: ‘uuid’
[10:58:40.630]   - Field: ‘seed’
[10:58:40.631]   - Field: ‘version’
[10:58:40.631]   - Field: ‘result’
[10:58:40.631]   - Field: ‘asynchronous’
[10:58:40.631]   - Field: ‘calls’
[10:58:40.631]   - Field: ‘globals’
[10:58:40.631]   - Field: ‘stdout’
[10:58:40.631]   - Field: ‘earlySignal’
[10:58:40.631]   - Field: ‘lazy’
[10:58:40.631]   - Field: ‘state’
[10:58:40.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:40.631] - Launch lazy future ...
[10:58:40.632] Packages needed by the future expression (n = 0): <none>
[10:58:40.632] Packages needed by future strategies (n = 0): <none>
[10:58:40.632] {
[10:58:40.632]     {
[10:58:40.632]         {
[10:58:40.632]             ...future.startTime <- base::Sys.time()
[10:58:40.632]             {
[10:58:40.632]                 {
[10:58:40.632]                   {
[10:58:40.632]                     {
[10:58:40.632]                       base::local({
[10:58:40.632]                         has_future <- base::requireNamespace("future", 
[10:58:40.632]                           quietly = TRUE)
[10:58:40.632]                         if (has_future) {
[10:58:40.632]                           ns <- base::getNamespace("future")
[10:58:40.632]                           version <- ns[[".package"]][["version"]]
[10:58:40.632]                           if (is.null(version)) 
[10:58:40.632]                             version <- utils::packageVersion("future")
[10:58:40.632]                         }
[10:58:40.632]                         else {
[10:58:40.632]                           version <- NULL
[10:58:40.632]                         }
[10:58:40.632]                         if (!has_future || version < "1.8.0") {
[10:58:40.632]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:40.632]                             "", base::R.version$version.string), 
[10:58:40.632]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:40.632]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:40.632]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:40.632]                               "release", "version")], collapse = " "), 
[10:58:40.632]                             hostname = base::Sys.info()[["nodename"]])
[10:58:40.632]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:40.632]                             info)
[10:58:40.632]                           info <- base::paste(info, collapse = "; ")
[10:58:40.632]                           if (!has_future) {
[10:58:40.632]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:40.632]                               info)
[10:58:40.632]                           }
[10:58:40.632]                           else {
[10:58:40.632]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:40.632]                               info, version)
[10:58:40.632]                           }
[10:58:40.632]                           base::stop(msg)
[10:58:40.632]                         }
[10:58:40.632]                       })
[10:58:40.632]                     }
[10:58:40.632]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:40.632]                     base::options(mc.cores = 1L)
[10:58:40.632]                   }
[10:58:40.632]                   ...future.strategy.old <- future::plan("list")
[10:58:40.632]                   options(future.plan = NULL)
[10:58:40.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:40.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:40.632]                 }
[10:58:40.632]                 ...future.workdir <- getwd()
[10:58:40.632]             }
[10:58:40.632]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:40.632]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:40.632]         }
[10:58:40.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:40.632]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:40.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:40.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:40.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:40.632]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:40.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:40.632]             base::names(...future.oldOptions))
[10:58:40.632]     }
[10:58:40.632]     if (FALSE) {
[10:58:40.632]     }
[10:58:40.632]     else {
[10:58:40.632]         if (TRUE) {
[10:58:40.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:40.632]                 open = "w")
[10:58:40.632]         }
[10:58:40.632]         else {
[10:58:40.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:40.632]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:40.632]         }
[10:58:40.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:40.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:40.632]             base::sink(type = "output", split = FALSE)
[10:58:40.632]             base::close(...future.stdout)
[10:58:40.632]         }, add = TRUE)
[10:58:40.632]     }
[10:58:40.632]     ...future.frame <- base::sys.nframe()
[10:58:40.632]     ...future.conditions <- base::list()
[10:58:40.632]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:40.632]     if (FALSE) {
[10:58:40.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:40.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:40.632]     }
[10:58:40.632]     ...future.result <- base::tryCatch({
[10:58:40.632]         base::withCallingHandlers({
[10:58:40.632]             ...future.value <- base::withVisible(base::local({
[10:58:40.632]                 ...future.makeSendCondition <- base::local({
[10:58:40.632]                   sendCondition <- NULL
[10:58:40.632]                   function(frame = 1L) {
[10:58:40.632]                     if (is.function(sendCondition)) 
[10:58:40.632]                       return(sendCondition)
[10:58:40.632]                     ns <- getNamespace("parallel")
[10:58:40.632]                     if (exists("sendData", mode = "function", 
[10:58:40.632]                       envir = ns)) {
[10:58:40.632]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:40.632]                         envir = ns)
[10:58:40.632]                       envir <- sys.frame(frame)
[10:58:40.632]                       master <- NULL
[10:58:40.632]                       while (!identical(envir, .GlobalEnv) && 
[10:58:40.632]                         !identical(envir, emptyenv())) {
[10:58:40.632]                         if (exists("master", mode = "list", envir = envir, 
[10:58:40.632]                           inherits = FALSE)) {
[10:58:40.632]                           master <- get("master", mode = "list", 
[10:58:40.632]                             envir = envir, inherits = FALSE)
[10:58:40.632]                           if (inherits(master, c("SOCKnode", 
[10:58:40.632]                             "SOCK0node"))) {
[10:58:40.632]                             sendCondition <<- function(cond) {
[10:58:40.632]                               data <- list(type = "VALUE", value = cond, 
[10:58:40.632]                                 success = TRUE)
[10:58:40.632]                               parallel_sendData(master, data)
[10:58:40.632]                             }
[10:58:40.632]                             return(sendCondition)
[10:58:40.632]                           }
[10:58:40.632]                         }
[10:58:40.632]                         frame <- frame + 1L
[10:58:40.632]                         envir <- sys.frame(frame)
[10:58:40.632]                       }
[10:58:40.632]                     }
[10:58:40.632]                     sendCondition <<- function(cond) NULL
[10:58:40.632]                   }
[10:58:40.632]                 })
[10:58:40.632]                 withCallingHandlers({
[10:58:40.632]                   {
[10:58:40.632]                     do.call(function(...) {
[10:58:40.632]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:40.632]                       if (!identical(...future.globals.maxSize.org, 
[10:58:40.632]                         ...future.globals.maxSize)) {
[10:58:40.632]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:40.632]                         on.exit(options(oopts), add = TRUE)
[10:58:40.632]                       }
[10:58:40.632]                       {
[10:58:40.632]                         lapply(seq_along(...future.elements_ii), 
[10:58:40.632]                           FUN = function(jj) {
[10:58:40.632]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:40.632]                             ...future.FUN(...future.X_jj, ...)
[10:58:40.632]                           })
[10:58:40.632]                       }
[10:58:40.632]                     }, args = future.call.arguments)
[10:58:40.632]                   }
[10:58:40.632]                 }, immediateCondition = function(cond) {
[10:58:40.632]                   sendCondition <- ...future.makeSendCondition()
[10:58:40.632]                   sendCondition(cond)
[10:58:40.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.632]                   {
[10:58:40.632]                     inherits <- base::inherits
[10:58:40.632]                     invokeRestart <- base::invokeRestart
[10:58:40.632]                     is.null <- base::is.null
[10:58:40.632]                     muffled <- FALSE
[10:58:40.632]                     if (inherits(cond, "message")) {
[10:58:40.632]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:40.632]                       if (muffled) 
[10:58:40.632]                         invokeRestart("muffleMessage")
[10:58:40.632]                     }
[10:58:40.632]                     else if (inherits(cond, "warning")) {
[10:58:40.632]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:40.632]                       if (muffled) 
[10:58:40.632]                         invokeRestart("muffleWarning")
[10:58:40.632]                     }
[10:58:40.632]                     else if (inherits(cond, "condition")) {
[10:58:40.632]                       if (!is.null(pattern)) {
[10:58:40.632]                         computeRestarts <- base::computeRestarts
[10:58:40.632]                         grepl <- base::grepl
[10:58:40.632]                         restarts <- computeRestarts(cond)
[10:58:40.632]                         for (restart in restarts) {
[10:58:40.632]                           name <- restart$name
[10:58:40.632]                           if (is.null(name)) 
[10:58:40.632]                             next
[10:58:40.632]                           if (!grepl(pattern, name)) 
[10:58:40.632]                             next
[10:58:40.632]                           invokeRestart(restart)
[10:58:40.632]                           muffled <- TRUE
[10:58:40.632]                           break
[10:58:40.632]                         }
[10:58:40.632]                       }
[10:58:40.632]                     }
[10:58:40.632]                     invisible(muffled)
[10:58:40.632]                   }
[10:58:40.632]                   muffleCondition(cond)
[10:58:40.632]                 })
[10:58:40.632]             }))
[10:58:40.632]             future::FutureResult(value = ...future.value$value, 
[10:58:40.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:40.632]                   ...future.rng), globalenv = if (FALSE) 
[10:58:40.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:40.632]                     ...future.globalenv.names))
[10:58:40.632]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:40.632]         }, condition = base::local({
[10:58:40.632]             c <- base::c
[10:58:40.632]             inherits <- base::inherits
[10:58:40.632]             invokeRestart <- base::invokeRestart
[10:58:40.632]             length <- base::length
[10:58:40.632]             list <- base::list
[10:58:40.632]             seq.int <- base::seq.int
[10:58:40.632]             signalCondition <- base::signalCondition
[10:58:40.632]             sys.calls <- base::sys.calls
[10:58:40.632]             `[[` <- base::`[[`
[10:58:40.632]             `+` <- base::`+`
[10:58:40.632]             `<<-` <- base::`<<-`
[10:58:40.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:40.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:40.632]                   3L)]
[10:58:40.632]             }
[10:58:40.632]             function(cond) {
[10:58:40.632]                 is_error <- inherits(cond, "error")
[10:58:40.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:40.632]                   NULL)
[10:58:40.632]                 if (is_error) {
[10:58:40.632]                   sessionInformation <- function() {
[10:58:40.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:40.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:40.632]                       search = base::search(), system = base::Sys.info())
[10:58:40.632]                   }
[10:58:40.632]                   ...future.conditions[[length(...future.conditions) + 
[10:58:40.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:40.632]                     cond$call), session = sessionInformation(), 
[10:58:40.632]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:40.632]                   signalCondition(cond)
[10:58:40.632]                 }
[10:58:40.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:40.632]                 "immediateCondition"))) {
[10:58:40.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:40.632]                   ...future.conditions[[length(...future.conditions) + 
[10:58:40.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:40.632]                   if (TRUE && !signal) {
[10:58:40.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.632]                     {
[10:58:40.632]                       inherits <- base::inherits
[10:58:40.632]                       invokeRestart <- base::invokeRestart
[10:58:40.632]                       is.null <- base::is.null
[10:58:40.632]                       muffled <- FALSE
[10:58:40.632]                       if (inherits(cond, "message")) {
[10:58:40.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:40.632]                         if (muffled) 
[10:58:40.632]                           invokeRestart("muffleMessage")
[10:58:40.632]                       }
[10:58:40.632]                       else if (inherits(cond, "warning")) {
[10:58:40.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:40.632]                         if (muffled) 
[10:58:40.632]                           invokeRestart("muffleWarning")
[10:58:40.632]                       }
[10:58:40.632]                       else if (inherits(cond, "condition")) {
[10:58:40.632]                         if (!is.null(pattern)) {
[10:58:40.632]                           computeRestarts <- base::computeRestarts
[10:58:40.632]                           grepl <- base::grepl
[10:58:40.632]                           restarts <- computeRestarts(cond)
[10:58:40.632]                           for (restart in restarts) {
[10:58:40.632]                             name <- restart$name
[10:58:40.632]                             if (is.null(name)) 
[10:58:40.632]                               next
[10:58:40.632]                             if (!grepl(pattern, name)) 
[10:58:40.632]                               next
[10:58:40.632]                             invokeRestart(restart)
[10:58:40.632]                             muffled <- TRUE
[10:58:40.632]                             break
[10:58:40.632]                           }
[10:58:40.632]                         }
[10:58:40.632]                       }
[10:58:40.632]                       invisible(muffled)
[10:58:40.632]                     }
[10:58:40.632]                     muffleCondition(cond, pattern = "^muffle")
[10:58:40.632]                   }
[10:58:40.632]                 }
[10:58:40.632]                 else {
[10:58:40.632]                   if (TRUE) {
[10:58:40.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.632]                     {
[10:58:40.632]                       inherits <- base::inherits
[10:58:40.632]                       invokeRestart <- base::invokeRestart
[10:58:40.632]                       is.null <- base::is.null
[10:58:40.632]                       muffled <- FALSE
[10:58:40.632]                       if (inherits(cond, "message")) {
[10:58:40.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:40.632]                         if (muffled) 
[10:58:40.632]                           invokeRestart("muffleMessage")
[10:58:40.632]                       }
[10:58:40.632]                       else if (inherits(cond, "warning")) {
[10:58:40.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:40.632]                         if (muffled) 
[10:58:40.632]                           invokeRestart("muffleWarning")
[10:58:40.632]                       }
[10:58:40.632]                       else if (inherits(cond, "condition")) {
[10:58:40.632]                         if (!is.null(pattern)) {
[10:58:40.632]                           computeRestarts <- base::computeRestarts
[10:58:40.632]                           grepl <- base::grepl
[10:58:40.632]                           restarts <- computeRestarts(cond)
[10:58:40.632]                           for (restart in restarts) {
[10:58:40.632]                             name <- restart$name
[10:58:40.632]                             if (is.null(name)) 
[10:58:40.632]                               next
[10:58:40.632]                             if (!grepl(pattern, name)) 
[10:58:40.632]                               next
[10:58:40.632]                             invokeRestart(restart)
[10:58:40.632]                             muffled <- TRUE
[10:58:40.632]                             break
[10:58:40.632]                           }
[10:58:40.632]                         }
[10:58:40.632]                       }
[10:58:40.632]                       invisible(muffled)
[10:58:40.632]                     }
[10:58:40.632]                     muffleCondition(cond, pattern = "^muffle")
[10:58:40.632]                   }
[10:58:40.632]                 }
[10:58:40.632]             }
[10:58:40.632]         }))
[10:58:40.632]     }, error = function(ex) {
[10:58:40.632]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:40.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:40.632]                 ...future.rng), started = ...future.startTime, 
[10:58:40.632]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:40.632]             version = "1.8"), class = "FutureResult")
[10:58:40.632]     }, finally = {
[10:58:40.632]         if (!identical(...future.workdir, getwd())) 
[10:58:40.632]             setwd(...future.workdir)
[10:58:40.632]         {
[10:58:40.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:40.632]                 ...future.oldOptions$nwarnings <- NULL
[10:58:40.632]             }
[10:58:40.632]             base::options(...future.oldOptions)
[10:58:40.632]             if (.Platform$OS.type == "windows") {
[10:58:40.632]                 old_names <- names(...future.oldEnvVars)
[10:58:40.632]                 envs <- base::Sys.getenv()
[10:58:40.632]                 names <- names(envs)
[10:58:40.632]                 common <- intersect(names, old_names)
[10:58:40.632]                 added <- setdiff(names, old_names)
[10:58:40.632]                 removed <- setdiff(old_names, names)
[10:58:40.632]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:40.632]                   envs[common]]
[10:58:40.632]                 NAMES <- toupper(changed)
[10:58:40.632]                 args <- list()
[10:58:40.632]                 for (kk in seq_along(NAMES)) {
[10:58:40.632]                   name <- changed[[kk]]
[10:58:40.632]                   NAME <- NAMES[[kk]]
[10:58:40.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.632]                     next
[10:58:40.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:40.632]                 }
[10:58:40.632]                 NAMES <- toupper(added)
[10:58:40.632]                 for (kk in seq_along(NAMES)) {
[10:58:40.632]                   name <- added[[kk]]
[10:58:40.632]                   NAME <- NAMES[[kk]]
[10:58:40.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.632]                     next
[10:58:40.632]                   args[[name]] <- ""
[10:58:40.632]                 }
[10:58:40.632]                 NAMES <- toupper(removed)
[10:58:40.632]                 for (kk in seq_along(NAMES)) {
[10:58:40.632]                   name <- removed[[kk]]
[10:58:40.632]                   NAME <- NAMES[[kk]]
[10:58:40.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.632]                     next
[10:58:40.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:40.632]                 }
[10:58:40.632]                 if (length(args) > 0) 
[10:58:40.632]                   base::do.call(base::Sys.setenv, args = args)
[10:58:40.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:40.632]             }
[10:58:40.632]             else {
[10:58:40.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:40.632]             }
[10:58:40.632]             {
[10:58:40.632]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:40.632]                   0L) {
[10:58:40.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:40.632]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:40.632]                   base::options(opts)
[10:58:40.632]                 }
[10:58:40.632]                 {
[10:58:40.632]                   {
[10:58:40.632]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:40.632]                     NULL
[10:58:40.632]                   }
[10:58:40.632]                   options(future.plan = NULL)
[10:58:40.632]                   if (is.na(NA_character_)) 
[10:58:40.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:40.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:40.632]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:40.632]                     .init = FALSE)
[10:58:40.632]                 }
[10:58:40.632]             }
[10:58:40.632]         }
[10:58:40.632]     })
[10:58:40.632]     if (TRUE) {
[10:58:40.632]         base::sink(type = "output", split = FALSE)
[10:58:40.632]         if (TRUE) {
[10:58:40.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:40.632]         }
[10:58:40.632]         else {
[10:58:40.632]             ...future.result["stdout"] <- base::list(NULL)
[10:58:40.632]         }
[10:58:40.632]         base::close(...future.stdout)
[10:58:40.632]         ...future.stdout <- NULL
[10:58:40.632]     }
[10:58:40.632]     ...future.result$conditions <- ...future.conditions
[10:58:40.632]     ...future.result$finished <- base::Sys.time()
[10:58:40.632]     ...future.result
[10:58:40.632] }
[10:58:40.635] Exporting 5 global objects (31.96 KiB) to cluster node #1 ...
[10:58:40.635] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:40.636] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:40.636] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ...
[10:58:40.677] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ... DONE
[10:58:40.677] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[10:58:40.677] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[10:58:40.678] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:40.678] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:40.678] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:40.678] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:40.678] Exporting 5 global objects (31.96 KiB) to cluster node #1 ... DONE
[10:58:40.679] MultisessionFuture started
[10:58:40.679] - Launch lazy future ... done
[10:58:40.679] run() for ‘MultisessionFuture’ ... done
[10:58:40.679] Created future:
[10:58:40.679] MultisessionFuture:
[10:58:40.679] Label: ‘future_apply-1’
[10:58:40.679] Expression:
[10:58:40.679] {
[10:58:40.679]     do.call(function(...) {
[10:58:40.679]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:40.679]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:40.679]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:40.679]             on.exit(options(oopts), add = TRUE)
[10:58:40.679]         }
[10:58:40.679]         {
[10:58:40.679]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:40.679]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:40.679]                 ...future.FUN(...future.X_jj, ...)
[10:58:40.679]             })
[10:58:40.679]         }
[10:58:40.679]     }, args = future.call.arguments)
[10:58:40.679] }
[10:58:40.679] Lazy evaluation: FALSE
[10:58:40.679] Asynchronous evaluation: TRUE
[10:58:40.679] Local evaluation: TRUE
[10:58:40.679] Environment: R_GlobalEnv
[10:58:40.679] Capture standard output: TRUE
[10:58:40.679] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:40.679] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:40.679] Packages: <none>
[10:58:40.679] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:40.679] Resolved: FALSE
[10:58:40.679] Value: <not collected>
[10:58:40.679] Conditions captured: <none>
[10:58:40.679] Early signaling: FALSE
[10:58:40.679] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:40.679] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:40.691] Chunk #1 of 2 ... DONE
[10:58:40.691] Chunk #2 of 2 ...
[10:58:40.691]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:40.691]  - seeds: <none>
[10:58:40.691]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:40.692] getGlobalsAndPackages() ...
[10:58:40.692] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:40.692] Resolving globals: FALSE
[10:58:40.692] Tweak future expression to call with '...' arguments ...
[10:58:40.692] {
[10:58:40.692]     do.call(function(...) {
[10:58:40.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:40.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:40.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:40.692]             on.exit(options(oopts), add = TRUE)
[10:58:40.692]         }
[10:58:40.692]         {
[10:58:40.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:40.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:40.692]                 ...future.FUN(...future.X_jj, ...)
[10:58:40.692]             })
[10:58:40.692]         }
[10:58:40.692]     }, args = future.call.arguments)
[10:58:40.692] }
[10:58:40.692] Tweak future expression to call with '...' arguments ... DONE
[10:58:40.693] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:40.693] 
[10:58:40.693] getGlobalsAndPackages() ... DONE
[10:58:40.693] run() for ‘Future’ ...
[10:58:40.693] - state: ‘created’
[10:58:40.693] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:40.707] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:40.707] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:40.707]   - Field: ‘node’
[10:58:40.707]   - Field: ‘label’
[10:58:40.707]   - Field: ‘local’
[10:58:40.707]   - Field: ‘owner’
[10:58:40.708]   - Field: ‘envir’
[10:58:40.708]   - Field: ‘workers’
[10:58:40.708]   - Field: ‘packages’
[10:58:40.708]   - Field: ‘gc’
[10:58:40.708]   - Field: ‘conditions’
[10:58:40.708]   - Field: ‘persistent’
[10:58:40.708]   - Field: ‘expr’
[10:58:40.708]   - Field: ‘uuid’
[10:58:40.708]   - Field: ‘seed’
[10:58:40.708]   - Field: ‘version’
[10:58:40.708]   - Field: ‘result’
[10:58:40.709]   - Field: ‘asynchronous’
[10:58:40.709]   - Field: ‘calls’
[10:58:40.709]   - Field: ‘globals’
[10:58:40.709]   - Field: ‘stdout’
[10:58:40.709]   - Field: ‘earlySignal’
[10:58:40.709]   - Field: ‘lazy’
[10:58:40.709]   - Field: ‘state’
[10:58:40.709] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:40.709] - Launch lazy future ...
[10:58:40.709] Packages needed by the future expression (n = 0): <none>
[10:58:40.710] Packages needed by future strategies (n = 0): <none>
[10:58:40.710] {
[10:58:40.710]     {
[10:58:40.710]         {
[10:58:40.710]             ...future.startTime <- base::Sys.time()
[10:58:40.710]             {
[10:58:40.710]                 {
[10:58:40.710]                   {
[10:58:40.710]                     {
[10:58:40.710]                       base::local({
[10:58:40.710]                         has_future <- base::requireNamespace("future", 
[10:58:40.710]                           quietly = TRUE)
[10:58:40.710]                         if (has_future) {
[10:58:40.710]                           ns <- base::getNamespace("future")
[10:58:40.710]                           version <- ns[[".package"]][["version"]]
[10:58:40.710]                           if (is.null(version)) 
[10:58:40.710]                             version <- utils::packageVersion("future")
[10:58:40.710]                         }
[10:58:40.710]                         else {
[10:58:40.710]                           version <- NULL
[10:58:40.710]                         }
[10:58:40.710]                         if (!has_future || version < "1.8.0") {
[10:58:40.710]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:40.710]                             "", base::R.version$version.string), 
[10:58:40.710]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:40.710]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:40.710]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:40.710]                               "release", "version")], collapse = " "), 
[10:58:40.710]                             hostname = base::Sys.info()[["nodename"]])
[10:58:40.710]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:40.710]                             info)
[10:58:40.710]                           info <- base::paste(info, collapse = "; ")
[10:58:40.710]                           if (!has_future) {
[10:58:40.710]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:40.710]                               info)
[10:58:40.710]                           }
[10:58:40.710]                           else {
[10:58:40.710]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:40.710]                               info, version)
[10:58:40.710]                           }
[10:58:40.710]                           base::stop(msg)
[10:58:40.710]                         }
[10:58:40.710]                       })
[10:58:40.710]                     }
[10:58:40.710]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:40.710]                     base::options(mc.cores = 1L)
[10:58:40.710]                   }
[10:58:40.710]                   ...future.strategy.old <- future::plan("list")
[10:58:40.710]                   options(future.plan = NULL)
[10:58:40.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:40.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:40.710]                 }
[10:58:40.710]                 ...future.workdir <- getwd()
[10:58:40.710]             }
[10:58:40.710]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:40.710]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:40.710]         }
[10:58:40.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:40.710]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:40.710]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:40.710]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:40.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:40.710]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:40.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:40.710]             base::names(...future.oldOptions))
[10:58:40.710]     }
[10:58:40.710]     if (FALSE) {
[10:58:40.710]     }
[10:58:40.710]     else {
[10:58:40.710]         if (TRUE) {
[10:58:40.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:40.710]                 open = "w")
[10:58:40.710]         }
[10:58:40.710]         else {
[10:58:40.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:40.710]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:40.710]         }
[10:58:40.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:40.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:40.710]             base::sink(type = "output", split = FALSE)
[10:58:40.710]             base::close(...future.stdout)
[10:58:40.710]         }, add = TRUE)
[10:58:40.710]     }
[10:58:40.710]     ...future.frame <- base::sys.nframe()
[10:58:40.710]     ...future.conditions <- base::list()
[10:58:40.710]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:40.710]     if (FALSE) {
[10:58:40.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:40.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:40.710]     }
[10:58:40.710]     ...future.result <- base::tryCatch({
[10:58:40.710]         base::withCallingHandlers({
[10:58:40.710]             ...future.value <- base::withVisible(base::local({
[10:58:40.710]                 ...future.makeSendCondition <- base::local({
[10:58:40.710]                   sendCondition <- NULL
[10:58:40.710]                   function(frame = 1L) {
[10:58:40.710]                     if (is.function(sendCondition)) 
[10:58:40.710]                       return(sendCondition)
[10:58:40.710]                     ns <- getNamespace("parallel")
[10:58:40.710]                     if (exists("sendData", mode = "function", 
[10:58:40.710]                       envir = ns)) {
[10:58:40.710]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:40.710]                         envir = ns)
[10:58:40.710]                       envir <- sys.frame(frame)
[10:58:40.710]                       master <- NULL
[10:58:40.710]                       while (!identical(envir, .GlobalEnv) && 
[10:58:40.710]                         !identical(envir, emptyenv())) {
[10:58:40.710]                         if (exists("master", mode = "list", envir = envir, 
[10:58:40.710]                           inherits = FALSE)) {
[10:58:40.710]                           master <- get("master", mode = "list", 
[10:58:40.710]                             envir = envir, inherits = FALSE)
[10:58:40.710]                           if (inherits(master, c("SOCKnode", 
[10:58:40.710]                             "SOCK0node"))) {
[10:58:40.710]                             sendCondition <<- function(cond) {
[10:58:40.710]                               data <- list(type = "VALUE", value = cond, 
[10:58:40.710]                                 success = TRUE)
[10:58:40.710]                               parallel_sendData(master, data)
[10:58:40.710]                             }
[10:58:40.710]                             return(sendCondition)
[10:58:40.710]                           }
[10:58:40.710]                         }
[10:58:40.710]                         frame <- frame + 1L
[10:58:40.710]                         envir <- sys.frame(frame)
[10:58:40.710]                       }
[10:58:40.710]                     }
[10:58:40.710]                     sendCondition <<- function(cond) NULL
[10:58:40.710]                   }
[10:58:40.710]                 })
[10:58:40.710]                 withCallingHandlers({
[10:58:40.710]                   {
[10:58:40.710]                     do.call(function(...) {
[10:58:40.710]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:40.710]                       if (!identical(...future.globals.maxSize.org, 
[10:58:40.710]                         ...future.globals.maxSize)) {
[10:58:40.710]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:40.710]                         on.exit(options(oopts), add = TRUE)
[10:58:40.710]                       }
[10:58:40.710]                       {
[10:58:40.710]                         lapply(seq_along(...future.elements_ii), 
[10:58:40.710]                           FUN = function(jj) {
[10:58:40.710]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:40.710]                             ...future.FUN(...future.X_jj, ...)
[10:58:40.710]                           })
[10:58:40.710]                       }
[10:58:40.710]                     }, args = future.call.arguments)
[10:58:40.710]                   }
[10:58:40.710]                 }, immediateCondition = function(cond) {
[10:58:40.710]                   sendCondition <- ...future.makeSendCondition()
[10:58:40.710]                   sendCondition(cond)
[10:58:40.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.710]                   {
[10:58:40.710]                     inherits <- base::inherits
[10:58:40.710]                     invokeRestart <- base::invokeRestart
[10:58:40.710]                     is.null <- base::is.null
[10:58:40.710]                     muffled <- FALSE
[10:58:40.710]                     if (inherits(cond, "message")) {
[10:58:40.710]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:40.710]                       if (muffled) 
[10:58:40.710]                         invokeRestart("muffleMessage")
[10:58:40.710]                     }
[10:58:40.710]                     else if (inherits(cond, "warning")) {
[10:58:40.710]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:40.710]                       if (muffled) 
[10:58:40.710]                         invokeRestart("muffleWarning")
[10:58:40.710]                     }
[10:58:40.710]                     else if (inherits(cond, "condition")) {
[10:58:40.710]                       if (!is.null(pattern)) {
[10:58:40.710]                         computeRestarts <- base::computeRestarts
[10:58:40.710]                         grepl <- base::grepl
[10:58:40.710]                         restarts <- computeRestarts(cond)
[10:58:40.710]                         for (restart in restarts) {
[10:58:40.710]                           name <- restart$name
[10:58:40.710]                           if (is.null(name)) 
[10:58:40.710]                             next
[10:58:40.710]                           if (!grepl(pattern, name)) 
[10:58:40.710]                             next
[10:58:40.710]                           invokeRestart(restart)
[10:58:40.710]                           muffled <- TRUE
[10:58:40.710]                           break
[10:58:40.710]                         }
[10:58:40.710]                       }
[10:58:40.710]                     }
[10:58:40.710]                     invisible(muffled)
[10:58:40.710]                   }
[10:58:40.710]                   muffleCondition(cond)
[10:58:40.710]                 })
[10:58:40.710]             }))
[10:58:40.710]             future::FutureResult(value = ...future.value$value, 
[10:58:40.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:40.710]                   ...future.rng), globalenv = if (FALSE) 
[10:58:40.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:40.710]                     ...future.globalenv.names))
[10:58:40.710]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:40.710]         }, condition = base::local({
[10:58:40.710]             c <- base::c
[10:58:40.710]             inherits <- base::inherits
[10:58:40.710]             invokeRestart <- base::invokeRestart
[10:58:40.710]             length <- base::length
[10:58:40.710]             list <- base::list
[10:58:40.710]             seq.int <- base::seq.int
[10:58:40.710]             signalCondition <- base::signalCondition
[10:58:40.710]             sys.calls <- base::sys.calls
[10:58:40.710]             `[[` <- base::`[[`
[10:58:40.710]             `+` <- base::`+`
[10:58:40.710]             `<<-` <- base::`<<-`
[10:58:40.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:40.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:40.710]                   3L)]
[10:58:40.710]             }
[10:58:40.710]             function(cond) {
[10:58:40.710]                 is_error <- inherits(cond, "error")
[10:58:40.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:40.710]                   NULL)
[10:58:40.710]                 if (is_error) {
[10:58:40.710]                   sessionInformation <- function() {
[10:58:40.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:40.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:40.710]                       search = base::search(), system = base::Sys.info())
[10:58:40.710]                   }
[10:58:40.710]                   ...future.conditions[[length(...future.conditions) + 
[10:58:40.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:40.710]                     cond$call), session = sessionInformation(), 
[10:58:40.710]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:40.710]                   signalCondition(cond)
[10:58:40.710]                 }
[10:58:40.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:40.710]                 "immediateCondition"))) {
[10:58:40.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:40.710]                   ...future.conditions[[length(...future.conditions) + 
[10:58:40.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:40.710]                   if (TRUE && !signal) {
[10:58:40.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.710]                     {
[10:58:40.710]                       inherits <- base::inherits
[10:58:40.710]                       invokeRestart <- base::invokeRestart
[10:58:40.710]                       is.null <- base::is.null
[10:58:40.710]                       muffled <- FALSE
[10:58:40.710]                       if (inherits(cond, "message")) {
[10:58:40.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:40.710]                         if (muffled) 
[10:58:40.710]                           invokeRestart("muffleMessage")
[10:58:40.710]                       }
[10:58:40.710]                       else if (inherits(cond, "warning")) {
[10:58:40.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:40.710]                         if (muffled) 
[10:58:40.710]                           invokeRestart("muffleWarning")
[10:58:40.710]                       }
[10:58:40.710]                       else if (inherits(cond, "condition")) {
[10:58:40.710]                         if (!is.null(pattern)) {
[10:58:40.710]                           computeRestarts <- base::computeRestarts
[10:58:40.710]                           grepl <- base::grepl
[10:58:40.710]                           restarts <- computeRestarts(cond)
[10:58:40.710]                           for (restart in restarts) {
[10:58:40.710]                             name <- restart$name
[10:58:40.710]                             if (is.null(name)) 
[10:58:40.710]                               next
[10:58:40.710]                             if (!grepl(pattern, name)) 
[10:58:40.710]                               next
[10:58:40.710]                             invokeRestart(restart)
[10:58:40.710]                             muffled <- TRUE
[10:58:40.710]                             break
[10:58:40.710]                           }
[10:58:40.710]                         }
[10:58:40.710]                       }
[10:58:40.710]                       invisible(muffled)
[10:58:40.710]                     }
[10:58:40.710]                     muffleCondition(cond, pattern = "^muffle")
[10:58:40.710]                   }
[10:58:40.710]                 }
[10:58:40.710]                 else {
[10:58:40.710]                   if (TRUE) {
[10:58:40.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.710]                     {
[10:58:40.710]                       inherits <- base::inherits
[10:58:40.710]                       invokeRestart <- base::invokeRestart
[10:58:40.710]                       is.null <- base::is.null
[10:58:40.710]                       muffled <- FALSE
[10:58:40.710]                       if (inherits(cond, "message")) {
[10:58:40.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:40.710]                         if (muffled) 
[10:58:40.710]                           invokeRestart("muffleMessage")
[10:58:40.710]                       }
[10:58:40.710]                       else if (inherits(cond, "warning")) {
[10:58:40.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:40.710]                         if (muffled) 
[10:58:40.710]                           invokeRestart("muffleWarning")
[10:58:40.710]                       }
[10:58:40.710]                       else if (inherits(cond, "condition")) {
[10:58:40.710]                         if (!is.null(pattern)) {
[10:58:40.710]                           computeRestarts <- base::computeRestarts
[10:58:40.710]                           grepl <- base::grepl
[10:58:40.710]                           restarts <- computeRestarts(cond)
[10:58:40.710]                           for (restart in restarts) {
[10:58:40.710]                             name <- restart$name
[10:58:40.710]                             if (is.null(name)) 
[10:58:40.710]                               next
[10:58:40.710]                             if (!grepl(pattern, name)) 
[10:58:40.710]                               next
[10:58:40.710]                             invokeRestart(restart)
[10:58:40.710]                             muffled <- TRUE
[10:58:40.710]                             break
[10:58:40.710]                           }
[10:58:40.710]                         }
[10:58:40.710]                       }
[10:58:40.710]                       invisible(muffled)
[10:58:40.710]                     }
[10:58:40.710]                     muffleCondition(cond, pattern = "^muffle")
[10:58:40.710]                   }
[10:58:40.710]                 }
[10:58:40.710]             }
[10:58:40.710]         }))
[10:58:40.710]     }, error = function(ex) {
[10:58:40.710]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:40.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:40.710]                 ...future.rng), started = ...future.startTime, 
[10:58:40.710]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:40.710]             version = "1.8"), class = "FutureResult")
[10:58:40.710]     }, finally = {
[10:58:40.710]         if (!identical(...future.workdir, getwd())) 
[10:58:40.710]             setwd(...future.workdir)
[10:58:40.710]         {
[10:58:40.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:40.710]                 ...future.oldOptions$nwarnings <- NULL
[10:58:40.710]             }
[10:58:40.710]             base::options(...future.oldOptions)
[10:58:40.710]             if (.Platform$OS.type == "windows") {
[10:58:40.710]                 old_names <- names(...future.oldEnvVars)
[10:58:40.710]                 envs <- base::Sys.getenv()
[10:58:40.710]                 names <- names(envs)
[10:58:40.710]                 common <- intersect(names, old_names)
[10:58:40.710]                 added <- setdiff(names, old_names)
[10:58:40.710]                 removed <- setdiff(old_names, names)
[10:58:40.710]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:40.710]                   envs[common]]
[10:58:40.710]                 NAMES <- toupper(changed)
[10:58:40.710]                 args <- list()
[10:58:40.710]                 for (kk in seq_along(NAMES)) {
[10:58:40.710]                   name <- changed[[kk]]
[10:58:40.710]                   NAME <- NAMES[[kk]]
[10:58:40.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.710]                     next
[10:58:40.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:40.710]                 }
[10:58:40.710]                 NAMES <- toupper(added)
[10:58:40.710]                 for (kk in seq_along(NAMES)) {
[10:58:40.710]                   name <- added[[kk]]
[10:58:40.710]                   NAME <- NAMES[[kk]]
[10:58:40.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.710]                     next
[10:58:40.710]                   args[[name]] <- ""
[10:58:40.710]                 }
[10:58:40.710]                 NAMES <- toupper(removed)
[10:58:40.710]                 for (kk in seq_along(NAMES)) {
[10:58:40.710]                   name <- removed[[kk]]
[10:58:40.710]                   NAME <- NAMES[[kk]]
[10:58:40.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.710]                     next
[10:58:40.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:40.710]                 }
[10:58:40.710]                 if (length(args) > 0) 
[10:58:40.710]                   base::do.call(base::Sys.setenv, args = args)
[10:58:40.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:40.710]             }
[10:58:40.710]             else {
[10:58:40.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:40.710]             }
[10:58:40.710]             {
[10:58:40.710]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:40.710]                   0L) {
[10:58:40.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:40.710]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:40.710]                   base::options(opts)
[10:58:40.710]                 }
[10:58:40.710]                 {
[10:58:40.710]                   {
[10:58:40.710]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:40.710]                     NULL
[10:58:40.710]                   }
[10:58:40.710]                   options(future.plan = NULL)
[10:58:40.710]                   if (is.na(NA_character_)) 
[10:58:40.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:40.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:40.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:40.710]                     .init = FALSE)
[10:58:40.710]                 }
[10:58:40.710]             }
[10:58:40.710]         }
[10:58:40.710]     })
[10:58:40.710]     if (TRUE) {
[10:58:40.710]         base::sink(type = "output", split = FALSE)
[10:58:40.710]         if (TRUE) {
[10:58:40.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:40.710]         }
[10:58:40.710]         else {
[10:58:40.710]             ...future.result["stdout"] <- base::list(NULL)
[10:58:40.710]         }
[10:58:40.710]         base::close(...future.stdout)
[10:58:40.710]         ...future.stdout <- NULL
[10:58:40.710]     }
[10:58:40.710]     ...future.result$conditions <- ...future.conditions
[10:58:40.710]     ...future.result$finished <- base::Sys.time()
[10:58:40.710]     ...future.result
[10:58:40.710] }
[10:58:40.761] Exporting 5 global objects (31.96 KiB) to cluster node #2 ...
[10:58:40.761] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:40.762] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:40.762] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ...
[10:58:40.804] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ... DONE
[10:58:40.804] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[10:58:40.804] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[10:58:40.804] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:40.805] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:40.805] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:40.805] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:40.805] Exporting 5 global objects (31.96 KiB) to cluster node #2 ... DONE
[10:58:40.806] MultisessionFuture started
[10:58:40.806] - Launch lazy future ... done
[10:58:40.806] run() for ‘MultisessionFuture’ ... done
[10:58:40.806] Created future:
[10:58:40.806] MultisessionFuture:
[10:58:40.806] Label: ‘future_apply-2’
[10:58:40.806] Expression:
[10:58:40.806] {
[10:58:40.806]     do.call(function(...) {
[10:58:40.806]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:40.806]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:40.806]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:40.806]             on.exit(options(oopts), add = TRUE)
[10:58:40.806]         }
[10:58:40.806]         {
[10:58:40.806]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:40.806]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:40.806]                 ...future.FUN(...future.X_jj, ...)
[10:58:40.806]             })
[10:58:40.806]         }
[10:58:40.806]     }, args = future.call.arguments)
[10:58:40.806] }
[10:58:40.806] Lazy evaluation: FALSE
[10:58:40.806] Asynchronous evaluation: TRUE
[10:58:40.806] Local evaluation: TRUE
[10:58:40.806] Environment: R_GlobalEnv
[10:58:40.806] Capture standard output: TRUE
[10:58:40.806] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:40.806] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:40.806] Packages: <none>
[10:58:40.806] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:40.806] Resolved: FALSE
[10:58:40.806] Value: <not collected>
[10:58:40.806] Conditions captured: <none>
[10:58:40.806] Early signaling: FALSE
[10:58:40.806] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:40.806] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:40.818] Chunk #2 of 2 ... DONE
[10:58:40.818] Launching 2 futures (chunks) ... DONE
[10:58:40.818] Resolving 2 futures (chunks) ...
[10:58:40.819] resolve() on list ...
[10:58:40.819]  recursive: 0
[10:58:40.819]  length: 2
[10:58:40.819] 
[10:58:40.819] receiveMessageFromWorker() for ClusterFuture ...
[10:58:40.819] - Validating connection of MultisessionFuture
[10:58:40.820] - received message: FutureResult
[10:58:40.820] - Received FutureResult
[10:58:40.820] - Erased future from FutureRegistry
[10:58:40.820] result() for ClusterFuture ...
[10:58:40.820] - result already collected: FutureResult
[10:58:40.820] result() for ClusterFuture ... done
[10:58:40.820] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:40.820] Future #1
[10:58:40.820] result() for ClusterFuture ...
[10:58:40.820] - result already collected: FutureResult
[10:58:40.820] result() for ClusterFuture ... done
[10:58:40.821] result() for ClusterFuture ...
[10:58:40.821] - result already collected: FutureResult
[10:58:40.821] result() for ClusterFuture ... done
[10:58:40.821] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:40.821] - nx: 2
[10:58:40.821] - relay: TRUE
[10:58:40.821] - stdout: TRUE
[10:58:40.821] - signal: TRUE
[10:58:40.821] - resignal: FALSE
[10:58:40.821] - force: TRUE
[10:58:40.821] - relayed: [n=2] FALSE, FALSE
[10:58:40.821] - queued futures: [n=2] FALSE, FALSE
[10:58:40.822]  - until=1
[10:58:40.822]  - relaying element #1
[10:58:40.822] result() for ClusterFuture ...
[10:58:40.822] - result already collected: FutureResult
[10:58:40.822] result() for ClusterFuture ... done
[10:58:40.822] result() for ClusterFuture ...
[10:58:40.822] - result already collected: FutureResult
[10:58:40.822] result() for ClusterFuture ... done
[10:58:40.822] result() for ClusterFuture ...
[10:58:40.822] - result already collected: FutureResult
[10:58:40.822] result() for ClusterFuture ... done
[10:58:40.822] result() for ClusterFuture ...
[10:58:40.823] - result already collected: FutureResult
[10:58:40.823] result() for ClusterFuture ... done
[10:58:40.823] - relayed: [n=2] TRUE, FALSE
[10:58:40.823] - queued futures: [n=2] TRUE, FALSE
[10:58:40.823] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:40.823]  length: 1 (resolved future 1)
[10:58:40.885] receiveMessageFromWorker() for ClusterFuture ...
[10:58:40.886] - Validating connection of MultisessionFuture
[10:58:40.886] - received message: FutureResult
[10:58:40.886] - Received FutureResult
[10:58:40.886] - Erased future from FutureRegistry
[10:58:40.886] result() for ClusterFuture ...
[10:58:40.886] - result already collected: FutureResult
[10:58:40.886] result() for ClusterFuture ... done
[10:58:40.886] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:40.887] Future #2
[10:58:40.887] result() for ClusterFuture ...
[10:58:40.887] - result already collected: FutureResult
[10:58:40.887] result() for ClusterFuture ... done
[10:58:40.887] result() for ClusterFuture ...
[10:58:40.887] - result already collected: FutureResult
[10:58:40.887] result() for ClusterFuture ... done
[10:58:40.887] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:40.887] - nx: 2
[10:58:40.887] - relay: TRUE
[10:58:40.887] - stdout: TRUE
[10:58:40.887] - signal: TRUE
[10:58:40.887] - resignal: FALSE
[10:58:40.888] - force: TRUE
[10:58:40.888] - relayed: [n=2] TRUE, FALSE
[10:58:40.888] - queued futures: [n=2] TRUE, FALSE
[10:58:40.888]  - until=2
[10:58:40.888]  - relaying element #2
[10:58:40.888] result() for ClusterFuture ...
[10:58:40.888] - result already collected: FutureResult
[10:58:40.888] result() for ClusterFuture ... done
[10:58:40.888] result() for ClusterFuture ...
[10:58:40.888] - result already collected: FutureResult
[10:58:40.888] result() for ClusterFuture ... done
[10:58:40.889] result() for ClusterFuture ...
[10:58:40.889] - result already collected: FutureResult
[10:58:40.889] result() for ClusterFuture ... done
[10:58:40.889] result() for ClusterFuture ...
[10:58:40.889] - result already collected: FutureResult
[10:58:40.889] result() for ClusterFuture ... done
[10:58:40.889] - relayed: [n=2] TRUE, TRUE
[10:58:40.889] - queued futures: [n=2] TRUE, TRUE
[10:58:40.889] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:40.889]  length: 0 (resolved future 2)
[10:58:40.889] Relaying remaining futures
[10:58:40.889] signalConditionsASAP(NULL, pos=0) ...
[10:58:40.890] - nx: 2
[10:58:40.890] - relay: TRUE
[10:58:40.890] - stdout: TRUE
[10:58:40.890] - signal: TRUE
[10:58:40.890] - resignal: FALSE
[10:58:40.890] - force: TRUE
[10:58:40.890] - relayed: [n=2] TRUE, TRUE
[10:58:40.890] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:40.890] - relayed: [n=2] TRUE, TRUE
[10:58:40.890] - queued futures: [n=2] TRUE, TRUE
[10:58:40.890] signalConditionsASAP(NULL, pos=0) ... done
[10:58:40.890] resolve() on list ... DONE
[10:58:40.891] result() for ClusterFuture ...
[10:58:40.891] - result already collected: FutureResult
[10:58:40.891] result() for ClusterFuture ... done
[10:58:40.891] result() for ClusterFuture ...
[10:58:40.891] - result already collected: FutureResult
[10:58:40.891] result() for ClusterFuture ... done
[10:58:40.891] result() for ClusterFuture ...
[10:58:40.891] - result already collected: FutureResult
[10:58:40.891] result() for ClusterFuture ... done
[10:58:40.891] result() for ClusterFuture ...
[10:58:40.891] - result already collected: FutureResult
[10:58:40.892] result() for ClusterFuture ... done
[10:58:40.892]  - Number of value chunks collected: 2
[10:58:40.892] Resolving 2 futures (chunks) ... DONE
[10:58:40.892] Reducing values from 2 chunks ...
[10:58:40.892]  - Number of values collected after concatenation: 2
[10:58:40.892]  - Number of values expected: 2
[10:58:40.892] Reducing values from 2 chunks ... DONE
[10:58:40.892] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:58:40.893] getGlobalsAndPackagesXApply() ...
[10:58:40.893]  - future.globals: TRUE
[10:58:40.893] getGlobalsAndPackages() ...
[10:58:40.893] Searching for globals...
[10:58:40.926] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:58:40.927] Searching for globals ... DONE
[10:58:40.927] Resolving globals: FALSE
[10:58:40.928] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:58:40.929] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:58:40.929] - globals: [1] ‘FUN’
[10:58:40.929] 
[10:58:40.929] getGlobalsAndPackages() ... DONE
[10:58:40.929]  - globals found/used: [n=1] ‘FUN’
[10:58:40.929]  - needed namespaces: [n=0] 
[10:58:40.929] Finding globals ... DONE
[10:58:40.930]  - use_args: TRUE
[10:58:40.930]  - Getting '...' globals ...
[10:58:40.930] resolve() on list ...
[10:58:40.930]  recursive: 0
[10:58:40.930]  length: 1
[10:58:40.930]  elements: ‘...’
[10:58:40.930]  length: 0 (resolved future 1)
[10:58:40.930] resolve() on list ... DONE
[10:58:40.930]    - '...' content: [n=0] 
[10:58:40.931] List of 1
[10:58:40.931]  $ ...: list()
[10:58:40.931]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:40.931]  - attr(*, "where")=List of 1
[10:58:40.931]   ..$ ...:<environment: 0x5635c17fc650> 
[10:58:40.931]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:40.931]  - attr(*, "resolved")= logi TRUE
[10:58:40.931]  - attr(*, "total_size")= num NA
[10:58:40.933]  - Getting '...' globals ... DONE
[10:58:40.933] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:40.933] List of 2
[10:58:40.933]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:40.933]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:40.933]  $ ...          : list()
[10:58:40.933]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:40.933]  - attr(*, "where")=List of 2
[10:58:40.933]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:40.933]   ..$ ...          :<environment: 0x5635c17fc650> 
[10:58:40.933]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:40.933]  - attr(*, "resolved")= logi FALSE
[10:58:40.933]  - attr(*, "total_size")= num 65967
[10:58:40.936] Packages to be attached in all futures: [n=0] 
[10:58:40.936] getGlobalsAndPackagesXApply() ... DONE
[10:58:40.938] future_lapply() ...
[10:58:40.970] Number of chunks: 2
[10:58:40.970] getGlobalsAndPackagesXApply() ...
[10:58:40.970]  - future.globals: <name-value list> with names ‘list()’
[10:58:40.970]  - use_args: TRUE
[10:58:40.970] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:40.970] List of 2
[10:58:40.970]  $ ...          : list()
[10:58:40.970]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:40.970]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:58:40.970]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:58:40.970]  - attr(*, "where")=List of 2
[10:58:40.970]   ..$ ...          :<environment: 0x5635c17fc650> 
[10:58:40.970]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:40.970]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:40.970]  - attr(*, "resolved")= logi FALSE
[10:58:40.970]  - attr(*, "total_size")= num NA
[10:58:40.973] Packages to be attached in all futures: [n=0] 
[10:58:40.974] getGlobalsAndPackagesXApply() ... DONE
[10:58:40.974] Number of futures (= number of chunks): 2
[10:58:40.974] Launching 2 futures (chunks) ...
[10:58:40.974] Chunk #1 of 2 ...
[10:58:40.974]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:40.974]  - seeds: <none>
[10:58:40.974]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:40.974] getGlobalsAndPackages() ...
[10:58:40.974] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:40.975] Resolving globals: FALSE
[10:58:40.975] Tweak future expression to call with '...' arguments ...
[10:58:40.975] {
[10:58:40.975]     do.call(function(...) {
[10:58:40.975]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:40.975]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:40.975]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:40.975]             on.exit(options(oopts), add = TRUE)
[10:58:40.975]         }
[10:58:40.975]         {
[10:58:40.975]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:40.975]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:40.975]                 ...future.FUN(...future.X_jj, ...)
[10:58:40.975]             })
[10:58:40.975]         }
[10:58:40.975]     }, args = future.call.arguments)
[10:58:40.975] }
[10:58:40.975] Tweak future expression to call with '...' arguments ... DONE
[10:58:40.975] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:40.976] 
[10:58:40.976] getGlobalsAndPackages() ... DONE
[10:58:40.976] run() for ‘Future’ ...
[10:58:40.976] - state: ‘created’
[10:58:40.976] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:40.990] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:40.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:40.991]   - Field: ‘node’
[10:58:40.991]   - Field: ‘label’
[10:58:40.991]   - Field: ‘local’
[10:58:40.991]   - Field: ‘owner’
[10:58:40.991]   - Field: ‘envir’
[10:58:40.991]   - Field: ‘workers’
[10:58:40.991]   - Field: ‘packages’
[10:58:40.991]   - Field: ‘gc’
[10:58:40.991]   - Field: ‘conditions’
[10:58:40.991]   - Field: ‘persistent’
[10:58:40.992]   - Field: ‘expr’
[10:58:40.992]   - Field: ‘uuid’
[10:58:40.992]   - Field: ‘seed’
[10:58:40.992]   - Field: ‘version’
[10:58:40.992]   - Field: ‘result’
[10:58:40.992]   - Field: ‘asynchronous’
[10:58:40.992]   - Field: ‘calls’
[10:58:40.992]   - Field: ‘globals’
[10:58:40.992]   - Field: ‘stdout’
[10:58:40.992]   - Field: ‘earlySignal’
[10:58:40.992]   - Field: ‘lazy’
[10:58:40.992]   - Field: ‘state’
[10:58:40.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:40.993] - Launch lazy future ...
[10:58:40.993] Packages needed by the future expression (n = 0): <none>
[10:58:40.993] Packages needed by future strategies (n = 0): <none>
[10:58:40.993] {
[10:58:40.993]     {
[10:58:40.993]         {
[10:58:40.993]             ...future.startTime <- base::Sys.time()
[10:58:40.993]             {
[10:58:40.993]                 {
[10:58:40.993]                   {
[10:58:40.993]                     {
[10:58:40.993]                       base::local({
[10:58:40.993]                         has_future <- base::requireNamespace("future", 
[10:58:40.993]                           quietly = TRUE)
[10:58:40.993]                         if (has_future) {
[10:58:40.993]                           ns <- base::getNamespace("future")
[10:58:40.993]                           version <- ns[[".package"]][["version"]]
[10:58:40.993]                           if (is.null(version)) 
[10:58:40.993]                             version <- utils::packageVersion("future")
[10:58:40.993]                         }
[10:58:40.993]                         else {
[10:58:40.993]                           version <- NULL
[10:58:40.993]                         }
[10:58:40.993]                         if (!has_future || version < "1.8.0") {
[10:58:40.993]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:40.993]                             "", base::R.version$version.string), 
[10:58:40.993]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:40.993]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:40.993]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:40.993]                               "release", "version")], collapse = " "), 
[10:58:40.993]                             hostname = base::Sys.info()[["nodename"]])
[10:58:40.993]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:40.993]                             info)
[10:58:40.993]                           info <- base::paste(info, collapse = "; ")
[10:58:40.993]                           if (!has_future) {
[10:58:40.993]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:40.993]                               info)
[10:58:40.993]                           }
[10:58:40.993]                           else {
[10:58:40.993]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:40.993]                               info, version)
[10:58:40.993]                           }
[10:58:40.993]                           base::stop(msg)
[10:58:40.993]                         }
[10:58:40.993]                       })
[10:58:40.993]                     }
[10:58:40.993]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:40.993]                     base::options(mc.cores = 1L)
[10:58:40.993]                   }
[10:58:40.993]                   ...future.strategy.old <- future::plan("list")
[10:58:40.993]                   options(future.plan = NULL)
[10:58:40.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:40.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:40.993]                 }
[10:58:40.993]                 ...future.workdir <- getwd()
[10:58:40.993]             }
[10:58:40.993]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:40.993]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:40.993]         }
[10:58:40.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:40.993]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:40.993]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:40.993]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:40.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:40.993]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:40.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:40.993]             base::names(...future.oldOptions))
[10:58:40.993]     }
[10:58:40.993]     if (FALSE) {
[10:58:40.993]     }
[10:58:40.993]     else {
[10:58:40.993]         if (TRUE) {
[10:58:40.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:40.993]                 open = "w")
[10:58:40.993]         }
[10:58:40.993]         else {
[10:58:40.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:40.993]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:40.993]         }
[10:58:40.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:40.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:40.993]             base::sink(type = "output", split = FALSE)
[10:58:40.993]             base::close(...future.stdout)
[10:58:40.993]         }, add = TRUE)
[10:58:40.993]     }
[10:58:40.993]     ...future.frame <- base::sys.nframe()
[10:58:40.993]     ...future.conditions <- base::list()
[10:58:40.993]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:40.993]     if (FALSE) {
[10:58:40.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:40.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:40.993]     }
[10:58:40.993]     ...future.result <- base::tryCatch({
[10:58:40.993]         base::withCallingHandlers({
[10:58:40.993]             ...future.value <- base::withVisible(base::local({
[10:58:40.993]                 ...future.makeSendCondition <- base::local({
[10:58:40.993]                   sendCondition <- NULL
[10:58:40.993]                   function(frame = 1L) {
[10:58:40.993]                     if (is.function(sendCondition)) 
[10:58:40.993]                       return(sendCondition)
[10:58:40.993]                     ns <- getNamespace("parallel")
[10:58:40.993]                     if (exists("sendData", mode = "function", 
[10:58:40.993]                       envir = ns)) {
[10:58:40.993]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:40.993]                         envir = ns)
[10:58:40.993]                       envir <- sys.frame(frame)
[10:58:40.993]                       master <- NULL
[10:58:40.993]                       while (!identical(envir, .GlobalEnv) && 
[10:58:40.993]                         !identical(envir, emptyenv())) {
[10:58:40.993]                         if (exists("master", mode = "list", envir = envir, 
[10:58:40.993]                           inherits = FALSE)) {
[10:58:40.993]                           master <- get("master", mode = "list", 
[10:58:40.993]                             envir = envir, inherits = FALSE)
[10:58:40.993]                           if (inherits(master, c("SOCKnode", 
[10:58:40.993]                             "SOCK0node"))) {
[10:58:40.993]                             sendCondition <<- function(cond) {
[10:58:40.993]                               data <- list(type = "VALUE", value = cond, 
[10:58:40.993]                                 success = TRUE)
[10:58:40.993]                               parallel_sendData(master, data)
[10:58:40.993]                             }
[10:58:40.993]                             return(sendCondition)
[10:58:40.993]                           }
[10:58:40.993]                         }
[10:58:40.993]                         frame <- frame + 1L
[10:58:40.993]                         envir <- sys.frame(frame)
[10:58:40.993]                       }
[10:58:40.993]                     }
[10:58:40.993]                     sendCondition <<- function(cond) NULL
[10:58:40.993]                   }
[10:58:40.993]                 })
[10:58:40.993]                 withCallingHandlers({
[10:58:40.993]                   {
[10:58:40.993]                     do.call(function(...) {
[10:58:40.993]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:40.993]                       if (!identical(...future.globals.maxSize.org, 
[10:58:40.993]                         ...future.globals.maxSize)) {
[10:58:40.993]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:40.993]                         on.exit(options(oopts), add = TRUE)
[10:58:40.993]                       }
[10:58:40.993]                       {
[10:58:40.993]                         lapply(seq_along(...future.elements_ii), 
[10:58:40.993]                           FUN = function(jj) {
[10:58:40.993]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:40.993]                             ...future.FUN(...future.X_jj, ...)
[10:58:40.993]                           })
[10:58:40.993]                       }
[10:58:40.993]                     }, args = future.call.arguments)
[10:58:40.993]                   }
[10:58:40.993]                 }, immediateCondition = function(cond) {
[10:58:40.993]                   sendCondition <- ...future.makeSendCondition()
[10:58:40.993]                   sendCondition(cond)
[10:58:40.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.993]                   {
[10:58:40.993]                     inherits <- base::inherits
[10:58:40.993]                     invokeRestart <- base::invokeRestart
[10:58:40.993]                     is.null <- base::is.null
[10:58:40.993]                     muffled <- FALSE
[10:58:40.993]                     if (inherits(cond, "message")) {
[10:58:40.993]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:40.993]                       if (muffled) 
[10:58:40.993]                         invokeRestart("muffleMessage")
[10:58:40.993]                     }
[10:58:40.993]                     else if (inherits(cond, "warning")) {
[10:58:40.993]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:40.993]                       if (muffled) 
[10:58:40.993]                         invokeRestart("muffleWarning")
[10:58:40.993]                     }
[10:58:40.993]                     else if (inherits(cond, "condition")) {
[10:58:40.993]                       if (!is.null(pattern)) {
[10:58:40.993]                         computeRestarts <- base::computeRestarts
[10:58:40.993]                         grepl <- base::grepl
[10:58:40.993]                         restarts <- computeRestarts(cond)
[10:58:40.993]                         for (restart in restarts) {
[10:58:40.993]                           name <- restart$name
[10:58:40.993]                           if (is.null(name)) 
[10:58:40.993]                             next
[10:58:40.993]                           if (!grepl(pattern, name)) 
[10:58:40.993]                             next
[10:58:40.993]                           invokeRestart(restart)
[10:58:40.993]                           muffled <- TRUE
[10:58:40.993]                           break
[10:58:40.993]                         }
[10:58:40.993]                       }
[10:58:40.993]                     }
[10:58:40.993]                     invisible(muffled)
[10:58:40.993]                   }
[10:58:40.993]                   muffleCondition(cond)
[10:58:40.993]                 })
[10:58:40.993]             }))
[10:58:40.993]             future::FutureResult(value = ...future.value$value, 
[10:58:40.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:40.993]                   ...future.rng), globalenv = if (FALSE) 
[10:58:40.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:40.993]                     ...future.globalenv.names))
[10:58:40.993]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:40.993]         }, condition = base::local({
[10:58:40.993]             c <- base::c
[10:58:40.993]             inherits <- base::inherits
[10:58:40.993]             invokeRestart <- base::invokeRestart
[10:58:40.993]             length <- base::length
[10:58:40.993]             list <- base::list
[10:58:40.993]             seq.int <- base::seq.int
[10:58:40.993]             signalCondition <- base::signalCondition
[10:58:40.993]             sys.calls <- base::sys.calls
[10:58:40.993]             `[[` <- base::`[[`
[10:58:40.993]             `+` <- base::`+`
[10:58:40.993]             `<<-` <- base::`<<-`
[10:58:40.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:40.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:40.993]                   3L)]
[10:58:40.993]             }
[10:58:40.993]             function(cond) {
[10:58:40.993]                 is_error <- inherits(cond, "error")
[10:58:40.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:40.993]                   NULL)
[10:58:40.993]                 if (is_error) {
[10:58:40.993]                   sessionInformation <- function() {
[10:58:40.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:40.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:40.993]                       search = base::search(), system = base::Sys.info())
[10:58:40.993]                   }
[10:58:40.993]                   ...future.conditions[[length(...future.conditions) + 
[10:58:40.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:40.993]                     cond$call), session = sessionInformation(), 
[10:58:40.993]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:40.993]                   signalCondition(cond)
[10:58:40.993]                 }
[10:58:40.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:40.993]                 "immediateCondition"))) {
[10:58:40.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:40.993]                   ...future.conditions[[length(...future.conditions) + 
[10:58:40.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:40.993]                   if (TRUE && !signal) {
[10:58:40.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.993]                     {
[10:58:40.993]                       inherits <- base::inherits
[10:58:40.993]                       invokeRestart <- base::invokeRestart
[10:58:40.993]                       is.null <- base::is.null
[10:58:40.993]                       muffled <- FALSE
[10:58:40.993]                       if (inherits(cond, "message")) {
[10:58:40.993]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:40.993]                         if (muffled) 
[10:58:40.993]                           invokeRestart("muffleMessage")
[10:58:40.993]                       }
[10:58:40.993]                       else if (inherits(cond, "warning")) {
[10:58:40.993]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:40.993]                         if (muffled) 
[10:58:40.993]                           invokeRestart("muffleWarning")
[10:58:40.993]                       }
[10:58:40.993]                       else if (inherits(cond, "condition")) {
[10:58:40.993]                         if (!is.null(pattern)) {
[10:58:40.993]                           computeRestarts <- base::computeRestarts
[10:58:40.993]                           grepl <- base::grepl
[10:58:40.993]                           restarts <- computeRestarts(cond)
[10:58:40.993]                           for (restart in restarts) {
[10:58:40.993]                             name <- restart$name
[10:58:40.993]                             if (is.null(name)) 
[10:58:40.993]                               next
[10:58:40.993]                             if (!grepl(pattern, name)) 
[10:58:40.993]                               next
[10:58:40.993]                             invokeRestart(restart)
[10:58:40.993]                             muffled <- TRUE
[10:58:40.993]                             break
[10:58:40.993]                           }
[10:58:40.993]                         }
[10:58:40.993]                       }
[10:58:40.993]                       invisible(muffled)
[10:58:40.993]                     }
[10:58:40.993]                     muffleCondition(cond, pattern = "^muffle")
[10:58:40.993]                   }
[10:58:40.993]                 }
[10:58:40.993]                 else {
[10:58:40.993]                   if (TRUE) {
[10:58:40.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:40.993]                     {
[10:58:40.993]                       inherits <- base::inherits
[10:58:40.993]                       invokeRestart <- base::invokeRestart
[10:58:40.993]                       is.null <- base::is.null
[10:58:40.993]                       muffled <- FALSE
[10:58:40.993]                       if (inherits(cond, "message")) {
[10:58:40.993]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:40.993]                         if (muffled) 
[10:58:40.993]                           invokeRestart("muffleMessage")
[10:58:40.993]                       }
[10:58:40.993]                       else if (inherits(cond, "warning")) {
[10:58:40.993]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:40.993]                         if (muffled) 
[10:58:40.993]                           invokeRestart("muffleWarning")
[10:58:40.993]                       }
[10:58:40.993]                       else if (inherits(cond, "condition")) {
[10:58:40.993]                         if (!is.null(pattern)) {
[10:58:40.993]                           computeRestarts <- base::computeRestarts
[10:58:40.993]                           grepl <- base::grepl
[10:58:40.993]                           restarts <- computeRestarts(cond)
[10:58:40.993]                           for (restart in restarts) {
[10:58:40.993]                             name <- restart$name
[10:58:40.993]                             if (is.null(name)) 
[10:58:40.993]                               next
[10:58:40.993]                             if (!grepl(pattern, name)) 
[10:58:40.993]                               next
[10:58:40.993]                             invokeRestart(restart)
[10:58:40.993]                             muffled <- TRUE
[10:58:40.993]                             break
[10:58:40.993]                           }
[10:58:40.993]                         }
[10:58:40.993]                       }
[10:58:40.993]                       invisible(muffled)
[10:58:40.993]                     }
[10:58:40.993]                     muffleCondition(cond, pattern = "^muffle")
[10:58:40.993]                   }
[10:58:40.993]                 }
[10:58:40.993]             }
[10:58:40.993]         }))
[10:58:40.993]     }, error = function(ex) {
[10:58:40.993]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:40.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:40.993]                 ...future.rng), started = ...future.startTime, 
[10:58:40.993]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:40.993]             version = "1.8"), class = "FutureResult")
[10:58:40.993]     }, finally = {
[10:58:40.993]         if (!identical(...future.workdir, getwd())) 
[10:58:40.993]             setwd(...future.workdir)
[10:58:40.993]         {
[10:58:40.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:40.993]                 ...future.oldOptions$nwarnings <- NULL
[10:58:40.993]             }
[10:58:40.993]             base::options(...future.oldOptions)
[10:58:40.993]             if (.Platform$OS.type == "windows") {
[10:58:40.993]                 old_names <- names(...future.oldEnvVars)
[10:58:40.993]                 envs <- base::Sys.getenv()
[10:58:40.993]                 names <- names(envs)
[10:58:40.993]                 common <- intersect(names, old_names)
[10:58:40.993]                 added <- setdiff(names, old_names)
[10:58:40.993]                 removed <- setdiff(old_names, names)
[10:58:40.993]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:40.993]                   envs[common]]
[10:58:40.993]                 NAMES <- toupper(changed)
[10:58:40.993]                 args <- list()
[10:58:40.993]                 for (kk in seq_along(NAMES)) {
[10:58:40.993]                   name <- changed[[kk]]
[10:58:40.993]                   NAME <- NAMES[[kk]]
[10:58:40.993]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.993]                     next
[10:58:40.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:40.993]                 }
[10:58:40.993]                 NAMES <- toupper(added)
[10:58:40.993]                 for (kk in seq_along(NAMES)) {
[10:58:40.993]                   name <- added[[kk]]
[10:58:40.993]                   NAME <- NAMES[[kk]]
[10:58:40.993]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.993]                     next
[10:58:40.993]                   args[[name]] <- ""
[10:58:40.993]                 }
[10:58:40.993]                 NAMES <- toupper(removed)
[10:58:40.993]                 for (kk in seq_along(NAMES)) {
[10:58:40.993]                   name <- removed[[kk]]
[10:58:40.993]                   NAME <- NAMES[[kk]]
[10:58:40.993]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:40.993]                     next
[10:58:40.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:40.993]                 }
[10:58:40.993]                 if (length(args) > 0) 
[10:58:40.993]                   base::do.call(base::Sys.setenv, args = args)
[10:58:40.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:40.993]             }
[10:58:40.993]             else {
[10:58:40.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:40.993]             }
[10:58:40.993]             {
[10:58:40.993]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:40.993]                   0L) {
[10:58:40.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:40.993]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:40.993]                   base::options(opts)
[10:58:40.993]                 }
[10:58:40.993]                 {
[10:58:40.993]                   {
[10:58:40.993]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:40.993]                     NULL
[10:58:40.993]                   }
[10:58:40.993]                   options(future.plan = NULL)
[10:58:40.993]                   if (is.na(NA_character_)) 
[10:58:40.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:40.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:40.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:40.993]                     .init = FALSE)
[10:58:40.993]                 }
[10:58:40.993]             }
[10:58:40.993]         }
[10:58:40.993]     })
[10:58:40.993]     if (TRUE) {
[10:58:40.993]         base::sink(type = "output", split = FALSE)
[10:58:40.993]         if (TRUE) {
[10:58:40.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:40.993]         }
[10:58:40.993]         else {
[10:58:40.993]             ...future.result["stdout"] <- base::list(NULL)
[10:58:40.993]         }
[10:58:40.993]         base::close(...future.stdout)
[10:58:40.993]         ...future.stdout <- NULL
[10:58:40.993]     }
[10:58:40.993]     ...future.result$conditions <- ...future.conditions
[10:58:40.993]     ...future.result$finished <- base::Sys.time()
[10:58:40.993]     ...future.result
[10:58:40.993] }
[10:58:40.996] Exporting 5 global objects (31.96 KiB) to cluster node #1 ...
[10:58:40.997] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:40.997] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:40.997] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ...
[10:58:41.039] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ... DONE
[10:58:41.039] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[10:58:41.039] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[10:58:41.039] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:41.040] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:41.040] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:41.040] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:41.040] Exporting 5 global objects (31.96 KiB) to cluster node #1 ... DONE
[10:58:41.041] MultisessionFuture started
[10:58:41.041] - Launch lazy future ... done
[10:58:41.041] run() for ‘MultisessionFuture’ ... done
[10:58:41.041] Created future:
[10:58:41.041] MultisessionFuture:
[10:58:41.041] Label: ‘future_apply-1’
[10:58:41.041] Expression:
[10:58:41.041] {
[10:58:41.041]     do.call(function(...) {
[10:58:41.041]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.041]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.041]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.041]             on.exit(options(oopts), add = TRUE)
[10:58:41.041]         }
[10:58:41.041]         {
[10:58:41.041]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.041]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.041]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.041]             })
[10:58:41.041]         }
[10:58:41.041]     }, args = future.call.arguments)
[10:58:41.041] }
[10:58:41.041] Lazy evaluation: FALSE
[10:58:41.041] Asynchronous evaluation: TRUE
[10:58:41.041] Local evaluation: TRUE
[10:58:41.041] Environment: R_GlobalEnv
[10:58:41.041] Capture standard output: TRUE
[10:58:41.041] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.041] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.041] Packages: <none>
[10:58:41.041] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.041] Resolved: FALSE
[10:58:41.041] Value: <not collected>
[10:58:41.041] Conditions captured: <none>
[10:58:41.041] Early signaling: FALSE
[10:58:41.041] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.041] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.053] Chunk #1 of 2 ... DONE
[10:58:41.053] Chunk #2 of 2 ...
[10:58:41.053]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.053]  - seeds: <none>
[10:58:41.053]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.053] getGlobalsAndPackages() ...
[10:58:41.053] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.054] Resolving globals: FALSE
[10:58:41.054] Tweak future expression to call with '...' arguments ...
[10:58:41.054] {
[10:58:41.054]     do.call(function(...) {
[10:58:41.054]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.054]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.054]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.054]             on.exit(options(oopts), add = TRUE)
[10:58:41.054]         }
[10:58:41.054]         {
[10:58:41.054]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.054]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.054]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.054]             })
[10:58:41.054]         }
[10:58:41.054]     }, args = future.call.arguments)
[10:58:41.054] }
[10:58:41.054] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.054] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.054] 
[10:58:41.055] getGlobalsAndPackages() ... DONE
[10:58:41.055] run() for ‘Future’ ...
[10:58:41.055] - state: ‘created’
[10:58:41.055] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.069] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.069] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.069]   - Field: ‘node’
[10:58:41.069]   - Field: ‘label’
[10:58:41.069]   - Field: ‘local’
[10:58:41.069]   - Field: ‘owner’
[10:58:41.069]   - Field: ‘envir’
[10:58:41.069]   - Field: ‘workers’
[10:58:41.069]   - Field: ‘packages’
[10:58:41.069]   - Field: ‘gc’
[10:58:41.070]   - Field: ‘conditions’
[10:58:41.070]   - Field: ‘persistent’
[10:58:41.070]   - Field: ‘expr’
[10:58:41.070]   - Field: ‘uuid’
[10:58:41.070]   - Field: ‘seed’
[10:58:41.070]   - Field: ‘version’
[10:58:41.070]   - Field: ‘result’
[10:58:41.070]   - Field: ‘asynchronous’
[10:58:41.070]   - Field: ‘calls’
[10:58:41.070]   - Field: ‘globals’
[10:58:41.070]   - Field: ‘stdout’
[10:58:41.070]   - Field: ‘earlySignal’
[10:58:41.071]   - Field: ‘lazy’
[10:58:41.071]   - Field: ‘state’
[10:58:41.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.071] - Launch lazy future ...
[10:58:41.071] Packages needed by the future expression (n = 0): <none>
[10:58:41.071] Packages needed by future strategies (n = 0): <none>
[10:58:41.072] {
[10:58:41.072]     {
[10:58:41.072]         {
[10:58:41.072]             ...future.startTime <- base::Sys.time()
[10:58:41.072]             {
[10:58:41.072]                 {
[10:58:41.072]                   {
[10:58:41.072]                     {
[10:58:41.072]                       base::local({
[10:58:41.072]                         has_future <- base::requireNamespace("future", 
[10:58:41.072]                           quietly = TRUE)
[10:58:41.072]                         if (has_future) {
[10:58:41.072]                           ns <- base::getNamespace("future")
[10:58:41.072]                           version <- ns[[".package"]][["version"]]
[10:58:41.072]                           if (is.null(version)) 
[10:58:41.072]                             version <- utils::packageVersion("future")
[10:58:41.072]                         }
[10:58:41.072]                         else {
[10:58:41.072]                           version <- NULL
[10:58:41.072]                         }
[10:58:41.072]                         if (!has_future || version < "1.8.0") {
[10:58:41.072]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.072]                             "", base::R.version$version.string), 
[10:58:41.072]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.072]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.072]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.072]                               "release", "version")], collapse = " "), 
[10:58:41.072]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.072]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.072]                             info)
[10:58:41.072]                           info <- base::paste(info, collapse = "; ")
[10:58:41.072]                           if (!has_future) {
[10:58:41.072]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.072]                               info)
[10:58:41.072]                           }
[10:58:41.072]                           else {
[10:58:41.072]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.072]                               info, version)
[10:58:41.072]                           }
[10:58:41.072]                           base::stop(msg)
[10:58:41.072]                         }
[10:58:41.072]                       })
[10:58:41.072]                     }
[10:58:41.072]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.072]                     base::options(mc.cores = 1L)
[10:58:41.072]                   }
[10:58:41.072]                   ...future.strategy.old <- future::plan("list")
[10:58:41.072]                   options(future.plan = NULL)
[10:58:41.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.072]                 }
[10:58:41.072]                 ...future.workdir <- getwd()
[10:58:41.072]             }
[10:58:41.072]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.072]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.072]         }
[10:58:41.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.072]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.072]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.072]             base::names(...future.oldOptions))
[10:58:41.072]     }
[10:58:41.072]     if (FALSE) {
[10:58:41.072]     }
[10:58:41.072]     else {
[10:58:41.072]         if (TRUE) {
[10:58:41.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.072]                 open = "w")
[10:58:41.072]         }
[10:58:41.072]         else {
[10:58:41.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.072]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.072]         }
[10:58:41.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.072]             base::sink(type = "output", split = FALSE)
[10:58:41.072]             base::close(...future.stdout)
[10:58:41.072]         }, add = TRUE)
[10:58:41.072]     }
[10:58:41.072]     ...future.frame <- base::sys.nframe()
[10:58:41.072]     ...future.conditions <- base::list()
[10:58:41.072]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.072]     if (FALSE) {
[10:58:41.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.072]     }
[10:58:41.072]     ...future.result <- base::tryCatch({
[10:58:41.072]         base::withCallingHandlers({
[10:58:41.072]             ...future.value <- base::withVisible(base::local({
[10:58:41.072]                 ...future.makeSendCondition <- base::local({
[10:58:41.072]                   sendCondition <- NULL
[10:58:41.072]                   function(frame = 1L) {
[10:58:41.072]                     if (is.function(sendCondition)) 
[10:58:41.072]                       return(sendCondition)
[10:58:41.072]                     ns <- getNamespace("parallel")
[10:58:41.072]                     if (exists("sendData", mode = "function", 
[10:58:41.072]                       envir = ns)) {
[10:58:41.072]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.072]                         envir = ns)
[10:58:41.072]                       envir <- sys.frame(frame)
[10:58:41.072]                       master <- NULL
[10:58:41.072]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.072]                         !identical(envir, emptyenv())) {
[10:58:41.072]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.072]                           inherits = FALSE)) {
[10:58:41.072]                           master <- get("master", mode = "list", 
[10:58:41.072]                             envir = envir, inherits = FALSE)
[10:58:41.072]                           if (inherits(master, c("SOCKnode", 
[10:58:41.072]                             "SOCK0node"))) {
[10:58:41.072]                             sendCondition <<- function(cond) {
[10:58:41.072]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.072]                                 success = TRUE)
[10:58:41.072]                               parallel_sendData(master, data)
[10:58:41.072]                             }
[10:58:41.072]                             return(sendCondition)
[10:58:41.072]                           }
[10:58:41.072]                         }
[10:58:41.072]                         frame <- frame + 1L
[10:58:41.072]                         envir <- sys.frame(frame)
[10:58:41.072]                       }
[10:58:41.072]                     }
[10:58:41.072]                     sendCondition <<- function(cond) NULL
[10:58:41.072]                   }
[10:58:41.072]                 })
[10:58:41.072]                 withCallingHandlers({
[10:58:41.072]                   {
[10:58:41.072]                     do.call(function(...) {
[10:58:41.072]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.072]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.072]                         ...future.globals.maxSize)) {
[10:58:41.072]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.072]                         on.exit(options(oopts), add = TRUE)
[10:58:41.072]                       }
[10:58:41.072]                       {
[10:58:41.072]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.072]                           FUN = function(jj) {
[10:58:41.072]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.072]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.072]                           })
[10:58:41.072]                       }
[10:58:41.072]                     }, args = future.call.arguments)
[10:58:41.072]                   }
[10:58:41.072]                 }, immediateCondition = function(cond) {
[10:58:41.072]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.072]                   sendCondition(cond)
[10:58:41.072]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.072]                   {
[10:58:41.072]                     inherits <- base::inherits
[10:58:41.072]                     invokeRestart <- base::invokeRestart
[10:58:41.072]                     is.null <- base::is.null
[10:58:41.072]                     muffled <- FALSE
[10:58:41.072]                     if (inherits(cond, "message")) {
[10:58:41.072]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.072]                       if (muffled) 
[10:58:41.072]                         invokeRestart("muffleMessage")
[10:58:41.072]                     }
[10:58:41.072]                     else if (inherits(cond, "warning")) {
[10:58:41.072]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.072]                       if (muffled) 
[10:58:41.072]                         invokeRestart("muffleWarning")
[10:58:41.072]                     }
[10:58:41.072]                     else if (inherits(cond, "condition")) {
[10:58:41.072]                       if (!is.null(pattern)) {
[10:58:41.072]                         computeRestarts <- base::computeRestarts
[10:58:41.072]                         grepl <- base::grepl
[10:58:41.072]                         restarts <- computeRestarts(cond)
[10:58:41.072]                         for (restart in restarts) {
[10:58:41.072]                           name <- restart$name
[10:58:41.072]                           if (is.null(name)) 
[10:58:41.072]                             next
[10:58:41.072]                           if (!grepl(pattern, name)) 
[10:58:41.072]                             next
[10:58:41.072]                           invokeRestart(restart)
[10:58:41.072]                           muffled <- TRUE
[10:58:41.072]                           break
[10:58:41.072]                         }
[10:58:41.072]                       }
[10:58:41.072]                     }
[10:58:41.072]                     invisible(muffled)
[10:58:41.072]                   }
[10:58:41.072]                   muffleCondition(cond)
[10:58:41.072]                 })
[10:58:41.072]             }))
[10:58:41.072]             future::FutureResult(value = ...future.value$value, 
[10:58:41.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.072]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.072]                     ...future.globalenv.names))
[10:58:41.072]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.072]         }, condition = base::local({
[10:58:41.072]             c <- base::c
[10:58:41.072]             inherits <- base::inherits
[10:58:41.072]             invokeRestart <- base::invokeRestart
[10:58:41.072]             length <- base::length
[10:58:41.072]             list <- base::list
[10:58:41.072]             seq.int <- base::seq.int
[10:58:41.072]             signalCondition <- base::signalCondition
[10:58:41.072]             sys.calls <- base::sys.calls
[10:58:41.072]             `[[` <- base::`[[`
[10:58:41.072]             `+` <- base::`+`
[10:58:41.072]             `<<-` <- base::`<<-`
[10:58:41.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.072]                   3L)]
[10:58:41.072]             }
[10:58:41.072]             function(cond) {
[10:58:41.072]                 is_error <- inherits(cond, "error")
[10:58:41.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.072]                   NULL)
[10:58:41.072]                 if (is_error) {
[10:58:41.072]                   sessionInformation <- function() {
[10:58:41.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.072]                       search = base::search(), system = base::Sys.info())
[10:58:41.072]                   }
[10:58:41.072]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.072]                     cond$call), session = sessionInformation(), 
[10:58:41.072]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.072]                   signalCondition(cond)
[10:58:41.072]                 }
[10:58:41.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.072]                 "immediateCondition"))) {
[10:58:41.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.072]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.072]                   if (TRUE && !signal) {
[10:58:41.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.072]                     {
[10:58:41.072]                       inherits <- base::inherits
[10:58:41.072]                       invokeRestart <- base::invokeRestart
[10:58:41.072]                       is.null <- base::is.null
[10:58:41.072]                       muffled <- FALSE
[10:58:41.072]                       if (inherits(cond, "message")) {
[10:58:41.072]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.072]                         if (muffled) 
[10:58:41.072]                           invokeRestart("muffleMessage")
[10:58:41.072]                       }
[10:58:41.072]                       else if (inherits(cond, "warning")) {
[10:58:41.072]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.072]                         if (muffled) 
[10:58:41.072]                           invokeRestart("muffleWarning")
[10:58:41.072]                       }
[10:58:41.072]                       else if (inherits(cond, "condition")) {
[10:58:41.072]                         if (!is.null(pattern)) {
[10:58:41.072]                           computeRestarts <- base::computeRestarts
[10:58:41.072]                           grepl <- base::grepl
[10:58:41.072]                           restarts <- computeRestarts(cond)
[10:58:41.072]                           for (restart in restarts) {
[10:58:41.072]                             name <- restart$name
[10:58:41.072]                             if (is.null(name)) 
[10:58:41.072]                               next
[10:58:41.072]                             if (!grepl(pattern, name)) 
[10:58:41.072]                               next
[10:58:41.072]                             invokeRestart(restart)
[10:58:41.072]                             muffled <- TRUE
[10:58:41.072]                             break
[10:58:41.072]                           }
[10:58:41.072]                         }
[10:58:41.072]                       }
[10:58:41.072]                       invisible(muffled)
[10:58:41.072]                     }
[10:58:41.072]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.072]                   }
[10:58:41.072]                 }
[10:58:41.072]                 else {
[10:58:41.072]                   if (TRUE) {
[10:58:41.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.072]                     {
[10:58:41.072]                       inherits <- base::inherits
[10:58:41.072]                       invokeRestart <- base::invokeRestart
[10:58:41.072]                       is.null <- base::is.null
[10:58:41.072]                       muffled <- FALSE
[10:58:41.072]                       if (inherits(cond, "message")) {
[10:58:41.072]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.072]                         if (muffled) 
[10:58:41.072]                           invokeRestart("muffleMessage")
[10:58:41.072]                       }
[10:58:41.072]                       else if (inherits(cond, "warning")) {
[10:58:41.072]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.072]                         if (muffled) 
[10:58:41.072]                           invokeRestart("muffleWarning")
[10:58:41.072]                       }
[10:58:41.072]                       else if (inherits(cond, "condition")) {
[10:58:41.072]                         if (!is.null(pattern)) {
[10:58:41.072]                           computeRestarts <- base::computeRestarts
[10:58:41.072]                           grepl <- base::grepl
[10:58:41.072]                           restarts <- computeRestarts(cond)
[10:58:41.072]                           for (restart in restarts) {
[10:58:41.072]                             name <- restart$name
[10:58:41.072]                             if (is.null(name)) 
[10:58:41.072]                               next
[10:58:41.072]                             if (!grepl(pattern, name)) 
[10:58:41.072]                               next
[10:58:41.072]                             invokeRestart(restart)
[10:58:41.072]                             muffled <- TRUE
[10:58:41.072]                             break
[10:58:41.072]                           }
[10:58:41.072]                         }
[10:58:41.072]                       }
[10:58:41.072]                       invisible(muffled)
[10:58:41.072]                     }
[10:58:41.072]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.072]                   }
[10:58:41.072]                 }
[10:58:41.072]             }
[10:58:41.072]         }))
[10:58:41.072]     }, error = function(ex) {
[10:58:41.072]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.072]                 ...future.rng), started = ...future.startTime, 
[10:58:41.072]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.072]             version = "1.8"), class = "FutureResult")
[10:58:41.072]     }, finally = {
[10:58:41.072]         if (!identical(...future.workdir, getwd())) 
[10:58:41.072]             setwd(...future.workdir)
[10:58:41.072]         {
[10:58:41.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.072]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.072]             }
[10:58:41.072]             base::options(...future.oldOptions)
[10:58:41.072]             if (.Platform$OS.type == "windows") {
[10:58:41.072]                 old_names <- names(...future.oldEnvVars)
[10:58:41.072]                 envs <- base::Sys.getenv()
[10:58:41.072]                 names <- names(envs)
[10:58:41.072]                 common <- intersect(names, old_names)
[10:58:41.072]                 added <- setdiff(names, old_names)
[10:58:41.072]                 removed <- setdiff(old_names, names)
[10:58:41.072]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.072]                   envs[common]]
[10:58:41.072]                 NAMES <- toupper(changed)
[10:58:41.072]                 args <- list()
[10:58:41.072]                 for (kk in seq_along(NAMES)) {
[10:58:41.072]                   name <- changed[[kk]]
[10:58:41.072]                   NAME <- NAMES[[kk]]
[10:58:41.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.072]                     next
[10:58:41.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.072]                 }
[10:58:41.072]                 NAMES <- toupper(added)
[10:58:41.072]                 for (kk in seq_along(NAMES)) {
[10:58:41.072]                   name <- added[[kk]]
[10:58:41.072]                   NAME <- NAMES[[kk]]
[10:58:41.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.072]                     next
[10:58:41.072]                   args[[name]] <- ""
[10:58:41.072]                 }
[10:58:41.072]                 NAMES <- toupper(removed)
[10:58:41.072]                 for (kk in seq_along(NAMES)) {
[10:58:41.072]                   name <- removed[[kk]]
[10:58:41.072]                   NAME <- NAMES[[kk]]
[10:58:41.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.072]                     next
[10:58:41.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.072]                 }
[10:58:41.072]                 if (length(args) > 0) 
[10:58:41.072]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.072]             }
[10:58:41.072]             else {
[10:58:41.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.072]             }
[10:58:41.072]             {
[10:58:41.072]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.072]                   0L) {
[10:58:41.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.072]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.072]                   base::options(opts)
[10:58:41.072]                 }
[10:58:41.072]                 {
[10:58:41.072]                   {
[10:58:41.072]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.072]                     NULL
[10:58:41.072]                   }
[10:58:41.072]                   options(future.plan = NULL)
[10:58:41.072]                   if (is.na(NA_character_)) 
[10:58:41.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.072]                     .init = FALSE)
[10:58:41.072]                 }
[10:58:41.072]             }
[10:58:41.072]         }
[10:58:41.072]     })
[10:58:41.072]     if (TRUE) {
[10:58:41.072]         base::sink(type = "output", split = FALSE)
[10:58:41.072]         if (TRUE) {
[10:58:41.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.072]         }
[10:58:41.072]         else {
[10:58:41.072]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.072]         }
[10:58:41.072]         base::close(...future.stdout)
[10:58:41.072]         ...future.stdout <- NULL
[10:58:41.072]     }
[10:58:41.072]     ...future.result$conditions <- ...future.conditions
[10:58:41.072]     ...future.result$finished <- base::Sys.time()
[10:58:41.072]     ...future.result
[10:58:41.072] }
[10:58:41.075] Exporting 5 global objects (31.96 KiB) to cluster node #2 ...
[10:58:41.075] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:41.075] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:41.076] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ...
[10:58:41.117] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ... DONE
[10:58:41.117] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[10:58:41.117] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[10:58:41.117] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:41.118] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:41.118] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:41.118] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:41.118] Exporting 5 global objects (31.96 KiB) to cluster node #2 ... DONE
[10:58:41.119] MultisessionFuture started
[10:58:41.119] - Launch lazy future ... done
[10:58:41.119] run() for ‘MultisessionFuture’ ... done
[10:58:41.119] Created future:
[10:58:41.120] MultisessionFuture:
[10:58:41.120] Label: ‘future_apply-2’
[10:58:41.120] Expression:
[10:58:41.120] {
[10:58:41.120]     do.call(function(...) {
[10:58:41.120]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.120]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.120]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.120]             on.exit(options(oopts), add = TRUE)
[10:58:41.120]         }
[10:58:41.120]         {
[10:58:41.120]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.120]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.120]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.120]             })
[10:58:41.120]         }
[10:58:41.120]     }, args = future.call.arguments)
[10:58:41.120] }
[10:58:41.120] Lazy evaluation: FALSE
[10:58:41.120] Asynchronous evaluation: TRUE
[10:58:41.120] Local evaluation: TRUE
[10:58:41.120] Environment: R_GlobalEnv
[10:58:41.120] Capture standard output: TRUE
[10:58:41.120] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.120] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.120] Packages: <none>
[10:58:41.120] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.120] Resolved: FALSE
[10:58:41.120] Value: <not collected>
[10:58:41.120] Conditions captured: <none>
[10:58:41.120] Early signaling: FALSE
[10:58:41.120] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.120] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.132] Chunk #2 of 2 ... DONE
[10:58:41.132] Launching 2 futures (chunks) ... DONE
[10:58:41.132] Resolving 2 futures (chunks) ...
[10:58:41.132] resolve() on list ...
[10:58:41.132]  recursive: 0
[10:58:41.132]  length: 2
[10:58:41.132] 
[10:58:41.133] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.133] - Validating connection of MultisessionFuture
[10:58:41.133] - received message: FutureResult
[10:58:41.133] - Received FutureResult
[10:58:41.133] - Erased future from FutureRegistry
[10:58:41.133] result() for ClusterFuture ...
[10:58:41.134] - result already collected: FutureResult
[10:58:41.134] result() for ClusterFuture ... done
[10:58:41.134] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.134] Future #1
[10:58:41.134] result() for ClusterFuture ...
[10:58:41.134] - result already collected: FutureResult
[10:58:41.134] result() for ClusterFuture ... done
[10:58:41.134] result() for ClusterFuture ...
[10:58:41.134] - result already collected: FutureResult
[10:58:41.134] result() for ClusterFuture ... done
[10:58:41.134] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:41.134] - nx: 2
[10:58:41.135] - relay: TRUE
[10:58:41.135] - stdout: TRUE
[10:58:41.135] - signal: TRUE
[10:58:41.135] - resignal: FALSE
[10:58:41.135] - force: TRUE
[10:58:41.135] - relayed: [n=2] FALSE, FALSE
[10:58:41.135] - queued futures: [n=2] FALSE, FALSE
[10:58:41.135]  - until=1
[10:58:41.135]  - relaying element #1
[10:58:41.135] result() for ClusterFuture ...
[10:58:41.135] - result already collected: FutureResult
[10:58:41.135] result() for ClusterFuture ... done
[10:58:41.136] result() for ClusterFuture ...
[10:58:41.136] - result already collected: FutureResult
[10:58:41.136] result() for ClusterFuture ... done
[10:58:41.136] result() for ClusterFuture ...
[10:58:41.136] - result already collected: FutureResult
[10:58:41.136] result() for ClusterFuture ... done
[10:58:41.136] result() for ClusterFuture ...
[10:58:41.136] - result already collected: FutureResult
[10:58:41.136] result() for ClusterFuture ... done
[10:58:41.136] - relayed: [n=2] TRUE, FALSE
[10:58:41.136] - queued futures: [n=2] TRUE, FALSE
[10:58:41.136] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:41.137]  length: 1 (resolved future 1)
[10:58:41.161] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.161] - Validating connection of MultisessionFuture
[10:58:41.161] - received message: FutureResult
[10:58:41.161] - Received FutureResult
[10:58:41.161] - Erased future from FutureRegistry
[10:58:41.162] result() for ClusterFuture ...
[10:58:41.162] - result already collected: FutureResult
[10:58:41.162] result() for ClusterFuture ... done
[10:58:41.162] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.162] Future #2
[10:58:41.162] result() for ClusterFuture ...
[10:58:41.162] - result already collected: FutureResult
[10:58:41.162] result() for ClusterFuture ... done
[10:58:41.162] result() for ClusterFuture ...
[10:58:41.162] - result already collected: FutureResult
[10:58:41.162] result() for ClusterFuture ... done
[10:58:41.163] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:41.163] - nx: 2
[10:58:41.163] - relay: TRUE
[10:58:41.163] - stdout: TRUE
[10:58:41.163] - signal: TRUE
[10:58:41.163] - resignal: FALSE
[10:58:41.163] - force: TRUE
[10:58:41.163] - relayed: [n=2] TRUE, FALSE
[10:58:41.163] - queued futures: [n=2] TRUE, FALSE
[10:58:41.163]  - until=2
[10:58:41.163]  - relaying element #2
[10:58:41.163] result() for ClusterFuture ...
[10:58:41.163] - result already collected: FutureResult
[10:58:41.164] result() for ClusterFuture ... done
[10:58:41.164] result() for ClusterFuture ...
[10:58:41.164] - result already collected: FutureResult
[10:58:41.164] result() for ClusterFuture ... done
[10:58:41.164] result() for ClusterFuture ...
[10:58:41.164] - result already collected: FutureResult
[10:58:41.164] result() for ClusterFuture ... done
[10:58:41.164] result() for ClusterFuture ...
[10:58:41.164] - result already collected: FutureResult
[10:58:41.164] result() for ClusterFuture ... done
[10:58:41.164] - relayed: [n=2] TRUE, TRUE
[10:58:41.164] - queued futures: [n=2] TRUE, TRUE
[10:58:41.165] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:41.165]  length: 0 (resolved future 2)
[10:58:41.165] Relaying remaining futures
[10:58:41.165] signalConditionsASAP(NULL, pos=0) ...
[10:58:41.165] - nx: 2
[10:58:41.165] - relay: TRUE
[10:58:41.165] - stdout: TRUE
[10:58:41.165] - signal: TRUE
[10:58:41.165] - resignal: FALSE
[10:58:41.165] - force: TRUE
[10:58:41.165] - relayed: [n=2] TRUE, TRUE
[10:58:41.165] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:41.166] - relayed: [n=2] TRUE, TRUE
[10:58:41.166] - queued futures: [n=2] TRUE, TRUE
[10:58:41.166] signalConditionsASAP(NULL, pos=0) ... done
[10:58:41.166] resolve() on list ... DONE
[10:58:41.166] result() for ClusterFuture ...
[10:58:41.166] - result already collected: FutureResult
[10:58:41.166] result() for ClusterFuture ... done
[10:58:41.166] result() for ClusterFuture ...
[10:58:41.166] - result already collected: FutureResult
[10:58:41.166] result() for ClusterFuture ... done
[10:58:41.166] result() for ClusterFuture ...
[10:58:41.167] - result already collected: FutureResult
[10:58:41.167] result() for ClusterFuture ... done
[10:58:41.167] result() for ClusterFuture ...
[10:58:41.167] - result already collected: FutureResult
[10:58:41.167] result() for ClusterFuture ... done
[10:58:41.167]  - Number of value chunks collected: 2
[10:58:41.167] Resolving 2 futures (chunks) ... DONE
[10:58:41.167] Reducing values from 2 chunks ...
[10:58:41.167]  - Number of values collected after concatenation: 2
[10:58:41.167]  - Number of values expected: 2
[10:58:41.167] Reducing values from 2 chunks ... DONE
[10:58:41.167] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:58:41.168] getGlobalsAndPackagesXApply() ...
[10:58:41.168]  - future.globals: TRUE
[10:58:41.168] getGlobalsAndPackages() ...
[10:58:41.168] Searching for globals...
[10:58:41.170] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:58:41.170] Searching for globals ... DONE
[10:58:41.170] Resolving globals: FALSE
[10:58:41.170] The total size of the 1 globals is 311 bytes (311 bytes)
[10:58:41.170] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:58:41.171] - globals: [1] ‘FUN’
[10:58:41.171] - packages: [1] ‘stats’
[10:58:41.171] getGlobalsAndPackages() ... DONE
[10:58:41.171]  - globals found/used: [n=1] ‘FUN’
[10:58:41.171]  - needed namespaces: [n=1] ‘stats’
[10:58:41.171] Finding globals ... DONE
[10:58:41.171]  - use_args: TRUE
[10:58:41.171]  - Getting '...' globals ...
[10:58:41.172] resolve() on list ...
[10:58:41.172]  recursive: 0
[10:58:41.172]  length: 1
[10:58:41.172]  elements: ‘...’
[10:58:41.172]  length: 0 (resolved future 1)
[10:58:41.172] resolve() on list ... DONE
[10:58:41.172]    - '...' content: [n=0] 
[10:58:41.172] List of 1
[10:58:41.172]  $ ...: list()
[10:58:41.172]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.172]  - attr(*, "where")=List of 1
[10:58:41.172]   ..$ ...:<environment: 0x5635c0f38c38> 
[10:58:41.172]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.172]  - attr(*, "resolved")= logi TRUE
[10:58:41.172]  - attr(*, "total_size")= num NA
[10:58:41.175]  - Getting '...' globals ... DONE
[10:58:41.175] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:41.175] List of 2
[10:58:41.175]  $ ...future.FUN:function (x, ...)  
[10:58:41.175]  $ ...          : list()
[10:58:41.175]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.175]  - attr(*, "where")=List of 2
[10:58:41.175]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:41.175]   ..$ ...          :<environment: 0x5635c0f38c38> 
[10:58:41.175]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.175]  - attr(*, "resolved")= logi FALSE
[10:58:41.175]  - attr(*, "total_size")= num 2586
[10:58:41.177] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:41.178] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.179] future_lapply() ...
[10:58:41.181] Number of chunks: 2
[10:58:41.181] getGlobalsAndPackagesXApply() ...
[10:58:41.181]  - future.globals: <name-value list> with names ‘list()’
[10:58:41.181]  - use_args: TRUE
[10:58:41.181] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:41.181] List of 2
[10:58:41.181]  $ ...          : list()
[10:58:41.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.181]  $ ...future.FUN:function (x, ...)  
[10:58:41.181]  - attr(*, "where")=List of 2
[10:58:41.181]   ..$ ...          :<environment: 0x5635c0f38c38> 
[10:58:41.181]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:58:41.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.181]  - attr(*, "resolved")= logi FALSE
[10:58:41.181]  - attr(*, "total_size")= num NA
[10:58:41.184] Packages to be attached in all futures: [n=1] ‘stats’
[10:58:41.184] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.184] Number of futures (= number of chunks): 2
[10:58:41.185] Launching 2 futures (chunks) ...
[10:58:41.185] Chunk #1 of 2 ...
[10:58:41.185]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.185]  - seeds: <none>
[10:58:41.185]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.185] getGlobalsAndPackages() ...
[10:58:41.185] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.185] Resolving globals: FALSE
[10:58:41.185] Tweak future expression to call with '...' arguments ...
[10:58:41.185] {
[10:58:41.185]     do.call(function(...) {
[10:58:41.185]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.185]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.185]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.185]             on.exit(options(oopts), add = TRUE)
[10:58:41.185]         }
[10:58:41.185]         {
[10:58:41.185]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.185]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.185]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.185]             })
[10:58:41.185]         }
[10:58:41.185]     }, args = future.call.arguments)
[10:58:41.185] }
[10:58:41.186] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.186] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.186] - packages: [1] ‘stats’
[10:58:41.186] getGlobalsAndPackages() ... DONE
[10:58:41.187] run() for ‘Future’ ...
[10:58:41.187] - state: ‘created’
[10:58:41.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.201]   - Field: ‘node’
[10:58:41.201]   - Field: ‘label’
[10:58:41.202]   - Field: ‘local’
[10:58:41.202]   - Field: ‘owner’
[10:58:41.202]   - Field: ‘envir’
[10:58:41.202]   - Field: ‘workers’
[10:58:41.202]   - Field: ‘packages’
[10:58:41.202]   - Field: ‘gc’
[10:58:41.202]   - Field: ‘conditions’
[10:58:41.202]   - Field: ‘persistent’
[10:58:41.202]   - Field: ‘expr’
[10:58:41.202]   - Field: ‘uuid’
[10:58:41.202]   - Field: ‘seed’
[10:58:41.202]   - Field: ‘version’
[10:58:41.203]   - Field: ‘result’
[10:58:41.203]   - Field: ‘asynchronous’
[10:58:41.203]   - Field: ‘calls’
[10:58:41.203]   - Field: ‘globals’
[10:58:41.203]   - Field: ‘stdout’
[10:58:41.203]   - Field: ‘earlySignal’
[10:58:41.203]   - Field: ‘lazy’
[10:58:41.203]   - Field: ‘state’
[10:58:41.203] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.203] - Launch lazy future ...
[10:58:41.204] Packages needed by the future expression (n = 1): ‘stats’
[10:58:41.204] Packages needed by future strategies (n = 0): <none>
[10:58:41.204] {
[10:58:41.204]     {
[10:58:41.204]         {
[10:58:41.204]             ...future.startTime <- base::Sys.time()
[10:58:41.204]             {
[10:58:41.204]                 {
[10:58:41.204]                   {
[10:58:41.204]                     {
[10:58:41.204]                       {
[10:58:41.204]                         base::local({
[10:58:41.204]                           has_future <- base::requireNamespace("future", 
[10:58:41.204]                             quietly = TRUE)
[10:58:41.204]                           if (has_future) {
[10:58:41.204]                             ns <- base::getNamespace("future")
[10:58:41.204]                             version <- ns[[".package"]][["version"]]
[10:58:41.204]                             if (is.null(version)) 
[10:58:41.204]                               version <- utils::packageVersion("future")
[10:58:41.204]                           }
[10:58:41.204]                           else {
[10:58:41.204]                             version <- NULL
[10:58:41.204]                           }
[10:58:41.204]                           if (!has_future || version < "1.8.0") {
[10:58:41.204]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.204]                               "", base::R.version$version.string), 
[10:58:41.204]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:41.204]                                 base::R.version$platform, 8 * 
[10:58:41.204]                                   base::.Machine$sizeof.pointer), 
[10:58:41.204]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.204]                                 "release", "version")], collapse = " "), 
[10:58:41.204]                               hostname = base::Sys.info()[["nodename"]])
[10:58:41.204]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.204]                               info)
[10:58:41.204]                             info <- base::paste(info, collapse = "; ")
[10:58:41.204]                             if (!has_future) {
[10:58:41.204]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.204]                                 info)
[10:58:41.204]                             }
[10:58:41.204]                             else {
[10:58:41.204]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.204]                                 info, version)
[10:58:41.204]                             }
[10:58:41.204]                             base::stop(msg)
[10:58:41.204]                           }
[10:58:41.204]                         })
[10:58:41.204]                       }
[10:58:41.204]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.204]                       base::options(mc.cores = 1L)
[10:58:41.204]                     }
[10:58:41.204]                     base::local({
[10:58:41.204]                       for (pkg in "stats") {
[10:58:41.204]                         base::loadNamespace(pkg)
[10:58:41.204]                         base::library(pkg, character.only = TRUE)
[10:58:41.204]                       }
[10:58:41.204]                     })
[10:58:41.204]                   }
[10:58:41.204]                   ...future.strategy.old <- future::plan("list")
[10:58:41.204]                   options(future.plan = NULL)
[10:58:41.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.204]                 }
[10:58:41.204]                 ...future.workdir <- getwd()
[10:58:41.204]             }
[10:58:41.204]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.204]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.204]         }
[10:58:41.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.204]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.204]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.204]             base::names(...future.oldOptions))
[10:58:41.204]     }
[10:58:41.204]     if (FALSE) {
[10:58:41.204]     }
[10:58:41.204]     else {
[10:58:41.204]         if (TRUE) {
[10:58:41.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.204]                 open = "w")
[10:58:41.204]         }
[10:58:41.204]         else {
[10:58:41.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.204]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.204]         }
[10:58:41.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.204]             base::sink(type = "output", split = FALSE)
[10:58:41.204]             base::close(...future.stdout)
[10:58:41.204]         }, add = TRUE)
[10:58:41.204]     }
[10:58:41.204]     ...future.frame <- base::sys.nframe()
[10:58:41.204]     ...future.conditions <- base::list()
[10:58:41.204]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.204]     if (FALSE) {
[10:58:41.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.204]     }
[10:58:41.204]     ...future.result <- base::tryCatch({
[10:58:41.204]         base::withCallingHandlers({
[10:58:41.204]             ...future.value <- base::withVisible(base::local({
[10:58:41.204]                 ...future.makeSendCondition <- base::local({
[10:58:41.204]                   sendCondition <- NULL
[10:58:41.204]                   function(frame = 1L) {
[10:58:41.204]                     if (is.function(sendCondition)) 
[10:58:41.204]                       return(sendCondition)
[10:58:41.204]                     ns <- getNamespace("parallel")
[10:58:41.204]                     if (exists("sendData", mode = "function", 
[10:58:41.204]                       envir = ns)) {
[10:58:41.204]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.204]                         envir = ns)
[10:58:41.204]                       envir <- sys.frame(frame)
[10:58:41.204]                       master <- NULL
[10:58:41.204]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.204]                         !identical(envir, emptyenv())) {
[10:58:41.204]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.204]                           inherits = FALSE)) {
[10:58:41.204]                           master <- get("master", mode = "list", 
[10:58:41.204]                             envir = envir, inherits = FALSE)
[10:58:41.204]                           if (inherits(master, c("SOCKnode", 
[10:58:41.204]                             "SOCK0node"))) {
[10:58:41.204]                             sendCondition <<- function(cond) {
[10:58:41.204]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.204]                                 success = TRUE)
[10:58:41.204]                               parallel_sendData(master, data)
[10:58:41.204]                             }
[10:58:41.204]                             return(sendCondition)
[10:58:41.204]                           }
[10:58:41.204]                         }
[10:58:41.204]                         frame <- frame + 1L
[10:58:41.204]                         envir <- sys.frame(frame)
[10:58:41.204]                       }
[10:58:41.204]                     }
[10:58:41.204]                     sendCondition <<- function(cond) NULL
[10:58:41.204]                   }
[10:58:41.204]                 })
[10:58:41.204]                 withCallingHandlers({
[10:58:41.204]                   {
[10:58:41.204]                     do.call(function(...) {
[10:58:41.204]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.204]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.204]                         ...future.globals.maxSize)) {
[10:58:41.204]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.204]                         on.exit(options(oopts), add = TRUE)
[10:58:41.204]                       }
[10:58:41.204]                       {
[10:58:41.204]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.204]                           FUN = function(jj) {
[10:58:41.204]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.204]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.204]                           })
[10:58:41.204]                       }
[10:58:41.204]                     }, args = future.call.arguments)
[10:58:41.204]                   }
[10:58:41.204]                 }, immediateCondition = function(cond) {
[10:58:41.204]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.204]                   sendCondition(cond)
[10:58:41.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.204]                   {
[10:58:41.204]                     inherits <- base::inherits
[10:58:41.204]                     invokeRestart <- base::invokeRestart
[10:58:41.204]                     is.null <- base::is.null
[10:58:41.204]                     muffled <- FALSE
[10:58:41.204]                     if (inherits(cond, "message")) {
[10:58:41.204]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.204]                       if (muffled) 
[10:58:41.204]                         invokeRestart("muffleMessage")
[10:58:41.204]                     }
[10:58:41.204]                     else if (inherits(cond, "warning")) {
[10:58:41.204]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.204]                       if (muffled) 
[10:58:41.204]                         invokeRestart("muffleWarning")
[10:58:41.204]                     }
[10:58:41.204]                     else if (inherits(cond, "condition")) {
[10:58:41.204]                       if (!is.null(pattern)) {
[10:58:41.204]                         computeRestarts <- base::computeRestarts
[10:58:41.204]                         grepl <- base::grepl
[10:58:41.204]                         restarts <- computeRestarts(cond)
[10:58:41.204]                         for (restart in restarts) {
[10:58:41.204]                           name <- restart$name
[10:58:41.204]                           if (is.null(name)) 
[10:58:41.204]                             next
[10:58:41.204]                           if (!grepl(pattern, name)) 
[10:58:41.204]                             next
[10:58:41.204]                           invokeRestart(restart)
[10:58:41.204]                           muffled <- TRUE
[10:58:41.204]                           break
[10:58:41.204]                         }
[10:58:41.204]                       }
[10:58:41.204]                     }
[10:58:41.204]                     invisible(muffled)
[10:58:41.204]                   }
[10:58:41.204]                   muffleCondition(cond)
[10:58:41.204]                 })
[10:58:41.204]             }))
[10:58:41.204]             future::FutureResult(value = ...future.value$value, 
[10:58:41.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.204]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.204]                     ...future.globalenv.names))
[10:58:41.204]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.204]         }, condition = base::local({
[10:58:41.204]             c <- base::c
[10:58:41.204]             inherits <- base::inherits
[10:58:41.204]             invokeRestart <- base::invokeRestart
[10:58:41.204]             length <- base::length
[10:58:41.204]             list <- base::list
[10:58:41.204]             seq.int <- base::seq.int
[10:58:41.204]             signalCondition <- base::signalCondition
[10:58:41.204]             sys.calls <- base::sys.calls
[10:58:41.204]             `[[` <- base::`[[`
[10:58:41.204]             `+` <- base::`+`
[10:58:41.204]             `<<-` <- base::`<<-`
[10:58:41.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.204]                   3L)]
[10:58:41.204]             }
[10:58:41.204]             function(cond) {
[10:58:41.204]                 is_error <- inherits(cond, "error")
[10:58:41.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.204]                   NULL)
[10:58:41.204]                 if (is_error) {
[10:58:41.204]                   sessionInformation <- function() {
[10:58:41.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.204]                       search = base::search(), system = base::Sys.info())
[10:58:41.204]                   }
[10:58:41.204]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.204]                     cond$call), session = sessionInformation(), 
[10:58:41.204]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.204]                   signalCondition(cond)
[10:58:41.204]                 }
[10:58:41.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.204]                 "immediateCondition"))) {
[10:58:41.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.204]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.204]                   if (TRUE && !signal) {
[10:58:41.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.204]                     {
[10:58:41.204]                       inherits <- base::inherits
[10:58:41.204]                       invokeRestart <- base::invokeRestart
[10:58:41.204]                       is.null <- base::is.null
[10:58:41.204]                       muffled <- FALSE
[10:58:41.204]                       if (inherits(cond, "message")) {
[10:58:41.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.204]                         if (muffled) 
[10:58:41.204]                           invokeRestart("muffleMessage")
[10:58:41.204]                       }
[10:58:41.204]                       else if (inherits(cond, "warning")) {
[10:58:41.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.204]                         if (muffled) 
[10:58:41.204]                           invokeRestart("muffleWarning")
[10:58:41.204]                       }
[10:58:41.204]                       else if (inherits(cond, "condition")) {
[10:58:41.204]                         if (!is.null(pattern)) {
[10:58:41.204]                           computeRestarts <- base::computeRestarts
[10:58:41.204]                           grepl <- base::grepl
[10:58:41.204]                           restarts <- computeRestarts(cond)
[10:58:41.204]                           for (restart in restarts) {
[10:58:41.204]                             name <- restart$name
[10:58:41.204]                             if (is.null(name)) 
[10:58:41.204]                               next
[10:58:41.204]                             if (!grepl(pattern, name)) 
[10:58:41.204]                               next
[10:58:41.204]                             invokeRestart(restart)
[10:58:41.204]                             muffled <- TRUE
[10:58:41.204]                             break
[10:58:41.204]                           }
[10:58:41.204]                         }
[10:58:41.204]                       }
[10:58:41.204]                       invisible(muffled)
[10:58:41.204]                     }
[10:58:41.204]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.204]                   }
[10:58:41.204]                 }
[10:58:41.204]                 else {
[10:58:41.204]                   if (TRUE) {
[10:58:41.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.204]                     {
[10:58:41.204]                       inherits <- base::inherits
[10:58:41.204]                       invokeRestart <- base::invokeRestart
[10:58:41.204]                       is.null <- base::is.null
[10:58:41.204]                       muffled <- FALSE
[10:58:41.204]                       if (inherits(cond, "message")) {
[10:58:41.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.204]                         if (muffled) 
[10:58:41.204]                           invokeRestart("muffleMessage")
[10:58:41.204]                       }
[10:58:41.204]                       else if (inherits(cond, "warning")) {
[10:58:41.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.204]                         if (muffled) 
[10:58:41.204]                           invokeRestart("muffleWarning")
[10:58:41.204]                       }
[10:58:41.204]                       else if (inherits(cond, "condition")) {
[10:58:41.204]                         if (!is.null(pattern)) {
[10:58:41.204]                           computeRestarts <- base::computeRestarts
[10:58:41.204]                           grepl <- base::grepl
[10:58:41.204]                           restarts <- computeRestarts(cond)
[10:58:41.204]                           for (restart in restarts) {
[10:58:41.204]                             name <- restart$name
[10:58:41.204]                             if (is.null(name)) 
[10:58:41.204]                               next
[10:58:41.204]                             if (!grepl(pattern, name)) 
[10:58:41.204]                               next
[10:58:41.204]                             invokeRestart(restart)
[10:58:41.204]                             muffled <- TRUE
[10:58:41.204]                             break
[10:58:41.204]                           }
[10:58:41.204]                         }
[10:58:41.204]                       }
[10:58:41.204]                       invisible(muffled)
[10:58:41.204]                     }
[10:58:41.204]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.204]                   }
[10:58:41.204]                 }
[10:58:41.204]             }
[10:58:41.204]         }))
[10:58:41.204]     }, error = function(ex) {
[10:58:41.204]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.204]                 ...future.rng), started = ...future.startTime, 
[10:58:41.204]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.204]             version = "1.8"), class = "FutureResult")
[10:58:41.204]     }, finally = {
[10:58:41.204]         if (!identical(...future.workdir, getwd())) 
[10:58:41.204]             setwd(...future.workdir)
[10:58:41.204]         {
[10:58:41.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.204]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.204]             }
[10:58:41.204]             base::options(...future.oldOptions)
[10:58:41.204]             if (.Platform$OS.type == "windows") {
[10:58:41.204]                 old_names <- names(...future.oldEnvVars)
[10:58:41.204]                 envs <- base::Sys.getenv()
[10:58:41.204]                 names <- names(envs)
[10:58:41.204]                 common <- intersect(names, old_names)
[10:58:41.204]                 added <- setdiff(names, old_names)
[10:58:41.204]                 removed <- setdiff(old_names, names)
[10:58:41.204]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.204]                   envs[common]]
[10:58:41.204]                 NAMES <- toupper(changed)
[10:58:41.204]                 args <- list()
[10:58:41.204]                 for (kk in seq_along(NAMES)) {
[10:58:41.204]                   name <- changed[[kk]]
[10:58:41.204]                   NAME <- NAMES[[kk]]
[10:58:41.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.204]                     next
[10:58:41.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.204]                 }
[10:58:41.204]                 NAMES <- toupper(added)
[10:58:41.204]                 for (kk in seq_along(NAMES)) {
[10:58:41.204]                   name <- added[[kk]]
[10:58:41.204]                   NAME <- NAMES[[kk]]
[10:58:41.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.204]                     next
[10:58:41.204]                   args[[name]] <- ""
[10:58:41.204]                 }
[10:58:41.204]                 NAMES <- toupper(removed)
[10:58:41.204]                 for (kk in seq_along(NAMES)) {
[10:58:41.204]                   name <- removed[[kk]]
[10:58:41.204]                   NAME <- NAMES[[kk]]
[10:58:41.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.204]                     next
[10:58:41.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.204]                 }
[10:58:41.204]                 if (length(args) > 0) 
[10:58:41.204]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.204]             }
[10:58:41.204]             else {
[10:58:41.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.204]             }
[10:58:41.204]             {
[10:58:41.204]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.204]                   0L) {
[10:58:41.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.204]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.204]                   base::options(opts)
[10:58:41.204]                 }
[10:58:41.204]                 {
[10:58:41.204]                   {
[10:58:41.204]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.204]                     NULL
[10:58:41.204]                   }
[10:58:41.204]                   options(future.plan = NULL)
[10:58:41.204]                   if (is.na(NA_character_)) 
[10:58:41.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.204]                     .init = FALSE)
[10:58:41.204]                 }
[10:58:41.204]             }
[10:58:41.204]         }
[10:58:41.204]     })
[10:58:41.204]     if (TRUE) {
[10:58:41.204]         base::sink(type = "output", split = FALSE)
[10:58:41.204]         if (TRUE) {
[10:58:41.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.204]         }
[10:58:41.204]         else {
[10:58:41.204]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.204]         }
[10:58:41.204]         base::close(...future.stdout)
[10:58:41.204]         ...future.stdout <- NULL
[10:58:41.204]     }
[10:58:41.204]     ...future.result$conditions <- ...future.conditions
[10:58:41.204]     ...future.result$finished <- base::Sys.time()
[10:58:41.204]     ...future.result
[10:58:41.204] }
[10:58:41.207] Exporting 5 global objects (0.98 KiB) to cluster node #1 ...
[10:58:41.207] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:41.208] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:41.208] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ...
[10:58:41.208] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ... DONE
[10:58:41.209] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[10:58:41.209] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[10:58:41.209] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:41.209] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:41.209] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:41.210] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:41.210] Exporting 5 global objects (0.98 KiB) to cluster node #1 ... DONE
[10:58:41.210] MultisessionFuture started
[10:58:41.210] - Launch lazy future ... done
[10:58:41.211] run() for ‘MultisessionFuture’ ... done
[10:58:41.211] Created future:
[10:58:41.211] MultisessionFuture:
[10:58:41.211] Label: ‘future_apply-1’
[10:58:41.211] Expression:
[10:58:41.211] {
[10:58:41.211]     do.call(function(...) {
[10:58:41.211]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.211]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.211]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.211]             on.exit(options(oopts), add = TRUE)
[10:58:41.211]         }
[10:58:41.211]         {
[10:58:41.211]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.211]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.211]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.211]             })
[10:58:41.211]         }
[10:58:41.211]     }, args = future.call.arguments)
[10:58:41.211] }
[10:58:41.211] Lazy evaluation: FALSE
[10:58:41.211] Asynchronous evaluation: TRUE
[10:58:41.211] Local evaluation: TRUE
[10:58:41.211] Environment: R_GlobalEnv
[10:58:41.211] Capture standard output: TRUE
[10:58:41.211] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.211] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.211] Packages: 1 packages (‘stats’)
[10:58:41.211] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.211] Resolved: FALSE
[10:58:41.211] Value: <not collected>
[10:58:41.211] Conditions captured: <none>
[10:58:41.211] Early signaling: FALSE
[10:58:41.211] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.211] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.224] Chunk #1 of 2 ... DONE
[10:58:41.224] Chunk #2 of 2 ...
[10:58:41.224]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.224]  - seeds: <none>
[10:58:41.224]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.224] getGlobalsAndPackages() ...
[10:58:41.225] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.225] Resolving globals: FALSE
[10:58:41.225] Tweak future expression to call with '...' arguments ...
[10:58:41.225] {
[10:58:41.225]     do.call(function(...) {
[10:58:41.225]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.225]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.225]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.225]             on.exit(options(oopts), add = TRUE)
[10:58:41.225]         }
[10:58:41.225]         {
[10:58:41.225]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.225]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.225]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.225]             })
[10:58:41.225]         }
[10:58:41.225]     }, args = future.call.arguments)
[10:58:41.225] }
[10:58:41.225] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.225] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.226] - packages: [1] ‘stats’
[10:58:41.226] getGlobalsAndPackages() ... DONE
[10:58:41.226] run() for ‘Future’ ...
[10:58:41.226] - state: ‘created’
[10:58:41.226] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.240] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.241]   - Field: ‘node’
[10:58:41.241]   - Field: ‘label’
[10:58:41.241]   - Field: ‘local’
[10:58:41.241]   - Field: ‘owner’
[10:58:41.241]   - Field: ‘envir’
[10:58:41.241]   - Field: ‘workers’
[10:58:41.241]   - Field: ‘packages’
[10:58:41.241]   - Field: ‘gc’
[10:58:41.241]   - Field: ‘conditions’
[10:58:41.241]   - Field: ‘persistent’
[10:58:41.241]   - Field: ‘expr’
[10:58:41.242]   - Field: ‘uuid’
[10:58:41.242]   - Field: ‘seed’
[10:58:41.242]   - Field: ‘version’
[10:58:41.242]   - Field: ‘result’
[10:58:41.242]   - Field: ‘asynchronous’
[10:58:41.242]   - Field: ‘calls’
[10:58:41.242]   - Field: ‘globals’
[10:58:41.242]   - Field: ‘stdout’
[10:58:41.242]   - Field: ‘earlySignal’
[10:58:41.242]   - Field: ‘lazy’
[10:58:41.242]   - Field: ‘state’
[10:58:41.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.243] - Launch lazy future ...
[10:58:41.243] Packages needed by the future expression (n = 1): ‘stats’
[10:58:41.243] Packages needed by future strategies (n = 0): <none>
[10:58:41.243] {
[10:58:41.243]     {
[10:58:41.243]         {
[10:58:41.243]             ...future.startTime <- base::Sys.time()
[10:58:41.243]             {
[10:58:41.243]                 {
[10:58:41.243]                   {
[10:58:41.243]                     {
[10:58:41.243]                       {
[10:58:41.243]                         base::local({
[10:58:41.243]                           has_future <- base::requireNamespace("future", 
[10:58:41.243]                             quietly = TRUE)
[10:58:41.243]                           if (has_future) {
[10:58:41.243]                             ns <- base::getNamespace("future")
[10:58:41.243]                             version <- ns[[".package"]][["version"]]
[10:58:41.243]                             if (is.null(version)) 
[10:58:41.243]                               version <- utils::packageVersion("future")
[10:58:41.243]                           }
[10:58:41.243]                           else {
[10:58:41.243]                             version <- NULL
[10:58:41.243]                           }
[10:58:41.243]                           if (!has_future || version < "1.8.0") {
[10:58:41.243]                             info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.243]                               "", base::R.version$version.string), 
[10:58:41.243]                               platform = base::sprintf("%s (%s-bit)", 
[10:58:41.243]                                 base::R.version$platform, 8 * 
[10:58:41.243]                                   base::.Machine$sizeof.pointer), 
[10:58:41.243]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.243]                                 "release", "version")], collapse = " "), 
[10:58:41.243]                               hostname = base::Sys.info()[["nodename"]])
[10:58:41.243]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.243]                               info)
[10:58:41.243]                             info <- base::paste(info, collapse = "; ")
[10:58:41.243]                             if (!has_future) {
[10:58:41.243]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.243]                                 info)
[10:58:41.243]                             }
[10:58:41.243]                             else {
[10:58:41.243]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.243]                                 info, version)
[10:58:41.243]                             }
[10:58:41.243]                             base::stop(msg)
[10:58:41.243]                           }
[10:58:41.243]                         })
[10:58:41.243]                       }
[10:58:41.243]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.243]                       base::options(mc.cores = 1L)
[10:58:41.243]                     }
[10:58:41.243]                     base::local({
[10:58:41.243]                       for (pkg in "stats") {
[10:58:41.243]                         base::loadNamespace(pkg)
[10:58:41.243]                         base::library(pkg, character.only = TRUE)
[10:58:41.243]                       }
[10:58:41.243]                     })
[10:58:41.243]                   }
[10:58:41.243]                   ...future.strategy.old <- future::plan("list")
[10:58:41.243]                   options(future.plan = NULL)
[10:58:41.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.243]                 }
[10:58:41.243]                 ...future.workdir <- getwd()
[10:58:41.243]             }
[10:58:41.243]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.243]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.243]         }
[10:58:41.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.243]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.243]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.243]             base::names(...future.oldOptions))
[10:58:41.243]     }
[10:58:41.243]     if (FALSE) {
[10:58:41.243]     }
[10:58:41.243]     else {
[10:58:41.243]         if (TRUE) {
[10:58:41.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.243]                 open = "w")
[10:58:41.243]         }
[10:58:41.243]         else {
[10:58:41.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.243]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.243]         }
[10:58:41.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.243]             base::sink(type = "output", split = FALSE)
[10:58:41.243]             base::close(...future.stdout)
[10:58:41.243]         }, add = TRUE)
[10:58:41.243]     }
[10:58:41.243]     ...future.frame <- base::sys.nframe()
[10:58:41.243]     ...future.conditions <- base::list()
[10:58:41.243]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.243]     if (FALSE) {
[10:58:41.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.243]     }
[10:58:41.243]     ...future.result <- base::tryCatch({
[10:58:41.243]         base::withCallingHandlers({
[10:58:41.243]             ...future.value <- base::withVisible(base::local({
[10:58:41.243]                 ...future.makeSendCondition <- base::local({
[10:58:41.243]                   sendCondition <- NULL
[10:58:41.243]                   function(frame = 1L) {
[10:58:41.243]                     if (is.function(sendCondition)) 
[10:58:41.243]                       return(sendCondition)
[10:58:41.243]                     ns <- getNamespace("parallel")
[10:58:41.243]                     if (exists("sendData", mode = "function", 
[10:58:41.243]                       envir = ns)) {
[10:58:41.243]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.243]                         envir = ns)
[10:58:41.243]                       envir <- sys.frame(frame)
[10:58:41.243]                       master <- NULL
[10:58:41.243]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.243]                         !identical(envir, emptyenv())) {
[10:58:41.243]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.243]                           inherits = FALSE)) {
[10:58:41.243]                           master <- get("master", mode = "list", 
[10:58:41.243]                             envir = envir, inherits = FALSE)
[10:58:41.243]                           if (inherits(master, c("SOCKnode", 
[10:58:41.243]                             "SOCK0node"))) {
[10:58:41.243]                             sendCondition <<- function(cond) {
[10:58:41.243]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.243]                                 success = TRUE)
[10:58:41.243]                               parallel_sendData(master, data)
[10:58:41.243]                             }
[10:58:41.243]                             return(sendCondition)
[10:58:41.243]                           }
[10:58:41.243]                         }
[10:58:41.243]                         frame <- frame + 1L
[10:58:41.243]                         envir <- sys.frame(frame)
[10:58:41.243]                       }
[10:58:41.243]                     }
[10:58:41.243]                     sendCondition <<- function(cond) NULL
[10:58:41.243]                   }
[10:58:41.243]                 })
[10:58:41.243]                 withCallingHandlers({
[10:58:41.243]                   {
[10:58:41.243]                     do.call(function(...) {
[10:58:41.243]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.243]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.243]                         ...future.globals.maxSize)) {
[10:58:41.243]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.243]                         on.exit(options(oopts), add = TRUE)
[10:58:41.243]                       }
[10:58:41.243]                       {
[10:58:41.243]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.243]                           FUN = function(jj) {
[10:58:41.243]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.243]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.243]                           })
[10:58:41.243]                       }
[10:58:41.243]                     }, args = future.call.arguments)
[10:58:41.243]                   }
[10:58:41.243]                 }, immediateCondition = function(cond) {
[10:58:41.243]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.243]                   sendCondition(cond)
[10:58:41.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.243]                   {
[10:58:41.243]                     inherits <- base::inherits
[10:58:41.243]                     invokeRestart <- base::invokeRestart
[10:58:41.243]                     is.null <- base::is.null
[10:58:41.243]                     muffled <- FALSE
[10:58:41.243]                     if (inherits(cond, "message")) {
[10:58:41.243]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.243]                       if (muffled) 
[10:58:41.243]                         invokeRestart("muffleMessage")
[10:58:41.243]                     }
[10:58:41.243]                     else if (inherits(cond, "warning")) {
[10:58:41.243]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.243]                       if (muffled) 
[10:58:41.243]                         invokeRestart("muffleWarning")
[10:58:41.243]                     }
[10:58:41.243]                     else if (inherits(cond, "condition")) {
[10:58:41.243]                       if (!is.null(pattern)) {
[10:58:41.243]                         computeRestarts <- base::computeRestarts
[10:58:41.243]                         grepl <- base::grepl
[10:58:41.243]                         restarts <- computeRestarts(cond)
[10:58:41.243]                         for (restart in restarts) {
[10:58:41.243]                           name <- restart$name
[10:58:41.243]                           if (is.null(name)) 
[10:58:41.243]                             next
[10:58:41.243]                           if (!grepl(pattern, name)) 
[10:58:41.243]                             next
[10:58:41.243]                           invokeRestart(restart)
[10:58:41.243]                           muffled <- TRUE
[10:58:41.243]                           break
[10:58:41.243]                         }
[10:58:41.243]                       }
[10:58:41.243]                     }
[10:58:41.243]                     invisible(muffled)
[10:58:41.243]                   }
[10:58:41.243]                   muffleCondition(cond)
[10:58:41.243]                 })
[10:58:41.243]             }))
[10:58:41.243]             future::FutureResult(value = ...future.value$value, 
[10:58:41.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.243]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.243]                     ...future.globalenv.names))
[10:58:41.243]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.243]         }, condition = base::local({
[10:58:41.243]             c <- base::c
[10:58:41.243]             inherits <- base::inherits
[10:58:41.243]             invokeRestart <- base::invokeRestart
[10:58:41.243]             length <- base::length
[10:58:41.243]             list <- base::list
[10:58:41.243]             seq.int <- base::seq.int
[10:58:41.243]             signalCondition <- base::signalCondition
[10:58:41.243]             sys.calls <- base::sys.calls
[10:58:41.243]             `[[` <- base::`[[`
[10:58:41.243]             `+` <- base::`+`
[10:58:41.243]             `<<-` <- base::`<<-`
[10:58:41.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.243]                   3L)]
[10:58:41.243]             }
[10:58:41.243]             function(cond) {
[10:58:41.243]                 is_error <- inherits(cond, "error")
[10:58:41.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.243]                   NULL)
[10:58:41.243]                 if (is_error) {
[10:58:41.243]                   sessionInformation <- function() {
[10:58:41.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.243]                       search = base::search(), system = base::Sys.info())
[10:58:41.243]                   }
[10:58:41.243]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.243]                     cond$call), session = sessionInformation(), 
[10:58:41.243]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.243]                   signalCondition(cond)
[10:58:41.243]                 }
[10:58:41.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.243]                 "immediateCondition"))) {
[10:58:41.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.243]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.243]                   if (TRUE && !signal) {
[10:58:41.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.243]                     {
[10:58:41.243]                       inherits <- base::inherits
[10:58:41.243]                       invokeRestart <- base::invokeRestart
[10:58:41.243]                       is.null <- base::is.null
[10:58:41.243]                       muffled <- FALSE
[10:58:41.243]                       if (inherits(cond, "message")) {
[10:58:41.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.243]                         if (muffled) 
[10:58:41.243]                           invokeRestart("muffleMessage")
[10:58:41.243]                       }
[10:58:41.243]                       else if (inherits(cond, "warning")) {
[10:58:41.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.243]                         if (muffled) 
[10:58:41.243]                           invokeRestart("muffleWarning")
[10:58:41.243]                       }
[10:58:41.243]                       else if (inherits(cond, "condition")) {
[10:58:41.243]                         if (!is.null(pattern)) {
[10:58:41.243]                           computeRestarts <- base::computeRestarts
[10:58:41.243]                           grepl <- base::grepl
[10:58:41.243]                           restarts <- computeRestarts(cond)
[10:58:41.243]                           for (restart in restarts) {
[10:58:41.243]                             name <- restart$name
[10:58:41.243]                             if (is.null(name)) 
[10:58:41.243]                               next
[10:58:41.243]                             if (!grepl(pattern, name)) 
[10:58:41.243]                               next
[10:58:41.243]                             invokeRestart(restart)
[10:58:41.243]                             muffled <- TRUE
[10:58:41.243]                             break
[10:58:41.243]                           }
[10:58:41.243]                         }
[10:58:41.243]                       }
[10:58:41.243]                       invisible(muffled)
[10:58:41.243]                     }
[10:58:41.243]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.243]                   }
[10:58:41.243]                 }
[10:58:41.243]                 else {
[10:58:41.243]                   if (TRUE) {
[10:58:41.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.243]                     {
[10:58:41.243]                       inherits <- base::inherits
[10:58:41.243]                       invokeRestart <- base::invokeRestart
[10:58:41.243]                       is.null <- base::is.null
[10:58:41.243]                       muffled <- FALSE
[10:58:41.243]                       if (inherits(cond, "message")) {
[10:58:41.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.243]                         if (muffled) 
[10:58:41.243]                           invokeRestart("muffleMessage")
[10:58:41.243]                       }
[10:58:41.243]                       else if (inherits(cond, "warning")) {
[10:58:41.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.243]                         if (muffled) 
[10:58:41.243]                           invokeRestart("muffleWarning")
[10:58:41.243]                       }
[10:58:41.243]                       else if (inherits(cond, "condition")) {
[10:58:41.243]                         if (!is.null(pattern)) {
[10:58:41.243]                           computeRestarts <- base::computeRestarts
[10:58:41.243]                           grepl <- base::grepl
[10:58:41.243]                           restarts <- computeRestarts(cond)
[10:58:41.243]                           for (restart in restarts) {
[10:58:41.243]                             name <- restart$name
[10:58:41.243]                             if (is.null(name)) 
[10:58:41.243]                               next
[10:58:41.243]                             if (!grepl(pattern, name)) 
[10:58:41.243]                               next
[10:58:41.243]                             invokeRestart(restart)
[10:58:41.243]                             muffled <- TRUE
[10:58:41.243]                             break
[10:58:41.243]                           }
[10:58:41.243]                         }
[10:58:41.243]                       }
[10:58:41.243]                       invisible(muffled)
[10:58:41.243]                     }
[10:58:41.243]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.243]                   }
[10:58:41.243]                 }
[10:58:41.243]             }
[10:58:41.243]         }))
[10:58:41.243]     }, error = function(ex) {
[10:58:41.243]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.243]                 ...future.rng), started = ...future.startTime, 
[10:58:41.243]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.243]             version = "1.8"), class = "FutureResult")
[10:58:41.243]     }, finally = {
[10:58:41.243]         if (!identical(...future.workdir, getwd())) 
[10:58:41.243]             setwd(...future.workdir)
[10:58:41.243]         {
[10:58:41.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.243]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.243]             }
[10:58:41.243]             base::options(...future.oldOptions)
[10:58:41.243]             if (.Platform$OS.type == "windows") {
[10:58:41.243]                 old_names <- names(...future.oldEnvVars)
[10:58:41.243]                 envs <- base::Sys.getenv()
[10:58:41.243]                 names <- names(envs)
[10:58:41.243]                 common <- intersect(names, old_names)
[10:58:41.243]                 added <- setdiff(names, old_names)
[10:58:41.243]                 removed <- setdiff(old_names, names)
[10:58:41.243]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.243]                   envs[common]]
[10:58:41.243]                 NAMES <- toupper(changed)
[10:58:41.243]                 args <- list()
[10:58:41.243]                 for (kk in seq_along(NAMES)) {
[10:58:41.243]                   name <- changed[[kk]]
[10:58:41.243]                   NAME <- NAMES[[kk]]
[10:58:41.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.243]                     next
[10:58:41.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.243]                 }
[10:58:41.243]                 NAMES <- toupper(added)
[10:58:41.243]                 for (kk in seq_along(NAMES)) {
[10:58:41.243]                   name <- added[[kk]]
[10:58:41.243]                   NAME <- NAMES[[kk]]
[10:58:41.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.243]                     next
[10:58:41.243]                   args[[name]] <- ""
[10:58:41.243]                 }
[10:58:41.243]                 NAMES <- toupper(removed)
[10:58:41.243]                 for (kk in seq_along(NAMES)) {
[10:58:41.243]                   name <- removed[[kk]]
[10:58:41.243]                   NAME <- NAMES[[kk]]
[10:58:41.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.243]                     next
[10:58:41.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.243]                 }
[10:58:41.243]                 if (length(args) > 0) 
[10:58:41.243]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.243]             }
[10:58:41.243]             else {
[10:58:41.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.243]             }
[10:58:41.243]             {
[10:58:41.243]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.243]                   0L) {
[10:58:41.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.243]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.243]                   base::options(opts)
[10:58:41.243]                 }
[10:58:41.243]                 {
[10:58:41.243]                   {
[10:58:41.243]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.243]                     NULL
[10:58:41.243]                   }
[10:58:41.243]                   options(future.plan = NULL)
[10:58:41.243]                   if (is.na(NA_character_)) 
[10:58:41.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.243]                     .init = FALSE)
[10:58:41.243]                 }
[10:58:41.243]             }
[10:58:41.243]         }
[10:58:41.243]     })
[10:58:41.243]     if (TRUE) {
[10:58:41.243]         base::sink(type = "output", split = FALSE)
[10:58:41.243]         if (TRUE) {
[10:58:41.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.243]         }
[10:58:41.243]         else {
[10:58:41.243]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.243]         }
[10:58:41.243]         base::close(...future.stdout)
[10:58:41.243]         ...future.stdout <- NULL
[10:58:41.243]     }
[10:58:41.243]     ...future.result$conditions <- ...future.conditions
[10:58:41.243]     ...future.result$finished <- base::Sys.time()
[10:58:41.243]     ...future.result
[10:58:41.243] }
[10:58:41.246] Exporting 5 global objects (0.98 KiB) to cluster node #2 ...
[10:58:41.246] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:41.246] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:41.247] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ...
[10:58:41.247] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ... DONE
[10:58:41.247] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[10:58:41.247] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[10:58:41.248] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:41.248] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:41.248] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:41.248] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:41.249] Exporting 5 global objects (0.98 KiB) to cluster node #2 ... DONE
[10:58:41.249] MultisessionFuture started
[10:58:41.249] - Launch lazy future ... done
[10:58:41.249] run() for ‘MultisessionFuture’ ... done
[10:58:41.249] Created future:
[10:58:41.249] MultisessionFuture:
[10:58:41.249] Label: ‘future_apply-2’
[10:58:41.249] Expression:
[10:58:41.249] {
[10:58:41.249]     do.call(function(...) {
[10:58:41.249]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.249]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.249]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.249]             on.exit(options(oopts), add = TRUE)
[10:58:41.249]         }
[10:58:41.249]         {
[10:58:41.249]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.249]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.249]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.249]             })
[10:58:41.249]         }
[10:58:41.249]     }, args = future.call.arguments)
[10:58:41.249] }
[10:58:41.249] Lazy evaluation: FALSE
[10:58:41.249] Asynchronous evaluation: TRUE
[10:58:41.249] Local evaluation: TRUE
[10:58:41.249] Environment: R_GlobalEnv
[10:58:41.249] Capture standard output: TRUE
[10:58:41.249] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.249] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.249] Packages: 1 packages (‘stats’)
[10:58:41.249] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.249] Resolved: FALSE
[10:58:41.249] Value: <not collected>
[10:58:41.249] Conditions captured: <none>
[10:58:41.249] Early signaling: FALSE
[10:58:41.249] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.249] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.261] Chunk #2 of 2 ... DONE
[10:58:41.261] Launching 2 futures (chunks) ... DONE
[10:58:41.261] Resolving 2 futures (chunks) ...
[10:58:41.261] resolve() on list ...
[10:58:41.261]  recursive: 0
[10:58:41.261]  length: 2
[10:58:41.261] 
[10:58:41.262] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.262] - Validating connection of MultisessionFuture
[10:58:41.262] - received message: FutureResult
[10:58:41.262] - Received FutureResult
[10:58:41.262] - Erased future from FutureRegistry
[10:58:41.262] result() for ClusterFuture ...
[10:58:41.262] - result already collected: FutureResult
[10:58:41.262] result() for ClusterFuture ... done
[10:58:41.262] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.263] Future #1
[10:58:41.263] result() for ClusterFuture ...
[10:58:41.263] - result already collected: FutureResult
[10:58:41.263] result() for ClusterFuture ... done
[10:58:41.263] result() for ClusterFuture ...
[10:58:41.263] - result already collected: FutureResult
[10:58:41.263] result() for ClusterFuture ... done
[10:58:41.263] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:41.263] - nx: 2
[10:58:41.263] - relay: TRUE
[10:58:41.263] - stdout: TRUE
[10:58:41.263] - signal: TRUE
[10:58:41.264] - resignal: FALSE
[10:58:41.264] - force: TRUE
[10:58:41.264] - relayed: [n=2] FALSE, FALSE
[10:58:41.264] - queued futures: [n=2] FALSE, FALSE
[10:58:41.264]  - until=1
[10:58:41.264]  - relaying element #1
[10:58:41.264] result() for ClusterFuture ...
[10:58:41.264] - result already collected: FutureResult
[10:58:41.264] result() for ClusterFuture ... done
[10:58:41.264] result() for ClusterFuture ...
[10:58:41.264] - result already collected: FutureResult
[10:58:41.264] result() for ClusterFuture ... done
[10:58:41.265] result() for ClusterFuture ...
[10:58:41.265] - result already collected: FutureResult
[10:58:41.265] result() for ClusterFuture ... done
[10:58:41.265] result() for ClusterFuture ...
[10:58:41.265] - result already collected: FutureResult
[10:58:41.265] result() for ClusterFuture ... done
[10:58:41.265] - relayed: [n=2] TRUE, FALSE
[10:58:41.265] - queued futures: [n=2] TRUE, FALSE
[10:58:41.265] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:41.265]  length: 1 (resolved future 1)
[10:58:41.293] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.293] - Validating connection of MultisessionFuture
[10:58:41.293] - received message: FutureResult
[10:58:41.293] - Received FutureResult
[10:58:41.293] - Erased future from FutureRegistry
[10:58:41.294] result() for ClusterFuture ...
[10:58:41.294] - result already collected: FutureResult
[10:58:41.294] result() for ClusterFuture ... done
[10:58:41.294] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.294] Future #2
[10:58:41.294] result() for ClusterFuture ...
[10:58:41.294] - result already collected: FutureResult
[10:58:41.294] result() for ClusterFuture ... done
[10:58:41.294] result() for ClusterFuture ...
[10:58:41.294] - result already collected: FutureResult
[10:58:41.294] result() for ClusterFuture ... done
[10:58:41.294] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:41.295] - nx: 2
[10:58:41.295] - relay: TRUE
[10:58:41.295] - stdout: TRUE
[10:58:41.295] - signal: TRUE
[10:58:41.295] - resignal: FALSE
[10:58:41.295] - force: TRUE
[10:58:41.295] - relayed: [n=2] TRUE, FALSE
[10:58:41.295] - queued futures: [n=2] TRUE, FALSE
[10:58:41.295]  - until=2
[10:58:41.295]  - relaying element #2
[10:58:41.295] result() for ClusterFuture ...
[10:58:41.295] - result already collected: FutureResult
[10:58:41.296] result() for ClusterFuture ... done
[10:58:41.296] result() for ClusterFuture ...
[10:58:41.296] - result already collected: FutureResult
[10:58:41.296] result() for ClusterFuture ... done
[10:58:41.296] result() for ClusterFuture ...
[10:58:41.296] - result already collected: FutureResult
[10:58:41.296] result() for ClusterFuture ... done
[10:58:41.296] result() for ClusterFuture ...
[10:58:41.296] - result already collected: FutureResult
[10:58:41.296] result() for ClusterFuture ... done
[10:58:41.296] - relayed: [n=2] TRUE, TRUE
[10:58:41.296] - queued futures: [n=2] TRUE, TRUE
[10:58:41.297] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:41.297]  length: 0 (resolved future 2)
[10:58:41.297] Relaying remaining futures
[10:58:41.297] signalConditionsASAP(NULL, pos=0) ...
[10:58:41.297] - nx: 2
[10:58:41.297] - relay: TRUE
[10:58:41.297] - stdout: TRUE
[10:58:41.297] - signal: TRUE
[10:58:41.297] - resignal: FALSE
[10:58:41.297] - force: TRUE
[10:58:41.297] - relayed: [n=2] TRUE, TRUE
[10:58:41.297] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:41.298] - relayed: [n=2] TRUE, TRUE
[10:58:41.298] - queued futures: [n=2] TRUE, TRUE
[10:58:41.298] signalConditionsASAP(NULL, pos=0) ... done
[10:58:41.298] resolve() on list ... DONE
[10:58:41.298] result() for ClusterFuture ...
[10:58:41.298] - result already collected: FutureResult
[10:58:41.298] result() for ClusterFuture ... done
[10:58:41.298] result() for ClusterFuture ...
[10:58:41.298] - result already collected: FutureResult
[10:58:41.298] result() for ClusterFuture ... done
[10:58:41.298] result() for ClusterFuture ...
[10:58:41.298] - result already collected: FutureResult
[10:58:41.299] result() for ClusterFuture ... done
[10:58:41.299] result() for ClusterFuture ...
[10:58:41.299] - result already collected: FutureResult
[10:58:41.299] result() for ClusterFuture ... done
[10:58:41.299]  - Number of value chunks collected: 2
[10:58:41.299] Resolving 2 futures (chunks) ... DONE
[10:58:41.299] Reducing values from 2 chunks ...
[10:58:41.299]  - Number of values collected after concatenation: 2
[10:58:41.299]  - Number of values expected: 2
[10:58:41.299] Reducing values from 2 chunks ... DONE
[10:58:41.299] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:58:41.300] getGlobalsAndPackagesXApply() ...
[10:58:41.300]  - future.globals: TRUE
[10:58:41.300] getGlobalsAndPackages() ...
[10:58:41.300] Searching for globals...
[10:58:41.301] - globals found: [1] ‘FUN’
[10:58:41.301] Searching for globals ... DONE
[10:58:41.301] Resolving globals: FALSE
[10:58:41.302] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:41.302] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:41.302] - globals: [1] ‘FUN’
[10:58:41.302] 
[10:58:41.302] getGlobalsAndPackages() ... DONE
[10:58:41.302]  - globals found/used: [n=1] ‘FUN’
[10:58:41.302]  - needed namespaces: [n=0] 
[10:58:41.303] Finding globals ... DONE
[10:58:41.303]  - use_args: TRUE
[10:58:41.303]  - Getting '...' globals ...
[10:58:41.303] resolve() on list ...
[10:58:41.303]  recursive: 0
[10:58:41.303]  length: 1
[10:58:41.303]  elements: ‘...’
[10:58:41.303]  length: 0 (resolved future 1)
[10:58:41.304] resolve() on list ... DONE
[10:58:41.304]    - '...' content: [n=0] 
[10:58:41.304] List of 1
[10:58:41.304]  $ ...: list()
[10:58:41.304]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.304]  - attr(*, "where")=List of 1
[10:58:41.304]   ..$ ...:<environment: 0x5635c01857e8> 
[10:58:41.304]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.304]  - attr(*, "resolved")= logi TRUE
[10:58:41.304]  - attr(*, "total_size")= num NA
[10:58:41.306]  - Getting '...' globals ... DONE
[10:58:41.306] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:41.306] List of 2
[10:58:41.306]  $ ...future.FUN:function (x)  
[10:58:41.306]  $ ...          : list()
[10:58:41.306]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.306]  - attr(*, "where")=List of 2
[10:58:41.306]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:41.306]   ..$ ...          :<environment: 0x5635c01857e8> 
[10:58:41.306]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.306]  - attr(*, "resolved")= logi FALSE
[10:58:41.306]  - attr(*, "total_size")= num 2624
[10:58:41.309] Packages to be attached in all futures: [n=0] 
[10:58:41.309] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.310] future_lapply() ...
[10:58:41.312] Number of chunks: 2
[10:58:41.312] getGlobalsAndPackagesXApply() ...
[10:58:41.312]  - future.globals: <name-value list> with names ‘list()’
[10:58:41.312]  - use_args: TRUE
[10:58:41.313] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:41.313] List of 2
[10:58:41.313]  $ ...          : list()
[10:58:41.313]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.313]  $ ...future.FUN:function (x)  
[10:58:41.313]  - attr(*, "where")=List of 2
[10:58:41.313]   ..$ ...          :<environment: 0x5635c01857e8> 
[10:58:41.313]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:41.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.313]  - attr(*, "resolved")= logi FALSE
[10:58:41.313]  - attr(*, "total_size")= num NA
[10:58:41.316] Packages to be attached in all futures: [n=0] 
[10:58:41.316] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.316] Number of futures (= number of chunks): 2
[10:58:41.316] Launching 2 futures (chunks) ...
[10:58:41.316] Chunk #1 of 2 ...
[10:58:41.316]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.317]  - seeds: <none>
[10:58:41.317]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.317] getGlobalsAndPackages() ...
[10:58:41.317] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.317] Resolving globals: FALSE
[10:58:41.317] Tweak future expression to call with '...' arguments ...
[10:58:41.317] {
[10:58:41.317]     do.call(function(...) {
[10:58:41.317]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.317]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.317]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.317]             on.exit(options(oopts), add = TRUE)
[10:58:41.317]         }
[10:58:41.317]         {
[10:58:41.317]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.317]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.317]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.317]             })
[10:58:41.317]         }
[10:58:41.317]     }, args = future.call.arguments)
[10:58:41.317] }
[10:58:41.317] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.318] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.318] 
[10:58:41.318] getGlobalsAndPackages() ... DONE
[10:58:41.318] run() for ‘Future’ ...
[10:58:41.318] - state: ‘created’
[10:58:41.318] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.332] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.332]   - Field: ‘node’
[10:58:41.332]   - Field: ‘label’
[10:58:41.332]   - Field: ‘local’
[10:58:41.332]   - Field: ‘owner’
[10:58:41.333]   - Field: ‘envir’
[10:58:41.333]   - Field: ‘workers’
[10:58:41.333]   - Field: ‘packages’
[10:58:41.333]   - Field: ‘gc’
[10:58:41.333]   - Field: ‘conditions’
[10:58:41.333]   - Field: ‘persistent’
[10:58:41.333]   - Field: ‘expr’
[10:58:41.333]   - Field: ‘uuid’
[10:58:41.333]   - Field: ‘seed’
[10:58:41.333]   - Field: ‘version’
[10:58:41.333]   - Field: ‘result’
[10:58:41.334]   - Field: ‘asynchronous’
[10:58:41.334]   - Field: ‘calls’
[10:58:41.334]   - Field: ‘globals’
[10:58:41.334]   - Field: ‘stdout’
[10:58:41.334]   - Field: ‘earlySignal’
[10:58:41.334]   - Field: ‘lazy’
[10:58:41.334]   - Field: ‘state’
[10:58:41.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.334] - Launch lazy future ...
[10:58:41.335] Packages needed by the future expression (n = 0): <none>
[10:58:41.335] Packages needed by future strategies (n = 0): <none>
[10:58:41.335] {
[10:58:41.335]     {
[10:58:41.335]         {
[10:58:41.335]             ...future.startTime <- base::Sys.time()
[10:58:41.335]             {
[10:58:41.335]                 {
[10:58:41.335]                   {
[10:58:41.335]                     {
[10:58:41.335]                       base::local({
[10:58:41.335]                         has_future <- base::requireNamespace("future", 
[10:58:41.335]                           quietly = TRUE)
[10:58:41.335]                         if (has_future) {
[10:58:41.335]                           ns <- base::getNamespace("future")
[10:58:41.335]                           version <- ns[[".package"]][["version"]]
[10:58:41.335]                           if (is.null(version)) 
[10:58:41.335]                             version <- utils::packageVersion("future")
[10:58:41.335]                         }
[10:58:41.335]                         else {
[10:58:41.335]                           version <- NULL
[10:58:41.335]                         }
[10:58:41.335]                         if (!has_future || version < "1.8.0") {
[10:58:41.335]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.335]                             "", base::R.version$version.string), 
[10:58:41.335]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.335]                               "release", "version")], collapse = " "), 
[10:58:41.335]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.335]                             info)
[10:58:41.335]                           info <- base::paste(info, collapse = "; ")
[10:58:41.335]                           if (!has_future) {
[10:58:41.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.335]                               info)
[10:58:41.335]                           }
[10:58:41.335]                           else {
[10:58:41.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.335]                               info, version)
[10:58:41.335]                           }
[10:58:41.335]                           base::stop(msg)
[10:58:41.335]                         }
[10:58:41.335]                       })
[10:58:41.335]                     }
[10:58:41.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.335]                     base::options(mc.cores = 1L)
[10:58:41.335]                   }
[10:58:41.335]                   ...future.strategy.old <- future::plan("list")
[10:58:41.335]                   options(future.plan = NULL)
[10:58:41.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.335]                 }
[10:58:41.335]                 ...future.workdir <- getwd()
[10:58:41.335]             }
[10:58:41.335]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.335]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.335]         }
[10:58:41.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.335]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.335]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.335]             base::names(...future.oldOptions))
[10:58:41.335]     }
[10:58:41.335]     if (FALSE) {
[10:58:41.335]     }
[10:58:41.335]     else {
[10:58:41.335]         if (TRUE) {
[10:58:41.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.335]                 open = "w")
[10:58:41.335]         }
[10:58:41.335]         else {
[10:58:41.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.335]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.335]         }
[10:58:41.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.335]             base::sink(type = "output", split = FALSE)
[10:58:41.335]             base::close(...future.stdout)
[10:58:41.335]         }, add = TRUE)
[10:58:41.335]     }
[10:58:41.335]     ...future.frame <- base::sys.nframe()
[10:58:41.335]     ...future.conditions <- base::list()
[10:58:41.335]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.335]     if (FALSE) {
[10:58:41.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.335]     }
[10:58:41.335]     ...future.result <- base::tryCatch({
[10:58:41.335]         base::withCallingHandlers({
[10:58:41.335]             ...future.value <- base::withVisible(base::local({
[10:58:41.335]                 ...future.makeSendCondition <- base::local({
[10:58:41.335]                   sendCondition <- NULL
[10:58:41.335]                   function(frame = 1L) {
[10:58:41.335]                     if (is.function(sendCondition)) 
[10:58:41.335]                       return(sendCondition)
[10:58:41.335]                     ns <- getNamespace("parallel")
[10:58:41.335]                     if (exists("sendData", mode = "function", 
[10:58:41.335]                       envir = ns)) {
[10:58:41.335]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.335]                         envir = ns)
[10:58:41.335]                       envir <- sys.frame(frame)
[10:58:41.335]                       master <- NULL
[10:58:41.335]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.335]                         !identical(envir, emptyenv())) {
[10:58:41.335]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.335]                           inherits = FALSE)) {
[10:58:41.335]                           master <- get("master", mode = "list", 
[10:58:41.335]                             envir = envir, inherits = FALSE)
[10:58:41.335]                           if (inherits(master, c("SOCKnode", 
[10:58:41.335]                             "SOCK0node"))) {
[10:58:41.335]                             sendCondition <<- function(cond) {
[10:58:41.335]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.335]                                 success = TRUE)
[10:58:41.335]                               parallel_sendData(master, data)
[10:58:41.335]                             }
[10:58:41.335]                             return(sendCondition)
[10:58:41.335]                           }
[10:58:41.335]                         }
[10:58:41.335]                         frame <- frame + 1L
[10:58:41.335]                         envir <- sys.frame(frame)
[10:58:41.335]                       }
[10:58:41.335]                     }
[10:58:41.335]                     sendCondition <<- function(cond) NULL
[10:58:41.335]                   }
[10:58:41.335]                 })
[10:58:41.335]                 withCallingHandlers({
[10:58:41.335]                   {
[10:58:41.335]                     do.call(function(...) {
[10:58:41.335]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.335]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.335]                         ...future.globals.maxSize)) {
[10:58:41.335]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.335]                         on.exit(options(oopts), add = TRUE)
[10:58:41.335]                       }
[10:58:41.335]                       {
[10:58:41.335]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.335]                           FUN = function(jj) {
[10:58:41.335]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.335]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.335]                           })
[10:58:41.335]                       }
[10:58:41.335]                     }, args = future.call.arguments)
[10:58:41.335]                   }
[10:58:41.335]                 }, immediateCondition = function(cond) {
[10:58:41.335]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.335]                   sendCondition(cond)
[10:58:41.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.335]                   {
[10:58:41.335]                     inherits <- base::inherits
[10:58:41.335]                     invokeRestart <- base::invokeRestart
[10:58:41.335]                     is.null <- base::is.null
[10:58:41.335]                     muffled <- FALSE
[10:58:41.335]                     if (inherits(cond, "message")) {
[10:58:41.335]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.335]                       if (muffled) 
[10:58:41.335]                         invokeRestart("muffleMessage")
[10:58:41.335]                     }
[10:58:41.335]                     else if (inherits(cond, "warning")) {
[10:58:41.335]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.335]                       if (muffled) 
[10:58:41.335]                         invokeRestart("muffleWarning")
[10:58:41.335]                     }
[10:58:41.335]                     else if (inherits(cond, "condition")) {
[10:58:41.335]                       if (!is.null(pattern)) {
[10:58:41.335]                         computeRestarts <- base::computeRestarts
[10:58:41.335]                         grepl <- base::grepl
[10:58:41.335]                         restarts <- computeRestarts(cond)
[10:58:41.335]                         for (restart in restarts) {
[10:58:41.335]                           name <- restart$name
[10:58:41.335]                           if (is.null(name)) 
[10:58:41.335]                             next
[10:58:41.335]                           if (!grepl(pattern, name)) 
[10:58:41.335]                             next
[10:58:41.335]                           invokeRestart(restart)
[10:58:41.335]                           muffled <- TRUE
[10:58:41.335]                           break
[10:58:41.335]                         }
[10:58:41.335]                       }
[10:58:41.335]                     }
[10:58:41.335]                     invisible(muffled)
[10:58:41.335]                   }
[10:58:41.335]                   muffleCondition(cond)
[10:58:41.335]                 })
[10:58:41.335]             }))
[10:58:41.335]             future::FutureResult(value = ...future.value$value, 
[10:58:41.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.335]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.335]                     ...future.globalenv.names))
[10:58:41.335]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.335]         }, condition = base::local({
[10:58:41.335]             c <- base::c
[10:58:41.335]             inherits <- base::inherits
[10:58:41.335]             invokeRestart <- base::invokeRestart
[10:58:41.335]             length <- base::length
[10:58:41.335]             list <- base::list
[10:58:41.335]             seq.int <- base::seq.int
[10:58:41.335]             signalCondition <- base::signalCondition
[10:58:41.335]             sys.calls <- base::sys.calls
[10:58:41.335]             `[[` <- base::`[[`
[10:58:41.335]             `+` <- base::`+`
[10:58:41.335]             `<<-` <- base::`<<-`
[10:58:41.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.335]                   3L)]
[10:58:41.335]             }
[10:58:41.335]             function(cond) {
[10:58:41.335]                 is_error <- inherits(cond, "error")
[10:58:41.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.335]                   NULL)
[10:58:41.335]                 if (is_error) {
[10:58:41.335]                   sessionInformation <- function() {
[10:58:41.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.335]                       search = base::search(), system = base::Sys.info())
[10:58:41.335]                   }
[10:58:41.335]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.335]                     cond$call), session = sessionInformation(), 
[10:58:41.335]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.335]                   signalCondition(cond)
[10:58:41.335]                 }
[10:58:41.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.335]                 "immediateCondition"))) {
[10:58:41.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.335]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.335]                   if (TRUE && !signal) {
[10:58:41.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.335]                     {
[10:58:41.335]                       inherits <- base::inherits
[10:58:41.335]                       invokeRestart <- base::invokeRestart
[10:58:41.335]                       is.null <- base::is.null
[10:58:41.335]                       muffled <- FALSE
[10:58:41.335]                       if (inherits(cond, "message")) {
[10:58:41.335]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.335]                         if (muffled) 
[10:58:41.335]                           invokeRestart("muffleMessage")
[10:58:41.335]                       }
[10:58:41.335]                       else if (inherits(cond, "warning")) {
[10:58:41.335]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.335]                         if (muffled) 
[10:58:41.335]                           invokeRestart("muffleWarning")
[10:58:41.335]                       }
[10:58:41.335]                       else if (inherits(cond, "condition")) {
[10:58:41.335]                         if (!is.null(pattern)) {
[10:58:41.335]                           computeRestarts <- base::computeRestarts
[10:58:41.335]                           grepl <- base::grepl
[10:58:41.335]                           restarts <- computeRestarts(cond)
[10:58:41.335]                           for (restart in restarts) {
[10:58:41.335]                             name <- restart$name
[10:58:41.335]                             if (is.null(name)) 
[10:58:41.335]                               next
[10:58:41.335]                             if (!grepl(pattern, name)) 
[10:58:41.335]                               next
[10:58:41.335]                             invokeRestart(restart)
[10:58:41.335]                             muffled <- TRUE
[10:58:41.335]                             break
[10:58:41.335]                           }
[10:58:41.335]                         }
[10:58:41.335]                       }
[10:58:41.335]                       invisible(muffled)
[10:58:41.335]                     }
[10:58:41.335]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.335]                   }
[10:58:41.335]                 }
[10:58:41.335]                 else {
[10:58:41.335]                   if (TRUE) {
[10:58:41.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.335]                     {
[10:58:41.335]                       inherits <- base::inherits
[10:58:41.335]                       invokeRestart <- base::invokeRestart
[10:58:41.335]                       is.null <- base::is.null
[10:58:41.335]                       muffled <- FALSE
[10:58:41.335]                       if (inherits(cond, "message")) {
[10:58:41.335]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.335]                         if (muffled) 
[10:58:41.335]                           invokeRestart("muffleMessage")
[10:58:41.335]                       }
[10:58:41.335]                       else if (inherits(cond, "warning")) {
[10:58:41.335]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.335]                         if (muffled) 
[10:58:41.335]                           invokeRestart("muffleWarning")
[10:58:41.335]                       }
[10:58:41.335]                       else if (inherits(cond, "condition")) {
[10:58:41.335]                         if (!is.null(pattern)) {
[10:58:41.335]                           computeRestarts <- base::computeRestarts
[10:58:41.335]                           grepl <- base::grepl
[10:58:41.335]                           restarts <- computeRestarts(cond)
[10:58:41.335]                           for (restart in restarts) {
[10:58:41.335]                             name <- restart$name
[10:58:41.335]                             if (is.null(name)) 
[10:58:41.335]                               next
[10:58:41.335]                             if (!grepl(pattern, name)) 
[10:58:41.335]                               next
[10:58:41.335]                             invokeRestart(restart)
[10:58:41.335]                             muffled <- TRUE
[10:58:41.335]                             break
[10:58:41.335]                           }
[10:58:41.335]                         }
[10:58:41.335]                       }
[10:58:41.335]                       invisible(muffled)
[10:58:41.335]                     }
[10:58:41.335]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.335]                   }
[10:58:41.335]                 }
[10:58:41.335]             }
[10:58:41.335]         }))
[10:58:41.335]     }, error = function(ex) {
[10:58:41.335]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.335]                 ...future.rng), started = ...future.startTime, 
[10:58:41.335]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.335]             version = "1.8"), class = "FutureResult")
[10:58:41.335]     }, finally = {
[10:58:41.335]         if (!identical(...future.workdir, getwd())) 
[10:58:41.335]             setwd(...future.workdir)
[10:58:41.335]         {
[10:58:41.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.335]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.335]             }
[10:58:41.335]             base::options(...future.oldOptions)
[10:58:41.335]             if (.Platform$OS.type == "windows") {
[10:58:41.335]                 old_names <- names(...future.oldEnvVars)
[10:58:41.335]                 envs <- base::Sys.getenv()
[10:58:41.335]                 names <- names(envs)
[10:58:41.335]                 common <- intersect(names, old_names)
[10:58:41.335]                 added <- setdiff(names, old_names)
[10:58:41.335]                 removed <- setdiff(old_names, names)
[10:58:41.335]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.335]                   envs[common]]
[10:58:41.335]                 NAMES <- toupper(changed)
[10:58:41.335]                 args <- list()
[10:58:41.335]                 for (kk in seq_along(NAMES)) {
[10:58:41.335]                   name <- changed[[kk]]
[10:58:41.335]                   NAME <- NAMES[[kk]]
[10:58:41.335]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.335]                     next
[10:58:41.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.335]                 }
[10:58:41.335]                 NAMES <- toupper(added)
[10:58:41.335]                 for (kk in seq_along(NAMES)) {
[10:58:41.335]                   name <- added[[kk]]
[10:58:41.335]                   NAME <- NAMES[[kk]]
[10:58:41.335]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.335]                     next
[10:58:41.335]                   args[[name]] <- ""
[10:58:41.335]                 }
[10:58:41.335]                 NAMES <- toupper(removed)
[10:58:41.335]                 for (kk in seq_along(NAMES)) {
[10:58:41.335]                   name <- removed[[kk]]
[10:58:41.335]                   NAME <- NAMES[[kk]]
[10:58:41.335]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.335]                     next
[10:58:41.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.335]                 }
[10:58:41.335]                 if (length(args) > 0) 
[10:58:41.335]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.335]             }
[10:58:41.335]             else {
[10:58:41.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.335]             }
[10:58:41.335]             {
[10:58:41.335]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.335]                   0L) {
[10:58:41.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.335]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.335]                   base::options(opts)
[10:58:41.335]                 }
[10:58:41.335]                 {
[10:58:41.335]                   {
[10:58:41.335]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.335]                     NULL
[10:58:41.335]                   }
[10:58:41.335]                   options(future.plan = NULL)
[10:58:41.335]                   if (is.na(NA_character_)) 
[10:58:41.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.335]                     .init = FALSE)
[10:58:41.335]                 }
[10:58:41.335]             }
[10:58:41.335]         }
[10:58:41.335]     })
[10:58:41.335]     if (TRUE) {
[10:58:41.335]         base::sink(type = "output", split = FALSE)
[10:58:41.335]         if (TRUE) {
[10:58:41.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.335]         }
[10:58:41.335]         else {
[10:58:41.335]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.335]         }
[10:58:41.335]         base::close(...future.stdout)
[10:58:41.335]         ...future.stdout <- NULL
[10:58:41.335]     }
[10:58:41.335]     ...future.result$conditions <- ...future.conditions
[10:58:41.335]     ...future.result$finished <- base::Sys.time()
[10:58:41.335]     ...future.result
[10:58:41.335] }
[10:58:41.338] Exporting 5 global objects (914 bytes) to cluster node #1 ...
[10:58:41.338] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:41.338] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:41.338] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:58:41.339] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:58:41.339] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ...
[10:58:41.339] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ... DONE
[10:58:41.339] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:41.340] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:41.340] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:41.340] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:41.340] Exporting 5 global objects (914 bytes) to cluster node #1 ... DONE
[10:58:41.341] MultisessionFuture started
[10:58:41.341] - Launch lazy future ... done
[10:58:41.341] run() for ‘MultisessionFuture’ ... done
[10:58:41.341] Created future:
[10:58:41.341] MultisessionFuture:
[10:58:41.341] Label: ‘future_apply-1’
[10:58:41.341] Expression:
[10:58:41.341] {
[10:58:41.341]     do.call(function(...) {
[10:58:41.341]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.341]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.341]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.341]             on.exit(options(oopts), add = TRUE)
[10:58:41.341]         }
[10:58:41.341]         {
[10:58:41.341]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.341]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.341]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.341]             })
[10:58:41.341]         }
[10:58:41.341]     }, args = future.call.arguments)
[10:58:41.341] }
[10:58:41.341] Lazy evaluation: FALSE
[10:58:41.341] Asynchronous evaluation: TRUE
[10:58:41.341] Local evaluation: TRUE
[10:58:41.341] Environment: R_GlobalEnv
[10:58:41.341] Capture standard output: TRUE
[10:58:41.341] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.341] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.341] Packages: <none>
[10:58:41.341] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.341] Resolved: FALSE
[10:58:41.341] Value: <not collected>
[10:58:41.341] Conditions captured: <none>
[10:58:41.341] Early signaling: FALSE
[10:58:41.341] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.341] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.352] Chunk #1 of 2 ... DONE
[10:58:41.352] Chunk #2 of 2 ...
[10:58:41.353]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.353]  - seeds: <none>
[10:58:41.353]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.353] getGlobalsAndPackages() ...
[10:58:41.353] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.353] Resolving globals: FALSE
[10:58:41.353] Tweak future expression to call with '...' arguments ...
[10:58:41.353] {
[10:58:41.353]     do.call(function(...) {
[10:58:41.353]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.353]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.353]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.353]             on.exit(options(oopts), add = TRUE)
[10:58:41.353]         }
[10:58:41.353]         {
[10:58:41.353]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.353]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.353]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.353]             })
[10:58:41.353]         }
[10:58:41.353]     }, args = future.call.arguments)
[10:58:41.353] }
[10:58:41.354] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.354] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.354] 
[10:58:41.354] getGlobalsAndPackages() ... DONE
[10:58:41.354] run() for ‘Future’ ...
[10:58:41.354] - state: ‘created’
[10:58:41.355] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.368] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.368] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.368]   - Field: ‘node’
[10:58:41.368]   - Field: ‘label’
[10:58:41.369]   - Field: ‘local’
[10:58:41.369]   - Field: ‘owner’
[10:58:41.369]   - Field: ‘envir’
[10:58:41.369]   - Field: ‘workers’
[10:58:41.369]   - Field: ‘packages’
[10:58:41.369]   - Field: ‘gc’
[10:58:41.369]   - Field: ‘conditions’
[10:58:41.369]   - Field: ‘persistent’
[10:58:41.369]   - Field: ‘expr’
[10:58:41.369]   - Field: ‘uuid’
[10:58:41.369]   - Field: ‘seed’
[10:58:41.370]   - Field: ‘version’
[10:58:41.370]   - Field: ‘result’
[10:58:41.370]   - Field: ‘asynchronous’
[10:58:41.370]   - Field: ‘calls’
[10:58:41.370]   - Field: ‘globals’
[10:58:41.370]   - Field: ‘stdout’
[10:58:41.370]   - Field: ‘earlySignal’
[10:58:41.370]   - Field: ‘lazy’
[10:58:41.370]   - Field: ‘state’
[10:58:41.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.370] - Launch lazy future ...
[10:58:41.371] Packages needed by the future expression (n = 0): <none>
[10:58:41.371] Packages needed by future strategies (n = 0): <none>
[10:58:41.371] {
[10:58:41.371]     {
[10:58:41.371]         {
[10:58:41.371]             ...future.startTime <- base::Sys.time()
[10:58:41.371]             {
[10:58:41.371]                 {
[10:58:41.371]                   {
[10:58:41.371]                     {
[10:58:41.371]                       base::local({
[10:58:41.371]                         has_future <- base::requireNamespace("future", 
[10:58:41.371]                           quietly = TRUE)
[10:58:41.371]                         if (has_future) {
[10:58:41.371]                           ns <- base::getNamespace("future")
[10:58:41.371]                           version <- ns[[".package"]][["version"]]
[10:58:41.371]                           if (is.null(version)) 
[10:58:41.371]                             version <- utils::packageVersion("future")
[10:58:41.371]                         }
[10:58:41.371]                         else {
[10:58:41.371]                           version <- NULL
[10:58:41.371]                         }
[10:58:41.371]                         if (!has_future || version < "1.8.0") {
[10:58:41.371]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.371]                             "", base::R.version$version.string), 
[10:58:41.371]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.371]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.371]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.371]                               "release", "version")], collapse = " "), 
[10:58:41.371]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.371]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.371]                             info)
[10:58:41.371]                           info <- base::paste(info, collapse = "; ")
[10:58:41.371]                           if (!has_future) {
[10:58:41.371]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.371]                               info)
[10:58:41.371]                           }
[10:58:41.371]                           else {
[10:58:41.371]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.371]                               info, version)
[10:58:41.371]                           }
[10:58:41.371]                           base::stop(msg)
[10:58:41.371]                         }
[10:58:41.371]                       })
[10:58:41.371]                     }
[10:58:41.371]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.371]                     base::options(mc.cores = 1L)
[10:58:41.371]                   }
[10:58:41.371]                   ...future.strategy.old <- future::plan("list")
[10:58:41.371]                   options(future.plan = NULL)
[10:58:41.371]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.371]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.371]                 }
[10:58:41.371]                 ...future.workdir <- getwd()
[10:58:41.371]             }
[10:58:41.371]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.371]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.371]         }
[10:58:41.371]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.371]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.371]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.371]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.371]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.371]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.371]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.371]             base::names(...future.oldOptions))
[10:58:41.371]     }
[10:58:41.371]     if (FALSE) {
[10:58:41.371]     }
[10:58:41.371]     else {
[10:58:41.371]         if (TRUE) {
[10:58:41.371]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.371]                 open = "w")
[10:58:41.371]         }
[10:58:41.371]         else {
[10:58:41.371]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.371]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.371]         }
[10:58:41.371]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.371]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.371]             base::sink(type = "output", split = FALSE)
[10:58:41.371]             base::close(...future.stdout)
[10:58:41.371]         }, add = TRUE)
[10:58:41.371]     }
[10:58:41.371]     ...future.frame <- base::sys.nframe()
[10:58:41.371]     ...future.conditions <- base::list()
[10:58:41.371]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.371]     if (FALSE) {
[10:58:41.371]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.371]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.371]     }
[10:58:41.371]     ...future.result <- base::tryCatch({
[10:58:41.371]         base::withCallingHandlers({
[10:58:41.371]             ...future.value <- base::withVisible(base::local({
[10:58:41.371]                 ...future.makeSendCondition <- base::local({
[10:58:41.371]                   sendCondition <- NULL
[10:58:41.371]                   function(frame = 1L) {
[10:58:41.371]                     if (is.function(sendCondition)) 
[10:58:41.371]                       return(sendCondition)
[10:58:41.371]                     ns <- getNamespace("parallel")
[10:58:41.371]                     if (exists("sendData", mode = "function", 
[10:58:41.371]                       envir = ns)) {
[10:58:41.371]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.371]                         envir = ns)
[10:58:41.371]                       envir <- sys.frame(frame)
[10:58:41.371]                       master <- NULL
[10:58:41.371]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.371]                         !identical(envir, emptyenv())) {
[10:58:41.371]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.371]                           inherits = FALSE)) {
[10:58:41.371]                           master <- get("master", mode = "list", 
[10:58:41.371]                             envir = envir, inherits = FALSE)
[10:58:41.371]                           if (inherits(master, c("SOCKnode", 
[10:58:41.371]                             "SOCK0node"))) {
[10:58:41.371]                             sendCondition <<- function(cond) {
[10:58:41.371]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.371]                                 success = TRUE)
[10:58:41.371]                               parallel_sendData(master, data)
[10:58:41.371]                             }
[10:58:41.371]                             return(sendCondition)
[10:58:41.371]                           }
[10:58:41.371]                         }
[10:58:41.371]                         frame <- frame + 1L
[10:58:41.371]                         envir <- sys.frame(frame)
[10:58:41.371]                       }
[10:58:41.371]                     }
[10:58:41.371]                     sendCondition <<- function(cond) NULL
[10:58:41.371]                   }
[10:58:41.371]                 })
[10:58:41.371]                 withCallingHandlers({
[10:58:41.371]                   {
[10:58:41.371]                     do.call(function(...) {
[10:58:41.371]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.371]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.371]                         ...future.globals.maxSize)) {
[10:58:41.371]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.371]                         on.exit(options(oopts), add = TRUE)
[10:58:41.371]                       }
[10:58:41.371]                       {
[10:58:41.371]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.371]                           FUN = function(jj) {
[10:58:41.371]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.371]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.371]                           })
[10:58:41.371]                       }
[10:58:41.371]                     }, args = future.call.arguments)
[10:58:41.371]                   }
[10:58:41.371]                 }, immediateCondition = function(cond) {
[10:58:41.371]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.371]                   sendCondition(cond)
[10:58:41.371]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.371]                   {
[10:58:41.371]                     inherits <- base::inherits
[10:58:41.371]                     invokeRestart <- base::invokeRestart
[10:58:41.371]                     is.null <- base::is.null
[10:58:41.371]                     muffled <- FALSE
[10:58:41.371]                     if (inherits(cond, "message")) {
[10:58:41.371]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.371]                       if (muffled) 
[10:58:41.371]                         invokeRestart("muffleMessage")
[10:58:41.371]                     }
[10:58:41.371]                     else if (inherits(cond, "warning")) {
[10:58:41.371]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.371]                       if (muffled) 
[10:58:41.371]                         invokeRestart("muffleWarning")
[10:58:41.371]                     }
[10:58:41.371]                     else if (inherits(cond, "condition")) {
[10:58:41.371]                       if (!is.null(pattern)) {
[10:58:41.371]                         computeRestarts <- base::computeRestarts
[10:58:41.371]                         grepl <- base::grepl
[10:58:41.371]                         restarts <- computeRestarts(cond)
[10:58:41.371]                         for (restart in restarts) {
[10:58:41.371]                           name <- restart$name
[10:58:41.371]                           if (is.null(name)) 
[10:58:41.371]                             next
[10:58:41.371]                           if (!grepl(pattern, name)) 
[10:58:41.371]                             next
[10:58:41.371]                           invokeRestart(restart)
[10:58:41.371]                           muffled <- TRUE
[10:58:41.371]                           break
[10:58:41.371]                         }
[10:58:41.371]                       }
[10:58:41.371]                     }
[10:58:41.371]                     invisible(muffled)
[10:58:41.371]                   }
[10:58:41.371]                   muffleCondition(cond)
[10:58:41.371]                 })
[10:58:41.371]             }))
[10:58:41.371]             future::FutureResult(value = ...future.value$value, 
[10:58:41.371]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.371]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.371]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.371]                     ...future.globalenv.names))
[10:58:41.371]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.371]         }, condition = base::local({
[10:58:41.371]             c <- base::c
[10:58:41.371]             inherits <- base::inherits
[10:58:41.371]             invokeRestart <- base::invokeRestart
[10:58:41.371]             length <- base::length
[10:58:41.371]             list <- base::list
[10:58:41.371]             seq.int <- base::seq.int
[10:58:41.371]             signalCondition <- base::signalCondition
[10:58:41.371]             sys.calls <- base::sys.calls
[10:58:41.371]             `[[` <- base::`[[`
[10:58:41.371]             `+` <- base::`+`
[10:58:41.371]             `<<-` <- base::`<<-`
[10:58:41.371]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.371]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.371]                   3L)]
[10:58:41.371]             }
[10:58:41.371]             function(cond) {
[10:58:41.371]                 is_error <- inherits(cond, "error")
[10:58:41.371]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.371]                   NULL)
[10:58:41.371]                 if (is_error) {
[10:58:41.371]                   sessionInformation <- function() {
[10:58:41.371]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.371]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.371]                       search = base::search(), system = base::Sys.info())
[10:58:41.371]                   }
[10:58:41.371]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.371]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.371]                     cond$call), session = sessionInformation(), 
[10:58:41.371]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.371]                   signalCondition(cond)
[10:58:41.371]                 }
[10:58:41.371]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.371]                 "immediateCondition"))) {
[10:58:41.371]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.371]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.371]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.371]                   if (TRUE && !signal) {
[10:58:41.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.371]                     {
[10:58:41.371]                       inherits <- base::inherits
[10:58:41.371]                       invokeRestart <- base::invokeRestart
[10:58:41.371]                       is.null <- base::is.null
[10:58:41.371]                       muffled <- FALSE
[10:58:41.371]                       if (inherits(cond, "message")) {
[10:58:41.371]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.371]                         if (muffled) 
[10:58:41.371]                           invokeRestart("muffleMessage")
[10:58:41.371]                       }
[10:58:41.371]                       else if (inherits(cond, "warning")) {
[10:58:41.371]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.371]                         if (muffled) 
[10:58:41.371]                           invokeRestart("muffleWarning")
[10:58:41.371]                       }
[10:58:41.371]                       else if (inherits(cond, "condition")) {
[10:58:41.371]                         if (!is.null(pattern)) {
[10:58:41.371]                           computeRestarts <- base::computeRestarts
[10:58:41.371]                           grepl <- base::grepl
[10:58:41.371]                           restarts <- computeRestarts(cond)
[10:58:41.371]                           for (restart in restarts) {
[10:58:41.371]                             name <- restart$name
[10:58:41.371]                             if (is.null(name)) 
[10:58:41.371]                               next
[10:58:41.371]                             if (!grepl(pattern, name)) 
[10:58:41.371]                               next
[10:58:41.371]                             invokeRestart(restart)
[10:58:41.371]                             muffled <- TRUE
[10:58:41.371]                             break
[10:58:41.371]                           }
[10:58:41.371]                         }
[10:58:41.371]                       }
[10:58:41.371]                       invisible(muffled)
[10:58:41.371]                     }
[10:58:41.371]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.371]                   }
[10:58:41.371]                 }
[10:58:41.371]                 else {
[10:58:41.371]                   if (TRUE) {
[10:58:41.371]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.371]                     {
[10:58:41.371]                       inherits <- base::inherits
[10:58:41.371]                       invokeRestart <- base::invokeRestart
[10:58:41.371]                       is.null <- base::is.null
[10:58:41.371]                       muffled <- FALSE
[10:58:41.371]                       if (inherits(cond, "message")) {
[10:58:41.371]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.371]                         if (muffled) 
[10:58:41.371]                           invokeRestart("muffleMessage")
[10:58:41.371]                       }
[10:58:41.371]                       else if (inherits(cond, "warning")) {
[10:58:41.371]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.371]                         if (muffled) 
[10:58:41.371]                           invokeRestart("muffleWarning")
[10:58:41.371]                       }
[10:58:41.371]                       else if (inherits(cond, "condition")) {
[10:58:41.371]                         if (!is.null(pattern)) {
[10:58:41.371]                           computeRestarts <- base::computeRestarts
[10:58:41.371]                           grepl <- base::grepl
[10:58:41.371]                           restarts <- computeRestarts(cond)
[10:58:41.371]                           for (restart in restarts) {
[10:58:41.371]                             name <- restart$name
[10:58:41.371]                             if (is.null(name)) 
[10:58:41.371]                               next
[10:58:41.371]                             if (!grepl(pattern, name)) 
[10:58:41.371]                               next
[10:58:41.371]                             invokeRestart(restart)
[10:58:41.371]                             muffled <- TRUE
[10:58:41.371]                             break
[10:58:41.371]                           }
[10:58:41.371]                         }
[10:58:41.371]                       }
[10:58:41.371]                       invisible(muffled)
[10:58:41.371]                     }
[10:58:41.371]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.371]                   }
[10:58:41.371]                 }
[10:58:41.371]             }
[10:58:41.371]         }))
[10:58:41.371]     }, error = function(ex) {
[10:58:41.371]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.371]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.371]                 ...future.rng), started = ...future.startTime, 
[10:58:41.371]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.371]             version = "1.8"), class = "FutureResult")
[10:58:41.371]     }, finally = {
[10:58:41.371]         if (!identical(...future.workdir, getwd())) 
[10:58:41.371]             setwd(...future.workdir)
[10:58:41.371]         {
[10:58:41.371]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.371]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.371]             }
[10:58:41.371]             base::options(...future.oldOptions)
[10:58:41.371]             if (.Platform$OS.type == "windows") {
[10:58:41.371]                 old_names <- names(...future.oldEnvVars)
[10:58:41.371]                 envs <- base::Sys.getenv()
[10:58:41.371]                 names <- names(envs)
[10:58:41.371]                 common <- intersect(names, old_names)
[10:58:41.371]                 added <- setdiff(names, old_names)
[10:58:41.371]                 removed <- setdiff(old_names, names)
[10:58:41.371]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.371]                   envs[common]]
[10:58:41.371]                 NAMES <- toupper(changed)
[10:58:41.371]                 args <- list()
[10:58:41.371]                 for (kk in seq_along(NAMES)) {
[10:58:41.371]                   name <- changed[[kk]]
[10:58:41.371]                   NAME <- NAMES[[kk]]
[10:58:41.371]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.371]                     next
[10:58:41.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.371]                 }
[10:58:41.371]                 NAMES <- toupper(added)
[10:58:41.371]                 for (kk in seq_along(NAMES)) {
[10:58:41.371]                   name <- added[[kk]]
[10:58:41.371]                   NAME <- NAMES[[kk]]
[10:58:41.371]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.371]                     next
[10:58:41.371]                   args[[name]] <- ""
[10:58:41.371]                 }
[10:58:41.371]                 NAMES <- toupper(removed)
[10:58:41.371]                 for (kk in seq_along(NAMES)) {
[10:58:41.371]                   name <- removed[[kk]]
[10:58:41.371]                   NAME <- NAMES[[kk]]
[10:58:41.371]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.371]                     next
[10:58:41.371]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.371]                 }
[10:58:41.371]                 if (length(args) > 0) 
[10:58:41.371]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.371]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.371]             }
[10:58:41.371]             else {
[10:58:41.371]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.371]             }
[10:58:41.371]             {
[10:58:41.371]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.371]                   0L) {
[10:58:41.371]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.371]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.371]                   base::options(opts)
[10:58:41.371]                 }
[10:58:41.371]                 {
[10:58:41.371]                   {
[10:58:41.371]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.371]                     NULL
[10:58:41.371]                   }
[10:58:41.371]                   options(future.plan = NULL)
[10:58:41.371]                   if (is.na(NA_character_)) 
[10:58:41.371]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.371]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.371]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.371]                     .init = FALSE)
[10:58:41.371]                 }
[10:58:41.371]             }
[10:58:41.371]         }
[10:58:41.371]     })
[10:58:41.371]     if (TRUE) {
[10:58:41.371]         base::sink(type = "output", split = FALSE)
[10:58:41.371]         if (TRUE) {
[10:58:41.371]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.371]         }
[10:58:41.371]         else {
[10:58:41.371]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.371]         }
[10:58:41.371]         base::close(...future.stdout)
[10:58:41.371]         ...future.stdout <- NULL
[10:58:41.371]     }
[10:58:41.371]     ...future.result$conditions <- ...future.conditions
[10:58:41.371]     ...future.result$finished <- base::Sys.time()
[10:58:41.371]     ...future.result
[10:58:41.371] }
[10:58:41.374] Exporting 5 global objects (914 bytes) to cluster node #2 ...
[10:58:41.374] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:41.374] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:41.374] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:58:41.375] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:58:41.375] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ...
[10:58:41.375] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ... DONE
[10:58:41.375] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:41.376] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:41.376] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:41.376] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:41.376] Exporting 5 global objects (914 bytes) to cluster node #2 ... DONE
[10:58:41.377] MultisessionFuture started
[10:58:41.377] - Launch lazy future ... done
[10:58:41.377] run() for ‘MultisessionFuture’ ... done
[10:58:41.377] Created future:
[10:58:41.377] MultisessionFuture:
[10:58:41.377] Label: ‘future_apply-2’
[10:58:41.377] Expression:
[10:58:41.377] {
[10:58:41.377]     do.call(function(...) {
[10:58:41.377]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.377]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.377]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.377]             on.exit(options(oopts), add = TRUE)
[10:58:41.377]         }
[10:58:41.377]         {
[10:58:41.377]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.377]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.377]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.377]             })
[10:58:41.377]         }
[10:58:41.377]     }, args = future.call.arguments)
[10:58:41.377] }
[10:58:41.377] Lazy evaluation: FALSE
[10:58:41.377] Asynchronous evaluation: TRUE
[10:58:41.377] Local evaluation: TRUE
[10:58:41.377] Environment: R_GlobalEnv
[10:58:41.377] Capture standard output: TRUE
[10:58:41.377] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.377] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.377] Packages: <none>
[10:58:41.377] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.377] Resolved: FALSE
[10:58:41.377] Value: <not collected>
[10:58:41.377] Conditions captured: <none>
[10:58:41.377] Early signaling: FALSE
[10:58:41.377] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.377] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.389] Chunk #2 of 2 ... DONE
[10:58:41.389] Launching 2 futures (chunks) ... DONE
[10:58:41.389] Resolving 2 futures (chunks) ...
[10:58:41.389] resolve() on list ...
[10:58:41.389]  recursive: 0
[10:58:41.389]  length: 2
[10:58:41.389] 
[10:58:41.390] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.390] - Validating connection of MultisessionFuture
[10:58:41.390] - received message: FutureResult
[10:58:41.390] - Received FutureResult
[10:58:41.390] - Erased future from FutureRegistry
[10:58:41.390] result() for ClusterFuture ...
[10:58:41.390] - result already collected: FutureResult
[10:58:41.390] result() for ClusterFuture ... done
[10:58:41.391] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.391] Future #1
[10:58:41.391] result() for ClusterFuture ...
[10:58:41.391] - result already collected: FutureResult
[10:58:41.391] result() for ClusterFuture ... done
[10:58:41.391] result() for ClusterFuture ...
[10:58:41.391] - result already collected: FutureResult
[10:58:41.391] result() for ClusterFuture ... done
[10:58:41.391] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:41.391] - nx: 2
[10:58:41.391] - relay: TRUE
[10:58:41.391] - stdout: TRUE
[10:58:41.392] - signal: TRUE
[10:58:41.392] - resignal: FALSE
[10:58:41.392] - force: TRUE
[10:58:41.392] - relayed: [n=2] FALSE, FALSE
[10:58:41.392] - queued futures: [n=2] FALSE, FALSE
[10:58:41.392]  - until=1
[10:58:41.392]  - relaying element #1
[10:58:41.392] result() for ClusterFuture ...
[10:58:41.392] - result already collected: FutureResult
[10:58:41.392] result() for ClusterFuture ... done
[10:58:41.392] result() for ClusterFuture ...
[10:58:41.392] - result already collected: FutureResult
[10:58:41.393] result() for ClusterFuture ... done
[10:58:41.393] result() for ClusterFuture ...
[10:58:41.393] - result already collected: FutureResult
[10:58:41.393] result() for ClusterFuture ... done
[10:58:41.393] result() for ClusterFuture ...
[10:58:41.393] - result already collected: FutureResult
[10:58:41.393] result() for ClusterFuture ... done
[10:58:41.393] - relayed: [n=2] TRUE, FALSE
[10:58:41.393] - queued futures: [n=2] TRUE, FALSE
[10:58:41.393] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:41.393]  length: 1 (resolved future 1)
[10:58:41.419] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.419] - Validating connection of MultisessionFuture
[10:58:41.419] - received message: FutureResult
[10:58:41.419] - Received FutureResult
[10:58:41.420] - Erased future from FutureRegistry
[10:58:41.420] result() for ClusterFuture ...
[10:58:41.420] - result already collected: FutureResult
[10:58:41.420] result() for ClusterFuture ... done
[10:58:41.420] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.420] Future #2
[10:58:41.420] result() for ClusterFuture ...
[10:58:41.420] - result already collected: FutureResult
[10:58:41.420] result() for ClusterFuture ... done
[10:58:41.420] result() for ClusterFuture ...
[10:58:41.420] - result already collected: FutureResult
[10:58:41.420] result() for ClusterFuture ... done
[10:58:41.421] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:41.421] - nx: 2
[10:58:41.421] - relay: TRUE
[10:58:41.421] - stdout: TRUE
[10:58:41.421] - signal: TRUE
[10:58:41.421] - resignal: FALSE
[10:58:41.421] - force: TRUE
[10:58:41.421] - relayed: [n=2] TRUE, FALSE
[10:58:41.421] - queued futures: [n=2] TRUE, FALSE
[10:58:41.421]  - until=2
[10:58:41.421]  - relaying element #2
[10:58:41.421] result() for ClusterFuture ...
[10:58:41.422] - result already collected: FutureResult
[10:58:41.422] result() for ClusterFuture ... done
[10:58:41.422] result() for ClusterFuture ...
[10:58:41.422] - result already collected: FutureResult
[10:58:41.422] result() for ClusterFuture ... done
[10:58:41.422] result() for ClusterFuture ...
[10:58:41.422] - result already collected: FutureResult
[10:58:41.422] result() for ClusterFuture ... done
[10:58:41.422] result() for ClusterFuture ...
[10:58:41.422] - result already collected: FutureResult
[10:58:41.422] result() for ClusterFuture ... done
[10:58:41.422] - relayed: [n=2] TRUE, TRUE
[10:58:41.423] - queued futures: [n=2] TRUE, TRUE
[10:58:41.423] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:41.423]  length: 0 (resolved future 2)
[10:58:41.423] Relaying remaining futures
[10:58:41.423] signalConditionsASAP(NULL, pos=0) ...
[10:58:41.423] - nx: 2
[10:58:41.423] - relay: TRUE
[10:58:41.423] - stdout: TRUE
[10:58:41.423] - signal: TRUE
[10:58:41.423] - resignal: FALSE
[10:58:41.423] - force: TRUE
[10:58:41.423] - relayed: [n=2] TRUE, TRUE
[10:58:41.423] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:41.424] - relayed: [n=2] TRUE, TRUE
[10:58:41.424] - queued futures: [n=2] TRUE, TRUE
[10:58:41.424] signalConditionsASAP(NULL, pos=0) ... done
[10:58:41.424] resolve() on list ... DONE
[10:58:41.424] result() for ClusterFuture ...
[10:58:41.424] - result already collected: FutureResult
[10:58:41.424] result() for ClusterFuture ... done
[10:58:41.424] result() for ClusterFuture ...
[10:58:41.424] - result already collected: FutureResult
[10:58:41.424] result() for ClusterFuture ... done
[10:58:41.426] result() for ClusterFuture ...
[10:58:41.426] - result already collected: FutureResult
[10:58:41.426] result() for ClusterFuture ... done
[10:58:41.426] result() for ClusterFuture ...
[10:58:41.427] - result already collected: FutureResult
[10:58:41.427] result() for ClusterFuture ... done
[10:58:41.427]  - Number of value chunks collected: 2
[10:58:41.427] Resolving 2 futures (chunks) ... DONE
[10:58:41.427] Reducing values from 2 chunks ...
[10:58:41.427]  - Number of values collected after concatenation: 2
[10:58:41.427]  - Number of values expected: 2
[10:58:41.427] Reducing values from 2 chunks ... DONE
[10:58:41.427] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:58:41.427] getGlobalsAndPackagesXApply() ...
[10:58:41.428]  - future.globals: TRUE
[10:58:41.428] getGlobalsAndPackages() ...
[10:58:41.428] Searching for globals...
[10:58:41.429] - globals found: [1] ‘FUN’
[10:58:41.429] Searching for globals ... DONE
[10:58:41.429] Resolving globals: FALSE
[10:58:41.429] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:41.430] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:41.430] - globals: [1] ‘FUN’
[10:58:41.430] 
[10:58:41.430] getGlobalsAndPackages() ... DONE
[10:58:41.430]  - globals found/used: [n=1] ‘FUN’
[10:58:41.430]  - needed namespaces: [n=0] 
[10:58:41.430] Finding globals ... DONE
[10:58:41.430]  - use_args: TRUE
[10:58:41.430]  - Getting '...' globals ...
[10:58:41.431] resolve() on list ...
[10:58:41.431]  recursive: 0
[10:58:41.431]  length: 1
[10:58:41.431]  elements: ‘...’
[10:58:41.431]  length: 0 (resolved future 1)
[10:58:41.431] resolve() on list ... DONE
[10:58:41.431]    - '...' content: [n=0] 
[10:58:41.431] List of 1
[10:58:41.431]  $ ...: list()
[10:58:41.431]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.431]  - attr(*, "where")=List of 1
[10:58:41.431]   ..$ ...:<environment: 0x5635bfdd12f8> 
[10:58:41.431]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.431]  - attr(*, "resolved")= logi TRUE
[10:58:41.431]  - attr(*, "total_size")= num NA
[10:58:41.433]  - Getting '...' globals ... DONE
[10:58:41.434] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:41.434] List of 2
[10:58:41.434]  $ ...future.FUN:function (x)  
[10:58:41.434]  $ ...          : list()
[10:58:41.434]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.434]  - attr(*, "where")=List of 2
[10:58:41.434]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:41.434]   ..$ ...          :<environment: 0x5635bfdd12f8> 
[10:58:41.434]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.434]  - attr(*, "resolved")= logi FALSE
[10:58:41.434]  - attr(*, "total_size")= num 3563
[10:58:41.436] Packages to be attached in all futures: [n=0] 
[10:58:41.436] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.438] future_lapply() ...
[10:58:41.439] Number of chunks: 2
[10:58:41.440] getGlobalsAndPackagesXApply() ...
[10:58:41.440]  - future.globals: <name-value list> with names ‘list()’
[10:58:41.440]  - use_args: TRUE
[10:58:41.440] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:41.440] List of 2
[10:58:41.440]  $ ...          : list()
[10:58:41.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.440]  $ ...future.FUN:function (x)  
[10:58:41.440]  - attr(*, "where")=List of 2
[10:58:41.440]   ..$ ...          :<environment: 0x5635bfdd12f8> 
[10:58:41.440]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:41.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.440]  - attr(*, "resolved")= logi FALSE
[10:58:41.440]  - attr(*, "total_size")= num NA
[10:58:41.443] Packages to be attached in all futures: [n=0] 
[10:58:41.443] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.443] Number of futures (= number of chunks): 2
[10:58:41.444] Launching 2 futures (chunks) ...
[10:58:41.444] Chunk #1 of 2 ...
[10:58:41.444]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.444]  - seeds: <none>
[10:58:41.444]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.444] getGlobalsAndPackages() ...
[10:58:41.444] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.444] Resolving globals: FALSE
[10:58:41.444] Tweak future expression to call with '...' arguments ...
[10:58:41.444] {
[10:58:41.444]     do.call(function(...) {
[10:58:41.444]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.444]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.444]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.444]             on.exit(options(oopts), add = TRUE)
[10:58:41.444]         }
[10:58:41.444]         {
[10:58:41.444]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.444]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.444]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.444]             })
[10:58:41.444]         }
[10:58:41.444]     }, args = future.call.arguments)
[10:58:41.444] }
[10:58:41.445] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.445] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.445] 
[10:58:41.445] getGlobalsAndPackages() ... DONE
[10:58:41.446] run() for ‘Future’ ...
[10:58:41.446] - state: ‘created’
[10:58:41.446] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.462] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.462] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.462]   - Field: ‘node’
[10:58:41.462]   - Field: ‘label’
[10:58:41.462]   - Field: ‘local’
[10:58:41.462]   - Field: ‘owner’
[10:58:41.462]   - Field: ‘envir’
[10:58:41.463]   - Field: ‘workers’
[10:58:41.463]   - Field: ‘packages’
[10:58:41.463]   - Field: ‘gc’
[10:58:41.463]   - Field: ‘conditions’
[10:58:41.463]   - Field: ‘persistent’
[10:58:41.463]   - Field: ‘expr’
[10:58:41.463]   - Field: ‘uuid’
[10:58:41.463]   - Field: ‘seed’
[10:58:41.463]   - Field: ‘version’
[10:58:41.463]   - Field: ‘result’
[10:58:41.463]   - Field: ‘asynchronous’
[10:58:41.463]   - Field: ‘calls’
[10:58:41.464]   - Field: ‘globals’
[10:58:41.464]   - Field: ‘stdout’
[10:58:41.464]   - Field: ‘earlySignal’
[10:58:41.464]   - Field: ‘lazy’
[10:58:41.464]   - Field: ‘state’
[10:58:41.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.464] - Launch lazy future ...
[10:58:41.464] Packages needed by the future expression (n = 0): <none>
[10:58:41.464] Packages needed by future strategies (n = 0): <none>
[10:58:41.465] {
[10:58:41.465]     {
[10:58:41.465]         {
[10:58:41.465]             ...future.startTime <- base::Sys.time()
[10:58:41.465]             {
[10:58:41.465]                 {
[10:58:41.465]                   {
[10:58:41.465]                     {
[10:58:41.465]                       base::local({
[10:58:41.465]                         has_future <- base::requireNamespace("future", 
[10:58:41.465]                           quietly = TRUE)
[10:58:41.465]                         if (has_future) {
[10:58:41.465]                           ns <- base::getNamespace("future")
[10:58:41.465]                           version <- ns[[".package"]][["version"]]
[10:58:41.465]                           if (is.null(version)) 
[10:58:41.465]                             version <- utils::packageVersion("future")
[10:58:41.465]                         }
[10:58:41.465]                         else {
[10:58:41.465]                           version <- NULL
[10:58:41.465]                         }
[10:58:41.465]                         if (!has_future || version < "1.8.0") {
[10:58:41.465]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.465]                             "", base::R.version$version.string), 
[10:58:41.465]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.465]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.465]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.465]                               "release", "version")], collapse = " "), 
[10:58:41.465]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.465]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.465]                             info)
[10:58:41.465]                           info <- base::paste(info, collapse = "; ")
[10:58:41.465]                           if (!has_future) {
[10:58:41.465]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.465]                               info)
[10:58:41.465]                           }
[10:58:41.465]                           else {
[10:58:41.465]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.465]                               info, version)
[10:58:41.465]                           }
[10:58:41.465]                           base::stop(msg)
[10:58:41.465]                         }
[10:58:41.465]                       })
[10:58:41.465]                     }
[10:58:41.465]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.465]                     base::options(mc.cores = 1L)
[10:58:41.465]                   }
[10:58:41.465]                   ...future.strategy.old <- future::plan("list")
[10:58:41.465]                   options(future.plan = NULL)
[10:58:41.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.465]                 }
[10:58:41.465]                 ...future.workdir <- getwd()
[10:58:41.465]             }
[10:58:41.465]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.465]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.465]         }
[10:58:41.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.465]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.465]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.465]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.465]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.465]             base::names(...future.oldOptions))
[10:58:41.465]     }
[10:58:41.465]     if (FALSE) {
[10:58:41.465]     }
[10:58:41.465]     else {
[10:58:41.465]         if (TRUE) {
[10:58:41.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.465]                 open = "w")
[10:58:41.465]         }
[10:58:41.465]         else {
[10:58:41.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.465]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.465]         }
[10:58:41.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.465]             base::sink(type = "output", split = FALSE)
[10:58:41.465]             base::close(...future.stdout)
[10:58:41.465]         }, add = TRUE)
[10:58:41.465]     }
[10:58:41.465]     ...future.frame <- base::sys.nframe()
[10:58:41.465]     ...future.conditions <- base::list()
[10:58:41.465]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.465]     if (FALSE) {
[10:58:41.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.465]     }
[10:58:41.465]     ...future.result <- base::tryCatch({
[10:58:41.465]         base::withCallingHandlers({
[10:58:41.465]             ...future.value <- base::withVisible(base::local({
[10:58:41.465]                 ...future.makeSendCondition <- base::local({
[10:58:41.465]                   sendCondition <- NULL
[10:58:41.465]                   function(frame = 1L) {
[10:58:41.465]                     if (is.function(sendCondition)) 
[10:58:41.465]                       return(sendCondition)
[10:58:41.465]                     ns <- getNamespace("parallel")
[10:58:41.465]                     if (exists("sendData", mode = "function", 
[10:58:41.465]                       envir = ns)) {
[10:58:41.465]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.465]                         envir = ns)
[10:58:41.465]                       envir <- sys.frame(frame)
[10:58:41.465]                       master <- NULL
[10:58:41.465]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.465]                         !identical(envir, emptyenv())) {
[10:58:41.465]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.465]                           inherits = FALSE)) {
[10:58:41.465]                           master <- get("master", mode = "list", 
[10:58:41.465]                             envir = envir, inherits = FALSE)
[10:58:41.465]                           if (inherits(master, c("SOCKnode", 
[10:58:41.465]                             "SOCK0node"))) {
[10:58:41.465]                             sendCondition <<- function(cond) {
[10:58:41.465]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.465]                                 success = TRUE)
[10:58:41.465]                               parallel_sendData(master, data)
[10:58:41.465]                             }
[10:58:41.465]                             return(sendCondition)
[10:58:41.465]                           }
[10:58:41.465]                         }
[10:58:41.465]                         frame <- frame + 1L
[10:58:41.465]                         envir <- sys.frame(frame)
[10:58:41.465]                       }
[10:58:41.465]                     }
[10:58:41.465]                     sendCondition <<- function(cond) NULL
[10:58:41.465]                   }
[10:58:41.465]                 })
[10:58:41.465]                 withCallingHandlers({
[10:58:41.465]                   {
[10:58:41.465]                     do.call(function(...) {
[10:58:41.465]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.465]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.465]                         ...future.globals.maxSize)) {
[10:58:41.465]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.465]                         on.exit(options(oopts), add = TRUE)
[10:58:41.465]                       }
[10:58:41.465]                       {
[10:58:41.465]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.465]                           FUN = function(jj) {
[10:58:41.465]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.465]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.465]                           })
[10:58:41.465]                       }
[10:58:41.465]                     }, args = future.call.arguments)
[10:58:41.465]                   }
[10:58:41.465]                 }, immediateCondition = function(cond) {
[10:58:41.465]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.465]                   sendCondition(cond)
[10:58:41.465]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.465]                   {
[10:58:41.465]                     inherits <- base::inherits
[10:58:41.465]                     invokeRestart <- base::invokeRestart
[10:58:41.465]                     is.null <- base::is.null
[10:58:41.465]                     muffled <- FALSE
[10:58:41.465]                     if (inherits(cond, "message")) {
[10:58:41.465]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.465]                       if (muffled) 
[10:58:41.465]                         invokeRestart("muffleMessage")
[10:58:41.465]                     }
[10:58:41.465]                     else if (inherits(cond, "warning")) {
[10:58:41.465]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.465]                       if (muffled) 
[10:58:41.465]                         invokeRestart("muffleWarning")
[10:58:41.465]                     }
[10:58:41.465]                     else if (inherits(cond, "condition")) {
[10:58:41.465]                       if (!is.null(pattern)) {
[10:58:41.465]                         computeRestarts <- base::computeRestarts
[10:58:41.465]                         grepl <- base::grepl
[10:58:41.465]                         restarts <- computeRestarts(cond)
[10:58:41.465]                         for (restart in restarts) {
[10:58:41.465]                           name <- restart$name
[10:58:41.465]                           if (is.null(name)) 
[10:58:41.465]                             next
[10:58:41.465]                           if (!grepl(pattern, name)) 
[10:58:41.465]                             next
[10:58:41.465]                           invokeRestart(restart)
[10:58:41.465]                           muffled <- TRUE
[10:58:41.465]                           break
[10:58:41.465]                         }
[10:58:41.465]                       }
[10:58:41.465]                     }
[10:58:41.465]                     invisible(muffled)
[10:58:41.465]                   }
[10:58:41.465]                   muffleCondition(cond)
[10:58:41.465]                 })
[10:58:41.465]             }))
[10:58:41.465]             future::FutureResult(value = ...future.value$value, 
[10:58:41.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.465]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.465]                     ...future.globalenv.names))
[10:58:41.465]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.465]         }, condition = base::local({
[10:58:41.465]             c <- base::c
[10:58:41.465]             inherits <- base::inherits
[10:58:41.465]             invokeRestart <- base::invokeRestart
[10:58:41.465]             length <- base::length
[10:58:41.465]             list <- base::list
[10:58:41.465]             seq.int <- base::seq.int
[10:58:41.465]             signalCondition <- base::signalCondition
[10:58:41.465]             sys.calls <- base::sys.calls
[10:58:41.465]             `[[` <- base::`[[`
[10:58:41.465]             `+` <- base::`+`
[10:58:41.465]             `<<-` <- base::`<<-`
[10:58:41.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.465]                   3L)]
[10:58:41.465]             }
[10:58:41.465]             function(cond) {
[10:58:41.465]                 is_error <- inherits(cond, "error")
[10:58:41.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.465]                   NULL)
[10:58:41.465]                 if (is_error) {
[10:58:41.465]                   sessionInformation <- function() {
[10:58:41.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.465]                       search = base::search(), system = base::Sys.info())
[10:58:41.465]                   }
[10:58:41.465]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.465]                     cond$call), session = sessionInformation(), 
[10:58:41.465]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.465]                   signalCondition(cond)
[10:58:41.465]                 }
[10:58:41.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.465]                 "immediateCondition"))) {
[10:58:41.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.465]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.465]                   if (TRUE && !signal) {
[10:58:41.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.465]                     {
[10:58:41.465]                       inherits <- base::inherits
[10:58:41.465]                       invokeRestart <- base::invokeRestart
[10:58:41.465]                       is.null <- base::is.null
[10:58:41.465]                       muffled <- FALSE
[10:58:41.465]                       if (inherits(cond, "message")) {
[10:58:41.465]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.465]                         if (muffled) 
[10:58:41.465]                           invokeRestart("muffleMessage")
[10:58:41.465]                       }
[10:58:41.465]                       else if (inherits(cond, "warning")) {
[10:58:41.465]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.465]                         if (muffled) 
[10:58:41.465]                           invokeRestart("muffleWarning")
[10:58:41.465]                       }
[10:58:41.465]                       else if (inherits(cond, "condition")) {
[10:58:41.465]                         if (!is.null(pattern)) {
[10:58:41.465]                           computeRestarts <- base::computeRestarts
[10:58:41.465]                           grepl <- base::grepl
[10:58:41.465]                           restarts <- computeRestarts(cond)
[10:58:41.465]                           for (restart in restarts) {
[10:58:41.465]                             name <- restart$name
[10:58:41.465]                             if (is.null(name)) 
[10:58:41.465]                               next
[10:58:41.465]                             if (!grepl(pattern, name)) 
[10:58:41.465]                               next
[10:58:41.465]                             invokeRestart(restart)
[10:58:41.465]                             muffled <- TRUE
[10:58:41.465]                             break
[10:58:41.465]                           }
[10:58:41.465]                         }
[10:58:41.465]                       }
[10:58:41.465]                       invisible(muffled)
[10:58:41.465]                     }
[10:58:41.465]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.465]                   }
[10:58:41.465]                 }
[10:58:41.465]                 else {
[10:58:41.465]                   if (TRUE) {
[10:58:41.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.465]                     {
[10:58:41.465]                       inherits <- base::inherits
[10:58:41.465]                       invokeRestart <- base::invokeRestart
[10:58:41.465]                       is.null <- base::is.null
[10:58:41.465]                       muffled <- FALSE
[10:58:41.465]                       if (inherits(cond, "message")) {
[10:58:41.465]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.465]                         if (muffled) 
[10:58:41.465]                           invokeRestart("muffleMessage")
[10:58:41.465]                       }
[10:58:41.465]                       else if (inherits(cond, "warning")) {
[10:58:41.465]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.465]                         if (muffled) 
[10:58:41.465]                           invokeRestart("muffleWarning")
[10:58:41.465]                       }
[10:58:41.465]                       else if (inherits(cond, "condition")) {
[10:58:41.465]                         if (!is.null(pattern)) {
[10:58:41.465]                           computeRestarts <- base::computeRestarts
[10:58:41.465]                           grepl <- base::grepl
[10:58:41.465]                           restarts <- computeRestarts(cond)
[10:58:41.465]                           for (restart in restarts) {
[10:58:41.465]                             name <- restart$name
[10:58:41.465]                             if (is.null(name)) 
[10:58:41.465]                               next
[10:58:41.465]                             if (!grepl(pattern, name)) 
[10:58:41.465]                               next
[10:58:41.465]                             invokeRestart(restart)
[10:58:41.465]                             muffled <- TRUE
[10:58:41.465]                             break
[10:58:41.465]                           }
[10:58:41.465]                         }
[10:58:41.465]                       }
[10:58:41.465]                       invisible(muffled)
[10:58:41.465]                     }
[10:58:41.465]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.465]                   }
[10:58:41.465]                 }
[10:58:41.465]             }
[10:58:41.465]         }))
[10:58:41.465]     }, error = function(ex) {
[10:58:41.465]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.465]                 ...future.rng), started = ...future.startTime, 
[10:58:41.465]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.465]             version = "1.8"), class = "FutureResult")
[10:58:41.465]     }, finally = {
[10:58:41.465]         if (!identical(...future.workdir, getwd())) 
[10:58:41.465]             setwd(...future.workdir)
[10:58:41.465]         {
[10:58:41.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.465]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.465]             }
[10:58:41.465]             base::options(...future.oldOptions)
[10:58:41.465]             if (.Platform$OS.type == "windows") {
[10:58:41.465]                 old_names <- names(...future.oldEnvVars)
[10:58:41.465]                 envs <- base::Sys.getenv()
[10:58:41.465]                 names <- names(envs)
[10:58:41.465]                 common <- intersect(names, old_names)
[10:58:41.465]                 added <- setdiff(names, old_names)
[10:58:41.465]                 removed <- setdiff(old_names, names)
[10:58:41.465]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.465]                   envs[common]]
[10:58:41.465]                 NAMES <- toupper(changed)
[10:58:41.465]                 args <- list()
[10:58:41.465]                 for (kk in seq_along(NAMES)) {
[10:58:41.465]                   name <- changed[[kk]]
[10:58:41.465]                   NAME <- NAMES[[kk]]
[10:58:41.465]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.465]                     next
[10:58:41.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.465]                 }
[10:58:41.465]                 NAMES <- toupper(added)
[10:58:41.465]                 for (kk in seq_along(NAMES)) {
[10:58:41.465]                   name <- added[[kk]]
[10:58:41.465]                   NAME <- NAMES[[kk]]
[10:58:41.465]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.465]                     next
[10:58:41.465]                   args[[name]] <- ""
[10:58:41.465]                 }
[10:58:41.465]                 NAMES <- toupper(removed)
[10:58:41.465]                 for (kk in seq_along(NAMES)) {
[10:58:41.465]                   name <- removed[[kk]]
[10:58:41.465]                   NAME <- NAMES[[kk]]
[10:58:41.465]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.465]                     next
[10:58:41.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.465]                 }
[10:58:41.465]                 if (length(args) > 0) 
[10:58:41.465]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.465]             }
[10:58:41.465]             else {
[10:58:41.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.465]             }
[10:58:41.465]             {
[10:58:41.465]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.465]                   0L) {
[10:58:41.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.465]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.465]                   base::options(opts)
[10:58:41.465]                 }
[10:58:41.465]                 {
[10:58:41.465]                   {
[10:58:41.465]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.465]                     NULL
[10:58:41.465]                   }
[10:58:41.465]                   options(future.plan = NULL)
[10:58:41.465]                   if (is.na(NA_character_)) 
[10:58:41.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.465]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.465]                     .init = FALSE)
[10:58:41.465]                 }
[10:58:41.465]             }
[10:58:41.465]         }
[10:58:41.465]     })
[10:58:41.465]     if (TRUE) {
[10:58:41.465]         base::sink(type = "output", split = FALSE)
[10:58:41.465]         if (TRUE) {
[10:58:41.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.465]         }
[10:58:41.465]         else {
[10:58:41.465]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.465]         }
[10:58:41.465]         base::close(...future.stdout)
[10:58:41.465]         ...future.stdout <- NULL
[10:58:41.465]     }
[10:58:41.465]     ...future.result$conditions <- ...future.conditions
[10:58:41.465]     ...future.result$finished <- base::Sys.time()
[10:58:41.465]     ...future.result
[10:58:41.465] }
[10:58:41.467] Exporting 5 global objects (1.03 KiB) to cluster node #1 ...
[10:58:41.468] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:41.468] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:41.468] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:58:41.468] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:58:41.469] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #1 ...
[10:58:41.469] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #1 ... DONE
[10:58:41.469] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:41.469] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:41.470] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:41.470] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:41.470] Exporting 5 global objects (1.03 KiB) to cluster node #1 ... DONE
[10:58:41.470] MultisessionFuture started
[10:58:41.470] - Launch lazy future ... done
[10:58:41.471] run() for ‘MultisessionFuture’ ... done
[10:58:41.471] Created future:
[10:58:41.471] MultisessionFuture:
[10:58:41.471] Label: ‘future_apply-1’
[10:58:41.471] Expression:
[10:58:41.471] {
[10:58:41.471]     do.call(function(...) {
[10:58:41.471]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.471]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.471]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.471]             on.exit(options(oopts), add = TRUE)
[10:58:41.471]         }
[10:58:41.471]         {
[10:58:41.471]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.471]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.471]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.471]             })
[10:58:41.471]         }
[10:58:41.471]     }, args = future.call.arguments)
[10:58:41.471] }
[10:58:41.471] Lazy evaluation: FALSE
[10:58:41.471] Asynchronous evaluation: TRUE
[10:58:41.471] Local evaluation: TRUE
[10:58:41.471] Environment: R_GlobalEnv
[10:58:41.471] Capture standard output: TRUE
[10:58:41.471] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.471] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.471] Packages: <none>
[10:58:41.471] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.471] Resolved: FALSE
[10:58:41.471] Value: <not collected>
[10:58:41.471] Conditions captured: <none>
[10:58:41.471] Early signaling: FALSE
[10:58:41.471] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.471] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.482] Chunk #1 of 2 ... DONE
[10:58:41.482] Chunk #2 of 2 ...
[10:58:41.482]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.482]  - seeds: <none>
[10:58:41.483]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.483] getGlobalsAndPackages() ...
[10:58:41.483] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.483] Resolving globals: FALSE
[10:58:41.483] Tweak future expression to call with '...' arguments ...
[10:58:41.483] {
[10:58:41.483]     do.call(function(...) {
[10:58:41.483]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.483]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.483]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.483]             on.exit(options(oopts), add = TRUE)
[10:58:41.483]         }
[10:58:41.483]         {
[10:58:41.483]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.483]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.483]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.483]             })
[10:58:41.483]         }
[10:58:41.483]     }, args = future.call.arguments)
[10:58:41.483] }
[10:58:41.483] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.484] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.484] 
[10:58:41.484] getGlobalsAndPackages() ... DONE
[10:58:41.484] run() for ‘Future’ ...
[10:58:41.484] - state: ‘created’
[10:58:41.484] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.498] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.498]   - Field: ‘node’
[10:58:41.498]   - Field: ‘label’
[10:58:41.498]   - Field: ‘local’
[10:58:41.498]   - Field: ‘owner’
[10:58:41.499]   - Field: ‘envir’
[10:58:41.499]   - Field: ‘workers’
[10:58:41.499]   - Field: ‘packages’
[10:58:41.499]   - Field: ‘gc’
[10:58:41.499]   - Field: ‘conditions’
[10:58:41.499]   - Field: ‘persistent’
[10:58:41.499]   - Field: ‘expr’
[10:58:41.499]   - Field: ‘uuid’
[10:58:41.499]   - Field: ‘seed’
[10:58:41.499]   - Field: ‘version’
[10:58:41.499]   - Field: ‘result’
[10:58:41.500]   - Field: ‘asynchronous’
[10:58:41.500]   - Field: ‘calls’
[10:58:41.500]   - Field: ‘globals’
[10:58:41.500]   - Field: ‘stdout’
[10:58:41.500]   - Field: ‘earlySignal’
[10:58:41.500]   - Field: ‘lazy’
[10:58:41.500]   - Field: ‘state’
[10:58:41.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.500] - Launch lazy future ...
[10:58:41.500] Packages needed by the future expression (n = 0): <none>
[10:58:41.501] Packages needed by future strategies (n = 0): <none>
[10:58:41.501] {
[10:58:41.501]     {
[10:58:41.501]         {
[10:58:41.501]             ...future.startTime <- base::Sys.time()
[10:58:41.501]             {
[10:58:41.501]                 {
[10:58:41.501]                   {
[10:58:41.501]                     {
[10:58:41.501]                       base::local({
[10:58:41.501]                         has_future <- base::requireNamespace("future", 
[10:58:41.501]                           quietly = TRUE)
[10:58:41.501]                         if (has_future) {
[10:58:41.501]                           ns <- base::getNamespace("future")
[10:58:41.501]                           version <- ns[[".package"]][["version"]]
[10:58:41.501]                           if (is.null(version)) 
[10:58:41.501]                             version <- utils::packageVersion("future")
[10:58:41.501]                         }
[10:58:41.501]                         else {
[10:58:41.501]                           version <- NULL
[10:58:41.501]                         }
[10:58:41.501]                         if (!has_future || version < "1.8.0") {
[10:58:41.501]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.501]                             "", base::R.version$version.string), 
[10:58:41.501]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.501]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.501]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.501]                               "release", "version")], collapse = " "), 
[10:58:41.501]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.501]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.501]                             info)
[10:58:41.501]                           info <- base::paste(info, collapse = "; ")
[10:58:41.501]                           if (!has_future) {
[10:58:41.501]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.501]                               info)
[10:58:41.501]                           }
[10:58:41.501]                           else {
[10:58:41.501]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.501]                               info, version)
[10:58:41.501]                           }
[10:58:41.501]                           base::stop(msg)
[10:58:41.501]                         }
[10:58:41.501]                       })
[10:58:41.501]                     }
[10:58:41.501]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.501]                     base::options(mc.cores = 1L)
[10:58:41.501]                   }
[10:58:41.501]                   ...future.strategy.old <- future::plan("list")
[10:58:41.501]                   options(future.plan = NULL)
[10:58:41.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.501]                 }
[10:58:41.501]                 ...future.workdir <- getwd()
[10:58:41.501]             }
[10:58:41.501]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.501]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.501]         }
[10:58:41.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.501]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.501]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.501]             base::names(...future.oldOptions))
[10:58:41.501]     }
[10:58:41.501]     if (FALSE) {
[10:58:41.501]     }
[10:58:41.501]     else {
[10:58:41.501]         if (TRUE) {
[10:58:41.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.501]                 open = "w")
[10:58:41.501]         }
[10:58:41.501]         else {
[10:58:41.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.501]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.501]         }
[10:58:41.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.501]             base::sink(type = "output", split = FALSE)
[10:58:41.501]             base::close(...future.stdout)
[10:58:41.501]         }, add = TRUE)
[10:58:41.501]     }
[10:58:41.501]     ...future.frame <- base::sys.nframe()
[10:58:41.501]     ...future.conditions <- base::list()
[10:58:41.501]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.501]     if (FALSE) {
[10:58:41.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.501]     }
[10:58:41.501]     ...future.result <- base::tryCatch({
[10:58:41.501]         base::withCallingHandlers({
[10:58:41.501]             ...future.value <- base::withVisible(base::local({
[10:58:41.501]                 ...future.makeSendCondition <- base::local({
[10:58:41.501]                   sendCondition <- NULL
[10:58:41.501]                   function(frame = 1L) {
[10:58:41.501]                     if (is.function(sendCondition)) 
[10:58:41.501]                       return(sendCondition)
[10:58:41.501]                     ns <- getNamespace("parallel")
[10:58:41.501]                     if (exists("sendData", mode = "function", 
[10:58:41.501]                       envir = ns)) {
[10:58:41.501]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.501]                         envir = ns)
[10:58:41.501]                       envir <- sys.frame(frame)
[10:58:41.501]                       master <- NULL
[10:58:41.501]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.501]                         !identical(envir, emptyenv())) {
[10:58:41.501]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.501]                           inherits = FALSE)) {
[10:58:41.501]                           master <- get("master", mode = "list", 
[10:58:41.501]                             envir = envir, inherits = FALSE)
[10:58:41.501]                           if (inherits(master, c("SOCKnode", 
[10:58:41.501]                             "SOCK0node"))) {
[10:58:41.501]                             sendCondition <<- function(cond) {
[10:58:41.501]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.501]                                 success = TRUE)
[10:58:41.501]                               parallel_sendData(master, data)
[10:58:41.501]                             }
[10:58:41.501]                             return(sendCondition)
[10:58:41.501]                           }
[10:58:41.501]                         }
[10:58:41.501]                         frame <- frame + 1L
[10:58:41.501]                         envir <- sys.frame(frame)
[10:58:41.501]                       }
[10:58:41.501]                     }
[10:58:41.501]                     sendCondition <<- function(cond) NULL
[10:58:41.501]                   }
[10:58:41.501]                 })
[10:58:41.501]                 withCallingHandlers({
[10:58:41.501]                   {
[10:58:41.501]                     do.call(function(...) {
[10:58:41.501]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.501]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.501]                         ...future.globals.maxSize)) {
[10:58:41.501]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.501]                         on.exit(options(oopts), add = TRUE)
[10:58:41.501]                       }
[10:58:41.501]                       {
[10:58:41.501]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.501]                           FUN = function(jj) {
[10:58:41.501]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.501]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.501]                           })
[10:58:41.501]                       }
[10:58:41.501]                     }, args = future.call.arguments)
[10:58:41.501]                   }
[10:58:41.501]                 }, immediateCondition = function(cond) {
[10:58:41.501]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.501]                   sendCondition(cond)
[10:58:41.501]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.501]                   {
[10:58:41.501]                     inherits <- base::inherits
[10:58:41.501]                     invokeRestart <- base::invokeRestart
[10:58:41.501]                     is.null <- base::is.null
[10:58:41.501]                     muffled <- FALSE
[10:58:41.501]                     if (inherits(cond, "message")) {
[10:58:41.501]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.501]                       if (muffled) 
[10:58:41.501]                         invokeRestart("muffleMessage")
[10:58:41.501]                     }
[10:58:41.501]                     else if (inherits(cond, "warning")) {
[10:58:41.501]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.501]                       if (muffled) 
[10:58:41.501]                         invokeRestart("muffleWarning")
[10:58:41.501]                     }
[10:58:41.501]                     else if (inherits(cond, "condition")) {
[10:58:41.501]                       if (!is.null(pattern)) {
[10:58:41.501]                         computeRestarts <- base::computeRestarts
[10:58:41.501]                         grepl <- base::grepl
[10:58:41.501]                         restarts <- computeRestarts(cond)
[10:58:41.501]                         for (restart in restarts) {
[10:58:41.501]                           name <- restart$name
[10:58:41.501]                           if (is.null(name)) 
[10:58:41.501]                             next
[10:58:41.501]                           if (!grepl(pattern, name)) 
[10:58:41.501]                             next
[10:58:41.501]                           invokeRestart(restart)
[10:58:41.501]                           muffled <- TRUE
[10:58:41.501]                           break
[10:58:41.501]                         }
[10:58:41.501]                       }
[10:58:41.501]                     }
[10:58:41.501]                     invisible(muffled)
[10:58:41.501]                   }
[10:58:41.501]                   muffleCondition(cond)
[10:58:41.501]                 })
[10:58:41.501]             }))
[10:58:41.501]             future::FutureResult(value = ...future.value$value, 
[10:58:41.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.501]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.501]                     ...future.globalenv.names))
[10:58:41.501]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.501]         }, condition = base::local({
[10:58:41.501]             c <- base::c
[10:58:41.501]             inherits <- base::inherits
[10:58:41.501]             invokeRestart <- base::invokeRestart
[10:58:41.501]             length <- base::length
[10:58:41.501]             list <- base::list
[10:58:41.501]             seq.int <- base::seq.int
[10:58:41.501]             signalCondition <- base::signalCondition
[10:58:41.501]             sys.calls <- base::sys.calls
[10:58:41.501]             `[[` <- base::`[[`
[10:58:41.501]             `+` <- base::`+`
[10:58:41.501]             `<<-` <- base::`<<-`
[10:58:41.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.501]                   3L)]
[10:58:41.501]             }
[10:58:41.501]             function(cond) {
[10:58:41.501]                 is_error <- inherits(cond, "error")
[10:58:41.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.501]                   NULL)
[10:58:41.501]                 if (is_error) {
[10:58:41.501]                   sessionInformation <- function() {
[10:58:41.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.501]                       search = base::search(), system = base::Sys.info())
[10:58:41.501]                   }
[10:58:41.501]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.501]                     cond$call), session = sessionInformation(), 
[10:58:41.501]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.501]                   signalCondition(cond)
[10:58:41.501]                 }
[10:58:41.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.501]                 "immediateCondition"))) {
[10:58:41.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.501]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.501]                   if (TRUE && !signal) {
[10:58:41.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.501]                     {
[10:58:41.501]                       inherits <- base::inherits
[10:58:41.501]                       invokeRestart <- base::invokeRestart
[10:58:41.501]                       is.null <- base::is.null
[10:58:41.501]                       muffled <- FALSE
[10:58:41.501]                       if (inherits(cond, "message")) {
[10:58:41.501]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.501]                         if (muffled) 
[10:58:41.501]                           invokeRestart("muffleMessage")
[10:58:41.501]                       }
[10:58:41.501]                       else if (inherits(cond, "warning")) {
[10:58:41.501]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.501]                         if (muffled) 
[10:58:41.501]                           invokeRestart("muffleWarning")
[10:58:41.501]                       }
[10:58:41.501]                       else if (inherits(cond, "condition")) {
[10:58:41.501]                         if (!is.null(pattern)) {
[10:58:41.501]                           computeRestarts <- base::computeRestarts
[10:58:41.501]                           grepl <- base::grepl
[10:58:41.501]                           restarts <- computeRestarts(cond)
[10:58:41.501]                           for (restart in restarts) {
[10:58:41.501]                             name <- restart$name
[10:58:41.501]                             if (is.null(name)) 
[10:58:41.501]                               next
[10:58:41.501]                             if (!grepl(pattern, name)) 
[10:58:41.501]                               next
[10:58:41.501]                             invokeRestart(restart)
[10:58:41.501]                             muffled <- TRUE
[10:58:41.501]                             break
[10:58:41.501]                           }
[10:58:41.501]                         }
[10:58:41.501]                       }
[10:58:41.501]                       invisible(muffled)
[10:58:41.501]                     }
[10:58:41.501]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.501]                   }
[10:58:41.501]                 }
[10:58:41.501]                 else {
[10:58:41.501]                   if (TRUE) {
[10:58:41.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.501]                     {
[10:58:41.501]                       inherits <- base::inherits
[10:58:41.501]                       invokeRestart <- base::invokeRestart
[10:58:41.501]                       is.null <- base::is.null
[10:58:41.501]                       muffled <- FALSE
[10:58:41.501]                       if (inherits(cond, "message")) {
[10:58:41.501]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.501]                         if (muffled) 
[10:58:41.501]                           invokeRestart("muffleMessage")
[10:58:41.501]                       }
[10:58:41.501]                       else if (inherits(cond, "warning")) {
[10:58:41.501]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.501]                         if (muffled) 
[10:58:41.501]                           invokeRestart("muffleWarning")
[10:58:41.501]                       }
[10:58:41.501]                       else if (inherits(cond, "condition")) {
[10:58:41.501]                         if (!is.null(pattern)) {
[10:58:41.501]                           computeRestarts <- base::computeRestarts
[10:58:41.501]                           grepl <- base::grepl
[10:58:41.501]                           restarts <- computeRestarts(cond)
[10:58:41.501]                           for (restart in restarts) {
[10:58:41.501]                             name <- restart$name
[10:58:41.501]                             if (is.null(name)) 
[10:58:41.501]                               next
[10:58:41.501]                             if (!grepl(pattern, name)) 
[10:58:41.501]                               next
[10:58:41.501]                             invokeRestart(restart)
[10:58:41.501]                             muffled <- TRUE
[10:58:41.501]                             break
[10:58:41.501]                           }
[10:58:41.501]                         }
[10:58:41.501]                       }
[10:58:41.501]                       invisible(muffled)
[10:58:41.501]                     }
[10:58:41.501]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.501]                   }
[10:58:41.501]                 }
[10:58:41.501]             }
[10:58:41.501]         }))
[10:58:41.501]     }, error = function(ex) {
[10:58:41.501]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.501]                 ...future.rng), started = ...future.startTime, 
[10:58:41.501]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.501]             version = "1.8"), class = "FutureResult")
[10:58:41.501]     }, finally = {
[10:58:41.501]         if (!identical(...future.workdir, getwd())) 
[10:58:41.501]             setwd(...future.workdir)
[10:58:41.501]         {
[10:58:41.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.501]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.501]             }
[10:58:41.501]             base::options(...future.oldOptions)
[10:58:41.501]             if (.Platform$OS.type == "windows") {
[10:58:41.501]                 old_names <- names(...future.oldEnvVars)
[10:58:41.501]                 envs <- base::Sys.getenv()
[10:58:41.501]                 names <- names(envs)
[10:58:41.501]                 common <- intersect(names, old_names)
[10:58:41.501]                 added <- setdiff(names, old_names)
[10:58:41.501]                 removed <- setdiff(old_names, names)
[10:58:41.501]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.501]                   envs[common]]
[10:58:41.501]                 NAMES <- toupper(changed)
[10:58:41.501]                 args <- list()
[10:58:41.501]                 for (kk in seq_along(NAMES)) {
[10:58:41.501]                   name <- changed[[kk]]
[10:58:41.501]                   NAME <- NAMES[[kk]]
[10:58:41.501]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.501]                     next
[10:58:41.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.501]                 }
[10:58:41.501]                 NAMES <- toupper(added)
[10:58:41.501]                 for (kk in seq_along(NAMES)) {
[10:58:41.501]                   name <- added[[kk]]
[10:58:41.501]                   NAME <- NAMES[[kk]]
[10:58:41.501]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.501]                     next
[10:58:41.501]                   args[[name]] <- ""
[10:58:41.501]                 }
[10:58:41.501]                 NAMES <- toupper(removed)
[10:58:41.501]                 for (kk in seq_along(NAMES)) {
[10:58:41.501]                   name <- removed[[kk]]
[10:58:41.501]                   NAME <- NAMES[[kk]]
[10:58:41.501]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.501]                     next
[10:58:41.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.501]                 }
[10:58:41.501]                 if (length(args) > 0) 
[10:58:41.501]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.501]             }
[10:58:41.501]             else {
[10:58:41.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.501]             }
[10:58:41.501]             {
[10:58:41.501]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.501]                   0L) {
[10:58:41.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.501]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.501]                   base::options(opts)
[10:58:41.501]                 }
[10:58:41.501]                 {
[10:58:41.501]                   {
[10:58:41.501]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.501]                     NULL
[10:58:41.501]                   }
[10:58:41.501]                   options(future.plan = NULL)
[10:58:41.501]                   if (is.na(NA_character_)) 
[10:58:41.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.501]                     .init = FALSE)
[10:58:41.501]                 }
[10:58:41.501]             }
[10:58:41.501]         }
[10:58:41.501]     })
[10:58:41.501]     if (TRUE) {
[10:58:41.501]         base::sink(type = "output", split = FALSE)
[10:58:41.501]         if (TRUE) {
[10:58:41.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.501]         }
[10:58:41.501]         else {
[10:58:41.501]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.501]         }
[10:58:41.501]         base::close(...future.stdout)
[10:58:41.501]         ...future.stdout <- NULL
[10:58:41.501]     }
[10:58:41.501]     ...future.result$conditions <- ...future.conditions
[10:58:41.501]     ...future.result$finished <- base::Sys.time()
[10:58:41.501]     ...future.result
[10:58:41.501] }
[10:58:41.504] Exporting 5 global objects (1.03 KiB) to cluster node #2 ...
[10:58:41.504] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:41.504] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:41.504] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:58:41.505] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:58:41.505] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #2 ...
[10:58:41.505] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #2 ... DONE
[10:58:41.505] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:41.506] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:41.506] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:41.506] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:41.506] Exporting 5 global objects (1.03 KiB) to cluster node #2 ... DONE
[10:58:41.507] MultisessionFuture started
[10:58:41.507] - Launch lazy future ... done
[10:58:41.507] run() for ‘MultisessionFuture’ ... done
[10:58:41.507] Created future:
[10:58:41.507] MultisessionFuture:
[10:58:41.507] Label: ‘future_apply-2’
[10:58:41.507] Expression:
[10:58:41.507] {
[10:58:41.507]     do.call(function(...) {
[10:58:41.507]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.507]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.507]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.507]             on.exit(options(oopts), add = TRUE)
[10:58:41.507]         }
[10:58:41.507]         {
[10:58:41.507]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.507]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.507]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.507]             })
[10:58:41.507]         }
[10:58:41.507]     }, args = future.call.arguments)
[10:58:41.507] }
[10:58:41.507] Lazy evaluation: FALSE
[10:58:41.507] Asynchronous evaluation: TRUE
[10:58:41.507] Local evaluation: TRUE
[10:58:41.507] Environment: R_GlobalEnv
[10:58:41.507] Capture standard output: TRUE
[10:58:41.507] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.507] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.507] Packages: <none>
[10:58:41.507] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.507] Resolved: FALSE
[10:58:41.507] Value: <not collected>
[10:58:41.507] Conditions captured: <none>
[10:58:41.507] Early signaling: FALSE
[10:58:41.507] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.507] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.518] Chunk #2 of 2 ... DONE
[10:58:41.519] Launching 2 futures (chunks) ... DONE
[10:58:41.519] Resolving 2 futures (chunks) ...
[10:58:41.519] resolve() on list ...
[10:58:41.519]  recursive: 0
[10:58:41.519]  length: 2
[10:58:41.519] 
[10:58:41.520] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.520] - Validating connection of MultisessionFuture
[10:58:41.520] - received message: FutureResult
[10:58:41.520] - Received FutureResult
[10:58:41.520] - Erased future from FutureRegistry
[10:58:41.520] result() for ClusterFuture ...
[10:58:41.520] - result already collected: FutureResult
[10:58:41.520] result() for ClusterFuture ... done
[10:58:41.520] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.520] Future #1
[10:58:41.521] result() for ClusterFuture ...
[10:58:41.521] - result already collected: FutureResult
[10:58:41.521] result() for ClusterFuture ... done
[10:58:41.521] result() for ClusterFuture ...
[10:58:41.521] - result already collected: FutureResult
[10:58:41.521] result() for ClusterFuture ... done
[10:58:41.521] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:41.521] - nx: 2
[10:58:41.521] - relay: TRUE
[10:58:41.521] - stdout: TRUE
[10:58:41.521] - signal: TRUE
[10:58:41.521] - resignal: FALSE
[10:58:41.522] - force: TRUE
[10:58:41.522] - relayed: [n=2] FALSE, FALSE
[10:58:41.522] - queued futures: [n=2] FALSE, FALSE
[10:58:41.522]  - until=1
[10:58:41.522]  - relaying element #1
[10:58:41.522] result() for ClusterFuture ...
[10:58:41.522] - result already collected: FutureResult
[10:58:41.522] result() for ClusterFuture ... done
[10:58:41.522] result() for ClusterFuture ...
[10:58:41.522] - result already collected: FutureResult
[10:58:41.522] result() for ClusterFuture ... done
[10:58:41.523] result() for ClusterFuture ...
[10:58:41.523] - result already collected: FutureResult
[10:58:41.523] result() for ClusterFuture ... done
[10:58:41.523] result() for ClusterFuture ...
[10:58:41.523] - result already collected: FutureResult
[10:58:41.523] result() for ClusterFuture ... done
[10:58:41.523] - relayed: [n=2] TRUE, FALSE
[10:58:41.523] - queued futures: [n=2] TRUE, FALSE
[10:58:41.523] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:41.523]  length: 1 (resolved future 1)
[10:58:41.549] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.549] - Validating connection of MultisessionFuture
[10:58:41.549] - received message: FutureResult
[10:58:41.549] - Received FutureResult
[10:58:41.550] - Erased future from FutureRegistry
[10:58:41.550] result() for ClusterFuture ...
[10:58:41.550] - result already collected: FutureResult
[10:58:41.550] result() for ClusterFuture ... done
[10:58:41.550] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.550] Future #2
[10:58:41.550] result() for ClusterFuture ...
[10:58:41.550] - result already collected: FutureResult
[10:58:41.550] result() for ClusterFuture ... done
[10:58:41.550] result() for ClusterFuture ...
[10:58:41.550] - result already collected: FutureResult
[10:58:41.550] result() for ClusterFuture ... done
[10:58:41.551] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:41.551] - nx: 2
[10:58:41.551] - relay: TRUE
[10:58:41.551] - stdout: TRUE
[10:58:41.551] - signal: TRUE
[10:58:41.551] - resignal: FALSE
[10:58:41.551] - force: TRUE
[10:58:41.551] - relayed: [n=2] TRUE, FALSE
[10:58:41.551] - queued futures: [n=2] TRUE, FALSE
[10:58:41.551]  - until=2
[10:58:41.551]  - relaying element #2
[10:58:41.551] result() for ClusterFuture ...
[10:58:41.552] - result already collected: FutureResult
[10:58:41.552] result() for ClusterFuture ... done
[10:58:41.552] result() for ClusterFuture ...
[10:58:41.552] - result already collected: FutureResult
[10:58:41.552] result() for ClusterFuture ... done
[10:58:41.552] result() for ClusterFuture ...
[10:58:41.552] - result already collected: FutureResult
[10:58:41.552] result() for ClusterFuture ... done
[10:58:41.552] result() for ClusterFuture ...
[10:58:41.552] - result already collected: FutureResult
[10:58:41.552] result() for ClusterFuture ... done
[10:58:41.553] - relayed: [n=2] TRUE, TRUE
[10:58:41.553] - queued futures: [n=2] TRUE, TRUE
[10:58:41.553] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:41.553]  length: 0 (resolved future 2)
[10:58:41.553] Relaying remaining futures
[10:58:41.553] signalConditionsASAP(NULL, pos=0) ...
[10:58:41.553] - nx: 2
[10:58:41.553] - relay: TRUE
[10:58:41.553] - stdout: TRUE
[10:58:41.553] - signal: TRUE
[10:58:41.553] - resignal: FALSE
[10:58:41.553] - force: TRUE
[10:58:41.553] - relayed: [n=2] TRUE, TRUE
[10:58:41.554] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:41.554] - relayed: [n=2] TRUE, TRUE
[10:58:41.554] - queued futures: [n=2] TRUE, TRUE
[10:58:41.554] signalConditionsASAP(NULL, pos=0) ... done
[10:58:41.554] resolve() on list ... DONE
[10:58:41.554] result() for ClusterFuture ...
[10:58:41.554] - result already collected: FutureResult
[10:58:41.554] result() for ClusterFuture ... done
[10:58:41.554] result() for ClusterFuture ...
[10:58:41.554] - result already collected: FutureResult
[10:58:41.554] result() for ClusterFuture ... done
[10:58:41.555] result() for ClusterFuture ...
[10:58:41.555] - result already collected: FutureResult
[10:58:41.555] result() for ClusterFuture ... done
[10:58:41.555] result() for ClusterFuture ...
[10:58:41.555] - result already collected: FutureResult
[10:58:41.555] result() for ClusterFuture ... done
[10:58:41.555]  - Number of value chunks collected: 2
[10:58:41.555] Resolving 2 futures (chunks) ... DONE
[10:58:41.555] Reducing values from 2 chunks ...
[10:58:41.555]  - Number of values collected after concatenation: 6
[10:58:41.555]  - Number of values expected: 6
[10:58:41.555] Reducing values from 2 chunks ... DONE
[10:58:41.556] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:58:41.556] getGlobalsAndPackagesXApply() ...
[10:58:41.556]  - future.globals: TRUE
[10:58:41.556] getGlobalsAndPackages() ...
[10:58:41.556] Searching for globals...
[10:58:41.557] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:58:41.558] Searching for globals ... DONE
[10:58:41.558] Resolving globals: FALSE
[10:58:41.558] The total size of the 1 globals is 411 bytes (411 bytes)
[10:58:41.558] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 411 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (411 bytes of class ‘function’)
[10:58:41.558] - globals: [1] ‘FUN’
[10:58:41.559] 
[10:58:41.559] getGlobalsAndPackages() ... DONE
[10:58:41.559]  - globals found/used: [n=1] ‘FUN’
[10:58:41.559]  - needed namespaces: [n=0] 
[10:58:41.559] Finding globals ... DONE
[10:58:41.559]  - use_args: TRUE
[10:58:41.559]  - Getting '...' globals ...
[10:58:41.559] resolve() on list ...
[10:58:41.559]  recursive: 0
[10:58:41.560]  length: 1
[10:58:41.560]  elements: ‘...’
[10:58:41.560]  length: 0 (resolved future 1)
[10:58:41.560] resolve() on list ... DONE
[10:58:41.560]    - '...' content: [n=0] 
[10:58:41.560] List of 1
[10:58:41.560]  $ ...: list()
[10:58:41.560]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.560]  - attr(*, "where")=List of 1
[10:58:41.560]   ..$ ...:<environment: 0x5635c10e7f00> 
[10:58:41.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.560]  - attr(*, "resolved")= logi TRUE
[10:58:41.560]  - attr(*, "total_size")= num NA
[10:58:41.562]  - Getting '...' globals ... DONE
[10:58:41.562] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:41.563] List of 2
[10:58:41.563]  $ ...future.FUN:function (x)  
[10:58:41.563]  $ ...          : list()
[10:58:41.563]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.563]  - attr(*, "where")=List of 2
[10:58:41.563]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:41.563]   ..$ ...          :<environment: 0x5635c10e7f00> 
[10:58:41.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.563]  - attr(*, "resolved")= logi FALSE
[10:58:41.563]  - attr(*, "total_size")= num 3672
[10:58:41.565] Packages to be attached in all futures: [n=0] 
[10:58:41.565] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.567] future_lapply() ...
[10:58:41.568] Number of chunks: 2
[10:58:41.569] getGlobalsAndPackagesXApply() ...
[10:58:41.569]  - future.globals: <name-value list> with names ‘list()’
[10:58:41.569]  - use_args: TRUE
[10:58:41.569] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:41.569] List of 2
[10:58:41.569]  $ ...          : list()
[10:58:41.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.569]  $ ...future.FUN:function (x)  
[10:58:41.569]  - attr(*, "where")=List of 2
[10:58:41.569]   ..$ ...          :<environment: 0x5635c10e7f00> 
[10:58:41.569]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:58:41.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.569]  - attr(*, "resolved")= logi FALSE
[10:58:41.569]  - attr(*, "total_size")= num NA
[10:58:41.572] Packages to be attached in all futures: [n=0] 
[10:58:41.572] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.572] Number of futures (= number of chunks): 2
[10:58:41.572] Launching 2 futures (chunks) ...
[10:58:41.572] Chunk #1 of 2 ...
[10:58:41.572]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.572]  - seeds: <none>
[10:58:41.572]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.573] getGlobalsAndPackages() ...
[10:58:41.573] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.573] Resolving globals: FALSE
[10:58:41.573] Tweak future expression to call with '...' arguments ...
[10:58:41.573] {
[10:58:41.573]     do.call(function(...) {
[10:58:41.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.573]             on.exit(options(oopts), add = TRUE)
[10:58:41.573]         }
[10:58:41.573]         {
[10:58:41.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.573]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.573]             })
[10:58:41.573]         }
[10:58:41.573]     }, args = future.call.arguments)
[10:58:41.573] }
[10:58:41.573] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.574] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.574] 
[10:58:41.574] getGlobalsAndPackages() ... DONE
[10:58:41.574] run() for ‘Future’ ...
[10:58:41.574] - state: ‘created’
[10:58:41.574] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.588] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.588]   - Field: ‘node’
[10:58:41.588]   - Field: ‘label’
[10:58:41.588]   - Field: ‘local’
[10:58:41.588]   - Field: ‘owner’
[10:58:41.588]   - Field: ‘envir’
[10:58:41.589]   - Field: ‘workers’
[10:58:41.589]   - Field: ‘packages’
[10:58:41.589]   - Field: ‘gc’
[10:58:41.589]   - Field: ‘conditions’
[10:58:41.589]   - Field: ‘persistent’
[10:58:41.589]   - Field: ‘expr’
[10:58:41.589]   - Field: ‘uuid’
[10:58:41.589]   - Field: ‘seed’
[10:58:41.589]   - Field: ‘version’
[10:58:41.589]   - Field: ‘result’
[10:58:41.589]   - Field: ‘asynchronous’
[10:58:41.590]   - Field: ‘calls’
[10:58:41.591]   - Field: ‘globals’
[10:58:41.591]   - Field: ‘stdout’
[10:58:41.591]   - Field: ‘earlySignal’
[10:58:41.592]   - Field: ‘lazy’
[10:58:41.592]   - Field: ‘state’
[10:58:41.592] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.592] - Launch lazy future ...
[10:58:41.592] Packages needed by the future expression (n = 0): <none>
[10:58:41.592] Packages needed by future strategies (n = 0): <none>
[10:58:41.593] {
[10:58:41.593]     {
[10:58:41.593]         {
[10:58:41.593]             ...future.startTime <- base::Sys.time()
[10:58:41.593]             {
[10:58:41.593]                 {
[10:58:41.593]                   {
[10:58:41.593]                     {
[10:58:41.593]                       base::local({
[10:58:41.593]                         has_future <- base::requireNamespace("future", 
[10:58:41.593]                           quietly = TRUE)
[10:58:41.593]                         if (has_future) {
[10:58:41.593]                           ns <- base::getNamespace("future")
[10:58:41.593]                           version <- ns[[".package"]][["version"]]
[10:58:41.593]                           if (is.null(version)) 
[10:58:41.593]                             version <- utils::packageVersion("future")
[10:58:41.593]                         }
[10:58:41.593]                         else {
[10:58:41.593]                           version <- NULL
[10:58:41.593]                         }
[10:58:41.593]                         if (!has_future || version < "1.8.0") {
[10:58:41.593]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.593]                             "", base::R.version$version.string), 
[10:58:41.593]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.593]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.593]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.593]                               "release", "version")], collapse = " "), 
[10:58:41.593]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.593]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.593]                             info)
[10:58:41.593]                           info <- base::paste(info, collapse = "; ")
[10:58:41.593]                           if (!has_future) {
[10:58:41.593]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.593]                               info)
[10:58:41.593]                           }
[10:58:41.593]                           else {
[10:58:41.593]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.593]                               info, version)
[10:58:41.593]                           }
[10:58:41.593]                           base::stop(msg)
[10:58:41.593]                         }
[10:58:41.593]                       })
[10:58:41.593]                     }
[10:58:41.593]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.593]                     base::options(mc.cores = 1L)
[10:58:41.593]                   }
[10:58:41.593]                   ...future.strategy.old <- future::plan("list")
[10:58:41.593]                   options(future.plan = NULL)
[10:58:41.593]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.593]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.593]                 }
[10:58:41.593]                 ...future.workdir <- getwd()
[10:58:41.593]             }
[10:58:41.593]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.593]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.593]         }
[10:58:41.593]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.593]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.593]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.593]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.593]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.593]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.593]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.593]             base::names(...future.oldOptions))
[10:58:41.593]     }
[10:58:41.593]     if (FALSE) {
[10:58:41.593]     }
[10:58:41.593]     else {
[10:58:41.593]         if (TRUE) {
[10:58:41.593]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.593]                 open = "w")
[10:58:41.593]         }
[10:58:41.593]         else {
[10:58:41.593]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.593]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.593]         }
[10:58:41.593]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.593]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.593]             base::sink(type = "output", split = FALSE)
[10:58:41.593]             base::close(...future.stdout)
[10:58:41.593]         }, add = TRUE)
[10:58:41.593]     }
[10:58:41.593]     ...future.frame <- base::sys.nframe()
[10:58:41.593]     ...future.conditions <- base::list()
[10:58:41.593]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.593]     if (FALSE) {
[10:58:41.593]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.593]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.593]     }
[10:58:41.593]     ...future.result <- base::tryCatch({
[10:58:41.593]         base::withCallingHandlers({
[10:58:41.593]             ...future.value <- base::withVisible(base::local({
[10:58:41.593]                 ...future.makeSendCondition <- base::local({
[10:58:41.593]                   sendCondition <- NULL
[10:58:41.593]                   function(frame = 1L) {
[10:58:41.593]                     if (is.function(sendCondition)) 
[10:58:41.593]                       return(sendCondition)
[10:58:41.593]                     ns <- getNamespace("parallel")
[10:58:41.593]                     if (exists("sendData", mode = "function", 
[10:58:41.593]                       envir = ns)) {
[10:58:41.593]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.593]                         envir = ns)
[10:58:41.593]                       envir <- sys.frame(frame)
[10:58:41.593]                       master <- NULL
[10:58:41.593]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.593]                         !identical(envir, emptyenv())) {
[10:58:41.593]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.593]                           inherits = FALSE)) {
[10:58:41.593]                           master <- get("master", mode = "list", 
[10:58:41.593]                             envir = envir, inherits = FALSE)
[10:58:41.593]                           if (inherits(master, c("SOCKnode", 
[10:58:41.593]                             "SOCK0node"))) {
[10:58:41.593]                             sendCondition <<- function(cond) {
[10:58:41.593]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.593]                                 success = TRUE)
[10:58:41.593]                               parallel_sendData(master, data)
[10:58:41.593]                             }
[10:58:41.593]                             return(sendCondition)
[10:58:41.593]                           }
[10:58:41.593]                         }
[10:58:41.593]                         frame <- frame + 1L
[10:58:41.593]                         envir <- sys.frame(frame)
[10:58:41.593]                       }
[10:58:41.593]                     }
[10:58:41.593]                     sendCondition <<- function(cond) NULL
[10:58:41.593]                   }
[10:58:41.593]                 })
[10:58:41.593]                 withCallingHandlers({
[10:58:41.593]                   {
[10:58:41.593]                     do.call(function(...) {
[10:58:41.593]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.593]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.593]                         ...future.globals.maxSize)) {
[10:58:41.593]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.593]                         on.exit(options(oopts), add = TRUE)
[10:58:41.593]                       }
[10:58:41.593]                       {
[10:58:41.593]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.593]                           FUN = function(jj) {
[10:58:41.593]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.593]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.593]                           })
[10:58:41.593]                       }
[10:58:41.593]                     }, args = future.call.arguments)
[10:58:41.593]                   }
[10:58:41.593]                 }, immediateCondition = function(cond) {
[10:58:41.593]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.593]                   sendCondition(cond)
[10:58:41.593]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.593]                   {
[10:58:41.593]                     inherits <- base::inherits
[10:58:41.593]                     invokeRestart <- base::invokeRestart
[10:58:41.593]                     is.null <- base::is.null
[10:58:41.593]                     muffled <- FALSE
[10:58:41.593]                     if (inherits(cond, "message")) {
[10:58:41.593]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.593]                       if (muffled) 
[10:58:41.593]                         invokeRestart("muffleMessage")
[10:58:41.593]                     }
[10:58:41.593]                     else if (inherits(cond, "warning")) {
[10:58:41.593]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.593]                       if (muffled) 
[10:58:41.593]                         invokeRestart("muffleWarning")
[10:58:41.593]                     }
[10:58:41.593]                     else if (inherits(cond, "condition")) {
[10:58:41.593]                       if (!is.null(pattern)) {
[10:58:41.593]                         computeRestarts <- base::computeRestarts
[10:58:41.593]                         grepl <- base::grepl
[10:58:41.593]                         restarts <- computeRestarts(cond)
[10:58:41.593]                         for (restart in restarts) {
[10:58:41.593]                           name <- restart$name
[10:58:41.593]                           if (is.null(name)) 
[10:58:41.593]                             next
[10:58:41.593]                           if (!grepl(pattern, name)) 
[10:58:41.593]                             next
[10:58:41.593]                           invokeRestart(restart)
[10:58:41.593]                           muffled <- TRUE
[10:58:41.593]                           break
[10:58:41.593]                         }
[10:58:41.593]                       }
[10:58:41.593]                     }
[10:58:41.593]                     invisible(muffled)
[10:58:41.593]                   }
[10:58:41.593]                   muffleCondition(cond)
[10:58:41.593]                 })
[10:58:41.593]             }))
[10:58:41.593]             future::FutureResult(value = ...future.value$value, 
[10:58:41.593]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.593]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.593]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.593]                     ...future.globalenv.names))
[10:58:41.593]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.593]         }, condition = base::local({
[10:58:41.593]             c <- base::c
[10:58:41.593]             inherits <- base::inherits
[10:58:41.593]             invokeRestart <- base::invokeRestart
[10:58:41.593]             length <- base::length
[10:58:41.593]             list <- base::list
[10:58:41.593]             seq.int <- base::seq.int
[10:58:41.593]             signalCondition <- base::signalCondition
[10:58:41.593]             sys.calls <- base::sys.calls
[10:58:41.593]             `[[` <- base::`[[`
[10:58:41.593]             `+` <- base::`+`
[10:58:41.593]             `<<-` <- base::`<<-`
[10:58:41.593]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.593]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.593]                   3L)]
[10:58:41.593]             }
[10:58:41.593]             function(cond) {
[10:58:41.593]                 is_error <- inherits(cond, "error")
[10:58:41.593]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.593]                   NULL)
[10:58:41.593]                 if (is_error) {
[10:58:41.593]                   sessionInformation <- function() {
[10:58:41.593]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.593]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.593]                       search = base::search(), system = base::Sys.info())
[10:58:41.593]                   }
[10:58:41.593]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.593]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.593]                     cond$call), session = sessionInformation(), 
[10:58:41.593]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.593]                   signalCondition(cond)
[10:58:41.593]                 }
[10:58:41.593]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.593]                 "immediateCondition"))) {
[10:58:41.593]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.593]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.593]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.593]                   if (TRUE && !signal) {
[10:58:41.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.593]                     {
[10:58:41.593]                       inherits <- base::inherits
[10:58:41.593]                       invokeRestart <- base::invokeRestart
[10:58:41.593]                       is.null <- base::is.null
[10:58:41.593]                       muffled <- FALSE
[10:58:41.593]                       if (inherits(cond, "message")) {
[10:58:41.593]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.593]                         if (muffled) 
[10:58:41.593]                           invokeRestart("muffleMessage")
[10:58:41.593]                       }
[10:58:41.593]                       else if (inherits(cond, "warning")) {
[10:58:41.593]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.593]                         if (muffled) 
[10:58:41.593]                           invokeRestart("muffleWarning")
[10:58:41.593]                       }
[10:58:41.593]                       else if (inherits(cond, "condition")) {
[10:58:41.593]                         if (!is.null(pattern)) {
[10:58:41.593]                           computeRestarts <- base::computeRestarts
[10:58:41.593]                           grepl <- base::grepl
[10:58:41.593]                           restarts <- computeRestarts(cond)
[10:58:41.593]                           for (restart in restarts) {
[10:58:41.593]                             name <- restart$name
[10:58:41.593]                             if (is.null(name)) 
[10:58:41.593]                               next
[10:58:41.593]                             if (!grepl(pattern, name)) 
[10:58:41.593]                               next
[10:58:41.593]                             invokeRestart(restart)
[10:58:41.593]                             muffled <- TRUE
[10:58:41.593]                             break
[10:58:41.593]                           }
[10:58:41.593]                         }
[10:58:41.593]                       }
[10:58:41.593]                       invisible(muffled)
[10:58:41.593]                     }
[10:58:41.593]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.593]                   }
[10:58:41.593]                 }
[10:58:41.593]                 else {
[10:58:41.593]                   if (TRUE) {
[10:58:41.593]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.593]                     {
[10:58:41.593]                       inherits <- base::inherits
[10:58:41.593]                       invokeRestart <- base::invokeRestart
[10:58:41.593]                       is.null <- base::is.null
[10:58:41.593]                       muffled <- FALSE
[10:58:41.593]                       if (inherits(cond, "message")) {
[10:58:41.593]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.593]                         if (muffled) 
[10:58:41.593]                           invokeRestart("muffleMessage")
[10:58:41.593]                       }
[10:58:41.593]                       else if (inherits(cond, "warning")) {
[10:58:41.593]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.593]                         if (muffled) 
[10:58:41.593]                           invokeRestart("muffleWarning")
[10:58:41.593]                       }
[10:58:41.593]                       else if (inherits(cond, "condition")) {
[10:58:41.593]                         if (!is.null(pattern)) {
[10:58:41.593]                           computeRestarts <- base::computeRestarts
[10:58:41.593]                           grepl <- base::grepl
[10:58:41.593]                           restarts <- computeRestarts(cond)
[10:58:41.593]                           for (restart in restarts) {
[10:58:41.593]                             name <- restart$name
[10:58:41.593]                             if (is.null(name)) 
[10:58:41.593]                               next
[10:58:41.593]                             if (!grepl(pattern, name)) 
[10:58:41.593]                               next
[10:58:41.593]                             invokeRestart(restart)
[10:58:41.593]                             muffled <- TRUE
[10:58:41.593]                             break
[10:58:41.593]                           }
[10:58:41.593]                         }
[10:58:41.593]                       }
[10:58:41.593]                       invisible(muffled)
[10:58:41.593]                     }
[10:58:41.593]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.593]                   }
[10:58:41.593]                 }
[10:58:41.593]             }
[10:58:41.593]         }))
[10:58:41.593]     }, error = function(ex) {
[10:58:41.593]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.593]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.593]                 ...future.rng), started = ...future.startTime, 
[10:58:41.593]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.593]             version = "1.8"), class = "FutureResult")
[10:58:41.593]     }, finally = {
[10:58:41.593]         if (!identical(...future.workdir, getwd())) 
[10:58:41.593]             setwd(...future.workdir)
[10:58:41.593]         {
[10:58:41.593]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.593]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.593]             }
[10:58:41.593]             base::options(...future.oldOptions)
[10:58:41.593]             if (.Platform$OS.type == "windows") {
[10:58:41.593]                 old_names <- names(...future.oldEnvVars)
[10:58:41.593]                 envs <- base::Sys.getenv()
[10:58:41.593]                 names <- names(envs)
[10:58:41.593]                 common <- intersect(names, old_names)
[10:58:41.593]                 added <- setdiff(names, old_names)
[10:58:41.593]                 removed <- setdiff(old_names, names)
[10:58:41.593]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.593]                   envs[common]]
[10:58:41.593]                 NAMES <- toupper(changed)
[10:58:41.593]                 args <- list()
[10:58:41.593]                 for (kk in seq_along(NAMES)) {
[10:58:41.593]                   name <- changed[[kk]]
[10:58:41.593]                   NAME <- NAMES[[kk]]
[10:58:41.593]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.593]                     next
[10:58:41.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.593]                 }
[10:58:41.593]                 NAMES <- toupper(added)
[10:58:41.593]                 for (kk in seq_along(NAMES)) {
[10:58:41.593]                   name <- added[[kk]]
[10:58:41.593]                   NAME <- NAMES[[kk]]
[10:58:41.593]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.593]                     next
[10:58:41.593]                   args[[name]] <- ""
[10:58:41.593]                 }
[10:58:41.593]                 NAMES <- toupper(removed)
[10:58:41.593]                 for (kk in seq_along(NAMES)) {
[10:58:41.593]                   name <- removed[[kk]]
[10:58:41.593]                   NAME <- NAMES[[kk]]
[10:58:41.593]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.593]                     next
[10:58:41.593]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.593]                 }
[10:58:41.593]                 if (length(args) > 0) 
[10:58:41.593]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.593]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.593]             }
[10:58:41.593]             else {
[10:58:41.593]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.593]             }
[10:58:41.593]             {
[10:58:41.593]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.593]                   0L) {
[10:58:41.593]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.593]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.593]                   base::options(opts)
[10:58:41.593]                 }
[10:58:41.593]                 {
[10:58:41.593]                   {
[10:58:41.593]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.593]                     NULL
[10:58:41.593]                   }
[10:58:41.593]                   options(future.plan = NULL)
[10:58:41.593]                   if (is.na(NA_character_)) 
[10:58:41.593]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.593]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.593]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.593]                     .init = FALSE)
[10:58:41.593]                 }
[10:58:41.593]             }
[10:58:41.593]         }
[10:58:41.593]     })
[10:58:41.593]     if (TRUE) {
[10:58:41.593]         base::sink(type = "output", split = FALSE)
[10:58:41.593]         if (TRUE) {
[10:58:41.593]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.593]         }
[10:58:41.593]         else {
[10:58:41.593]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.593]         }
[10:58:41.593]         base::close(...future.stdout)
[10:58:41.593]         ...future.stdout <- NULL
[10:58:41.593]     }
[10:58:41.593]     ...future.result$conditions <- ...future.conditions
[10:58:41.593]     ...future.result$finished <- base::Sys.time()
[10:58:41.593]     ...future.result
[10:58:41.593] }
[10:58:41.595] Exporting 5 global objects (1.11 KiB) to cluster node #1 ...
[10:58:41.595] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:41.596] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:41.596] Exporting ‘...future.FUN’ (411 bytes) to cluster node #1 ...
[10:58:41.596] Exporting ‘...future.FUN’ (411 bytes) to cluster node #1 ... DONE
[10:58:41.596] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ...
[10:58:41.597] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ... DONE
[10:58:41.597] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:41.597] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:41.597] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:41.598] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:41.598] Exporting 5 global objects (1.11 KiB) to cluster node #1 ... DONE
[10:58:41.598] MultisessionFuture started
[10:58:41.598] - Launch lazy future ... done
[10:58:41.598] run() for ‘MultisessionFuture’ ... done
[10:58:41.599] Created future:
[10:58:41.599] MultisessionFuture:
[10:58:41.599] Label: ‘future_apply-1’
[10:58:41.599] Expression:
[10:58:41.599] {
[10:58:41.599]     do.call(function(...) {
[10:58:41.599]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.599]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.599]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.599]             on.exit(options(oopts), add = TRUE)
[10:58:41.599]         }
[10:58:41.599]         {
[10:58:41.599]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.599]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.599]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.599]             })
[10:58:41.599]         }
[10:58:41.599]     }, args = future.call.arguments)
[10:58:41.599] }
[10:58:41.599] Lazy evaluation: FALSE
[10:58:41.599] Asynchronous evaluation: TRUE
[10:58:41.599] Local evaluation: TRUE
[10:58:41.599] Environment: R_GlobalEnv
[10:58:41.599] Capture standard output: TRUE
[10:58:41.599] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.599] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.599] Packages: <none>
[10:58:41.599] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.599] Resolved: FALSE
[10:58:41.599] Value: <not collected>
[10:58:41.599] Conditions captured: <none>
[10:58:41.599] Early signaling: FALSE
[10:58:41.599] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.599] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.610] Chunk #1 of 2 ... DONE
[10:58:41.610] Chunk #2 of 2 ...
[10:58:41.610]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.610]  - seeds: <none>
[10:58:41.610]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.611] getGlobalsAndPackages() ...
[10:58:41.611] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.611] Resolving globals: FALSE
[10:58:41.611] Tweak future expression to call with '...' arguments ...
[10:58:41.611] {
[10:58:41.611]     do.call(function(...) {
[10:58:41.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.611]             on.exit(options(oopts), add = TRUE)
[10:58:41.611]         }
[10:58:41.611]         {
[10:58:41.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.611]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.611]             })
[10:58:41.611]         }
[10:58:41.611]     }, args = future.call.arguments)
[10:58:41.611] }
[10:58:41.611] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.612] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.612] 
[10:58:41.612] getGlobalsAndPackages() ... DONE
[10:58:41.612] run() for ‘Future’ ...
[10:58:41.612] - state: ‘created’
[10:58:41.612] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.626] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.626]   - Field: ‘node’
[10:58:41.626]   - Field: ‘label’
[10:58:41.626]   - Field: ‘local’
[10:58:41.626]   - Field: ‘owner’
[10:58:41.626]   - Field: ‘envir’
[10:58:41.627]   - Field: ‘workers’
[10:58:41.627]   - Field: ‘packages’
[10:58:41.627]   - Field: ‘gc’
[10:58:41.627]   - Field: ‘conditions’
[10:58:41.627]   - Field: ‘persistent’
[10:58:41.627]   - Field: ‘expr’
[10:58:41.627]   - Field: ‘uuid’
[10:58:41.627]   - Field: ‘seed’
[10:58:41.627]   - Field: ‘version’
[10:58:41.627]   - Field: ‘result’
[10:58:41.627]   - Field: ‘asynchronous’
[10:58:41.627]   - Field: ‘calls’
[10:58:41.628]   - Field: ‘globals’
[10:58:41.628]   - Field: ‘stdout’
[10:58:41.628]   - Field: ‘earlySignal’
[10:58:41.628]   - Field: ‘lazy’
[10:58:41.628]   - Field: ‘state’
[10:58:41.628] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.628] - Launch lazy future ...
[10:58:41.628] Packages needed by the future expression (n = 0): <none>
[10:58:41.628] Packages needed by future strategies (n = 0): <none>
[10:58:41.629] {
[10:58:41.629]     {
[10:58:41.629]         {
[10:58:41.629]             ...future.startTime <- base::Sys.time()
[10:58:41.629]             {
[10:58:41.629]                 {
[10:58:41.629]                   {
[10:58:41.629]                     {
[10:58:41.629]                       base::local({
[10:58:41.629]                         has_future <- base::requireNamespace("future", 
[10:58:41.629]                           quietly = TRUE)
[10:58:41.629]                         if (has_future) {
[10:58:41.629]                           ns <- base::getNamespace("future")
[10:58:41.629]                           version <- ns[[".package"]][["version"]]
[10:58:41.629]                           if (is.null(version)) 
[10:58:41.629]                             version <- utils::packageVersion("future")
[10:58:41.629]                         }
[10:58:41.629]                         else {
[10:58:41.629]                           version <- NULL
[10:58:41.629]                         }
[10:58:41.629]                         if (!has_future || version < "1.8.0") {
[10:58:41.629]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.629]                             "", base::R.version$version.string), 
[10:58:41.629]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.629]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.629]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.629]                               "release", "version")], collapse = " "), 
[10:58:41.629]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.629]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.629]                             info)
[10:58:41.629]                           info <- base::paste(info, collapse = "; ")
[10:58:41.629]                           if (!has_future) {
[10:58:41.629]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.629]                               info)
[10:58:41.629]                           }
[10:58:41.629]                           else {
[10:58:41.629]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.629]                               info, version)
[10:58:41.629]                           }
[10:58:41.629]                           base::stop(msg)
[10:58:41.629]                         }
[10:58:41.629]                       })
[10:58:41.629]                     }
[10:58:41.629]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.629]                     base::options(mc.cores = 1L)
[10:58:41.629]                   }
[10:58:41.629]                   ...future.strategy.old <- future::plan("list")
[10:58:41.629]                   options(future.plan = NULL)
[10:58:41.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.629]                 }
[10:58:41.629]                 ...future.workdir <- getwd()
[10:58:41.629]             }
[10:58:41.629]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.629]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.629]         }
[10:58:41.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.629]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.629]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.629]             base::names(...future.oldOptions))
[10:58:41.629]     }
[10:58:41.629]     if (FALSE) {
[10:58:41.629]     }
[10:58:41.629]     else {
[10:58:41.629]         if (TRUE) {
[10:58:41.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.629]                 open = "w")
[10:58:41.629]         }
[10:58:41.629]         else {
[10:58:41.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.629]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.629]         }
[10:58:41.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.629]             base::sink(type = "output", split = FALSE)
[10:58:41.629]             base::close(...future.stdout)
[10:58:41.629]         }, add = TRUE)
[10:58:41.629]     }
[10:58:41.629]     ...future.frame <- base::sys.nframe()
[10:58:41.629]     ...future.conditions <- base::list()
[10:58:41.629]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.629]     if (FALSE) {
[10:58:41.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.629]     }
[10:58:41.629]     ...future.result <- base::tryCatch({
[10:58:41.629]         base::withCallingHandlers({
[10:58:41.629]             ...future.value <- base::withVisible(base::local({
[10:58:41.629]                 ...future.makeSendCondition <- base::local({
[10:58:41.629]                   sendCondition <- NULL
[10:58:41.629]                   function(frame = 1L) {
[10:58:41.629]                     if (is.function(sendCondition)) 
[10:58:41.629]                       return(sendCondition)
[10:58:41.629]                     ns <- getNamespace("parallel")
[10:58:41.629]                     if (exists("sendData", mode = "function", 
[10:58:41.629]                       envir = ns)) {
[10:58:41.629]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.629]                         envir = ns)
[10:58:41.629]                       envir <- sys.frame(frame)
[10:58:41.629]                       master <- NULL
[10:58:41.629]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.629]                         !identical(envir, emptyenv())) {
[10:58:41.629]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.629]                           inherits = FALSE)) {
[10:58:41.629]                           master <- get("master", mode = "list", 
[10:58:41.629]                             envir = envir, inherits = FALSE)
[10:58:41.629]                           if (inherits(master, c("SOCKnode", 
[10:58:41.629]                             "SOCK0node"))) {
[10:58:41.629]                             sendCondition <<- function(cond) {
[10:58:41.629]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.629]                                 success = TRUE)
[10:58:41.629]                               parallel_sendData(master, data)
[10:58:41.629]                             }
[10:58:41.629]                             return(sendCondition)
[10:58:41.629]                           }
[10:58:41.629]                         }
[10:58:41.629]                         frame <- frame + 1L
[10:58:41.629]                         envir <- sys.frame(frame)
[10:58:41.629]                       }
[10:58:41.629]                     }
[10:58:41.629]                     sendCondition <<- function(cond) NULL
[10:58:41.629]                   }
[10:58:41.629]                 })
[10:58:41.629]                 withCallingHandlers({
[10:58:41.629]                   {
[10:58:41.629]                     do.call(function(...) {
[10:58:41.629]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.629]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.629]                         ...future.globals.maxSize)) {
[10:58:41.629]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.629]                         on.exit(options(oopts), add = TRUE)
[10:58:41.629]                       }
[10:58:41.629]                       {
[10:58:41.629]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.629]                           FUN = function(jj) {
[10:58:41.629]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.629]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.629]                           })
[10:58:41.629]                       }
[10:58:41.629]                     }, args = future.call.arguments)
[10:58:41.629]                   }
[10:58:41.629]                 }, immediateCondition = function(cond) {
[10:58:41.629]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.629]                   sendCondition(cond)
[10:58:41.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.629]                   {
[10:58:41.629]                     inherits <- base::inherits
[10:58:41.629]                     invokeRestart <- base::invokeRestart
[10:58:41.629]                     is.null <- base::is.null
[10:58:41.629]                     muffled <- FALSE
[10:58:41.629]                     if (inherits(cond, "message")) {
[10:58:41.629]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.629]                       if (muffled) 
[10:58:41.629]                         invokeRestart("muffleMessage")
[10:58:41.629]                     }
[10:58:41.629]                     else if (inherits(cond, "warning")) {
[10:58:41.629]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.629]                       if (muffled) 
[10:58:41.629]                         invokeRestart("muffleWarning")
[10:58:41.629]                     }
[10:58:41.629]                     else if (inherits(cond, "condition")) {
[10:58:41.629]                       if (!is.null(pattern)) {
[10:58:41.629]                         computeRestarts <- base::computeRestarts
[10:58:41.629]                         grepl <- base::grepl
[10:58:41.629]                         restarts <- computeRestarts(cond)
[10:58:41.629]                         for (restart in restarts) {
[10:58:41.629]                           name <- restart$name
[10:58:41.629]                           if (is.null(name)) 
[10:58:41.629]                             next
[10:58:41.629]                           if (!grepl(pattern, name)) 
[10:58:41.629]                             next
[10:58:41.629]                           invokeRestart(restart)
[10:58:41.629]                           muffled <- TRUE
[10:58:41.629]                           break
[10:58:41.629]                         }
[10:58:41.629]                       }
[10:58:41.629]                     }
[10:58:41.629]                     invisible(muffled)
[10:58:41.629]                   }
[10:58:41.629]                   muffleCondition(cond)
[10:58:41.629]                 })
[10:58:41.629]             }))
[10:58:41.629]             future::FutureResult(value = ...future.value$value, 
[10:58:41.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.629]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.629]                     ...future.globalenv.names))
[10:58:41.629]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.629]         }, condition = base::local({
[10:58:41.629]             c <- base::c
[10:58:41.629]             inherits <- base::inherits
[10:58:41.629]             invokeRestart <- base::invokeRestart
[10:58:41.629]             length <- base::length
[10:58:41.629]             list <- base::list
[10:58:41.629]             seq.int <- base::seq.int
[10:58:41.629]             signalCondition <- base::signalCondition
[10:58:41.629]             sys.calls <- base::sys.calls
[10:58:41.629]             `[[` <- base::`[[`
[10:58:41.629]             `+` <- base::`+`
[10:58:41.629]             `<<-` <- base::`<<-`
[10:58:41.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.629]                   3L)]
[10:58:41.629]             }
[10:58:41.629]             function(cond) {
[10:58:41.629]                 is_error <- inherits(cond, "error")
[10:58:41.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.629]                   NULL)
[10:58:41.629]                 if (is_error) {
[10:58:41.629]                   sessionInformation <- function() {
[10:58:41.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.629]                       search = base::search(), system = base::Sys.info())
[10:58:41.629]                   }
[10:58:41.629]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.629]                     cond$call), session = sessionInformation(), 
[10:58:41.629]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.629]                   signalCondition(cond)
[10:58:41.629]                 }
[10:58:41.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.629]                 "immediateCondition"))) {
[10:58:41.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.629]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.629]                   if (TRUE && !signal) {
[10:58:41.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.629]                     {
[10:58:41.629]                       inherits <- base::inherits
[10:58:41.629]                       invokeRestart <- base::invokeRestart
[10:58:41.629]                       is.null <- base::is.null
[10:58:41.629]                       muffled <- FALSE
[10:58:41.629]                       if (inherits(cond, "message")) {
[10:58:41.629]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.629]                         if (muffled) 
[10:58:41.629]                           invokeRestart("muffleMessage")
[10:58:41.629]                       }
[10:58:41.629]                       else if (inherits(cond, "warning")) {
[10:58:41.629]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.629]                         if (muffled) 
[10:58:41.629]                           invokeRestart("muffleWarning")
[10:58:41.629]                       }
[10:58:41.629]                       else if (inherits(cond, "condition")) {
[10:58:41.629]                         if (!is.null(pattern)) {
[10:58:41.629]                           computeRestarts <- base::computeRestarts
[10:58:41.629]                           grepl <- base::grepl
[10:58:41.629]                           restarts <- computeRestarts(cond)
[10:58:41.629]                           for (restart in restarts) {
[10:58:41.629]                             name <- restart$name
[10:58:41.629]                             if (is.null(name)) 
[10:58:41.629]                               next
[10:58:41.629]                             if (!grepl(pattern, name)) 
[10:58:41.629]                               next
[10:58:41.629]                             invokeRestart(restart)
[10:58:41.629]                             muffled <- TRUE
[10:58:41.629]                             break
[10:58:41.629]                           }
[10:58:41.629]                         }
[10:58:41.629]                       }
[10:58:41.629]                       invisible(muffled)
[10:58:41.629]                     }
[10:58:41.629]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.629]                   }
[10:58:41.629]                 }
[10:58:41.629]                 else {
[10:58:41.629]                   if (TRUE) {
[10:58:41.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.629]                     {
[10:58:41.629]                       inherits <- base::inherits
[10:58:41.629]                       invokeRestart <- base::invokeRestart
[10:58:41.629]                       is.null <- base::is.null
[10:58:41.629]                       muffled <- FALSE
[10:58:41.629]                       if (inherits(cond, "message")) {
[10:58:41.629]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.629]                         if (muffled) 
[10:58:41.629]                           invokeRestart("muffleMessage")
[10:58:41.629]                       }
[10:58:41.629]                       else if (inherits(cond, "warning")) {
[10:58:41.629]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.629]                         if (muffled) 
[10:58:41.629]                           invokeRestart("muffleWarning")
[10:58:41.629]                       }
[10:58:41.629]                       else if (inherits(cond, "condition")) {
[10:58:41.629]                         if (!is.null(pattern)) {
[10:58:41.629]                           computeRestarts <- base::computeRestarts
[10:58:41.629]                           grepl <- base::grepl
[10:58:41.629]                           restarts <- computeRestarts(cond)
[10:58:41.629]                           for (restart in restarts) {
[10:58:41.629]                             name <- restart$name
[10:58:41.629]                             if (is.null(name)) 
[10:58:41.629]                               next
[10:58:41.629]                             if (!grepl(pattern, name)) 
[10:58:41.629]                               next
[10:58:41.629]                             invokeRestart(restart)
[10:58:41.629]                             muffled <- TRUE
[10:58:41.629]                             break
[10:58:41.629]                           }
[10:58:41.629]                         }
[10:58:41.629]                       }
[10:58:41.629]                       invisible(muffled)
[10:58:41.629]                     }
[10:58:41.629]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.629]                   }
[10:58:41.629]                 }
[10:58:41.629]             }
[10:58:41.629]         }))
[10:58:41.629]     }, error = function(ex) {
[10:58:41.629]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.629]                 ...future.rng), started = ...future.startTime, 
[10:58:41.629]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.629]             version = "1.8"), class = "FutureResult")
[10:58:41.629]     }, finally = {
[10:58:41.629]         if (!identical(...future.workdir, getwd())) 
[10:58:41.629]             setwd(...future.workdir)
[10:58:41.629]         {
[10:58:41.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.629]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.629]             }
[10:58:41.629]             base::options(...future.oldOptions)
[10:58:41.629]             if (.Platform$OS.type == "windows") {
[10:58:41.629]                 old_names <- names(...future.oldEnvVars)
[10:58:41.629]                 envs <- base::Sys.getenv()
[10:58:41.629]                 names <- names(envs)
[10:58:41.629]                 common <- intersect(names, old_names)
[10:58:41.629]                 added <- setdiff(names, old_names)
[10:58:41.629]                 removed <- setdiff(old_names, names)
[10:58:41.629]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.629]                   envs[common]]
[10:58:41.629]                 NAMES <- toupper(changed)
[10:58:41.629]                 args <- list()
[10:58:41.629]                 for (kk in seq_along(NAMES)) {
[10:58:41.629]                   name <- changed[[kk]]
[10:58:41.629]                   NAME <- NAMES[[kk]]
[10:58:41.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.629]                     next
[10:58:41.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.629]                 }
[10:58:41.629]                 NAMES <- toupper(added)
[10:58:41.629]                 for (kk in seq_along(NAMES)) {
[10:58:41.629]                   name <- added[[kk]]
[10:58:41.629]                   NAME <- NAMES[[kk]]
[10:58:41.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.629]                     next
[10:58:41.629]                   args[[name]] <- ""
[10:58:41.629]                 }
[10:58:41.629]                 NAMES <- toupper(removed)
[10:58:41.629]                 for (kk in seq_along(NAMES)) {
[10:58:41.629]                   name <- removed[[kk]]
[10:58:41.629]                   NAME <- NAMES[[kk]]
[10:58:41.629]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.629]                     next
[10:58:41.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.629]                 }
[10:58:41.629]                 if (length(args) > 0) 
[10:58:41.629]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.629]             }
[10:58:41.629]             else {
[10:58:41.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.629]             }
[10:58:41.629]             {
[10:58:41.629]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.629]                   0L) {
[10:58:41.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.629]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.629]                   base::options(opts)
[10:58:41.629]                 }
[10:58:41.629]                 {
[10:58:41.629]                   {
[10:58:41.629]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.629]                     NULL
[10:58:41.629]                   }
[10:58:41.629]                   options(future.plan = NULL)
[10:58:41.629]                   if (is.na(NA_character_)) 
[10:58:41.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.629]                     .init = FALSE)
[10:58:41.629]                 }
[10:58:41.629]             }
[10:58:41.629]         }
[10:58:41.629]     })
[10:58:41.629]     if (TRUE) {
[10:58:41.629]         base::sink(type = "output", split = FALSE)
[10:58:41.629]         if (TRUE) {
[10:58:41.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.629]         }
[10:58:41.629]         else {
[10:58:41.629]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.629]         }
[10:58:41.629]         base::close(...future.stdout)
[10:58:41.629]         ...future.stdout <- NULL
[10:58:41.629]     }
[10:58:41.629]     ...future.result$conditions <- ...future.conditions
[10:58:41.629]     ...future.result$finished <- base::Sys.time()
[10:58:41.629]     ...future.result
[10:58:41.629] }
[10:58:41.631] Exporting 5 global objects (1.11 KiB) to cluster node #2 ...
[10:58:41.632] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:41.632] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:41.632] Exporting ‘...future.FUN’ (411 bytes) to cluster node #2 ...
[10:58:41.632] Exporting ‘...future.FUN’ (411 bytes) to cluster node #2 ... DONE
[10:58:41.633] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ...
[10:58:41.633] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ... DONE
[10:58:41.633] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:41.633] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:41.634] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:41.634] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:41.634] Exporting 5 global objects (1.11 KiB) to cluster node #2 ... DONE
[10:58:41.635] MultisessionFuture started
[10:58:41.635] - Launch lazy future ... done
[10:58:41.635] run() for ‘MultisessionFuture’ ... done
[10:58:41.635] Created future:
[10:58:41.635] MultisessionFuture:
[10:58:41.635] Label: ‘future_apply-2’
[10:58:41.635] Expression:
[10:58:41.635] {
[10:58:41.635]     do.call(function(...) {
[10:58:41.635]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.635]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.635]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.635]             on.exit(options(oopts), add = TRUE)
[10:58:41.635]         }
[10:58:41.635]         {
[10:58:41.635]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.635]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.635]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.635]             })
[10:58:41.635]         }
[10:58:41.635]     }, args = future.call.arguments)
[10:58:41.635] }
[10:58:41.635] Lazy evaluation: FALSE
[10:58:41.635] Asynchronous evaluation: TRUE
[10:58:41.635] Local evaluation: TRUE
[10:58:41.635] Environment: R_GlobalEnv
[10:58:41.635] Capture standard output: TRUE
[10:58:41.635] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.635] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.635] Packages: <none>
[10:58:41.635] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.635] Resolved: FALSE
[10:58:41.635] Value: <not collected>
[10:58:41.635] Conditions captured: <none>
[10:58:41.635] Early signaling: FALSE
[10:58:41.635] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.635] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.646] Chunk #2 of 2 ... DONE
[10:58:41.646] Launching 2 futures (chunks) ... DONE
[10:58:41.646] Resolving 2 futures (chunks) ...
[10:58:41.647] resolve() on list ...
[10:58:41.647]  recursive: 0
[10:58:41.647]  length: 2
[10:58:41.647] 
[10:58:41.647] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.647] - Validating connection of MultisessionFuture
[10:58:41.648] - received message: FutureResult
[10:58:41.648] - Received FutureResult
[10:58:41.648] - Erased future from FutureRegistry
[10:58:41.648] result() for ClusterFuture ...
[10:58:41.648] - result already collected: FutureResult
[10:58:41.648] result() for ClusterFuture ... done
[10:58:41.648] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.648] Future #1
[10:58:41.648] result() for ClusterFuture ...
[10:58:41.648] - result already collected: FutureResult
[10:58:41.648] result() for ClusterFuture ... done
[10:58:41.649] result() for ClusterFuture ...
[10:58:41.649] - result already collected: FutureResult
[10:58:41.649] result() for ClusterFuture ... done
[10:58:41.649] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:41.649] - nx: 2
[10:58:41.649] - relay: TRUE
[10:58:41.649] - stdout: TRUE
[10:58:41.649] - signal: TRUE
[10:58:41.649] - resignal: FALSE
[10:58:41.649] - force: TRUE
[10:58:41.649] - relayed: [n=2] FALSE, FALSE
[10:58:41.649] - queued futures: [n=2] FALSE, FALSE
[10:58:41.650]  - until=1
[10:58:41.650]  - relaying element #1
[10:58:41.650] result() for ClusterFuture ...
[10:58:41.650] - result already collected: FutureResult
[10:58:41.650] result() for ClusterFuture ... done
[10:58:41.650] result() for ClusterFuture ...
[10:58:41.650] - result already collected: FutureResult
[10:58:41.650] result() for ClusterFuture ... done
[10:58:41.650] result() for ClusterFuture ...
[10:58:41.650] - result already collected: FutureResult
[10:58:41.650] result() for ClusterFuture ... done
[10:58:41.650] result() for ClusterFuture ...
[10:58:41.651] - result already collected: FutureResult
[10:58:41.651] result() for ClusterFuture ... done
[10:58:41.651] - relayed: [n=2] TRUE, FALSE
[10:58:41.651] - queued futures: [n=2] TRUE, FALSE
[10:58:41.651] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:41.651]  length: 1 (resolved future 1)
[10:58:41.676] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.676] - Validating connection of MultisessionFuture
[10:58:41.676] - received message: FutureResult
[10:58:41.677] - Received FutureResult
[10:58:41.677] - Erased future from FutureRegistry
[10:58:41.677] result() for ClusterFuture ...
[10:58:41.677] - result already collected: FutureResult
[10:58:41.677] result() for ClusterFuture ... done
[10:58:41.677] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.677] Future #2
[10:58:41.677] result() for ClusterFuture ...
[10:58:41.677] - result already collected: FutureResult
[10:58:41.677] result() for ClusterFuture ... done
[10:58:41.678] result() for ClusterFuture ...
[10:58:41.678] - result already collected: FutureResult
[10:58:41.678] result() for ClusterFuture ... done
[10:58:41.678] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:41.678] - nx: 2
[10:58:41.678] - relay: TRUE
[10:58:41.678] - stdout: TRUE
[10:58:41.678] - signal: TRUE
[10:58:41.678] - resignal: FALSE
[10:58:41.678] - force: TRUE
[10:58:41.678] - relayed: [n=2] TRUE, FALSE
[10:58:41.678] - queued futures: [n=2] TRUE, FALSE
[10:58:41.679]  - until=2
[10:58:41.679]  - relaying element #2
[10:58:41.679] result() for ClusterFuture ...
[10:58:41.679] - result already collected: FutureResult
[10:58:41.679] result() for ClusterFuture ... done
[10:58:41.679] result() for ClusterFuture ...
[10:58:41.679] - result already collected: FutureResult
[10:58:41.679] result() for ClusterFuture ... done
[10:58:41.679] result() for ClusterFuture ...
[10:58:41.679] - result already collected: FutureResult
[10:58:41.679] result() for ClusterFuture ... done
[10:58:41.679] result() for ClusterFuture ...
[10:58:41.680] - result already collected: FutureResult
[10:58:41.680] result() for ClusterFuture ... done
[10:58:41.680] - relayed: [n=2] TRUE, TRUE
[10:58:41.680] - queued futures: [n=2] TRUE, TRUE
[10:58:41.680] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:41.680]  length: 0 (resolved future 2)
[10:58:41.680] Relaying remaining futures
[10:58:41.680] signalConditionsASAP(NULL, pos=0) ...
[10:58:41.680] - nx: 2
[10:58:41.680] - relay: TRUE
[10:58:41.680] - stdout: TRUE
[10:58:41.680] - signal: TRUE
[10:58:41.681] - resignal: FALSE
[10:58:41.681] - force: TRUE
[10:58:41.681] - relayed: [n=2] TRUE, TRUE
[10:58:41.681] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:41.681] - relayed: [n=2] TRUE, TRUE
[10:58:41.681] - queued futures: [n=2] TRUE, TRUE
[10:58:41.681] signalConditionsASAP(NULL, pos=0) ... done
[10:58:41.681] resolve() on list ... DONE
[10:58:41.681] result() for ClusterFuture ...
[10:58:41.681] - result already collected: FutureResult
[10:58:41.681] result() for ClusterFuture ... done
[10:58:41.681] result() for ClusterFuture ...
[10:58:41.682] - result already collected: FutureResult
[10:58:41.682] result() for ClusterFuture ... done
[10:58:41.682] result() for ClusterFuture ...
[10:58:41.682] - result already collected: FutureResult
[10:58:41.682] result() for ClusterFuture ... done
[10:58:41.682] result() for ClusterFuture ...
[10:58:41.682] - result already collected: FutureResult
[10:58:41.682] result() for ClusterFuture ... done
[10:58:41.682]  - Number of value chunks collected: 2
[10:58:41.682] Resolving 2 futures (chunks) ... DONE
[10:58:41.682] Reducing values from 2 chunks ...
[10:58:41.682]  - Number of values collected after concatenation: 6
[10:58:41.683]  - Number of values expected: 6
[10:58:41.683] Reducing values from 2 chunks ... DONE
[10:58:41.683] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:58:41.683] getGlobalsAndPackagesXApply() ...
[10:58:41.683]  - future.globals: TRUE
[10:58:41.683] getGlobalsAndPackages() ...
[10:58:41.683] Searching for globals...
[10:58:41.684] - globals found: [1] ‘FUN’
[10:58:41.684] Searching for globals ... DONE
[10:58:41.684] Resolving globals: FALSE
[10:58:41.685] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:41.685] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:41.685] - globals: [1] ‘FUN’
[10:58:41.685] 
[10:58:41.685] getGlobalsAndPackages() ... DONE
[10:58:41.685]  - globals found/used: [n=1] ‘FUN’
[10:58:41.686]  - needed namespaces: [n=0] 
[10:58:41.686] Finding globals ... DONE
[10:58:41.686]  - use_args: TRUE
[10:58:41.686]  - Getting '...' globals ...
[10:58:41.686] resolve() on list ...
[10:58:41.686]  recursive: 0
[10:58:41.686]  length: 1
[10:58:41.686]  elements: ‘...’
[10:58:41.686]  length: 0 (resolved future 1)
[10:58:41.687] resolve() on list ... DONE
[10:58:41.687]    - '...' content: [n=0] 
[10:58:41.687] List of 1
[10:58:41.687]  $ ...: list()
[10:58:41.687]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.687]  - attr(*, "where")=List of 1
[10:58:41.687]   ..$ ...:<environment: 0x5635c05dcbc0> 
[10:58:41.687]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.687]  - attr(*, "resolved")= logi TRUE
[10:58:41.687]  - attr(*, "total_size")= num NA
[10:58:41.689]  - Getting '...' globals ... DONE
[10:58:41.689] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:41.689] List of 2
[10:58:41.689]  $ ...future.FUN:function (x)  
[10:58:41.689]  $ ...          : list()
[10:58:41.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.689]  - attr(*, "where")=List of 2
[10:58:41.689]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:41.689]   ..$ ...          :<environment: 0x5635c05dcbc0> 
[10:58:41.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.689]  - attr(*, "resolved")= logi FALSE
[10:58:41.689]  - attr(*, "total_size")= num 2547
[10:58:41.692] Packages to be attached in all futures: [n=0] 
[10:58:41.692] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.693] future_lapply() ...
[10:58:41.695] Number of chunks: 2
[10:58:41.695] getGlobalsAndPackagesXApply() ...
[10:58:41.695]  - future.globals: <name-value list> with names ‘list()’
[10:58:41.695]  - use_args: TRUE
[10:58:41.695] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:41.696] List of 2
[10:58:41.696]  $ ...          : list()
[10:58:41.696]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.696]  $ ...future.FUN:function (x)  
[10:58:41.696]  - attr(*, "where")=List of 2
[10:58:41.696]   ..$ ...          :<environment: 0x5635c05dcbc0> 
[10:58:41.696]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:41.696]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.696]  - attr(*, "resolved")= logi FALSE
[10:58:41.696]  - attr(*, "total_size")= num NA
[10:58:41.699] Packages to be attached in all futures: [n=0] 
[10:58:41.699] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.699] Number of futures (= number of chunks): 2
[10:58:41.699] Launching 2 futures (chunks) ...
[10:58:41.699] Chunk #1 of 2 ...
[10:58:41.699]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.699]  - seeds: <none>
[10:58:41.700]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.700] getGlobalsAndPackages() ...
[10:58:41.700] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.700] Resolving globals: FALSE
[10:58:41.700] Tweak future expression to call with '...' arguments ...
[10:58:41.700] {
[10:58:41.700]     do.call(function(...) {
[10:58:41.700]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.700]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.700]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.700]             on.exit(options(oopts), add = TRUE)
[10:58:41.700]         }
[10:58:41.700]         {
[10:58:41.700]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.700]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.700]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.700]             })
[10:58:41.700]         }
[10:58:41.700]     }, args = future.call.arguments)
[10:58:41.700] }
[10:58:41.700] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.701] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.701] 
[10:58:41.701] getGlobalsAndPackages() ... DONE
[10:58:41.701] run() for ‘Future’ ...
[10:58:41.701] - state: ‘created’
[10:58:41.701] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.715] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.715] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.715]   - Field: ‘node’
[10:58:41.715]   - Field: ‘label’
[10:58:41.715]   - Field: ‘local’
[10:58:41.716]   - Field: ‘owner’
[10:58:41.716]   - Field: ‘envir’
[10:58:41.716]   - Field: ‘workers’
[10:58:41.716]   - Field: ‘packages’
[10:58:41.716]   - Field: ‘gc’
[10:58:41.716]   - Field: ‘conditions’
[10:58:41.716]   - Field: ‘persistent’
[10:58:41.716]   - Field: ‘expr’
[10:58:41.716]   - Field: ‘uuid’
[10:58:41.716]   - Field: ‘seed’
[10:58:41.716]   - Field: ‘version’
[10:58:41.717]   - Field: ‘result’
[10:58:41.717]   - Field: ‘asynchronous’
[10:58:41.717]   - Field: ‘calls’
[10:58:41.717]   - Field: ‘globals’
[10:58:41.717]   - Field: ‘stdout’
[10:58:41.717]   - Field: ‘earlySignal’
[10:58:41.717]   - Field: ‘lazy’
[10:58:41.717]   - Field: ‘state’
[10:58:41.717] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.717] - Launch lazy future ...
[10:58:41.718] Packages needed by the future expression (n = 0): <none>
[10:58:41.718] Packages needed by future strategies (n = 0): <none>
[10:58:41.718] {
[10:58:41.718]     {
[10:58:41.718]         {
[10:58:41.718]             ...future.startTime <- base::Sys.time()
[10:58:41.718]             {
[10:58:41.718]                 {
[10:58:41.718]                   {
[10:58:41.718]                     {
[10:58:41.718]                       base::local({
[10:58:41.718]                         has_future <- base::requireNamespace("future", 
[10:58:41.718]                           quietly = TRUE)
[10:58:41.718]                         if (has_future) {
[10:58:41.718]                           ns <- base::getNamespace("future")
[10:58:41.718]                           version <- ns[[".package"]][["version"]]
[10:58:41.718]                           if (is.null(version)) 
[10:58:41.718]                             version <- utils::packageVersion("future")
[10:58:41.718]                         }
[10:58:41.718]                         else {
[10:58:41.718]                           version <- NULL
[10:58:41.718]                         }
[10:58:41.718]                         if (!has_future || version < "1.8.0") {
[10:58:41.718]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.718]                             "", base::R.version$version.string), 
[10:58:41.718]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.718]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.718]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.718]                               "release", "version")], collapse = " "), 
[10:58:41.718]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.718]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.718]                             info)
[10:58:41.718]                           info <- base::paste(info, collapse = "; ")
[10:58:41.718]                           if (!has_future) {
[10:58:41.718]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.718]                               info)
[10:58:41.718]                           }
[10:58:41.718]                           else {
[10:58:41.718]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.718]                               info, version)
[10:58:41.718]                           }
[10:58:41.718]                           base::stop(msg)
[10:58:41.718]                         }
[10:58:41.718]                       })
[10:58:41.718]                     }
[10:58:41.718]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.718]                     base::options(mc.cores = 1L)
[10:58:41.718]                   }
[10:58:41.718]                   ...future.strategy.old <- future::plan("list")
[10:58:41.718]                   options(future.plan = NULL)
[10:58:41.718]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.718]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.718]                 }
[10:58:41.718]                 ...future.workdir <- getwd()
[10:58:41.718]             }
[10:58:41.718]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.718]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.718]         }
[10:58:41.718]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.718]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.718]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.718]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.718]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.718]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.718]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.718]             base::names(...future.oldOptions))
[10:58:41.718]     }
[10:58:41.718]     if (FALSE) {
[10:58:41.718]     }
[10:58:41.718]     else {
[10:58:41.718]         if (TRUE) {
[10:58:41.718]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.718]                 open = "w")
[10:58:41.718]         }
[10:58:41.718]         else {
[10:58:41.718]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.718]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.718]         }
[10:58:41.718]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.718]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.718]             base::sink(type = "output", split = FALSE)
[10:58:41.718]             base::close(...future.stdout)
[10:58:41.718]         }, add = TRUE)
[10:58:41.718]     }
[10:58:41.718]     ...future.frame <- base::sys.nframe()
[10:58:41.718]     ...future.conditions <- base::list()
[10:58:41.718]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.718]     if (FALSE) {
[10:58:41.718]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.718]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.718]     }
[10:58:41.718]     ...future.result <- base::tryCatch({
[10:58:41.718]         base::withCallingHandlers({
[10:58:41.718]             ...future.value <- base::withVisible(base::local({
[10:58:41.718]                 ...future.makeSendCondition <- base::local({
[10:58:41.718]                   sendCondition <- NULL
[10:58:41.718]                   function(frame = 1L) {
[10:58:41.718]                     if (is.function(sendCondition)) 
[10:58:41.718]                       return(sendCondition)
[10:58:41.718]                     ns <- getNamespace("parallel")
[10:58:41.718]                     if (exists("sendData", mode = "function", 
[10:58:41.718]                       envir = ns)) {
[10:58:41.718]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.718]                         envir = ns)
[10:58:41.718]                       envir <- sys.frame(frame)
[10:58:41.718]                       master <- NULL
[10:58:41.718]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.718]                         !identical(envir, emptyenv())) {
[10:58:41.718]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.718]                           inherits = FALSE)) {
[10:58:41.718]                           master <- get("master", mode = "list", 
[10:58:41.718]                             envir = envir, inherits = FALSE)
[10:58:41.718]                           if (inherits(master, c("SOCKnode", 
[10:58:41.718]                             "SOCK0node"))) {
[10:58:41.718]                             sendCondition <<- function(cond) {
[10:58:41.718]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.718]                                 success = TRUE)
[10:58:41.718]                               parallel_sendData(master, data)
[10:58:41.718]                             }
[10:58:41.718]                             return(sendCondition)
[10:58:41.718]                           }
[10:58:41.718]                         }
[10:58:41.718]                         frame <- frame + 1L
[10:58:41.718]                         envir <- sys.frame(frame)
[10:58:41.718]                       }
[10:58:41.718]                     }
[10:58:41.718]                     sendCondition <<- function(cond) NULL
[10:58:41.718]                   }
[10:58:41.718]                 })
[10:58:41.718]                 withCallingHandlers({
[10:58:41.718]                   {
[10:58:41.718]                     do.call(function(...) {
[10:58:41.718]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.718]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.718]                         ...future.globals.maxSize)) {
[10:58:41.718]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.718]                         on.exit(options(oopts), add = TRUE)
[10:58:41.718]                       }
[10:58:41.718]                       {
[10:58:41.718]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.718]                           FUN = function(jj) {
[10:58:41.718]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.718]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.718]                           })
[10:58:41.718]                       }
[10:58:41.718]                     }, args = future.call.arguments)
[10:58:41.718]                   }
[10:58:41.718]                 }, immediateCondition = function(cond) {
[10:58:41.718]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.718]                   sendCondition(cond)
[10:58:41.718]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.718]                   {
[10:58:41.718]                     inherits <- base::inherits
[10:58:41.718]                     invokeRestart <- base::invokeRestart
[10:58:41.718]                     is.null <- base::is.null
[10:58:41.718]                     muffled <- FALSE
[10:58:41.718]                     if (inherits(cond, "message")) {
[10:58:41.718]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.718]                       if (muffled) 
[10:58:41.718]                         invokeRestart("muffleMessage")
[10:58:41.718]                     }
[10:58:41.718]                     else if (inherits(cond, "warning")) {
[10:58:41.718]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.718]                       if (muffled) 
[10:58:41.718]                         invokeRestart("muffleWarning")
[10:58:41.718]                     }
[10:58:41.718]                     else if (inherits(cond, "condition")) {
[10:58:41.718]                       if (!is.null(pattern)) {
[10:58:41.718]                         computeRestarts <- base::computeRestarts
[10:58:41.718]                         grepl <- base::grepl
[10:58:41.718]                         restarts <- computeRestarts(cond)
[10:58:41.718]                         for (restart in restarts) {
[10:58:41.718]                           name <- restart$name
[10:58:41.718]                           if (is.null(name)) 
[10:58:41.718]                             next
[10:58:41.718]                           if (!grepl(pattern, name)) 
[10:58:41.718]                             next
[10:58:41.718]                           invokeRestart(restart)
[10:58:41.718]                           muffled <- TRUE
[10:58:41.718]                           break
[10:58:41.718]                         }
[10:58:41.718]                       }
[10:58:41.718]                     }
[10:58:41.718]                     invisible(muffled)
[10:58:41.718]                   }
[10:58:41.718]                   muffleCondition(cond)
[10:58:41.718]                 })
[10:58:41.718]             }))
[10:58:41.718]             future::FutureResult(value = ...future.value$value, 
[10:58:41.718]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.718]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.718]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.718]                     ...future.globalenv.names))
[10:58:41.718]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.718]         }, condition = base::local({
[10:58:41.718]             c <- base::c
[10:58:41.718]             inherits <- base::inherits
[10:58:41.718]             invokeRestart <- base::invokeRestart
[10:58:41.718]             length <- base::length
[10:58:41.718]             list <- base::list
[10:58:41.718]             seq.int <- base::seq.int
[10:58:41.718]             signalCondition <- base::signalCondition
[10:58:41.718]             sys.calls <- base::sys.calls
[10:58:41.718]             `[[` <- base::`[[`
[10:58:41.718]             `+` <- base::`+`
[10:58:41.718]             `<<-` <- base::`<<-`
[10:58:41.718]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.718]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.718]                   3L)]
[10:58:41.718]             }
[10:58:41.718]             function(cond) {
[10:58:41.718]                 is_error <- inherits(cond, "error")
[10:58:41.718]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.718]                   NULL)
[10:58:41.718]                 if (is_error) {
[10:58:41.718]                   sessionInformation <- function() {
[10:58:41.718]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.718]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.718]                       search = base::search(), system = base::Sys.info())
[10:58:41.718]                   }
[10:58:41.718]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.718]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.718]                     cond$call), session = sessionInformation(), 
[10:58:41.718]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.718]                   signalCondition(cond)
[10:58:41.718]                 }
[10:58:41.718]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.718]                 "immediateCondition"))) {
[10:58:41.718]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.718]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.718]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.718]                   if (TRUE && !signal) {
[10:58:41.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.718]                     {
[10:58:41.718]                       inherits <- base::inherits
[10:58:41.718]                       invokeRestart <- base::invokeRestart
[10:58:41.718]                       is.null <- base::is.null
[10:58:41.718]                       muffled <- FALSE
[10:58:41.718]                       if (inherits(cond, "message")) {
[10:58:41.718]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.718]                         if (muffled) 
[10:58:41.718]                           invokeRestart("muffleMessage")
[10:58:41.718]                       }
[10:58:41.718]                       else if (inherits(cond, "warning")) {
[10:58:41.718]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.718]                         if (muffled) 
[10:58:41.718]                           invokeRestart("muffleWarning")
[10:58:41.718]                       }
[10:58:41.718]                       else if (inherits(cond, "condition")) {
[10:58:41.718]                         if (!is.null(pattern)) {
[10:58:41.718]                           computeRestarts <- base::computeRestarts
[10:58:41.718]                           grepl <- base::grepl
[10:58:41.718]                           restarts <- computeRestarts(cond)
[10:58:41.718]                           for (restart in restarts) {
[10:58:41.718]                             name <- restart$name
[10:58:41.718]                             if (is.null(name)) 
[10:58:41.718]                               next
[10:58:41.718]                             if (!grepl(pattern, name)) 
[10:58:41.718]                               next
[10:58:41.718]                             invokeRestart(restart)
[10:58:41.718]                             muffled <- TRUE
[10:58:41.718]                             break
[10:58:41.718]                           }
[10:58:41.718]                         }
[10:58:41.718]                       }
[10:58:41.718]                       invisible(muffled)
[10:58:41.718]                     }
[10:58:41.718]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.718]                   }
[10:58:41.718]                 }
[10:58:41.718]                 else {
[10:58:41.718]                   if (TRUE) {
[10:58:41.718]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.718]                     {
[10:58:41.718]                       inherits <- base::inherits
[10:58:41.718]                       invokeRestart <- base::invokeRestart
[10:58:41.718]                       is.null <- base::is.null
[10:58:41.718]                       muffled <- FALSE
[10:58:41.718]                       if (inherits(cond, "message")) {
[10:58:41.718]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.718]                         if (muffled) 
[10:58:41.718]                           invokeRestart("muffleMessage")
[10:58:41.718]                       }
[10:58:41.718]                       else if (inherits(cond, "warning")) {
[10:58:41.718]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.718]                         if (muffled) 
[10:58:41.718]                           invokeRestart("muffleWarning")
[10:58:41.718]                       }
[10:58:41.718]                       else if (inherits(cond, "condition")) {
[10:58:41.718]                         if (!is.null(pattern)) {
[10:58:41.718]                           computeRestarts <- base::computeRestarts
[10:58:41.718]                           grepl <- base::grepl
[10:58:41.718]                           restarts <- computeRestarts(cond)
[10:58:41.718]                           for (restart in restarts) {
[10:58:41.718]                             name <- restart$name
[10:58:41.718]                             if (is.null(name)) 
[10:58:41.718]                               next
[10:58:41.718]                             if (!grepl(pattern, name)) 
[10:58:41.718]                               next
[10:58:41.718]                             invokeRestart(restart)
[10:58:41.718]                             muffled <- TRUE
[10:58:41.718]                             break
[10:58:41.718]                           }
[10:58:41.718]                         }
[10:58:41.718]                       }
[10:58:41.718]                       invisible(muffled)
[10:58:41.718]                     }
[10:58:41.718]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.718]                   }
[10:58:41.718]                 }
[10:58:41.718]             }
[10:58:41.718]         }))
[10:58:41.718]     }, error = function(ex) {
[10:58:41.718]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.718]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.718]                 ...future.rng), started = ...future.startTime, 
[10:58:41.718]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.718]             version = "1.8"), class = "FutureResult")
[10:58:41.718]     }, finally = {
[10:58:41.718]         if (!identical(...future.workdir, getwd())) 
[10:58:41.718]             setwd(...future.workdir)
[10:58:41.718]         {
[10:58:41.718]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.718]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.718]             }
[10:58:41.718]             base::options(...future.oldOptions)
[10:58:41.718]             if (.Platform$OS.type == "windows") {
[10:58:41.718]                 old_names <- names(...future.oldEnvVars)
[10:58:41.718]                 envs <- base::Sys.getenv()
[10:58:41.718]                 names <- names(envs)
[10:58:41.718]                 common <- intersect(names, old_names)
[10:58:41.718]                 added <- setdiff(names, old_names)
[10:58:41.718]                 removed <- setdiff(old_names, names)
[10:58:41.718]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.718]                   envs[common]]
[10:58:41.718]                 NAMES <- toupper(changed)
[10:58:41.718]                 args <- list()
[10:58:41.718]                 for (kk in seq_along(NAMES)) {
[10:58:41.718]                   name <- changed[[kk]]
[10:58:41.718]                   NAME <- NAMES[[kk]]
[10:58:41.718]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.718]                     next
[10:58:41.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.718]                 }
[10:58:41.718]                 NAMES <- toupper(added)
[10:58:41.718]                 for (kk in seq_along(NAMES)) {
[10:58:41.718]                   name <- added[[kk]]
[10:58:41.718]                   NAME <- NAMES[[kk]]
[10:58:41.718]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.718]                     next
[10:58:41.718]                   args[[name]] <- ""
[10:58:41.718]                 }
[10:58:41.718]                 NAMES <- toupper(removed)
[10:58:41.718]                 for (kk in seq_along(NAMES)) {
[10:58:41.718]                   name <- removed[[kk]]
[10:58:41.718]                   NAME <- NAMES[[kk]]
[10:58:41.718]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.718]                     next
[10:58:41.718]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.718]                 }
[10:58:41.718]                 if (length(args) > 0) 
[10:58:41.718]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.718]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.718]             }
[10:58:41.718]             else {
[10:58:41.718]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.718]             }
[10:58:41.718]             {
[10:58:41.718]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.718]                   0L) {
[10:58:41.718]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.718]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.718]                   base::options(opts)
[10:58:41.718]                 }
[10:58:41.718]                 {
[10:58:41.718]                   {
[10:58:41.718]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.718]                     NULL
[10:58:41.718]                   }
[10:58:41.718]                   options(future.plan = NULL)
[10:58:41.718]                   if (is.na(NA_character_)) 
[10:58:41.718]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.718]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.718]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.718]                     .init = FALSE)
[10:58:41.718]                 }
[10:58:41.718]             }
[10:58:41.718]         }
[10:58:41.718]     })
[10:58:41.718]     if (TRUE) {
[10:58:41.718]         base::sink(type = "output", split = FALSE)
[10:58:41.718]         if (TRUE) {
[10:58:41.718]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.718]         }
[10:58:41.718]         else {
[10:58:41.718]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.718]         }
[10:58:41.718]         base::close(...future.stdout)
[10:58:41.718]         ...future.stdout <- NULL
[10:58:41.718]     }
[10:58:41.718]     ...future.result$conditions <- ...future.conditions
[10:58:41.718]     ...future.result$finished <- base::Sys.time()
[10:58:41.718]     ...future.result
[10:58:41.718] }
[10:58:41.721] Exporting 5 global objects (854 bytes) to cluster node #1 ...
[10:58:41.721] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:41.721] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:41.721] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:58:41.722] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:58:41.722] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[10:58:41.722] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[10:58:41.722] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:41.723] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:41.723] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:41.723] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:41.723] Exporting 5 global objects (854 bytes) to cluster node #1 ... DONE
[10:58:41.724] MultisessionFuture started
[10:58:41.724] - Launch lazy future ... done
[10:58:41.724] run() for ‘MultisessionFuture’ ... done
[10:58:41.724] Created future:
[10:58:41.724] MultisessionFuture:
[10:58:41.724] Label: ‘future_apply-1’
[10:58:41.724] Expression:
[10:58:41.724] {
[10:58:41.724]     do.call(function(...) {
[10:58:41.724]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.724]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.724]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.724]             on.exit(options(oopts), add = TRUE)
[10:58:41.724]         }
[10:58:41.724]         {
[10:58:41.724]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.724]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.724]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.724]             })
[10:58:41.724]         }
[10:58:41.724]     }, args = future.call.arguments)
[10:58:41.724] }
[10:58:41.724] Lazy evaluation: FALSE
[10:58:41.724] Asynchronous evaluation: TRUE
[10:58:41.724] Local evaluation: TRUE
[10:58:41.724] Environment: R_GlobalEnv
[10:58:41.724] Capture standard output: TRUE
[10:58:41.724] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.724] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.724] Packages: <none>
[10:58:41.724] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.724] Resolved: FALSE
[10:58:41.724] Value: <not collected>
[10:58:41.724] Conditions captured: <none>
[10:58:41.724] Early signaling: FALSE
[10:58:41.724] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.724] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.735] Chunk #1 of 2 ... DONE
[10:58:41.735] Chunk #2 of 2 ...
[10:58:41.736]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.736]  - seeds: <none>
[10:58:41.736]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.736] getGlobalsAndPackages() ...
[10:58:41.736] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.736] Resolving globals: FALSE
[10:58:41.736] Tweak future expression to call with '...' arguments ...
[10:58:41.737] {
[10:58:41.737]     do.call(function(...) {
[10:58:41.737]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.737]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.737]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.737]             on.exit(options(oopts), add = TRUE)
[10:58:41.737]         }
[10:58:41.737]         {
[10:58:41.737]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.737]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.737]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.737]             })
[10:58:41.737]         }
[10:58:41.737]     }, args = future.call.arguments)
[10:58:41.737] }
[10:58:41.737] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.737] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.737] 
[10:58:41.737] getGlobalsAndPackages() ... DONE
[10:58:41.738] run() for ‘Future’ ...
[10:58:41.738] - state: ‘created’
[10:58:41.738] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.752] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.752] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.752]   - Field: ‘node’
[10:58:41.752]   - Field: ‘label’
[10:58:41.752]   - Field: ‘local’
[10:58:41.752]   - Field: ‘owner’
[10:58:41.752]   - Field: ‘envir’
[10:58:41.753]   - Field: ‘workers’
[10:58:41.753]   - Field: ‘packages’
[10:58:41.753]   - Field: ‘gc’
[10:58:41.753]   - Field: ‘conditions’
[10:58:41.753]   - Field: ‘persistent’
[10:58:41.753]   - Field: ‘expr’
[10:58:41.753]   - Field: ‘uuid’
[10:58:41.753]   - Field: ‘seed’
[10:58:41.753]   - Field: ‘version’
[10:58:41.753]   - Field: ‘result’
[10:58:41.753]   - Field: ‘asynchronous’
[10:58:41.754]   - Field: ‘calls’
[10:58:41.754]   - Field: ‘globals’
[10:58:41.754]   - Field: ‘stdout’
[10:58:41.754]   - Field: ‘earlySignal’
[10:58:41.754]   - Field: ‘lazy’
[10:58:41.754]   - Field: ‘state’
[10:58:41.754] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.754] - Launch lazy future ...
[10:58:41.754] Packages needed by the future expression (n = 0): <none>
[10:58:41.755] Packages needed by future strategies (n = 0): <none>
[10:58:41.755] {
[10:58:41.755]     {
[10:58:41.755]         {
[10:58:41.755]             ...future.startTime <- base::Sys.time()
[10:58:41.755]             {
[10:58:41.755]                 {
[10:58:41.755]                   {
[10:58:41.755]                     {
[10:58:41.755]                       base::local({
[10:58:41.755]                         has_future <- base::requireNamespace("future", 
[10:58:41.755]                           quietly = TRUE)
[10:58:41.755]                         if (has_future) {
[10:58:41.755]                           ns <- base::getNamespace("future")
[10:58:41.755]                           version <- ns[[".package"]][["version"]]
[10:58:41.755]                           if (is.null(version)) 
[10:58:41.755]                             version <- utils::packageVersion("future")
[10:58:41.755]                         }
[10:58:41.755]                         else {
[10:58:41.755]                           version <- NULL
[10:58:41.755]                         }
[10:58:41.755]                         if (!has_future || version < "1.8.0") {
[10:58:41.755]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.755]                             "", base::R.version$version.string), 
[10:58:41.755]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.755]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.755]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.755]                               "release", "version")], collapse = " "), 
[10:58:41.755]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.755]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.755]                             info)
[10:58:41.755]                           info <- base::paste(info, collapse = "; ")
[10:58:41.755]                           if (!has_future) {
[10:58:41.755]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.755]                               info)
[10:58:41.755]                           }
[10:58:41.755]                           else {
[10:58:41.755]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.755]                               info, version)
[10:58:41.755]                           }
[10:58:41.755]                           base::stop(msg)
[10:58:41.755]                         }
[10:58:41.755]                       })
[10:58:41.755]                     }
[10:58:41.755]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.755]                     base::options(mc.cores = 1L)
[10:58:41.755]                   }
[10:58:41.755]                   ...future.strategy.old <- future::plan("list")
[10:58:41.755]                   options(future.plan = NULL)
[10:58:41.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.755]                 }
[10:58:41.755]                 ...future.workdir <- getwd()
[10:58:41.755]             }
[10:58:41.755]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.755]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.755]         }
[10:58:41.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.755]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.755]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.755]             base::names(...future.oldOptions))
[10:58:41.755]     }
[10:58:41.755]     if (FALSE) {
[10:58:41.755]     }
[10:58:41.755]     else {
[10:58:41.755]         if (TRUE) {
[10:58:41.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.755]                 open = "w")
[10:58:41.755]         }
[10:58:41.755]         else {
[10:58:41.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.755]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.755]         }
[10:58:41.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.755]             base::sink(type = "output", split = FALSE)
[10:58:41.755]             base::close(...future.stdout)
[10:58:41.755]         }, add = TRUE)
[10:58:41.755]     }
[10:58:41.755]     ...future.frame <- base::sys.nframe()
[10:58:41.755]     ...future.conditions <- base::list()
[10:58:41.755]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.755]     if (FALSE) {
[10:58:41.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.755]     }
[10:58:41.755]     ...future.result <- base::tryCatch({
[10:58:41.755]         base::withCallingHandlers({
[10:58:41.755]             ...future.value <- base::withVisible(base::local({
[10:58:41.755]                 ...future.makeSendCondition <- base::local({
[10:58:41.755]                   sendCondition <- NULL
[10:58:41.755]                   function(frame = 1L) {
[10:58:41.755]                     if (is.function(sendCondition)) 
[10:58:41.755]                       return(sendCondition)
[10:58:41.755]                     ns <- getNamespace("parallel")
[10:58:41.755]                     if (exists("sendData", mode = "function", 
[10:58:41.755]                       envir = ns)) {
[10:58:41.755]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.755]                         envir = ns)
[10:58:41.755]                       envir <- sys.frame(frame)
[10:58:41.755]                       master <- NULL
[10:58:41.755]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.755]                         !identical(envir, emptyenv())) {
[10:58:41.755]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.755]                           inherits = FALSE)) {
[10:58:41.755]                           master <- get("master", mode = "list", 
[10:58:41.755]                             envir = envir, inherits = FALSE)
[10:58:41.755]                           if (inherits(master, c("SOCKnode", 
[10:58:41.755]                             "SOCK0node"))) {
[10:58:41.755]                             sendCondition <<- function(cond) {
[10:58:41.755]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.755]                                 success = TRUE)
[10:58:41.755]                               parallel_sendData(master, data)
[10:58:41.755]                             }
[10:58:41.755]                             return(sendCondition)
[10:58:41.755]                           }
[10:58:41.755]                         }
[10:58:41.755]                         frame <- frame + 1L
[10:58:41.755]                         envir <- sys.frame(frame)
[10:58:41.755]                       }
[10:58:41.755]                     }
[10:58:41.755]                     sendCondition <<- function(cond) NULL
[10:58:41.755]                   }
[10:58:41.755]                 })
[10:58:41.755]                 withCallingHandlers({
[10:58:41.755]                   {
[10:58:41.755]                     do.call(function(...) {
[10:58:41.755]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.755]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.755]                         ...future.globals.maxSize)) {
[10:58:41.755]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.755]                         on.exit(options(oopts), add = TRUE)
[10:58:41.755]                       }
[10:58:41.755]                       {
[10:58:41.755]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.755]                           FUN = function(jj) {
[10:58:41.755]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.755]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.755]                           })
[10:58:41.755]                       }
[10:58:41.755]                     }, args = future.call.arguments)
[10:58:41.755]                   }
[10:58:41.755]                 }, immediateCondition = function(cond) {
[10:58:41.755]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.755]                   sendCondition(cond)
[10:58:41.755]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.755]                   {
[10:58:41.755]                     inherits <- base::inherits
[10:58:41.755]                     invokeRestart <- base::invokeRestart
[10:58:41.755]                     is.null <- base::is.null
[10:58:41.755]                     muffled <- FALSE
[10:58:41.755]                     if (inherits(cond, "message")) {
[10:58:41.755]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.755]                       if (muffled) 
[10:58:41.755]                         invokeRestart("muffleMessage")
[10:58:41.755]                     }
[10:58:41.755]                     else if (inherits(cond, "warning")) {
[10:58:41.755]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.755]                       if (muffled) 
[10:58:41.755]                         invokeRestart("muffleWarning")
[10:58:41.755]                     }
[10:58:41.755]                     else if (inherits(cond, "condition")) {
[10:58:41.755]                       if (!is.null(pattern)) {
[10:58:41.755]                         computeRestarts <- base::computeRestarts
[10:58:41.755]                         grepl <- base::grepl
[10:58:41.755]                         restarts <- computeRestarts(cond)
[10:58:41.755]                         for (restart in restarts) {
[10:58:41.755]                           name <- restart$name
[10:58:41.755]                           if (is.null(name)) 
[10:58:41.755]                             next
[10:58:41.755]                           if (!grepl(pattern, name)) 
[10:58:41.755]                             next
[10:58:41.755]                           invokeRestart(restart)
[10:58:41.755]                           muffled <- TRUE
[10:58:41.755]                           break
[10:58:41.755]                         }
[10:58:41.755]                       }
[10:58:41.755]                     }
[10:58:41.755]                     invisible(muffled)
[10:58:41.755]                   }
[10:58:41.755]                   muffleCondition(cond)
[10:58:41.755]                 })
[10:58:41.755]             }))
[10:58:41.755]             future::FutureResult(value = ...future.value$value, 
[10:58:41.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.755]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.755]                     ...future.globalenv.names))
[10:58:41.755]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.755]         }, condition = base::local({
[10:58:41.755]             c <- base::c
[10:58:41.755]             inherits <- base::inherits
[10:58:41.755]             invokeRestart <- base::invokeRestart
[10:58:41.755]             length <- base::length
[10:58:41.755]             list <- base::list
[10:58:41.755]             seq.int <- base::seq.int
[10:58:41.755]             signalCondition <- base::signalCondition
[10:58:41.755]             sys.calls <- base::sys.calls
[10:58:41.755]             `[[` <- base::`[[`
[10:58:41.755]             `+` <- base::`+`
[10:58:41.755]             `<<-` <- base::`<<-`
[10:58:41.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.755]                   3L)]
[10:58:41.755]             }
[10:58:41.755]             function(cond) {
[10:58:41.755]                 is_error <- inherits(cond, "error")
[10:58:41.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.755]                   NULL)
[10:58:41.755]                 if (is_error) {
[10:58:41.755]                   sessionInformation <- function() {
[10:58:41.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.755]                       search = base::search(), system = base::Sys.info())
[10:58:41.755]                   }
[10:58:41.755]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.755]                     cond$call), session = sessionInformation(), 
[10:58:41.755]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.755]                   signalCondition(cond)
[10:58:41.755]                 }
[10:58:41.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.755]                 "immediateCondition"))) {
[10:58:41.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.755]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.755]                   if (TRUE && !signal) {
[10:58:41.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.755]                     {
[10:58:41.755]                       inherits <- base::inherits
[10:58:41.755]                       invokeRestart <- base::invokeRestart
[10:58:41.755]                       is.null <- base::is.null
[10:58:41.755]                       muffled <- FALSE
[10:58:41.755]                       if (inherits(cond, "message")) {
[10:58:41.755]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.755]                         if (muffled) 
[10:58:41.755]                           invokeRestart("muffleMessage")
[10:58:41.755]                       }
[10:58:41.755]                       else if (inherits(cond, "warning")) {
[10:58:41.755]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.755]                         if (muffled) 
[10:58:41.755]                           invokeRestart("muffleWarning")
[10:58:41.755]                       }
[10:58:41.755]                       else if (inherits(cond, "condition")) {
[10:58:41.755]                         if (!is.null(pattern)) {
[10:58:41.755]                           computeRestarts <- base::computeRestarts
[10:58:41.755]                           grepl <- base::grepl
[10:58:41.755]                           restarts <- computeRestarts(cond)
[10:58:41.755]                           for (restart in restarts) {
[10:58:41.755]                             name <- restart$name
[10:58:41.755]                             if (is.null(name)) 
[10:58:41.755]                               next
[10:58:41.755]                             if (!grepl(pattern, name)) 
[10:58:41.755]                               next
[10:58:41.755]                             invokeRestart(restart)
[10:58:41.755]                             muffled <- TRUE
[10:58:41.755]                             break
[10:58:41.755]                           }
[10:58:41.755]                         }
[10:58:41.755]                       }
[10:58:41.755]                       invisible(muffled)
[10:58:41.755]                     }
[10:58:41.755]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.755]                   }
[10:58:41.755]                 }
[10:58:41.755]                 else {
[10:58:41.755]                   if (TRUE) {
[10:58:41.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.755]                     {
[10:58:41.755]                       inherits <- base::inherits
[10:58:41.755]                       invokeRestart <- base::invokeRestart
[10:58:41.755]                       is.null <- base::is.null
[10:58:41.755]                       muffled <- FALSE
[10:58:41.755]                       if (inherits(cond, "message")) {
[10:58:41.755]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.755]                         if (muffled) 
[10:58:41.755]                           invokeRestart("muffleMessage")
[10:58:41.755]                       }
[10:58:41.755]                       else if (inherits(cond, "warning")) {
[10:58:41.755]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.755]                         if (muffled) 
[10:58:41.755]                           invokeRestart("muffleWarning")
[10:58:41.755]                       }
[10:58:41.755]                       else if (inherits(cond, "condition")) {
[10:58:41.755]                         if (!is.null(pattern)) {
[10:58:41.755]                           computeRestarts <- base::computeRestarts
[10:58:41.755]                           grepl <- base::grepl
[10:58:41.755]                           restarts <- computeRestarts(cond)
[10:58:41.755]                           for (restart in restarts) {
[10:58:41.755]                             name <- restart$name
[10:58:41.755]                             if (is.null(name)) 
[10:58:41.755]                               next
[10:58:41.755]                             if (!grepl(pattern, name)) 
[10:58:41.755]                               next
[10:58:41.755]                             invokeRestart(restart)
[10:58:41.755]                             muffled <- TRUE
[10:58:41.755]                             break
[10:58:41.755]                           }
[10:58:41.755]                         }
[10:58:41.755]                       }
[10:58:41.755]                       invisible(muffled)
[10:58:41.755]                     }
[10:58:41.755]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.755]                   }
[10:58:41.755]                 }
[10:58:41.755]             }
[10:58:41.755]         }))
[10:58:41.755]     }, error = function(ex) {
[10:58:41.755]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.755]                 ...future.rng), started = ...future.startTime, 
[10:58:41.755]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.755]             version = "1.8"), class = "FutureResult")
[10:58:41.755]     }, finally = {
[10:58:41.755]         if (!identical(...future.workdir, getwd())) 
[10:58:41.755]             setwd(...future.workdir)
[10:58:41.755]         {
[10:58:41.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.755]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.755]             }
[10:58:41.755]             base::options(...future.oldOptions)
[10:58:41.755]             if (.Platform$OS.type == "windows") {
[10:58:41.755]                 old_names <- names(...future.oldEnvVars)
[10:58:41.755]                 envs <- base::Sys.getenv()
[10:58:41.755]                 names <- names(envs)
[10:58:41.755]                 common <- intersect(names, old_names)
[10:58:41.755]                 added <- setdiff(names, old_names)
[10:58:41.755]                 removed <- setdiff(old_names, names)
[10:58:41.755]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.755]                   envs[common]]
[10:58:41.755]                 NAMES <- toupper(changed)
[10:58:41.755]                 args <- list()
[10:58:41.755]                 for (kk in seq_along(NAMES)) {
[10:58:41.755]                   name <- changed[[kk]]
[10:58:41.755]                   NAME <- NAMES[[kk]]
[10:58:41.755]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.755]                     next
[10:58:41.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.755]                 }
[10:58:41.755]                 NAMES <- toupper(added)
[10:58:41.755]                 for (kk in seq_along(NAMES)) {
[10:58:41.755]                   name <- added[[kk]]
[10:58:41.755]                   NAME <- NAMES[[kk]]
[10:58:41.755]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.755]                     next
[10:58:41.755]                   args[[name]] <- ""
[10:58:41.755]                 }
[10:58:41.755]                 NAMES <- toupper(removed)
[10:58:41.755]                 for (kk in seq_along(NAMES)) {
[10:58:41.755]                   name <- removed[[kk]]
[10:58:41.755]                   NAME <- NAMES[[kk]]
[10:58:41.755]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.755]                     next
[10:58:41.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.755]                 }
[10:58:41.755]                 if (length(args) > 0) 
[10:58:41.755]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.755]             }
[10:58:41.755]             else {
[10:58:41.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.755]             }
[10:58:41.755]             {
[10:58:41.755]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.755]                   0L) {
[10:58:41.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.755]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.755]                   base::options(opts)
[10:58:41.755]                 }
[10:58:41.755]                 {
[10:58:41.755]                   {
[10:58:41.755]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.755]                     NULL
[10:58:41.755]                   }
[10:58:41.755]                   options(future.plan = NULL)
[10:58:41.755]                   if (is.na(NA_character_)) 
[10:58:41.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.755]                     .init = FALSE)
[10:58:41.755]                 }
[10:58:41.755]             }
[10:58:41.755]         }
[10:58:41.755]     })
[10:58:41.755]     if (TRUE) {
[10:58:41.755]         base::sink(type = "output", split = FALSE)
[10:58:41.755]         if (TRUE) {
[10:58:41.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.755]         }
[10:58:41.755]         else {
[10:58:41.755]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.755]         }
[10:58:41.755]         base::close(...future.stdout)
[10:58:41.755]         ...future.stdout <- NULL
[10:58:41.755]     }
[10:58:41.755]     ...future.result$conditions <- ...future.conditions
[10:58:41.755]     ...future.result$finished <- base::Sys.time()
[10:58:41.755]     ...future.result
[10:58:41.755] }
[10:58:41.758] Exporting 5 global objects (854 bytes) to cluster node #2 ...
[10:58:41.758] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:41.758] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:41.758] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:58:41.759] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:58:41.759] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[10:58:41.759] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[10:58:41.759] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:41.760] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:41.760] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:41.760] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:41.760] Exporting 5 global objects (854 bytes) to cluster node #2 ... DONE
[10:58:41.761] MultisessionFuture started
[10:58:41.761] - Launch lazy future ... done
[10:58:41.761] run() for ‘MultisessionFuture’ ... done
[10:58:41.761] Created future:
[10:58:41.761] MultisessionFuture:
[10:58:41.761] Label: ‘future_apply-2’
[10:58:41.761] Expression:
[10:58:41.761] {
[10:58:41.761]     do.call(function(...) {
[10:58:41.761]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.761]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.761]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.761]             on.exit(options(oopts), add = TRUE)
[10:58:41.761]         }
[10:58:41.761]         {
[10:58:41.761]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.761]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.761]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.761]             })
[10:58:41.761]         }
[10:58:41.761]     }, args = future.call.arguments)
[10:58:41.761] }
[10:58:41.761] Lazy evaluation: FALSE
[10:58:41.761] Asynchronous evaluation: TRUE
[10:58:41.761] Local evaluation: TRUE
[10:58:41.761] Environment: R_GlobalEnv
[10:58:41.761] Capture standard output: TRUE
[10:58:41.761] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.761] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.761] Packages: <none>
[10:58:41.761] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.761] Resolved: FALSE
[10:58:41.761] Value: <not collected>
[10:58:41.761] Conditions captured: <none>
[10:58:41.761] Early signaling: FALSE
[10:58:41.761] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.761] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.773] Chunk #2 of 2 ... DONE
[10:58:41.773] Launching 2 futures (chunks) ... DONE
[10:58:41.773] Resolving 2 futures (chunks) ...
[10:58:41.773] resolve() on list ...
[10:58:41.773]  recursive: 0
[10:58:41.773]  length: 2
[10:58:41.773] 
[10:58:41.774] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.774] - Validating connection of MultisessionFuture
[10:58:41.774] - received message: FutureResult
[10:58:41.774] - Received FutureResult
[10:58:41.774] - Erased future from FutureRegistry
[10:58:41.774] result() for ClusterFuture ...
[10:58:41.774] - result already collected: FutureResult
[10:58:41.774] result() for ClusterFuture ... done
[10:58:41.775] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.775] Future #1
[10:58:41.775] result() for ClusterFuture ...
[10:58:41.775] - result already collected: FutureResult
[10:58:41.775] result() for ClusterFuture ... done
[10:58:41.775] result() for ClusterFuture ...
[10:58:41.775] - result already collected: FutureResult
[10:58:41.775] result() for ClusterFuture ... done
[10:58:41.775] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:41.775] - nx: 2
[10:58:41.775] - relay: TRUE
[10:58:41.775] - stdout: TRUE
[10:58:41.776] - signal: TRUE
[10:58:41.776] - resignal: FALSE
[10:58:41.776] - force: TRUE
[10:58:41.776] - relayed: [n=2] FALSE, FALSE
[10:58:41.776] - queued futures: [n=2] FALSE, FALSE
[10:58:41.776]  - until=1
[10:58:41.776]  - relaying element #1
[10:58:41.776] result() for ClusterFuture ...
[10:58:41.776] - result already collected: FutureResult
[10:58:41.776] result() for ClusterFuture ... done
[10:58:41.776] result() for ClusterFuture ...
[10:58:41.776] - result already collected: FutureResult
[10:58:41.777] result() for ClusterFuture ... done
[10:58:41.777] result() for ClusterFuture ...
[10:58:41.777] - result already collected: FutureResult
[10:58:41.777] result() for ClusterFuture ... done
[10:58:41.777] result() for ClusterFuture ...
[10:58:41.777] - result already collected: FutureResult
[10:58:41.777] result() for ClusterFuture ... done
[10:58:41.777] - relayed: [n=2] TRUE, FALSE
[10:58:41.777] - queued futures: [n=2] TRUE, FALSE
[10:58:41.777] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:41.777]  length: 1 (resolved future 1)
[10:58:41.803] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.803] - Validating connection of MultisessionFuture
[10:58:41.803] - received message: FutureResult
[10:58:41.803] - Received FutureResult
[10:58:41.804] - Erased future from FutureRegistry
[10:58:41.804] result() for ClusterFuture ...
[10:58:41.804] - result already collected: FutureResult
[10:58:41.804] result() for ClusterFuture ... done
[10:58:41.804] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.804] Future #2
[10:58:41.804] result() for ClusterFuture ...
[10:58:41.804] - result already collected: FutureResult
[10:58:41.804] result() for ClusterFuture ... done
[10:58:41.804] result() for ClusterFuture ...
[10:58:41.804] - result already collected: FutureResult
[10:58:41.805] result() for ClusterFuture ... done
[10:58:41.806] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:41.807] - nx: 2
[10:58:41.807] - relay: TRUE
[10:58:41.807] - stdout: TRUE
[10:58:41.807] - signal: TRUE
[10:58:41.807] - resignal: FALSE
[10:58:41.807] - force: TRUE
[10:58:41.807] - relayed: [n=2] TRUE, FALSE
[10:58:41.807] - queued futures: [n=2] TRUE, FALSE
[10:58:41.807]  - until=2
[10:58:41.807]  - relaying element #2
[10:58:41.807] result() for ClusterFuture ...
[10:58:41.807] - result already collected: FutureResult
[10:58:41.808] result() for ClusterFuture ... done
[10:58:41.808] result() for ClusterFuture ...
[10:58:41.808] - result already collected: FutureResult
[10:58:41.808] result() for ClusterFuture ... done
[10:58:41.808] result() for ClusterFuture ...
[10:58:41.808] - result already collected: FutureResult
[10:58:41.808] result() for ClusterFuture ... done
[10:58:41.808] result() for ClusterFuture ...
[10:58:41.808] - result already collected: FutureResult
[10:58:41.808] result() for ClusterFuture ... done
[10:58:41.808] - relayed: [n=2] TRUE, TRUE
[10:58:41.808] - queued futures: [n=2] TRUE, TRUE
[10:58:41.809] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:41.809]  length: 0 (resolved future 2)
[10:58:41.809] Relaying remaining futures
[10:58:41.809] signalConditionsASAP(NULL, pos=0) ...
[10:58:41.809] - nx: 2
[10:58:41.809] - relay: TRUE
[10:58:41.809] - stdout: TRUE
[10:58:41.809] - signal: TRUE
[10:58:41.809] - resignal: FALSE
[10:58:41.809] - force: TRUE
[10:58:41.809] - relayed: [n=2] TRUE, TRUE
[10:58:41.809] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:41.810] - relayed: [n=2] TRUE, TRUE
[10:58:41.810] - queued futures: [n=2] TRUE, TRUE
[10:58:41.810] signalConditionsASAP(NULL, pos=0) ... done
[10:58:41.810] resolve() on list ... DONE
[10:58:41.810] result() for ClusterFuture ...
[10:58:41.810] - result already collected: FutureResult
[10:58:41.810] result() for ClusterFuture ... done
[10:58:41.810] result() for ClusterFuture ...
[10:58:41.810] - result already collected: FutureResult
[10:58:41.810] result() for ClusterFuture ... done
[10:58:41.810] result() for ClusterFuture ...
[10:58:41.810] - result already collected: FutureResult
[10:58:41.810] result() for ClusterFuture ... done
[10:58:41.811] result() for ClusterFuture ...
[10:58:41.811] - result already collected: FutureResult
[10:58:41.811] result() for ClusterFuture ... done
[10:58:41.811]  - Number of value chunks collected: 2
[10:58:41.811] Resolving 2 futures (chunks) ... DONE
[10:58:41.811] Reducing values from 2 chunks ...
[10:58:41.811]  - Number of values collected after concatenation: 2
[10:58:41.811]  - Number of values expected: 2
[10:58:41.811] Reducing values from 2 chunks ... DONE
[10:58:41.811] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:58:41.812] getGlobalsAndPackagesXApply() ...
[10:58:41.812]  - future.globals: TRUE
[10:58:41.812] getGlobalsAndPackages() ...
[10:58:41.812] Searching for globals...
[10:58:41.813] - globals found: [1] ‘FUN’
[10:58:41.813] Searching for globals ... DONE
[10:58:41.813] Resolving globals: FALSE
[10:58:41.813] The total size of the 1 globals is 185 bytes (185 bytes)
[10:58:41.814] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:58:41.814] - globals: [1] ‘FUN’
[10:58:41.814] 
[10:58:41.814] getGlobalsAndPackages() ... DONE
[10:58:41.814]  - globals found/used: [n=1] ‘FUN’
[10:58:41.814]  - needed namespaces: [n=0] 
[10:58:41.814] Finding globals ... DONE
[10:58:41.814]  - use_args: TRUE
[10:58:41.814]  - Getting '...' globals ...
[10:58:41.815] resolve() on list ...
[10:58:41.815]  recursive: 0
[10:58:41.815]  length: 1
[10:58:41.815]  elements: ‘...’
[10:58:41.815]  length: 0 (resolved future 1)
[10:58:41.815] resolve() on list ... DONE
[10:58:41.815]    - '...' content: [n=0] 
[10:58:41.815] List of 1
[10:58:41.815]  $ ...: list()
[10:58:41.815]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.815]  - attr(*, "where")=List of 1
[10:58:41.815]   ..$ ...:<environment: 0x5635bf8731b0> 
[10:58:41.815]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.815]  - attr(*, "resolved")= logi TRUE
[10:58:41.815]  - attr(*, "total_size")= num NA
[10:58:41.818]  - Getting '...' globals ... DONE
[10:58:41.818] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:41.818] List of 2
[10:58:41.818]  $ ...future.FUN:function (x)  
[10:58:41.818]  $ ...          : list()
[10:58:41.818]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.818]  - attr(*, "where")=List of 2
[10:58:41.818]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:41.818]   ..$ ...          :<environment: 0x5635bf8731b0> 
[10:58:41.818]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.818]  - attr(*, "resolved")= logi FALSE
[10:58:41.818]  - attr(*, "total_size")= num 2274
[10:58:41.820] Packages to be attached in all futures: [n=0] 
[10:58:41.821] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.822] future_lapply() ...
[10:58:41.824] Number of chunks: 2
[10:58:41.824] getGlobalsAndPackagesXApply() ...
[10:58:41.824]  - future.globals: <name-value list> with names ‘list()’
[10:58:41.824]  - use_args: TRUE
[10:58:41.824] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:41.824] List of 2
[10:58:41.824]  $ ...          : list()
[10:58:41.824]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.824]  $ ...future.FUN:function (x)  
[10:58:41.824]  - attr(*, "where")=List of 2
[10:58:41.824]   ..$ ...          :<environment: 0x5635bf8731b0> 
[10:58:41.824]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:41.824]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.824]  - attr(*, "resolved")= logi FALSE
[10:58:41.824]  - attr(*, "total_size")= num NA
[10:58:41.828] Packages to be attached in all futures: [n=0] 
[10:58:41.828] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.828] Number of futures (= number of chunks): 2
[10:58:41.828] Launching 2 futures (chunks) ...
[10:58:41.828] Chunk #1 of 2 ...
[10:58:41.828]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.828]  - seeds: <none>
[10:58:41.828]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.828] getGlobalsAndPackages() ...
[10:58:41.829] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.829] Resolving globals: FALSE
[10:58:41.829] Tweak future expression to call with '...' arguments ...
[10:58:41.829] {
[10:58:41.829]     do.call(function(...) {
[10:58:41.829]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.829]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.829]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.829]             on.exit(options(oopts), add = TRUE)
[10:58:41.829]         }
[10:58:41.829]         {
[10:58:41.829]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.829]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.829]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.829]             })
[10:58:41.829]         }
[10:58:41.829]     }, args = future.call.arguments)
[10:58:41.829] }
[10:58:41.829] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.829] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.830] 
[10:58:41.830] getGlobalsAndPackages() ... DONE
[10:58:41.830] run() for ‘Future’ ...
[10:58:41.830] - state: ‘created’
[10:58:41.830] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.844] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.844] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.844]   - Field: ‘node’
[10:58:41.844]   - Field: ‘label’
[10:58:41.844]   - Field: ‘local’
[10:58:41.844]   - Field: ‘owner’
[10:58:41.845]   - Field: ‘envir’
[10:58:41.845]   - Field: ‘workers’
[10:58:41.845]   - Field: ‘packages’
[10:58:41.845]   - Field: ‘gc’
[10:58:41.845]   - Field: ‘conditions’
[10:58:41.845]   - Field: ‘persistent’
[10:58:41.845]   - Field: ‘expr’
[10:58:41.845]   - Field: ‘uuid’
[10:58:41.845]   - Field: ‘seed’
[10:58:41.845]   - Field: ‘version’
[10:58:41.845]   - Field: ‘result’
[10:58:41.845]   - Field: ‘asynchronous’
[10:58:41.846]   - Field: ‘calls’
[10:58:41.846]   - Field: ‘globals’
[10:58:41.846]   - Field: ‘stdout’
[10:58:41.846]   - Field: ‘earlySignal’
[10:58:41.846]   - Field: ‘lazy’
[10:58:41.846]   - Field: ‘state’
[10:58:41.846] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.846] - Launch lazy future ...
[10:58:41.846] Packages needed by the future expression (n = 0): <none>
[10:58:41.847] Packages needed by future strategies (n = 0): <none>
[10:58:41.847] {
[10:58:41.847]     {
[10:58:41.847]         {
[10:58:41.847]             ...future.startTime <- base::Sys.time()
[10:58:41.847]             {
[10:58:41.847]                 {
[10:58:41.847]                   {
[10:58:41.847]                     {
[10:58:41.847]                       base::local({
[10:58:41.847]                         has_future <- base::requireNamespace("future", 
[10:58:41.847]                           quietly = TRUE)
[10:58:41.847]                         if (has_future) {
[10:58:41.847]                           ns <- base::getNamespace("future")
[10:58:41.847]                           version <- ns[[".package"]][["version"]]
[10:58:41.847]                           if (is.null(version)) 
[10:58:41.847]                             version <- utils::packageVersion("future")
[10:58:41.847]                         }
[10:58:41.847]                         else {
[10:58:41.847]                           version <- NULL
[10:58:41.847]                         }
[10:58:41.847]                         if (!has_future || version < "1.8.0") {
[10:58:41.847]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.847]                             "", base::R.version$version.string), 
[10:58:41.847]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.847]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.847]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.847]                               "release", "version")], collapse = " "), 
[10:58:41.847]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.847]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.847]                             info)
[10:58:41.847]                           info <- base::paste(info, collapse = "; ")
[10:58:41.847]                           if (!has_future) {
[10:58:41.847]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.847]                               info)
[10:58:41.847]                           }
[10:58:41.847]                           else {
[10:58:41.847]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.847]                               info, version)
[10:58:41.847]                           }
[10:58:41.847]                           base::stop(msg)
[10:58:41.847]                         }
[10:58:41.847]                       })
[10:58:41.847]                     }
[10:58:41.847]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.847]                     base::options(mc.cores = 1L)
[10:58:41.847]                   }
[10:58:41.847]                   ...future.strategy.old <- future::plan("list")
[10:58:41.847]                   options(future.plan = NULL)
[10:58:41.847]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.847]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.847]                 }
[10:58:41.847]                 ...future.workdir <- getwd()
[10:58:41.847]             }
[10:58:41.847]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.847]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.847]         }
[10:58:41.847]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.847]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.847]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.847]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.847]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.847]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.847]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.847]             base::names(...future.oldOptions))
[10:58:41.847]     }
[10:58:41.847]     if (FALSE) {
[10:58:41.847]     }
[10:58:41.847]     else {
[10:58:41.847]         if (TRUE) {
[10:58:41.847]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.847]                 open = "w")
[10:58:41.847]         }
[10:58:41.847]         else {
[10:58:41.847]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.847]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.847]         }
[10:58:41.847]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.847]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.847]             base::sink(type = "output", split = FALSE)
[10:58:41.847]             base::close(...future.stdout)
[10:58:41.847]         }, add = TRUE)
[10:58:41.847]     }
[10:58:41.847]     ...future.frame <- base::sys.nframe()
[10:58:41.847]     ...future.conditions <- base::list()
[10:58:41.847]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.847]     if (FALSE) {
[10:58:41.847]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.847]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.847]     }
[10:58:41.847]     ...future.result <- base::tryCatch({
[10:58:41.847]         base::withCallingHandlers({
[10:58:41.847]             ...future.value <- base::withVisible(base::local({
[10:58:41.847]                 ...future.makeSendCondition <- base::local({
[10:58:41.847]                   sendCondition <- NULL
[10:58:41.847]                   function(frame = 1L) {
[10:58:41.847]                     if (is.function(sendCondition)) 
[10:58:41.847]                       return(sendCondition)
[10:58:41.847]                     ns <- getNamespace("parallel")
[10:58:41.847]                     if (exists("sendData", mode = "function", 
[10:58:41.847]                       envir = ns)) {
[10:58:41.847]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.847]                         envir = ns)
[10:58:41.847]                       envir <- sys.frame(frame)
[10:58:41.847]                       master <- NULL
[10:58:41.847]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.847]                         !identical(envir, emptyenv())) {
[10:58:41.847]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.847]                           inherits = FALSE)) {
[10:58:41.847]                           master <- get("master", mode = "list", 
[10:58:41.847]                             envir = envir, inherits = FALSE)
[10:58:41.847]                           if (inherits(master, c("SOCKnode", 
[10:58:41.847]                             "SOCK0node"))) {
[10:58:41.847]                             sendCondition <<- function(cond) {
[10:58:41.847]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.847]                                 success = TRUE)
[10:58:41.847]                               parallel_sendData(master, data)
[10:58:41.847]                             }
[10:58:41.847]                             return(sendCondition)
[10:58:41.847]                           }
[10:58:41.847]                         }
[10:58:41.847]                         frame <- frame + 1L
[10:58:41.847]                         envir <- sys.frame(frame)
[10:58:41.847]                       }
[10:58:41.847]                     }
[10:58:41.847]                     sendCondition <<- function(cond) NULL
[10:58:41.847]                   }
[10:58:41.847]                 })
[10:58:41.847]                 withCallingHandlers({
[10:58:41.847]                   {
[10:58:41.847]                     do.call(function(...) {
[10:58:41.847]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.847]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.847]                         ...future.globals.maxSize)) {
[10:58:41.847]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.847]                         on.exit(options(oopts), add = TRUE)
[10:58:41.847]                       }
[10:58:41.847]                       {
[10:58:41.847]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.847]                           FUN = function(jj) {
[10:58:41.847]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.847]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.847]                           })
[10:58:41.847]                       }
[10:58:41.847]                     }, args = future.call.arguments)
[10:58:41.847]                   }
[10:58:41.847]                 }, immediateCondition = function(cond) {
[10:58:41.847]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.847]                   sendCondition(cond)
[10:58:41.847]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.847]                   {
[10:58:41.847]                     inherits <- base::inherits
[10:58:41.847]                     invokeRestart <- base::invokeRestart
[10:58:41.847]                     is.null <- base::is.null
[10:58:41.847]                     muffled <- FALSE
[10:58:41.847]                     if (inherits(cond, "message")) {
[10:58:41.847]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.847]                       if (muffled) 
[10:58:41.847]                         invokeRestart("muffleMessage")
[10:58:41.847]                     }
[10:58:41.847]                     else if (inherits(cond, "warning")) {
[10:58:41.847]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.847]                       if (muffled) 
[10:58:41.847]                         invokeRestart("muffleWarning")
[10:58:41.847]                     }
[10:58:41.847]                     else if (inherits(cond, "condition")) {
[10:58:41.847]                       if (!is.null(pattern)) {
[10:58:41.847]                         computeRestarts <- base::computeRestarts
[10:58:41.847]                         grepl <- base::grepl
[10:58:41.847]                         restarts <- computeRestarts(cond)
[10:58:41.847]                         for (restart in restarts) {
[10:58:41.847]                           name <- restart$name
[10:58:41.847]                           if (is.null(name)) 
[10:58:41.847]                             next
[10:58:41.847]                           if (!grepl(pattern, name)) 
[10:58:41.847]                             next
[10:58:41.847]                           invokeRestart(restart)
[10:58:41.847]                           muffled <- TRUE
[10:58:41.847]                           break
[10:58:41.847]                         }
[10:58:41.847]                       }
[10:58:41.847]                     }
[10:58:41.847]                     invisible(muffled)
[10:58:41.847]                   }
[10:58:41.847]                   muffleCondition(cond)
[10:58:41.847]                 })
[10:58:41.847]             }))
[10:58:41.847]             future::FutureResult(value = ...future.value$value, 
[10:58:41.847]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.847]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.847]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.847]                     ...future.globalenv.names))
[10:58:41.847]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.847]         }, condition = base::local({
[10:58:41.847]             c <- base::c
[10:58:41.847]             inherits <- base::inherits
[10:58:41.847]             invokeRestart <- base::invokeRestart
[10:58:41.847]             length <- base::length
[10:58:41.847]             list <- base::list
[10:58:41.847]             seq.int <- base::seq.int
[10:58:41.847]             signalCondition <- base::signalCondition
[10:58:41.847]             sys.calls <- base::sys.calls
[10:58:41.847]             `[[` <- base::`[[`
[10:58:41.847]             `+` <- base::`+`
[10:58:41.847]             `<<-` <- base::`<<-`
[10:58:41.847]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.847]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.847]                   3L)]
[10:58:41.847]             }
[10:58:41.847]             function(cond) {
[10:58:41.847]                 is_error <- inherits(cond, "error")
[10:58:41.847]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.847]                   NULL)
[10:58:41.847]                 if (is_error) {
[10:58:41.847]                   sessionInformation <- function() {
[10:58:41.847]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.847]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.847]                       search = base::search(), system = base::Sys.info())
[10:58:41.847]                   }
[10:58:41.847]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.847]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.847]                     cond$call), session = sessionInformation(), 
[10:58:41.847]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.847]                   signalCondition(cond)
[10:58:41.847]                 }
[10:58:41.847]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.847]                 "immediateCondition"))) {
[10:58:41.847]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.847]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.847]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.847]                   if (TRUE && !signal) {
[10:58:41.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.847]                     {
[10:58:41.847]                       inherits <- base::inherits
[10:58:41.847]                       invokeRestart <- base::invokeRestart
[10:58:41.847]                       is.null <- base::is.null
[10:58:41.847]                       muffled <- FALSE
[10:58:41.847]                       if (inherits(cond, "message")) {
[10:58:41.847]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.847]                         if (muffled) 
[10:58:41.847]                           invokeRestart("muffleMessage")
[10:58:41.847]                       }
[10:58:41.847]                       else if (inherits(cond, "warning")) {
[10:58:41.847]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.847]                         if (muffled) 
[10:58:41.847]                           invokeRestart("muffleWarning")
[10:58:41.847]                       }
[10:58:41.847]                       else if (inherits(cond, "condition")) {
[10:58:41.847]                         if (!is.null(pattern)) {
[10:58:41.847]                           computeRestarts <- base::computeRestarts
[10:58:41.847]                           grepl <- base::grepl
[10:58:41.847]                           restarts <- computeRestarts(cond)
[10:58:41.847]                           for (restart in restarts) {
[10:58:41.847]                             name <- restart$name
[10:58:41.847]                             if (is.null(name)) 
[10:58:41.847]                               next
[10:58:41.847]                             if (!grepl(pattern, name)) 
[10:58:41.847]                               next
[10:58:41.847]                             invokeRestart(restart)
[10:58:41.847]                             muffled <- TRUE
[10:58:41.847]                             break
[10:58:41.847]                           }
[10:58:41.847]                         }
[10:58:41.847]                       }
[10:58:41.847]                       invisible(muffled)
[10:58:41.847]                     }
[10:58:41.847]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.847]                   }
[10:58:41.847]                 }
[10:58:41.847]                 else {
[10:58:41.847]                   if (TRUE) {
[10:58:41.847]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.847]                     {
[10:58:41.847]                       inherits <- base::inherits
[10:58:41.847]                       invokeRestart <- base::invokeRestart
[10:58:41.847]                       is.null <- base::is.null
[10:58:41.847]                       muffled <- FALSE
[10:58:41.847]                       if (inherits(cond, "message")) {
[10:58:41.847]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.847]                         if (muffled) 
[10:58:41.847]                           invokeRestart("muffleMessage")
[10:58:41.847]                       }
[10:58:41.847]                       else if (inherits(cond, "warning")) {
[10:58:41.847]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.847]                         if (muffled) 
[10:58:41.847]                           invokeRestart("muffleWarning")
[10:58:41.847]                       }
[10:58:41.847]                       else if (inherits(cond, "condition")) {
[10:58:41.847]                         if (!is.null(pattern)) {
[10:58:41.847]                           computeRestarts <- base::computeRestarts
[10:58:41.847]                           grepl <- base::grepl
[10:58:41.847]                           restarts <- computeRestarts(cond)
[10:58:41.847]                           for (restart in restarts) {
[10:58:41.847]                             name <- restart$name
[10:58:41.847]                             if (is.null(name)) 
[10:58:41.847]                               next
[10:58:41.847]                             if (!grepl(pattern, name)) 
[10:58:41.847]                               next
[10:58:41.847]                             invokeRestart(restart)
[10:58:41.847]                             muffled <- TRUE
[10:58:41.847]                             break
[10:58:41.847]                           }
[10:58:41.847]                         }
[10:58:41.847]                       }
[10:58:41.847]                       invisible(muffled)
[10:58:41.847]                     }
[10:58:41.847]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.847]                   }
[10:58:41.847]                 }
[10:58:41.847]             }
[10:58:41.847]         }))
[10:58:41.847]     }, error = function(ex) {
[10:58:41.847]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.847]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.847]                 ...future.rng), started = ...future.startTime, 
[10:58:41.847]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.847]             version = "1.8"), class = "FutureResult")
[10:58:41.847]     }, finally = {
[10:58:41.847]         if (!identical(...future.workdir, getwd())) 
[10:58:41.847]             setwd(...future.workdir)
[10:58:41.847]         {
[10:58:41.847]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.847]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.847]             }
[10:58:41.847]             base::options(...future.oldOptions)
[10:58:41.847]             if (.Platform$OS.type == "windows") {
[10:58:41.847]                 old_names <- names(...future.oldEnvVars)
[10:58:41.847]                 envs <- base::Sys.getenv()
[10:58:41.847]                 names <- names(envs)
[10:58:41.847]                 common <- intersect(names, old_names)
[10:58:41.847]                 added <- setdiff(names, old_names)
[10:58:41.847]                 removed <- setdiff(old_names, names)
[10:58:41.847]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.847]                   envs[common]]
[10:58:41.847]                 NAMES <- toupper(changed)
[10:58:41.847]                 args <- list()
[10:58:41.847]                 for (kk in seq_along(NAMES)) {
[10:58:41.847]                   name <- changed[[kk]]
[10:58:41.847]                   NAME <- NAMES[[kk]]
[10:58:41.847]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.847]                     next
[10:58:41.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.847]                 }
[10:58:41.847]                 NAMES <- toupper(added)
[10:58:41.847]                 for (kk in seq_along(NAMES)) {
[10:58:41.847]                   name <- added[[kk]]
[10:58:41.847]                   NAME <- NAMES[[kk]]
[10:58:41.847]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.847]                     next
[10:58:41.847]                   args[[name]] <- ""
[10:58:41.847]                 }
[10:58:41.847]                 NAMES <- toupper(removed)
[10:58:41.847]                 for (kk in seq_along(NAMES)) {
[10:58:41.847]                   name <- removed[[kk]]
[10:58:41.847]                   NAME <- NAMES[[kk]]
[10:58:41.847]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.847]                     next
[10:58:41.847]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.847]                 }
[10:58:41.847]                 if (length(args) > 0) 
[10:58:41.847]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.847]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.847]             }
[10:58:41.847]             else {
[10:58:41.847]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.847]             }
[10:58:41.847]             {
[10:58:41.847]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.847]                   0L) {
[10:58:41.847]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.847]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.847]                   base::options(opts)
[10:58:41.847]                 }
[10:58:41.847]                 {
[10:58:41.847]                   {
[10:58:41.847]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.847]                     NULL
[10:58:41.847]                   }
[10:58:41.847]                   options(future.plan = NULL)
[10:58:41.847]                   if (is.na(NA_character_)) 
[10:58:41.847]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.847]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.847]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.847]                     .init = FALSE)
[10:58:41.847]                 }
[10:58:41.847]             }
[10:58:41.847]         }
[10:58:41.847]     })
[10:58:41.847]     if (TRUE) {
[10:58:41.847]         base::sink(type = "output", split = FALSE)
[10:58:41.847]         if (TRUE) {
[10:58:41.847]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.847]         }
[10:58:41.847]         else {
[10:58:41.847]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.847]         }
[10:58:41.847]         base::close(...future.stdout)
[10:58:41.847]         ...future.stdout <- NULL
[10:58:41.847]     }
[10:58:41.847]     ...future.result$conditions <- ...future.conditions
[10:58:41.847]     ...future.result$finished <- base::Sys.time()
[10:58:41.847]     ...future.result
[10:58:41.847] }
[10:58:41.850] Exporting 5 global objects (913 bytes) to cluster node #1 ...
[10:58:41.850] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:41.850] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:41.850] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:58:41.851] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:58:41.851] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #1 ...
[10:58:41.851] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #1 ... DONE
[10:58:41.851] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:41.852] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:41.852] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:41.852] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:41.852] Exporting 5 global objects (913 bytes) to cluster node #1 ... DONE
[10:58:41.853] MultisessionFuture started
[10:58:41.853] - Launch lazy future ... done
[10:58:41.853] run() for ‘MultisessionFuture’ ... done
[10:58:41.853] Created future:
[10:58:41.853] MultisessionFuture:
[10:58:41.853] Label: ‘future_apply-1’
[10:58:41.853] Expression:
[10:58:41.853] {
[10:58:41.853]     do.call(function(...) {
[10:58:41.853]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.853]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.853]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.853]             on.exit(options(oopts), add = TRUE)
[10:58:41.853]         }
[10:58:41.853]         {
[10:58:41.853]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.853]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.853]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.853]             })
[10:58:41.853]         }
[10:58:41.853]     }, args = future.call.arguments)
[10:58:41.853] }
[10:58:41.853] Lazy evaluation: FALSE
[10:58:41.853] Asynchronous evaluation: TRUE
[10:58:41.853] Local evaluation: TRUE
[10:58:41.853] Environment: R_GlobalEnv
[10:58:41.853] Capture standard output: TRUE
[10:58:41.853] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.853] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.853] Packages: <none>
[10:58:41.853] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.853] Resolved: FALSE
[10:58:41.853] Value: <not collected>
[10:58:41.853] Conditions captured: <none>
[10:58:41.853] Early signaling: FALSE
[10:58:41.853] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.853] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.864] Chunk #1 of 2 ... DONE
[10:58:41.864] Chunk #2 of 2 ...
[10:58:41.865]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.865]  - seeds: <none>
[10:58:41.865]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.865] getGlobalsAndPackages() ...
[10:58:41.865] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.865] Resolving globals: FALSE
[10:58:41.865] Tweak future expression to call with '...' arguments ...
[10:58:41.865] {
[10:58:41.865]     do.call(function(...) {
[10:58:41.865]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.865]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.865]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.865]             on.exit(options(oopts), add = TRUE)
[10:58:41.865]         }
[10:58:41.865]         {
[10:58:41.865]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.865]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.865]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.865]             })
[10:58:41.865]         }
[10:58:41.865]     }, args = future.call.arguments)
[10:58:41.865] }
[10:58:41.866] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.866] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.866] 
[10:58:41.866] getGlobalsAndPackages() ... DONE
[10:58:41.866] run() for ‘Future’ ...
[10:58:41.866] - state: ‘created’
[10:58:41.867] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.880] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.880] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.880]   - Field: ‘node’
[10:58:41.880]   - Field: ‘label’
[10:58:41.880]   - Field: ‘local’
[10:58:41.881]   - Field: ‘owner’
[10:58:41.881]   - Field: ‘envir’
[10:58:41.881]   - Field: ‘workers’
[10:58:41.881]   - Field: ‘packages’
[10:58:41.881]   - Field: ‘gc’
[10:58:41.881]   - Field: ‘conditions’
[10:58:41.881]   - Field: ‘persistent’
[10:58:41.881]   - Field: ‘expr’
[10:58:41.881]   - Field: ‘uuid’
[10:58:41.881]   - Field: ‘seed’
[10:58:41.881]   - Field: ‘version’
[10:58:41.882]   - Field: ‘result’
[10:58:41.882]   - Field: ‘asynchronous’
[10:58:41.882]   - Field: ‘calls’
[10:58:41.882]   - Field: ‘globals’
[10:58:41.882]   - Field: ‘stdout’
[10:58:41.882]   - Field: ‘earlySignal’
[10:58:41.882]   - Field: ‘lazy’
[10:58:41.882]   - Field: ‘state’
[10:58:41.882] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.882] - Launch lazy future ...
[10:58:41.883] Packages needed by the future expression (n = 0): <none>
[10:58:41.883] Packages needed by future strategies (n = 0): <none>
[10:58:41.883] {
[10:58:41.883]     {
[10:58:41.883]         {
[10:58:41.883]             ...future.startTime <- base::Sys.time()
[10:58:41.883]             {
[10:58:41.883]                 {
[10:58:41.883]                   {
[10:58:41.883]                     {
[10:58:41.883]                       base::local({
[10:58:41.883]                         has_future <- base::requireNamespace("future", 
[10:58:41.883]                           quietly = TRUE)
[10:58:41.883]                         if (has_future) {
[10:58:41.883]                           ns <- base::getNamespace("future")
[10:58:41.883]                           version <- ns[[".package"]][["version"]]
[10:58:41.883]                           if (is.null(version)) 
[10:58:41.883]                             version <- utils::packageVersion("future")
[10:58:41.883]                         }
[10:58:41.883]                         else {
[10:58:41.883]                           version <- NULL
[10:58:41.883]                         }
[10:58:41.883]                         if (!has_future || version < "1.8.0") {
[10:58:41.883]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.883]                             "", base::R.version$version.string), 
[10:58:41.883]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.883]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.883]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.883]                               "release", "version")], collapse = " "), 
[10:58:41.883]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.883]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.883]                             info)
[10:58:41.883]                           info <- base::paste(info, collapse = "; ")
[10:58:41.883]                           if (!has_future) {
[10:58:41.883]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.883]                               info)
[10:58:41.883]                           }
[10:58:41.883]                           else {
[10:58:41.883]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.883]                               info, version)
[10:58:41.883]                           }
[10:58:41.883]                           base::stop(msg)
[10:58:41.883]                         }
[10:58:41.883]                       })
[10:58:41.883]                     }
[10:58:41.883]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.883]                     base::options(mc.cores = 1L)
[10:58:41.883]                   }
[10:58:41.883]                   ...future.strategy.old <- future::plan("list")
[10:58:41.883]                   options(future.plan = NULL)
[10:58:41.883]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.883]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.883]                 }
[10:58:41.883]                 ...future.workdir <- getwd()
[10:58:41.883]             }
[10:58:41.883]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.883]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.883]         }
[10:58:41.883]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.883]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.883]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.883]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.883]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.883]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.883]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.883]             base::names(...future.oldOptions))
[10:58:41.883]     }
[10:58:41.883]     if (FALSE) {
[10:58:41.883]     }
[10:58:41.883]     else {
[10:58:41.883]         if (TRUE) {
[10:58:41.883]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.883]                 open = "w")
[10:58:41.883]         }
[10:58:41.883]         else {
[10:58:41.883]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.883]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.883]         }
[10:58:41.883]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.883]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.883]             base::sink(type = "output", split = FALSE)
[10:58:41.883]             base::close(...future.stdout)
[10:58:41.883]         }, add = TRUE)
[10:58:41.883]     }
[10:58:41.883]     ...future.frame <- base::sys.nframe()
[10:58:41.883]     ...future.conditions <- base::list()
[10:58:41.883]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.883]     if (FALSE) {
[10:58:41.883]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.883]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.883]     }
[10:58:41.883]     ...future.result <- base::tryCatch({
[10:58:41.883]         base::withCallingHandlers({
[10:58:41.883]             ...future.value <- base::withVisible(base::local({
[10:58:41.883]                 ...future.makeSendCondition <- base::local({
[10:58:41.883]                   sendCondition <- NULL
[10:58:41.883]                   function(frame = 1L) {
[10:58:41.883]                     if (is.function(sendCondition)) 
[10:58:41.883]                       return(sendCondition)
[10:58:41.883]                     ns <- getNamespace("parallel")
[10:58:41.883]                     if (exists("sendData", mode = "function", 
[10:58:41.883]                       envir = ns)) {
[10:58:41.883]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.883]                         envir = ns)
[10:58:41.883]                       envir <- sys.frame(frame)
[10:58:41.883]                       master <- NULL
[10:58:41.883]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.883]                         !identical(envir, emptyenv())) {
[10:58:41.883]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.883]                           inherits = FALSE)) {
[10:58:41.883]                           master <- get("master", mode = "list", 
[10:58:41.883]                             envir = envir, inherits = FALSE)
[10:58:41.883]                           if (inherits(master, c("SOCKnode", 
[10:58:41.883]                             "SOCK0node"))) {
[10:58:41.883]                             sendCondition <<- function(cond) {
[10:58:41.883]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.883]                                 success = TRUE)
[10:58:41.883]                               parallel_sendData(master, data)
[10:58:41.883]                             }
[10:58:41.883]                             return(sendCondition)
[10:58:41.883]                           }
[10:58:41.883]                         }
[10:58:41.883]                         frame <- frame + 1L
[10:58:41.883]                         envir <- sys.frame(frame)
[10:58:41.883]                       }
[10:58:41.883]                     }
[10:58:41.883]                     sendCondition <<- function(cond) NULL
[10:58:41.883]                   }
[10:58:41.883]                 })
[10:58:41.883]                 withCallingHandlers({
[10:58:41.883]                   {
[10:58:41.883]                     do.call(function(...) {
[10:58:41.883]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.883]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.883]                         ...future.globals.maxSize)) {
[10:58:41.883]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.883]                         on.exit(options(oopts), add = TRUE)
[10:58:41.883]                       }
[10:58:41.883]                       {
[10:58:41.883]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.883]                           FUN = function(jj) {
[10:58:41.883]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.883]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.883]                           })
[10:58:41.883]                       }
[10:58:41.883]                     }, args = future.call.arguments)
[10:58:41.883]                   }
[10:58:41.883]                 }, immediateCondition = function(cond) {
[10:58:41.883]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.883]                   sendCondition(cond)
[10:58:41.883]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.883]                   {
[10:58:41.883]                     inherits <- base::inherits
[10:58:41.883]                     invokeRestart <- base::invokeRestart
[10:58:41.883]                     is.null <- base::is.null
[10:58:41.883]                     muffled <- FALSE
[10:58:41.883]                     if (inherits(cond, "message")) {
[10:58:41.883]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.883]                       if (muffled) 
[10:58:41.883]                         invokeRestart("muffleMessage")
[10:58:41.883]                     }
[10:58:41.883]                     else if (inherits(cond, "warning")) {
[10:58:41.883]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.883]                       if (muffled) 
[10:58:41.883]                         invokeRestart("muffleWarning")
[10:58:41.883]                     }
[10:58:41.883]                     else if (inherits(cond, "condition")) {
[10:58:41.883]                       if (!is.null(pattern)) {
[10:58:41.883]                         computeRestarts <- base::computeRestarts
[10:58:41.883]                         grepl <- base::grepl
[10:58:41.883]                         restarts <- computeRestarts(cond)
[10:58:41.883]                         for (restart in restarts) {
[10:58:41.883]                           name <- restart$name
[10:58:41.883]                           if (is.null(name)) 
[10:58:41.883]                             next
[10:58:41.883]                           if (!grepl(pattern, name)) 
[10:58:41.883]                             next
[10:58:41.883]                           invokeRestart(restart)
[10:58:41.883]                           muffled <- TRUE
[10:58:41.883]                           break
[10:58:41.883]                         }
[10:58:41.883]                       }
[10:58:41.883]                     }
[10:58:41.883]                     invisible(muffled)
[10:58:41.883]                   }
[10:58:41.883]                   muffleCondition(cond)
[10:58:41.883]                 })
[10:58:41.883]             }))
[10:58:41.883]             future::FutureResult(value = ...future.value$value, 
[10:58:41.883]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.883]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.883]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.883]                     ...future.globalenv.names))
[10:58:41.883]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.883]         }, condition = base::local({
[10:58:41.883]             c <- base::c
[10:58:41.883]             inherits <- base::inherits
[10:58:41.883]             invokeRestart <- base::invokeRestart
[10:58:41.883]             length <- base::length
[10:58:41.883]             list <- base::list
[10:58:41.883]             seq.int <- base::seq.int
[10:58:41.883]             signalCondition <- base::signalCondition
[10:58:41.883]             sys.calls <- base::sys.calls
[10:58:41.883]             `[[` <- base::`[[`
[10:58:41.883]             `+` <- base::`+`
[10:58:41.883]             `<<-` <- base::`<<-`
[10:58:41.883]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.883]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.883]                   3L)]
[10:58:41.883]             }
[10:58:41.883]             function(cond) {
[10:58:41.883]                 is_error <- inherits(cond, "error")
[10:58:41.883]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.883]                   NULL)
[10:58:41.883]                 if (is_error) {
[10:58:41.883]                   sessionInformation <- function() {
[10:58:41.883]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.883]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.883]                       search = base::search(), system = base::Sys.info())
[10:58:41.883]                   }
[10:58:41.883]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.883]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.883]                     cond$call), session = sessionInformation(), 
[10:58:41.883]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.883]                   signalCondition(cond)
[10:58:41.883]                 }
[10:58:41.883]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.883]                 "immediateCondition"))) {
[10:58:41.883]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.883]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.883]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.883]                   if (TRUE && !signal) {
[10:58:41.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.883]                     {
[10:58:41.883]                       inherits <- base::inherits
[10:58:41.883]                       invokeRestart <- base::invokeRestart
[10:58:41.883]                       is.null <- base::is.null
[10:58:41.883]                       muffled <- FALSE
[10:58:41.883]                       if (inherits(cond, "message")) {
[10:58:41.883]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.883]                         if (muffled) 
[10:58:41.883]                           invokeRestart("muffleMessage")
[10:58:41.883]                       }
[10:58:41.883]                       else if (inherits(cond, "warning")) {
[10:58:41.883]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.883]                         if (muffled) 
[10:58:41.883]                           invokeRestart("muffleWarning")
[10:58:41.883]                       }
[10:58:41.883]                       else if (inherits(cond, "condition")) {
[10:58:41.883]                         if (!is.null(pattern)) {
[10:58:41.883]                           computeRestarts <- base::computeRestarts
[10:58:41.883]                           grepl <- base::grepl
[10:58:41.883]                           restarts <- computeRestarts(cond)
[10:58:41.883]                           for (restart in restarts) {
[10:58:41.883]                             name <- restart$name
[10:58:41.883]                             if (is.null(name)) 
[10:58:41.883]                               next
[10:58:41.883]                             if (!grepl(pattern, name)) 
[10:58:41.883]                               next
[10:58:41.883]                             invokeRestart(restart)
[10:58:41.883]                             muffled <- TRUE
[10:58:41.883]                             break
[10:58:41.883]                           }
[10:58:41.883]                         }
[10:58:41.883]                       }
[10:58:41.883]                       invisible(muffled)
[10:58:41.883]                     }
[10:58:41.883]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.883]                   }
[10:58:41.883]                 }
[10:58:41.883]                 else {
[10:58:41.883]                   if (TRUE) {
[10:58:41.883]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.883]                     {
[10:58:41.883]                       inherits <- base::inherits
[10:58:41.883]                       invokeRestart <- base::invokeRestart
[10:58:41.883]                       is.null <- base::is.null
[10:58:41.883]                       muffled <- FALSE
[10:58:41.883]                       if (inherits(cond, "message")) {
[10:58:41.883]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.883]                         if (muffled) 
[10:58:41.883]                           invokeRestart("muffleMessage")
[10:58:41.883]                       }
[10:58:41.883]                       else if (inherits(cond, "warning")) {
[10:58:41.883]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.883]                         if (muffled) 
[10:58:41.883]                           invokeRestart("muffleWarning")
[10:58:41.883]                       }
[10:58:41.883]                       else if (inherits(cond, "condition")) {
[10:58:41.883]                         if (!is.null(pattern)) {
[10:58:41.883]                           computeRestarts <- base::computeRestarts
[10:58:41.883]                           grepl <- base::grepl
[10:58:41.883]                           restarts <- computeRestarts(cond)
[10:58:41.883]                           for (restart in restarts) {
[10:58:41.883]                             name <- restart$name
[10:58:41.883]                             if (is.null(name)) 
[10:58:41.883]                               next
[10:58:41.883]                             if (!grepl(pattern, name)) 
[10:58:41.883]                               next
[10:58:41.883]                             invokeRestart(restart)
[10:58:41.883]                             muffled <- TRUE
[10:58:41.883]                             break
[10:58:41.883]                           }
[10:58:41.883]                         }
[10:58:41.883]                       }
[10:58:41.883]                       invisible(muffled)
[10:58:41.883]                     }
[10:58:41.883]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.883]                   }
[10:58:41.883]                 }
[10:58:41.883]             }
[10:58:41.883]         }))
[10:58:41.883]     }, error = function(ex) {
[10:58:41.883]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.883]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.883]                 ...future.rng), started = ...future.startTime, 
[10:58:41.883]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.883]             version = "1.8"), class = "FutureResult")
[10:58:41.883]     }, finally = {
[10:58:41.883]         if (!identical(...future.workdir, getwd())) 
[10:58:41.883]             setwd(...future.workdir)
[10:58:41.883]         {
[10:58:41.883]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.883]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.883]             }
[10:58:41.883]             base::options(...future.oldOptions)
[10:58:41.883]             if (.Platform$OS.type == "windows") {
[10:58:41.883]                 old_names <- names(...future.oldEnvVars)
[10:58:41.883]                 envs <- base::Sys.getenv()
[10:58:41.883]                 names <- names(envs)
[10:58:41.883]                 common <- intersect(names, old_names)
[10:58:41.883]                 added <- setdiff(names, old_names)
[10:58:41.883]                 removed <- setdiff(old_names, names)
[10:58:41.883]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.883]                   envs[common]]
[10:58:41.883]                 NAMES <- toupper(changed)
[10:58:41.883]                 args <- list()
[10:58:41.883]                 for (kk in seq_along(NAMES)) {
[10:58:41.883]                   name <- changed[[kk]]
[10:58:41.883]                   NAME <- NAMES[[kk]]
[10:58:41.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.883]                     next
[10:58:41.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.883]                 }
[10:58:41.883]                 NAMES <- toupper(added)
[10:58:41.883]                 for (kk in seq_along(NAMES)) {
[10:58:41.883]                   name <- added[[kk]]
[10:58:41.883]                   NAME <- NAMES[[kk]]
[10:58:41.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.883]                     next
[10:58:41.883]                   args[[name]] <- ""
[10:58:41.883]                 }
[10:58:41.883]                 NAMES <- toupper(removed)
[10:58:41.883]                 for (kk in seq_along(NAMES)) {
[10:58:41.883]                   name <- removed[[kk]]
[10:58:41.883]                   NAME <- NAMES[[kk]]
[10:58:41.883]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.883]                     next
[10:58:41.883]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.883]                 }
[10:58:41.883]                 if (length(args) > 0) 
[10:58:41.883]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.883]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.883]             }
[10:58:41.883]             else {
[10:58:41.883]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.883]             }
[10:58:41.883]             {
[10:58:41.883]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.883]                   0L) {
[10:58:41.883]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.883]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.883]                   base::options(opts)
[10:58:41.883]                 }
[10:58:41.883]                 {
[10:58:41.883]                   {
[10:58:41.883]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.883]                     NULL
[10:58:41.883]                   }
[10:58:41.883]                   options(future.plan = NULL)
[10:58:41.883]                   if (is.na(NA_character_)) 
[10:58:41.883]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.883]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.883]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.883]                     .init = FALSE)
[10:58:41.883]                 }
[10:58:41.883]             }
[10:58:41.883]         }
[10:58:41.883]     })
[10:58:41.883]     if (TRUE) {
[10:58:41.883]         base::sink(type = "output", split = FALSE)
[10:58:41.883]         if (TRUE) {
[10:58:41.883]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.883]         }
[10:58:41.883]         else {
[10:58:41.883]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.883]         }
[10:58:41.883]         base::close(...future.stdout)
[10:58:41.883]         ...future.stdout <- NULL
[10:58:41.883]     }
[10:58:41.883]     ...future.result$conditions <- ...future.conditions
[10:58:41.883]     ...future.result$finished <- base::Sys.time()
[10:58:41.883]     ...future.result
[10:58:41.883] }
[10:58:41.886] Exporting 5 global objects (913 bytes) to cluster node #2 ...
[10:58:41.886] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:41.886] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:41.886] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:58:41.887] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:58:41.887] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #2 ...
[10:58:41.887] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #2 ... DONE
[10:58:41.887] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:41.888] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:41.888] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:41.888] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:41.888] Exporting 5 global objects (913 bytes) to cluster node #2 ... DONE
[10:58:41.889] MultisessionFuture started
[10:58:41.889] - Launch lazy future ... done
[10:58:41.889] run() for ‘MultisessionFuture’ ... done
[10:58:41.889] Created future:
[10:58:41.889] MultisessionFuture:
[10:58:41.889] Label: ‘future_apply-2’
[10:58:41.889] Expression:
[10:58:41.889] {
[10:58:41.889]     do.call(function(...) {
[10:58:41.889]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.889]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.889]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.889]             on.exit(options(oopts), add = TRUE)
[10:58:41.889]         }
[10:58:41.889]         {
[10:58:41.889]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.889]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.889]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.889]             })
[10:58:41.889]         }
[10:58:41.889]     }, args = future.call.arguments)
[10:58:41.889] }
[10:58:41.889] Lazy evaluation: FALSE
[10:58:41.889] Asynchronous evaluation: TRUE
[10:58:41.889] Local evaluation: TRUE
[10:58:41.889] Environment: R_GlobalEnv
[10:58:41.889] Capture standard output: TRUE
[10:58:41.889] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.889] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.889] Packages: <none>
[10:58:41.889] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.889] Resolved: FALSE
[10:58:41.889] Value: <not collected>
[10:58:41.889] Conditions captured: <none>
[10:58:41.889] Early signaling: FALSE
[10:58:41.889] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.889] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.900] Chunk #2 of 2 ... DONE
[10:58:41.901] Launching 2 futures (chunks) ... DONE
[10:58:41.901] Resolving 2 futures (chunks) ...
[10:58:41.901] resolve() on list ...
[10:58:41.901]  recursive: 0
[10:58:41.901]  length: 2
[10:58:41.901] 
[10:58:41.902] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.902] - Validating connection of MultisessionFuture
[10:58:41.902] - received message: FutureResult
[10:58:41.902] - Received FutureResult
[10:58:41.902] - Erased future from FutureRegistry
[10:58:41.902] result() for ClusterFuture ...
[10:58:41.902] - result already collected: FutureResult
[10:58:41.902] result() for ClusterFuture ... done
[10:58:41.903] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.903] Future #1
[10:58:41.903] result() for ClusterFuture ...
[10:58:41.903] - result already collected: FutureResult
[10:58:41.903] result() for ClusterFuture ... done
[10:58:41.903] result() for ClusterFuture ...
[10:58:41.903] - result already collected: FutureResult
[10:58:41.903] result() for ClusterFuture ... done
[10:58:41.903] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:41.903] - nx: 2
[10:58:41.903] - relay: TRUE
[10:58:41.903] - stdout: TRUE
[10:58:41.904] - signal: TRUE
[10:58:41.904] - resignal: FALSE
[10:58:41.904] - force: TRUE
[10:58:41.904] - relayed: [n=2] FALSE, FALSE
[10:58:41.904] - queued futures: [n=2] FALSE, FALSE
[10:58:41.904]  - until=1
[10:58:41.904]  - relaying element #1
[10:58:41.904] result() for ClusterFuture ...
[10:58:41.904] - result already collected: FutureResult
[10:58:41.904] result() for ClusterFuture ... done
[10:58:41.904] result() for ClusterFuture ...
[10:58:41.904] - result already collected: FutureResult
[10:58:41.905] result() for ClusterFuture ... done
[10:58:41.905] result() for ClusterFuture ...
[10:58:41.905] - result already collected: FutureResult
[10:58:41.905] result() for ClusterFuture ... done
[10:58:41.905] result() for ClusterFuture ...
[10:58:41.905] - result already collected: FutureResult
[10:58:41.905] result() for ClusterFuture ... done
[10:58:41.905] - relayed: [n=2] TRUE, FALSE
[10:58:41.905] - queued futures: [n=2] TRUE, FALSE
[10:58:41.905] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:41.905]  length: 1 (resolved future 1)
[10:58:41.931] receiveMessageFromWorker() for ClusterFuture ...
[10:58:41.931] - Validating connection of MultisessionFuture
[10:58:41.931] - received message: FutureResult
[10:58:41.931] - Received FutureResult
[10:58:41.932] - Erased future from FutureRegistry
[10:58:41.932] result() for ClusterFuture ...
[10:58:41.932] - result already collected: FutureResult
[10:58:41.932] result() for ClusterFuture ... done
[10:58:41.932] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:41.932] Future #2
[10:58:41.932] result() for ClusterFuture ...
[10:58:41.932] - result already collected: FutureResult
[10:58:41.932] result() for ClusterFuture ... done
[10:58:41.932] result() for ClusterFuture ...
[10:58:41.932] - result already collected: FutureResult
[10:58:41.933] result() for ClusterFuture ... done
[10:58:41.933] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:41.933] - nx: 2
[10:58:41.933] - relay: TRUE
[10:58:41.933] - stdout: TRUE
[10:58:41.933] - signal: TRUE
[10:58:41.933] - resignal: FALSE
[10:58:41.933] - force: TRUE
[10:58:41.933] - relayed: [n=2] TRUE, FALSE
[10:58:41.933] - queued futures: [n=2] TRUE, FALSE
[10:58:41.933]  - until=2
[10:58:41.933]  - relaying element #2
[10:58:41.934] result() for ClusterFuture ...
[10:58:41.934] - result already collected: FutureResult
[10:58:41.934] result() for ClusterFuture ... done
[10:58:41.934] result() for ClusterFuture ...
[10:58:41.934] - result already collected: FutureResult
[10:58:41.934] result() for ClusterFuture ... done
[10:58:41.934] result() for ClusterFuture ...
[10:58:41.934] - result already collected: FutureResult
[10:58:41.934] result() for ClusterFuture ... done
[10:58:41.934] result() for ClusterFuture ...
[10:58:41.934] - result already collected: FutureResult
[10:58:41.934] result() for ClusterFuture ... done
[10:58:41.935] - relayed: [n=2] TRUE, TRUE
[10:58:41.935] - queued futures: [n=2] TRUE, TRUE
[10:58:41.935] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:41.935]  length: 0 (resolved future 2)
[10:58:41.935] Relaying remaining futures
[10:58:41.935] signalConditionsASAP(NULL, pos=0) ...
[10:58:41.935] - nx: 2
[10:58:41.935] - relay: TRUE
[10:58:41.935] - stdout: TRUE
[10:58:41.935] - signal: TRUE
[10:58:41.935] - resignal: FALSE
[10:58:41.935] - force: TRUE
[10:58:41.936] - relayed: [n=2] TRUE, TRUE
[10:58:41.936] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:41.936] - relayed: [n=2] TRUE, TRUE
[10:58:41.936] - queued futures: [n=2] TRUE, TRUE
[10:58:41.936] signalConditionsASAP(NULL, pos=0) ... done
[10:58:41.936] resolve() on list ... DONE
[10:58:41.936] result() for ClusterFuture ...
[10:58:41.936] - result already collected: FutureResult
[10:58:41.936] result() for ClusterFuture ... done
[10:58:41.936] result() for ClusterFuture ...
[10:58:41.936] - result already collected: FutureResult
[10:58:41.937] result() for ClusterFuture ... done
[10:58:41.937] result() for ClusterFuture ...
[10:58:41.937] - result already collected: FutureResult
[10:58:41.937] result() for ClusterFuture ... done
[10:58:41.937] result() for ClusterFuture ...
[10:58:41.937] - result already collected: FutureResult
[10:58:41.937] result() for ClusterFuture ... done
[10:58:41.937]  - Number of value chunks collected: 2
[10:58:41.937] Resolving 2 futures (chunks) ... DONE
[10:58:41.937] Reducing values from 2 chunks ...
[10:58:41.937]  - Number of values collected after concatenation: 2
[10:58:41.937]  - Number of values expected: 2
[10:58:41.938] Reducing values from 2 chunks ... DONE
[10:58:41.938] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:58:41.938] getGlobalsAndPackagesXApply() ...
[10:58:41.938]  - future.globals: TRUE
[10:58:41.938] getGlobalsAndPackages() ...
[10:58:41.938] Searching for globals...
[10:58:41.940] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:58:41.941] Searching for globals ... DONE
[10:58:41.941] Resolving globals: FALSE
[10:58:41.941] The total size of the 1 globals is 1.28 KiB (1311 bytes)
[10:58:41.942] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 1.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.28 KiB of class ‘function’)
[10:58:41.942] - globals: [1] ‘FUN’
[10:58:41.942] 
[10:58:41.942] getGlobalsAndPackages() ... DONE
[10:58:41.942]  - globals found/used: [n=1] ‘FUN’
[10:58:41.942]  - needed namespaces: [n=0] 
[10:58:41.942] Finding globals ... DONE
[10:58:41.942]  - use_args: TRUE
[10:58:41.942]  - Getting '...' globals ...
[10:58:41.943] resolve() on list ...
[10:58:41.943]  recursive: 0
[10:58:41.943]  length: 1
[10:58:41.943]  elements: ‘...’
[10:58:41.943]  length: 0 (resolved future 1)
[10:58:41.943] resolve() on list ... DONE
[10:58:41.943]    - '...' content: [n=0] 
[10:58:41.943] List of 1
[10:58:41.943]  $ ...: list()
[10:58:41.943]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.943]  - attr(*, "where")=List of 1
[10:58:41.943]   ..$ ...:<environment: 0x5635c1309750> 
[10:58:41.943]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.943]  - attr(*, "resolved")= logi TRUE
[10:58:41.943]  - attr(*, "total_size")= num NA
[10:58:41.946]  - Getting '...' globals ... DONE
[10:58:41.946] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:41.946] List of 2
[10:58:41.946]  $ ...future.FUN:function (x)  
[10:58:41.946]  $ ...          : list()
[10:58:41.946]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.946]  - attr(*, "where")=List of 2
[10:58:41.946]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:41.946]   ..$ ...          :<environment: 0x5635c1309750> 
[10:58:41.946]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.946]  - attr(*, "resolved")= logi FALSE
[10:58:41.946]  - attr(*, "total_size")= num 4449
[10:58:41.948] Packages to be attached in all futures: [n=0] 
[10:58:41.948] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.950] future_lapply() ...
[10:58:41.952] Number of chunks: 2
[10:58:41.953] getGlobalsAndPackagesXApply() ...
[10:58:41.953]  - future.globals: <name-value list> with names ‘list()’
[10:58:41.953]  - use_args: TRUE
[10:58:41.953] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:41.953] List of 2
[10:58:41.953]  $ ...          : list()
[10:58:41.953]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:41.953]  $ ...future.FUN:function (x)  
[10:58:41.953]  - attr(*, "where")=List of 2
[10:58:41.953]   ..$ ...          :<environment: 0x5635c1309750> 
[10:58:41.953]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:58:41.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:41.953]  - attr(*, "resolved")= logi FALSE
[10:58:41.953]  - attr(*, "total_size")= num NA
[10:58:41.958] Packages to be attached in all futures: [n=0] 
[10:58:41.958] getGlobalsAndPackagesXApply() ... DONE
[10:58:41.958] Number of futures (= number of chunks): 2
[10:58:41.958] Launching 2 futures (chunks) ...
[10:58:41.958] Chunk #1 of 2 ...
[10:58:41.958]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.958]  - seeds: <none>
[10:58:41.958]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.958] getGlobalsAndPackages() ...
[10:58:41.959] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.959] Resolving globals: FALSE
[10:58:41.959] Tweak future expression to call with '...' arguments ...
[10:58:41.959] {
[10:58:41.959]     do.call(function(...) {
[10:58:41.959]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.959]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.959]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.959]             on.exit(options(oopts), add = TRUE)
[10:58:41.959]         }
[10:58:41.959]         {
[10:58:41.959]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.959]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.959]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.959]             })
[10:58:41.959]         }
[10:58:41.959]     }, args = future.call.arguments)
[10:58:41.959] }
[10:58:41.959] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.959] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.960] 
[10:58:41.960] getGlobalsAndPackages() ... DONE
[10:58:41.960] run() for ‘Future’ ...
[10:58:41.960] - state: ‘created’
[10:58:41.960] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:41.974] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.974] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:41.974]   - Field: ‘node’
[10:58:41.974]   - Field: ‘label’
[10:58:41.974]   - Field: ‘local’
[10:58:41.975]   - Field: ‘owner’
[10:58:41.975]   - Field: ‘envir’
[10:58:41.975]   - Field: ‘workers’
[10:58:41.975]   - Field: ‘packages’
[10:58:41.975]   - Field: ‘gc’
[10:58:41.975]   - Field: ‘conditions’
[10:58:41.975]   - Field: ‘persistent’
[10:58:41.975]   - Field: ‘expr’
[10:58:41.975]   - Field: ‘uuid’
[10:58:41.975]   - Field: ‘seed’
[10:58:41.975]   - Field: ‘version’
[10:58:41.975]   - Field: ‘result’
[10:58:41.976]   - Field: ‘asynchronous’
[10:58:41.976]   - Field: ‘calls’
[10:58:41.976]   - Field: ‘globals’
[10:58:41.976]   - Field: ‘stdout’
[10:58:41.976]   - Field: ‘earlySignal’
[10:58:41.976]   - Field: ‘lazy’
[10:58:41.976]   - Field: ‘state’
[10:58:41.976] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:41.976] - Launch lazy future ...
[10:58:41.977] Packages needed by the future expression (n = 0): <none>
[10:58:41.977] Packages needed by future strategies (n = 0): <none>
[10:58:41.977] {
[10:58:41.977]     {
[10:58:41.977]         {
[10:58:41.977]             ...future.startTime <- base::Sys.time()
[10:58:41.977]             {
[10:58:41.977]                 {
[10:58:41.977]                   {
[10:58:41.977]                     {
[10:58:41.977]                       base::local({
[10:58:41.977]                         has_future <- base::requireNamespace("future", 
[10:58:41.977]                           quietly = TRUE)
[10:58:41.977]                         if (has_future) {
[10:58:41.977]                           ns <- base::getNamespace("future")
[10:58:41.977]                           version <- ns[[".package"]][["version"]]
[10:58:41.977]                           if (is.null(version)) 
[10:58:41.977]                             version <- utils::packageVersion("future")
[10:58:41.977]                         }
[10:58:41.977]                         else {
[10:58:41.977]                           version <- NULL
[10:58:41.977]                         }
[10:58:41.977]                         if (!has_future || version < "1.8.0") {
[10:58:41.977]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:41.977]                             "", base::R.version$version.string), 
[10:58:41.977]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:41.977]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:41.977]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:41.977]                               "release", "version")], collapse = " "), 
[10:58:41.977]                             hostname = base::Sys.info()[["nodename"]])
[10:58:41.977]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:41.977]                             info)
[10:58:41.977]                           info <- base::paste(info, collapse = "; ")
[10:58:41.977]                           if (!has_future) {
[10:58:41.977]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:41.977]                               info)
[10:58:41.977]                           }
[10:58:41.977]                           else {
[10:58:41.977]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:41.977]                               info, version)
[10:58:41.977]                           }
[10:58:41.977]                           base::stop(msg)
[10:58:41.977]                         }
[10:58:41.977]                       })
[10:58:41.977]                     }
[10:58:41.977]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:41.977]                     base::options(mc.cores = 1L)
[10:58:41.977]                   }
[10:58:41.977]                   ...future.strategy.old <- future::plan("list")
[10:58:41.977]                   options(future.plan = NULL)
[10:58:41.977]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.977]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:41.977]                 }
[10:58:41.977]                 ...future.workdir <- getwd()
[10:58:41.977]             }
[10:58:41.977]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:41.977]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:41.977]         }
[10:58:41.977]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:41.977]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:41.977]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:41.977]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:41.977]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:41.977]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:41.977]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:41.977]             base::names(...future.oldOptions))
[10:58:41.977]     }
[10:58:41.977]     if (FALSE) {
[10:58:41.977]     }
[10:58:41.977]     else {
[10:58:41.977]         if (TRUE) {
[10:58:41.977]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:41.977]                 open = "w")
[10:58:41.977]         }
[10:58:41.977]         else {
[10:58:41.977]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:41.977]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:41.977]         }
[10:58:41.977]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:41.977]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:41.977]             base::sink(type = "output", split = FALSE)
[10:58:41.977]             base::close(...future.stdout)
[10:58:41.977]         }, add = TRUE)
[10:58:41.977]     }
[10:58:41.977]     ...future.frame <- base::sys.nframe()
[10:58:41.977]     ...future.conditions <- base::list()
[10:58:41.977]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:41.977]     if (FALSE) {
[10:58:41.977]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:41.977]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:41.977]     }
[10:58:41.977]     ...future.result <- base::tryCatch({
[10:58:41.977]         base::withCallingHandlers({
[10:58:41.977]             ...future.value <- base::withVisible(base::local({
[10:58:41.977]                 ...future.makeSendCondition <- base::local({
[10:58:41.977]                   sendCondition <- NULL
[10:58:41.977]                   function(frame = 1L) {
[10:58:41.977]                     if (is.function(sendCondition)) 
[10:58:41.977]                       return(sendCondition)
[10:58:41.977]                     ns <- getNamespace("parallel")
[10:58:41.977]                     if (exists("sendData", mode = "function", 
[10:58:41.977]                       envir = ns)) {
[10:58:41.977]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:41.977]                         envir = ns)
[10:58:41.977]                       envir <- sys.frame(frame)
[10:58:41.977]                       master <- NULL
[10:58:41.977]                       while (!identical(envir, .GlobalEnv) && 
[10:58:41.977]                         !identical(envir, emptyenv())) {
[10:58:41.977]                         if (exists("master", mode = "list", envir = envir, 
[10:58:41.977]                           inherits = FALSE)) {
[10:58:41.977]                           master <- get("master", mode = "list", 
[10:58:41.977]                             envir = envir, inherits = FALSE)
[10:58:41.977]                           if (inherits(master, c("SOCKnode", 
[10:58:41.977]                             "SOCK0node"))) {
[10:58:41.977]                             sendCondition <<- function(cond) {
[10:58:41.977]                               data <- list(type = "VALUE", value = cond, 
[10:58:41.977]                                 success = TRUE)
[10:58:41.977]                               parallel_sendData(master, data)
[10:58:41.977]                             }
[10:58:41.977]                             return(sendCondition)
[10:58:41.977]                           }
[10:58:41.977]                         }
[10:58:41.977]                         frame <- frame + 1L
[10:58:41.977]                         envir <- sys.frame(frame)
[10:58:41.977]                       }
[10:58:41.977]                     }
[10:58:41.977]                     sendCondition <<- function(cond) NULL
[10:58:41.977]                   }
[10:58:41.977]                 })
[10:58:41.977]                 withCallingHandlers({
[10:58:41.977]                   {
[10:58:41.977]                     do.call(function(...) {
[10:58:41.977]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.977]                       if (!identical(...future.globals.maxSize.org, 
[10:58:41.977]                         ...future.globals.maxSize)) {
[10:58:41.977]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.977]                         on.exit(options(oopts), add = TRUE)
[10:58:41.977]                       }
[10:58:41.977]                       {
[10:58:41.977]                         lapply(seq_along(...future.elements_ii), 
[10:58:41.977]                           FUN = function(jj) {
[10:58:41.977]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.977]                             ...future.FUN(...future.X_jj, ...)
[10:58:41.977]                           })
[10:58:41.977]                       }
[10:58:41.977]                     }, args = future.call.arguments)
[10:58:41.977]                   }
[10:58:41.977]                 }, immediateCondition = function(cond) {
[10:58:41.977]                   sendCondition <- ...future.makeSendCondition()
[10:58:41.977]                   sendCondition(cond)
[10:58:41.977]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.977]                   {
[10:58:41.977]                     inherits <- base::inherits
[10:58:41.977]                     invokeRestart <- base::invokeRestart
[10:58:41.977]                     is.null <- base::is.null
[10:58:41.977]                     muffled <- FALSE
[10:58:41.977]                     if (inherits(cond, "message")) {
[10:58:41.977]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:41.977]                       if (muffled) 
[10:58:41.977]                         invokeRestart("muffleMessage")
[10:58:41.977]                     }
[10:58:41.977]                     else if (inherits(cond, "warning")) {
[10:58:41.977]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:41.977]                       if (muffled) 
[10:58:41.977]                         invokeRestart("muffleWarning")
[10:58:41.977]                     }
[10:58:41.977]                     else if (inherits(cond, "condition")) {
[10:58:41.977]                       if (!is.null(pattern)) {
[10:58:41.977]                         computeRestarts <- base::computeRestarts
[10:58:41.977]                         grepl <- base::grepl
[10:58:41.977]                         restarts <- computeRestarts(cond)
[10:58:41.977]                         for (restart in restarts) {
[10:58:41.977]                           name <- restart$name
[10:58:41.977]                           if (is.null(name)) 
[10:58:41.977]                             next
[10:58:41.977]                           if (!grepl(pattern, name)) 
[10:58:41.977]                             next
[10:58:41.977]                           invokeRestart(restart)
[10:58:41.977]                           muffled <- TRUE
[10:58:41.977]                           break
[10:58:41.977]                         }
[10:58:41.977]                       }
[10:58:41.977]                     }
[10:58:41.977]                     invisible(muffled)
[10:58:41.977]                   }
[10:58:41.977]                   muffleCondition(cond)
[10:58:41.977]                 })
[10:58:41.977]             }))
[10:58:41.977]             future::FutureResult(value = ...future.value$value, 
[10:58:41.977]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.977]                   ...future.rng), globalenv = if (FALSE) 
[10:58:41.977]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:41.977]                     ...future.globalenv.names))
[10:58:41.977]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:41.977]         }, condition = base::local({
[10:58:41.977]             c <- base::c
[10:58:41.977]             inherits <- base::inherits
[10:58:41.977]             invokeRestart <- base::invokeRestart
[10:58:41.977]             length <- base::length
[10:58:41.977]             list <- base::list
[10:58:41.977]             seq.int <- base::seq.int
[10:58:41.977]             signalCondition <- base::signalCondition
[10:58:41.977]             sys.calls <- base::sys.calls
[10:58:41.977]             `[[` <- base::`[[`
[10:58:41.977]             `+` <- base::`+`
[10:58:41.977]             `<<-` <- base::`<<-`
[10:58:41.977]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:41.977]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:41.977]                   3L)]
[10:58:41.977]             }
[10:58:41.977]             function(cond) {
[10:58:41.977]                 is_error <- inherits(cond, "error")
[10:58:41.977]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:41.977]                   NULL)
[10:58:41.977]                 if (is_error) {
[10:58:41.977]                   sessionInformation <- function() {
[10:58:41.977]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:41.977]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:41.977]                       search = base::search(), system = base::Sys.info())
[10:58:41.977]                   }
[10:58:41.977]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.977]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:41.977]                     cond$call), session = sessionInformation(), 
[10:58:41.977]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:41.977]                   signalCondition(cond)
[10:58:41.977]                 }
[10:58:41.977]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:41.977]                 "immediateCondition"))) {
[10:58:41.977]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:41.977]                   ...future.conditions[[length(...future.conditions) + 
[10:58:41.977]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:41.977]                   if (TRUE && !signal) {
[10:58:41.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.977]                     {
[10:58:41.977]                       inherits <- base::inherits
[10:58:41.977]                       invokeRestart <- base::invokeRestart
[10:58:41.977]                       is.null <- base::is.null
[10:58:41.977]                       muffled <- FALSE
[10:58:41.977]                       if (inherits(cond, "message")) {
[10:58:41.977]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.977]                         if (muffled) 
[10:58:41.977]                           invokeRestart("muffleMessage")
[10:58:41.977]                       }
[10:58:41.977]                       else if (inherits(cond, "warning")) {
[10:58:41.977]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.977]                         if (muffled) 
[10:58:41.977]                           invokeRestart("muffleWarning")
[10:58:41.977]                       }
[10:58:41.977]                       else if (inherits(cond, "condition")) {
[10:58:41.977]                         if (!is.null(pattern)) {
[10:58:41.977]                           computeRestarts <- base::computeRestarts
[10:58:41.977]                           grepl <- base::grepl
[10:58:41.977]                           restarts <- computeRestarts(cond)
[10:58:41.977]                           for (restart in restarts) {
[10:58:41.977]                             name <- restart$name
[10:58:41.977]                             if (is.null(name)) 
[10:58:41.977]                               next
[10:58:41.977]                             if (!grepl(pattern, name)) 
[10:58:41.977]                               next
[10:58:41.977]                             invokeRestart(restart)
[10:58:41.977]                             muffled <- TRUE
[10:58:41.977]                             break
[10:58:41.977]                           }
[10:58:41.977]                         }
[10:58:41.977]                       }
[10:58:41.977]                       invisible(muffled)
[10:58:41.977]                     }
[10:58:41.977]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.977]                   }
[10:58:41.977]                 }
[10:58:41.977]                 else {
[10:58:41.977]                   if (TRUE) {
[10:58:41.977]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:41.977]                     {
[10:58:41.977]                       inherits <- base::inherits
[10:58:41.977]                       invokeRestart <- base::invokeRestart
[10:58:41.977]                       is.null <- base::is.null
[10:58:41.977]                       muffled <- FALSE
[10:58:41.977]                       if (inherits(cond, "message")) {
[10:58:41.977]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:41.977]                         if (muffled) 
[10:58:41.977]                           invokeRestart("muffleMessage")
[10:58:41.977]                       }
[10:58:41.977]                       else if (inherits(cond, "warning")) {
[10:58:41.977]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:41.977]                         if (muffled) 
[10:58:41.977]                           invokeRestart("muffleWarning")
[10:58:41.977]                       }
[10:58:41.977]                       else if (inherits(cond, "condition")) {
[10:58:41.977]                         if (!is.null(pattern)) {
[10:58:41.977]                           computeRestarts <- base::computeRestarts
[10:58:41.977]                           grepl <- base::grepl
[10:58:41.977]                           restarts <- computeRestarts(cond)
[10:58:41.977]                           for (restart in restarts) {
[10:58:41.977]                             name <- restart$name
[10:58:41.977]                             if (is.null(name)) 
[10:58:41.977]                               next
[10:58:41.977]                             if (!grepl(pattern, name)) 
[10:58:41.977]                               next
[10:58:41.977]                             invokeRestart(restart)
[10:58:41.977]                             muffled <- TRUE
[10:58:41.977]                             break
[10:58:41.977]                           }
[10:58:41.977]                         }
[10:58:41.977]                       }
[10:58:41.977]                       invisible(muffled)
[10:58:41.977]                     }
[10:58:41.977]                     muffleCondition(cond, pattern = "^muffle")
[10:58:41.977]                   }
[10:58:41.977]                 }
[10:58:41.977]             }
[10:58:41.977]         }))
[10:58:41.977]     }, error = function(ex) {
[10:58:41.977]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:41.977]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:41.977]                 ...future.rng), started = ...future.startTime, 
[10:58:41.977]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:41.977]             version = "1.8"), class = "FutureResult")
[10:58:41.977]     }, finally = {
[10:58:41.977]         if (!identical(...future.workdir, getwd())) 
[10:58:41.977]             setwd(...future.workdir)
[10:58:41.977]         {
[10:58:41.977]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:41.977]                 ...future.oldOptions$nwarnings <- NULL
[10:58:41.977]             }
[10:58:41.977]             base::options(...future.oldOptions)
[10:58:41.977]             if (.Platform$OS.type == "windows") {
[10:58:41.977]                 old_names <- names(...future.oldEnvVars)
[10:58:41.977]                 envs <- base::Sys.getenv()
[10:58:41.977]                 names <- names(envs)
[10:58:41.977]                 common <- intersect(names, old_names)
[10:58:41.977]                 added <- setdiff(names, old_names)
[10:58:41.977]                 removed <- setdiff(old_names, names)
[10:58:41.977]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:41.977]                   envs[common]]
[10:58:41.977]                 NAMES <- toupper(changed)
[10:58:41.977]                 args <- list()
[10:58:41.977]                 for (kk in seq_along(NAMES)) {
[10:58:41.977]                   name <- changed[[kk]]
[10:58:41.977]                   NAME <- NAMES[[kk]]
[10:58:41.977]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.977]                     next
[10:58:41.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.977]                 }
[10:58:41.977]                 NAMES <- toupper(added)
[10:58:41.977]                 for (kk in seq_along(NAMES)) {
[10:58:41.977]                   name <- added[[kk]]
[10:58:41.977]                   NAME <- NAMES[[kk]]
[10:58:41.977]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.977]                     next
[10:58:41.977]                   args[[name]] <- ""
[10:58:41.977]                 }
[10:58:41.977]                 NAMES <- toupper(removed)
[10:58:41.977]                 for (kk in seq_along(NAMES)) {
[10:58:41.977]                   name <- removed[[kk]]
[10:58:41.977]                   NAME <- NAMES[[kk]]
[10:58:41.977]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:41.977]                     next
[10:58:41.977]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:41.977]                 }
[10:58:41.977]                 if (length(args) > 0) 
[10:58:41.977]                   base::do.call(base::Sys.setenv, args = args)
[10:58:41.977]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:41.977]             }
[10:58:41.977]             else {
[10:58:41.977]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:41.977]             }
[10:58:41.977]             {
[10:58:41.977]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:41.977]                   0L) {
[10:58:41.977]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:41.977]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:41.977]                   base::options(opts)
[10:58:41.977]                 }
[10:58:41.977]                 {
[10:58:41.977]                   {
[10:58:41.977]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:41.977]                     NULL
[10:58:41.977]                   }
[10:58:41.977]                   options(future.plan = NULL)
[10:58:41.977]                   if (is.na(NA_character_)) 
[10:58:41.977]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:41.977]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:41.977]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:41.977]                     .init = FALSE)
[10:58:41.977]                 }
[10:58:41.977]             }
[10:58:41.977]         }
[10:58:41.977]     })
[10:58:41.977]     if (TRUE) {
[10:58:41.977]         base::sink(type = "output", split = FALSE)
[10:58:41.977]         if (TRUE) {
[10:58:41.977]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:41.977]         }
[10:58:41.977]         else {
[10:58:41.977]             ...future.result["stdout"] <- base::list(NULL)
[10:58:41.977]         }
[10:58:41.977]         base::close(...future.stdout)
[10:58:41.977]         ...future.stdout <- NULL
[10:58:41.977]     }
[10:58:41.977]     ...future.result$conditions <- ...future.conditions
[10:58:41.977]     ...future.result$finished <- base::Sys.time()
[10:58:41.977]     ...future.result
[10:58:41.977] }
[10:58:41.980] Exporting 5 global objects (1.92 KiB) to cluster node #1 ...
[10:58:41.980] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:41.980] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:41.981] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ...
[10:58:41.981] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ... DONE
[10:58:41.981] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ...
[10:58:41.981] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ... DONE
[10:58:41.982] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:58:41.982] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:58:41.982] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:41.982] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:41.983] Exporting 5 global objects (1.92 KiB) to cluster node #1 ... DONE
[10:58:41.983] MultisessionFuture started
[10:58:41.983] - Launch lazy future ... done
[10:58:41.983] run() for ‘MultisessionFuture’ ... done
[10:58:41.983] Created future:
[10:58:41.983] MultisessionFuture:
[10:58:41.983] Label: ‘future_apply-1’
[10:58:41.983] Expression:
[10:58:41.983] {
[10:58:41.983]     do.call(function(...) {
[10:58:41.983]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.983]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.983]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.983]             on.exit(options(oopts), add = TRUE)
[10:58:41.983]         }
[10:58:41.983]         {
[10:58:41.983]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.983]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.983]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.983]             })
[10:58:41.983]         }
[10:58:41.983]     }, args = future.call.arguments)
[10:58:41.983] }
[10:58:41.983] Lazy evaluation: FALSE
[10:58:41.983] Asynchronous evaluation: TRUE
[10:58:41.983] Local evaluation: TRUE
[10:58:41.983] Environment: R_GlobalEnv
[10:58:41.983] Capture standard output: TRUE
[10:58:41.983] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:41.983] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:41.983] Packages: <none>
[10:58:41.983] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:41.983] Resolved: FALSE
[10:58:41.983] Value: <not collected>
[10:58:41.983] Conditions captured: <none>
[10:58:41.983] Early signaling: FALSE
[10:58:41.983] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:41.983] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:41.995] Chunk #1 of 2 ... DONE
[10:58:41.995] Chunk #2 of 2 ...
[10:58:41.995]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:41.995]  - seeds: <none>
[10:58:41.995]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.995] getGlobalsAndPackages() ...
[10:58:41.996] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.996] Resolving globals: FALSE
[10:58:41.996] Tweak future expression to call with '...' arguments ...
[10:58:41.996] {
[10:58:41.996]     do.call(function(...) {
[10:58:41.996]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:41.996]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:41.996]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:41.996]             on.exit(options(oopts), add = TRUE)
[10:58:41.996]         }
[10:58:41.996]         {
[10:58:41.996]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:41.996]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:41.996]                 ...future.FUN(...future.X_jj, ...)
[10:58:41.996]             })
[10:58:41.996]         }
[10:58:41.996]     }, args = future.call.arguments)
[10:58:41.996] }
[10:58:41.996] Tweak future expression to call with '...' arguments ... DONE
[10:58:41.996] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:41.997] 
[10:58:41.997] getGlobalsAndPackages() ... DONE
[10:58:41.997] run() for ‘Future’ ...
[10:58:41.997] - state: ‘created’
[10:58:41.997] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:42.011] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:42.012] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:42.012]   - Field: ‘node’
[10:58:42.012]   - Field: ‘label’
[10:58:42.012]   - Field: ‘local’
[10:58:42.012]   - Field: ‘owner’
[10:58:42.012]   - Field: ‘envir’
[10:58:42.012]   - Field: ‘workers’
[10:58:42.012]   - Field: ‘packages’
[10:58:42.012]   - Field: ‘gc’
[10:58:42.013]   - Field: ‘conditions’
[10:58:42.013]   - Field: ‘persistent’
[10:58:42.013]   - Field: ‘expr’
[10:58:42.013]   - Field: ‘uuid’
[10:58:42.013]   - Field: ‘seed’
[10:58:42.013]   - Field: ‘version’
[10:58:42.013]   - Field: ‘result’
[10:58:42.013]   - Field: ‘asynchronous’
[10:58:42.013]   - Field: ‘calls’
[10:58:42.013]   - Field: ‘globals’
[10:58:42.013]   - Field: ‘stdout’
[10:58:42.013]   - Field: ‘earlySignal’
[10:58:42.014]   - Field: ‘lazy’
[10:58:42.014]   - Field: ‘state’
[10:58:42.014] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:42.014] - Launch lazy future ...
[10:58:42.014] Packages needed by the future expression (n = 0): <none>
[10:58:42.014] Packages needed by future strategies (n = 0): <none>
[10:58:42.015] {
[10:58:42.015]     {
[10:58:42.015]         {
[10:58:42.015]             ...future.startTime <- base::Sys.time()
[10:58:42.015]             {
[10:58:42.015]                 {
[10:58:42.015]                   {
[10:58:42.015]                     {
[10:58:42.015]                       base::local({
[10:58:42.015]                         has_future <- base::requireNamespace("future", 
[10:58:42.015]                           quietly = TRUE)
[10:58:42.015]                         if (has_future) {
[10:58:42.015]                           ns <- base::getNamespace("future")
[10:58:42.015]                           version <- ns[[".package"]][["version"]]
[10:58:42.015]                           if (is.null(version)) 
[10:58:42.015]                             version <- utils::packageVersion("future")
[10:58:42.015]                         }
[10:58:42.015]                         else {
[10:58:42.015]                           version <- NULL
[10:58:42.015]                         }
[10:58:42.015]                         if (!has_future || version < "1.8.0") {
[10:58:42.015]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.015]                             "", base::R.version$version.string), 
[10:58:42.015]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:42.015]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.015]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.015]                               "release", "version")], collapse = " "), 
[10:58:42.015]                             hostname = base::Sys.info()[["nodename"]])
[10:58:42.015]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.015]                             info)
[10:58:42.015]                           info <- base::paste(info, collapse = "; ")
[10:58:42.015]                           if (!has_future) {
[10:58:42.015]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.015]                               info)
[10:58:42.015]                           }
[10:58:42.015]                           else {
[10:58:42.015]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.015]                               info, version)
[10:58:42.015]                           }
[10:58:42.015]                           base::stop(msg)
[10:58:42.015]                         }
[10:58:42.015]                       })
[10:58:42.015]                     }
[10:58:42.015]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:42.015]                     base::options(mc.cores = 1L)
[10:58:42.015]                   }
[10:58:42.015]                   ...future.strategy.old <- future::plan("list")
[10:58:42.015]                   options(future.plan = NULL)
[10:58:42.015]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.015]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.015]                 }
[10:58:42.015]                 ...future.workdir <- getwd()
[10:58:42.015]             }
[10:58:42.015]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.015]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.015]         }
[10:58:42.015]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.015]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:42.015]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.015]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.015]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.015]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.015]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.015]             base::names(...future.oldOptions))
[10:58:42.015]     }
[10:58:42.015]     if (FALSE) {
[10:58:42.015]     }
[10:58:42.015]     else {
[10:58:42.015]         if (TRUE) {
[10:58:42.015]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.015]                 open = "w")
[10:58:42.015]         }
[10:58:42.015]         else {
[10:58:42.015]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.015]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.015]         }
[10:58:42.015]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.015]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.015]             base::sink(type = "output", split = FALSE)
[10:58:42.015]             base::close(...future.stdout)
[10:58:42.015]         }, add = TRUE)
[10:58:42.015]     }
[10:58:42.015]     ...future.frame <- base::sys.nframe()
[10:58:42.015]     ...future.conditions <- base::list()
[10:58:42.015]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.015]     if (FALSE) {
[10:58:42.015]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.015]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.015]     }
[10:58:42.015]     ...future.result <- base::tryCatch({
[10:58:42.015]         base::withCallingHandlers({
[10:58:42.015]             ...future.value <- base::withVisible(base::local({
[10:58:42.015]                 ...future.makeSendCondition <- base::local({
[10:58:42.015]                   sendCondition <- NULL
[10:58:42.015]                   function(frame = 1L) {
[10:58:42.015]                     if (is.function(sendCondition)) 
[10:58:42.015]                       return(sendCondition)
[10:58:42.015]                     ns <- getNamespace("parallel")
[10:58:42.015]                     if (exists("sendData", mode = "function", 
[10:58:42.015]                       envir = ns)) {
[10:58:42.015]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:42.015]                         envir = ns)
[10:58:42.015]                       envir <- sys.frame(frame)
[10:58:42.015]                       master <- NULL
[10:58:42.015]                       while (!identical(envir, .GlobalEnv) && 
[10:58:42.015]                         !identical(envir, emptyenv())) {
[10:58:42.015]                         if (exists("master", mode = "list", envir = envir, 
[10:58:42.015]                           inherits = FALSE)) {
[10:58:42.015]                           master <- get("master", mode = "list", 
[10:58:42.015]                             envir = envir, inherits = FALSE)
[10:58:42.015]                           if (inherits(master, c("SOCKnode", 
[10:58:42.015]                             "SOCK0node"))) {
[10:58:42.015]                             sendCondition <<- function(cond) {
[10:58:42.015]                               data <- list(type = "VALUE", value = cond, 
[10:58:42.015]                                 success = TRUE)
[10:58:42.015]                               parallel_sendData(master, data)
[10:58:42.015]                             }
[10:58:42.015]                             return(sendCondition)
[10:58:42.015]                           }
[10:58:42.015]                         }
[10:58:42.015]                         frame <- frame + 1L
[10:58:42.015]                         envir <- sys.frame(frame)
[10:58:42.015]                       }
[10:58:42.015]                     }
[10:58:42.015]                     sendCondition <<- function(cond) NULL
[10:58:42.015]                   }
[10:58:42.015]                 })
[10:58:42.015]                 withCallingHandlers({
[10:58:42.015]                   {
[10:58:42.015]                     do.call(function(...) {
[10:58:42.015]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.015]                       if (!identical(...future.globals.maxSize.org, 
[10:58:42.015]                         ...future.globals.maxSize)) {
[10:58:42.015]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.015]                         on.exit(options(oopts), add = TRUE)
[10:58:42.015]                       }
[10:58:42.015]                       {
[10:58:42.015]                         lapply(seq_along(...future.elements_ii), 
[10:58:42.015]                           FUN = function(jj) {
[10:58:42.015]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.015]                             ...future.FUN(...future.X_jj, ...)
[10:58:42.015]                           })
[10:58:42.015]                       }
[10:58:42.015]                     }, args = future.call.arguments)
[10:58:42.015]                   }
[10:58:42.015]                 }, immediateCondition = function(cond) {
[10:58:42.015]                   sendCondition <- ...future.makeSendCondition()
[10:58:42.015]                   sendCondition(cond)
[10:58:42.015]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.015]                   {
[10:58:42.015]                     inherits <- base::inherits
[10:58:42.015]                     invokeRestart <- base::invokeRestart
[10:58:42.015]                     is.null <- base::is.null
[10:58:42.015]                     muffled <- FALSE
[10:58:42.015]                     if (inherits(cond, "message")) {
[10:58:42.015]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:42.015]                       if (muffled) 
[10:58:42.015]                         invokeRestart("muffleMessage")
[10:58:42.015]                     }
[10:58:42.015]                     else if (inherits(cond, "warning")) {
[10:58:42.015]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:42.015]                       if (muffled) 
[10:58:42.015]                         invokeRestart("muffleWarning")
[10:58:42.015]                     }
[10:58:42.015]                     else if (inherits(cond, "condition")) {
[10:58:42.015]                       if (!is.null(pattern)) {
[10:58:42.015]                         computeRestarts <- base::computeRestarts
[10:58:42.015]                         grepl <- base::grepl
[10:58:42.015]                         restarts <- computeRestarts(cond)
[10:58:42.015]                         for (restart in restarts) {
[10:58:42.015]                           name <- restart$name
[10:58:42.015]                           if (is.null(name)) 
[10:58:42.015]                             next
[10:58:42.015]                           if (!grepl(pattern, name)) 
[10:58:42.015]                             next
[10:58:42.015]                           invokeRestart(restart)
[10:58:42.015]                           muffled <- TRUE
[10:58:42.015]                           break
[10:58:42.015]                         }
[10:58:42.015]                       }
[10:58:42.015]                     }
[10:58:42.015]                     invisible(muffled)
[10:58:42.015]                   }
[10:58:42.015]                   muffleCondition(cond)
[10:58:42.015]                 })
[10:58:42.015]             }))
[10:58:42.015]             future::FutureResult(value = ...future.value$value, 
[10:58:42.015]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.015]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.015]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.015]                     ...future.globalenv.names))
[10:58:42.015]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.015]         }, condition = base::local({
[10:58:42.015]             c <- base::c
[10:58:42.015]             inherits <- base::inherits
[10:58:42.015]             invokeRestart <- base::invokeRestart
[10:58:42.015]             length <- base::length
[10:58:42.015]             list <- base::list
[10:58:42.015]             seq.int <- base::seq.int
[10:58:42.015]             signalCondition <- base::signalCondition
[10:58:42.015]             sys.calls <- base::sys.calls
[10:58:42.015]             `[[` <- base::`[[`
[10:58:42.015]             `+` <- base::`+`
[10:58:42.015]             `<<-` <- base::`<<-`
[10:58:42.015]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.015]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.015]                   3L)]
[10:58:42.015]             }
[10:58:42.015]             function(cond) {
[10:58:42.015]                 is_error <- inherits(cond, "error")
[10:58:42.015]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.015]                   NULL)
[10:58:42.015]                 if (is_error) {
[10:58:42.015]                   sessionInformation <- function() {
[10:58:42.015]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.015]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.015]                       search = base::search(), system = base::Sys.info())
[10:58:42.015]                   }
[10:58:42.015]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.015]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.015]                     cond$call), session = sessionInformation(), 
[10:58:42.015]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.015]                   signalCondition(cond)
[10:58:42.015]                 }
[10:58:42.015]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:58:42.015]                 "immediateCondition"))) {
[10:58:42.015]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.015]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.015]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.015]                   if (TRUE && !signal) {
[10:58:42.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.015]                     {
[10:58:42.015]                       inherits <- base::inherits
[10:58:42.015]                       invokeRestart <- base::invokeRestart
[10:58:42.015]                       is.null <- base::is.null
[10:58:42.015]                       muffled <- FALSE
[10:58:42.015]                       if (inherits(cond, "message")) {
[10:58:42.015]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.015]                         if (muffled) 
[10:58:42.015]                           invokeRestart("muffleMessage")
[10:58:42.015]                       }
[10:58:42.015]                       else if (inherits(cond, "warning")) {
[10:58:42.015]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.015]                         if (muffled) 
[10:58:42.015]                           invokeRestart("muffleWarning")
[10:58:42.015]                       }
[10:58:42.015]                       else if (inherits(cond, "condition")) {
[10:58:42.015]                         if (!is.null(pattern)) {
[10:58:42.015]                           computeRestarts <- base::computeRestarts
[10:58:42.015]                           grepl <- base::grepl
[10:58:42.015]                           restarts <- computeRestarts(cond)
[10:58:42.015]                           for (restart in restarts) {
[10:58:42.015]                             name <- restart$name
[10:58:42.015]                             if (is.null(name)) 
[10:58:42.015]                               next
[10:58:42.015]                             if (!grepl(pattern, name)) 
[10:58:42.015]                               next
[10:58:42.015]                             invokeRestart(restart)
[10:58:42.015]                             muffled <- TRUE
[10:58:42.015]                             break
[10:58:42.015]                           }
[10:58:42.015]                         }
[10:58:42.015]                       }
[10:58:42.015]                       invisible(muffled)
[10:58:42.015]                     }
[10:58:42.015]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.015]                   }
[10:58:42.015]                 }
[10:58:42.015]                 else {
[10:58:42.015]                   if (TRUE) {
[10:58:42.015]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.015]                     {
[10:58:42.015]                       inherits <- base::inherits
[10:58:42.015]                       invokeRestart <- base::invokeRestart
[10:58:42.015]                       is.null <- base::is.null
[10:58:42.015]                       muffled <- FALSE
[10:58:42.015]                       if (inherits(cond, "message")) {
[10:58:42.015]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.015]                         if (muffled) 
[10:58:42.015]                           invokeRestart("muffleMessage")
[10:58:42.015]                       }
[10:58:42.015]                       else if (inherits(cond, "warning")) {
[10:58:42.015]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.015]                         if (muffled) 
[10:58:42.015]                           invokeRestart("muffleWarning")
[10:58:42.015]                       }
[10:58:42.015]                       else if (inherits(cond, "condition")) {
[10:58:42.015]                         if (!is.null(pattern)) {
[10:58:42.015]                           computeRestarts <- base::computeRestarts
[10:58:42.015]                           grepl <- base::grepl
[10:58:42.015]                           restarts <- computeRestarts(cond)
[10:58:42.015]                           for (restart in restarts) {
[10:58:42.015]                             name <- restart$name
[10:58:42.015]                             if (is.null(name)) 
[10:58:42.015]                               next
[10:58:42.015]                             if (!grepl(pattern, name)) 
[10:58:42.015]                               next
[10:58:42.015]                             invokeRestart(restart)
[10:58:42.015]                             muffled <- TRUE
[10:58:42.015]                             break
[10:58:42.015]                           }
[10:58:42.015]                         }
[10:58:42.015]                       }
[10:58:42.015]                       invisible(muffled)
[10:58:42.015]                     }
[10:58:42.015]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.015]                   }
[10:58:42.015]                 }
[10:58:42.015]             }
[10:58:42.015]         }))
[10:58:42.015]     }, error = function(ex) {
[10:58:42.015]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.015]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.015]                 ...future.rng), started = ...future.startTime, 
[10:58:42.015]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.015]             version = "1.8"), class = "FutureResult")
[10:58:42.015]     }, finally = {
[10:58:42.015]         if (!identical(...future.workdir, getwd())) 
[10:58:42.015]             setwd(...future.workdir)
[10:58:42.015]         {
[10:58:42.015]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.015]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.015]             }
[10:58:42.015]             base::options(...future.oldOptions)
[10:58:42.015]             if (.Platform$OS.type == "windows") {
[10:58:42.015]                 old_names <- names(...future.oldEnvVars)
[10:58:42.015]                 envs <- base::Sys.getenv()
[10:58:42.015]                 names <- names(envs)
[10:58:42.015]                 common <- intersect(names, old_names)
[10:58:42.015]                 added <- setdiff(names, old_names)
[10:58:42.015]                 removed <- setdiff(old_names, names)
[10:58:42.015]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.015]                   envs[common]]
[10:58:42.015]                 NAMES <- toupper(changed)
[10:58:42.015]                 args <- list()
[10:58:42.015]                 for (kk in seq_along(NAMES)) {
[10:58:42.015]                   name <- changed[[kk]]
[10:58:42.015]                   NAME <- NAMES[[kk]]
[10:58:42.015]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.015]                     next
[10:58:42.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.015]                 }
[10:58:42.015]                 NAMES <- toupper(added)
[10:58:42.015]                 for (kk in seq_along(NAMES)) {
[10:58:42.015]                   name <- added[[kk]]
[10:58:42.015]                   NAME <- NAMES[[kk]]
[10:58:42.015]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.015]                     next
[10:58:42.015]                   args[[name]] <- ""
[10:58:42.015]                 }
[10:58:42.015]                 NAMES <- toupper(removed)
[10:58:42.015]                 for (kk in seq_along(NAMES)) {
[10:58:42.015]                   name <- removed[[kk]]
[10:58:42.015]                   NAME <- NAMES[[kk]]
[10:58:42.015]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.015]                     next
[10:58:42.015]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.015]                 }
[10:58:42.015]                 if (length(args) > 0) 
[10:58:42.015]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.015]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.015]             }
[10:58:42.015]             else {
[10:58:42.015]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.015]             }
[10:58:42.015]             {
[10:58:42.015]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.015]                   0L) {
[10:58:42.015]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.015]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.015]                   base::options(opts)
[10:58:42.015]                 }
[10:58:42.015]                 {
[10:58:42.015]                   {
[10:58:42.015]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:42.015]                     NULL
[10:58:42.015]                   }
[10:58:42.015]                   options(future.plan = NULL)
[10:58:42.015]                   if (is.na(NA_character_)) 
[10:58:42.015]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.015]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.015]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.015]                     .init = FALSE)
[10:58:42.015]                 }
[10:58:42.015]             }
[10:58:42.015]         }
[10:58:42.015]     })
[10:58:42.015]     if (TRUE) {
[10:58:42.015]         base::sink(type = "output", split = FALSE)
[10:58:42.015]         if (TRUE) {
[10:58:42.015]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.015]         }
[10:58:42.015]         else {
[10:58:42.015]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.015]         }
[10:58:42.015]         base::close(...future.stdout)
[10:58:42.015]         ...future.stdout <- NULL
[10:58:42.015]     }
[10:58:42.015]     ...future.result$conditions <- ...future.conditions
[10:58:42.015]     ...future.result$finished <- base::Sys.time()
[10:58:42.015]     ...future.result
[10:58:42.015] }
[10:58:42.018] Exporting 5 global objects (1.92 KiB) to cluster node #2 ...
[10:58:42.018] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:42.018] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:42.018] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ...
[10:58:42.019] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ... DONE
[10:58:42.019] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ...
[10:58:42.019] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ... DONE
[10:58:42.019] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:58:42.020] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:58:42.020] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:42.020] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:42.020] Exporting 5 global objects (1.92 KiB) to cluster node #2 ... DONE
[10:58:42.021] MultisessionFuture started
[10:58:42.021] - Launch lazy future ... done
[10:58:42.021] run() for ‘MultisessionFuture’ ... done
[10:58:42.021] Created future:
[10:58:42.021] MultisessionFuture:
[10:58:42.021] Label: ‘future_apply-2’
[10:58:42.021] Expression:
[10:58:42.021] {
[10:58:42.021]     do.call(function(...) {
[10:58:42.021]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.021]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.021]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.021]             on.exit(options(oopts), add = TRUE)
[10:58:42.021]         }
[10:58:42.021]         {
[10:58:42.021]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.021]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.021]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.021]             })
[10:58:42.021]         }
[10:58:42.021]     }, args = future.call.arguments)
[10:58:42.021] }
[10:58:42.021] Lazy evaluation: FALSE
[10:58:42.021] Asynchronous evaluation: TRUE
[10:58:42.021] Local evaluation: TRUE
[10:58:42.021] Environment: R_GlobalEnv
[10:58:42.021] Capture standard output: TRUE
[10:58:42.021] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:58:42.021] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:42.021] Packages: <none>
[10:58:42.021] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:58:42.021] Resolved: FALSE
[10:58:42.021] Value: <not collected>
[10:58:42.021] Conditions captured: <none>
[10:58:42.021] Early signaling: FALSE
[10:58:42.021] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:42.021] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:42.033] Chunk #2 of 2 ... DONE
[10:58:42.033] Launching 2 futures (chunks) ... DONE
[10:58:42.033] Resolving 2 futures (chunks) ...
[10:58:42.033] resolve() on list ...
[10:58:42.033]  recursive: 0
[10:58:42.033]  length: 2
[10:58:42.033] 
[10:58:42.034] receiveMessageFromWorker() for ClusterFuture ...
[10:58:42.034] - Validating connection of MultisessionFuture
[10:58:42.034] - received message: FutureResult
[10:58:42.034] - Received FutureResult
[10:58:42.034] - Erased future from FutureRegistry
[10:58:42.035] result() for ClusterFuture ...
[10:58:42.035] - result already collected: FutureResult
[10:58:42.035] result() for ClusterFuture ... done
[10:58:42.035] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:42.035] Future #1
[10:58:42.035] result() for ClusterFuture ...
[10:58:42.035] - result already collected: FutureResult
[10:58:42.035] result() for ClusterFuture ... done
[10:58:42.035] result() for ClusterFuture ...
[10:58:42.035] - result already collected: FutureResult
[10:58:42.035] result() for ClusterFuture ... done
[10:58:42.036] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:42.036] - nx: 2
[10:58:42.036] - relay: TRUE
[10:58:42.036] - stdout: TRUE
[10:58:42.036] - signal: TRUE
[10:58:42.036] - resignal: FALSE
[10:58:42.036] - force: TRUE
[10:58:42.036] - relayed: [n=2] FALSE, FALSE
[10:58:42.036] - queued futures: [n=2] FALSE, FALSE
[10:58:42.036]  - until=1
[10:58:42.036]  - relaying element #1
[10:58:42.036] result() for ClusterFuture ...
[10:58:42.037] - result already collected: FutureResult
[10:58:42.037] result() for ClusterFuture ... done
[10:58:42.037] result() for ClusterFuture ...
[10:58:42.037] - result already collected: FutureResult
[10:58:42.037] result() for ClusterFuture ... done
[10:58:42.037] result() for ClusterFuture ...
[10:58:42.037] - result already collected: FutureResult
[10:58:42.037] result() for ClusterFuture ... done
[10:58:42.037] result() for ClusterFuture ...
[10:58:42.037] - result already collected: FutureResult
[10:58:42.037] result() for ClusterFuture ... done
[10:58:42.038] - relayed: [n=2] TRUE, FALSE
[10:58:42.038] - queued futures: [n=2] TRUE, FALSE
[10:58:42.038] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:42.038]  length: 1 (resolved future 1)
[10:58:42.063] receiveMessageFromWorker() for ClusterFuture ...
[10:58:42.063] - Validating connection of MultisessionFuture
[10:58:42.063] - received message: FutureResult
[10:58:42.064] - Received FutureResult
[10:58:42.064] - Erased future from FutureRegistry
[10:58:42.064] result() for ClusterFuture ...
[10:58:42.064] - result already collected: FutureResult
[10:58:42.064] result() for ClusterFuture ... done
[10:58:42.064] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:42.064] Future #2
[10:58:42.064] result() for ClusterFuture ...
[10:58:42.064] - result already collected: FutureResult
[10:58:42.064] result() for ClusterFuture ... done
[10:58:42.065] result() for ClusterFuture ...
[10:58:42.065] - result already collected: FutureResult
[10:58:42.065] result() for ClusterFuture ... done
[10:58:42.065] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:42.065] - nx: 2
[10:58:42.065] - relay: TRUE
[10:58:42.065] - stdout: TRUE
[10:58:42.065] - signal: TRUE
[10:58:42.065] - resignal: FALSE
[10:58:42.065] - force: TRUE
[10:58:42.065] - relayed: [n=2] TRUE, FALSE
[10:58:42.065] - queued futures: [n=2] TRUE, FALSE
[10:58:42.066]  - until=2
[10:58:42.066]  - relaying element #2
[10:58:42.066] result() for ClusterFuture ...
[10:58:42.066] - result already collected: FutureResult
[10:58:42.066] result() for ClusterFuture ... done
[10:58:42.066] result() for ClusterFuture ...
[10:58:42.066] - result already collected: FutureResult
[10:58:42.066] result() for ClusterFuture ... done
[10:58:42.066] result() for ClusterFuture ...
[10:58:42.066] - result already collected: FutureResult
[10:58:42.066] result() for ClusterFuture ... done
[10:58:42.066] result() for ClusterFuture ...
[10:58:42.067] - result already collected: FutureResult
[10:58:42.067] result() for ClusterFuture ... done
[10:58:42.067] - relayed: [n=2] TRUE, TRUE
[10:58:42.067] - queued futures: [n=2] TRUE, TRUE
[10:58:42.067] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:42.067]  length: 0 (resolved future 2)
[10:58:42.067] Relaying remaining futures
[10:58:42.067] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.067] - nx: 2
[10:58:42.067] - relay: TRUE
[10:58:42.067] - stdout: TRUE
[10:58:42.067] - signal: TRUE
[10:58:42.068] - resignal: FALSE
[10:58:42.068] - force: TRUE
[10:58:42.068] - relayed: [n=2] TRUE, TRUE
[10:58:42.068] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:42.068] - relayed: [n=2] TRUE, TRUE
[10:58:42.068] - queued futures: [n=2] TRUE, TRUE
[10:58:42.068] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.068] resolve() on list ... DONE
[10:58:42.068] result() for ClusterFuture ...
[10:58:42.068] - result already collected: FutureResult
[10:58:42.068] result() for ClusterFuture ... done
[10:58:42.069] result() for ClusterFuture ...
[10:58:42.069] - result already collected: FutureResult
[10:58:42.069] result() for ClusterFuture ... done
[10:58:42.069] result() for ClusterFuture ...
[10:58:42.069] - result already collected: FutureResult
[10:58:42.069] result() for ClusterFuture ... done
[10:58:42.069] result() for ClusterFuture ...
[10:58:42.069] - result already collected: FutureResult
[10:58:42.069] result() for ClusterFuture ... done
[10:58:42.069]  - Number of value chunks collected: 2
[10:58:42.069] Resolving 2 futures (chunks) ... DONE
[10:58:42.070] Reducing values from 2 chunks ...
[10:58:42.070]  - Number of values collected after concatenation: 2
[10:58:42.070]  - Number of values expected: 2
[10:58:42.070] Reducing values from 2 chunks ... DONE
[10:58:42.070] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:58:42.070] getGlobalsAndPackagesXApply() ...
[10:58:42.070]  - future.globals: TRUE
[10:58:42.070] getGlobalsAndPackages() ...
[10:58:42.070] Searching for globals...
[10:58:42.073] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:58:42.074] Searching for globals ... DONE
[10:58:42.074] Resolving globals: FALSE
[10:58:42.074] The total size of the 1 globals is 3.66 KiB (3746 bytes)
[10:58:42.075] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 3.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.66 KiB of class ‘function’)
[10:58:42.075] - globals: [1] ‘FUN’
[10:58:42.075] 
[10:58:42.075] getGlobalsAndPackages() ... DONE
[10:58:42.075]  - globals found/used: [n=1] ‘FUN’
[10:58:42.075]  - needed namespaces: [n=0] 
[10:58:42.075] Finding globals ... DONE
[10:58:42.075]  - use_args: TRUE
[10:58:42.075]  - Getting '...' globals ...
[10:58:42.076] resolve() on list ...
[10:58:42.076]  recursive: 0
[10:58:42.076]  length: 1
[10:58:42.076]  elements: ‘...’
[10:58:42.076]  length: 0 (resolved future 1)
[10:58:42.076] resolve() on list ... DONE
[10:58:42.076]    - '...' content: [n=0] 
[10:58:42.076] List of 1
[10:58:42.076]  $ ...: list()
[10:58:42.076]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.076]  - attr(*, "where")=List of 1
[10:58:42.076]   ..$ ...:<environment: 0x5635c0983388> 
[10:58:42.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.076]  - attr(*, "resolved")= logi TRUE
[10:58:42.076]  - attr(*, "total_size")= num NA
[10:58:42.079]  - Getting '...' globals ... DONE
[10:58:42.079] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:58:42.079] List of 2
[10:58:42.079]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:58:42.079]  $ ...          : list()
[10:58:42.079]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.079]  - attr(*, "where")=List of 2
[10:58:42.079]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:58:42.079]   ..$ ...          :<environment: 0x5635c0983388> 
[10:58:42.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.079]  - attr(*, "resolved")= logi FALSE
[10:58:42.079]  - attr(*, "total_size")= num 9424
[10:58:42.082] Packages to be attached in all futures: [n=0] 
[10:58:42.082] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.083] future_lapply() ...
[10:58:42.085] Generating random seeds ...
[10:58:42.086] Generating random seed streams for 2 elements ...
[10:58:42.086] Generating random seed streams for 2 elements ... DONE
[10:58:42.086] Generating random seeds ... DONE
[10:58:42.086] Will set RNG state on exit: 10407, 1487047905, 90638566, 2103384037, -1199129823, 1117540959, -500440078
[10:58:42.087] Number of chunks: 2
[10:58:42.087] getGlobalsAndPackagesXApply() ...
[10:58:42.088]  - future.globals: <name-value list> with names ‘list()’
[10:58:42.088]  - use_args: TRUE
[10:58:42.088] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:58:42.088] List of 2
[10:58:42.088]  $ ...          : list()
[10:58:42.088]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:58:42.088]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:58:42.088]  - attr(*, "where")=List of 2
[10:58:42.088]   ..$ ...          :<environment: 0x5635c0983388> 
[10:58:42.088]   ..$ ...future.FUN:<environment: namespace:base> 
[10:58:42.088]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:58:42.088]  - attr(*, "resolved")= logi FALSE
[10:58:42.088]  - attr(*, "total_size")= num NA
[10:58:42.091] Packages to be attached in all futures: [n=0] 
[10:58:42.091] getGlobalsAndPackagesXApply() ... DONE
[10:58:42.092] Number of futures (= number of chunks): 2
[10:58:42.092] Launching 2 futures (chunks) ...
[10:58:42.092] Chunk #1 of 2 ...
[10:58:42.092]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:42.092]  - seeds: [1] <seeds>
[10:58:42.092]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.092] getGlobalsAndPackages() ...
[10:58:42.093] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.093] Resolving globals: FALSE
[10:58:42.093] Tweak future expression to call with '...' arguments ...
[10:58:42.093] {
[10:58:42.093]     do.call(function(...) {
[10:58:42.093]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.093]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.093]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.093]             on.exit(options(oopts), add = TRUE)
[10:58:42.093]         }
[10:58:42.093]         {
[10:58:42.093]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.093]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.093]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:42.093]                   envir = globalenv(), inherits = FALSE)
[10:58:42.093]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.093]             })
[10:58:42.093]         }
[10:58:42.093]     }, args = future.call.arguments)
[10:58:42.093] }
[10:58:42.093] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.094] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.094] 
[10:58:42.094] getGlobalsAndPackages() ... DONE
[10:58:42.094] run() for ‘Future’ ...
[10:58:42.094] - state: ‘created’
[10:58:42.094] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:42.108] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:42.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:42.109]   - Field: ‘node’
[10:58:42.109]   - Field: ‘label’
[10:58:42.109]   - Field: ‘local’
[10:58:42.109]   - Field: ‘owner’
[10:58:42.109]   - Field: ‘envir’
[10:58:42.109]   - Field: ‘workers’
[10:58:42.109]   - Field: ‘packages’
[10:58:42.109]   - Field: ‘gc’
[10:58:42.109]   - Field: ‘conditions’
[10:58:42.109]   - Field: ‘persistent’
[10:58:42.109]   - Field: ‘expr’
[10:58:42.110]   - Field: ‘uuid’
[10:58:42.110]   - Field: ‘seed’
[10:58:42.110]   - Field: ‘version’
[10:58:42.110]   - Field: ‘result’
[10:58:42.110]   - Field: ‘asynchronous’
[10:58:42.110]   - Field: ‘calls’
[10:58:42.110]   - Field: ‘globals’
[10:58:42.110]   - Field: ‘stdout’
[10:58:42.110]   - Field: ‘earlySignal’
[10:58:42.110]   - Field: ‘lazy’
[10:58:42.110]   - Field: ‘state’
[10:58:42.111] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:42.111] - Launch lazy future ...
[10:58:42.111] Packages needed by the future expression (n = 0): <none>
[10:58:42.111] Packages needed by future strategies (n = 0): <none>
[10:58:42.112] {
[10:58:42.112]     {
[10:58:42.112]         {
[10:58:42.112]             ...future.startTime <- base::Sys.time()
[10:58:42.112]             {
[10:58:42.112]                 {
[10:58:42.112]                   {
[10:58:42.112]                     {
[10:58:42.112]                       base::local({
[10:58:42.112]                         has_future <- base::requireNamespace("future", 
[10:58:42.112]                           quietly = TRUE)
[10:58:42.112]                         if (has_future) {
[10:58:42.112]                           ns <- base::getNamespace("future")
[10:58:42.112]                           version <- ns[[".package"]][["version"]]
[10:58:42.112]                           if (is.null(version)) 
[10:58:42.112]                             version <- utils::packageVersion("future")
[10:58:42.112]                         }
[10:58:42.112]                         else {
[10:58:42.112]                           version <- NULL
[10:58:42.112]                         }
[10:58:42.112]                         if (!has_future || version < "1.8.0") {
[10:58:42.112]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.112]                             "", base::R.version$version.string), 
[10:58:42.112]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:42.112]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.112]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.112]                               "release", "version")], collapse = " "), 
[10:58:42.112]                             hostname = base::Sys.info()[["nodename"]])
[10:58:42.112]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.112]                             info)
[10:58:42.112]                           info <- base::paste(info, collapse = "; ")
[10:58:42.112]                           if (!has_future) {
[10:58:42.112]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.112]                               info)
[10:58:42.112]                           }
[10:58:42.112]                           else {
[10:58:42.112]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.112]                               info, version)
[10:58:42.112]                           }
[10:58:42.112]                           base::stop(msg)
[10:58:42.112]                         }
[10:58:42.112]                       })
[10:58:42.112]                     }
[10:58:42.112]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:42.112]                     base::options(mc.cores = 1L)
[10:58:42.112]                   }
[10:58:42.112]                   ...future.strategy.old <- future::plan("list")
[10:58:42.112]                   options(future.plan = NULL)
[10:58:42.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.112]                 }
[10:58:42.112]                 ...future.workdir <- getwd()
[10:58:42.112]             }
[10:58:42.112]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.112]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.112]         }
[10:58:42.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.112]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:42.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.112]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.112]             base::names(...future.oldOptions))
[10:58:42.112]     }
[10:58:42.112]     if (FALSE) {
[10:58:42.112]     }
[10:58:42.112]     else {
[10:58:42.112]         if (TRUE) {
[10:58:42.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.112]                 open = "w")
[10:58:42.112]         }
[10:58:42.112]         else {
[10:58:42.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.112]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.112]         }
[10:58:42.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.112]             base::sink(type = "output", split = FALSE)
[10:58:42.112]             base::close(...future.stdout)
[10:58:42.112]         }, add = TRUE)
[10:58:42.112]     }
[10:58:42.112]     ...future.frame <- base::sys.nframe()
[10:58:42.112]     ...future.conditions <- base::list()
[10:58:42.112]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.112]     if (FALSE) {
[10:58:42.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.112]     }
[10:58:42.112]     ...future.result <- base::tryCatch({
[10:58:42.112]         base::withCallingHandlers({
[10:58:42.112]             ...future.value <- base::withVisible(base::local({
[10:58:42.112]                 ...future.makeSendCondition <- base::local({
[10:58:42.112]                   sendCondition <- NULL
[10:58:42.112]                   function(frame = 1L) {
[10:58:42.112]                     if (is.function(sendCondition)) 
[10:58:42.112]                       return(sendCondition)
[10:58:42.112]                     ns <- getNamespace("parallel")
[10:58:42.112]                     if (exists("sendData", mode = "function", 
[10:58:42.112]                       envir = ns)) {
[10:58:42.112]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:42.112]                         envir = ns)
[10:58:42.112]                       envir <- sys.frame(frame)
[10:58:42.112]                       master <- NULL
[10:58:42.112]                       while (!identical(envir, .GlobalEnv) && 
[10:58:42.112]                         !identical(envir, emptyenv())) {
[10:58:42.112]                         if (exists("master", mode = "list", envir = envir, 
[10:58:42.112]                           inherits = FALSE)) {
[10:58:42.112]                           master <- get("master", mode = "list", 
[10:58:42.112]                             envir = envir, inherits = FALSE)
[10:58:42.112]                           if (inherits(master, c("SOCKnode", 
[10:58:42.112]                             "SOCK0node"))) {
[10:58:42.112]                             sendCondition <<- function(cond) {
[10:58:42.112]                               data <- list(type = "VALUE", value = cond, 
[10:58:42.112]                                 success = TRUE)
[10:58:42.112]                               parallel_sendData(master, data)
[10:58:42.112]                             }
[10:58:42.112]                             return(sendCondition)
[10:58:42.112]                           }
[10:58:42.112]                         }
[10:58:42.112]                         frame <- frame + 1L
[10:58:42.112]                         envir <- sys.frame(frame)
[10:58:42.112]                       }
[10:58:42.112]                     }
[10:58:42.112]                     sendCondition <<- function(cond) NULL
[10:58:42.112]                   }
[10:58:42.112]                 })
[10:58:42.112]                 withCallingHandlers({
[10:58:42.112]                   {
[10:58:42.112]                     do.call(function(...) {
[10:58:42.112]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.112]                       if (!identical(...future.globals.maxSize.org, 
[10:58:42.112]                         ...future.globals.maxSize)) {
[10:58:42.112]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.112]                         on.exit(options(oopts), add = TRUE)
[10:58:42.112]                       }
[10:58:42.112]                       {
[10:58:42.112]                         lapply(seq_along(...future.elements_ii), 
[10:58:42.112]                           FUN = function(jj) {
[10:58:42.112]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.112]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:42.112]                               envir = globalenv(), inherits = FALSE)
[10:58:42.112]                             ...future.FUN(...future.X_jj, ...)
[10:58:42.112]                           })
[10:58:42.112]                       }
[10:58:42.112]                     }, args = future.call.arguments)
[10:58:42.112]                   }
[10:58:42.112]                 }, immediateCondition = function(cond) {
[10:58:42.112]                   sendCondition <- ...future.makeSendCondition()
[10:58:42.112]                   sendCondition(cond)
[10:58:42.112]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.112]                   {
[10:58:42.112]                     inherits <- base::inherits
[10:58:42.112]                     invokeRestart <- base::invokeRestart
[10:58:42.112]                     is.null <- base::is.null
[10:58:42.112]                     muffled <- FALSE
[10:58:42.112]                     if (inherits(cond, "message")) {
[10:58:42.112]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:42.112]                       if (muffled) 
[10:58:42.112]                         invokeRestart("muffleMessage")
[10:58:42.112]                     }
[10:58:42.112]                     else if (inherits(cond, "warning")) {
[10:58:42.112]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:42.112]                       if (muffled) 
[10:58:42.112]                         invokeRestart("muffleWarning")
[10:58:42.112]                     }
[10:58:42.112]                     else if (inherits(cond, "condition")) {
[10:58:42.112]                       if (!is.null(pattern)) {
[10:58:42.112]                         computeRestarts <- base::computeRestarts
[10:58:42.112]                         grepl <- base::grepl
[10:58:42.112]                         restarts <- computeRestarts(cond)
[10:58:42.112]                         for (restart in restarts) {
[10:58:42.112]                           name <- restart$name
[10:58:42.112]                           if (is.null(name)) 
[10:58:42.112]                             next
[10:58:42.112]                           if (!grepl(pattern, name)) 
[10:58:42.112]                             next
[10:58:42.112]                           invokeRestart(restart)
[10:58:42.112]                           muffled <- TRUE
[10:58:42.112]                           break
[10:58:42.112]                         }
[10:58:42.112]                       }
[10:58:42.112]                     }
[10:58:42.112]                     invisible(muffled)
[10:58:42.112]                   }
[10:58:42.112]                   muffleCondition(cond)
[10:58:42.112]                 })
[10:58:42.112]             }))
[10:58:42.112]             future::FutureResult(value = ...future.value$value, 
[10:58:42.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.112]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.112]                     ...future.globalenv.names))
[10:58:42.112]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.112]         }, condition = base::local({
[10:58:42.112]             c <- base::c
[10:58:42.112]             inherits <- base::inherits
[10:58:42.112]             invokeRestart <- base::invokeRestart
[10:58:42.112]             length <- base::length
[10:58:42.112]             list <- base::list
[10:58:42.112]             seq.int <- base::seq.int
[10:58:42.112]             signalCondition <- base::signalCondition
[10:58:42.112]             sys.calls <- base::sys.calls
[10:58:42.112]             `[[` <- base::`[[`
[10:58:42.112]             `+` <- base::`+`
[10:58:42.112]             `<<-` <- base::`<<-`
[10:58:42.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.112]                   3L)]
[10:58:42.112]             }
[10:58:42.112]             function(cond) {
[10:58:42.112]                 is_error <- inherits(cond, "error")
[10:58:42.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.112]                   NULL)
[10:58:42.112]                 if (is_error) {
[10:58:42.112]                   sessionInformation <- function() {
[10:58:42.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.112]                       search = base::search(), system = base::Sys.info())
[10:58:42.112]                   }
[10:58:42.112]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.112]                     cond$call), session = sessionInformation(), 
[10:58:42.112]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.112]                   signalCondition(cond)
[10:58:42.112]                 }
[10:58:42.112]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:58:42.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.112]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.112]                   if (TRUE && !signal) {
[10:58:42.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.112]                     {
[10:58:42.112]                       inherits <- base::inherits
[10:58:42.112]                       invokeRestart <- base::invokeRestart
[10:58:42.112]                       is.null <- base::is.null
[10:58:42.112]                       muffled <- FALSE
[10:58:42.112]                       if (inherits(cond, "message")) {
[10:58:42.112]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.112]                         if (muffled) 
[10:58:42.112]                           invokeRestart("muffleMessage")
[10:58:42.112]                       }
[10:58:42.112]                       else if (inherits(cond, "warning")) {
[10:58:42.112]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.112]                         if (muffled) 
[10:58:42.112]                           invokeRestart("muffleWarning")
[10:58:42.112]                       }
[10:58:42.112]                       else if (inherits(cond, "condition")) {
[10:58:42.112]                         if (!is.null(pattern)) {
[10:58:42.112]                           computeRestarts <- base::computeRestarts
[10:58:42.112]                           grepl <- base::grepl
[10:58:42.112]                           restarts <- computeRestarts(cond)
[10:58:42.112]                           for (restart in restarts) {
[10:58:42.112]                             name <- restart$name
[10:58:42.112]                             if (is.null(name)) 
[10:58:42.112]                               next
[10:58:42.112]                             if (!grepl(pattern, name)) 
[10:58:42.112]                               next
[10:58:42.112]                             invokeRestart(restart)
[10:58:42.112]                             muffled <- TRUE
[10:58:42.112]                             break
[10:58:42.112]                           }
[10:58:42.112]                         }
[10:58:42.112]                       }
[10:58:42.112]                       invisible(muffled)
[10:58:42.112]                     }
[10:58:42.112]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.112]                   }
[10:58:42.112]                 }
[10:58:42.112]                 else {
[10:58:42.112]                   if (TRUE) {
[10:58:42.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.112]                     {
[10:58:42.112]                       inherits <- base::inherits
[10:58:42.112]                       invokeRestart <- base::invokeRestart
[10:58:42.112]                       is.null <- base::is.null
[10:58:42.112]                       muffled <- FALSE
[10:58:42.112]                       if (inherits(cond, "message")) {
[10:58:42.112]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.112]                         if (muffled) 
[10:58:42.112]                           invokeRestart("muffleMessage")
[10:58:42.112]                       }
[10:58:42.112]                       else if (inherits(cond, "warning")) {
[10:58:42.112]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.112]                         if (muffled) 
[10:58:42.112]                           invokeRestart("muffleWarning")
[10:58:42.112]                       }
[10:58:42.112]                       else if (inherits(cond, "condition")) {
[10:58:42.112]                         if (!is.null(pattern)) {
[10:58:42.112]                           computeRestarts <- base::computeRestarts
[10:58:42.112]                           grepl <- base::grepl
[10:58:42.112]                           restarts <- computeRestarts(cond)
[10:58:42.112]                           for (restart in restarts) {
[10:58:42.112]                             name <- restart$name
[10:58:42.112]                             if (is.null(name)) 
[10:58:42.112]                               next
[10:58:42.112]                             if (!grepl(pattern, name)) 
[10:58:42.112]                               next
[10:58:42.112]                             invokeRestart(restart)
[10:58:42.112]                             muffled <- TRUE
[10:58:42.112]                             break
[10:58:42.112]                           }
[10:58:42.112]                         }
[10:58:42.112]                       }
[10:58:42.112]                       invisible(muffled)
[10:58:42.112]                     }
[10:58:42.112]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.112]                   }
[10:58:42.112]                 }
[10:58:42.112]             }
[10:58:42.112]         }))
[10:58:42.112]     }, error = function(ex) {
[10:58:42.112]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.112]                 ...future.rng), started = ...future.startTime, 
[10:58:42.112]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.112]             version = "1.8"), class = "FutureResult")
[10:58:42.112]     }, finally = {
[10:58:42.112]         if (!identical(...future.workdir, getwd())) 
[10:58:42.112]             setwd(...future.workdir)
[10:58:42.112]         {
[10:58:42.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.112]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.112]             }
[10:58:42.112]             base::options(...future.oldOptions)
[10:58:42.112]             if (.Platform$OS.type == "windows") {
[10:58:42.112]                 old_names <- names(...future.oldEnvVars)
[10:58:42.112]                 envs <- base::Sys.getenv()
[10:58:42.112]                 names <- names(envs)
[10:58:42.112]                 common <- intersect(names, old_names)
[10:58:42.112]                 added <- setdiff(names, old_names)
[10:58:42.112]                 removed <- setdiff(old_names, names)
[10:58:42.112]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.112]                   envs[common]]
[10:58:42.112]                 NAMES <- toupper(changed)
[10:58:42.112]                 args <- list()
[10:58:42.112]                 for (kk in seq_along(NAMES)) {
[10:58:42.112]                   name <- changed[[kk]]
[10:58:42.112]                   NAME <- NAMES[[kk]]
[10:58:42.112]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.112]                     next
[10:58:42.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.112]                 }
[10:58:42.112]                 NAMES <- toupper(added)
[10:58:42.112]                 for (kk in seq_along(NAMES)) {
[10:58:42.112]                   name <- added[[kk]]
[10:58:42.112]                   NAME <- NAMES[[kk]]
[10:58:42.112]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.112]                     next
[10:58:42.112]                   args[[name]] <- ""
[10:58:42.112]                 }
[10:58:42.112]                 NAMES <- toupper(removed)
[10:58:42.112]                 for (kk in seq_along(NAMES)) {
[10:58:42.112]                   name <- removed[[kk]]
[10:58:42.112]                   NAME <- NAMES[[kk]]
[10:58:42.112]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.112]                     next
[10:58:42.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.112]                 }
[10:58:42.112]                 if (length(args) > 0) 
[10:58:42.112]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.112]             }
[10:58:42.112]             else {
[10:58:42.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.112]             }
[10:58:42.112]             {
[10:58:42.112]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.112]                   0L) {
[10:58:42.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.112]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.112]                   base::options(opts)
[10:58:42.112]                 }
[10:58:42.112]                 {
[10:58:42.112]                   {
[10:58:42.112]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:42.112]                     NULL
[10:58:42.112]                   }
[10:58:42.112]                   options(future.plan = NULL)
[10:58:42.112]                   if (is.na(NA_character_)) 
[10:58:42.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.112]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.112]                     .init = FALSE)
[10:58:42.112]                 }
[10:58:42.112]             }
[10:58:42.112]         }
[10:58:42.112]     })
[10:58:42.112]     if (TRUE) {
[10:58:42.112]         base::sink(type = "output", split = FALSE)
[10:58:42.112]         if (TRUE) {
[10:58:42.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.112]         }
[10:58:42.112]         else {
[10:58:42.112]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.112]         }
[10:58:42.112]         base::close(...future.stdout)
[10:58:42.112]         ...future.stdout <- NULL
[10:58:42.112]     }
[10:58:42.112]     ...future.result$conditions <- ...future.conditions
[10:58:42.112]     ...future.result$finished <- base::Sys.time()
[10:58:42.112]     ...future.result
[10:58:42.112] }
[10:58:42.114] Exporting 5 global objects (4.35 KiB) to cluster node #1 ...
[10:58:42.115] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:58:42.115] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:58:42.115] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #1 ...
[10:58:42.157] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #1 ... DONE
[10:58:42.157] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ...
[10:58:42.157] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ... DONE
[10:58:42.157] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ...
[10:58:42.158] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ... DONE
[10:58:42.158] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:58:42.158] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:58:42.158] Exporting 5 global objects (4.35 KiB) to cluster node #1 ... DONE
[10:58:42.159] MultisessionFuture started
[10:58:42.159] - Launch lazy future ... done
[10:58:42.159] run() for ‘MultisessionFuture’ ... done
[10:58:42.159] Created future:
[10:58:42.159] MultisessionFuture:
[10:58:42.159] Label: ‘future_apply-1’
[10:58:42.159] Expression:
[10:58:42.159] {
[10:58:42.159]     do.call(function(...) {
[10:58:42.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.159]             on.exit(options(oopts), add = TRUE)
[10:58:42.159]         }
[10:58:42.159]         {
[10:58:42.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.159]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:42.159]                   envir = globalenv(), inherits = FALSE)
[10:58:42.159]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.159]             })
[10:58:42.159]         }
[10:58:42.159]     }, args = future.call.arguments)
[10:58:42.159] }
[10:58:42.159] Lazy evaluation: FALSE
[10:58:42.159] Asynchronous evaluation: TRUE
[10:58:42.159] Local evaluation: TRUE
[10:58:42.159] Environment: R_GlobalEnv
[10:58:42.159] Capture standard output: TRUE
[10:58:42.159] Capture condition classes: <none>
[10:58:42.159] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:42.159] Packages: <none>
[10:58:42.159] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:58:42.159] Resolved: FALSE
[10:58:42.159] Value: <not collected>
[10:58:42.159] Conditions captured: <none>
[10:58:42.159] Early signaling: FALSE
[10:58:42.159] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:42.159] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:42.171] Chunk #1 of 2 ... DONE
[10:58:42.171] Chunk #2 of 2 ...
[10:58:42.171]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:58:42.171]  - seeds: [1] <seeds>
[10:58:42.171]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.171] getGlobalsAndPackages() ...
[10:58:42.171] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.172] Resolving globals: FALSE
[10:58:42.172] Tweak future expression to call with '...' arguments ...
[10:58:42.172] {
[10:58:42.172]     do.call(function(...) {
[10:58:42.172]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.172]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.172]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.172]             on.exit(options(oopts), add = TRUE)
[10:58:42.172]         }
[10:58:42.172]         {
[10:58:42.172]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.172]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.172]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:42.172]                   envir = globalenv(), inherits = FALSE)
[10:58:42.172]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.172]             })
[10:58:42.172]         }
[10:58:42.172]     }, args = future.call.arguments)
[10:58:42.172] }
[10:58:42.172] Tweak future expression to call with '...' arguments ... DONE
[10:58:42.172] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:58:42.173] 
[10:58:42.173] getGlobalsAndPackages() ... DONE
[10:58:42.173] run() for ‘Future’ ...
[10:58:42.173] - state: ‘created’
[10:58:42.173] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:58:42.190] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:42.190] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:58:42.190]   - Field: ‘node’
[10:58:42.190]   - Field: ‘label’
[10:58:42.190]   - Field: ‘local’
[10:58:42.190]   - Field: ‘owner’
[10:58:42.191]   - Field: ‘envir’
[10:58:42.191]   - Field: ‘workers’
[10:58:42.191]   - Field: ‘packages’
[10:58:42.191]   - Field: ‘gc’
[10:58:42.191]   - Field: ‘conditions’
[10:58:42.191]   - Field: ‘persistent’
[10:58:42.191]   - Field: ‘expr’
[10:58:42.191]   - Field: ‘uuid’
[10:58:42.191]   - Field: ‘seed’
[10:58:42.191]   - Field: ‘version’
[10:58:42.191]   - Field: ‘result’
[10:58:42.192]   - Field: ‘asynchronous’
[10:58:42.192]   - Field: ‘calls’
[10:58:42.192]   - Field: ‘globals’
[10:58:42.192]   - Field: ‘stdout’
[10:58:42.192]   - Field: ‘earlySignal’
[10:58:42.192]   - Field: ‘lazy’
[10:58:42.192]   - Field: ‘state’
[10:58:42.192] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:58:42.192] - Launch lazy future ...
[10:58:42.192] Packages needed by the future expression (n = 0): <none>
[10:58:42.193] Packages needed by future strategies (n = 0): <none>
[10:58:42.193] {
[10:58:42.193]     {
[10:58:42.193]         {
[10:58:42.193]             ...future.startTime <- base::Sys.time()
[10:58:42.193]             {
[10:58:42.193]                 {
[10:58:42.193]                   {
[10:58:42.193]                     {
[10:58:42.193]                       base::local({
[10:58:42.193]                         has_future <- base::requireNamespace("future", 
[10:58:42.193]                           quietly = TRUE)
[10:58:42.193]                         if (has_future) {
[10:58:42.193]                           ns <- base::getNamespace("future")
[10:58:42.193]                           version <- ns[[".package"]][["version"]]
[10:58:42.193]                           if (is.null(version)) 
[10:58:42.193]                             version <- utils::packageVersion("future")
[10:58:42.193]                         }
[10:58:42.193]                         else {
[10:58:42.193]                           version <- NULL
[10:58:42.193]                         }
[10:58:42.193]                         if (!has_future || version < "1.8.0") {
[10:58:42.193]                           info <- base::c(r_version = base::gsub("R version ", 
[10:58:42.193]                             "", base::R.version$version.string), 
[10:58:42.193]                             platform = base::sprintf("%s (%s-bit)", 
[10:58:42.193]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:58:42.193]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:58:42.193]                               "release", "version")], collapse = " "), 
[10:58:42.193]                             hostname = base::Sys.info()[["nodename"]])
[10:58:42.193]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:58:42.193]                             info)
[10:58:42.193]                           info <- base::paste(info, collapse = "; ")
[10:58:42.193]                           if (!has_future) {
[10:58:42.193]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:58:42.193]                               info)
[10:58:42.193]                           }
[10:58:42.193]                           else {
[10:58:42.193]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:58:42.193]                               info, version)
[10:58:42.193]                           }
[10:58:42.193]                           base::stop(msg)
[10:58:42.193]                         }
[10:58:42.193]                       })
[10:58:42.193]                     }
[10:58:42.193]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:58:42.193]                     base::options(mc.cores = 1L)
[10:58:42.193]                   }
[10:58:42.193]                   ...future.strategy.old <- future::plan("list")
[10:58:42.193]                   options(future.plan = NULL)
[10:58:42.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:58:42.193]                 }
[10:58:42.193]                 ...future.workdir <- getwd()
[10:58:42.193]             }
[10:58:42.193]             ...future.oldOptions <- base::as.list(base::.Options)
[10:58:42.193]             ...future.oldEnvVars <- base::Sys.getenv()
[10:58:42.193]         }
[10:58:42.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:58:42.193]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:58:42.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:58:42.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:58:42.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:58:42.193]             future.stdout.windows.reencode = NULL, width = 80L)
[10:58:42.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:58:42.193]             base::names(...future.oldOptions))
[10:58:42.193]     }
[10:58:42.193]     if (FALSE) {
[10:58:42.193]     }
[10:58:42.193]     else {
[10:58:42.193]         if (TRUE) {
[10:58:42.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:58:42.193]                 open = "w")
[10:58:42.193]         }
[10:58:42.193]         else {
[10:58:42.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:58:42.193]                 windows = "NUL", "/dev/null"), open = "w")
[10:58:42.193]         }
[10:58:42.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:58:42.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:58:42.193]             base::sink(type = "output", split = FALSE)
[10:58:42.193]             base::close(...future.stdout)
[10:58:42.193]         }, add = TRUE)
[10:58:42.193]     }
[10:58:42.193]     ...future.frame <- base::sys.nframe()
[10:58:42.193]     ...future.conditions <- base::list()
[10:58:42.193]     ...future.rng <- base::globalenv()$.Random.seed
[10:58:42.193]     if (FALSE) {
[10:58:42.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:58:42.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:58:42.193]     }
[10:58:42.193]     ...future.result <- base::tryCatch({
[10:58:42.193]         base::withCallingHandlers({
[10:58:42.193]             ...future.value <- base::withVisible(base::local({
[10:58:42.193]                 ...future.makeSendCondition <- base::local({
[10:58:42.193]                   sendCondition <- NULL
[10:58:42.193]                   function(frame = 1L) {
[10:58:42.193]                     if (is.function(sendCondition)) 
[10:58:42.193]                       return(sendCondition)
[10:58:42.193]                     ns <- getNamespace("parallel")
[10:58:42.193]                     if (exists("sendData", mode = "function", 
[10:58:42.193]                       envir = ns)) {
[10:58:42.193]                       parallel_sendData <- get("sendData", mode = "function", 
[10:58:42.193]                         envir = ns)
[10:58:42.193]                       envir <- sys.frame(frame)
[10:58:42.193]                       master <- NULL
[10:58:42.193]                       while (!identical(envir, .GlobalEnv) && 
[10:58:42.193]                         !identical(envir, emptyenv())) {
[10:58:42.193]                         if (exists("master", mode = "list", envir = envir, 
[10:58:42.193]                           inherits = FALSE)) {
[10:58:42.193]                           master <- get("master", mode = "list", 
[10:58:42.193]                             envir = envir, inherits = FALSE)
[10:58:42.193]                           if (inherits(master, c("SOCKnode", 
[10:58:42.193]                             "SOCK0node"))) {
[10:58:42.193]                             sendCondition <<- function(cond) {
[10:58:42.193]                               data <- list(type = "VALUE", value = cond, 
[10:58:42.193]                                 success = TRUE)
[10:58:42.193]                               parallel_sendData(master, data)
[10:58:42.193]                             }
[10:58:42.193]                             return(sendCondition)
[10:58:42.193]                           }
[10:58:42.193]                         }
[10:58:42.193]                         frame <- frame + 1L
[10:58:42.193]                         envir <- sys.frame(frame)
[10:58:42.193]                       }
[10:58:42.193]                     }
[10:58:42.193]                     sendCondition <<- function(cond) NULL
[10:58:42.193]                   }
[10:58:42.193]                 })
[10:58:42.193]                 withCallingHandlers({
[10:58:42.193]                   {
[10:58:42.193]                     do.call(function(...) {
[10:58:42.193]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.193]                       if (!identical(...future.globals.maxSize.org, 
[10:58:42.193]                         ...future.globals.maxSize)) {
[10:58:42.193]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.193]                         on.exit(options(oopts), add = TRUE)
[10:58:42.193]                       }
[10:58:42.193]                       {
[10:58:42.193]                         lapply(seq_along(...future.elements_ii), 
[10:58:42.193]                           FUN = function(jj) {
[10:58:42.193]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.193]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:42.193]                               envir = globalenv(), inherits = FALSE)
[10:58:42.193]                             ...future.FUN(...future.X_jj, ...)
[10:58:42.193]                           })
[10:58:42.193]                       }
[10:58:42.193]                     }, args = future.call.arguments)
[10:58:42.193]                   }
[10:58:42.193]                 }, immediateCondition = function(cond) {
[10:58:42.193]                   sendCondition <- ...future.makeSendCondition()
[10:58:42.193]                   sendCondition(cond)
[10:58:42.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.193]                   {
[10:58:42.193]                     inherits <- base::inherits
[10:58:42.193]                     invokeRestart <- base::invokeRestart
[10:58:42.193]                     is.null <- base::is.null
[10:58:42.193]                     muffled <- FALSE
[10:58:42.193]                     if (inherits(cond, "message")) {
[10:58:42.193]                       muffled <- grepl(pattern, "muffleMessage")
[10:58:42.193]                       if (muffled) 
[10:58:42.193]                         invokeRestart("muffleMessage")
[10:58:42.193]                     }
[10:58:42.193]                     else if (inherits(cond, "warning")) {
[10:58:42.193]                       muffled <- grepl(pattern, "muffleWarning")
[10:58:42.193]                       if (muffled) 
[10:58:42.193]                         invokeRestart("muffleWarning")
[10:58:42.193]                     }
[10:58:42.193]                     else if (inherits(cond, "condition")) {
[10:58:42.193]                       if (!is.null(pattern)) {
[10:58:42.193]                         computeRestarts <- base::computeRestarts
[10:58:42.193]                         grepl <- base::grepl
[10:58:42.193]                         restarts <- computeRestarts(cond)
[10:58:42.193]                         for (restart in restarts) {
[10:58:42.193]                           name <- restart$name
[10:58:42.193]                           if (is.null(name)) 
[10:58:42.193]                             next
[10:58:42.193]                           if (!grepl(pattern, name)) 
[10:58:42.193]                             next
[10:58:42.193]                           invokeRestart(restart)
[10:58:42.193]                           muffled <- TRUE
[10:58:42.193]                           break
[10:58:42.193]                         }
[10:58:42.193]                       }
[10:58:42.193]                     }
[10:58:42.193]                     invisible(muffled)
[10:58:42.193]                   }
[10:58:42.193]                   muffleCondition(cond)
[10:58:42.193]                 })
[10:58:42.193]             }))
[10:58:42.193]             future::FutureResult(value = ...future.value$value, 
[10:58:42.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.193]                   ...future.rng), globalenv = if (FALSE) 
[10:58:42.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:58:42.193]                     ...future.globalenv.names))
[10:58:42.193]                 else NULL, started = ...future.startTime, version = "1.8")
[10:58:42.193]         }, condition = base::local({
[10:58:42.193]             c <- base::c
[10:58:42.193]             inherits <- base::inherits
[10:58:42.193]             invokeRestart <- base::invokeRestart
[10:58:42.193]             length <- base::length
[10:58:42.193]             list <- base::list
[10:58:42.193]             seq.int <- base::seq.int
[10:58:42.193]             signalCondition <- base::signalCondition
[10:58:42.193]             sys.calls <- base::sys.calls
[10:58:42.193]             `[[` <- base::`[[`
[10:58:42.193]             `+` <- base::`+`
[10:58:42.193]             `<<-` <- base::`<<-`
[10:58:42.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:58:42.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:58:42.193]                   3L)]
[10:58:42.193]             }
[10:58:42.193]             function(cond) {
[10:58:42.193]                 is_error <- inherits(cond, "error")
[10:58:42.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:58:42.193]                   NULL)
[10:58:42.193]                 if (is_error) {
[10:58:42.193]                   sessionInformation <- function() {
[10:58:42.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:58:42.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:58:42.193]                       search = base::search(), system = base::Sys.info())
[10:58:42.193]                   }
[10:58:42.193]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:58:42.193]                     cond$call), session = sessionInformation(), 
[10:58:42.193]                     timestamp = base::Sys.time(), signaled = 0L)
[10:58:42.193]                   signalCondition(cond)
[10:58:42.193]                 }
[10:58:42.193]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:58:42.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:58:42.193]                   ...future.conditions[[length(...future.conditions) + 
[10:58:42.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:58:42.193]                   if (TRUE && !signal) {
[10:58:42.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.193]                     {
[10:58:42.193]                       inherits <- base::inherits
[10:58:42.193]                       invokeRestart <- base::invokeRestart
[10:58:42.193]                       is.null <- base::is.null
[10:58:42.193]                       muffled <- FALSE
[10:58:42.193]                       if (inherits(cond, "message")) {
[10:58:42.193]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.193]                         if (muffled) 
[10:58:42.193]                           invokeRestart("muffleMessage")
[10:58:42.193]                       }
[10:58:42.193]                       else if (inherits(cond, "warning")) {
[10:58:42.193]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.193]                         if (muffled) 
[10:58:42.193]                           invokeRestart("muffleWarning")
[10:58:42.193]                       }
[10:58:42.193]                       else if (inherits(cond, "condition")) {
[10:58:42.193]                         if (!is.null(pattern)) {
[10:58:42.193]                           computeRestarts <- base::computeRestarts
[10:58:42.193]                           grepl <- base::grepl
[10:58:42.193]                           restarts <- computeRestarts(cond)
[10:58:42.193]                           for (restart in restarts) {
[10:58:42.193]                             name <- restart$name
[10:58:42.193]                             if (is.null(name)) 
[10:58:42.193]                               next
[10:58:42.193]                             if (!grepl(pattern, name)) 
[10:58:42.193]                               next
[10:58:42.193]                             invokeRestart(restart)
[10:58:42.193]                             muffled <- TRUE
[10:58:42.193]                             break
[10:58:42.193]                           }
[10:58:42.193]                         }
[10:58:42.193]                       }
[10:58:42.193]                       invisible(muffled)
[10:58:42.193]                     }
[10:58:42.193]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.193]                   }
[10:58:42.193]                 }
[10:58:42.193]                 else {
[10:58:42.193]                   if (TRUE) {
[10:58:42.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:58:42.193]                     {
[10:58:42.193]                       inherits <- base::inherits
[10:58:42.193]                       invokeRestart <- base::invokeRestart
[10:58:42.193]                       is.null <- base::is.null
[10:58:42.193]                       muffled <- FALSE
[10:58:42.193]                       if (inherits(cond, "message")) {
[10:58:42.193]                         muffled <- grepl(pattern, "muffleMessage")
[10:58:42.193]                         if (muffled) 
[10:58:42.193]                           invokeRestart("muffleMessage")
[10:58:42.193]                       }
[10:58:42.193]                       else if (inherits(cond, "warning")) {
[10:58:42.193]                         muffled <- grepl(pattern, "muffleWarning")
[10:58:42.193]                         if (muffled) 
[10:58:42.193]                           invokeRestart("muffleWarning")
[10:58:42.193]                       }
[10:58:42.193]                       else if (inherits(cond, "condition")) {
[10:58:42.193]                         if (!is.null(pattern)) {
[10:58:42.193]                           computeRestarts <- base::computeRestarts
[10:58:42.193]                           grepl <- base::grepl
[10:58:42.193]                           restarts <- computeRestarts(cond)
[10:58:42.193]                           for (restart in restarts) {
[10:58:42.193]                             name <- restart$name
[10:58:42.193]                             if (is.null(name)) 
[10:58:42.193]                               next
[10:58:42.193]                             if (!grepl(pattern, name)) 
[10:58:42.193]                               next
[10:58:42.193]                             invokeRestart(restart)
[10:58:42.193]                             muffled <- TRUE
[10:58:42.193]                             break
[10:58:42.193]                           }
[10:58:42.193]                         }
[10:58:42.193]                       }
[10:58:42.193]                       invisible(muffled)
[10:58:42.193]                     }
[10:58:42.193]                     muffleCondition(cond, pattern = "^muffle")
[10:58:42.193]                   }
[10:58:42.193]                 }
[10:58:42.193]             }
[10:58:42.193]         }))
[10:58:42.193]     }, error = function(ex) {
[10:58:42.193]         base::structure(base::list(value = NULL, visible = NULL, 
[10:58:42.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:58:42.193]                 ...future.rng), started = ...future.startTime, 
[10:58:42.193]             finished = Sys.time(), session_uuid = NA_character_, 
[10:58:42.193]             version = "1.8"), class = "FutureResult")
[10:58:42.193]     }, finally = {
[10:58:42.193]         if (!identical(...future.workdir, getwd())) 
[10:58:42.193]             setwd(...future.workdir)
[10:58:42.193]         {
[10:58:42.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:58:42.193]                 ...future.oldOptions$nwarnings <- NULL
[10:58:42.193]             }
[10:58:42.193]             base::options(...future.oldOptions)
[10:58:42.193]             if (.Platform$OS.type == "windows") {
[10:58:42.193]                 old_names <- names(...future.oldEnvVars)
[10:58:42.193]                 envs <- base::Sys.getenv()
[10:58:42.193]                 names <- names(envs)
[10:58:42.193]                 common <- intersect(names, old_names)
[10:58:42.193]                 added <- setdiff(names, old_names)
[10:58:42.193]                 removed <- setdiff(old_names, names)
[10:58:42.193]                 changed <- common[...future.oldEnvVars[common] != 
[10:58:42.193]                   envs[common]]
[10:58:42.193]                 NAMES <- toupper(changed)
[10:58:42.193]                 args <- list()
[10:58:42.193]                 for (kk in seq_along(NAMES)) {
[10:58:42.193]                   name <- changed[[kk]]
[10:58:42.193]                   NAME <- NAMES[[kk]]
[10:58:42.193]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.193]                     next
[10:58:42.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.193]                 }
[10:58:42.193]                 NAMES <- toupper(added)
[10:58:42.193]                 for (kk in seq_along(NAMES)) {
[10:58:42.193]                   name <- added[[kk]]
[10:58:42.193]                   NAME <- NAMES[[kk]]
[10:58:42.193]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.193]                     next
[10:58:42.193]                   args[[name]] <- ""
[10:58:42.193]                 }
[10:58:42.193]                 NAMES <- toupper(removed)
[10:58:42.193]                 for (kk in seq_along(NAMES)) {
[10:58:42.193]                   name <- removed[[kk]]
[10:58:42.193]                   NAME <- NAMES[[kk]]
[10:58:42.193]                   if (name != NAME && is.element(NAME, old_names)) 
[10:58:42.193]                     next
[10:58:42.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:58:42.193]                 }
[10:58:42.193]                 if (length(args) > 0) 
[10:58:42.193]                   base::do.call(base::Sys.setenv, args = args)
[10:58:42.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:58:42.193]             }
[10:58:42.193]             else {
[10:58:42.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:58:42.193]             }
[10:58:42.193]             {
[10:58:42.193]                 if (base::length(...future.futureOptionsAdded) > 
[10:58:42.193]                   0L) {
[10:58:42.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:58:42.193]                   base::names(opts) <- ...future.futureOptionsAdded
[10:58:42.193]                   base::options(opts)
[10:58:42.193]                 }
[10:58:42.193]                 {
[10:58:42.193]                   {
[10:58:42.193]                     base::options(mc.cores = ...future.mc.cores.old)
[10:58:42.193]                     NULL
[10:58:42.193]                   }
[10:58:42.193]                   options(future.plan = NULL)
[10:58:42.193]                   if (is.na(NA_character_)) 
[10:58:42.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:58:42.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:58:42.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:58:42.193]                     .init = FALSE)
[10:58:42.193]                 }
[10:58:42.193]             }
[10:58:42.193]         }
[10:58:42.193]     })
[10:58:42.193]     if (TRUE) {
[10:58:42.193]         base::sink(type = "output", split = FALSE)
[10:58:42.193]         if (TRUE) {
[10:58:42.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:58:42.193]         }
[10:58:42.193]         else {
[10:58:42.193]             ...future.result["stdout"] <- base::list(NULL)
[10:58:42.193]         }
[10:58:42.193]         base::close(...future.stdout)
[10:58:42.193]         ...future.stdout <- NULL
[10:58:42.193]     }
[10:58:42.193]     ...future.result$conditions <- ...future.conditions
[10:58:42.193]     ...future.result$finished <- base::Sys.time()
[10:58:42.193]     ...future.result
[10:58:42.193] }
[10:58:42.196] Exporting 5 global objects (4.35 KiB) to cluster node #2 ...
[10:58:42.196] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:58:42.196] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:58:42.197] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #2 ...
[10:58:42.238] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #2 ... DONE
[10:58:42.238] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ...
[10:58:42.238] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ... DONE
[10:58:42.238] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ...
[10:58:42.239] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ... DONE
[10:58:42.239] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:58:42.239] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:58:42.239] Exporting 5 global objects (4.35 KiB) to cluster node #2 ... DONE
[10:58:42.240] MultisessionFuture started
[10:58:42.240] - Launch lazy future ... done
[10:58:42.240] run() for ‘MultisessionFuture’ ... done
[10:58:42.240] Created future:
[10:58:42.240] MultisessionFuture:
[10:58:42.240] Label: ‘future_apply-2’
[10:58:42.240] Expression:
[10:58:42.240] {
[10:58:42.240]     do.call(function(...) {
[10:58:42.240]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:58:42.240]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:58:42.240]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:58:42.240]             on.exit(options(oopts), add = TRUE)
[10:58:42.240]         }
[10:58:42.240]         {
[10:58:42.240]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:58:42.240]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:58:42.240]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:58:42.240]                   envir = globalenv(), inherits = FALSE)
[10:58:42.240]                 ...future.FUN(...future.X_jj, ...)
[10:58:42.240]             })
[10:58:42.240]         }
[10:58:42.240]     }, args = future.call.arguments)
[10:58:42.240] }
[10:58:42.240] Lazy evaluation: FALSE
[10:58:42.240] Asynchronous evaluation: TRUE
[10:58:42.240] Local evaluation: TRUE
[10:58:42.240] Environment: R_GlobalEnv
[10:58:42.240] Capture standard output: TRUE
[10:58:42.240] Capture condition classes: <none>
[10:58:42.240] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:58:42.240] Packages: <none>
[10:58:42.240] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:58:42.240] Resolved: FALSE
[10:58:42.240] Value: <not collected>
[10:58:42.240] Conditions captured: <none>
[10:58:42.240] Early signaling: FALSE
[10:58:42.240] Owner process: 04bc5331-856d-d08a-38ac-eabff5c25e8b
[10:58:42.240] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:58:42.252] Chunk #2 of 2 ... DONE
[10:58:42.252] Launching 2 futures (chunks) ... DONE
[10:58:42.252] Resolving 2 futures (chunks) ...
[10:58:42.252] resolve() on list ...
[10:58:42.252]  recursive: 0
[10:58:42.253]  length: 2
[10:58:42.253] 
[10:58:42.253] receiveMessageFromWorker() for ClusterFuture ...
[10:58:42.253] - Validating connection of MultisessionFuture
[10:58:42.253] - received message: FutureResult
[10:58:42.253] - Received FutureResult
[10:58:42.254] - Erased future from FutureRegistry
[10:58:42.254] result() for ClusterFuture ...
[10:58:42.254] - result already collected: FutureResult
[10:58:42.254] result() for ClusterFuture ... done
[10:58:42.254] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:42.254] Future #1
[10:58:42.254] result() for ClusterFuture ...
[10:58:42.254] - result already collected: FutureResult
[10:58:42.254] result() for ClusterFuture ... done
[10:58:42.254] result() for ClusterFuture ...
[10:58:42.254] - result already collected: FutureResult
[10:58:42.254] result() for ClusterFuture ... done
[10:58:42.255] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:58:42.255] - nx: 2
[10:58:42.255] - relay: TRUE
[10:58:42.255] - stdout: TRUE
[10:58:42.255] - signal: TRUE
[10:58:42.255] - resignal: FALSE
[10:58:42.255] - force: TRUE
[10:58:42.255] - relayed: [n=2] FALSE, FALSE
[10:58:42.255] - queued futures: [n=2] FALSE, FALSE
[10:58:42.255]  - until=1
[10:58:42.255]  - relaying element #1
[10:58:42.255] result() for ClusterFuture ...
[10:58:42.256] - result already collected: FutureResult
[10:58:42.256] result() for ClusterFuture ... done
[10:58:42.256] result() for ClusterFuture ...
[10:58:42.256] - result already collected: FutureResult
[10:58:42.256] result() for ClusterFuture ... done
[10:58:42.256] result() for ClusterFuture ...
[10:58:42.256] - result already collected: FutureResult
[10:58:42.256] result() for ClusterFuture ... done
[10:58:42.256] result() for ClusterFuture ...
[10:58:42.256] - result already collected: FutureResult
[10:58:42.256] result() for ClusterFuture ... done
[10:58:42.256] - relayed: [n=2] TRUE, FALSE
[10:58:42.257] - queued futures: [n=2] TRUE, FALSE
[10:58:42.257] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:58:42.257]  length: 1 (resolved future 1)
[10:58:42.282] receiveMessageFromWorker() for ClusterFuture ...
[10:58:42.282] - Validating connection of MultisessionFuture
[10:58:42.283] - received message: FutureResult
[10:58:42.283] - Received FutureResult
[10:58:42.283] - Erased future from FutureRegistry
[10:58:42.283] result() for ClusterFuture ...
[10:58:42.283] - result already collected: FutureResult
[10:58:42.283] result() for ClusterFuture ... done
[10:58:42.283] receiveMessageFromWorker() for ClusterFuture ... done
[10:58:42.283] Future #2
[10:58:42.283] result() for ClusterFuture ...
[10:58:42.283] - result already collected: FutureResult
[10:58:42.284] result() for ClusterFuture ... done
[10:58:42.284] result() for ClusterFuture ...
[10:58:42.284] - result already collected: FutureResult
[10:58:42.284] result() for ClusterFuture ... done
[10:58:42.284] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:58:42.284] - nx: 2
[10:58:42.284] - relay: TRUE
[10:58:42.284] - stdout: TRUE
[10:58:42.284] - signal: TRUE
[10:58:42.284] - resignal: FALSE
[10:58:42.284] - force: TRUE
[10:58:42.284] - relayed: [n=2] TRUE, FALSE
[10:58:42.285] - queued futures: [n=2] TRUE, FALSE
[10:58:42.285]  - until=2
[10:58:42.285]  - relaying element #2
[10:58:42.285] result() for ClusterFuture ...
[10:58:42.285] - result already collected: FutureResult
[10:58:42.285] result() for ClusterFuture ... done
[10:58:42.285] result() for ClusterFuture ...
[10:58:42.285] - result already collected: FutureResult
[10:58:42.285] result() for ClusterFuture ... done
[10:58:42.285] result() for ClusterFuture ...
[10:58:42.285] - result already collected: FutureResult
[10:58:42.286] result() for ClusterFuture ... done
[10:58:42.286] result() for ClusterFuture ...
[10:58:42.286] - result already collected: FutureResult
[10:58:42.286] result() for ClusterFuture ... done
[10:58:42.286] - relayed: [n=2] TRUE, TRUE
[10:58:42.286] - queued futures: [n=2] TRUE, TRUE
[10:58:42.286] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:58:42.286]  length: 0 (resolved future 2)
[10:58:42.286] Relaying remaining futures
[10:58:42.286] signalConditionsASAP(NULL, pos=0) ...
[10:58:42.286] - nx: 2
[10:58:42.286] - relay: TRUE
[10:58:42.287] - stdout: TRUE
[10:58:42.287] - signal: TRUE
[10:58:42.287] - resignal: FALSE
[10:58:42.287] - force: TRUE
[10:58:42.287] - relayed: [n=2] TRUE, TRUE
[10:58:42.287] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:58:42.287] - relayed: [n=2] TRUE, TRUE
[10:58:42.287] - queued futures: [n=2] TRUE, TRUE
[10:58:42.287] signalConditionsASAP(NULL, pos=0) ... done
[10:58:42.287] resolve() on list ... DONE
[10:58:42.287] result() for ClusterFuture ...
[10:58:42.287] - result already collected: FutureResult
[10:58:42.288] result() for ClusterFuture ... done
[10:58:42.288] result() for ClusterFuture ...
[10:58:42.288] - result already collected: FutureResult
[10:58:42.288] result() for ClusterFuture ... done
[10:58:42.288] result() for ClusterFuture ...
[10:58:42.288] - result already collected: FutureResult
[10:58:42.288] result() for ClusterFuture ... done
[10:58:42.288] result() for ClusterFuture ...
[10:58:42.288] - result already collected: FutureResult
[10:58:42.288] result() for ClusterFuture ... done
[10:58:42.288]  - Number of value chunks collected: 2
[10:58:42.289] Resolving 2 futures (chunks) ... DONE
[10:58:42.289] Reducing values from 2 chunks ...
[10:58:42.289]  - Number of values collected after concatenation: 2
[10:58:42.289]  - Number of values expected: 2
[10:58:42.289] Reducing values from 2 chunks ... DONE
[10:58:42.289] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:58:42.289] plan(): Setting new future strategy stack:
[10:58:42.289] List of future strategies:
[10:58:42.289] 1. sequential:
[10:58:42.289]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.289]    - tweaked: FALSE
[10:58:42.289]    - call: plan(sequential)
[10:58:42.290] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[10:58:42.292] plan(): Setting new future strategy stack:
[10:58:42.292] List of future strategies:
[10:58:42.292] 1. FutureStrategy:
[10:58:42.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:58:42.292]    - tweaked: FALSE
[10:58:42.292]    - call: future::plan(oplan)
[10:58:42.293] plan(): nbrOfWorkers() = 1
> 
