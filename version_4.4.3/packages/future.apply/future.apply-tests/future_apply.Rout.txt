
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[08:24:51.555] plan(): Setting new future strategy stack:
[08:24:51.555] List of future strategies:
[08:24:51.555] 1. sequential:
[08:24:51.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.555]    - tweaked: FALSE
[08:24:51.555]    - call: future::plan("sequential")
[08:24:51.569] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[08:24:51.633] plan(): Setting new future strategy stack:
[08:24:51.634] List of future strategies:
[08:24:51.634] 1. sequential:
[08:24:51.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.634]    - tweaked: FALSE
[08:24:51.634]    - call: plan(strategy)
[08:24:51.645] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[08:24:51.646] getGlobalsAndPackagesXApply() ...
[08:24:51.646]  - future.globals: TRUE
[08:24:51.646] getGlobalsAndPackages() ...
[08:24:51.647] Searching for globals...
[08:24:51.687] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[08:24:51.687] Searching for globals ... DONE
[08:24:51.687] Resolving globals: FALSE
[08:24:51.690] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[08:24:51.690] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[08:24:51.690] - globals: [1] ‘FUN’
[08:24:51.690] 
[08:24:51.690] getGlobalsAndPackages() ... DONE
[08:24:51.691]  - globals found/used: [n=1] ‘FUN’
[08:24:51.691]  - needed namespaces: [n=0] 
[08:24:51.691] Finding globals ... DONE
[08:24:51.691]  - use_args: TRUE
[08:24:51.691]  - Getting '...' globals ...
[08:24:51.692] resolve() on list ...
[08:24:51.692]  recursive: 0
[08:24:51.692]  length: 1
[08:24:51.692]  elements: ‘...’
[08:24:51.692]  length: 0 (resolved future 1)
[08:24:51.692] resolve() on list ... DONE
[08:24:51.692]    - '...' content: [n=0] 
[08:24:51.693] List of 1
[08:24:51.693]  $ ...: list()
[08:24:51.693]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.693]  - attr(*, "where")=List of 1
[08:24:51.693]   ..$ ...:<environment: 0x56540de8d930> 
[08:24:51.693]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.693]  - attr(*, "resolved")= logi TRUE
[08:24:51.693]  - attr(*, "total_size")= num NA
[08:24:51.697]  - Getting '...' globals ... DONE
[08:24:51.697] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:51.697] List of 2
[08:24:51.697]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:51.697]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:51.697]  $ ...          : list()
[08:24:51.697]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.697]  - attr(*, "where")=List of 2
[08:24:51.697]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:51.697]   ..$ ...          :<environment: 0x56540de8d930> 
[08:24:51.697]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.697]  - attr(*, "resolved")= logi FALSE
[08:24:51.697]  - attr(*, "total_size")= num 65963
[08:24:51.700] Packages to be attached in all futures: [n=0] 
[08:24:51.700] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.701] future_lapply() ...
[08:24:51.734] Number of chunks: 1
[08:24:51.734] getGlobalsAndPackagesXApply() ...
[08:24:51.734]  - future.globals: <name-value list> with names ‘list()’
[08:24:51.734]  - use_args: TRUE
[08:24:51.734] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:51.734] List of 2
[08:24:51.734]  $ ...          : list()
[08:24:51.734]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.734]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:51.734]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:51.734]  - attr(*, "where")=List of 2
[08:24:51.734]   ..$ ...          :<environment: 0x56540de8d930> 
[08:24:51.734]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:51.734]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.734]  - attr(*, "resolved")= logi FALSE
[08:24:51.734]  - attr(*, "total_size")= num NA
[08:24:51.738] Packages to be attached in all futures: [n=0] 
[08:24:51.738] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.738] Number of futures (= number of chunks): 1
[08:24:51.738] Launching 1 futures (chunks) ...
[08:24:51.738] Chunk #1 of 1 ...
[08:24:51.739]  - seeds: <none>
[08:24:51.739]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.739] getGlobalsAndPackages() ...
[08:24:51.739] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.739] Resolving globals: FALSE
[08:24:51.739] Tweak future expression to call with '...' arguments ...
[08:24:51.739] {
[08:24:51.739]     do.call(function(...) {
[08:24:51.739]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.739]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.739]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.739]             on.exit(options(oopts), add = TRUE)
[08:24:51.739]         }
[08:24:51.739]         {
[08:24:51.739]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.739]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.739]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.739]             })
[08:24:51.739]         }
[08:24:51.739]     }, args = future.call.arguments)
[08:24:51.739] }
[08:24:51.740] Tweak future expression to call with '...' arguments ... DONE
[08:24:51.740] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.740] 
[08:24:51.740] getGlobalsAndPackages() ... DONE
[08:24:51.741] run() for ‘Future’ ...
[08:24:51.741] - state: ‘created’
[08:24:51.741] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:51.742] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.742] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:51.742]   - Field: ‘label’
[08:24:51.742]   - Field: ‘local’
[08:24:51.742]   - Field: ‘owner’
[08:24:51.742]   - Field: ‘envir’
[08:24:51.742]   - Field: ‘packages’
[08:24:51.742]   - Field: ‘gc’
[08:24:51.742]   - Field: ‘conditions’
[08:24:51.742]   - Field: ‘expr’
[08:24:51.742]   - Field: ‘uuid’
[08:24:51.743]   - Field: ‘seed’
[08:24:51.743]   - Field: ‘version’
[08:24:51.743]   - Field: ‘result’
[08:24:51.743]   - Field: ‘asynchronous’
[08:24:51.743]   - Field: ‘calls’
[08:24:51.743]   - Field: ‘globals’
[08:24:51.743]   - Field: ‘stdout’
[08:24:51.743]   - Field: ‘earlySignal’
[08:24:51.743]   - Field: ‘lazy’
[08:24:51.743]   - Field: ‘state’
[08:24:51.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:51.744] - Launch lazy future ...
[08:24:51.744] Packages needed by the future expression (n = 0): <none>
[08:24:51.744] Packages needed by future strategies (n = 0): <none>
[08:24:51.745] {
[08:24:51.745]     {
[08:24:51.745]         {
[08:24:51.745]             ...future.startTime <- base::Sys.time()
[08:24:51.745]             {
[08:24:51.745]                 {
[08:24:51.745]                   {
[08:24:51.745]                     base::local({
[08:24:51.745]                       has_future <- base::requireNamespace("future", 
[08:24:51.745]                         quietly = TRUE)
[08:24:51.745]                       if (has_future) {
[08:24:51.745]                         ns <- base::getNamespace("future")
[08:24:51.745]                         version <- ns[[".package"]][["version"]]
[08:24:51.745]                         if (is.null(version)) 
[08:24:51.745]                           version <- utils::packageVersion("future")
[08:24:51.745]                       }
[08:24:51.745]                       else {
[08:24:51.745]                         version <- NULL
[08:24:51.745]                       }
[08:24:51.745]                       if (!has_future || version < "1.8.0") {
[08:24:51.745]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:51.745]                           "", base::R.version$version.string), 
[08:24:51.745]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:51.745]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:51.745]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:51.745]                             "release", "version")], collapse = " "), 
[08:24:51.745]                           hostname = base::Sys.info()[["nodename"]])
[08:24:51.745]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:51.745]                           info)
[08:24:51.745]                         info <- base::paste(info, collapse = "; ")
[08:24:51.745]                         if (!has_future) {
[08:24:51.745]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:51.745]                             info)
[08:24:51.745]                         }
[08:24:51.745]                         else {
[08:24:51.745]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:51.745]                             info, version)
[08:24:51.745]                         }
[08:24:51.745]                         base::stop(msg)
[08:24:51.745]                       }
[08:24:51.745]                     })
[08:24:51.745]                   }
[08:24:51.745]                   ...future.strategy.old <- future::plan("list")
[08:24:51.745]                   options(future.plan = NULL)
[08:24:51.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:51.745]                 }
[08:24:51.745]                 ...future.workdir <- getwd()
[08:24:51.745]             }
[08:24:51.745]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:51.745]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:51.745]         }
[08:24:51.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:51.745]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:51.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:51.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:51.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:51.745]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:51.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:51.745]             base::names(...future.oldOptions))
[08:24:51.745]     }
[08:24:51.745]     if (FALSE) {
[08:24:51.745]     }
[08:24:51.745]     else {
[08:24:51.745]         if (TRUE) {
[08:24:51.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:51.745]                 open = "w")
[08:24:51.745]         }
[08:24:51.745]         else {
[08:24:51.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:51.745]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:51.745]         }
[08:24:51.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:51.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:51.745]             base::sink(type = "output", split = FALSE)
[08:24:51.745]             base::close(...future.stdout)
[08:24:51.745]         }, add = TRUE)
[08:24:51.745]     }
[08:24:51.745]     ...future.frame <- base::sys.nframe()
[08:24:51.745]     ...future.conditions <- base::list()
[08:24:51.745]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:51.745]     if (FALSE) {
[08:24:51.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:51.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:51.745]     }
[08:24:51.745]     ...future.result <- base::tryCatch({
[08:24:51.745]         base::withCallingHandlers({
[08:24:51.745]             ...future.value <- base::withVisible(base::local({
[08:24:51.745]                 do.call(function(...) {
[08:24:51.745]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.745]                   if (!identical(...future.globals.maxSize.org, 
[08:24:51.745]                     ...future.globals.maxSize)) {
[08:24:51.745]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.745]                     on.exit(options(oopts), add = TRUE)
[08:24:51.745]                   }
[08:24:51.745]                   {
[08:24:51.745]                     lapply(seq_along(...future.elements_ii), 
[08:24:51.745]                       FUN = function(jj) {
[08:24:51.745]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.745]                         ...future.FUN(...future.X_jj, ...)
[08:24:51.745]                       })
[08:24:51.745]                   }
[08:24:51.745]                 }, args = future.call.arguments)
[08:24:51.745]             }))
[08:24:51.745]             future::FutureResult(value = ...future.value$value, 
[08:24:51.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.745]                   ...future.rng), globalenv = if (FALSE) 
[08:24:51.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:51.745]                     ...future.globalenv.names))
[08:24:51.745]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:51.745]         }, condition = base::local({
[08:24:51.745]             c <- base::c
[08:24:51.745]             inherits <- base::inherits
[08:24:51.745]             invokeRestart <- base::invokeRestart
[08:24:51.745]             length <- base::length
[08:24:51.745]             list <- base::list
[08:24:51.745]             seq.int <- base::seq.int
[08:24:51.745]             signalCondition <- base::signalCondition
[08:24:51.745]             sys.calls <- base::sys.calls
[08:24:51.745]             `[[` <- base::`[[`
[08:24:51.745]             `+` <- base::`+`
[08:24:51.745]             `<<-` <- base::`<<-`
[08:24:51.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:51.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:51.745]                   3L)]
[08:24:51.745]             }
[08:24:51.745]             function(cond) {
[08:24:51.745]                 is_error <- inherits(cond, "error")
[08:24:51.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:51.745]                   NULL)
[08:24:51.745]                 if (is_error) {
[08:24:51.745]                   sessionInformation <- function() {
[08:24:51.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:51.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:51.745]                       search = base::search(), system = base::Sys.info())
[08:24:51.745]                   }
[08:24:51.745]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:51.745]                     cond$call), session = sessionInformation(), 
[08:24:51.745]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:51.745]                   signalCondition(cond)
[08:24:51.745]                 }
[08:24:51.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:51.745]                 "immediateCondition"))) {
[08:24:51.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:51.745]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:51.745]                   if (TRUE && !signal) {
[08:24:51.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.745]                     {
[08:24:51.745]                       inherits <- base::inherits
[08:24:51.745]                       invokeRestart <- base::invokeRestart
[08:24:51.745]                       is.null <- base::is.null
[08:24:51.745]                       muffled <- FALSE
[08:24:51.745]                       if (inherits(cond, "message")) {
[08:24:51.745]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.745]                         if (muffled) 
[08:24:51.745]                           invokeRestart("muffleMessage")
[08:24:51.745]                       }
[08:24:51.745]                       else if (inherits(cond, "warning")) {
[08:24:51.745]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.745]                         if (muffled) 
[08:24:51.745]                           invokeRestart("muffleWarning")
[08:24:51.745]                       }
[08:24:51.745]                       else if (inherits(cond, "condition")) {
[08:24:51.745]                         if (!is.null(pattern)) {
[08:24:51.745]                           computeRestarts <- base::computeRestarts
[08:24:51.745]                           grepl <- base::grepl
[08:24:51.745]                           restarts <- computeRestarts(cond)
[08:24:51.745]                           for (restart in restarts) {
[08:24:51.745]                             name <- restart$name
[08:24:51.745]                             if (is.null(name)) 
[08:24:51.745]                               next
[08:24:51.745]                             if (!grepl(pattern, name)) 
[08:24:51.745]                               next
[08:24:51.745]                             invokeRestart(restart)
[08:24:51.745]                             muffled <- TRUE
[08:24:51.745]                             break
[08:24:51.745]                           }
[08:24:51.745]                         }
[08:24:51.745]                       }
[08:24:51.745]                       invisible(muffled)
[08:24:51.745]                     }
[08:24:51.745]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.745]                   }
[08:24:51.745]                 }
[08:24:51.745]                 else {
[08:24:51.745]                   if (TRUE) {
[08:24:51.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.745]                     {
[08:24:51.745]                       inherits <- base::inherits
[08:24:51.745]                       invokeRestart <- base::invokeRestart
[08:24:51.745]                       is.null <- base::is.null
[08:24:51.745]                       muffled <- FALSE
[08:24:51.745]                       if (inherits(cond, "message")) {
[08:24:51.745]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.745]                         if (muffled) 
[08:24:51.745]                           invokeRestart("muffleMessage")
[08:24:51.745]                       }
[08:24:51.745]                       else if (inherits(cond, "warning")) {
[08:24:51.745]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.745]                         if (muffled) 
[08:24:51.745]                           invokeRestart("muffleWarning")
[08:24:51.745]                       }
[08:24:51.745]                       else if (inherits(cond, "condition")) {
[08:24:51.745]                         if (!is.null(pattern)) {
[08:24:51.745]                           computeRestarts <- base::computeRestarts
[08:24:51.745]                           grepl <- base::grepl
[08:24:51.745]                           restarts <- computeRestarts(cond)
[08:24:51.745]                           for (restart in restarts) {
[08:24:51.745]                             name <- restart$name
[08:24:51.745]                             if (is.null(name)) 
[08:24:51.745]                               next
[08:24:51.745]                             if (!grepl(pattern, name)) 
[08:24:51.745]                               next
[08:24:51.745]                             invokeRestart(restart)
[08:24:51.745]                             muffled <- TRUE
[08:24:51.745]                             break
[08:24:51.745]                           }
[08:24:51.745]                         }
[08:24:51.745]                       }
[08:24:51.745]                       invisible(muffled)
[08:24:51.745]                     }
[08:24:51.745]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.745]                   }
[08:24:51.745]                 }
[08:24:51.745]             }
[08:24:51.745]         }))
[08:24:51.745]     }, error = function(ex) {
[08:24:51.745]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:51.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.745]                 ...future.rng), started = ...future.startTime, 
[08:24:51.745]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:51.745]             version = "1.8"), class = "FutureResult")
[08:24:51.745]     }, finally = {
[08:24:51.745]         if (!identical(...future.workdir, getwd())) 
[08:24:51.745]             setwd(...future.workdir)
[08:24:51.745]         {
[08:24:51.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:51.745]                 ...future.oldOptions$nwarnings <- NULL
[08:24:51.745]             }
[08:24:51.745]             base::options(...future.oldOptions)
[08:24:51.745]             if (.Platform$OS.type == "windows") {
[08:24:51.745]                 old_names <- names(...future.oldEnvVars)
[08:24:51.745]                 envs <- base::Sys.getenv()
[08:24:51.745]                 names <- names(envs)
[08:24:51.745]                 common <- intersect(names, old_names)
[08:24:51.745]                 added <- setdiff(names, old_names)
[08:24:51.745]                 removed <- setdiff(old_names, names)
[08:24:51.745]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:51.745]                   envs[common]]
[08:24:51.745]                 NAMES <- toupper(changed)
[08:24:51.745]                 args <- list()
[08:24:51.745]                 for (kk in seq_along(NAMES)) {
[08:24:51.745]                   name <- changed[[kk]]
[08:24:51.745]                   NAME <- NAMES[[kk]]
[08:24:51.745]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.745]                     next
[08:24:51.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.745]                 }
[08:24:51.745]                 NAMES <- toupper(added)
[08:24:51.745]                 for (kk in seq_along(NAMES)) {
[08:24:51.745]                   name <- added[[kk]]
[08:24:51.745]                   NAME <- NAMES[[kk]]
[08:24:51.745]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.745]                     next
[08:24:51.745]                   args[[name]] <- ""
[08:24:51.745]                 }
[08:24:51.745]                 NAMES <- toupper(removed)
[08:24:51.745]                 for (kk in seq_along(NAMES)) {
[08:24:51.745]                   name <- removed[[kk]]
[08:24:51.745]                   NAME <- NAMES[[kk]]
[08:24:51.745]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.745]                     next
[08:24:51.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.745]                 }
[08:24:51.745]                 if (length(args) > 0) 
[08:24:51.745]                   base::do.call(base::Sys.setenv, args = args)
[08:24:51.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:51.745]             }
[08:24:51.745]             else {
[08:24:51.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:51.745]             }
[08:24:51.745]             {
[08:24:51.745]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:51.745]                   0L) {
[08:24:51.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:51.745]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:51.745]                   base::options(opts)
[08:24:51.745]                 }
[08:24:51.745]                 {
[08:24:51.745]                   {
[08:24:51.745]                     NULL
[08:24:51.745]                     RNGkind("Mersenne-Twister")
[08:24:51.745]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:51.745]                       inherits = FALSE)
[08:24:51.745]                   }
[08:24:51.745]                   options(future.plan = NULL)
[08:24:51.745]                   if (is.na(NA_character_)) 
[08:24:51.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:51.745]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:51.745]                     .init = FALSE)
[08:24:51.745]                 }
[08:24:51.745]             }
[08:24:51.745]         }
[08:24:51.745]     })
[08:24:51.745]     if (TRUE) {
[08:24:51.745]         base::sink(type = "output", split = FALSE)
[08:24:51.745]         if (TRUE) {
[08:24:51.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:51.745]         }
[08:24:51.745]         else {
[08:24:51.745]             ...future.result["stdout"] <- base::list(NULL)
[08:24:51.745]         }
[08:24:51.745]         base::close(...future.stdout)
[08:24:51.745]         ...future.stdout <- NULL
[08:24:51.745]     }
[08:24:51.745]     ...future.result$conditions <- ...future.conditions
[08:24:51.745]     ...future.result$finished <- base::Sys.time()
[08:24:51.745]     ...future.result
[08:24:51.745] }
[08:24:51.747] assign_globals() ...
[08:24:51.747] List of 5
[08:24:51.747]  $ future.call.arguments    : list()
[08:24:51.747]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.747]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:51.747]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:51.747]  $ ...future.elements_ii    :List of 2
[08:24:51.747]   ..$ : num [1:4] 1 3 1 7
[08:24:51.747]   ..$ : num [1:4] 2 4 6 8
[08:24:51.747]  $ ...future.seeds_ii       : NULL
[08:24:51.747]  $ ...future.globals.maxSize: num Inf
[08:24:51.747]  - attr(*, "resolved")= logi FALSE
[08:24:51.747]  - attr(*, "total_size")= num NA
[08:24:51.747]  - attr(*, "where")=List of 5
[08:24:51.747]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:51.747]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:51.747]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:51.747]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:51.747]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:51.747]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.747]  - attr(*, "already-done")= logi TRUE
[08:24:51.752] - copied ‘future.call.arguments’ to environment
[08:24:51.752] - copied ‘...future.FUN’ to environment
[08:24:51.752] - copied ‘...future.elements_ii’ to environment
[08:24:51.752] - copied ‘...future.seeds_ii’ to environment
[08:24:51.752] - copied ‘...future.globals.maxSize’ to environment
[08:24:51.753] assign_globals() ... done
[08:24:51.753] plan(): Setting new future strategy stack:
[08:24:51.753] List of future strategies:
[08:24:51.753] 1. sequential:
[08:24:51.753]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.753]    - tweaked: FALSE
[08:24:51.753]    - call: NULL
[08:24:51.753] plan(): nbrOfWorkers() = 1
[08:24:51.755] plan(): Setting new future strategy stack:
[08:24:51.755] List of future strategies:
[08:24:51.755] 1. sequential:
[08:24:51.755]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.755]    - tweaked: FALSE
[08:24:51.755]    - call: plan(strategy)
[08:24:51.755] plan(): nbrOfWorkers() = 1
[08:24:51.756] SequentialFuture started (and completed)
[08:24:51.756] - Launch lazy future ... done
[08:24:51.756] run() for ‘SequentialFuture’ ... done
[08:24:51.756] Created future:
[08:24:51.756] SequentialFuture:
[08:24:51.756] Label: ‘future_apply-1’
[08:24:51.756] Expression:
[08:24:51.756] {
[08:24:51.756]     do.call(function(...) {
[08:24:51.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.756]             on.exit(options(oopts), add = TRUE)
[08:24:51.756]         }
[08:24:51.756]         {
[08:24:51.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.756]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.756]             })
[08:24:51.756]         }
[08:24:51.756]     }, args = future.call.arguments)
[08:24:51.756] }
[08:24:51.756] Lazy evaluation: FALSE
[08:24:51.756] Asynchronous evaluation: FALSE
[08:24:51.756] Local evaluation: TRUE
[08:24:51.756] Environment: R_GlobalEnv
[08:24:51.756] Capture standard output: TRUE
[08:24:51.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:51.756] Globals: 5 objects totaling 31.56 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 111 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:51.756] Packages: <none>
[08:24:51.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:51.756] Resolved: TRUE
[08:24:51.756] Value: 429 bytes of class ‘list’
[08:24:51.756] Early signaling: FALSE
[08:24:51.756] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:51.756] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.758] Chunk #1 of 1 ... DONE
[08:24:51.758] Launching 1 futures (chunks) ... DONE
[08:24:51.758] Resolving 1 futures (chunks) ...
[08:24:51.758] resolve() on list ...
[08:24:51.758]  recursive: 0
[08:24:51.758]  length: 1
[08:24:51.758] 
[08:24:51.758] resolved() for ‘SequentialFuture’ ...
[08:24:51.759] - state: ‘finished’
[08:24:51.759] - run: TRUE
[08:24:51.759] - result: ‘FutureResult’
[08:24:51.759] resolved() for ‘SequentialFuture’ ... done
[08:24:51.759] Future #1
[08:24:51.759] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:51.759] - nx: 1
[08:24:51.759] - relay: TRUE
[08:24:51.760] - stdout: TRUE
[08:24:51.760] - signal: TRUE
[08:24:51.760] - resignal: FALSE
[08:24:51.760] - force: TRUE
[08:24:51.762] - relayed: [n=1] FALSE
[08:24:51.762] - queued futures: [n=1] FALSE
[08:24:51.762]  - until=1
[08:24:51.762]  - relaying element #1
[08:24:51.762] - relayed: [n=1] TRUE
[08:24:51.762] - queued futures: [n=1] TRUE
[08:24:51.763] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:51.763]  length: 0 (resolved future 1)
[08:24:51.763] Relaying remaining futures
[08:24:51.763] signalConditionsASAP(NULL, pos=0) ...
[08:24:51.763] - nx: 1
[08:24:51.763] - relay: TRUE
[08:24:51.763] - stdout: TRUE
[08:24:51.763] - signal: TRUE
[08:24:51.763] - resignal: FALSE
[08:24:51.763] - force: TRUE
[08:24:51.763] - relayed: [n=1] TRUE
[08:24:51.764] - queued futures: [n=1] TRUE
 - flush all
[08:24:51.764] - relayed: [n=1] TRUE
[08:24:51.764] - queued futures: [n=1] TRUE
[08:24:51.764] signalConditionsASAP(NULL, pos=0) ... done
[08:24:51.764] resolve() on list ... DONE
[08:24:51.764]  - Number of value chunks collected: 1
[08:24:51.764] Resolving 1 futures (chunks) ... DONE
[08:24:51.764] Reducing values from 1 chunks ...
[08:24:51.764]  - Number of values collected after concatenation: 2
[08:24:51.764]  - Number of values expected: 2
[08:24:51.765] Reducing values from 1 chunks ... DONE
[08:24:51.765] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[08:24:51.765] getGlobalsAndPackagesXApply() ...
[08:24:51.766]  - future.globals: TRUE
[08:24:51.766] getGlobalsAndPackages() ...
[08:24:51.766] Searching for globals...
[08:24:51.798] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[08:24:51.799] Searching for globals ... DONE
[08:24:51.799] Resolving globals: FALSE
[08:24:51.802] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[08:24:51.803] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[08:24:51.803] - globals: [1] ‘FUN’
[08:24:51.803] 
[08:24:51.803] getGlobalsAndPackages() ... DONE
[08:24:51.803]  - globals found/used: [n=1] ‘FUN’
[08:24:51.803]  - needed namespaces: [n=0] 
[08:24:51.803] Finding globals ... DONE
[08:24:51.803]  - use_args: TRUE
[08:24:51.803]  - Getting '...' globals ...
[08:24:51.804] resolve() on list ...
[08:24:51.804]  recursive: 0
[08:24:51.804]  length: 1
[08:24:51.804]  elements: ‘...’
[08:24:51.804]  length: 0 (resolved future 1)
[08:24:51.804] resolve() on list ... DONE
[08:24:51.804]    - '...' content: [n=0] 
[08:24:51.804] List of 1
[08:24:51.804]  $ ...: list()
[08:24:51.804]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.804]  - attr(*, "where")=List of 1
[08:24:51.804]   ..$ ...:<environment: 0x56540c5d4698> 
[08:24:51.804]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.804]  - attr(*, "resolved")= logi TRUE
[08:24:51.804]  - attr(*, "total_size")= num NA
[08:24:51.807]  - Getting '...' globals ... DONE
[08:24:51.807] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:51.807] List of 2
[08:24:51.807]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:51.807]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:51.807]  $ ...          : list()
[08:24:51.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.807]  - attr(*, "where")=List of 2
[08:24:51.807]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:51.807]   ..$ ...          :<environment: 0x56540c5d4698> 
[08:24:51.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.807]  - attr(*, "resolved")= logi FALSE
[08:24:51.807]  - attr(*, "total_size")= num 65967
[08:24:51.810] Packages to be attached in all futures: [n=0] 
[08:24:51.810] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.811] future_lapply() ...
[08:24:51.844] Number of chunks: 1
[08:24:51.845] getGlobalsAndPackagesXApply() ...
[08:24:51.845]  - future.globals: <name-value list> with names ‘list()’
[08:24:51.845]  - use_args: TRUE
[08:24:51.845] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:51.845] List of 2
[08:24:51.845]  $ ...          : list()
[08:24:51.845]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.845]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:51.845]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:51.845]  - attr(*, "where")=List of 2
[08:24:51.845]   ..$ ...          :<environment: 0x56540c5d4698> 
[08:24:51.845]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:51.845]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.845]  - attr(*, "resolved")= logi FALSE
[08:24:51.845]  - attr(*, "total_size")= num NA
[08:24:51.849] Packages to be attached in all futures: [n=0] 
[08:24:51.849] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.849] Number of futures (= number of chunks): 1
[08:24:51.849] Launching 1 futures (chunks) ...
[08:24:51.849] Chunk #1 of 1 ...
[08:24:51.850]  - seeds: <none>
[08:24:51.850]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.850] getGlobalsAndPackages() ...
[08:24:51.850] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.850] Resolving globals: FALSE
[08:24:51.850] Tweak future expression to call with '...' arguments ...
[08:24:51.850] {
[08:24:51.850]     do.call(function(...) {
[08:24:51.850]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.850]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.850]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.850]             on.exit(options(oopts), add = TRUE)
[08:24:51.850]         }
[08:24:51.850]         {
[08:24:51.850]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.850]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.850]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.850]             })
[08:24:51.850]         }
[08:24:51.850]     }, args = future.call.arguments)
[08:24:51.850] }
[08:24:51.850] Tweak future expression to call with '...' arguments ... DONE
[08:24:51.851] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.851] 
[08:24:51.851] getGlobalsAndPackages() ... DONE
[08:24:51.851] run() for ‘Future’ ...
[08:24:51.851] - state: ‘created’
[08:24:51.852] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:51.852] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:51.852]   - Field: ‘label’
[08:24:51.852]   - Field: ‘local’
[08:24:51.852]   - Field: ‘owner’
[08:24:51.852]   - Field: ‘envir’
[08:24:51.852]   - Field: ‘packages’
[08:24:51.853]   - Field: ‘gc’
[08:24:51.853]   - Field: ‘conditions’
[08:24:51.853]   - Field: ‘expr’
[08:24:51.853]   - Field: ‘uuid’
[08:24:51.853]   - Field: ‘seed’
[08:24:51.853]   - Field: ‘version’
[08:24:51.853]   - Field: ‘result’
[08:24:51.853]   - Field: ‘asynchronous’
[08:24:51.853]   - Field: ‘calls’
[08:24:51.853]   - Field: ‘globals’
[08:24:51.853]   - Field: ‘stdout’
[08:24:51.854]   - Field: ‘earlySignal’
[08:24:51.854]   - Field: ‘lazy’
[08:24:51.854]   - Field: ‘state’
[08:24:51.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:51.854] - Launch lazy future ...
[08:24:51.854] Packages needed by the future expression (n = 0): <none>
[08:24:51.854] Packages needed by future strategies (n = 0): <none>
[08:24:51.855] {
[08:24:51.855]     {
[08:24:51.855]         {
[08:24:51.855]             ...future.startTime <- base::Sys.time()
[08:24:51.855]             {
[08:24:51.855]                 {
[08:24:51.855]                   {
[08:24:51.855]                     base::local({
[08:24:51.855]                       has_future <- base::requireNamespace("future", 
[08:24:51.855]                         quietly = TRUE)
[08:24:51.855]                       if (has_future) {
[08:24:51.855]                         ns <- base::getNamespace("future")
[08:24:51.855]                         version <- ns[[".package"]][["version"]]
[08:24:51.855]                         if (is.null(version)) 
[08:24:51.855]                           version <- utils::packageVersion("future")
[08:24:51.855]                       }
[08:24:51.855]                       else {
[08:24:51.855]                         version <- NULL
[08:24:51.855]                       }
[08:24:51.855]                       if (!has_future || version < "1.8.0") {
[08:24:51.855]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:51.855]                           "", base::R.version$version.string), 
[08:24:51.855]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:51.855]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:51.855]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:51.855]                             "release", "version")], collapse = " "), 
[08:24:51.855]                           hostname = base::Sys.info()[["nodename"]])
[08:24:51.855]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:51.855]                           info)
[08:24:51.855]                         info <- base::paste(info, collapse = "; ")
[08:24:51.855]                         if (!has_future) {
[08:24:51.855]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:51.855]                             info)
[08:24:51.855]                         }
[08:24:51.855]                         else {
[08:24:51.855]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:51.855]                             info, version)
[08:24:51.855]                         }
[08:24:51.855]                         base::stop(msg)
[08:24:51.855]                       }
[08:24:51.855]                     })
[08:24:51.855]                   }
[08:24:51.855]                   ...future.strategy.old <- future::plan("list")
[08:24:51.855]                   options(future.plan = NULL)
[08:24:51.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:51.855]                 }
[08:24:51.855]                 ...future.workdir <- getwd()
[08:24:51.855]             }
[08:24:51.855]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:51.855]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:51.855]         }
[08:24:51.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:51.855]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:51.855]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:51.855]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:51.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:51.855]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:51.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:51.855]             base::names(...future.oldOptions))
[08:24:51.855]     }
[08:24:51.855]     if (FALSE) {
[08:24:51.855]     }
[08:24:51.855]     else {
[08:24:51.855]         if (TRUE) {
[08:24:51.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:51.855]                 open = "w")
[08:24:51.855]         }
[08:24:51.855]         else {
[08:24:51.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:51.855]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:51.855]         }
[08:24:51.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:51.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:51.855]             base::sink(type = "output", split = FALSE)
[08:24:51.855]             base::close(...future.stdout)
[08:24:51.855]         }, add = TRUE)
[08:24:51.855]     }
[08:24:51.855]     ...future.frame <- base::sys.nframe()
[08:24:51.855]     ...future.conditions <- base::list()
[08:24:51.855]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:51.855]     if (FALSE) {
[08:24:51.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:51.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:51.855]     }
[08:24:51.855]     ...future.result <- base::tryCatch({
[08:24:51.855]         base::withCallingHandlers({
[08:24:51.855]             ...future.value <- base::withVisible(base::local({
[08:24:51.855]                 do.call(function(...) {
[08:24:51.855]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.855]                   if (!identical(...future.globals.maxSize.org, 
[08:24:51.855]                     ...future.globals.maxSize)) {
[08:24:51.855]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.855]                     on.exit(options(oopts), add = TRUE)
[08:24:51.855]                   }
[08:24:51.855]                   {
[08:24:51.855]                     lapply(seq_along(...future.elements_ii), 
[08:24:51.855]                       FUN = function(jj) {
[08:24:51.855]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.855]                         ...future.FUN(...future.X_jj, ...)
[08:24:51.855]                       })
[08:24:51.855]                   }
[08:24:51.855]                 }, args = future.call.arguments)
[08:24:51.855]             }))
[08:24:51.855]             future::FutureResult(value = ...future.value$value, 
[08:24:51.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.855]                   ...future.rng), globalenv = if (FALSE) 
[08:24:51.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:51.855]                     ...future.globalenv.names))
[08:24:51.855]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:51.855]         }, condition = base::local({
[08:24:51.855]             c <- base::c
[08:24:51.855]             inherits <- base::inherits
[08:24:51.855]             invokeRestart <- base::invokeRestart
[08:24:51.855]             length <- base::length
[08:24:51.855]             list <- base::list
[08:24:51.855]             seq.int <- base::seq.int
[08:24:51.855]             signalCondition <- base::signalCondition
[08:24:51.855]             sys.calls <- base::sys.calls
[08:24:51.855]             `[[` <- base::`[[`
[08:24:51.855]             `+` <- base::`+`
[08:24:51.855]             `<<-` <- base::`<<-`
[08:24:51.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:51.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:51.855]                   3L)]
[08:24:51.855]             }
[08:24:51.855]             function(cond) {
[08:24:51.855]                 is_error <- inherits(cond, "error")
[08:24:51.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:51.855]                   NULL)
[08:24:51.855]                 if (is_error) {
[08:24:51.855]                   sessionInformation <- function() {
[08:24:51.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:51.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:51.855]                       search = base::search(), system = base::Sys.info())
[08:24:51.855]                   }
[08:24:51.855]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:51.855]                     cond$call), session = sessionInformation(), 
[08:24:51.855]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:51.855]                   signalCondition(cond)
[08:24:51.855]                 }
[08:24:51.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:51.855]                 "immediateCondition"))) {
[08:24:51.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:51.855]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:51.855]                   if (TRUE && !signal) {
[08:24:51.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.855]                     {
[08:24:51.855]                       inherits <- base::inherits
[08:24:51.855]                       invokeRestart <- base::invokeRestart
[08:24:51.855]                       is.null <- base::is.null
[08:24:51.855]                       muffled <- FALSE
[08:24:51.855]                       if (inherits(cond, "message")) {
[08:24:51.855]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.855]                         if (muffled) 
[08:24:51.855]                           invokeRestart("muffleMessage")
[08:24:51.855]                       }
[08:24:51.855]                       else if (inherits(cond, "warning")) {
[08:24:51.855]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.855]                         if (muffled) 
[08:24:51.855]                           invokeRestart("muffleWarning")
[08:24:51.855]                       }
[08:24:51.855]                       else if (inherits(cond, "condition")) {
[08:24:51.855]                         if (!is.null(pattern)) {
[08:24:51.855]                           computeRestarts <- base::computeRestarts
[08:24:51.855]                           grepl <- base::grepl
[08:24:51.855]                           restarts <- computeRestarts(cond)
[08:24:51.855]                           for (restart in restarts) {
[08:24:51.855]                             name <- restart$name
[08:24:51.855]                             if (is.null(name)) 
[08:24:51.855]                               next
[08:24:51.855]                             if (!grepl(pattern, name)) 
[08:24:51.855]                               next
[08:24:51.855]                             invokeRestart(restart)
[08:24:51.855]                             muffled <- TRUE
[08:24:51.855]                             break
[08:24:51.855]                           }
[08:24:51.855]                         }
[08:24:51.855]                       }
[08:24:51.855]                       invisible(muffled)
[08:24:51.855]                     }
[08:24:51.855]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.855]                   }
[08:24:51.855]                 }
[08:24:51.855]                 else {
[08:24:51.855]                   if (TRUE) {
[08:24:51.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.855]                     {
[08:24:51.855]                       inherits <- base::inherits
[08:24:51.855]                       invokeRestart <- base::invokeRestart
[08:24:51.855]                       is.null <- base::is.null
[08:24:51.855]                       muffled <- FALSE
[08:24:51.855]                       if (inherits(cond, "message")) {
[08:24:51.855]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.855]                         if (muffled) 
[08:24:51.855]                           invokeRestart("muffleMessage")
[08:24:51.855]                       }
[08:24:51.855]                       else if (inherits(cond, "warning")) {
[08:24:51.855]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.855]                         if (muffled) 
[08:24:51.855]                           invokeRestart("muffleWarning")
[08:24:51.855]                       }
[08:24:51.855]                       else if (inherits(cond, "condition")) {
[08:24:51.855]                         if (!is.null(pattern)) {
[08:24:51.855]                           computeRestarts <- base::computeRestarts
[08:24:51.855]                           grepl <- base::grepl
[08:24:51.855]                           restarts <- computeRestarts(cond)
[08:24:51.855]                           for (restart in restarts) {
[08:24:51.855]                             name <- restart$name
[08:24:51.855]                             if (is.null(name)) 
[08:24:51.855]                               next
[08:24:51.855]                             if (!grepl(pattern, name)) 
[08:24:51.855]                               next
[08:24:51.855]                             invokeRestart(restart)
[08:24:51.855]                             muffled <- TRUE
[08:24:51.855]                             break
[08:24:51.855]                           }
[08:24:51.855]                         }
[08:24:51.855]                       }
[08:24:51.855]                       invisible(muffled)
[08:24:51.855]                     }
[08:24:51.855]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.855]                   }
[08:24:51.855]                 }
[08:24:51.855]             }
[08:24:51.855]         }))
[08:24:51.855]     }, error = function(ex) {
[08:24:51.855]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:51.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.855]                 ...future.rng), started = ...future.startTime, 
[08:24:51.855]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:51.855]             version = "1.8"), class = "FutureResult")
[08:24:51.855]     }, finally = {
[08:24:51.855]         if (!identical(...future.workdir, getwd())) 
[08:24:51.855]             setwd(...future.workdir)
[08:24:51.855]         {
[08:24:51.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:51.855]                 ...future.oldOptions$nwarnings <- NULL
[08:24:51.855]             }
[08:24:51.855]             base::options(...future.oldOptions)
[08:24:51.855]             if (.Platform$OS.type == "windows") {
[08:24:51.855]                 old_names <- names(...future.oldEnvVars)
[08:24:51.855]                 envs <- base::Sys.getenv()
[08:24:51.855]                 names <- names(envs)
[08:24:51.855]                 common <- intersect(names, old_names)
[08:24:51.855]                 added <- setdiff(names, old_names)
[08:24:51.855]                 removed <- setdiff(old_names, names)
[08:24:51.855]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:51.855]                   envs[common]]
[08:24:51.855]                 NAMES <- toupper(changed)
[08:24:51.855]                 args <- list()
[08:24:51.855]                 for (kk in seq_along(NAMES)) {
[08:24:51.855]                   name <- changed[[kk]]
[08:24:51.855]                   NAME <- NAMES[[kk]]
[08:24:51.855]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.855]                     next
[08:24:51.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.855]                 }
[08:24:51.855]                 NAMES <- toupper(added)
[08:24:51.855]                 for (kk in seq_along(NAMES)) {
[08:24:51.855]                   name <- added[[kk]]
[08:24:51.855]                   NAME <- NAMES[[kk]]
[08:24:51.855]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.855]                     next
[08:24:51.855]                   args[[name]] <- ""
[08:24:51.855]                 }
[08:24:51.855]                 NAMES <- toupper(removed)
[08:24:51.855]                 for (kk in seq_along(NAMES)) {
[08:24:51.855]                   name <- removed[[kk]]
[08:24:51.855]                   NAME <- NAMES[[kk]]
[08:24:51.855]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.855]                     next
[08:24:51.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.855]                 }
[08:24:51.855]                 if (length(args) > 0) 
[08:24:51.855]                   base::do.call(base::Sys.setenv, args = args)
[08:24:51.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:51.855]             }
[08:24:51.855]             else {
[08:24:51.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:51.855]             }
[08:24:51.855]             {
[08:24:51.855]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:51.855]                   0L) {
[08:24:51.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:51.855]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:51.855]                   base::options(opts)
[08:24:51.855]                 }
[08:24:51.855]                 {
[08:24:51.855]                   {
[08:24:51.855]                     NULL
[08:24:51.855]                     RNGkind("Mersenne-Twister")
[08:24:51.855]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:51.855]                       inherits = FALSE)
[08:24:51.855]                   }
[08:24:51.855]                   options(future.plan = NULL)
[08:24:51.855]                   if (is.na(NA_character_)) 
[08:24:51.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:51.855]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:51.855]                     .init = FALSE)
[08:24:51.855]                 }
[08:24:51.855]             }
[08:24:51.855]         }
[08:24:51.855]     })
[08:24:51.855]     if (TRUE) {
[08:24:51.855]         base::sink(type = "output", split = FALSE)
[08:24:51.855]         if (TRUE) {
[08:24:51.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:51.855]         }
[08:24:51.855]         else {
[08:24:51.855]             ...future.result["stdout"] <- base::list(NULL)
[08:24:51.855]         }
[08:24:51.855]         base::close(...future.stdout)
[08:24:51.855]         ...future.stdout <- NULL
[08:24:51.855]     }
[08:24:51.855]     ...future.result$conditions <- ...future.conditions
[08:24:51.855]     ...future.result$finished <- base::Sys.time()
[08:24:51.855]     ...future.result
[08:24:51.855] }
[08:24:51.856] assign_globals() ...
[08:24:51.857] List of 5
[08:24:51.857]  $ future.call.arguments    : list()
[08:24:51.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.857]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:51.857]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:51.857]  $ ...future.elements_ii    :List of 2
[08:24:51.857]   ..$ : num [1:4] 1 3 1 7
[08:24:51.857]   ..$ : num [1:4] 2 4 6 8
[08:24:51.857]  $ ...future.seeds_ii       : NULL
[08:24:51.857]  $ ...future.globals.maxSize: num Inf
[08:24:51.857]  - attr(*, "resolved")= logi FALSE
[08:24:51.857]  - attr(*, "total_size")= num NA
[08:24:51.857]  - attr(*, "where")=List of 5
[08:24:51.857]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:51.857]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:51.857]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:51.857]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:51.857]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:51.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.857]  - attr(*, "already-done")= logi TRUE
[08:24:51.862] - copied ‘future.call.arguments’ to environment
[08:24:51.862] - copied ‘...future.FUN’ to environment
[08:24:51.862] - copied ‘...future.elements_ii’ to environment
[08:24:51.862] - copied ‘...future.seeds_ii’ to environment
[08:24:51.862] - copied ‘...future.globals.maxSize’ to environment
[08:24:51.862] assign_globals() ... done
[08:24:51.862] plan(): Setting new future strategy stack:
[08:24:51.862] List of future strategies:
[08:24:51.862] 1. sequential:
[08:24:51.862]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.862]    - tweaked: FALSE
[08:24:51.862]    - call: NULL
[08:24:51.863] plan(): nbrOfWorkers() = 1
[08:24:51.864] plan(): Setting new future strategy stack:
[08:24:51.864] List of future strategies:
[08:24:51.864] 1. sequential:
[08:24:51.864]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.864]    - tweaked: FALSE
[08:24:51.864]    - call: plan(strategy)
[08:24:51.865] plan(): nbrOfWorkers() = 1
[08:24:51.865] SequentialFuture started (and completed)
[08:24:51.865] - Launch lazy future ... done
[08:24:51.865] run() for ‘SequentialFuture’ ... done
[08:24:51.865] Created future:
[08:24:51.865] SequentialFuture:
[08:24:51.865] Label: ‘future_apply-1’
[08:24:51.865] Expression:
[08:24:51.865] {
[08:24:51.865]     do.call(function(...) {
[08:24:51.865]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.865]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.865]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.865]             on.exit(options(oopts), add = TRUE)
[08:24:51.865]         }
[08:24:51.865]         {
[08:24:51.865]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.865]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.865]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.865]             })
[08:24:51.865]         }
[08:24:51.865]     }, args = future.call.arguments)
[08:24:51.865] }
[08:24:51.865] Lazy evaluation: FALSE
[08:24:51.865] Asynchronous evaluation: FALSE
[08:24:51.865] Local evaluation: TRUE
[08:24:51.865] Environment: R_GlobalEnv
[08:24:51.865] Capture standard output: TRUE
[08:24:51.865] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:51.865] Globals: 5 objects totaling 31.56 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 111 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:51.865] Packages: <none>
[08:24:51.865] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:51.865] Resolved: TRUE
[08:24:51.865] Value: 429 bytes of class ‘list’
[08:24:51.865] Early signaling: FALSE
[08:24:51.865] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:51.865] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.866] Chunk #1 of 1 ... DONE
[08:24:51.866] Launching 1 futures (chunks) ... DONE
[08:24:51.866] Resolving 1 futures (chunks) ...
[08:24:51.867] resolve() on list ...
[08:24:51.867]  recursive: 0
[08:24:51.867]  length: 1
[08:24:51.867] 
[08:24:51.867] resolved() for ‘SequentialFuture’ ...
[08:24:51.867] - state: ‘finished’
[08:24:51.867] - run: TRUE
[08:24:51.867] - result: ‘FutureResult’
[08:24:51.867] resolved() for ‘SequentialFuture’ ... done
[08:24:51.867] Future #1
[08:24:51.868] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:51.868] - nx: 1
[08:24:51.868] - relay: TRUE
[08:24:51.870] - stdout: TRUE
[08:24:51.870] - signal: TRUE
[08:24:51.870] - resignal: FALSE
[08:24:51.870] - force: TRUE
[08:24:51.870] - relayed: [n=1] FALSE
[08:24:51.870] - queued futures: [n=1] FALSE
[08:24:51.870]  - until=1
[08:24:51.870]  - relaying element #1
[08:24:51.870] - relayed: [n=1] TRUE
[08:24:51.870] - queued futures: [n=1] TRUE
[08:24:51.870] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:51.871]  length: 0 (resolved future 1)
[08:24:51.871] Relaying remaining futures
[08:24:51.871] signalConditionsASAP(NULL, pos=0) ...
[08:24:51.871] - nx: 1
[08:24:51.871] - relay: TRUE
[08:24:51.871] - stdout: TRUE
[08:24:51.871] - signal: TRUE
[08:24:51.871] - resignal: FALSE
[08:24:51.871] - force: TRUE
[08:24:51.871] - relayed: [n=1] TRUE
[08:24:51.871] - queued futures: [n=1] TRUE
 - flush all
[08:24:51.872] - relayed: [n=1] TRUE
[08:24:51.872] - queued futures: [n=1] TRUE
[08:24:51.872] signalConditionsASAP(NULL, pos=0) ... done
[08:24:51.872] resolve() on list ... DONE
[08:24:51.872]  - Number of value chunks collected: 1
[08:24:51.872] Resolving 1 futures (chunks) ... DONE
[08:24:51.872] Reducing values from 1 chunks ...
[08:24:51.872]  - Number of values collected after concatenation: 2
[08:24:51.872]  - Number of values expected: 2
[08:24:51.872] Reducing values from 1 chunks ... DONE
[08:24:51.873] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[08:24:51.874] getGlobalsAndPackagesXApply() ...
[08:24:51.875]  - future.globals: TRUE
[08:24:51.875] getGlobalsAndPackages() ...
[08:24:51.875] Searching for globals...
[08:24:51.876] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:51.876] Searching for globals ... DONE
[08:24:51.876] Resolving globals: FALSE
[08:24:51.876] The total size of the 1 globals is 311 bytes (311 bytes)
[08:24:51.877] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[08:24:51.877] - globals: [1] ‘FUN’
[08:24:51.877] - packages: [1] ‘stats’
[08:24:51.877] getGlobalsAndPackages() ... DONE
[08:24:51.877]  - globals found/used: [n=1] ‘FUN’
[08:24:51.877]  - needed namespaces: [n=1] ‘stats’
[08:24:51.877] Finding globals ... DONE
[08:24:51.878]  - use_args: TRUE
[08:24:51.878]  - Getting '...' globals ...
[08:24:51.878] resolve() on list ...
[08:24:51.878]  recursive: 0
[08:24:51.878]  length: 1
[08:24:51.878]  elements: ‘...’
[08:24:51.878]  length: 0 (resolved future 1)
[08:24:51.878] resolve() on list ... DONE
[08:24:51.878]    - '...' content: [n=0] 
[08:24:51.879] List of 1
[08:24:51.879]  $ ...: list()
[08:24:51.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.879]  - attr(*, "where")=List of 1
[08:24:51.879]   ..$ ...:<environment: 0x56540bd25cc8> 
[08:24:51.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.879]  - attr(*, "resolved")= logi TRUE
[08:24:51.879]  - attr(*, "total_size")= num NA
[08:24:51.881]  - Getting '...' globals ... DONE
[08:24:51.881] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:51.881] List of 2
[08:24:51.881]  $ ...future.FUN:function (x, ...)  
[08:24:51.881]  $ ...          : list()
[08:24:51.881]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.881]  - attr(*, "where")=List of 2
[08:24:51.881]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:51.881]   ..$ ...          :<environment: 0x56540bd25cc8> 
[08:24:51.881]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.881]  - attr(*, "resolved")= logi FALSE
[08:24:51.881]  - attr(*, "total_size")= num 2586
[08:24:51.884] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:51.884] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.884] future_lapply() ...
[08:24:51.885] Number of chunks: 1
[08:24:51.885] getGlobalsAndPackagesXApply() ...
[08:24:51.885]  - future.globals: <name-value list> with names ‘list()’
[08:24:51.885]  - use_args: TRUE
[08:24:51.885] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:51.885] List of 2
[08:24:51.885]  $ ...          : list()
[08:24:51.885]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.885]  $ ...future.FUN:function (x, ...)  
[08:24:51.885]  - attr(*, "where")=List of 2
[08:24:51.885]   ..$ ...          :<environment: 0x56540bd25cc8> 
[08:24:51.885]   ..$ ...future.FUN:<environment: namespace:stats> 
[08:24:51.885]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.885]  - attr(*, "resolved")= logi FALSE
[08:24:51.885]  - attr(*, "total_size")= num NA
[08:24:51.888] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:51.888] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.888] Number of futures (= number of chunks): 1
[08:24:51.888] Launching 1 futures (chunks) ...
[08:24:51.888] Chunk #1 of 1 ...
[08:24:51.888]  - seeds: <none>
[08:24:51.889]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.889] getGlobalsAndPackages() ...
[08:24:51.889] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.889] Resolving globals: FALSE
[08:24:51.889] Tweak future expression to call with '...' arguments ...
[08:24:51.889] {
[08:24:51.889]     do.call(function(...) {
[08:24:51.889]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.889]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.889]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.889]             on.exit(options(oopts), add = TRUE)
[08:24:51.889]         }
[08:24:51.889]         {
[08:24:51.889]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.889]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.889]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.889]             })
[08:24:51.889]         }
[08:24:51.889]     }, args = future.call.arguments)
[08:24:51.889] }
[08:24:51.889] Tweak future expression to call with '...' arguments ... DONE
[08:24:51.890] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.890] - packages: [1] ‘stats’
[08:24:51.890] getGlobalsAndPackages() ... DONE
[08:24:51.890] run() for ‘Future’ ...
[08:24:51.890] - state: ‘created’
[08:24:51.890] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:51.891] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.891] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:51.891]   - Field: ‘label’
[08:24:51.891]   - Field: ‘local’
[08:24:51.891]   - Field: ‘owner’
[08:24:51.891]   - Field: ‘envir’
[08:24:51.891]   - Field: ‘packages’
[08:24:51.891]   - Field: ‘gc’
[08:24:51.892]   - Field: ‘conditions’
[08:24:51.892]   - Field: ‘expr’
[08:24:51.892]   - Field: ‘uuid’
[08:24:51.892]   - Field: ‘seed’
[08:24:51.892]   - Field: ‘version’
[08:24:51.892]   - Field: ‘result’
[08:24:51.894]   - Field: ‘asynchronous’
[08:24:51.894]   - Field: ‘calls’
[08:24:51.894]   - Field: ‘globals’
[08:24:51.894]   - Field: ‘stdout’
[08:24:51.894]   - Field: ‘earlySignal’
[08:24:51.894]   - Field: ‘lazy’
[08:24:51.894]   - Field: ‘state’
[08:24:51.894] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:51.894] - Launch lazy future ...
[08:24:51.895] Packages needed by the future expression (n = 1): ‘stats’
[08:24:51.895] Packages needed by future strategies (n = 0): <none>
[08:24:51.895] {
[08:24:51.895]     {
[08:24:51.895]         {
[08:24:51.895]             ...future.startTime <- base::Sys.time()
[08:24:51.895]             {
[08:24:51.895]                 {
[08:24:51.895]                   {
[08:24:51.895]                     {
[08:24:51.895]                       base::local({
[08:24:51.895]                         has_future <- base::requireNamespace("future", 
[08:24:51.895]                           quietly = TRUE)
[08:24:51.895]                         if (has_future) {
[08:24:51.895]                           ns <- base::getNamespace("future")
[08:24:51.895]                           version <- ns[[".package"]][["version"]]
[08:24:51.895]                           if (is.null(version)) 
[08:24:51.895]                             version <- utils::packageVersion("future")
[08:24:51.895]                         }
[08:24:51.895]                         else {
[08:24:51.895]                           version <- NULL
[08:24:51.895]                         }
[08:24:51.895]                         if (!has_future || version < "1.8.0") {
[08:24:51.895]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:51.895]                             "", base::R.version$version.string), 
[08:24:51.895]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:51.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:51.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:51.895]                               "release", "version")], collapse = " "), 
[08:24:51.895]                             hostname = base::Sys.info()[["nodename"]])
[08:24:51.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:51.895]                             info)
[08:24:51.895]                           info <- base::paste(info, collapse = "; ")
[08:24:51.895]                           if (!has_future) {
[08:24:51.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:51.895]                               info)
[08:24:51.895]                           }
[08:24:51.895]                           else {
[08:24:51.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:51.895]                               info, version)
[08:24:51.895]                           }
[08:24:51.895]                           base::stop(msg)
[08:24:51.895]                         }
[08:24:51.895]                       })
[08:24:51.895]                     }
[08:24:51.895]                     base::local({
[08:24:51.895]                       for (pkg in "stats") {
[08:24:51.895]                         base::loadNamespace(pkg)
[08:24:51.895]                         base::library(pkg, character.only = TRUE)
[08:24:51.895]                       }
[08:24:51.895]                     })
[08:24:51.895]                   }
[08:24:51.895]                   ...future.strategy.old <- future::plan("list")
[08:24:51.895]                   options(future.plan = NULL)
[08:24:51.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:51.895]                 }
[08:24:51.895]                 ...future.workdir <- getwd()
[08:24:51.895]             }
[08:24:51.895]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:51.895]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:51.895]         }
[08:24:51.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:51.895]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:51.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:51.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:51.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:51.895]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:51.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:51.895]             base::names(...future.oldOptions))
[08:24:51.895]     }
[08:24:51.895]     if (FALSE) {
[08:24:51.895]     }
[08:24:51.895]     else {
[08:24:51.895]         if (TRUE) {
[08:24:51.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:51.895]                 open = "w")
[08:24:51.895]         }
[08:24:51.895]         else {
[08:24:51.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:51.895]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:51.895]         }
[08:24:51.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:51.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:51.895]             base::sink(type = "output", split = FALSE)
[08:24:51.895]             base::close(...future.stdout)
[08:24:51.895]         }, add = TRUE)
[08:24:51.895]     }
[08:24:51.895]     ...future.frame <- base::sys.nframe()
[08:24:51.895]     ...future.conditions <- base::list()
[08:24:51.895]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:51.895]     if (FALSE) {
[08:24:51.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:51.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:51.895]     }
[08:24:51.895]     ...future.result <- base::tryCatch({
[08:24:51.895]         base::withCallingHandlers({
[08:24:51.895]             ...future.value <- base::withVisible(base::local({
[08:24:51.895]                 do.call(function(...) {
[08:24:51.895]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.895]                   if (!identical(...future.globals.maxSize.org, 
[08:24:51.895]                     ...future.globals.maxSize)) {
[08:24:51.895]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.895]                     on.exit(options(oopts), add = TRUE)
[08:24:51.895]                   }
[08:24:51.895]                   {
[08:24:51.895]                     lapply(seq_along(...future.elements_ii), 
[08:24:51.895]                       FUN = function(jj) {
[08:24:51.895]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.895]                         ...future.FUN(...future.X_jj, ...)
[08:24:51.895]                       })
[08:24:51.895]                   }
[08:24:51.895]                 }, args = future.call.arguments)
[08:24:51.895]             }))
[08:24:51.895]             future::FutureResult(value = ...future.value$value, 
[08:24:51.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.895]                   ...future.rng), globalenv = if (FALSE) 
[08:24:51.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:51.895]                     ...future.globalenv.names))
[08:24:51.895]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:51.895]         }, condition = base::local({
[08:24:51.895]             c <- base::c
[08:24:51.895]             inherits <- base::inherits
[08:24:51.895]             invokeRestart <- base::invokeRestart
[08:24:51.895]             length <- base::length
[08:24:51.895]             list <- base::list
[08:24:51.895]             seq.int <- base::seq.int
[08:24:51.895]             signalCondition <- base::signalCondition
[08:24:51.895]             sys.calls <- base::sys.calls
[08:24:51.895]             `[[` <- base::`[[`
[08:24:51.895]             `+` <- base::`+`
[08:24:51.895]             `<<-` <- base::`<<-`
[08:24:51.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:51.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:51.895]                   3L)]
[08:24:51.895]             }
[08:24:51.895]             function(cond) {
[08:24:51.895]                 is_error <- inherits(cond, "error")
[08:24:51.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:51.895]                   NULL)
[08:24:51.895]                 if (is_error) {
[08:24:51.895]                   sessionInformation <- function() {
[08:24:51.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:51.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:51.895]                       search = base::search(), system = base::Sys.info())
[08:24:51.895]                   }
[08:24:51.895]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:51.895]                     cond$call), session = sessionInformation(), 
[08:24:51.895]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:51.895]                   signalCondition(cond)
[08:24:51.895]                 }
[08:24:51.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:51.895]                 "immediateCondition"))) {
[08:24:51.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:51.895]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:51.895]                   if (TRUE && !signal) {
[08:24:51.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.895]                     {
[08:24:51.895]                       inherits <- base::inherits
[08:24:51.895]                       invokeRestart <- base::invokeRestart
[08:24:51.895]                       is.null <- base::is.null
[08:24:51.895]                       muffled <- FALSE
[08:24:51.895]                       if (inherits(cond, "message")) {
[08:24:51.895]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.895]                         if (muffled) 
[08:24:51.895]                           invokeRestart("muffleMessage")
[08:24:51.895]                       }
[08:24:51.895]                       else if (inherits(cond, "warning")) {
[08:24:51.895]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.895]                         if (muffled) 
[08:24:51.895]                           invokeRestart("muffleWarning")
[08:24:51.895]                       }
[08:24:51.895]                       else if (inherits(cond, "condition")) {
[08:24:51.895]                         if (!is.null(pattern)) {
[08:24:51.895]                           computeRestarts <- base::computeRestarts
[08:24:51.895]                           grepl <- base::grepl
[08:24:51.895]                           restarts <- computeRestarts(cond)
[08:24:51.895]                           for (restart in restarts) {
[08:24:51.895]                             name <- restart$name
[08:24:51.895]                             if (is.null(name)) 
[08:24:51.895]                               next
[08:24:51.895]                             if (!grepl(pattern, name)) 
[08:24:51.895]                               next
[08:24:51.895]                             invokeRestart(restart)
[08:24:51.895]                             muffled <- TRUE
[08:24:51.895]                             break
[08:24:51.895]                           }
[08:24:51.895]                         }
[08:24:51.895]                       }
[08:24:51.895]                       invisible(muffled)
[08:24:51.895]                     }
[08:24:51.895]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.895]                   }
[08:24:51.895]                 }
[08:24:51.895]                 else {
[08:24:51.895]                   if (TRUE) {
[08:24:51.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.895]                     {
[08:24:51.895]                       inherits <- base::inherits
[08:24:51.895]                       invokeRestart <- base::invokeRestart
[08:24:51.895]                       is.null <- base::is.null
[08:24:51.895]                       muffled <- FALSE
[08:24:51.895]                       if (inherits(cond, "message")) {
[08:24:51.895]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.895]                         if (muffled) 
[08:24:51.895]                           invokeRestart("muffleMessage")
[08:24:51.895]                       }
[08:24:51.895]                       else if (inherits(cond, "warning")) {
[08:24:51.895]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.895]                         if (muffled) 
[08:24:51.895]                           invokeRestart("muffleWarning")
[08:24:51.895]                       }
[08:24:51.895]                       else if (inherits(cond, "condition")) {
[08:24:51.895]                         if (!is.null(pattern)) {
[08:24:51.895]                           computeRestarts <- base::computeRestarts
[08:24:51.895]                           grepl <- base::grepl
[08:24:51.895]                           restarts <- computeRestarts(cond)
[08:24:51.895]                           for (restart in restarts) {
[08:24:51.895]                             name <- restart$name
[08:24:51.895]                             if (is.null(name)) 
[08:24:51.895]                               next
[08:24:51.895]                             if (!grepl(pattern, name)) 
[08:24:51.895]                               next
[08:24:51.895]                             invokeRestart(restart)
[08:24:51.895]                             muffled <- TRUE
[08:24:51.895]                             break
[08:24:51.895]                           }
[08:24:51.895]                         }
[08:24:51.895]                       }
[08:24:51.895]                       invisible(muffled)
[08:24:51.895]                     }
[08:24:51.895]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.895]                   }
[08:24:51.895]                 }
[08:24:51.895]             }
[08:24:51.895]         }))
[08:24:51.895]     }, error = function(ex) {
[08:24:51.895]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:51.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.895]                 ...future.rng), started = ...future.startTime, 
[08:24:51.895]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:51.895]             version = "1.8"), class = "FutureResult")
[08:24:51.895]     }, finally = {
[08:24:51.895]         if (!identical(...future.workdir, getwd())) 
[08:24:51.895]             setwd(...future.workdir)
[08:24:51.895]         {
[08:24:51.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:51.895]                 ...future.oldOptions$nwarnings <- NULL
[08:24:51.895]             }
[08:24:51.895]             base::options(...future.oldOptions)
[08:24:51.895]             if (.Platform$OS.type == "windows") {
[08:24:51.895]                 old_names <- names(...future.oldEnvVars)
[08:24:51.895]                 envs <- base::Sys.getenv()
[08:24:51.895]                 names <- names(envs)
[08:24:51.895]                 common <- intersect(names, old_names)
[08:24:51.895]                 added <- setdiff(names, old_names)
[08:24:51.895]                 removed <- setdiff(old_names, names)
[08:24:51.895]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:51.895]                   envs[common]]
[08:24:51.895]                 NAMES <- toupper(changed)
[08:24:51.895]                 args <- list()
[08:24:51.895]                 for (kk in seq_along(NAMES)) {
[08:24:51.895]                   name <- changed[[kk]]
[08:24:51.895]                   NAME <- NAMES[[kk]]
[08:24:51.895]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.895]                     next
[08:24:51.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.895]                 }
[08:24:51.895]                 NAMES <- toupper(added)
[08:24:51.895]                 for (kk in seq_along(NAMES)) {
[08:24:51.895]                   name <- added[[kk]]
[08:24:51.895]                   NAME <- NAMES[[kk]]
[08:24:51.895]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.895]                     next
[08:24:51.895]                   args[[name]] <- ""
[08:24:51.895]                 }
[08:24:51.895]                 NAMES <- toupper(removed)
[08:24:51.895]                 for (kk in seq_along(NAMES)) {
[08:24:51.895]                   name <- removed[[kk]]
[08:24:51.895]                   NAME <- NAMES[[kk]]
[08:24:51.895]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.895]                     next
[08:24:51.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.895]                 }
[08:24:51.895]                 if (length(args) > 0) 
[08:24:51.895]                   base::do.call(base::Sys.setenv, args = args)
[08:24:51.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:51.895]             }
[08:24:51.895]             else {
[08:24:51.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:51.895]             }
[08:24:51.895]             {
[08:24:51.895]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:51.895]                   0L) {
[08:24:51.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:51.895]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:51.895]                   base::options(opts)
[08:24:51.895]                 }
[08:24:51.895]                 {
[08:24:51.895]                   {
[08:24:51.895]                     NULL
[08:24:51.895]                     RNGkind("Mersenne-Twister")
[08:24:51.895]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:51.895]                       inherits = FALSE)
[08:24:51.895]                   }
[08:24:51.895]                   options(future.plan = NULL)
[08:24:51.895]                   if (is.na(NA_character_)) 
[08:24:51.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:51.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:51.895]                     .init = FALSE)
[08:24:51.895]                 }
[08:24:51.895]             }
[08:24:51.895]         }
[08:24:51.895]     })
[08:24:51.895]     if (TRUE) {
[08:24:51.895]         base::sink(type = "output", split = FALSE)
[08:24:51.895]         if (TRUE) {
[08:24:51.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:51.895]         }
[08:24:51.895]         else {
[08:24:51.895]             ...future.result["stdout"] <- base::list(NULL)
[08:24:51.895]         }
[08:24:51.895]         base::close(...future.stdout)
[08:24:51.895]         ...future.stdout <- NULL
[08:24:51.895]     }
[08:24:51.895]     ...future.result$conditions <- ...future.conditions
[08:24:51.895]     ...future.result$finished <- base::Sys.time()
[08:24:51.895]     ...future.result
[08:24:51.895] }
[08:24:51.897] assign_globals() ...
[08:24:51.897] List of 5
[08:24:51.897]  $ future.call.arguments    : list()
[08:24:51.897]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.897]  $ ...future.FUN            :function (x, ...)  
[08:24:51.897]  $ ...future.elements_ii    :List of 2
[08:24:51.897]   ..$ : num [1:4] 1 3 1 7
[08:24:51.897]   ..$ : num [1:4] 2 4 6 8
[08:24:51.897]  $ ...future.seeds_ii       : NULL
[08:24:51.897]  $ ...future.globals.maxSize: num Inf
[08:24:51.897]  - attr(*, "resolved")= logi FALSE
[08:24:51.897]  - attr(*, "total_size")= num NA
[08:24:51.897]  - attr(*, "where")=List of 5
[08:24:51.897]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:51.897]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:51.897]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:51.897]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:51.897]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:51.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.897]  - attr(*, "already-done")= logi TRUE
[08:24:51.902] - copied ‘future.call.arguments’ to environment
[08:24:51.902] - copied ‘...future.FUN’ to environment
[08:24:51.902] - copied ‘...future.elements_ii’ to environment
[08:24:51.902] - copied ‘...future.seeds_ii’ to environment
[08:24:51.903] - copied ‘...future.globals.maxSize’ to environment
[08:24:51.903] assign_globals() ... done
[08:24:51.903] plan(): Setting new future strategy stack:
[08:24:51.903] List of future strategies:
[08:24:51.903] 1. sequential:
[08:24:51.903]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.903]    - tweaked: FALSE
[08:24:51.903]    - call: NULL
[08:24:51.904] plan(): nbrOfWorkers() = 1
[08:24:51.905] plan(): Setting new future strategy stack:
[08:24:51.905] List of future strategies:
[08:24:51.905] 1. sequential:
[08:24:51.905]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.905]    - tweaked: FALSE
[08:24:51.905]    - call: plan(strategy)
[08:24:51.905] plan(): nbrOfWorkers() = 1
[08:24:51.905] SequentialFuture started (and completed)
[08:24:51.905] - Launch lazy future ... done
[08:24:51.906] run() for ‘SequentialFuture’ ... done
[08:24:51.906] Created future:
[08:24:51.906] SequentialFuture:
[08:24:51.906] Label: ‘future_apply-1’
[08:24:51.906] Expression:
[08:24:51.906] {
[08:24:51.906]     do.call(function(...) {
[08:24:51.906]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.906]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.906]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.906]             on.exit(options(oopts), add = TRUE)
[08:24:51.906]         }
[08:24:51.906]         {
[08:24:51.906]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.906]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.906]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.906]             })
[08:24:51.906]         }
[08:24:51.906]     }, args = future.call.arguments)
[08:24:51.906] }
[08:24:51.906] Lazy evaluation: FALSE
[08:24:51.906] Asynchronous evaluation: FALSE
[08:24:51.906] Local evaluation: TRUE
[08:24:51.906] Environment: R_GlobalEnv
[08:24:51.906] Capture standard output: TRUE
[08:24:51.906] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:51.906] Globals: 5 objects totaling 585 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 111 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:51.906] Packages: 1 packages (‘stats’)
[08:24:51.906] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:51.906] Resolved: TRUE
[08:24:51.906] Value: 290 bytes of class ‘list’
[08:24:51.906] Early signaling: FALSE
[08:24:51.906] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:51.906] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.907] Chunk #1 of 1 ... DONE
[08:24:51.907] Launching 1 futures (chunks) ... DONE
[08:24:51.907] Resolving 1 futures (chunks) ...
[08:24:51.907] resolve() on list ...
[08:24:51.907]  recursive: 0
[08:24:51.907]  length: 1
[08:24:51.907] 
[08:24:51.907] resolved() for ‘SequentialFuture’ ...
[08:24:51.907] - state: ‘finished’
[08:24:51.907] - run: TRUE
[08:24:51.907] - result: ‘FutureResult’
[08:24:51.908] resolved() for ‘SequentialFuture’ ... done
[08:24:51.908] Future #1
[08:24:51.908] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:51.908] - nx: 1
[08:24:51.908] - relay: TRUE
[08:24:51.908] - stdout: TRUE
[08:24:51.908] - signal: TRUE
[08:24:51.908] - resignal: FALSE
[08:24:51.908] - force: TRUE
[08:24:51.908] - relayed: [n=1] FALSE
[08:24:51.908] - queued futures: [n=1] FALSE
[08:24:51.909]  - until=1
[08:24:51.909]  - relaying element #1
[08:24:51.909] - relayed: [n=1] TRUE
[08:24:51.909] - queued futures: [n=1] TRUE
[08:24:51.909] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:51.909]  length: 0 (resolved future 1)
[08:24:51.909] Relaying remaining futures
[08:24:51.909] signalConditionsASAP(NULL, pos=0) ...
[08:24:51.909] - nx: 1
[08:24:51.909] - relay: TRUE
[08:24:51.909] - stdout: TRUE
[08:24:51.910] - signal: TRUE
[08:24:51.910] - resignal: FALSE
[08:24:51.910] - force: TRUE
[08:24:51.910] - relayed: [n=1] TRUE
[08:24:51.910] - queued futures: [n=1] TRUE
 - flush all
[08:24:51.910] - relayed: [n=1] TRUE
[08:24:51.910] - queued futures: [n=1] TRUE
[08:24:51.910] signalConditionsASAP(NULL, pos=0) ... done
[08:24:51.910] resolve() on list ... DONE
[08:24:51.910]  - Number of value chunks collected: 1
[08:24:51.910] Resolving 1 futures (chunks) ... DONE
[08:24:51.911] Reducing values from 1 chunks ...
[08:24:51.911]  - Number of values collected after concatenation: 2
[08:24:51.911]  - Number of values expected: 2
[08:24:51.911] Reducing values from 1 chunks ... DONE
[08:24:51.911] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[08:24:51.912] getGlobalsAndPackagesXApply() ...
[08:24:51.912]  - future.globals: TRUE
[08:24:51.912] getGlobalsAndPackages() ...
[08:24:51.912] Searching for globals...
[08:24:51.913] - globals found: [1] ‘FUN’
[08:24:51.913] Searching for globals ... DONE
[08:24:51.913] Resolving globals: FALSE
[08:24:51.913] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:51.914] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:51.914] - globals: [1] ‘FUN’
[08:24:51.914] 
[08:24:51.914] getGlobalsAndPackages() ... DONE
[08:24:51.914]  - globals found/used: [n=1] ‘FUN’
[08:24:51.914]  - needed namespaces: [n=0] 
[08:24:51.914] Finding globals ... DONE
[08:24:51.914]  - use_args: TRUE
[08:24:51.914]  - Getting '...' globals ...
[08:24:51.915] resolve() on list ...
[08:24:51.915]  recursive: 0
[08:24:51.915]  length: 1
[08:24:51.915]  elements: ‘...’
[08:24:51.915]  length: 0 (resolved future 1)
[08:24:51.915] resolve() on list ... DONE
[08:24:51.915]    - '...' content: [n=0] 
[08:24:51.915] List of 1
[08:24:51.915]  $ ...: list()
[08:24:51.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.915]  - attr(*, "where")=List of 1
[08:24:51.915]   ..$ ...:<environment: 0x56540e23a100> 
[08:24:51.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.915]  - attr(*, "resolved")= logi TRUE
[08:24:51.915]  - attr(*, "total_size")= num NA
[08:24:51.919]  - Getting '...' globals ... DONE
[08:24:51.919] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:51.920] List of 2
[08:24:51.920]  $ ...future.FUN:function (x)  
[08:24:51.920]  $ ...          : list()
[08:24:51.920]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.920]  - attr(*, "where")=List of 2
[08:24:51.920]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:51.920]   ..$ ...          :<environment: 0x56540e23a100> 
[08:24:51.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.920]  - attr(*, "resolved")= logi FALSE
[08:24:51.920]  - attr(*, "total_size")= num 2624
[08:24:51.922] Packages to be attached in all futures: [n=0] 
[08:24:51.922] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.923] future_lapply() ...
[08:24:51.923] Number of chunks: 1
[08:24:51.923] getGlobalsAndPackagesXApply() ...
[08:24:51.923]  - future.globals: <name-value list> with names ‘list()’
[08:24:51.923]  - use_args: TRUE
[08:24:51.923] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:51.924] List of 2
[08:24:51.924]  $ ...          : list()
[08:24:51.924]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.924]  $ ...future.FUN:function (x)  
[08:24:51.924]  - attr(*, "where")=List of 2
[08:24:51.924]   ..$ ...          :<environment: 0x56540e23a100> 
[08:24:51.924]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:51.924]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.924]  - attr(*, "resolved")= logi FALSE
[08:24:51.924]  - attr(*, "total_size")= num NA
[08:24:51.927] Packages to be attached in all futures: [n=0] 
[08:24:51.927] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.927] Number of futures (= number of chunks): 1
[08:24:51.927] Launching 1 futures (chunks) ...
[08:24:51.927] Chunk #1 of 1 ...
[08:24:51.928]  - seeds: <none>
[08:24:51.928]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.928] getGlobalsAndPackages() ...
[08:24:51.928] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.928] Resolving globals: FALSE
[08:24:51.928] Tweak future expression to call with '...' arguments ...
[08:24:51.928] {
[08:24:51.928]     do.call(function(...) {
[08:24:51.928]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.928]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.928]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.928]             on.exit(options(oopts), add = TRUE)
[08:24:51.928]         }
[08:24:51.928]         {
[08:24:51.928]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.928]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.928]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.928]             })
[08:24:51.928]         }
[08:24:51.928]     }, args = future.call.arguments)
[08:24:51.928] }
[08:24:51.928] Tweak future expression to call with '...' arguments ... DONE
[08:24:51.929] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.929] 
[08:24:51.929] getGlobalsAndPackages() ... DONE
[08:24:51.929] run() for ‘Future’ ...
[08:24:51.929] - state: ‘created’
[08:24:51.929] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:51.930] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.930] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:51.930]   - Field: ‘label’
[08:24:51.930]   - Field: ‘local’
[08:24:51.930]   - Field: ‘owner’
[08:24:51.930]   - Field: ‘envir’
[08:24:51.930]   - Field: ‘packages’
[08:24:51.930]   - Field: ‘gc’
[08:24:51.930]   - Field: ‘conditions’
[08:24:51.931]   - Field: ‘expr’
[08:24:51.931]   - Field: ‘uuid’
[08:24:51.931]   - Field: ‘seed’
[08:24:51.931]   - Field: ‘version’
[08:24:51.931]   - Field: ‘result’
[08:24:51.931]   - Field: ‘asynchronous’
[08:24:51.931]   - Field: ‘calls’
[08:24:51.931]   - Field: ‘globals’
[08:24:51.931]   - Field: ‘stdout’
[08:24:51.931]   - Field: ‘earlySignal’
[08:24:51.931]   - Field: ‘lazy’
[08:24:51.931]   - Field: ‘state’
[08:24:51.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:51.932] - Launch lazy future ...
[08:24:51.932] Packages needed by the future expression (n = 0): <none>
[08:24:51.932] Packages needed by future strategies (n = 0): <none>
[08:24:51.932] {
[08:24:51.932]     {
[08:24:51.932]         {
[08:24:51.932]             ...future.startTime <- base::Sys.time()
[08:24:51.932]             {
[08:24:51.932]                 {
[08:24:51.932]                   {
[08:24:51.932]                     base::local({
[08:24:51.932]                       has_future <- base::requireNamespace("future", 
[08:24:51.932]                         quietly = TRUE)
[08:24:51.932]                       if (has_future) {
[08:24:51.932]                         ns <- base::getNamespace("future")
[08:24:51.932]                         version <- ns[[".package"]][["version"]]
[08:24:51.932]                         if (is.null(version)) 
[08:24:51.932]                           version <- utils::packageVersion("future")
[08:24:51.932]                       }
[08:24:51.932]                       else {
[08:24:51.932]                         version <- NULL
[08:24:51.932]                       }
[08:24:51.932]                       if (!has_future || version < "1.8.0") {
[08:24:51.932]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:51.932]                           "", base::R.version$version.string), 
[08:24:51.932]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:51.932]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:51.932]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:51.932]                             "release", "version")], collapse = " "), 
[08:24:51.932]                           hostname = base::Sys.info()[["nodename"]])
[08:24:51.932]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:51.932]                           info)
[08:24:51.932]                         info <- base::paste(info, collapse = "; ")
[08:24:51.932]                         if (!has_future) {
[08:24:51.932]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:51.932]                             info)
[08:24:51.932]                         }
[08:24:51.932]                         else {
[08:24:51.932]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:51.932]                             info, version)
[08:24:51.932]                         }
[08:24:51.932]                         base::stop(msg)
[08:24:51.932]                       }
[08:24:51.932]                     })
[08:24:51.932]                   }
[08:24:51.932]                   ...future.strategy.old <- future::plan("list")
[08:24:51.932]                   options(future.plan = NULL)
[08:24:51.932]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.932]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:51.932]                 }
[08:24:51.932]                 ...future.workdir <- getwd()
[08:24:51.932]             }
[08:24:51.932]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:51.932]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:51.932]         }
[08:24:51.932]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:51.932]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:51.932]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:51.932]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:51.932]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:51.932]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:51.932]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:51.932]             base::names(...future.oldOptions))
[08:24:51.932]     }
[08:24:51.932]     if (FALSE) {
[08:24:51.932]     }
[08:24:51.932]     else {
[08:24:51.932]         if (TRUE) {
[08:24:51.932]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:51.932]                 open = "w")
[08:24:51.932]         }
[08:24:51.932]         else {
[08:24:51.932]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:51.932]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:51.932]         }
[08:24:51.932]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:51.932]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:51.932]             base::sink(type = "output", split = FALSE)
[08:24:51.932]             base::close(...future.stdout)
[08:24:51.932]         }, add = TRUE)
[08:24:51.932]     }
[08:24:51.932]     ...future.frame <- base::sys.nframe()
[08:24:51.932]     ...future.conditions <- base::list()
[08:24:51.932]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:51.932]     if (FALSE) {
[08:24:51.932]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:51.932]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:51.932]     }
[08:24:51.932]     ...future.result <- base::tryCatch({
[08:24:51.932]         base::withCallingHandlers({
[08:24:51.932]             ...future.value <- base::withVisible(base::local({
[08:24:51.932]                 do.call(function(...) {
[08:24:51.932]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.932]                   if (!identical(...future.globals.maxSize.org, 
[08:24:51.932]                     ...future.globals.maxSize)) {
[08:24:51.932]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.932]                     on.exit(options(oopts), add = TRUE)
[08:24:51.932]                   }
[08:24:51.932]                   {
[08:24:51.932]                     lapply(seq_along(...future.elements_ii), 
[08:24:51.932]                       FUN = function(jj) {
[08:24:51.932]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.932]                         ...future.FUN(...future.X_jj, ...)
[08:24:51.932]                       })
[08:24:51.932]                   }
[08:24:51.932]                 }, args = future.call.arguments)
[08:24:51.932]             }))
[08:24:51.932]             future::FutureResult(value = ...future.value$value, 
[08:24:51.932]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.932]                   ...future.rng), globalenv = if (FALSE) 
[08:24:51.932]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:51.932]                     ...future.globalenv.names))
[08:24:51.932]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:51.932]         }, condition = base::local({
[08:24:51.932]             c <- base::c
[08:24:51.932]             inherits <- base::inherits
[08:24:51.932]             invokeRestart <- base::invokeRestart
[08:24:51.932]             length <- base::length
[08:24:51.932]             list <- base::list
[08:24:51.932]             seq.int <- base::seq.int
[08:24:51.932]             signalCondition <- base::signalCondition
[08:24:51.932]             sys.calls <- base::sys.calls
[08:24:51.932]             `[[` <- base::`[[`
[08:24:51.932]             `+` <- base::`+`
[08:24:51.932]             `<<-` <- base::`<<-`
[08:24:51.932]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:51.932]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:51.932]                   3L)]
[08:24:51.932]             }
[08:24:51.932]             function(cond) {
[08:24:51.932]                 is_error <- inherits(cond, "error")
[08:24:51.932]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:51.932]                   NULL)
[08:24:51.932]                 if (is_error) {
[08:24:51.932]                   sessionInformation <- function() {
[08:24:51.932]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:51.932]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:51.932]                       search = base::search(), system = base::Sys.info())
[08:24:51.932]                   }
[08:24:51.932]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.932]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:51.932]                     cond$call), session = sessionInformation(), 
[08:24:51.932]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:51.932]                   signalCondition(cond)
[08:24:51.932]                 }
[08:24:51.932]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:51.932]                 "immediateCondition"))) {
[08:24:51.932]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:51.932]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.932]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:51.932]                   if (TRUE && !signal) {
[08:24:51.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.932]                     {
[08:24:51.932]                       inherits <- base::inherits
[08:24:51.932]                       invokeRestart <- base::invokeRestart
[08:24:51.932]                       is.null <- base::is.null
[08:24:51.932]                       muffled <- FALSE
[08:24:51.932]                       if (inherits(cond, "message")) {
[08:24:51.932]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.932]                         if (muffled) 
[08:24:51.932]                           invokeRestart("muffleMessage")
[08:24:51.932]                       }
[08:24:51.932]                       else if (inherits(cond, "warning")) {
[08:24:51.932]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.932]                         if (muffled) 
[08:24:51.932]                           invokeRestart("muffleWarning")
[08:24:51.932]                       }
[08:24:51.932]                       else if (inherits(cond, "condition")) {
[08:24:51.932]                         if (!is.null(pattern)) {
[08:24:51.932]                           computeRestarts <- base::computeRestarts
[08:24:51.932]                           grepl <- base::grepl
[08:24:51.932]                           restarts <- computeRestarts(cond)
[08:24:51.932]                           for (restart in restarts) {
[08:24:51.932]                             name <- restart$name
[08:24:51.932]                             if (is.null(name)) 
[08:24:51.932]                               next
[08:24:51.932]                             if (!grepl(pattern, name)) 
[08:24:51.932]                               next
[08:24:51.932]                             invokeRestart(restart)
[08:24:51.932]                             muffled <- TRUE
[08:24:51.932]                             break
[08:24:51.932]                           }
[08:24:51.932]                         }
[08:24:51.932]                       }
[08:24:51.932]                       invisible(muffled)
[08:24:51.932]                     }
[08:24:51.932]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.932]                   }
[08:24:51.932]                 }
[08:24:51.932]                 else {
[08:24:51.932]                   if (TRUE) {
[08:24:51.932]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.932]                     {
[08:24:51.932]                       inherits <- base::inherits
[08:24:51.932]                       invokeRestart <- base::invokeRestart
[08:24:51.932]                       is.null <- base::is.null
[08:24:51.932]                       muffled <- FALSE
[08:24:51.932]                       if (inherits(cond, "message")) {
[08:24:51.932]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.932]                         if (muffled) 
[08:24:51.932]                           invokeRestart("muffleMessage")
[08:24:51.932]                       }
[08:24:51.932]                       else if (inherits(cond, "warning")) {
[08:24:51.932]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.932]                         if (muffled) 
[08:24:51.932]                           invokeRestart("muffleWarning")
[08:24:51.932]                       }
[08:24:51.932]                       else if (inherits(cond, "condition")) {
[08:24:51.932]                         if (!is.null(pattern)) {
[08:24:51.932]                           computeRestarts <- base::computeRestarts
[08:24:51.932]                           grepl <- base::grepl
[08:24:51.932]                           restarts <- computeRestarts(cond)
[08:24:51.932]                           for (restart in restarts) {
[08:24:51.932]                             name <- restart$name
[08:24:51.932]                             if (is.null(name)) 
[08:24:51.932]                               next
[08:24:51.932]                             if (!grepl(pattern, name)) 
[08:24:51.932]                               next
[08:24:51.932]                             invokeRestart(restart)
[08:24:51.932]                             muffled <- TRUE
[08:24:51.932]                             break
[08:24:51.932]                           }
[08:24:51.932]                         }
[08:24:51.932]                       }
[08:24:51.932]                       invisible(muffled)
[08:24:51.932]                     }
[08:24:51.932]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.932]                   }
[08:24:51.932]                 }
[08:24:51.932]             }
[08:24:51.932]         }))
[08:24:51.932]     }, error = function(ex) {
[08:24:51.932]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:51.932]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.932]                 ...future.rng), started = ...future.startTime, 
[08:24:51.932]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:51.932]             version = "1.8"), class = "FutureResult")
[08:24:51.932]     }, finally = {
[08:24:51.932]         if (!identical(...future.workdir, getwd())) 
[08:24:51.932]             setwd(...future.workdir)
[08:24:51.932]         {
[08:24:51.932]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:51.932]                 ...future.oldOptions$nwarnings <- NULL
[08:24:51.932]             }
[08:24:51.932]             base::options(...future.oldOptions)
[08:24:51.932]             if (.Platform$OS.type == "windows") {
[08:24:51.932]                 old_names <- names(...future.oldEnvVars)
[08:24:51.932]                 envs <- base::Sys.getenv()
[08:24:51.932]                 names <- names(envs)
[08:24:51.932]                 common <- intersect(names, old_names)
[08:24:51.932]                 added <- setdiff(names, old_names)
[08:24:51.932]                 removed <- setdiff(old_names, names)
[08:24:51.932]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:51.932]                   envs[common]]
[08:24:51.932]                 NAMES <- toupper(changed)
[08:24:51.932]                 args <- list()
[08:24:51.932]                 for (kk in seq_along(NAMES)) {
[08:24:51.932]                   name <- changed[[kk]]
[08:24:51.932]                   NAME <- NAMES[[kk]]
[08:24:51.932]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.932]                     next
[08:24:51.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.932]                 }
[08:24:51.932]                 NAMES <- toupper(added)
[08:24:51.932]                 for (kk in seq_along(NAMES)) {
[08:24:51.932]                   name <- added[[kk]]
[08:24:51.932]                   NAME <- NAMES[[kk]]
[08:24:51.932]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.932]                     next
[08:24:51.932]                   args[[name]] <- ""
[08:24:51.932]                 }
[08:24:51.932]                 NAMES <- toupper(removed)
[08:24:51.932]                 for (kk in seq_along(NAMES)) {
[08:24:51.932]                   name <- removed[[kk]]
[08:24:51.932]                   NAME <- NAMES[[kk]]
[08:24:51.932]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.932]                     next
[08:24:51.932]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.932]                 }
[08:24:51.932]                 if (length(args) > 0) 
[08:24:51.932]                   base::do.call(base::Sys.setenv, args = args)
[08:24:51.932]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:51.932]             }
[08:24:51.932]             else {
[08:24:51.932]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:51.932]             }
[08:24:51.932]             {
[08:24:51.932]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:51.932]                   0L) {
[08:24:51.932]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:51.932]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:51.932]                   base::options(opts)
[08:24:51.932]                 }
[08:24:51.932]                 {
[08:24:51.932]                   {
[08:24:51.932]                     NULL
[08:24:51.932]                     RNGkind("Mersenne-Twister")
[08:24:51.932]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:51.932]                       inherits = FALSE)
[08:24:51.932]                   }
[08:24:51.932]                   options(future.plan = NULL)
[08:24:51.932]                   if (is.na(NA_character_)) 
[08:24:51.932]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.932]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:51.932]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:51.932]                     .init = FALSE)
[08:24:51.932]                 }
[08:24:51.932]             }
[08:24:51.932]         }
[08:24:51.932]     })
[08:24:51.932]     if (TRUE) {
[08:24:51.932]         base::sink(type = "output", split = FALSE)
[08:24:51.932]         if (TRUE) {
[08:24:51.932]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:51.932]         }
[08:24:51.932]         else {
[08:24:51.932]             ...future.result["stdout"] <- base::list(NULL)
[08:24:51.932]         }
[08:24:51.932]         base::close(...future.stdout)
[08:24:51.932]         ...future.stdout <- NULL
[08:24:51.932]     }
[08:24:51.932]     ...future.result$conditions <- ...future.conditions
[08:24:51.932]     ...future.result$finished <- base::Sys.time()
[08:24:51.932]     ...future.result
[08:24:51.932] }
[08:24:51.934] assign_globals() ...
[08:24:51.934] List of 5
[08:24:51.934]  $ future.call.arguments    : list()
[08:24:51.934]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.934]  $ ...future.FUN            :function (x)  
[08:24:51.934]  $ ...future.elements_ii    :List of 2
[08:24:51.934]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[08:24:51.934]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[08:24:51.934]  $ ...future.seeds_ii       : NULL
[08:24:51.934]  $ ...future.globals.maxSize: num Inf
[08:24:51.934]  - attr(*, "resolved")= logi FALSE
[08:24:51.934]  - attr(*, "total_size")= num NA
[08:24:51.934]  - attr(*, "where")=List of 5
[08:24:51.934]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:51.934]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:51.934]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:51.934]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:51.934]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:51.934]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.934]  - attr(*, "already-done")= logi TRUE
[08:24:51.939] - copied ‘future.call.arguments’ to environment
[08:24:51.939] - copied ‘...future.FUN’ to environment
[08:24:51.939] - copied ‘...future.elements_ii’ to environment
[08:24:51.939] - copied ‘...future.seeds_ii’ to environment
[08:24:51.940] - copied ‘...future.globals.maxSize’ to environment
[08:24:51.940] assign_globals() ... done
[08:24:51.940] plan(): Setting new future strategy stack:
[08:24:51.940] List of future strategies:
[08:24:51.940] 1. sequential:
[08:24:51.940]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.940]    - tweaked: FALSE
[08:24:51.940]    - call: NULL
[08:24:51.940] plan(): nbrOfWorkers() = 1
[08:24:51.943] plan(): Setting new future strategy stack:
[08:24:51.943] List of future strategies:
[08:24:51.943] 1. sequential:
[08:24:51.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.943]    - tweaked: FALSE
[08:24:51.943]    - call: plan(strategy)
[08:24:51.943] plan(): nbrOfWorkers() = 1
[08:24:51.943] SequentialFuture started (and completed)
[08:24:51.944] - Launch lazy future ... done
[08:24:51.944] run() for ‘SequentialFuture’ ... done
[08:24:51.944] Created future:
[08:24:51.944] SequentialFuture:
[08:24:51.944] Label: ‘future_apply-1’
[08:24:51.944] Expression:
[08:24:51.944] {
[08:24:51.944]     do.call(function(...) {
[08:24:51.944]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.944]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.944]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.944]             on.exit(options(oopts), add = TRUE)
[08:24:51.944]         }
[08:24:51.944]         {
[08:24:51.944]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.944]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.944]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.944]             })
[08:24:51.944]         }
[08:24:51.944]     }, args = future.call.arguments)
[08:24:51.944] }
[08:24:51.944] Lazy evaluation: FALSE
[08:24:51.944] Asynchronous evaluation: FALSE
[08:24:51.944] Local evaluation: TRUE
[08:24:51.944] Environment: R_GlobalEnv
[08:24:51.944] Capture standard output: TRUE
[08:24:51.944] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:51.944] Globals: 5 objects totaling 523 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 175 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:51.944] Packages: <none>
[08:24:51.944] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:51.944] Resolved: TRUE
[08:24:51.944] Value: 175 bytes of class ‘list’
[08:24:51.944] Early signaling: FALSE
[08:24:51.944] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:51.944] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.945] Chunk #1 of 1 ... DONE
[08:24:51.945] Launching 1 futures (chunks) ... DONE
[08:24:51.945] Resolving 1 futures (chunks) ...
[08:24:51.945] resolve() on list ...
[08:24:51.945]  recursive: 0
[08:24:51.945]  length: 1
[08:24:51.945] 
[08:24:51.945] resolved() for ‘SequentialFuture’ ...
[08:24:51.945] - state: ‘finished’
[08:24:51.945] - run: TRUE
[08:24:51.946] - result: ‘FutureResult’
[08:24:51.946] resolved() for ‘SequentialFuture’ ... done
[08:24:51.946] Future #1
[08:24:51.946] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:51.946] - nx: 1
[08:24:51.946] - relay: TRUE
[08:24:51.946] - stdout: TRUE
[08:24:51.946] - signal: TRUE
[08:24:51.946] - resignal: FALSE
[08:24:51.946] - force: TRUE
[08:24:51.946] - relayed: [n=1] FALSE
[08:24:51.947] - queued futures: [n=1] FALSE
[08:24:51.947]  - until=1
[08:24:51.947]  - relaying element #1
[08:24:51.947] - relayed: [n=1] TRUE
[08:24:51.947] - queued futures: [n=1] TRUE
[08:24:51.947] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:51.947]  length: 0 (resolved future 1)
[08:24:51.947] Relaying remaining futures
[08:24:51.947] signalConditionsASAP(NULL, pos=0) ...
[08:24:51.947] - nx: 1
[08:24:51.947] - relay: TRUE
[08:24:51.948] - stdout: TRUE
[08:24:51.948] - signal: TRUE
[08:24:51.948] - resignal: FALSE
[08:24:51.948] - force: TRUE
[08:24:51.948] - relayed: [n=1] TRUE
[08:24:51.948] - queued futures: [n=1] TRUE
 - flush all
[08:24:51.948] - relayed: [n=1] TRUE
[08:24:51.948] - queued futures: [n=1] TRUE
[08:24:51.948] signalConditionsASAP(NULL, pos=0) ... done
[08:24:51.948] resolve() on list ... DONE
[08:24:51.948]  - Number of value chunks collected: 1
[08:24:51.949] Resolving 1 futures (chunks) ... DONE
[08:24:51.949] Reducing values from 1 chunks ...
[08:24:51.949]  - Number of values collected after concatenation: 2
[08:24:51.949]  - Number of values expected: 2
[08:24:51.949] Reducing values from 1 chunks ... DONE
[08:24:51.949] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[08:24:51.949] getGlobalsAndPackagesXApply() ...
[08:24:51.949]  - future.globals: TRUE
[08:24:51.949] getGlobalsAndPackages() ...
[08:24:51.949] Searching for globals...
[08:24:51.950] - globals found: [1] ‘FUN’
[08:24:51.951] Searching for globals ... DONE
[08:24:51.951] Resolving globals: FALSE
[08:24:51.951] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:51.951] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:51.951] - globals: [1] ‘FUN’
[08:24:51.952] 
[08:24:51.952] getGlobalsAndPackages() ... DONE
[08:24:51.952]  - globals found/used: [n=1] ‘FUN’
[08:24:51.952]  - needed namespaces: [n=0] 
[08:24:51.952] Finding globals ... DONE
[08:24:51.952]  - use_args: TRUE
[08:24:51.952]  - Getting '...' globals ...
[08:24:51.952] resolve() on list ...
[08:24:51.952]  recursive: 0
[08:24:51.953]  length: 1
[08:24:51.953]  elements: ‘...’
[08:24:51.953]  length: 0 (resolved future 1)
[08:24:51.953] resolve() on list ... DONE
[08:24:51.953]    - '...' content: [n=0] 
[08:24:51.953] List of 1
[08:24:51.953]  $ ...: list()
[08:24:51.953]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.953]  - attr(*, "where")=List of 1
[08:24:51.953]   ..$ ...:<environment: 0x56540c8071e8> 
[08:24:51.953]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.953]  - attr(*, "resolved")= logi TRUE
[08:24:51.953]  - attr(*, "total_size")= num NA
[08:24:51.955]  - Getting '...' globals ... DONE
[08:24:51.955] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:51.956] List of 2
[08:24:51.956]  $ ...future.FUN:function (x)  
[08:24:51.956]  $ ...          : list()
[08:24:51.956]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.956]  - attr(*, "where")=List of 2
[08:24:51.956]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:51.956]   ..$ ...          :<environment: 0x56540c8071e8> 
[08:24:51.956]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.956]  - attr(*, "resolved")= logi FALSE
[08:24:51.956]  - attr(*, "total_size")= num 3563
[08:24:51.958] Packages to be attached in all futures: [n=0] 
[08:24:51.958] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.958] future_lapply() ...
[08:24:51.959] Number of chunks: 1
[08:24:51.959] getGlobalsAndPackagesXApply() ...
[08:24:51.959]  - future.globals: <name-value list> with names ‘list()’
[08:24:51.959]  - use_args: TRUE
[08:24:51.959] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:51.959] List of 2
[08:24:51.959]  $ ...          : list()
[08:24:51.959]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.959]  $ ...future.FUN:function (x)  
[08:24:51.959]  - attr(*, "where")=List of 2
[08:24:51.959]   ..$ ...          :<environment: 0x56540c8071e8> 
[08:24:51.959]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:51.959]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.959]  - attr(*, "resolved")= logi FALSE
[08:24:51.959]  - attr(*, "total_size")= num NA
[08:24:51.963] Packages to be attached in all futures: [n=0] 
[08:24:51.963] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.963] Number of futures (= number of chunks): 1
[08:24:51.963] Launching 1 futures (chunks) ...
[08:24:51.965] Chunk #1 of 1 ...
[08:24:51.965]  - seeds: <none>
[08:24:51.965]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.965] getGlobalsAndPackages() ...
[08:24:51.965] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.965] Resolving globals: FALSE
[08:24:51.965] Tweak future expression to call with '...' arguments ...
[08:24:51.965] {
[08:24:51.965]     do.call(function(...) {
[08:24:51.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.965]             on.exit(options(oopts), add = TRUE)
[08:24:51.965]         }
[08:24:51.965]         {
[08:24:51.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.965]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.965]             })
[08:24:51.965]         }
[08:24:51.965]     }, args = future.call.arguments)
[08:24:51.965] }
[08:24:51.966] Tweak future expression to call with '...' arguments ... DONE
[08:24:51.966] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:51.966] 
[08:24:51.966] getGlobalsAndPackages() ... DONE
[08:24:51.967] run() for ‘Future’ ...
[08:24:51.967] - state: ‘created’
[08:24:51.967] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:51.967] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.967] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:51.967]   - Field: ‘label’
[08:24:51.967]   - Field: ‘local’
[08:24:51.968]   - Field: ‘owner’
[08:24:51.968]   - Field: ‘envir’
[08:24:51.968]   - Field: ‘packages’
[08:24:51.968]   - Field: ‘gc’
[08:24:51.968]   - Field: ‘conditions’
[08:24:51.968]   - Field: ‘expr’
[08:24:51.968]   - Field: ‘uuid’
[08:24:51.968]   - Field: ‘seed’
[08:24:51.968]   - Field: ‘version’
[08:24:51.968]   - Field: ‘result’
[08:24:51.968]   - Field: ‘asynchronous’
[08:24:51.969]   - Field: ‘calls’
[08:24:51.969]   - Field: ‘globals’
[08:24:51.969]   - Field: ‘stdout’
[08:24:51.969]   - Field: ‘earlySignal’
[08:24:51.969]   - Field: ‘lazy’
[08:24:51.969]   - Field: ‘state’
[08:24:51.969] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:51.969] - Launch lazy future ...
[08:24:51.969] Packages needed by the future expression (n = 0): <none>
[08:24:51.969] Packages needed by future strategies (n = 0): <none>
[08:24:51.970] {
[08:24:51.970]     {
[08:24:51.970]         {
[08:24:51.970]             ...future.startTime <- base::Sys.time()
[08:24:51.970]             {
[08:24:51.970]                 {
[08:24:51.970]                   {
[08:24:51.970]                     base::local({
[08:24:51.970]                       has_future <- base::requireNamespace("future", 
[08:24:51.970]                         quietly = TRUE)
[08:24:51.970]                       if (has_future) {
[08:24:51.970]                         ns <- base::getNamespace("future")
[08:24:51.970]                         version <- ns[[".package"]][["version"]]
[08:24:51.970]                         if (is.null(version)) 
[08:24:51.970]                           version <- utils::packageVersion("future")
[08:24:51.970]                       }
[08:24:51.970]                       else {
[08:24:51.970]                         version <- NULL
[08:24:51.970]                       }
[08:24:51.970]                       if (!has_future || version < "1.8.0") {
[08:24:51.970]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:51.970]                           "", base::R.version$version.string), 
[08:24:51.970]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:51.970]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:51.970]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:51.970]                             "release", "version")], collapse = " "), 
[08:24:51.970]                           hostname = base::Sys.info()[["nodename"]])
[08:24:51.970]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:51.970]                           info)
[08:24:51.970]                         info <- base::paste(info, collapse = "; ")
[08:24:51.970]                         if (!has_future) {
[08:24:51.970]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:51.970]                             info)
[08:24:51.970]                         }
[08:24:51.970]                         else {
[08:24:51.970]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:51.970]                             info, version)
[08:24:51.970]                         }
[08:24:51.970]                         base::stop(msg)
[08:24:51.970]                       }
[08:24:51.970]                     })
[08:24:51.970]                   }
[08:24:51.970]                   ...future.strategy.old <- future::plan("list")
[08:24:51.970]                   options(future.plan = NULL)
[08:24:51.970]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.970]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:51.970]                 }
[08:24:51.970]                 ...future.workdir <- getwd()
[08:24:51.970]             }
[08:24:51.970]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:51.970]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:51.970]         }
[08:24:51.970]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:51.970]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:51.970]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:51.970]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:51.970]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:51.970]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:51.970]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:51.970]             base::names(...future.oldOptions))
[08:24:51.970]     }
[08:24:51.970]     if (FALSE) {
[08:24:51.970]     }
[08:24:51.970]     else {
[08:24:51.970]         if (TRUE) {
[08:24:51.970]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:51.970]                 open = "w")
[08:24:51.970]         }
[08:24:51.970]         else {
[08:24:51.970]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:51.970]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:51.970]         }
[08:24:51.970]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:51.970]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:51.970]             base::sink(type = "output", split = FALSE)
[08:24:51.970]             base::close(...future.stdout)
[08:24:51.970]         }, add = TRUE)
[08:24:51.970]     }
[08:24:51.970]     ...future.frame <- base::sys.nframe()
[08:24:51.970]     ...future.conditions <- base::list()
[08:24:51.970]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:51.970]     if (FALSE) {
[08:24:51.970]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:51.970]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:51.970]     }
[08:24:51.970]     ...future.result <- base::tryCatch({
[08:24:51.970]         base::withCallingHandlers({
[08:24:51.970]             ...future.value <- base::withVisible(base::local({
[08:24:51.970]                 do.call(function(...) {
[08:24:51.970]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.970]                   if (!identical(...future.globals.maxSize.org, 
[08:24:51.970]                     ...future.globals.maxSize)) {
[08:24:51.970]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.970]                     on.exit(options(oopts), add = TRUE)
[08:24:51.970]                   }
[08:24:51.970]                   {
[08:24:51.970]                     lapply(seq_along(...future.elements_ii), 
[08:24:51.970]                       FUN = function(jj) {
[08:24:51.970]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.970]                         ...future.FUN(...future.X_jj, ...)
[08:24:51.970]                       })
[08:24:51.970]                   }
[08:24:51.970]                 }, args = future.call.arguments)
[08:24:51.970]             }))
[08:24:51.970]             future::FutureResult(value = ...future.value$value, 
[08:24:51.970]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.970]                   ...future.rng), globalenv = if (FALSE) 
[08:24:51.970]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:51.970]                     ...future.globalenv.names))
[08:24:51.970]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:51.970]         }, condition = base::local({
[08:24:51.970]             c <- base::c
[08:24:51.970]             inherits <- base::inherits
[08:24:51.970]             invokeRestart <- base::invokeRestart
[08:24:51.970]             length <- base::length
[08:24:51.970]             list <- base::list
[08:24:51.970]             seq.int <- base::seq.int
[08:24:51.970]             signalCondition <- base::signalCondition
[08:24:51.970]             sys.calls <- base::sys.calls
[08:24:51.970]             `[[` <- base::`[[`
[08:24:51.970]             `+` <- base::`+`
[08:24:51.970]             `<<-` <- base::`<<-`
[08:24:51.970]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:51.970]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:51.970]                   3L)]
[08:24:51.970]             }
[08:24:51.970]             function(cond) {
[08:24:51.970]                 is_error <- inherits(cond, "error")
[08:24:51.970]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:51.970]                   NULL)
[08:24:51.970]                 if (is_error) {
[08:24:51.970]                   sessionInformation <- function() {
[08:24:51.970]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:51.970]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:51.970]                       search = base::search(), system = base::Sys.info())
[08:24:51.970]                   }
[08:24:51.970]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.970]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:51.970]                     cond$call), session = sessionInformation(), 
[08:24:51.970]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:51.970]                   signalCondition(cond)
[08:24:51.970]                 }
[08:24:51.970]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:51.970]                 "immediateCondition"))) {
[08:24:51.970]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:51.970]                   ...future.conditions[[length(...future.conditions) + 
[08:24:51.970]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:51.970]                   if (TRUE && !signal) {
[08:24:51.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.970]                     {
[08:24:51.970]                       inherits <- base::inherits
[08:24:51.970]                       invokeRestart <- base::invokeRestart
[08:24:51.970]                       is.null <- base::is.null
[08:24:51.970]                       muffled <- FALSE
[08:24:51.970]                       if (inherits(cond, "message")) {
[08:24:51.970]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.970]                         if (muffled) 
[08:24:51.970]                           invokeRestart("muffleMessage")
[08:24:51.970]                       }
[08:24:51.970]                       else if (inherits(cond, "warning")) {
[08:24:51.970]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.970]                         if (muffled) 
[08:24:51.970]                           invokeRestart("muffleWarning")
[08:24:51.970]                       }
[08:24:51.970]                       else if (inherits(cond, "condition")) {
[08:24:51.970]                         if (!is.null(pattern)) {
[08:24:51.970]                           computeRestarts <- base::computeRestarts
[08:24:51.970]                           grepl <- base::grepl
[08:24:51.970]                           restarts <- computeRestarts(cond)
[08:24:51.970]                           for (restart in restarts) {
[08:24:51.970]                             name <- restart$name
[08:24:51.970]                             if (is.null(name)) 
[08:24:51.970]                               next
[08:24:51.970]                             if (!grepl(pattern, name)) 
[08:24:51.970]                               next
[08:24:51.970]                             invokeRestart(restart)
[08:24:51.970]                             muffled <- TRUE
[08:24:51.970]                             break
[08:24:51.970]                           }
[08:24:51.970]                         }
[08:24:51.970]                       }
[08:24:51.970]                       invisible(muffled)
[08:24:51.970]                     }
[08:24:51.970]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.970]                   }
[08:24:51.970]                 }
[08:24:51.970]                 else {
[08:24:51.970]                   if (TRUE) {
[08:24:51.970]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:51.970]                     {
[08:24:51.970]                       inherits <- base::inherits
[08:24:51.970]                       invokeRestart <- base::invokeRestart
[08:24:51.970]                       is.null <- base::is.null
[08:24:51.970]                       muffled <- FALSE
[08:24:51.970]                       if (inherits(cond, "message")) {
[08:24:51.970]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:51.970]                         if (muffled) 
[08:24:51.970]                           invokeRestart("muffleMessage")
[08:24:51.970]                       }
[08:24:51.970]                       else if (inherits(cond, "warning")) {
[08:24:51.970]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:51.970]                         if (muffled) 
[08:24:51.970]                           invokeRestart("muffleWarning")
[08:24:51.970]                       }
[08:24:51.970]                       else if (inherits(cond, "condition")) {
[08:24:51.970]                         if (!is.null(pattern)) {
[08:24:51.970]                           computeRestarts <- base::computeRestarts
[08:24:51.970]                           grepl <- base::grepl
[08:24:51.970]                           restarts <- computeRestarts(cond)
[08:24:51.970]                           for (restart in restarts) {
[08:24:51.970]                             name <- restart$name
[08:24:51.970]                             if (is.null(name)) 
[08:24:51.970]                               next
[08:24:51.970]                             if (!grepl(pattern, name)) 
[08:24:51.970]                               next
[08:24:51.970]                             invokeRestart(restart)
[08:24:51.970]                             muffled <- TRUE
[08:24:51.970]                             break
[08:24:51.970]                           }
[08:24:51.970]                         }
[08:24:51.970]                       }
[08:24:51.970]                       invisible(muffled)
[08:24:51.970]                     }
[08:24:51.970]                     muffleCondition(cond, pattern = "^muffle")
[08:24:51.970]                   }
[08:24:51.970]                 }
[08:24:51.970]             }
[08:24:51.970]         }))
[08:24:51.970]     }, error = function(ex) {
[08:24:51.970]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:51.970]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:51.970]                 ...future.rng), started = ...future.startTime, 
[08:24:51.970]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:51.970]             version = "1.8"), class = "FutureResult")
[08:24:51.970]     }, finally = {
[08:24:51.970]         if (!identical(...future.workdir, getwd())) 
[08:24:51.970]             setwd(...future.workdir)
[08:24:51.970]         {
[08:24:51.970]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:51.970]                 ...future.oldOptions$nwarnings <- NULL
[08:24:51.970]             }
[08:24:51.970]             base::options(...future.oldOptions)
[08:24:51.970]             if (.Platform$OS.type == "windows") {
[08:24:51.970]                 old_names <- names(...future.oldEnvVars)
[08:24:51.970]                 envs <- base::Sys.getenv()
[08:24:51.970]                 names <- names(envs)
[08:24:51.970]                 common <- intersect(names, old_names)
[08:24:51.970]                 added <- setdiff(names, old_names)
[08:24:51.970]                 removed <- setdiff(old_names, names)
[08:24:51.970]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:51.970]                   envs[common]]
[08:24:51.970]                 NAMES <- toupper(changed)
[08:24:51.970]                 args <- list()
[08:24:51.970]                 for (kk in seq_along(NAMES)) {
[08:24:51.970]                   name <- changed[[kk]]
[08:24:51.970]                   NAME <- NAMES[[kk]]
[08:24:51.970]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.970]                     next
[08:24:51.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.970]                 }
[08:24:51.970]                 NAMES <- toupper(added)
[08:24:51.970]                 for (kk in seq_along(NAMES)) {
[08:24:51.970]                   name <- added[[kk]]
[08:24:51.970]                   NAME <- NAMES[[kk]]
[08:24:51.970]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.970]                     next
[08:24:51.970]                   args[[name]] <- ""
[08:24:51.970]                 }
[08:24:51.970]                 NAMES <- toupper(removed)
[08:24:51.970]                 for (kk in seq_along(NAMES)) {
[08:24:51.970]                   name <- removed[[kk]]
[08:24:51.970]                   NAME <- NAMES[[kk]]
[08:24:51.970]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:51.970]                     next
[08:24:51.970]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:51.970]                 }
[08:24:51.970]                 if (length(args) > 0) 
[08:24:51.970]                   base::do.call(base::Sys.setenv, args = args)
[08:24:51.970]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:51.970]             }
[08:24:51.970]             else {
[08:24:51.970]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:51.970]             }
[08:24:51.970]             {
[08:24:51.970]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:51.970]                   0L) {
[08:24:51.970]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:51.970]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:51.970]                   base::options(opts)
[08:24:51.970]                 }
[08:24:51.970]                 {
[08:24:51.970]                   {
[08:24:51.970]                     NULL
[08:24:51.970]                     RNGkind("Mersenne-Twister")
[08:24:51.970]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:51.970]                       inherits = FALSE)
[08:24:51.970]                   }
[08:24:51.970]                   options(future.plan = NULL)
[08:24:51.970]                   if (is.na(NA_character_)) 
[08:24:51.970]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:51.970]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:51.970]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:51.970]                     .init = FALSE)
[08:24:51.970]                 }
[08:24:51.970]             }
[08:24:51.970]         }
[08:24:51.970]     })
[08:24:51.970]     if (TRUE) {
[08:24:51.970]         base::sink(type = "output", split = FALSE)
[08:24:51.970]         if (TRUE) {
[08:24:51.970]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:51.970]         }
[08:24:51.970]         else {
[08:24:51.970]             ...future.result["stdout"] <- base::list(NULL)
[08:24:51.970]         }
[08:24:51.970]         base::close(...future.stdout)
[08:24:51.970]         ...future.stdout <- NULL
[08:24:51.970]     }
[08:24:51.970]     ...future.result$conditions <- ...future.conditions
[08:24:51.970]     ...future.result$finished <- base::Sys.time()
[08:24:51.970]     ...future.result
[08:24:51.970] }
[08:24:51.972] assign_globals() ...
[08:24:51.972] List of 5
[08:24:51.972]  $ future.call.arguments    : list()
[08:24:51.972]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.972]  $ ...future.FUN            :function (x)  
[08:24:51.972]  $ ...future.elements_ii    :List of 6
[08:24:51.972]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[08:24:51.972]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[08:24:51.972]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[08:24:51.972]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[08:24:51.972]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[08:24:51.972]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[08:24:51.972]  $ ...future.seeds_ii       : NULL
[08:24:51.972]  $ ...future.globals.maxSize: num Inf
[08:24:51.972]  - attr(*, "resolved")= logi FALSE
[08:24:51.972]  - attr(*, "total_size")= num NA
[08:24:51.972]  - attr(*, "where")=List of 5
[08:24:51.972]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:51.972]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:51.972]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:51.972]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:51.972]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:51.972]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.972]  - attr(*, "already-done")= logi TRUE
[08:24:51.978] - copied ‘future.call.arguments’ to environment
[08:24:51.978] - copied ‘...future.FUN’ to environment
[08:24:51.978] - copied ‘...future.elements_ii’ to environment
[08:24:51.978] - copied ‘...future.seeds_ii’ to environment
[08:24:51.978] - copied ‘...future.globals.maxSize’ to environment
[08:24:51.978] assign_globals() ... done
[08:24:51.979] plan(): Setting new future strategy stack:
[08:24:51.979] List of future strategies:
[08:24:51.979] 1. sequential:
[08:24:51.979]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.979]    - tweaked: FALSE
[08:24:51.979]    - call: NULL
[08:24:51.979] plan(): nbrOfWorkers() = 1
[08:24:51.980] plan(): Setting new future strategy stack:
[08:24:51.980] List of future strategies:
[08:24:51.980] 1. sequential:
[08:24:51.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:51.980]    - tweaked: FALSE
[08:24:51.980]    - call: plan(strategy)
[08:24:51.981] plan(): nbrOfWorkers() = 1
[08:24:51.981] SequentialFuture started (and completed)
[08:24:51.981] - Launch lazy future ... done
[08:24:51.981] run() for ‘SequentialFuture’ ... done
[08:24:51.981] Created future:
[08:24:51.981] SequentialFuture:
[08:24:51.981] Label: ‘future_apply-1’
[08:24:51.981] Expression:
[08:24:51.981] {
[08:24:51.981]     do.call(function(...) {
[08:24:51.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:51.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:51.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:51.981]             on.exit(options(oopts), add = TRUE)
[08:24:51.981]         }
[08:24:51.981]         {
[08:24:51.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:51.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:51.981]                 ...future.FUN(...future.X_jj, ...)
[08:24:51.981]             })
[08:24:51.981]         }
[08:24:51.981]     }, args = future.call.arguments)
[08:24:51.981] }
[08:24:51.981] Lazy evaluation: FALSE
[08:24:51.981] Asynchronous evaluation: FALSE
[08:24:51.981] Local evaluation: TRUE
[08:24:51.981] Environment: R_GlobalEnv
[08:24:51.981] Capture standard output: TRUE
[08:24:51.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:51.981] Globals: 5 objects totaling 811 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 463 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:51.981] Packages: <none>
[08:24:51.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:51.981] Resolved: TRUE
[08:24:51.981] Value: 463 bytes of class ‘list’
[08:24:51.981] Early signaling: FALSE
[08:24:51.981] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:51.981] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:51.982] Chunk #1 of 1 ... DONE
[08:24:51.982] Launching 1 futures (chunks) ... DONE
[08:24:51.982] Resolving 1 futures (chunks) ...
[08:24:51.982] resolve() on list ...
[08:24:51.982]  recursive: 0
[08:24:51.983]  length: 1
[08:24:51.983] 
[08:24:51.983] resolved() for ‘SequentialFuture’ ...
[08:24:51.983] - state: ‘finished’
[08:24:51.983] - run: TRUE
[08:24:51.983] - result: ‘FutureResult’
[08:24:51.983] resolved() for ‘SequentialFuture’ ... done
[08:24:51.983] Future #1
[08:24:51.983] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:51.983] - nx: 1
[08:24:51.983] - relay: TRUE
[08:24:51.984] - stdout: TRUE
[08:24:51.984] - signal: TRUE
[08:24:51.984] - resignal: FALSE
[08:24:51.984] - force: TRUE
[08:24:51.984] - relayed: [n=1] FALSE
[08:24:51.984] - queued futures: [n=1] FALSE
[08:24:51.984]  - until=1
[08:24:51.984]  - relaying element #1
[08:24:51.984] - relayed: [n=1] TRUE
[08:24:51.984] - queued futures: [n=1] TRUE
[08:24:51.985] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:51.985]  length: 0 (resolved future 1)
[08:24:51.985] Relaying remaining futures
[08:24:51.985] signalConditionsASAP(NULL, pos=0) ...
[08:24:51.985] - nx: 1
[08:24:51.985] - relay: TRUE
[08:24:51.985] - stdout: TRUE
[08:24:51.985] - signal: TRUE
[08:24:51.985] - resignal: FALSE
[08:24:51.985] - force: TRUE
[08:24:51.985] - relayed: [n=1] TRUE
[08:24:51.985] - queued futures: [n=1] TRUE
 - flush all
[08:24:51.986] - relayed: [n=1] TRUE
[08:24:51.986] - queued futures: [n=1] TRUE
[08:24:51.986] signalConditionsASAP(NULL, pos=0) ... done
[08:24:51.986] resolve() on list ... DONE
[08:24:51.986]  - Number of value chunks collected: 1
[08:24:51.986] Resolving 1 futures (chunks) ... DONE
[08:24:51.986] Reducing values from 1 chunks ...
[08:24:51.986]  - Number of values collected after concatenation: 6
[08:24:51.986]  - Number of values expected: 6
[08:24:51.986] Reducing values from 1 chunks ... DONE
[08:24:51.986] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[08:24:51.987] getGlobalsAndPackagesXApply() ...
[08:24:51.987]  - future.globals: TRUE
[08:24:51.987] getGlobalsAndPackages() ...
[08:24:51.989] Searching for globals...
[08:24:51.990] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[08:24:51.991] Searching for globals ... DONE
[08:24:51.991] Resolving globals: FALSE
[08:24:51.991] The total size of the 1 globals is 411 bytes (411 bytes)
[08:24:51.991] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 411 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (411 bytes of class ‘function’)
[08:24:51.991] - globals: [1] ‘FUN’
[08:24:51.992] 
[08:24:51.992] getGlobalsAndPackages() ... DONE
[08:24:51.992]  - globals found/used: [n=1] ‘FUN’
[08:24:51.992]  - needed namespaces: [n=0] 
[08:24:51.992] Finding globals ... DONE
[08:24:51.992]  - use_args: TRUE
[08:24:51.992]  - Getting '...' globals ...
[08:24:51.992] resolve() on list ...
[08:24:51.993]  recursive: 0
[08:24:51.993]  length: 1
[08:24:51.993]  elements: ‘...’
[08:24:51.993]  length: 0 (resolved future 1)
[08:24:51.993] resolve() on list ... DONE
[08:24:51.993]    - '...' content: [n=0] 
[08:24:51.993] List of 1
[08:24:51.993]  $ ...: list()
[08:24:51.993]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.993]  - attr(*, "where")=List of 1
[08:24:51.993]   ..$ ...:<environment: 0x56540e7a6208> 
[08:24:51.993]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.993]  - attr(*, "resolved")= logi TRUE
[08:24:51.993]  - attr(*, "total_size")= num NA
[08:24:51.995]  - Getting '...' globals ... DONE
[08:24:51.996] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:51.996] List of 2
[08:24:51.996]  $ ...future.FUN:function (x)  
[08:24:51.996]  $ ...          : list()
[08:24:51.996]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:51.996]  - attr(*, "where")=List of 2
[08:24:51.996]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:51.996]   ..$ ...          :<environment: 0x56540e7a6208> 
[08:24:51.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:51.996]  - attr(*, "resolved")= logi FALSE
[08:24:51.996]  - attr(*, "total_size")= num 3672
[08:24:51.998] Packages to be attached in all futures: [n=0] 
[08:24:51.998] getGlobalsAndPackagesXApply() ... DONE
[08:24:51.999] future_lapply() ...
[08:24:51.999] Number of chunks: 1
[08:24:51.999] getGlobalsAndPackagesXApply() ...
[08:24:51.999]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.000]  - use_args: TRUE
[08:24:52.000] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.000] List of 2
[08:24:52.000]  $ ...          : list()
[08:24:52.000]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.000]  $ ...future.FUN:function (x)  
[08:24:52.000]  - attr(*, "where")=List of 2
[08:24:52.000]   ..$ ...          :<environment: 0x56540e7a6208> 
[08:24:52.000]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[08:24:52.000]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.000]  - attr(*, "resolved")= logi FALSE
[08:24:52.000]  - attr(*, "total_size")= num NA
[08:24:52.002] Packages to be attached in all futures: [n=0] 
[08:24:52.003] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.003] Number of futures (= number of chunks): 1
[08:24:52.003] Launching 1 futures (chunks) ...
[08:24:52.003] Chunk #1 of 1 ...
[08:24:52.003]  - seeds: <none>
[08:24:52.003]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.003] getGlobalsAndPackages() ...
[08:24:52.003] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.004] Resolving globals: FALSE
[08:24:52.004] Tweak future expression to call with '...' arguments ...
[08:24:52.004] {
[08:24:52.004]     do.call(function(...) {
[08:24:52.004]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.004]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.004]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.004]             on.exit(options(oopts), add = TRUE)
[08:24:52.004]         }
[08:24:52.004]         {
[08:24:52.004]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.004]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.004]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.004]             })
[08:24:52.004]         }
[08:24:52.004]     }, args = future.call.arguments)
[08:24:52.004] }
[08:24:52.004] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.004] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.004] 
[08:24:52.004] getGlobalsAndPackages() ... DONE
[08:24:52.005] run() for ‘Future’ ...
[08:24:52.005] - state: ‘created’
[08:24:52.005] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:52.005] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.005] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:52.005]   - Field: ‘label’
[08:24:52.006]   - Field: ‘local’
[08:24:52.006]   - Field: ‘owner’
[08:24:52.006]   - Field: ‘envir’
[08:24:52.006]   - Field: ‘packages’
[08:24:52.006]   - Field: ‘gc’
[08:24:52.006]   - Field: ‘conditions’
[08:24:52.006]   - Field: ‘expr’
[08:24:52.006]   - Field: ‘uuid’
[08:24:52.006]   - Field: ‘seed’
[08:24:52.006]   - Field: ‘version’
[08:24:52.006]   - Field: ‘result’
[08:24:52.007]   - Field: ‘asynchronous’
[08:24:52.007]   - Field: ‘calls’
[08:24:52.007]   - Field: ‘globals’
[08:24:52.007]   - Field: ‘stdout’
[08:24:52.007]   - Field: ‘earlySignal’
[08:24:52.007]   - Field: ‘lazy’
[08:24:52.007]   - Field: ‘state’
[08:24:52.007] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:52.007] - Launch lazy future ...
[08:24:52.007] Packages needed by the future expression (n = 0): <none>
[08:24:52.008] Packages needed by future strategies (n = 0): <none>
[08:24:52.008] {
[08:24:52.008]     {
[08:24:52.008]         {
[08:24:52.008]             ...future.startTime <- base::Sys.time()
[08:24:52.008]             {
[08:24:52.008]                 {
[08:24:52.008]                   {
[08:24:52.008]                     base::local({
[08:24:52.008]                       has_future <- base::requireNamespace("future", 
[08:24:52.008]                         quietly = TRUE)
[08:24:52.008]                       if (has_future) {
[08:24:52.008]                         ns <- base::getNamespace("future")
[08:24:52.008]                         version <- ns[[".package"]][["version"]]
[08:24:52.008]                         if (is.null(version)) 
[08:24:52.008]                           version <- utils::packageVersion("future")
[08:24:52.008]                       }
[08:24:52.008]                       else {
[08:24:52.008]                         version <- NULL
[08:24:52.008]                       }
[08:24:52.008]                       if (!has_future || version < "1.8.0") {
[08:24:52.008]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.008]                           "", base::R.version$version.string), 
[08:24:52.008]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:52.008]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.008]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.008]                             "release", "version")], collapse = " "), 
[08:24:52.008]                           hostname = base::Sys.info()[["nodename"]])
[08:24:52.008]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.008]                           info)
[08:24:52.008]                         info <- base::paste(info, collapse = "; ")
[08:24:52.008]                         if (!has_future) {
[08:24:52.008]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.008]                             info)
[08:24:52.008]                         }
[08:24:52.008]                         else {
[08:24:52.008]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.008]                             info, version)
[08:24:52.008]                         }
[08:24:52.008]                         base::stop(msg)
[08:24:52.008]                       }
[08:24:52.008]                     })
[08:24:52.008]                   }
[08:24:52.008]                   ...future.strategy.old <- future::plan("list")
[08:24:52.008]                   options(future.plan = NULL)
[08:24:52.008]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.008]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.008]                 }
[08:24:52.008]                 ...future.workdir <- getwd()
[08:24:52.008]             }
[08:24:52.008]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.008]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.008]         }
[08:24:52.008]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.008]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.008]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.008]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.008]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.008]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.008]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.008]             base::names(...future.oldOptions))
[08:24:52.008]     }
[08:24:52.008]     if (FALSE) {
[08:24:52.008]     }
[08:24:52.008]     else {
[08:24:52.008]         if (TRUE) {
[08:24:52.008]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.008]                 open = "w")
[08:24:52.008]         }
[08:24:52.008]         else {
[08:24:52.008]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.008]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.008]         }
[08:24:52.008]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.008]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.008]             base::sink(type = "output", split = FALSE)
[08:24:52.008]             base::close(...future.stdout)
[08:24:52.008]         }, add = TRUE)
[08:24:52.008]     }
[08:24:52.008]     ...future.frame <- base::sys.nframe()
[08:24:52.008]     ...future.conditions <- base::list()
[08:24:52.008]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.008]     if (FALSE) {
[08:24:52.008]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.008]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.008]     }
[08:24:52.008]     ...future.result <- base::tryCatch({
[08:24:52.008]         base::withCallingHandlers({
[08:24:52.008]             ...future.value <- base::withVisible(base::local({
[08:24:52.008]                 do.call(function(...) {
[08:24:52.008]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.008]                   if (!identical(...future.globals.maxSize.org, 
[08:24:52.008]                     ...future.globals.maxSize)) {
[08:24:52.008]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.008]                     on.exit(options(oopts), add = TRUE)
[08:24:52.008]                   }
[08:24:52.008]                   {
[08:24:52.008]                     lapply(seq_along(...future.elements_ii), 
[08:24:52.008]                       FUN = function(jj) {
[08:24:52.008]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.008]                         ...future.FUN(...future.X_jj, ...)
[08:24:52.008]                       })
[08:24:52.008]                   }
[08:24:52.008]                 }, args = future.call.arguments)
[08:24:52.008]             }))
[08:24:52.008]             future::FutureResult(value = ...future.value$value, 
[08:24:52.008]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.008]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.008]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.008]                     ...future.globalenv.names))
[08:24:52.008]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.008]         }, condition = base::local({
[08:24:52.008]             c <- base::c
[08:24:52.008]             inherits <- base::inherits
[08:24:52.008]             invokeRestart <- base::invokeRestart
[08:24:52.008]             length <- base::length
[08:24:52.008]             list <- base::list
[08:24:52.008]             seq.int <- base::seq.int
[08:24:52.008]             signalCondition <- base::signalCondition
[08:24:52.008]             sys.calls <- base::sys.calls
[08:24:52.008]             `[[` <- base::`[[`
[08:24:52.008]             `+` <- base::`+`
[08:24:52.008]             `<<-` <- base::`<<-`
[08:24:52.008]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.008]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.008]                   3L)]
[08:24:52.008]             }
[08:24:52.008]             function(cond) {
[08:24:52.008]                 is_error <- inherits(cond, "error")
[08:24:52.008]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.008]                   NULL)
[08:24:52.008]                 if (is_error) {
[08:24:52.008]                   sessionInformation <- function() {
[08:24:52.008]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.008]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.008]                       search = base::search(), system = base::Sys.info())
[08:24:52.008]                   }
[08:24:52.008]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.008]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.008]                     cond$call), session = sessionInformation(), 
[08:24:52.008]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.008]                   signalCondition(cond)
[08:24:52.008]                 }
[08:24:52.008]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.008]                 "immediateCondition"))) {
[08:24:52.008]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.008]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.008]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.008]                   if (TRUE && !signal) {
[08:24:52.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.008]                     {
[08:24:52.008]                       inherits <- base::inherits
[08:24:52.008]                       invokeRestart <- base::invokeRestart
[08:24:52.008]                       is.null <- base::is.null
[08:24:52.008]                       muffled <- FALSE
[08:24:52.008]                       if (inherits(cond, "message")) {
[08:24:52.008]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.008]                         if (muffled) 
[08:24:52.008]                           invokeRestart("muffleMessage")
[08:24:52.008]                       }
[08:24:52.008]                       else if (inherits(cond, "warning")) {
[08:24:52.008]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.008]                         if (muffled) 
[08:24:52.008]                           invokeRestart("muffleWarning")
[08:24:52.008]                       }
[08:24:52.008]                       else if (inherits(cond, "condition")) {
[08:24:52.008]                         if (!is.null(pattern)) {
[08:24:52.008]                           computeRestarts <- base::computeRestarts
[08:24:52.008]                           grepl <- base::grepl
[08:24:52.008]                           restarts <- computeRestarts(cond)
[08:24:52.008]                           for (restart in restarts) {
[08:24:52.008]                             name <- restart$name
[08:24:52.008]                             if (is.null(name)) 
[08:24:52.008]                               next
[08:24:52.008]                             if (!grepl(pattern, name)) 
[08:24:52.008]                               next
[08:24:52.008]                             invokeRestart(restart)
[08:24:52.008]                             muffled <- TRUE
[08:24:52.008]                             break
[08:24:52.008]                           }
[08:24:52.008]                         }
[08:24:52.008]                       }
[08:24:52.008]                       invisible(muffled)
[08:24:52.008]                     }
[08:24:52.008]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.008]                   }
[08:24:52.008]                 }
[08:24:52.008]                 else {
[08:24:52.008]                   if (TRUE) {
[08:24:52.008]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.008]                     {
[08:24:52.008]                       inherits <- base::inherits
[08:24:52.008]                       invokeRestart <- base::invokeRestart
[08:24:52.008]                       is.null <- base::is.null
[08:24:52.008]                       muffled <- FALSE
[08:24:52.008]                       if (inherits(cond, "message")) {
[08:24:52.008]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.008]                         if (muffled) 
[08:24:52.008]                           invokeRestart("muffleMessage")
[08:24:52.008]                       }
[08:24:52.008]                       else if (inherits(cond, "warning")) {
[08:24:52.008]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.008]                         if (muffled) 
[08:24:52.008]                           invokeRestart("muffleWarning")
[08:24:52.008]                       }
[08:24:52.008]                       else if (inherits(cond, "condition")) {
[08:24:52.008]                         if (!is.null(pattern)) {
[08:24:52.008]                           computeRestarts <- base::computeRestarts
[08:24:52.008]                           grepl <- base::grepl
[08:24:52.008]                           restarts <- computeRestarts(cond)
[08:24:52.008]                           for (restart in restarts) {
[08:24:52.008]                             name <- restart$name
[08:24:52.008]                             if (is.null(name)) 
[08:24:52.008]                               next
[08:24:52.008]                             if (!grepl(pattern, name)) 
[08:24:52.008]                               next
[08:24:52.008]                             invokeRestart(restart)
[08:24:52.008]                             muffled <- TRUE
[08:24:52.008]                             break
[08:24:52.008]                           }
[08:24:52.008]                         }
[08:24:52.008]                       }
[08:24:52.008]                       invisible(muffled)
[08:24:52.008]                     }
[08:24:52.008]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.008]                   }
[08:24:52.008]                 }
[08:24:52.008]             }
[08:24:52.008]         }))
[08:24:52.008]     }, error = function(ex) {
[08:24:52.008]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.008]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.008]                 ...future.rng), started = ...future.startTime, 
[08:24:52.008]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.008]             version = "1.8"), class = "FutureResult")
[08:24:52.008]     }, finally = {
[08:24:52.008]         if (!identical(...future.workdir, getwd())) 
[08:24:52.008]             setwd(...future.workdir)
[08:24:52.008]         {
[08:24:52.008]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.008]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.008]             }
[08:24:52.008]             base::options(...future.oldOptions)
[08:24:52.008]             if (.Platform$OS.type == "windows") {
[08:24:52.008]                 old_names <- names(...future.oldEnvVars)
[08:24:52.008]                 envs <- base::Sys.getenv()
[08:24:52.008]                 names <- names(envs)
[08:24:52.008]                 common <- intersect(names, old_names)
[08:24:52.008]                 added <- setdiff(names, old_names)
[08:24:52.008]                 removed <- setdiff(old_names, names)
[08:24:52.008]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.008]                   envs[common]]
[08:24:52.008]                 NAMES <- toupper(changed)
[08:24:52.008]                 args <- list()
[08:24:52.008]                 for (kk in seq_along(NAMES)) {
[08:24:52.008]                   name <- changed[[kk]]
[08:24:52.008]                   NAME <- NAMES[[kk]]
[08:24:52.008]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.008]                     next
[08:24:52.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.008]                 }
[08:24:52.008]                 NAMES <- toupper(added)
[08:24:52.008]                 for (kk in seq_along(NAMES)) {
[08:24:52.008]                   name <- added[[kk]]
[08:24:52.008]                   NAME <- NAMES[[kk]]
[08:24:52.008]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.008]                     next
[08:24:52.008]                   args[[name]] <- ""
[08:24:52.008]                 }
[08:24:52.008]                 NAMES <- toupper(removed)
[08:24:52.008]                 for (kk in seq_along(NAMES)) {
[08:24:52.008]                   name <- removed[[kk]]
[08:24:52.008]                   NAME <- NAMES[[kk]]
[08:24:52.008]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.008]                     next
[08:24:52.008]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.008]                 }
[08:24:52.008]                 if (length(args) > 0) 
[08:24:52.008]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.008]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.008]             }
[08:24:52.008]             else {
[08:24:52.008]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.008]             }
[08:24:52.008]             {
[08:24:52.008]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.008]                   0L) {
[08:24:52.008]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.008]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.008]                   base::options(opts)
[08:24:52.008]                 }
[08:24:52.008]                 {
[08:24:52.008]                   {
[08:24:52.008]                     NULL
[08:24:52.008]                     RNGkind("Mersenne-Twister")
[08:24:52.008]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:52.008]                       inherits = FALSE)
[08:24:52.008]                   }
[08:24:52.008]                   options(future.plan = NULL)
[08:24:52.008]                   if (is.na(NA_character_)) 
[08:24:52.008]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.008]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.008]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.008]                     .init = FALSE)
[08:24:52.008]                 }
[08:24:52.008]             }
[08:24:52.008]         }
[08:24:52.008]     })
[08:24:52.008]     if (TRUE) {
[08:24:52.008]         base::sink(type = "output", split = FALSE)
[08:24:52.008]         if (TRUE) {
[08:24:52.008]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.008]         }
[08:24:52.008]         else {
[08:24:52.008]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.008]         }
[08:24:52.008]         base::close(...future.stdout)
[08:24:52.008]         ...future.stdout <- NULL
[08:24:52.008]     }
[08:24:52.008]     ...future.result$conditions <- ...future.conditions
[08:24:52.008]     ...future.result$finished <- base::Sys.time()
[08:24:52.008]     ...future.result
[08:24:52.008] }
[08:24:52.010] assign_globals() ...
[08:24:52.010] List of 5
[08:24:52.010]  $ future.call.arguments    : list()
[08:24:52.010]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.010]  $ ...future.FUN            :function (x)  
[08:24:52.010]  $ ...future.elements_ii    :List of 6
[08:24:52.010]   ..$ : int [1:4] 1 7 13 19
[08:24:52.010]   ..$ : int [1:4] 2 8 14 20
[08:24:52.010]   ..$ : int [1:4] 3 9 15 21
[08:24:52.010]   ..$ : int [1:4] 4 10 16 22
[08:24:52.010]   ..$ : int [1:4] 5 11 17 23
[08:24:52.010]   ..$ : int [1:4] 6 12 18 24
[08:24:52.010]  $ ...future.seeds_ii       : NULL
[08:24:52.010]  $ ...future.globals.maxSize: num Inf
[08:24:52.010]  - attr(*, "resolved")= logi FALSE
[08:24:52.010]  - attr(*, "total_size")= num NA
[08:24:52.010]  - attr(*, "where")=List of 5
[08:24:52.010]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.010]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.010]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.010]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.010]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.010]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.010]  - attr(*, "already-done")= logi TRUE
[08:24:52.018] - copied ‘future.call.arguments’ to environment
[08:24:52.018] - reassign environment for ‘...future.FUN’
[08:24:52.018] - copied ‘...future.FUN’ to environment
[08:24:52.018] - copied ‘...future.elements_ii’ to environment
[08:24:52.018] - copied ‘...future.seeds_ii’ to environment
[08:24:52.018] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.018] assign_globals() ... done
[08:24:52.018] plan(): Setting new future strategy stack:
[08:24:52.019] List of future strategies:
[08:24:52.019] 1. sequential:
[08:24:52.019]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.019]    - tweaked: FALSE
[08:24:52.019]    - call: NULL
[08:24:52.019] plan(): nbrOfWorkers() = 1
[08:24:52.020] plan(): Setting new future strategy stack:
[08:24:52.020] List of future strategies:
[08:24:52.020] 1. sequential:
[08:24:52.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.020]    - tweaked: FALSE
[08:24:52.020]    - call: plan(strategy)
[08:24:52.020] plan(): nbrOfWorkers() = 1
[08:24:52.020] SequentialFuture started (and completed)
[08:24:52.021] - Launch lazy future ... done
[08:24:52.021] run() for ‘SequentialFuture’ ... done
[08:24:52.021] Created future:
[08:24:52.021] SequentialFuture:
[08:24:52.021] Label: ‘future_apply-1’
[08:24:52.021] Expression:
[08:24:52.021] {
[08:24:52.021]     do.call(function(...) {
[08:24:52.021]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.021]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.021]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.021]             on.exit(options(oopts), add = TRUE)
[08:24:52.021]         }
[08:24:52.021]         {
[08:24:52.021]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.021]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.021]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.021]             })
[08:24:52.021]         }
[08:24:52.021]     }, args = future.call.arguments)
[08:24:52.021] }
[08:24:52.021] Lazy evaluation: FALSE
[08:24:52.021] Asynchronous evaluation: FALSE
[08:24:52.021] Local evaluation: TRUE
[08:24:52.021] Environment: R_GlobalEnv
[08:24:52.021] Capture standard output: TRUE
[08:24:52.021] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.021] Globals: 5 objects totaling 749 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 175 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.021] Packages: <none>
[08:24:52.021] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.021] Resolved: TRUE
[08:24:52.021] Value: 521 bytes of class ‘list’
[08:24:52.021] Early signaling: FALSE
[08:24:52.021] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.021] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.022] Chunk #1 of 1 ... DONE
[08:24:52.022] Launching 1 futures (chunks) ... DONE
[08:24:52.022] Resolving 1 futures (chunks) ...
[08:24:52.022] resolve() on list ...
[08:24:52.022]  recursive: 0
[08:24:52.022]  length: 1
[08:24:52.022] 
[08:24:52.022] resolved() for ‘SequentialFuture’ ...
[08:24:52.022] - state: ‘finished’
[08:24:52.023] - run: TRUE
[08:24:52.023] - result: ‘FutureResult’
[08:24:52.023] resolved() for ‘SequentialFuture’ ... done
[08:24:52.023] Future #1
[08:24:52.023] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:52.023] - nx: 1
[08:24:52.023] - relay: TRUE
[08:24:52.023] - stdout: TRUE
[08:24:52.023] - signal: TRUE
[08:24:52.023] - resignal: FALSE
[08:24:52.023] - force: TRUE
[08:24:52.023] - relayed: [n=1] FALSE
[08:24:52.024] - queued futures: [n=1] FALSE
[08:24:52.024]  - until=1
[08:24:52.024]  - relaying element #1
[08:24:52.024] - relayed: [n=1] TRUE
[08:24:52.024] - queued futures: [n=1] TRUE
[08:24:52.024] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:52.024]  length: 0 (resolved future 1)
[08:24:52.024] Relaying remaining futures
[08:24:52.024] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.024] - nx: 1
[08:24:52.025] - relay: TRUE
[08:24:52.025] - stdout: TRUE
[08:24:52.025] - signal: TRUE
[08:24:52.025] - resignal: FALSE
[08:24:52.025] - force: TRUE
[08:24:52.025] - relayed: [n=1] TRUE
[08:24:52.025] - queued futures: [n=1] TRUE
 - flush all
[08:24:52.025] - relayed: [n=1] TRUE
[08:24:52.025] - queued futures: [n=1] TRUE
[08:24:52.025] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.025] resolve() on list ... DONE
[08:24:52.026]  - Number of value chunks collected: 1
[08:24:52.026] Resolving 1 futures (chunks) ... DONE
[08:24:52.026] Reducing values from 1 chunks ...
[08:24:52.026]  - Number of values collected after concatenation: 6
[08:24:52.026]  - Number of values expected: 6
[08:24:52.026] Reducing values from 1 chunks ... DONE
[08:24:52.026] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[08:24:52.026] getGlobalsAndPackagesXApply() ...
[08:24:52.026]  - future.globals: TRUE
[08:24:52.026] getGlobalsAndPackages() ...
[08:24:52.027] Searching for globals...
[08:24:52.028] - globals found: [1] ‘FUN’
[08:24:52.028] Searching for globals ... DONE
[08:24:52.028] Resolving globals: FALSE
[08:24:52.028] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:52.028] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:52.028] - globals: [1] ‘FUN’
[08:24:52.029] 
[08:24:52.029] getGlobalsAndPackages() ... DONE
[08:24:52.029]  - globals found/used: [n=1] ‘FUN’
[08:24:52.029]  - needed namespaces: [n=0] 
[08:24:52.029] Finding globals ... DONE
[08:24:52.029]  - use_args: TRUE
[08:24:52.029]  - Getting '...' globals ...
[08:24:52.029] resolve() on list ...
[08:24:52.029]  recursive: 0
[08:24:52.030]  length: 1
[08:24:52.030]  elements: ‘...’
[08:24:52.030]  length: 0 (resolved future 1)
[08:24:52.030] resolve() on list ... DONE
[08:24:52.030]    - '...' content: [n=0] 
[08:24:52.030] List of 1
[08:24:52.030]  $ ...: list()
[08:24:52.030]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.030]  - attr(*, "where")=List of 1
[08:24:52.030]   ..$ ...:<environment: 0x56540e0ee4f0> 
[08:24:52.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.030]  - attr(*, "resolved")= logi TRUE
[08:24:52.030]  - attr(*, "total_size")= num NA
[08:24:52.032]  - Getting '...' globals ... DONE
[08:24:52.033] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.033] List of 2
[08:24:52.033]  $ ...future.FUN:function (x)  
[08:24:52.033]  $ ...          : list()
[08:24:52.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.033]  - attr(*, "where")=List of 2
[08:24:52.033]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.033]   ..$ ...          :<environment: 0x56540e0ee4f0> 
[08:24:52.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.033]  - attr(*, "resolved")= logi FALSE
[08:24:52.033]  - attr(*, "total_size")= num 2547
[08:24:52.067] Packages to be attached in all futures: [n=0] 
[08:24:52.067] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.067] future_lapply() ...
[08:24:52.067] Number of chunks: 1
[08:24:52.068] getGlobalsAndPackagesXApply() ...
[08:24:52.068]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.068]  - use_args: TRUE
[08:24:52.068] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.068] List of 2
[08:24:52.068]  $ ...          : list()
[08:24:52.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.068]  $ ...future.FUN:function (x)  
[08:24:52.068]  - attr(*, "where")=List of 2
[08:24:52.068]   ..$ ...          :<environment: 0x56540e0ee4f0> 
[08:24:52.068]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:52.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.068]  - attr(*, "resolved")= logi FALSE
[08:24:52.068]  - attr(*, "total_size")= num NA
[08:24:52.071] Packages to be attached in all futures: [n=0] 
[08:24:52.071] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.072] Number of futures (= number of chunks): 1
[08:24:52.072] Launching 1 futures (chunks) ...
[08:24:52.072] Chunk #1 of 1 ...
[08:24:52.072]  - seeds: <none>
[08:24:52.072]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.072] getGlobalsAndPackages() ...
[08:24:52.072] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.072] Resolving globals: FALSE
[08:24:52.073] Tweak future expression to call with '...' arguments ...
[08:24:52.073] {
[08:24:52.073]     do.call(function(...) {
[08:24:52.073]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.073]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.073]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.073]             on.exit(options(oopts), add = TRUE)
[08:24:52.073]         }
[08:24:52.073]         {
[08:24:52.073]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.073]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.073]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.073]             })
[08:24:52.073]         }
[08:24:52.073]     }, args = future.call.arguments)
[08:24:52.073] }
[08:24:52.073] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.073] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.073] 
[08:24:52.074] getGlobalsAndPackages() ... DONE
[08:24:52.074] run() for ‘Future’ ...
[08:24:52.074] - state: ‘created’
[08:24:52.074] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:52.074] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.074] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:52.075]   - Field: ‘label’
[08:24:52.075]   - Field: ‘local’
[08:24:52.075]   - Field: ‘owner’
[08:24:52.075]   - Field: ‘envir’
[08:24:52.075]   - Field: ‘packages’
[08:24:52.075]   - Field: ‘gc’
[08:24:52.075]   - Field: ‘conditions’
[08:24:52.075]   - Field: ‘expr’
[08:24:52.075]   - Field: ‘uuid’
[08:24:52.075]   - Field: ‘seed’
[08:24:52.075]   - Field: ‘version’
[08:24:52.076]   - Field: ‘result’
[08:24:52.076]   - Field: ‘asynchronous’
[08:24:52.076]   - Field: ‘calls’
[08:24:52.076]   - Field: ‘globals’
[08:24:52.076]   - Field: ‘stdout’
[08:24:52.076]   - Field: ‘earlySignal’
[08:24:52.076]   - Field: ‘lazy’
[08:24:52.076]   - Field: ‘state’
[08:24:52.076] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:52.076] - Launch lazy future ...
[08:24:52.076] Packages needed by the future expression (n = 0): <none>
[08:24:52.077] Packages needed by future strategies (n = 0): <none>
[08:24:52.077] {
[08:24:52.077]     {
[08:24:52.077]         {
[08:24:52.077]             ...future.startTime <- base::Sys.time()
[08:24:52.077]             {
[08:24:52.077]                 {
[08:24:52.077]                   {
[08:24:52.077]                     base::local({
[08:24:52.077]                       has_future <- base::requireNamespace("future", 
[08:24:52.077]                         quietly = TRUE)
[08:24:52.077]                       if (has_future) {
[08:24:52.077]                         ns <- base::getNamespace("future")
[08:24:52.077]                         version <- ns[[".package"]][["version"]]
[08:24:52.077]                         if (is.null(version)) 
[08:24:52.077]                           version <- utils::packageVersion("future")
[08:24:52.077]                       }
[08:24:52.077]                       else {
[08:24:52.077]                         version <- NULL
[08:24:52.077]                       }
[08:24:52.077]                       if (!has_future || version < "1.8.0") {
[08:24:52.077]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.077]                           "", base::R.version$version.string), 
[08:24:52.077]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:52.077]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.077]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.077]                             "release", "version")], collapse = " "), 
[08:24:52.077]                           hostname = base::Sys.info()[["nodename"]])
[08:24:52.077]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.077]                           info)
[08:24:52.077]                         info <- base::paste(info, collapse = "; ")
[08:24:52.077]                         if (!has_future) {
[08:24:52.077]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.077]                             info)
[08:24:52.077]                         }
[08:24:52.077]                         else {
[08:24:52.077]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.077]                             info, version)
[08:24:52.077]                         }
[08:24:52.077]                         base::stop(msg)
[08:24:52.077]                       }
[08:24:52.077]                     })
[08:24:52.077]                   }
[08:24:52.077]                   ...future.strategy.old <- future::plan("list")
[08:24:52.077]                   options(future.plan = NULL)
[08:24:52.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.077]                 }
[08:24:52.077]                 ...future.workdir <- getwd()
[08:24:52.077]             }
[08:24:52.077]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.077]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.077]         }
[08:24:52.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.077]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.077]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.077]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.077]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.077]             base::names(...future.oldOptions))
[08:24:52.077]     }
[08:24:52.077]     if (FALSE) {
[08:24:52.077]     }
[08:24:52.077]     else {
[08:24:52.077]         if (TRUE) {
[08:24:52.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.077]                 open = "w")
[08:24:52.077]         }
[08:24:52.077]         else {
[08:24:52.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.077]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.077]         }
[08:24:52.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.077]             base::sink(type = "output", split = FALSE)
[08:24:52.077]             base::close(...future.stdout)
[08:24:52.077]         }, add = TRUE)
[08:24:52.077]     }
[08:24:52.077]     ...future.frame <- base::sys.nframe()
[08:24:52.077]     ...future.conditions <- base::list()
[08:24:52.077]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.077]     if (FALSE) {
[08:24:52.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.077]     }
[08:24:52.077]     ...future.result <- base::tryCatch({
[08:24:52.077]         base::withCallingHandlers({
[08:24:52.077]             ...future.value <- base::withVisible(base::local({
[08:24:52.077]                 do.call(function(...) {
[08:24:52.077]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.077]                   if (!identical(...future.globals.maxSize.org, 
[08:24:52.077]                     ...future.globals.maxSize)) {
[08:24:52.077]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.077]                     on.exit(options(oopts), add = TRUE)
[08:24:52.077]                   }
[08:24:52.077]                   {
[08:24:52.077]                     lapply(seq_along(...future.elements_ii), 
[08:24:52.077]                       FUN = function(jj) {
[08:24:52.077]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.077]                         ...future.FUN(...future.X_jj, ...)
[08:24:52.077]                       })
[08:24:52.077]                   }
[08:24:52.077]                 }, args = future.call.arguments)
[08:24:52.077]             }))
[08:24:52.077]             future::FutureResult(value = ...future.value$value, 
[08:24:52.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.077]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.077]                     ...future.globalenv.names))
[08:24:52.077]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.077]         }, condition = base::local({
[08:24:52.077]             c <- base::c
[08:24:52.077]             inherits <- base::inherits
[08:24:52.077]             invokeRestart <- base::invokeRestart
[08:24:52.077]             length <- base::length
[08:24:52.077]             list <- base::list
[08:24:52.077]             seq.int <- base::seq.int
[08:24:52.077]             signalCondition <- base::signalCondition
[08:24:52.077]             sys.calls <- base::sys.calls
[08:24:52.077]             `[[` <- base::`[[`
[08:24:52.077]             `+` <- base::`+`
[08:24:52.077]             `<<-` <- base::`<<-`
[08:24:52.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.077]                   3L)]
[08:24:52.077]             }
[08:24:52.077]             function(cond) {
[08:24:52.077]                 is_error <- inherits(cond, "error")
[08:24:52.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.077]                   NULL)
[08:24:52.077]                 if (is_error) {
[08:24:52.077]                   sessionInformation <- function() {
[08:24:52.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.077]                       search = base::search(), system = base::Sys.info())
[08:24:52.077]                   }
[08:24:52.077]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.077]                     cond$call), session = sessionInformation(), 
[08:24:52.077]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.077]                   signalCondition(cond)
[08:24:52.077]                 }
[08:24:52.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.077]                 "immediateCondition"))) {
[08:24:52.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.077]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.077]                   if (TRUE && !signal) {
[08:24:52.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.077]                     {
[08:24:52.077]                       inherits <- base::inherits
[08:24:52.077]                       invokeRestart <- base::invokeRestart
[08:24:52.077]                       is.null <- base::is.null
[08:24:52.077]                       muffled <- FALSE
[08:24:52.077]                       if (inherits(cond, "message")) {
[08:24:52.077]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.077]                         if (muffled) 
[08:24:52.077]                           invokeRestart("muffleMessage")
[08:24:52.077]                       }
[08:24:52.077]                       else if (inherits(cond, "warning")) {
[08:24:52.077]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.077]                         if (muffled) 
[08:24:52.077]                           invokeRestart("muffleWarning")
[08:24:52.077]                       }
[08:24:52.077]                       else if (inherits(cond, "condition")) {
[08:24:52.077]                         if (!is.null(pattern)) {
[08:24:52.077]                           computeRestarts <- base::computeRestarts
[08:24:52.077]                           grepl <- base::grepl
[08:24:52.077]                           restarts <- computeRestarts(cond)
[08:24:52.077]                           for (restart in restarts) {
[08:24:52.077]                             name <- restart$name
[08:24:52.077]                             if (is.null(name)) 
[08:24:52.077]                               next
[08:24:52.077]                             if (!grepl(pattern, name)) 
[08:24:52.077]                               next
[08:24:52.077]                             invokeRestart(restart)
[08:24:52.077]                             muffled <- TRUE
[08:24:52.077]                             break
[08:24:52.077]                           }
[08:24:52.077]                         }
[08:24:52.077]                       }
[08:24:52.077]                       invisible(muffled)
[08:24:52.077]                     }
[08:24:52.077]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.077]                   }
[08:24:52.077]                 }
[08:24:52.077]                 else {
[08:24:52.077]                   if (TRUE) {
[08:24:52.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.077]                     {
[08:24:52.077]                       inherits <- base::inherits
[08:24:52.077]                       invokeRestart <- base::invokeRestart
[08:24:52.077]                       is.null <- base::is.null
[08:24:52.077]                       muffled <- FALSE
[08:24:52.077]                       if (inherits(cond, "message")) {
[08:24:52.077]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.077]                         if (muffled) 
[08:24:52.077]                           invokeRestart("muffleMessage")
[08:24:52.077]                       }
[08:24:52.077]                       else if (inherits(cond, "warning")) {
[08:24:52.077]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.077]                         if (muffled) 
[08:24:52.077]                           invokeRestart("muffleWarning")
[08:24:52.077]                       }
[08:24:52.077]                       else if (inherits(cond, "condition")) {
[08:24:52.077]                         if (!is.null(pattern)) {
[08:24:52.077]                           computeRestarts <- base::computeRestarts
[08:24:52.077]                           grepl <- base::grepl
[08:24:52.077]                           restarts <- computeRestarts(cond)
[08:24:52.077]                           for (restart in restarts) {
[08:24:52.077]                             name <- restart$name
[08:24:52.077]                             if (is.null(name)) 
[08:24:52.077]                               next
[08:24:52.077]                             if (!grepl(pattern, name)) 
[08:24:52.077]                               next
[08:24:52.077]                             invokeRestart(restart)
[08:24:52.077]                             muffled <- TRUE
[08:24:52.077]                             break
[08:24:52.077]                           }
[08:24:52.077]                         }
[08:24:52.077]                       }
[08:24:52.077]                       invisible(muffled)
[08:24:52.077]                     }
[08:24:52.077]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.077]                   }
[08:24:52.077]                 }
[08:24:52.077]             }
[08:24:52.077]         }))
[08:24:52.077]     }, error = function(ex) {
[08:24:52.077]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.077]                 ...future.rng), started = ...future.startTime, 
[08:24:52.077]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.077]             version = "1.8"), class = "FutureResult")
[08:24:52.077]     }, finally = {
[08:24:52.077]         if (!identical(...future.workdir, getwd())) 
[08:24:52.077]             setwd(...future.workdir)
[08:24:52.077]         {
[08:24:52.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.077]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.077]             }
[08:24:52.077]             base::options(...future.oldOptions)
[08:24:52.077]             if (.Platform$OS.type == "windows") {
[08:24:52.077]                 old_names <- names(...future.oldEnvVars)
[08:24:52.077]                 envs <- base::Sys.getenv()
[08:24:52.077]                 names <- names(envs)
[08:24:52.077]                 common <- intersect(names, old_names)
[08:24:52.077]                 added <- setdiff(names, old_names)
[08:24:52.077]                 removed <- setdiff(old_names, names)
[08:24:52.077]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.077]                   envs[common]]
[08:24:52.077]                 NAMES <- toupper(changed)
[08:24:52.077]                 args <- list()
[08:24:52.077]                 for (kk in seq_along(NAMES)) {
[08:24:52.077]                   name <- changed[[kk]]
[08:24:52.077]                   NAME <- NAMES[[kk]]
[08:24:52.077]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.077]                     next
[08:24:52.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.077]                 }
[08:24:52.077]                 NAMES <- toupper(added)
[08:24:52.077]                 for (kk in seq_along(NAMES)) {
[08:24:52.077]                   name <- added[[kk]]
[08:24:52.077]                   NAME <- NAMES[[kk]]
[08:24:52.077]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.077]                     next
[08:24:52.077]                   args[[name]] <- ""
[08:24:52.077]                 }
[08:24:52.077]                 NAMES <- toupper(removed)
[08:24:52.077]                 for (kk in seq_along(NAMES)) {
[08:24:52.077]                   name <- removed[[kk]]
[08:24:52.077]                   NAME <- NAMES[[kk]]
[08:24:52.077]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.077]                     next
[08:24:52.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.077]                 }
[08:24:52.077]                 if (length(args) > 0) 
[08:24:52.077]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.077]             }
[08:24:52.077]             else {
[08:24:52.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.077]             }
[08:24:52.077]             {
[08:24:52.077]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.077]                   0L) {
[08:24:52.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.077]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.077]                   base::options(opts)
[08:24:52.077]                 }
[08:24:52.077]                 {
[08:24:52.077]                   {
[08:24:52.077]                     NULL
[08:24:52.077]                     RNGkind("Mersenne-Twister")
[08:24:52.077]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:52.077]                       inherits = FALSE)
[08:24:52.077]                   }
[08:24:52.077]                   options(future.plan = NULL)
[08:24:52.077]                   if (is.na(NA_character_)) 
[08:24:52.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.077]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.077]                     .init = FALSE)
[08:24:52.077]                 }
[08:24:52.077]             }
[08:24:52.077]         }
[08:24:52.077]     })
[08:24:52.077]     if (TRUE) {
[08:24:52.077]         base::sink(type = "output", split = FALSE)
[08:24:52.077]         if (TRUE) {
[08:24:52.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.077]         }
[08:24:52.077]         else {
[08:24:52.077]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.077]         }
[08:24:52.077]         base::close(...future.stdout)
[08:24:52.077]         ...future.stdout <- NULL
[08:24:52.077]     }
[08:24:52.077]     ...future.result$conditions <- ...future.conditions
[08:24:52.077]     ...future.result$finished <- base::Sys.time()
[08:24:52.077]     ...future.result
[08:24:52.077] }
[08:24:52.079] assign_globals() ...
[08:24:52.079] List of 5
[08:24:52.079]  $ future.call.arguments    : list()
[08:24:52.079]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.079]  $ ...future.FUN            :function (x)  
[08:24:52.079]  $ ...future.elements_ii    :List of 2
[08:24:52.079]   ..$ : int 1
[08:24:52.079]   ..$ : int 2
[08:24:52.079]  $ ...future.seeds_ii       : NULL
[08:24:52.079]  $ ...future.globals.maxSize: num Inf
[08:24:52.079]  - attr(*, "resolved")= logi FALSE
[08:24:52.079]  - attr(*, "total_size")= num NA
[08:24:52.079]  - attr(*, "where")=List of 5
[08:24:52.079]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.079]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.079]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.079]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.079]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.079]  - attr(*, "already-done")= logi TRUE
[08:24:52.084] - copied ‘future.call.arguments’ to environment
[08:24:52.084] - copied ‘...future.FUN’ to environment
[08:24:52.084] - copied ‘...future.elements_ii’ to environment
[08:24:52.084] - copied ‘...future.seeds_ii’ to environment
[08:24:52.084] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.084] assign_globals() ... done
[08:24:52.085] plan(): Setting new future strategy stack:
[08:24:52.085] List of future strategies:
[08:24:52.085] 1. sequential:
[08:24:52.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.085]    - tweaked: FALSE
[08:24:52.085]    - call: NULL
[08:24:52.085] plan(): nbrOfWorkers() = 1
[08:24:52.086] plan(): Setting new future strategy stack:
[08:24:52.086] List of future strategies:
[08:24:52.086] 1. sequential:
[08:24:52.086]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.086]    - tweaked: FALSE
[08:24:52.086]    - call: plan(strategy)
[08:24:52.087] plan(): nbrOfWorkers() = 1
[08:24:52.087] SequentialFuture started (and completed)
[08:24:52.087] - Launch lazy future ... done
[08:24:52.087] run() for ‘SequentialFuture’ ... done
[08:24:52.087] Created future:
[08:24:52.087] SequentialFuture:
[08:24:52.087] Label: ‘future_apply-1’
[08:24:52.087] Expression:
[08:24:52.087] {
[08:24:52.087]     do.call(function(...) {
[08:24:52.087]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.087]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.087]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.087]             on.exit(options(oopts), add = TRUE)
[08:24:52.087]         }
[08:24:52.087]         {
[08:24:52.087]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.087]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.087]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.087]             })
[08:24:52.087]         }
[08:24:52.087]     }, args = future.call.arguments)
[08:24:52.087] }
[08:24:52.087] Lazy evaluation: FALSE
[08:24:52.087] Asynchronous evaluation: FALSE
[08:24:52.087] Local evaluation: TRUE
[08:24:52.087] Environment: R_GlobalEnv
[08:24:52.087] Capture standard output: TRUE
[08:24:52.087] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.087] Globals: 5 objects totaling 403 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.087] Packages: <none>
[08:24:52.087] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.087] Resolved: TRUE
[08:24:52.087] Value: 55 bytes of class ‘list’
[08:24:52.087] Early signaling: FALSE
[08:24:52.087] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.087] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.088] Chunk #1 of 1 ... DONE
[08:24:52.088] Launching 1 futures (chunks) ... DONE
[08:24:52.088] Resolving 1 futures (chunks) ...
[08:24:52.088] resolve() on list ...
[08:24:52.088]  recursive: 0
[08:24:52.088]  length: 1
[08:24:52.089] 
[08:24:52.089] resolved() for ‘SequentialFuture’ ...
[08:24:52.089] - state: ‘finished’
[08:24:52.089] - run: TRUE
[08:24:52.089] - result: ‘FutureResult’
[08:24:52.089] resolved() for ‘SequentialFuture’ ... done
[08:24:52.089] Future #1
[08:24:52.091] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:52.091] - nx: 1
[08:24:52.091] - relay: TRUE
[08:24:52.091] - stdout: TRUE
[08:24:52.091] - signal: TRUE
[08:24:52.091] - resignal: FALSE
[08:24:52.091] - force: TRUE
[08:24:52.091] - relayed: [n=1] FALSE
[08:24:52.091] - queued futures: [n=1] FALSE
[08:24:52.092]  - until=1
[08:24:52.092]  - relaying element #1
[08:24:52.092] - relayed: [n=1] TRUE
[08:24:52.092] - queued futures: [n=1] TRUE
[08:24:52.092] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:52.092]  length: 0 (resolved future 1)
[08:24:52.092] Relaying remaining futures
[08:24:52.092] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.093] - nx: 1
[08:24:52.093] - relay: TRUE
[08:24:52.093] - stdout: TRUE
[08:24:52.093] - signal: TRUE
[08:24:52.093] - resignal: FALSE
[08:24:52.093] - force: TRUE
[08:24:52.093] - relayed: [n=1] TRUE
[08:24:52.093] - queued futures: [n=1] TRUE
 - flush all
[08:24:52.093] - relayed: [n=1] TRUE
[08:24:52.093] - queued futures: [n=1] TRUE
[08:24:52.093] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.093] resolve() on list ... DONE
[08:24:52.094]  - Number of value chunks collected: 1
[08:24:52.094] Resolving 1 futures (chunks) ... DONE
[08:24:52.094] Reducing values from 1 chunks ...
[08:24:52.094]  - Number of values collected after concatenation: 2
[08:24:52.094]  - Number of values expected: 2
[08:24:52.094] Reducing values from 1 chunks ... DONE
[08:24:52.094] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[08:24:52.094] getGlobalsAndPackagesXApply() ...
[08:24:52.094]  - future.globals: TRUE
[08:24:52.095] getGlobalsAndPackages() ...
[08:24:52.095] Searching for globals...
[08:24:52.096] - globals found: [1] ‘FUN’
[08:24:52.096] Searching for globals ... DONE
[08:24:52.096] Resolving globals: FALSE
[08:24:52.096] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:52.096] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:52.097] - globals: [1] ‘FUN’
[08:24:52.097] 
[08:24:52.097] getGlobalsAndPackages() ... DONE
[08:24:52.097]  - globals found/used: [n=1] ‘FUN’
[08:24:52.097]  - needed namespaces: [n=0] 
[08:24:52.097] Finding globals ... DONE
[08:24:52.097]  - use_args: TRUE
[08:24:52.097]  - Getting '...' globals ...
[08:24:52.098] resolve() on list ...
[08:24:52.098]  recursive: 0
[08:24:52.098]  length: 1
[08:24:52.098]  elements: ‘...’
[08:24:52.098]  length: 0 (resolved future 1)
[08:24:52.098] resolve() on list ... DONE
[08:24:52.098]    - '...' content: [n=0] 
[08:24:52.098] List of 1
[08:24:52.098]  $ ...: list()
[08:24:52.098]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.098]  - attr(*, "where")=List of 1
[08:24:52.098]   ..$ ...:<environment: 0x56540c9ae6a8> 
[08:24:52.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.098]  - attr(*, "resolved")= logi TRUE
[08:24:52.098]  - attr(*, "total_size")= num NA
[08:24:52.100]  - Getting '...' globals ... DONE
[08:24:52.101] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.101] List of 2
[08:24:52.101]  $ ...future.FUN:function (x)  
[08:24:52.101]  $ ...          : list()
[08:24:52.101]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.101]  - attr(*, "where")=List of 2
[08:24:52.101]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.101]   ..$ ...          :<environment: 0x56540c9ae6a8> 
[08:24:52.101]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.101]  - attr(*, "resolved")= logi FALSE
[08:24:52.101]  - attr(*, "total_size")= num 2274
[08:24:52.103] Packages to be attached in all futures: [n=0] 
[08:24:52.103] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.104] future_lapply() ...
[08:24:52.104] Number of chunks: 1
[08:24:52.104] getGlobalsAndPackagesXApply() ...
[08:24:52.104]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.104]  - use_args: TRUE
[08:24:52.105] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.105] List of 2
[08:24:52.105]  $ ...          : list()
[08:24:52.105]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.105]  $ ...future.FUN:function (x)  
[08:24:52.105]  - attr(*, "where")=List of 2
[08:24:52.105]   ..$ ...          :<environment: 0x56540c9ae6a8> 
[08:24:52.105]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:52.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.105]  - attr(*, "resolved")= logi FALSE
[08:24:52.105]  - attr(*, "total_size")= num NA
[08:24:52.108] Packages to be attached in all futures: [n=0] 
[08:24:52.108] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.108] Number of futures (= number of chunks): 1
[08:24:52.108] Launching 1 futures (chunks) ...
[08:24:52.108] Chunk #1 of 1 ...
[08:24:52.108]  - seeds: <none>
[08:24:52.109]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.109] getGlobalsAndPackages() ...
[08:24:52.109] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.109] Resolving globals: FALSE
[08:24:52.109] Tweak future expression to call with '...' arguments ...
[08:24:52.109] {
[08:24:52.109]     do.call(function(...) {
[08:24:52.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.109]             on.exit(options(oopts), add = TRUE)
[08:24:52.109]         }
[08:24:52.109]         {
[08:24:52.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.109]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.109]             })
[08:24:52.109]         }
[08:24:52.109]     }, args = future.call.arguments)
[08:24:52.109] }
[08:24:52.109] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.110] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.110] 
[08:24:52.110] getGlobalsAndPackages() ... DONE
[08:24:52.110] run() for ‘Future’ ...
[08:24:52.110] - state: ‘created’
[08:24:52.110] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:52.111] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:52.111]   - Field: ‘label’
[08:24:52.111]   - Field: ‘local’
[08:24:52.111]   - Field: ‘owner’
[08:24:52.111]   - Field: ‘envir’
[08:24:52.111]   - Field: ‘packages’
[08:24:52.111]   - Field: ‘gc’
[08:24:52.111]   - Field: ‘conditions’
[08:24:52.112]   - Field: ‘expr’
[08:24:52.112]   - Field: ‘uuid’
[08:24:52.112]   - Field: ‘seed’
[08:24:52.112]   - Field: ‘version’
[08:24:52.112]   - Field: ‘result’
[08:24:52.112]   - Field: ‘asynchronous’
[08:24:52.112]   - Field: ‘calls’
[08:24:52.112]   - Field: ‘globals’
[08:24:52.112]   - Field: ‘stdout’
[08:24:52.112]   - Field: ‘earlySignal’
[08:24:52.112]   - Field: ‘lazy’
[08:24:52.112]   - Field: ‘state’
[08:24:52.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:52.113] - Launch lazy future ...
[08:24:52.113] Packages needed by the future expression (n = 0): <none>
[08:24:52.113] Packages needed by future strategies (n = 0): <none>
[08:24:52.115] {
[08:24:52.115]     {
[08:24:52.115]         {
[08:24:52.115]             ...future.startTime <- base::Sys.time()
[08:24:52.115]             {
[08:24:52.115]                 {
[08:24:52.115]                   {
[08:24:52.115]                     base::local({
[08:24:52.115]                       has_future <- base::requireNamespace("future", 
[08:24:52.115]                         quietly = TRUE)
[08:24:52.115]                       if (has_future) {
[08:24:52.115]                         ns <- base::getNamespace("future")
[08:24:52.115]                         version <- ns[[".package"]][["version"]]
[08:24:52.115]                         if (is.null(version)) 
[08:24:52.115]                           version <- utils::packageVersion("future")
[08:24:52.115]                       }
[08:24:52.115]                       else {
[08:24:52.115]                         version <- NULL
[08:24:52.115]                       }
[08:24:52.115]                       if (!has_future || version < "1.8.0") {
[08:24:52.115]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.115]                           "", base::R.version$version.string), 
[08:24:52.115]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:52.115]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.115]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.115]                             "release", "version")], collapse = " "), 
[08:24:52.115]                           hostname = base::Sys.info()[["nodename"]])
[08:24:52.115]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.115]                           info)
[08:24:52.115]                         info <- base::paste(info, collapse = "; ")
[08:24:52.115]                         if (!has_future) {
[08:24:52.115]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.115]                             info)
[08:24:52.115]                         }
[08:24:52.115]                         else {
[08:24:52.115]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.115]                             info, version)
[08:24:52.115]                         }
[08:24:52.115]                         base::stop(msg)
[08:24:52.115]                       }
[08:24:52.115]                     })
[08:24:52.115]                   }
[08:24:52.115]                   ...future.strategy.old <- future::plan("list")
[08:24:52.115]                   options(future.plan = NULL)
[08:24:52.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.115]                 }
[08:24:52.115]                 ...future.workdir <- getwd()
[08:24:52.115]             }
[08:24:52.115]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.115]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.115]         }
[08:24:52.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.115]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.115]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.115]             base::names(...future.oldOptions))
[08:24:52.115]     }
[08:24:52.115]     if (FALSE) {
[08:24:52.115]     }
[08:24:52.115]     else {
[08:24:52.115]         if (TRUE) {
[08:24:52.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.115]                 open = "w")
[08:24:52.115]         }
[08:24:52.115]         else {
[08:24:52.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.115]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.115]         }
[08:24:52.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.115]             base::sink(type = "output", split = FALSE)
[08:24:52.115]             base::close(...future.stdout)
[08:24:52.115]         }, add = TRUE)
[08:24:52.115]     }
[08:24:52.115]     ...future.frame <- base::sys.nframe()
[08:24:52.115]     ...future.conditions <- base::list()
[08:24:52.115]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.115]     if (FALSE) {
[08:24:52.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.115]     }
[08:24:52.115]     ...future.result <- base::tryCatch({
[08:24:52.115]         base::withCallingHandlers({
[08:24:52.115]             ...future.value <- base::withVisible(base::local({
[08:24:52.115]                 do.call(function(...) {
[08:24:52.115]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.115]                   if (!identical(...future.globals.maxSize.org, 
[08:24:52.115]                     ...future.globals.maxSize)) {
[08:24:52.115]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.115]                     on.exit(options(oopts), add = TRUE)
[08:24:52.115]                   }
[08:24:52.115]                   {
[08:24:52.115]                     lapply(seq_along(...future.elements_ii), 
[08:24:52.115]                       FUN = function(jj) {
[08:24:52.115]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.115]                         ...future.FUN(...future.X_jj, ...)
[08:24:52.115]                       })
[08:24:52.115]                   }
[08:24:52.115]                 }, args = future.call.arguments)
[08:24:52.115]             }))
[08:24:52.115]             future::FutureResult(value = ...future.value$value, 
[08:24:52.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.115]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.115]                     ...future.globalenv.names))
[08:24:52.115]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.115]         }, condition = base::local({
[08:24:52.115]             c <- base::c
[08:24:52.115]             inherits <- base::inherits
[08:24:52.115]             invokeRestart <- base::invokeRestart
[08:24:52.115]             length <- base::length
[08:24:52.115]             list <- base::list
[08:24:52.115]             seq.int <- base::seq.int
[08:24:52.115]             signalCondition <- base::signalCondition
[08:24:52.115]             sys.calls <- base::sys.calls
[08:24:52.115]             `[[` <- base::`[[`
[08:24:52.115]             `+` <- base::`+`
[08:24:52.115]             `<<-` <- base::`<<-`
[08:24:52.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.115]                   3L)]
[08:24:52.115]             }
[08:24:52.115]             function(cond) {
[08:24:52.115]                 is_error <- inherits(cond, "error")
[08:24:52.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.115]                   NULL)
[08:24:52.115]                 if (is_error) {
[08:24:52.115]                   sessionInformation <- function() {
[08:24:52.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.115]                       search = base::search(), system = base::Sys.info())
[08:24:52.115]                   }
[08:24:52.115]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.115]                     cond$call), session = sessionInformation(), 
[08:24:52.115]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.115]                   signalCondition(cond)
[08:24:52.115]                 }
[08:24:52.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.115]                 "immediateCondition"))) {
[08:24:52.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.115]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.115]                   if (TRUE && !signal) {
[08:24:52.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.115]                     {
[08:24:52.115]                       inherits <- base::inherits
[08:24:52.115]                       invokeRestart <- base::invokeRestart
[08:24:52.115]                       is.null <- base::is.null
[08:24:52.115]                       muffled <- FALSE
[08:24:52.115]                       if (inherits(cond, "message")) {
[08:24:52.115]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.115]                         if (muffled) 
[08:24:52.115]                           invokeRestart("muffleMessage")
[08:24:52.115]                       }
[08:24:52.115]                       else if (inherits(cond, "warning")) {
[08:24:52.115]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.115]                         if (muffled) 
[08:24:52.115]                           invokeRestart("muffleWarning")
[08:24:52.115]                       }
[08:24:52.115]                       else if (inherits(cond, "condition")) {
[08:24:52.115]                         if (!is.null(pattern)) {
[08:24:52.115]                           computeRestarts <- base::computeRestarts
[08:24:52.115]                           grepl <- base::grepl
[08:24:52.115]                           restarts <- computeRestarts(cond)
[08:24:52.115]                           for (restart in restarts) {
[08:24:52.115]                             name <- restart$name
[08:24:52.115]                             if (is.null(name)) 
[08:24:52.115]                               next
[08:24:52.115]                             if (!grepl(pattern, name)) 
[08:24:52.115]                               next
[08:24:52.115]                             invokeRestart(restart)
[08:24:52.115]                             muffled <- TRUE
[08:24:52.115]                             break
[08:24:52.115]                           }
[08:24:52.115]                         }
[08:24:52.115]                       }
[08:24:52.115]                       invisible(muffled)
[08:24:52.115]                     }
[08:24:52.115]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.115]                   }
[08:24:52.115]                 }
[08:24:52.115]                 else {
[08:24:52.115]                   if (TRUE) {
[08:24:52.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.115]                     {
[08:24:52.115]                       inherits <- base::inherits
[08:24:52.115]                       invokeRestart <- base::invokeRestart
[08:24:52.115]                       is.null <- base::is.null
[08:24:52.115]                       muffled <- FALSE
[08:24:52.115]                       if (inherits(cond, "message")) {
[08:24:52.115]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.115]                         if (muffled) 
[08:24:52.115]                           invokeRestart("muffleMessage")
[08:24:52.115]                       }
[08:24:52.115]                       else if (inherits(cond, "warning")) {
[08:24:52.115]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.115]                         if (muffled) 
[08:24:52.115]                           invokeRestart("muffleWarning")
[08:24:52.115]                       }
[08:24:52.115]                       else if (inherits(cond, "condition")) {
[08:24:52.115]                         if (!is.null(pattern)) {
[08:24:52.115]                           computeRestarts <- base::computeRestarts
[08:24:52.115]                           grepl <- base::grepl
[08:24:52.115]                           restarts <- computeRestarts(cond)
[08:24:52.115]                           for (restart in restarts) {
[08:24:52.115]                             name <- restart$name
[08:24:52.115]                             if (is.null(name)) 
[08:24:52.115]                               next
[08:24:52.115]                             if (!grepl(pattern, name)) 
[08:24:52.115]                               next
[08:24:52.115]                             invokeRestart(restart)
[08:24:52.115]                             muffled <- TRUE
[08:24:52.115]                             break
[08:24:52.115]                           }
[08:24:52.115]                         }
[08:24:52.115]                       }
[08:24:52.115]                       invisible(muffled)
[08:24:52.115]                     }
[08:24:52.115]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.115]                   }
[08:24:52.115]                 }
[08:24:52.115]             }
[08:24:52.115]         }))
[08:24:52.115]     }, error = function(ex) {
[08:24:52.115]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.115]                 ...future.rng), started = ...future.startTime, 
[08:24:52.115]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.115]             version = "1.8"), class = "FutureResult")
[08:24:52.115]     }, finally = {
[08:24:52.115]         if (!identical(...future.workdir, getwd())) 
[08:24:52.115]             setwd(...future.workdir)
[08:24:52.115]         {
[08:24:52.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.115]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.115]             }
[08:24:52.115]             base::options(...future.oldOptions)
[08:24:52.115]             if (.Platform$OS.type == "windows") {
[08:24:52.115]                 old_names <- names(...future.oldEnvVars)
[08:24:52.115]                 envs <- base::Sys.getenv()
[08:24:52.115]                 names <- names(envs)
[08:24:52.115]                 common <- intersect(names, old_names)
[08:24:52.115]                 added <- setdiff(names, old_names)
[08:24:52.115]                 removed <- setdiff(old_names, names)
[08:24:52.115]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.115]                   envs[common]]
[08:24:52.115]                 NAMES <- toupper(changed)
[08:24:52.115]                 args <- list()
[08:24:52.115]                 for (kk in seq_along(NAMES)) {
[08:24:52.115]                   name <- changed[[kk]]
[08:24:52.115]                   NAME <- NAMES[[kk]]
[08:24:52.115]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.115]                     next
[08:24:52.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.115]                 }
[08:24:52.115]                 NAMES <- toupper(added)
[08:24:52.115]                 for (kk in seq_along(NAMES)) {
[08:24:52.115]                   name <- added[[kk]]
[08:24:52.115]                   NAME <- NAMES[[kk]]
[08:24:52.115]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.115]                     next
[08:24:52.115]                   args[[name]] <- ""
[08:24:52.115]                 }
[08:24:52.115]                 NAMES <- toupper(removed)
[08:24:52.115]                 for (kk in seq_along(NAMES)) {
[08:24:52.115]                   name <- removed[[kk]]
[08:24:52.115]                   NAME <- NAMES[[kk]]
[08:24:52.115]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.115]                     next
[08:24:52.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.115]                 }
[08:24:52.115]                 if (length(args) > 0) 
[08:24:52.115]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.115]             }
[08:24:52.115]             else {
[08:24:52.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.115]             }
[08:24:52.115]             {
[08:24:52.115]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.115]                   0L) {
[08:24:52.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.115]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.115]                   base::options(opts)
[08:24:52.115]                 }
[08:24:52.115]                 {
[08:24:52.115]                   {
[08:24:52.115]                     NULL
[08:24:52.115]                     RNGkind("Mersenne-Twister")
[08:24:52.115]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:52.115]                       inherits = FALSE)
[08:24:52.115]                   }
[08:24:52.115]                   options(future.plan = NULL)
[08:24:52.115]                   if (is.na(NA_character_)) 
[08:24:52.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.115]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.115]                     .init = FALSE)
[08:24:52.115]                 }
[08:24:52.115]             }
[08:24:52.115]         }
[08:24:52.115]     })
[08:24:52.115]     if (TRUE) {
[08:24:52.115]         base::sink(type = "output", split = FALSE)
[08:24:52.115]         if (TRUE) {
[08:24:52.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.115]         }
[08:24:52.115]         else {
[08:24:52.115]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.115]         }
[08:24:52.115]         base::close(...future.stdout)
[08:24:52.115]         ...future.stdout <- NULL
[08:24:52.115]     }
[08:24:52.115]     ...future.result$conditions <- ...future.conditions
[08:24:52.115]     ...future.result$finished <- base::Sys.time()
[08:24:52.115]     ...future.result
[08:24:52.115] }
[08:24:52.116] assign_globals() ...
[08:24:52.116] List of 5
[08:24:52.116]  $ future.call.arguments    : list()
[08:24:52.116]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.116]  $ ...future.FUN            :function (x)  
[08:24:52.116]  $ ...future.elements_ii    :List of 2
[08:24:52.116]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[08:24:52.116]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[08:24:52.116]  $ ...future.seeds_ii       : NULL
[08:24:52.116]  $ ...future.globals.maxSize: num Inf
[08:24:52.116]  - attr(*, "resolved")= logi FALSE
[08:24:52.116]  - attr(*, "total_size")= num NA
[08:24:52.116]  - attr(*, "where")=List of 5
[08:24:52.116]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.116]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.116]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.116]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.116]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.116]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.116]  - attr(*, "already-done")= logi TRUE
[08:24:52.122] - copied ‘future.call.arguments’ to environment
[08:24:52.122] - copied ‘...future.FUN’ to environment
[08:24:52.122] - copied ‘...future.elements_ii’ to environment
[08:24:52.122] - copied ‘...future.seeds_ii’ to environment
[08:24:52.122] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.122] assign_globals() ... done
[08:24:52.123] plan(): Setting new future strategy stack:
[08:24:52.123] List of future strategies:
[08:24:52.123] 1. sequential:
[08:24:52.123]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.123]    - tweaked: FALSE
[08:24:52.123]    - call: NULL
[08:24:52.123] plan(): nbrOfWorkers() = 1
[08:24:52.124] plan(): Setting new future strategy stack:
[08:24:52.124] List of future strategies:
[08:24:52.124] 1. sequential:
[08:24:52.124]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.124]    - tweaked: FALSE
[08:24:52.124]    - call: plan(strategy)
[08:24:52.124] plan(): nbrOfWorkers() = 1
[08:24:52.125] SequentialFuture started (and completed)
[08:24:52.125] - Launch lazy future ... done
[08:24:52.125] run() for ‘SequentialFuture’ ... done
[08:24:52.125] Created future:
[08:24:52.125] SequentialFuture:
[08:24:52.125] Label: ‘future_apply-1’
[08:24:52.125] Expression:
[08:24:52.125] {
[08:24:52.125]     do.call(function(...) {
[08:24:52.125]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.125]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.125]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.125]             on.exit(options(oopts), add = TRUE)
[08:24:52.125]         }
[08:24:52.125]         {
[08:24:52.125]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.125]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.125]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.125]             })
[08:24:52.125]         }
[08:24:52.125]     }, args = future.call.arguments)
[08:24:52.125] }
[08:24:52.125] Lazy evaluation: FALSE
[08:24:52.125] Asynchronous evaluation: FALSE
[08:24:52.125] Local evaluation: TRUE
[08:24:52.125] Environment: R_GlobalEnv
[08:24:52.125] Capture standard output: TRUE
[08:24:52.125] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.125] Globals: 5 objects totaling 510 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 162 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.125] Packages: <none>
[08:24:52.125] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.125] Resolved: TRUE
[08:24:52.125] Value: 162 bytes of class ‘list’
[08:24:52.125] Early signaling: FALSE
[08:24:52.125] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.125] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.126] Chunk #1 of 1 ... DONE
[08:24:52.126] Launching 1 futures (chunks) ... DONE
[08:24:52.126] Resolving 1 futures (chunks) ...
[08:24:52.126] resolve() on list ...
[08:24:52.126]  recursive: 0
[08:24:52.126]  length: 1
[08:24:52.126] 
[08:24:52.126] resolved() for ‘SequentialFuture’ ...
[08:24:52.127] - state: ‘finished’
[08:24:52.127] - run: TRUE
[08:24:52.127] - result: ‘FutureResult’
[08:24:52.127] resolved() for ‘SequentialFuture’ ... done
[08:24:52.127] Future #1
[08:24:52.127] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:52.127] - nx: 1
[08:24:52.127] - relay: TRUE
[08:24:52.127] - stdout: TRUE
[08:24:52.127] - signal: TRUE
[08:24:52.127] - resignal: FALSE
[08:24:52.128] - force: TRUE
[08:24:52.128] - relayed: [n=1] FALSE
[08:24:52.128] - queued futures: [n=1] FALSE
[08:24:52.128]  - until=1
[08:24:52.128]  - relaying element #1
[08:24:52.128] - relayed: [n=1] TRUE
[08:24:52.128] - queued futures: [n=1] TRUE
[08:24:52.128] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:52.128]  length: 0 (resolved future 1)
[08:24:52.128] Relaying remaining futures
[08:24:52.129] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.129] - nx: 1
[08:24:52.129] - relay: TRUE
[08:24:52.129] - stdout: TRUE
[08:24:52.129] - signal: TRUE
[08:24:52.129] - resignal: FALSE
[08:24:52.129] - force: TRUE
[08:24:52.129] - relayed: [n=1] TRUE
[08:24:52.129] - queued futures: [n=1] TRUE
 - flush all
[08:24:52.129] - relayed: [n=1] TRUE
[08:24:52.129] - queued futures: [n=1] TRUE
[08:24:52.129] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.130] resolve() on list ... DONE
[08:24:52.130]  - Number of value chunks collected: 1
[08:24:52.130] Resolving 1 futures (chunks) ... DONE
[08:24:52.130] Reducing values from 1 chunks ...
[08:24:52.130]  - Number of values collected after concatenation: 2
[08:24:52.130]  - Number of values expected: 2
[08:24:52.130] Reducing values from 1 chunks ... DONE
[08:24:52.130] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[08:24:52.131] getGlobalsAndPackagesXApply() ...
[08:24:52.131]  - future.globals: TRUE
[08:24:52.131] getGlobalsAndPackages() ...
[08:24:52.131] Searching for globals...
[08:24:52.133] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[08:24:52.133] Searching for globals ... DONE
[08:24:52.133] Resolving globals: FALSE
[08:24:52.134] The total size of the 1 globals is 1.28 KiB (1311 bytes)
[08:24:52.134] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 1.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.28 KiB of class ‘function’)
[08:24:52.134] - globals: [1] ‘FUN’
[08:24:52.135] 
[08:24:52.135] getGlobalsAndPackages() ... DONE
[08:24:52.135]  - globals found/used: [n=1] ‘FUN’
[08:24:52.135]  - needed namespaces: [n=0] 
[08:24:52.135] Finding globals ... DONE
[08:24:52.135]  - use_args: TRUE
[08:24:52.135]  - Getting '...' globals ...
[08:24:52.135] resolve() on list ...
[08:24:52.135]  recursive: 0
[08:24:52.136]  length: 1
[08:24:52.136]  elements: ‘...’
[08:24:52.136]  length: 0 (resolved future 1)
[08:24:52.136] resolve() on list ... DONE
[08:24:52.136]    - '...' content: [n=0] 
[08:24:52.136] List of 1
[08:24:52.136]  $ ...: list()
[08:24:52.136]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.136]  - attr(*, "where")=List of 1
[08:24:52.136]   ..$ ...:<environment: 0x56540dfda810> 
[08:24:52.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.136]  - attr(*, "resolved")= logi TRUE
[08:24:52.136]  - attr(*, "total_size")= num NA
[08:24:52.140]  - Getting '...' globals ... DONE
[08:24:52.140] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.140] List of 2
[08:24:52.140]  $ ...future.FUN:function (x)  
[08:24:52.140]  $ ...          : list()
[08:24:52.140]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.140]  - attr(*, "where")=List of 2
[08:24:52.140]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.140]   ..$ ...          :<environment: 0x56540dfda810> 
[08:24:52.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.140]  - attr(*, "resolved")= logi FALSE
[08:24:52.140]  - attr(*, "total_size")= num 4449
[08:24:52.143] Packages to be attached in all futures: [n=0] 
[08:24:52.143] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.144] future_lapply() ...
[08:24:52.145] Number of chunks: 1
[08:24:52.145] getGlobalsAndPackagesXApply() ...
[08:24:52.145]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.145]  - use_args: TRUE
[08:24:52.146] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.146] List of 2
[08:24:52.146]  $ ...          : list()
[08:24:52.146]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.146]  $ ...future.FUN:function (x)  
[08:24:52.146]  - attr(*, "where")=List of 2
[08:24:52.146]   ..$ ...          :<environment: 0x56540dfda810> 
[08:24:52.146]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[08:24:52.146]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.146]  - attr(*, "resolved")= logi FALSE
[08:24:52.146]  - attr(*, "total_size")= num NA
[08:24:52.148] Packages to be attached in all futures: [n=0] 
[08:24:52.149] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.149] Number of futures (= number of chunks): 1
[08:24:52.149] Launching 1 futures (chunks) ...
[08:24:52.149] Chunk #1 of 1 ...
[08:24:52.149]  - seeds: <none>
[08:24:52.149]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.149] getGlobalsAndPackages() ...
[08:24:52.149] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.150] Resolving globals: FALSE
[08:24:52.150] Tweak future expression to call with '...' arguments ...
[08:24:52.150] {
[08:24:52.150]     do.call(function(...) {
[08:24:52.150]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.150]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.150]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.150]             on.exit(options(oopts), add = TRUE)
[08:24:52.150]         }
[08:24:52.150]         {
[08:24:52.150]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.150]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.150]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.150]             })
[08:24:52.150]         }
[08:24:52.150]     }, args = future.call.arguments)
[08:24:52.150] }
[08:24:52.150] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.150] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.150] 
[08:24:52.151] getGlobalsAndPackages() ... DONE
[08:24:52.151] run() for ‘Future’ ...
[08:24:52.151] - state: ‘created’
[08:24:52.151] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:52.151] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.151] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:52.152]   - Field: ‘label’
[08:24:52.152]   - Field: ‘local’
[08:24:52.152]   - Field: ‘owner’
[08:24:52.152]   - Field: ‘envir’
[08:24:52.152]   - Field: ‘packages’
[08:24:52.152]   - Field: ‘gc’
[08:24:52.152]   - Field: ‘conditions’
[08:24:52.152]   - Field: ‘expr’
[08:24:52.152]   - Field: ‘uuid’
[08:24:52.152]   - Field: ‘seed’
[08:24:52.152]   - Field: ‘version’
[08:24:52.153]   - Field: ‘result’
[08:24:52.153]   - Field: ‘asynchronous’
[08:24:52.153]   - Field: ‘calls’
[08:24:52.153]   - Field: ‘globals’
[08:24:52.153]   - Field: ‘stdout’
[08:24:52.153]   - Field: ‘earlySignal’
[08:24:52.153]   - Field: ‘lazy’
[08:24:52.153]   - Field: ‘state’
[08:24:52.153] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:52.153] - Launch lazy future ...
[08:24:52.154] Packages needed by the future expression (n = 0): <none>
[08:24:52.154] Packages needed by future strategies (n = 0): <none>
[08:24:52.154] {
[08:24:52.154]     {
[08:24:52.154]         {
[08:24:52.154]             ...future.startTime <- base::Sys.time()
[08:24:52.154]             {
[08:24:52.154]                 {
[08:24:52.154]                   {
[08:24:52.154]                     base::local({
[08:24:52.154]                       has_future <- base::requireNamespace("future", 
[08:24:52.154]                         quietly = TRUE)
[08:24:52.154]                       if (has_future) {
[08:24:52.154]                         ns <- base::getNamespace("future")
[08:24:52.154]                         version <- ns[[".package"]][["version"]]
[08:24:52.154]                         if (is.null(version)) 
[08:24:52.154]                           version <- utils::packageVersion("future")
[08:24:52.154]                       }
[08:24:52.154]                       else {
[08:24:52.154]                         version <- NULL
[08:24:52.154]                       }
[08:24:52.154]                       if (!has_future || version < "1.8.0") {
[08:24:52.154]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.154]                           "", base::R.version$version.string), 
[08:24:52.154]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:52.154]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.154]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.154]                             "release", "version")], collapse = " "), 
[08:24:52.154]                           hostname = base::Sys.info()[["nodename"]])
[08:24:52.154]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.154]                           info)
[08:24:52.154]                         info <- base::paste(info, collapse = "; ")
[08:24:52.154]                         if (!has_future) {
[08:24:52.154]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.154]                             info)
[08:24:52.154]                         }
[08:24:52.154]                         else {
[08:24:52.154]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.154]                             info, version)
[08:24:52.154]                         }
[08:24:52.154]                         base::stop(msg)
[08:24:52.154]                       }
[08:24:52.154]                     })
[08:24:52.154]                   }
[08:24:52.154]                   ...future.strategy.old <- future::plan("list")
[08:24:52.154]                   options(future.plan = NULL)
[08:24:52.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.154]                 }
[08:24:52.154]                 ...future.workdir <- getwd()
[08:24:52.154]             }
[08:24:52.154]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.154]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.154]         }
[08:24:52.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.154]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.154]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.154]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.154]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.154]             base::names(...future.oldOptions))
[08:24:52.154]     }
[08:24:52.154]     if (FALSE) {
[08:24:52.154]     }
[08:24:52.154]     else {
[08:24:52.154]         if (TRUE) {
[08:24:52.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.154]                 open = "w")
[08:24:52.154]         }
[08:24:52.154]         else {
[08:24:52.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.154]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.154]         }
[08:24:52.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.154]             base::sink(type = "output", split = FALSE)
[08:24:52.154]             base::close(...future.stdout)
[08:24:52.154]         }, add = TRUE)
[08:24:52.154]     }
[08:24:52.154]     ...future.frame <- base::sys.nframe()
[08:24:52.154]     ...future.conditions <- base::list()
[08:24:52.154]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.154]     if (FALSE) {
[08:24:52.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.154]     }
[08:24:52.154]     ...future.result <- base::tryCatch({
[08:24:52.154]         base::withCallingHandlers({
[08:24:52.154]             ...future.value <- base::withVisible(base::local({
[08:24:52.154]                 do.call(function(...) {
[08:24:52.154]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.154]                   if (!identical(...future.globals.maxSize.org, 
[08:24:52.154]                     ...future.globals.maxSize)) {
[08:24:52.154]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.154]                     on.exit(options(oopts), add = TRUE)
[08:24:52.154]                   }
[08:24:52.154]                   {
[08:24:52.154]                     lapply(seq_along(...future.elements_ii), 
[08:24:52.154]                       FUN = function(jj) {
[08:24:52.154]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.154]                         ...future.FUN(...future.X_jj, ...)
[08:24:52.154]                       })
[08:24:52.154]                   }
[08:24:52.154]                 }, args = future.call.arguments)
[08:24:52.154]             }))
[08:24:52.154]             future::FutureResult(value = ...future.value$value, 
[08:24:52.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.154]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.154]                     ...future.globalenv.names))
[08:24:52.154]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.154]         }, condition = base::local({
[08:24:52.154]             c <- base::c
[08:24:52.154]             inherits <- base::inherits
[08:24:52.154]             invokeRestart <- base::invokeRestart
[08:24:52.154]             length <- base::length
[08:24:52.154]             list <- base::list
[08:24:52.154]             seq.int <- base::seq.int
[08:24:52.154]             signalCondition <- base::signalCondition
[08:24:52.154]             sys.calls <- base::sys.calls
[08:24:52.154]             `[[` <- base::`[[`
[08:24:52.154]             `+` <- base::`+`
[08:24:52.154]             `<<-` <- base::`<<-`
[08:24:52.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.154]                   3L)]
[08:24:52.154]             }
[08:24:52.154]             function(cond) {
[08:24:52.154]                 is_error <- inherits(cond, "error")
[08:24:52.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.154]                   NULL)
[08:24:52.154]                 if (is_error) {
[08:24:52.154]                   sessionInformation <- function() {
[08:24:52.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.154]                       search = base::search(), system = base::Sys.info())
[08:24:52.154]                   }
[08:24:52.154]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.154]                     cond$call), session = sessionInformation(), 
[08:24:52.154]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.154]                   signalCondition(cond)
[08:24:52.154]                 }
[08:24:52.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.154]                 "immediateCondition"))) {
[08:24:52.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.154]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.154]                   if (TRUE && !signal) {
[08:24:52.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.154]                     {
[08:24:52.154]                       inherits <- base::inherits
[08:24:52.154]                       invokeRestart <- base::invokeRestart
[08:24:52.154]                       is.null <- base::is.null
[08:24:52.154]                       muffled <- FALSE
[08:24:52.154]                       if (inherits(cond, "message")) {
[08:24:52.154]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.154]                         if (muffled) 
[08:24:52.154]                           invokeRestart("muffleMessage")
[08:24:52.154]                       }
[08:24:52.154]                       else if (inherits(cond, "warning")) {
[08:24:52.154]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.154]                         if (muffled) 
[08:24:52.154]                           invokeRestart("muffleWarning")
[08:24:52.154]                       }
[08:24:52.154]                       else if (inherits(cond, "condition")) {
[08:24:52.154]                         if (!is.null(pattern)) {
[08:24:52.154]                           computeRestarts <- base::computeRestarts
[08:24:52.154]                           grepl <- base::grepl
[08:24:52.154]                           restarts <- computeRestarts(cond)
[08:24:52.154]                           for (restart in restarts) {
[08:24:52.154]                             name <- restart$name
[08:24:52.154]                             if (is.null(name)) 
[08:24:52.154]                               next
[08:24:52.154]                             if (!grepl(pattern, name)) 
[08:24:52.154]                               next
[08:24:52.154]                             invokeRestart(restart)
[08:24:52.154]                             muffled <- TRUE
[08:24:52.154]                             break
[08:24:52.154]                           }
[08:24:52.154]                         }
[08:24:52.154]                       }
[08:24:52.154]                       invisible(muffled)
[08:24:52.154]                     }
[08:24:52.154]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.154]                   }
[08:24:52.154]                 }
[08:24:52.154]                 else {
[08:24:52.154]                   if (TRUE) {
[08:24:52.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.154]                     {
[08:24:52.154]                       inherits <- base::inherits
[08:24:52.154]                       invokeRestart <- base::invokeRestart
[08:24:52.154]                       is.null <- base::is.null
[08:24:52.154]                       muffled <- FALSE
[08:24:52.154]                       if (inherits(cond, "message")) {
[08:24:52.154]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.154]                         if (muffled) 
[08:24:52.154]                           invokeRestart("muffleMessage")
[08:24:52.154]                       }
[08:24:52.154]                       else if (inherits(cond, "warning")) {
[08:24:52.154]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.154]                         if (muffled) 
[08:24:52.154]                           invokeRestart("muffleWarning")
[08:24:52.154]                       }
[08:24:52.154]                       else if (inherits(cond, "condition")) {
[08:24:52.154]                         if (!is.null(pattern)) {
[08:24:52.154]                           computeRestarts <- base::computeRestarts
[08:24:52.154]                           grepl <- base::grepl
[08:24:52.154]                           restarts <- computeRestarts(cond)
[08:24:52.154]                           for (restart in restarts) {
[08:24:52.154]                             name <- restart$name
[08:24:52.154]                             if (is.null(name)) 
[08:24:52.154]                               next
[08:24:52.154]                             if (!grepl(pattern, name)) 
[08:24:52.154]                               next
[08:24:52.154]                             invokeRestart(restart)
[08:24:52.154]                             muffled <- TRUE
[08:24:52.154]                             break
[08:24:52.154]                           }
[08:24:52.154]                         }
[08:24:52.154]                       }
[08:24:52.154]                       invisible(muffled)
[08:24:52.154]                     }
[08:24:52.154]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.154]                   }
[08:24:52.154]                 }
[08:24:52.154]             }
[08:24:52.154]         }))
[08:24:52.154]     }, error = function(ex) {
[08:24:52.154]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.154]                 ...future.rng), started = ...future.startTime, 
[08:24:52.154]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.154]             version = "1.8"), class = "FutureResult")
[08:24:52.154]     }, finally = {
[08:24:52.154]         if (!identical(...future.workdir, getwd())) 
[08:24:52.154]             setwd(...future.workdir)
[08:24:52.154]         {
[08:24:52.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.154]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.154]             }
[08:24:52.154]             base::options(...future.oldOptions)
[08:24:52.154]             if (.Platform$OS.type == "windows") {
[08:24:52.154]                 old_names <- names(...future.oldEnvVars)
[08:24:52.154]                 envs <- base::Sys.getenv()
[08:24:52.154]                 names <- names(envs)
[08:24:52.154]                 common <- intersect(names, old_names)
[08:24:52.154]                 added <- setdiff(names, old_names)
[08:24:52.154]                 removed <- setdiff(old_names, names)
[08:24:52.154]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.154]                   envs[common]]
[08:24:52.154]                 NAMES <- toupper(changed)
[08:24:52.154]                 args <- list()
[08:24:52.154]                 for (kk in seq_along(NAMES)) {
[08:24:52.154]                   name <- changed[[kk]]
[08:24:52.154]                   NAME <- NAMES[[kk]]
[08:24:52.154]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.154]                     next
[08:24:52.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.154]                 }
[08:24:52.154]                 NAMES <- toupper(added)
[08:24:52.154]                 for (kk in seq_along(NAMES)) {
[08:24:52.154]                   name <- added[[kk]]
[08:24:52.154]                   NAME <- NAMES[[kk]]
[08:24:52.154]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.154]                     next
[08:24:52.154]                   args[[name]] <- ""
[08:24:52.154]                 }
[08:24:52.154]                 NAMES <- toupper(removed)
[08:24:52.154]                 for (kk in seq_along(NAMES)) {
[08:24:52.154]                   name <- removed[[kk]]
[08:24:52.154]                   NAME <- NAMES[[kk]]
[08:24:52.154]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.154]                     next
[08:24:52.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.154]                 }
[08:24:52.154]                 if (length(args) > 0) 
[08:24:52.154]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.154]             }
[08:24:52.154]             else {
[08:24:52.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.154]             }
[08:24:52.154]             {
[08:24:52.154]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.154]                   0L) {
[08:24:52.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.154]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.154]                   base::options(opts)
[08:24:52.154]                 }
[08:24:52.154]                 {
[08:24:52.154]                   {
[08:24:52.154]                     NULL
[08:24:52.154]                     RNGkind("Mersenne-Twister")
[08:24:52.154]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:24:52.154]                       inherits = FALSE)
[08:24:52.154]                   }
[08:24:52.154]                   options(future.plan = NULL)
[08:24:52.154]                   if (is.na(NA_character_)) 
[08:24:52.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.154]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.154]                     .init = FALSE)
[08:24:52.154]                 }
[08:24:52.154]             }
[08:24:52.154]         }
[08:24:52.154]     })
[08:24:52.154]     if (TRUE) {
[08:24:52.154]         base::sink(type = "output", split = FALSE)
[08:24:52.154]         if (TRUE) {
[08:24:52.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.154]         }
[08:24:52.154]         else {
[08:24:52.154]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.154]         }
[08:24:52.154]         base::close(...future.stdout)
[08:24:52.154]         ...future.stdout <- NULL
[08:24:52.154]     }
[08:24:52.154]     ...future.result$conditions <- ...future.conditions
[08:24:52.154]     ...future.result$finished <- base::Sys.time()
[08:24:52.154]     ...future.result
[08:24:52.154] }
[08:24:52.156] assign_globals() ...
[08:24:52.156] List of 5
[08:24:52.156]  $ future.call.arguments    : list()
[08:24:52.156]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.156]  $ ...future.FUN            :function (x)  
[08:24:52.156]  $ ...future.elements_ii    :List of 2
[08:24:52.156]   ..$ : int [1:2] 1 3
[08:24:52.156]   ..$ : int [1:2] 2 4
[08:24:52.156]  $ ...future.seeds_ii       : NULL
[08:24:52.156]  $ ...future.globals.maxSize: num Inf
[08:24:52.156]  - attr(*, "resolved")= logi FALSE
[08:24:52.156]  - attr(*, "total_size")= num NA
[08:24:52.156]  - attr(*, "where")=List of 5
[08:24:52.156]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.156]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.156]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.156]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.156]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.156]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.156]  - attr(*, "already-done")= logi TRUE
[08:24:52.161] - copied ‘future.call.arguments’ to environment
[08:24:52.161] - reassign environment for ‘...future.FUN’
[08:24:52.161] - copied ‘...future.FUN’ to environment
[08:24:52.161] - copied ‘...future.elements_ii’ to environment
[08:24:52.161] - copied ‘...future.seeds_ii’ to environment
[08:24:52.161] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.162] assign_globals() ... done
[08:24:52.162] plan(): Setting new future strategy stack:
[08:24:52.162] List of future strategies:
[08:24:52.162] 1. sequential:
[08:24:52.162]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.162]    - tweaked: FALSE
[08:24:52.162]    - call: NULL
[08:24:52.162] plan(): nbrOfWorkers() = 1
[08:24:52.163] plan(): Setting new future strategy stack:
[08:24:52.163] List of future strategies:
[08:24:52.163] 1. sequential:
[08:24:52.163]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.163]    - tweaked: FALSE
[08:24:52.163]    - call: plan(strategy)
[08:24:52.164] plan(): nbrOfWorkers() = 1
[08:24:52.164] SequentialFuture started (and completed)
[08:24:52.166] - Launch lazy future ... done
[08:24:52.166] run() for ‘SequentialFuture’ ... done
[08:24:52.166] Created future:
[08:24:52.166] SequentialFuture:
[08:24:52.166] Label: ‘future_apply-1’
[08:24:52.166] Expression:
[08:24:52.166] {
[08:24:52.166]     do.call(function(...) {
[08:24:52.166]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.166]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.166]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.166]             on.exit(options(oopts), add = TRUE)
[08:24:52.166]         }
[08:24:52.166]         {
[08:24:52.166]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.166]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.166]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.166]             })
[08:24:52.166]         }
[08:24:52.166]     }, args = future.call.arguments)
[08:24:52.166] }
[08:24:52.166] Lazy evaluation: FALSE
[08:24:52.166] Asynchronous evaluation: FALSE
[08:24:52.166] Local evaluation: TRUE
[08:24:52.166] Environment: R_GlobalEnv
[08:24:52.166] Capture standard output: TRUE
[08:24:52.166] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.166] Globals: 5 objects totaling 1.50 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 63 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.166] Packages: <none>
[08:24:52.166] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.166] Resolved: TRUE
[08:24:52.166] Value: 114 bytes of class ‘list’
[08:24:52.166] Early signaling: FALSE
[08:24:52.166] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.166] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.167] Chunk #1 of 1 ... DONE
[08:24:52.167] Launching 1 futures (chunks) ... DONE
[08:24:52.167] Resolving 1 futures (chunks) ...
[08:24:52.167] resolve() on list ...
[08:24:52.167]  recursive: 0
[08:24:52.167]  length: 1
[08:24:52.168] 
[08:24:52.168] resolved() for ‘SequentialFuture’ ...
[08:24:52.168] - state: ‘finished’
[08:24:52.168] - run: TRUE
[08:24:52.168] - result: ‘FutureResult’
[08:24:52.168] resolved() for ‘SequentialFuture’ ... done
[08:24:52.168] Future #1
[08:24:52.168] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:52.168] - nx: 1
[08:24:52.168] - relay: TRUE
[08:24:52.169] - stdout: TRUE
[08:24:52.169] - signal: TRUE
[08:24:52.169] - resignal: FALSE
[08:24:52.169] - force: TRUE
[08:24:52.169] - relayed: [n=1] FALSE
[08:24:52.169] - queued futures: [n=1] FALSE
[08:24:52.169]  - until=1
[08:24:52.169]  - relaying element #1
[08:24:52.169] - relayed: [n=1] TRUE
[08:24:52.169] - queued futures: [n=1] TRUE
[08:24:52.169] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:52.170]  length: 0 (resolved future 1)
[08:24:52.170] Relaying remaining futures
[08:24:52.170] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.170] - nx: 1
[08:24:52.170] - relay: TRUE
[08:24:52.170] - stdout: TRUE
[08:24:52.170] - signal: TRUE
[08:24:52.170] - resignal: FALSE
[08:24:52.170] - force: TRUE
[08:24:52.170] - relayed: [n=1] TRUE
[08:24:52.170] - queued futures: [n=1] TRUE
 - flush all
[08:24:52.171] - relayed: [n=1] TRUE
[08:24:52.171] - queued futures: [n=1] TRUE
[08:24:52.171] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.171] resolve() on list ... DONE
[08:24:52.171]  - Number of value chunks collected: 1
[08:24:52.171] Resolving 1 futures (chunks) ... DONE
[08:24:52.171] Reducing values from 1 chunks ...
[08:24:52.171]  - Number of values collected after concatenation: 2
[08:24:52.171]  - Number of values expected: 2
[08:24:52.171] Reducing values from 1 chunks ... DONE
[08:24:52.171] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[08:24:52.172] getGlobalsAndPackagesXApply() ...
[08:24:52.172]  - future.globals: TRUE
[08:24:52.172] getGlobalsAndPackages() ...
[08:24:52.172] Searching for globals...
[08:24:52.175] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[08:24:52.175] Searching for globals ... DONE
[08:24:52.175] Resolving globals: FALSE
[08:24:52.176] The total size of the 1 globals is 3.66 KiB (3746 bytes)
[08:24:52.176] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 3.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.66 KiB of class ‘function’)
[08:24:52.176] - globals: [1] ‘FUN’
[08:24:52.176] 
[08:24:52.176] getGlobalsAndPackages() ... DONE
[08:24:52.176]  - globals found/used: [n=1] ‘FUN’
[08:24:52.176]  - needed namespaces: [n=0] 
[08:24:52.177] Finding globals ... DONE
[08:24:52.177]  - use_args: TRUE
[08:24:52.177]  - Getting '...' globals ...
[08:24:52.177] resolve() on list ...
[08:24:52.177]  recursive: 0
[08:24:52.177]  length: 1
[08:24:52.177]  elements: ‘...’
[08:24:52.177]  length: 0 (resolved future 1)
[08:24:52.178] resolve() on list ... DONE
[08:24:52.178]    - '...' content: [n=0] 
[08:24:52.178] List of 1
[08:24:52.178]  $ ...: list()
[08:24:52.178]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.178]  - attr(*, "where")=List of 1
[08:24:52.178]   ..$ ...:<environment: 0x56540bc2d6c8> 
[08:24:52.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.178]  - attr(*, "resolved")= logi TRUE
[08:24:52.178]  - attr(*, "total_size")= num NA
[08:24:52.180]  - Getting '...' globals ... DONE
[08:24:52.180] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.180] List of 2
[08:24:52.180]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[08:24:52.180]  $ ...          : list()
[08:24:52.180]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.180]  - attr(*, "where")=List of 2
[08:24:52.180]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.180]   ..$ ...          :<environment: 0x56540bc2d6c8> 
[08:24:52.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.180]  - attr(*, "resolved")= logi FALSE
[08:24:52.180]  - attr(*, "total_size")= num 9424
[08:24:52.183] Packages to be attached in all futures: [n=0] 
[08:24:52.183] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.183] future_lapply() ...
[08:24:52.185] Generating random seeds ...
[08:24:52.185] Generating random seed streams for 2 elements ...
[08:24:52.185] Generating random seed streams for 2 elements ... DONE
[08:24:52.186] Generating random seeds ... DONE
[08:24:52.186] Will set RNG state on exit: 10407, 701004209, 1348071527, -2008890217, 176981820, 1308466952, -761549667
[08:24:52.186] Number of chunks: 1
[08:24:52.186] getGlobalsAndPackagesXApply() ...
[08:24:52.186]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.186]  - use_args: TRUE
[08:24:52.186] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.186] List of 2
[08:24:52.186]  $ ...          : list()
[08:24:52.186]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.186]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[08:24:52.186]  - attr(*, "where")=List of 2
[08:24:52.186]   ..$ ...          :<environment: 0x56540bc2d6c8> 
[08:24:52.186]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:52.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.186]  - attr(*, "resolved")= logi FALSE
[08:24:52.186]  - attr(*, "total_size")= num NA
[08:24:52.192] Packages to be attached in all futures: [n=0] 
[08:24:52.192] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.192] Number of futures (= number of chunks): 1
[08:24:52.192] Launching 1 futures (chunks) ...
[08:24:52.192] Chunk #1 of 1 ...
[08:24:52.192]  - seeds: [2] <seeds>
[08:24:52.193]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.193] getGlobalsAndPackages() ...
[08:24:52.193] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.193] Resolving globals: FALSE
[08:24:52.193] Tweak future expression to call with '...' arguments ...
[08:24:52.193] {
[08:24:52.193]     do.call(function(...) {
[08:24:52.193]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.193]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.193]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.193]             on.exit(options(oopts), add = TRUE)
[08:24:52.193]         }
[08:24:52.193]         {
[08:24:52.193]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.193]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.193]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:52.193]                   envir = globalenv(), inherits = FALSE)
[08:24:52.193]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.193]             })
[08:24:52.193]         }
[08:24:52.193]     }, args = future.call.arguments)
[08:24:52.193] }
[08:24:52.193] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.194] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.194] 
[08:24:52.194] getGlobalsAndPackages() ... DONE
[08:24:52.194] run() for ‘Future’ ...
[08:24:52.194] - state: ‘created’
[08:24:52.194] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:24:52.195] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.195] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:24:52.195]   - Field: ‘label’
[08:24:52.195]   - Field: ‘local’
[08:24:52.195]   - Field: ‘owner’
[08:24:52.195]   - Field: ‘envir’
[08:24:52.195]   - Field: ‘packages’
[08:24:52.195]   - Field: ‘gc’
[08:24:52.195]   - Field: ‘conditions’
[08:24:52.196]   - Field: ‘expr’
[08:24:52.196]   - Field: ‘uuid’
[08:24:52.196]   - Field: ‘seed’
[08:24:52.196]   - Field: ‘version’
[08:24:52.196]   - Field: ‘result’
[08:24:52.196]   - Field: ‘asynchronous’
[08:24:52.196]   - Field: ‘calls’
[08:24:52.196]   - Field: ‘globals’
[08:24:52.196]   - Field: ‘stdout’
[08:24:52.196]   - Field: ‘earlySignal’
[08:24:52.196]   - Field: ‘lazy’
[08:24:52.197]   - Field: ‘state’
[08:24:52.197] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:24:52.197] - Launch lazy future ...
[08:24:52.197] Packages needed by the future expression (n = 0): <none>
[08:24:52.197] Packages needed by future strategies (n = 0): <none>
[08:24:52.197] {
[08:24:52.197]     {
[08:24:52.197]         {
[08:24:52.197]             ...future.startTime <- base::Sys.time()
[08:24:52.197]             {
[08:24:52.197]                 {
[08:24:52.197]                   {
[08:24:52.197]                     base::local({
[08:24:52.197]                       has_future <- base::requireNamespace("future", 
[08:24:52.197]                         quietly = TRUE)
[08:24:52.197]                       if (has_future) {
[08:24:52.197]                         ns <- base::getNamespace("future")
[08:24:52.197]                         version <- ns[[".package"]][["version"]]
[08:24:52.197]                         if (is.null(version)) 
[08:24:52.197]                           version <- utils::packageVersion("future")
[08:24:52.197]                       }
[08:24:52.197]                       else {
[08:24:52.197]                         version <- NULL
[08:24:52.197]                       }
[08:24:52.197]                       if (!has_future || version < "1.8.0") {
[08:24:52.197]                         info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.197]                           "", base::R.version$version.string), 
[08:24:52.197]                           platform = base::sprintf("%s (%s-bit)", 
[08:24:52.197]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.197]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.197]                             "release", "version")], collapse = " "), 
[08:24:52.197]                           hostname = base::Sys.info()[["nodename"]])
[08:24:52.197]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.197]                           info)
[08:24:52.197]                         info <- base::paste(info, collapse = "; ")
[08:24:52.197]                         if (!has_future) {
[08:24:52.197]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.197]                             info)
[08:24:52.197]                         }
[08:24:52.197]                         else {
[08:24:52.197]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.197]                             info, version)
[08:24:52.197]                         }
[08:24:52.197]                         base::stop(msg)
[08:24:52.197]                       }
[08:24:52.197]                     })
[08:24:52.197]                   }
[08:24:52.197]                   ...future.strategy.old <- future::plan("list")
[08:24:52.197]                   options(future.plan = NULL)
[08:24:52.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.197]                 }
[08:24:52.197]                 ...future.workdir <- getwd()
[08:24:52.197]             }
[08:24:52.197]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.197]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.197]         }
[08:24:52.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.197]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.197]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.197]             base::names(...future.oldOptions))
[08:24:52.197]     }
[08:24:52.197]     if (FALSE) {
[08:24:52.197]     }
[08:24:52.197]     else {
[08:24:52.197]         if (TRUE) {
[08:24:52.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.197]                 open = "w")
[08:24:52.197]         }
[08:24:52.197]         else {
[08:24:52.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.197]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.197]         }
[08:24:52.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.197]             base::sink(type = "output", split = FALSE)
[08:24:52.197]             base::close(...future.stdout)
[08:24:52.197]         }, add = TRUE)
[08:24:52.197]     }
[08:24:52.197]     ...future.frame <- base::sys.nframe()
[08:24:52.197]     ...future.conditions <- base::list()
[08:24:52.197]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.197]     if (FALSE) {
[08:24:52.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.197]     }
[08:24:52.197]     ...future.result <- base::tryCatch({
[08:24:52.197]         base::withCallingHandlers({
[08:24:52.197]             ...future.value <- base::withVisible(base::local({
[08:24:52.197]                 do.call(function(...) {
[08:24:52.197]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.197]                   if (!identical(...future.globals.maxSize.org, 
[08:24:52.197]                     ...future.globals.maxSize)) {
[08:24:52.197]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.197]                     on.exit(options(oopts), add = TRUE)
[08:24:52.197]                   }
[08:24:52.197]                   {
[08:24:52.197]                     lapply(seq_along(...future.elements_ii), 
[08:24:52.197]                       FUN = function(jj) {
[08:24:52.197]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.197]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:52.197]                           envir = globalenv(), inherits = FALSE)
[08:24:52.197]                         ...future.FUN(...future.X_jj, ...)
[08:24:52.197]                       })
[08:24:52.197]                   }
[08:24:52.197]                 }, args = future.call.arguments)
[08:24:52.197]             }))
[08:24:52.197]             future::FutureResult(value = ...future.value$value, 
[08:24:52.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.197]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.197]                     ...future.globalenv.names))
[08:24:52.197]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.197]         }, condition = base::local({
[08:24:52.197]             c <- base::c
[08:24:52.197]             inherits <- base::inherits
[08:24:52.197]             invokeRestart <- base::invokeRestart
[08:24:52.197]             length <- base::length
[08:24:52.197]             list <- base::list
[08:24:52.197]             seq.int <- base::seq.int
[08:24:52.197]             signalCondition <- base::signalCondition
[08:24:52.197]             sys.calls <- base::sys.calls
[08:24:52.197]             `[[` <- base::`[[`
[08:24:52.197]             `+` <- base::`+`
[08:24:52.197]             `<<-` <- base::`<<-`
[08:24:52.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.197]                   3L)]
[08:24:52.197]             }
[08:24:52.197]             function(cond) {
[08:24:52.197]                 is_error <- inherits(cond, "error")
[08:24:52.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.197]                   NULL)
[08:24:52.197]                 if (is_error) {
[08:24:52.197]                   sessionInformation <- function() {
[08:24:52.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.197]                       search = base::search(), system = base::Sys.info())
[08:24:52.197]                   }
[08:24:52.197]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.197]                     cond$call), session = sessionInformation(), 
[08:24:52.197]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.197]                   signalCondition(cond)
[08:24:52.197]                 }
[08:24:52.197]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[08:24:52.197]                   signal <- TRUE && inherits(cond, character(0))
[08:24:52.197]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.197]                   if (TRUE && !signal) {
[08:24:52.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.197]                     {
[08:24:52.197]                       inherits <- base::inherits
[08:24:52.197]                       invokeRestart <- base::invokeRestart
[08:24:52.197]                       is.null <- base::is.null
[08:24:52.197]                       muffled <- FALSE
[08:24:52.197]                       if (inherits(cond, "message")) {
[08:24:52.197]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.197]                         if (muffled) 
[08:24:52.197]                           invokeRestart("muffleMessage")
[08:24:52.197]                       }
[08:24:52.197]                       else if (inherits(cond, "warning")) {
[08:24:52.197]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.197]                         if (muffled) 
[08:24:52.197]                           invokeRestart("muffleWarning")
[08:24:52.197]                       }
[08:24:52.197]                       else if (inherits(cond, "condition")) {
[08:24:52.197]                         if (!is.null(pattern)) {
[08:24:52.197]                           computeRestarts <- base::computeRestarts
[08:24:52.197]                           grepl <- base::grepl
[08:24:52.197]                           restarts <- computeRestarts(cond)
[08:24:52.197]                           for (restart in restarts) {
[08:24:52.197]                             name <- restart$name
[08:24:52.197]                             if (is.null(name)) 
[08:24:52.197]                               next
[08:24:52.197]                             if (!grepl(pattern, name)) 
[08:24:52.197]                               next
[08:24:52.197]                             invokeRestart(restart)
[08:24:52.197]                             muffled <- TRUE
[08:24:52.197]                             break
[08:24:52.197]                           }
[08:24:52.197]                         }
[08:24:52.197]                       }
[08:24:52.197]                       invisible(muffled)
[08:24:52.197]                     }
[08:24:52.197]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.197]                   }
[08:24:52.197]                 }
[08:24:52.197]                 else {
[08:24:52.197]                   if (FALSE) {
[08:24:52.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.197]                     {
[08:24:52.197]                       inherits <- base::inherits
[08:24:52.197]                       invokeRestart <- base::invokeRestart
[08:24:52.197]                       is.null <- base::is.null
[08:24:52.197]                       muffled <- FALSE
[08:24:52.197]                       if (inherits(cond, "message")) {
[08:24:52.197]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.197]                         if (muffled) 
[08:24:52.197]                           invokeRestart("muffleMessage")
[08:24:52.197]                       }
[08:24:52.197]                       else if (inherits(cond, "warning")) {
[08:24:52.197]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.197]                         if (muffled) 
[08:24:52.197]                           invokeRestart("muffleWarning")
[08:24:52.197]                       }
[08:24:52.197]                       else if (inherits(cond, "condition")) {
[08:24:52.197]                         if (!is.null(pattern)) {
[08:24:52.197]                           computeRestarts <- base::computeRestarts
[08:24:52.197]                           grepl <- base::grepl
[08:24:52.197]                           restarts <- computeRestarts(cond)
[08:24:52.197]                           for (restart in restarts) {
[08:24:52.197]                             name <- restart$name
[08:24:52.197]                             if (is.null(name)) 
[08:24:52.197]                               next
[08:24:52.197]                             if (!grepl(pattern, name)) 
[08:24:52.197]                               next
[08:24:52.197]                             invokeRestart(restart)
[08:24:52.197]                             muffled <- TRUE
[08:24:52.197]                             break
[08:24:52.197]                           }
[08:24:52.197]                         }
[08:24:52.197]                       }
[08:24:52.197]                       invisible(muffled)
[08:24:52.197]                     }
[08:24:52.197]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.197]                   }
[08:24:52.197]                 }
[08:24:52.197]             }
[08:24:52.197]         }))
[08:24:52.197]     }, error = function(ex) {
[08:24:52.197]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.197]                 ...future.rng), started = ...future.startTime, 
[08:24:52.197]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.197]             version = "1.8"), class = "FutureResult")
[08:24:52.197]     }, finally = {
[08:24:52.197]         if (!identical(...future.workdir, getwd())) 
[08:24:52.197]             setwd(...future.workdir)
[08:24:52.197]         {
[08:24:52.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.197]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.197]             }
[08:24:52.197]             base::options(...future.oldOptions)
[08:24:52.197]             if (.Platform$OS.type == "windows") {
[08:24:52.197]                 old_names <- names(...future.oldEnvVars)
[08:24:52.197]                 envs <- base::Sys.getenv()
[08:24:52.197]                 names <- names(envs)
[08:24:52.197]                 common <- intersect(names, old_names)
[08:24:52.197]                 added <- setdiff(names, old_names)
[08:24:52.197]                 removed <- setdiff(old_names, names)
[08:24:52.197]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.197]                   envs[common]]
[08:24:52.197]                 NAMES <- toupper(changed)
[08:24:52.197]                 args <- list()
[08:24:52.197]                 for (kk in seq_along(NAMES)) {
[08:24:52.197]                   name <- changed[[kk]]
[08:24:52.197]                   NAME <- NAMES[[kk]]
[08:24:52.197]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.197]                     next
[08:24:52.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.197]                 }
[08:24:52.197]                 NAMES <- toupper(added)
[08:24:52.197]                 for (kk in seq_along(NAMES)) {
[08:24:52.197]                   name <- added[[kk]]
[08:24:52.197]                   NAME <- NAMES[[kk]]
[08:24:52.197]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.197]                     next
[08:24:52.197]                   args[[name]] <- ""
[08:24:52.197]                 }
[08:24:52.197]                 NAMES <- toupper(removed)
[08:24:52.197]                 for (kk in seq_along(NAMES)) {
[08:24:52.197]                   name <- removed[[kk]]
[08:24:52.197]                   NAME <- NAMES[[kk]]
[08:24:52.197]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.197]                     next
[08:24:52.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.197]                 }
[08:24:52.197]                 if (length(args) > 0) 
[08:24:52.197]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.197]             }
[08:24:52.197]             else {
[08:24:52.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.197]             }
[08:24:52.197]             {
[08:24:52.197]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.197]                   0L) {
[08:24:52.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.197]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.197]                   base::options(opts)
[08:24:52.197]                 }
[08:24:52.197]                 {
[08:24:52.197]                   {
[08:24:52.197]                     base::assign(".Random.seed", c(10407L, 701004209L, 
[08:24:52.197]                     1348071527L, -2008890217L, 176981820L, 1308466952L, 
[08:24:52.197]                     -761549667L), envir = base::globalenv(), 
[08:24:52.197]                       inherits = FALSE)
[08:24:52.197]                     NULL
[08:24:52.197]                   }
[08:24:52.197]                   options(future.plan = NULL)
[08:24:52.197]                   if (is.na(NA_character_)) 
[08:24:52.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.197]                     .init = FALSE)
[08:24:52.197]                 }
[08:24:52.197]             }
[08:24:52.197]         }
[08:24:52.197]     })
[08:24:52.197]     if (TRUE) {
[08:24:52.197]         base::sink(type = "output", split = FALSE)
[08:24:52.197]         if (TRUE) {
[08:24:52.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.197]         }
[08:24:52.197]         else {
[08:24:52.197]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.197]         }
[08:24:52.197]         base::close(...future.stdout)
[08:24:52.197]         ...future.stdout <- NULL
[08:24:52.197]     }
[08:24:52.197]     ...future.result$conditions <- ...future.conditions
[08:24:52.197]     ...future.result$finished <- base::Sys.time()
[08:24:52.197]     ...future.result
[08:24:52.197] }
[08:24:52.199] assign_globals() ...
[08:24:52.199] List of 5
[08:24:52.199]  $ future.call.arguments    : list()
[08:24:52.199]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.199]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[08:24:52.199]  $ ...future.elements_ii    :List of 2
[08:24:52.199]   ..$ : int [1:2] 1 3
[08:24:52.199]   ..$ : int [1:2] 2 4
[08:24:52.199]  $ ...future.seeds_ii       :List of 2
[08:24:52.199]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[08:24:52.199]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[08:24:52.199]  $ ...future.globals.maxSize: num Inf
[08:24:52.199]  - attr(*, "resolved")= logi FALSE
[08:24:52.199]  - attr(*, "total_size")= num NA
[08:24:52.199]  - attr(*, "where")=List of 5
[08:24:52.199]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.199]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.199]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.199]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.199]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.199]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.199]  - attr(*, "already-done")= logi TRUE
[08:24:52.205] - copied ‘future.call.arguments’ to environment
[08:24:52.205] - copied ‘...future.FUN’ to environment
[08:24:52.205] - copied ‘...future.elements_ii’ to environment
[08:24:52.205] - copied ‘...future.seeds_ii’ to environment
[08:24:52.205] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.205] assign_globals() ... done
[08:24:52.206] plan(): Setting new future strategy stack:
[08:24:52.206] List of future strategies:
[08:24:52.206] 1. sequential:
[08:24:52.206]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.206]    - tweaked: FALSE
[08:24:52.206]    - call: NULL
[08:24:52.206] plan(): nbrOfWorkers() = 1
[08:24:52.207] plan(): Setting new future strategy stack:
[08:24:52.207] List of future strategies:
[08:24:52.207] 1. sequential:
[08:24:52.207]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.207]    - tweaked: FALSE
[08:24:52.207]    - call: plan(strategy)
[08:24:52.207] plan(): nbrOfWorkers() = 1
[08:24:52.208] SequentialFuture started (and completed)
[08:24:52.208] - Launch lazy future ... done
[08:24:52.208] run() for ‘SequentialFuture’ ... done
[08:24:52.208] Created future:
[08:24:52.208] SequentialFuture:
[08:24:52.208] Label: ‘future_apply-1’
[08:24:52.208] Expression:
[08:24:52.208] {
[08:24:52.208]     do.call(function(...) {
[08:24:52.208]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.208]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.208]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.208]             on.exit(options(oopts), add = TRUE)
[08:24:52.208]         }
[08:24:52.208]         {
[08:24:52.208]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.208]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.208]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:52.208]                   envir = globalenv(), inherits = FALSE)
[08:24:52.208]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.208]             })
[08:24:52.208]         }
[08:24:52.208]     }, args = future.call.arguments)
[08:24:52.208] }
[08:24:52.208] Lazy evaluation: FALSE
[08:24:52.208] Asynchronous evaluation: FALSE
[08:24:52.208] Local evaluation: TRUE
[08:24:52.208] Environment: R_GlobalEnv
[08:24:52.208] Capture standard output: TRUE
[08:24:52.208] Capture condition classes: <none>
[08:24:52.208] Globals: 5 objects totaling 3.95 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 63 bytes, list ‘...future.seeds_ii’ of 103 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.208] Packages: <none>
[08:24:52.208] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:24:52.208] Resolved: TRUE
[08:24:52.208] Value: 63 bytes of class ‘list’
[08:24:52.208] Early signaling: FALSE
[08:24:52.208] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.208] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:24:52.209] Chunk #1 of 1 ... DONE
[08:24:52.209] Launching 1 futures (chunks) ... DONE
[08:24:52.209] Resolving 1 futures (chunks) ...
[08:24:52.209] resolve() on list ...
[08:24:52.209]  recursive: 0
[08:24:52.209]  length: 1
[08:24:52.209] 
[08:24:52.209] resolved() for ‘SequentialFuture’ ...
[08:24:52.210] - state: ‘finished’
[08:24:52.210] - run: TRUE
[08:24:52.210] - result: ‘FutureResult’
[08:24:52.210] resolved() for ‘SequentialFuture’ ... done
[08:24:52.210] Future #1
[08:24:52.210] signalConditionsASAP(SequentialFuture, pos=1) ...
[08:24:52.210] - nx: 1
[08:24:52.210] - relay: TRUE
[08:24:52.210] - stdout: TRUE
[08:24:52.210] - signal: TRUE
[08:24:52.210] - resignal: FALSE
[08:24:52.211] - force: TRUE
[08:24:52.211] - relayed: [n=1] FALSE
[08:24:52.211] - queued futures: [n=1] FALSE
[08:24:52.211]  - until=1
[08:24:52.211]  - relaying element #1
[08:24:52.211] - relayed: [n=1] TRUE
[08:24:52.211] - queued futures: [n=1] TRUE
[08:24:52.211] signalConditionsASAP(SequentialFuture, pos=1) ... done
[08:24:52.211]  length: 0 (resolved future 1)
[08:24:52.211] Relaying remaining futures
[08:24:52.212] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.212] - nx: 1
[08:24:52.212] - relay: TRUE
[08:24:52.212] - stdout: TRUE
[08:24:52.212] - signal: TRUE
[08:24:52.212] - resignal: FALSE
[08:24:52.212] - force: TRUE
[08:24:52.212] - relayed: [n=1] TRUE
[08:24:52.212] - queued futures: [n=1] TRUE
 - flush all
[08:24:52.212] - relayed: [n=1] TRUE
[08:24:52.212] - queued futures: [n=1] TRUE
[08:24:52.212] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.213] resolve() on list ... DONE
[08:24:52.214]  - Number of value chunks collected: 1
[08:24:52.214] Resolving 1 futures (chunks) ... DONE
[08:24:52.214] Reducing values from 1 chunks ...
[08:24:52.214]  - Number of values collected after concatenation: 2
[08:24:52.215]  - Number of values expected: 2
[08:24:52.215] Reducing values from 1 chunks ... DONE
[08:24:52.215] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[08:24:52.215] plan(): Setting new future strategy stack:
[08:24:52.215] List of future strategies:
[08:24:52.215] 1. sequential:
[08:24:52.215]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.215]    - tweaked: FALSE
[08:24:52.215]    - call: plan(sequential)
[08:24:52.216] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[08:24:52.216] plan(): Setting new future strategy stack:
[08:24:52.216] List of future strategies:
[08:24:52.216] 1. multicore:
[08:24:52.216]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.216]    - tweaked: FALSE
[08:24:52.216]    - call: plan(strategy)
[08:24:52.218] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[08:24:52.218] getGlobalsAndPackagesXApply() ...
[08:24:52.219]  - future.globals: TRUE
[08:24:52.219] getGlobalsAndPackages() ...
[08:24:52.219] Searching for globals...
[08:24:52.254] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[08:24:52.255] Searching for globals ... DONE
[08:24:52.255] Resolving globals: FALSE
[08:24:52.257] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[08:24:52.257] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[08:24:52.257] - globals: [1] ‘FUN’
[08:24:52.257] 
[08:24:52.257] getGlobalsAndPackages() ... DONE
[08:24:52.258]  - globals found/used: [n=1] ‘FUN’
[08:24:52.258]  - needed namespaces: [n=0] 
[08:24:52.258] Finding globals ... DONE
[08:24:52.258]  - use_args: TRUE
[08:24:52.258]  - Getting '...' globals ...
[08:24:52.258] resolve() on list ...
[08:24:52.258]  recursive: 0
[08:24:52.258]  length: 1
[08:24:52.259]  elements: ‘...’
[08:24:52.259]  length: 0 (resolved future 1)
[08:24:52.259] resolve() on list ... DONE
[08:24:52.259]    - '...' content: [n=0] 
[08:24:52.259] List of 1
[08:24:52.259]  $ ...: list()
[08:24:52.259]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.259]  - attr(*, "where")=List of 1
[08:24:52.259]   ..$ ...:<environment: 0x56540cc78468> 
[08:24:52.259]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.259]  - attr(*, "resolved")= logi TRUE
[08:24:52.259]  - attr(*, "total_size")= num NA
[08:24:52.262]  - Getting '...' globals ... DONE
[08:24:52.262] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.262] List of 2
[08:24:52.262]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:52.262]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:52.262]  $ ...          : list()
[08:24:52.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.262]  - attr(*, "where")=List of 2
[08:24:52.262]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.262]   ..$ ...          :<environment: 0x56540cc78468> 
[08:24:52.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.262]  - attr(*, "resolved")= logi FALSE
[08:24:52.262]  - attr(*, "total_size")= num 65963
[08:24:52.265] Packages to be attached in all futures: [n=0] 
[08:24:52.265] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.266] future_lapply() ...
[08:24:52.302] Number of chunks: 2
[08:24:52.302] getGlobalsAndPackagesXApply() ...
[08:24:52.302]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.302]  - use_args: TRUE
[08:24:52.302] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.303] List of 2
[08:24:52.303]  $ ...          : list()
[08:24:52.303]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.303]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:52.303]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:52.303]  - attr(*, "where")=List of 2
[08:24:52.303]   ..$ ...          :<environment: 0x56540cc78468> 
[08:24:52.303]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:52.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.303]  - attr(*, "resolved")= logi FALSE
[08:24:52.303]  - attr(*, "total_size")= num NA
[08:24:52.306] Packages to be attached in all futures: [n=0] 
[08:24:52.306] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.307] Number of futures (= number of chunks): 2
[08:24:52.307] Launching 2 futures (chunks) ...
[08:24:52.307] Chunk #1 of 2 ...
[08:24:52.307]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.307]  - seeds: <none>
[08:24:52.307]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.307] getGlobalsAndPackages() ...
[08:24:52.307] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.307] Resolving globals: FALSE
[08:24:52.307] Tweak future expression to call with '...' arguments ...
[08:24:52.308] {
[08:24:52.308]     do.call(function(...) {
[08:24:52.308]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.308]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.308]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.308]             on.exit(options(oopts), add = TRUE)
[08:24:52.308]         }
[08:24:52.308]         {
[08:24:52.308]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.308]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.308]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.308]             })
[08:24:52.308]         }
[08:24:52.308]     }, args = future.call.arguments)
[08:24:52.308] }
[08:24:52.308] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.308] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.308] 
[08:24:52.308] getGlobalsAndPackages() ... DONE
[08:24:52.309] run() for ‘Future’ ...
[08:24:52.309] - state: ‘created’
[08:24:52.309] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.311] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.311] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.311]   - Field: ‘label’
[08:24:52.311]   - Field: ‘local’
[08:24:52.311]   - Field: ‘owner’
[08:24:52.311]   - Field: ‘envir’
[08:24:52.311]   - Field: ‘workers’
[08:24:52.311]   - Field: ‘packages’
[08:24:52.311]   - Field: ‘gc’
[08:24:52.312]   - Field: ‘job’
[08:24:52.312]   - Field: ‘conditions’
[08:24:52.312]   - Field: ‘expr’
[08:24:52.312]   - Field: ‘uuid’
[08:24:52.312]   - Field: ‘seed’
[08:24:52.312]   - Field: ‘version’
[08:24:52.312]   - Field: ‘result’
[08:24:52.312]   - Field: ‘asynchronous’
[08:24:52.312]   - Field: ‘calls’
[08:24:52.312]   - Field: ‘globals’
[08:24:52.312]   - Field: ‘stdout’
[08:24:52.313]   - Field: ‘earlySignal’
[08:24:52.313]   - Field: ‘lazy’
[08:24:52.313]   - Field: ‘state’
[08:24:52.313] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.313] - Launch lazy future ...
[08:24:52.314] Packages needed by the future expression (n = 0): <none>
[08:24:52.314] Packages needed by future strategies (n = 0): <none>
[08:24:52.314] {
[08:24:52.314]     {
[08:24:52.314]         {
[08:24:52.314]             ...future.startTime <- base::Sys.time()
[08:24:52.314]             {
[08:24:52.314]                 {
[08:24:52.314]                   {
[08:24:52.314]                     {
[08:24:52.314]                       base::local({
[08:24:52.314]                         has_future <- base::requireNamespace("future", 
[08:24:52.314]                           quietly = TRUE)
[08:24:52.314]                         if (has_future) {
[08:24:52.314]                           ns <- base::getNamespace("future")
[08:24:52.314]                           version <- ns[[".package"]][["version"]]
[08:24:52.314]                           if (is.null(version)) 
[08:24:52.314]                             version <- utils::packageVersion("future")
[08:24:52.314]                         }
[08:24:52.314]                         else {
[08:24:52.314]                           version <- NULL
[08:24:52.314]                         }
[08:24:52.314]                         if (!has_future || version < "1.8.0") {
[08:24:52.314]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.314]                             "", base::R.version$version.string), 
[08:24:52.314]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.314]                               "release", "version")], collapse = " "), 
[08:24:52.314]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.314]                             info)
[08:24:52.314]                           info <- base::paste(info, collapse = "; ")
[08:24:52.314]                           if (!has_future) {
[08:24:52.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.314]                               info)
[08:24:52.314]                           }
[08:24:52.314]                           else {
[08:24:52.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.314]                               info, version)
[08:24:52.314]                           }
[08:24:52.314]                           base::stop(msg)
[08:24:52.314]                         }
[08:24:52.314]                       })
[08:24:52.314]                     }
[08:24:52.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.314]                     base::options(mc.cores = 1L)
[08:24:52.314]                   }
[08:24:52.314]                   ...future.strategy.old <- future::plan("list")
[08:24:52.314]                   options(future.plan = NULL)
[08:24:52.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.314]                 }
[08:24:52.314]                 ...future.workdir <- getwd()
[08:24:52.314]             }
[08:24:52.314]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.314]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.314]         }
[08:24:52.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.314]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.314]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.314]             base::names(...future.oldOptions))
[08:24:52.314]     }
[08:24:52.314]     if (FALSE) {
[08:24:52.314]     }
[08:24:52.314]     else {
[08:24:52.314]         if (TRUE) {
[08:24:52.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.314]                 open = "w")
[08:24:52.314]         }
[08:24:52.314]         else {
[08:24:52.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.314]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.314]         }
[08:24:52.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.314]             base::sink(type = "output", split = FALSE)
[08:24:52.314]             base::close(...future.stdout)
[08:24:52.314]         }, add = TRUE)
[08:24:52.314]     }
[08:24:52.314]     ...future.frame <- base::sys.nframe()
[08:24:52.314]     ...future.conditions <- base::list()
[08:24:52.314]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.314]     if (FALSE) {
[08:24:52.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.314]     }
[08:24:52.314]     ...future.result <- base::tryCatch({
[08:24:52.314]         base::withCallingHandlers({
[08:24:52.314]             ...future.value <- base::withVisible(base::local({
[08:24:52.314]                 withCallingHandlers({
[08:24:52.314]                   {
[08:24:52.314]                     do.call(function(...) {
[08:24:52.314]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.314]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.314]                         ...future.globals.maxSize)) {
[08:24:52.314]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.314]                         on.exit(options(oopts), add = TRUE)
[08:24:52.314]                       }
[08:24:52.314]                       {
[08:24:52.314]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.314]                           FUN = function(jj) {
[08:24:52.314]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.314]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.314]                           })
[08:24:52.314]                       }
[08:24:52.314]                     }, args = future.call.arguments)
[08:24:52.314]                   }
[08:24:52.314]                 }, immediateCondition = function(cond) {
[08:24:52.314]                   save_rds <- function (object, pathname, ...) 
[08:24:52.314]                   {
[08:24:52.314]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.314]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.314]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.314]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.314]                         fi_tmp[["mtime"]])
[08:24:52.314]                     }
[08:24:52.314]                     tryCatch({
[08:24:52.314]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.314]                     }, error = function(ex) {
[08:24:52.314]                       msg <- conditionMessage(ex)
[08:24:52.314]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.314]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.314]                         fi_tmp[["mtime"]], msg)
[08:24:52.314]                       ex$message <- msg
[08:24:52.314]                       stop(ex)
[08:24:52.314]                     })
[08:24:52.314]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.314]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.314]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.314]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.314]                       fi <- file.info(pathname)
[08:24:52.314]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.314]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.314]                         fi[["size"]], fi[["mtime"]])
[08:24:52.314]                       stop(msg)
[08:24:52.314]                     }
[08:24:52.314]                     invisible(pathname)
[08:24:52.314]                   }
[08:24:52.314]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.314]                     rootPath = tempdir()) 
[08:24:52.314]                   {
[08:24:52.314]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.314]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.314]                       tmpdir = path, fileext = ".rds")
[08:24:52.314]                     save_rds(obj, file)
[08:24:52.314]                   }
[08:24:52.314]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.314]                   {
[08:24:52.314]                     inherits <- base::inherits
[08:24:52.314]                     invokeRestart <- base::invokeRestart
[08:24:52.314]                     is.null <- base::is.null
[08:24:52.314]                     muffled <- FALSE
[08:24:52.314]                     if (inherits(cond, "message")) {
[08:24:52.314]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.314]                       if (muffled) 
[08:24:52.314]                         invokeRestart("muffleMessage")
[08:24:52.314]                     }
[08:24:52.314]                     else if (inherits(cond, "warning")) {
[08:24:52.314]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.314]                       if (muffled) 
[08:24:52.314]                         invokeRestart("muffleWarning")
[08:24:52.314]                     }
[08:24:52.314]                     else if (inherits(cond, "condition")) {
[08:24:52.314]                       if (!is.null(pattern)) {
[08:24:52.314]                         computeRestarts <- base::computeRestarts
[08:24:52.314]                         grepl <- base::grepl
[08:24:52.314]                         restarts <- computeRestarts(cond)
[08:24:52.314]                         for (restart in restarts) {
[08:24:52.314]                           name <- restart$name
[08:24:52.314]                           if (is.null(name)) 
[08:24:52.314]                             next
[08:24:52.314]                           if (!grepl(pattern, name)) 
[08:24:52.314]                             next
[08:24:52.314]                           invokeRestart(restart)
[08:24:52.314]                           muffled <- TRUE
[08:24:52.314]                           break
[08:24:52.314]                         }
[08:24:52.314]                       }
[08:24:52.314]                     }
[08:24:52.314]                     invisible(muffled)
[08:24:52.314]                   }
[08:24:52.314]                   muffleCondition(cond)
[08:24:52.314]                 })
[08:24:52.314]             }))
[08:24:52.314]             future::FutureResult(value = ...future.value$value, 
[08:24:52.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.314]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.314]                     ...future.globalenv.names))
[08:24:52.314]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.314]         }, condition = base::local({
[08:24:52.314]             c <- base::c
[08:24:52.314]             inherits <- base::inherits
[08:24:52.314]             invokeRestart <- base::invokeRestart
[08:24:52.314]             length <- base::length
[08:24:52.314]             list <- base::list
[08:24:52.314]             seq.int <- base::seq.int
[08:24:52.314]             signalCondition <- base::signalCondition
[08:24:52.314]             sys.calls <- base::sys.calls
[08:24:52.314]             `[[` <- base::`[[`
[08:24:52.314]             `+` <- base::`+`
[08:24:52.314]             `<<-` <- base::`<<-`
[08:24:52.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.314]                   3L)]
[08:24:52.314]             }
[08:24:52.314]             function(cond) {
[08:24:52.314]                 is_error <- inherits(cond, "error")
[08:24:52.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.314]                   NULL)
[08:24:52.314]                 if (is_error) {
[08:24:52.314]                   sessionInformation <- function() {
[08:24:52.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.314]                       search = base::search(), system = base::Sys.info())
[08:24:52.314]                   }
[08:24:52.314]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.314]                     cond$call), session = sessionInformation(), 
[08:24:52.314]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.314]                   signalCondition(cond)
[08:24:52.314]                 }
[08:24:52.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.314]                 "immediateCondition"))) {
[08:24:52.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.314]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.314]                   if (TRUE && !signal) {
[08:24:52.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.314]                     {
[08:24:52.314]                       inherits <- base::inherits
[08:24:52.314]                       invokeRestart <- base::invokeRestart
[08:24:52.314]                       is.null <- base::is.null
[08:24:52.314]                       muffled <- FALSE
[08:24:52.314]                       if (inherits(cond, "message")) {
[08:24:52.314]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.314]                         if (muffled) 
[08:24:52.314]                           invokeRestart("muffleMessage")
[08:24:52.314]                       }
[08:24:52.314]                       else if (inherits(cond, "warning")) {
[08:24:52.314]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.314]                         if (muffled) 
[08:24:52.314]                           invokeRestart("muffleWarning")
[08:24:52.314]                       }
[08:24:52.314]                       else if (inherits(cond, "condition")) {
[08:24:52.314]                         if (!is.null(pattern)) {
[08:24:52.314]                           computeRestarts <- base::computeRestarts
[08:24:52.314]                           grepl <- base::grepl
[08:24:52.314]                           restarts <- computeRestarts(cond)
[08:24:52.314]                           for (restart in restarts) {
[08:24:52.314]                             name <- restart$name
[08:24:52.314]                             if (is.null(name)) 
[08:24:52.314]                               next
[08:24:52.314]                             if (!grepl(pattern, name)) 
[08:24:52.314]                               next
[08:24:52.314]                             invokeRestart(restart)
[08:24:52.314]                             muffled <- TRUE
[08:24:52.314]                             break
[08:24:52.314]                           }
[08:24:52.314]                         }
[08:24:52.314]                       }
[08:24:52.314]                       invisible(muffled)
[08:24:52.314]                     }
[08:24:52.314]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.314]                   }
[08:24:52.314]                 }
[08:24:52.314]                 else {
[08:24:52.314]                   if (TRUE) {
[08:24:52.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.314]                     {
[08:24:52.314]                       inherits <- base::inherits
[08:24:52.314]                       invokeRestart <- base::invokeRestart
[08:24:52.314]                       is.null <- base::is.null
[08:24:52.314]                       muffled <- FALSE
[08:24:52.314]                       if (inherits(cond, "message")) {
[08:24:52.314]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.314]                         if (muffled) 
[08:24:52.314]                           invokeRestart("muffleMessage")
[08:24:52.314]                       }
[08:24:52.314]                       else if (inherits(cond, "warning")) {
[08:24:52.314]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.314]                         if (muffled) 
[08:24:52.314]                           invokeRestart("muffleWarning")
[08:24:52.314]                       }
[08:24:52.314]                       else if (inherits(cond, "condition")) {
[08:24:52.314]                         if (!is.null(pattern)) {
[08:24:52.314]                           computeRestarts <- base::computeRestarts
[08:24:52.314]                           grepl <- base::grepl
[08:24:52.314]                           restarts <- computeRestarts(cond)
[08:24:52.314]                           for (restart in restarts) {
[08:24:52.314]                             name <- restart$name
[08:24:52.314]                             if (is.null(name)) 
[08:24:52.314]                               next
[08:24:52.314]                             if (!grepl(pattern, name)) 
[08:24:52.314]                               next
[08:24:52.314]                             invokeRestart(restart)
[08:24:52.314]                             muffled <- TRUE
[08:24:52.314]                             break
[08:24:52.314]                           }
[08:24:52.314]                         }
[08:24:52.314]                       }
[08:24:52.314]                       invisible(muffled)
[08:24:52.314]                     }
[08:24:52.314]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.314]                   }
[08:24:52.314]                 }
[08:24:52.314]             }
[08:24:52.314]         }))
[08:24:52.314]     }, error = function(ex) {
[08:24:52.314]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.314]                 ...future.rng), started = ...future.startTime, 
[08:24:52.314]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.314]             version = "1.8"), class = "FutureResult")
[08:24:52.314]     }, finally = {
[08:24:52.314]         if (!identical(...future.workdir, getwd())) 
[08:24:52.314]             setwd(...future.workdir)
[08:24:52.314]         {
[08:24:52.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.314]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.314]             }
[08:24:52.314]             base::options(...future.oldOptions)
[08:24:52.314]             if (.Platform$OS.type == "windows") {
[08:24:52.314]                 old_names <- names(...future.oldEnvVars)
[08:24:52.314]                 envs <- base::Sys.getenv()
[08:24:52.314]                 names <- names(envs)
[08:24:52.314]                 common <- intersect(names, old_names)
[08:24:52.314]                 added <- setdiff(names, old_names)
[08:24:52.314]                 removed <- setdiff(old_names, names)
[08:24:52.314]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.314]                   envs[common]]
[08:24:52.314]                 NAMES <- toupper(changed)
[08:24:52.314]                 args <- list()
[08:24:52.314]                 for (kk in seq_along(NAMES)) {
[08:24:52.314]                   name <- changed[[kk]]
[08:24:52.314]                   NAME <- NAMES[[kk]]
[08:24:52.314]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.314]                     next
[08:24:52.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.314]                 }
[08:24:52.314]                 NAMES <- toupper(added)
[08:24:52.314]                 for (kk in seq_along(NAMES)) {
[08:24:52.314]                   name <- added[[kk]]
[08:24:52.314]                   NAME <- NAMES[[kk]]
[08:24:52.314]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.314]                     next
[08:24:52.314]                   args[[name]] <- ""
[08:24:52.314]                 }
[08:24:52.314]                 NAMES <- toupper(removed)
[08:24:52.314]                 for (kk in seq_along(NAMES)) {
[08:24:52.314]                   name <- removed[[kk]]
[08:24:52.314]                   NAME <- NAMES[[kk]]
[08:24:52.314]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.314]                     next
[08:24:52.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.314]                 }
[08:24:52.314]                 if (length(args) > 0) 
[08:24:52.314]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.314]             }
[08:24:52.314]             else {
[08:24:52.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.314]             }
[08:24:52.314]             {
[08:24:52.314]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.314]                   0L) {
[08:24:52.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.314]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.314]                   base::options(opts)
[08:24:52.314]                 }
[08:24:52.314]                 {
[08:24:52.314]                   {
[08:24:52.314]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.314]                     NULL
[08:24:52.314]                   }
[08:24:52.314]                   options(future.plan = NULL)
[08:24:52.314]                   if (is.na(NA_character_)) 
[08:24:52.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.314]                     .init = FALSE)
[08:24:52.314]                 }
[08:24:52.314]             }
[08:24:52.314]         }
[08:24:52.314]     })
[08:24:52.314]     if (TRUE) {
[08:24:52.314]         base::sink(type = "output", split = FALSE)
[08:24:52.314]         if (TRUE) {
[08:24:52.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.314]         }
[08:24:52.314]         else {
[08:24:52.314]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.314]         }
[08:24:52.314]         base::close(...future.stdout)
[08:24:52.314]         ...future.stdout <- NULL
[08:24:52.314]     }
[08:24:52.314]     ...future.result$conditions <- ...future.conditions
[08:24:52.314]     ...future.result$finished <- base::Sys.time()
[08:24:52.314]     ...future.result
[08:24:52.314] }
[08:24:52.317] assign_globals() ...
[08:24:52.317] List of 5
[08:24:52.317]  $ future.call.arguments    : list()
[08:24:52.317]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.317]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:52.317]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:52.317]  $ ...future.elements_ii    :List of 1
[08:24:52.317]   ..$ : num [1:4] 1 3 1 7
[08:24:52.317]  $ ...future.seeds_ii       : NULL
[08:24:52.317]  $ ...future.globals.maxSize: num Inf
[08:24:52.317]  - attr(*, "resolved")= logi FALSE
[08:24:52.317]  - attr(*, "total_size")= num NA
[08:24:52.317]  - attr(*, "where")=List of 5
[08:24:52.317]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.317]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.317]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.317]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.317]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.317]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.317]  - attr(*, "already-done")= logi TRUE
[08:24:52.324] - copied ‘future.call.arguments’ to environment
[08:24:52.324] - copied ‘...future.FUN’ to environment
[08:24:52.324] - copied ‘...future.elements_ii’ to environment
[08:24:52.324] - copied ‘...future.seeds_ii’ to environment
[08:24:52.324] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.324] assign_globals() ... done
[08:24:52.325] requestCore(): workers = 2
[08:24:52.328] MulticoreFuture started
[08:24:52.329] - Launch lazy future ... done
[08:24:52.329] plan(): Setting new future strategy stack:
[08:24:52.329] run() for ‘MulticoreFuture’ ... done
[08:24:52.329] Created future:
[08:24:52.329] List of future strategies:
[08:24:52.329] 1. sequential:
[08:24:52.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.329]    - tweaked: FALSE
[08:24:52.329]    - call: NULL
[08:24:52.330] plan(): nbrOfWorkers() = 1
[08:24:52.333] plan(): Setting new future strategy stack:
[08:24:52.333] List of future strategies:
[08:24:52.333] 1. multicore:
[08:24:52.333]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.333]    - tweaked: FALSE
[08:24:52.333]    - call: plan(strategy)
[08:24:52.337] plan(): nbrOfWorkers() = 2
[08:24:52.330] MulticoreFuture:
[08:24:52.330] Label: ‘future_apply-1’
[08:24:52.330] Expression:
[08:24:52.330] {
[08:24:52.330]     do.call(function(...) {
[08:24:52.330]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.330]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.330]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.330]             on.exit(options(oopts), add = TRUE)
[08:24:52.330]         }
[08:24:52.330]         {
[08:24:52.330]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.330]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.330]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.330]             })
[08:24:52.330]         }
[08:24:52.330]     }, args = future.call.arguments)
[08:24:52.330] }
[08:24:52.330] Lazy evaluation: FALSE
[08:24:52.330] Asynchronous evaluation: TRUE
[08:24:52.330] Local evaluation: TRUE
[08:24:52.330] Environment: R_GlobalEnv
[08:24:52.330] Capture standard output: TRUE
[08:24:52.330] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.330] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.330] Packages: <none>
[08:24:52.330] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.330] Resolved: TRUE
[08:24:52.330] Value: <not collected>
[08:24:52.330] Conditions captured: <none>
[08:24:52.330] Early signaling: FALSE
[08:24:52.330] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.330] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.338] Chunk #1 of 2 ... DONE
[08:24:52.338] Chunk #2 of 2 ...
[08:24:52.339]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.339]  - seeds: <none>
[08:24:52.339]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.339] getGlobalsAndPackages() ...
[08:24:52.339] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.340] Resolving globals: FALSE
[08:24:52.340] Tweak future expression to call with '...' arguments ...
[08:24:52.340] {
[08:24:52.340]     do.call(function(...) {
[08:24:52.340]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.340]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.340]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.340]             on.exit(options(oopts), add = TRUE)
[08:24:52.340]         }
[08:24:52.340]         {
[08:24:52.340]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.340]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.340]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.340]             })
[08:24:52.340]         }
[08:24:52.340]     }, args = future.call.arguments)
[08:24:52.340] }
[08:24:52.341] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.341] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.342] 
[08:24:52.342] getGlobalsAndPackages() ... DONE
[08:24:52.342] run() for ‘Future’ ...
[08:24:52.343] - state: ‘created’
[08:24:52.343] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.346] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.346] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.347]   - Field: ‘label’
[08:24:52.347]   - Field: ‘local’
[08:24:52.347]   - Field: ‘owner’
[08:24:52.347]   - Field: ‘envir’
[08:24:52.347]   - Field: ‘workers’
[08:24:52.348]   - Field: ‘packages’
[08:24:52.348]   - Field: ‘gc’
[08:24:52.348]   - Field: ‘job’
[08:24:52.348]   - Field: ‘conditions’
[08:24:52.348]   - Field: ‘expr’
[08:24:52.348]   - Field: ‘uuid’
[08:24:52.349]   - Field: ‘seed’
[08:24:52.349]   - Field: ‘version’
[08:24:52.349]   - Field: ‘result’
[08:24:52.349]   - Field: ‘asynchronous’
[08:24:52.349]   - Field: ‘calls’
[08:24:52.349]   - Field: ‘globals’
[08:24:52.350]   - Field: ‘stdout’
[08:24:52.350]   - Field: ‘earlySignal’
[08:24:52.350]   - Field: ‘lazy’
[08:24:52.350]   - Field: ‘state’
[08:24:52.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.351] - Launch lazy future ...
[08:24:52.351] Packages needed by the future expression (n = 0): <none>
[08:24:52.351] Packages needed by future strategies (n = 0): <none>
[08:24:52.352] {
[08:24:52.352]     {
[08:24:52.352]         {
[08:24:52.352]             ...future.startTime <- base::Sys.time()
[08:24:52.352]             {
[08:24:52.352]                 {
[08:24:52.352]                   {
[08:24:52.352]                     {
[08:24:52.352]                       base::local({
[08:24:52.352]                         has_future <- base::requireNamespace("future", 
[08:24:52.352]                           quietly = TRUE)
[08:24:52.352]                         if (has_future) {
[08:24:52.352]                           ns <- base::getNamespace("future")
[08:24:52.352]                           version <- ns[[".package"]][["version"]]
[08:24:52.352]                           if (is.null(version)) 
[08:24:52.352]                             version <- utils::packageVersion("future")
[08:24:52.352]                         }
[08:24:52.352]                         else {
[08:24:52.352]                           version <- NULL
[08:24:52.352]                         }
[08:24:52.352]                         if (!has_future || version < "1.8.0") {
[08:24:52.352]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.352]                             "", base::R.version$version.string), 
[08:24:52.352]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.352]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.352]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.352]                               "release", "version")], collapse = " "), 
[08:24:52.352]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.352]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.352]                             info)
[08:24:52.352]                           info <- base::paste(info, collapse = "; ")
[08:24:52.352]                           if (!has_future) {
[08:24:52.352]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.352]                               info)
[08:24:52.352]                           }
[08:24:52.352]                           else {
[08:24:52.352]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.352]                               info, version)
[08:24:52.352]                           }
[08:24:52.352]                           base::stop(msg)
[08:24:52.352]                         }
[08:24:52.352]                       })
[08:24:52.352]                     }
[08:24:52.352]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.352]                     base::options(mc.cores = 1L)
[08:24:52.352]                   }
[08:24:52.352]                   ...future.strategy.old <- future::plan("list")
[08:24:52.352]                   options(future.plan = NULL)
[08:24:52.352]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.352]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.352]                 }
[08:24:52.352]                 ...future.workdir <- getwd()
[08:24:52.352]             }
[08:24:52.352]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.352]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.352]         }
[08:24:52.352]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.352]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.352]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.352]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.352]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.352]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.352]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.352]             base::names(...future.oldOptions))
[08:24:52.352]     }
[08:24:52.352]     if (FALSE) {
[08:24:52.352]     }
[08:24:52.352]     else {
[08:24:52.352]         if (TRUE) {
[08:24:52.352]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.352]                 open = "w")
[08:24:52.352]         }
[08:24:52.352]         else {
[08:24:52.352]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.352]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.352]         }
[08:24:52.352]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.352]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.352]             base::sink(type = "output", split = FALSE)
[08:24:52.352]             base::close(...future.stdout)
[08:24:52.352]         }, add = TRUE)
[08:24:52.352]     }
[08:24:52.352]     ...future.frame <- base::sys.nframe()
[08:24:52.352]     ...future.conditions <- base::list()
[08:24:52.352]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.352]     if (FALSE) {
[08:24:52.352]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.352]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.352]     }
[08:24:52.352]     ...future.result <- base::tryCatch({
[08:24:52.352]         base::withCallingHandlers({
[08:24:52.352]             ...future.value <- base::withVisible(base::local({
[08:24:52.352]                 withCallingHandlers({
[08:24:52.352]                   {
[08:24:52.352]                     do.call(function(...) {
[08:24:52.352]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.352]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.352]                         ...future.globals.maxSize)) {
[08:24:52.352]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.352]                         on.exit(options(oopts), add = TRUE)
[08:24:52.352]                       }
[08:24:52.352]                       {
[08:24:52.352]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.352]                           FUN = function(jj) {
[08:24:52.352]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.352]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.352]                           })
[08:24:52.352]                       }
[08:24:52.352]                     }, args = future.call.arguments)
[08:24:52.352]                   }
[08:24:52.352]                 }, immediateCondition = function(cond) {
[08:24:52.352]                   save_rds <- function (object, pathname, ...) 
[08:24:52.352]                   {
[08:24:52.352]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.352]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.352]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.352]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.352]                         fi_tmp[["mtime"]])
[08:24:52.352]                     }
[08:24:52.352]                     tryCatch({
[08:24:52.352]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.352]                     }, error = function(ex) {
[08:24:52.352]                       msg <- conditionMessage(ex)
[08:24:52.352]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.352]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.352]                         fi_tmp[["mtime"]], msg)
[08:24:52.352]                       ex$message <- msg
[08:24:52.352]                       stop(ex)
[08:24:52.352]                     })
[08:24:52.352]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.352]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.352]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.352]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.352]                       fi <- file.info(pathname)
[08:24:52.352]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.352]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.352]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.352]                         fi[["size"]], fi[["mtime"]])
[08:24:52.352]                       stop(msg)
[08:24:52.352]                     }
[08:24:52.352]                     invisible(pathname)
[08:24:52.352]                   }
[08:24:52.352]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.352]                     rootPath = tempdir()) 
[08:24:52.352]                   {
[08:24:52.352]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.352]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.352]                       tmpdir = path, fileext = ".rds")
[08:24:52.352]                     save_rds(obj, file)
[08:24:52.352]                   }
[08:24:52.352]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.352]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.352]                   {
[08:24:52.352]                     inherits <- base::inherits
[08:24:52.352]                     invokeRestart <- base::invokeRestart
[08:24:52.352]                     is.null <- base::is.null
[08:24:52.352]                     muffled <- FALSE
[08:24:52.352]                     if (inherits(cond, "message")) {
[08:24:52.352]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.352]                       if (muffled) 
[08:24:52.352]                         invokeRestart("muffleMessage")
[08:24:52.352]                     }
[08:24:52.352]                     else if (inherits(cond, "warning")) {
[08:24:52.352]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.352]                       if (muffled) 
[08:24:52.352]                         invokeRestart("muffleWarning")
[08:24:52.352]                     }
[08:24:52.352]                     else if (inherits(cond, "condition")) {
[08:24:52.352]                       if (!is.null(pattern)) {
[08:24:52.352]                         computeRestarts <- base::computeRestarts
[08:24:52.352]                         grepl <- base::grepl
[08:24:52.352]                         restarts <- computeRestarts(cond)
[08:24:52.352]                         for (restart in restarts) {
[08:24:52.352]                           name <- restart$name
[08:24:52.352]                           if (is.null(name)) 
[08:24:52.352]                             next
[08:24:52.352]                           if (!grepl(pattern, name)) 
[08:24:52.352]                             next
[08:24:52.352]                           invokeRestart(restart)
[08:24:52.352]                           muffled <- TRUE
[08:24:52.352]                           break
[08:24:52.352]                         }
[08:24:52.352]                       }
[08:24:52.352]                     }
[08:24:52.352]                     invisible(muffled)
[08:24:52.352]                   }
[08:24:52.352]                   muffleCondition(cond)
[08:24:52.352]                 })
[08:24:52.352]             }))
[08:24:52.352]             future::FutureResult(value = ...future.value$value, 
[08:24:52.352]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.352]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.352]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.352]                     ...future.globalenv.names))
[08:24:52.352]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.352]         }, condition = base::local({
[08:24:52.352]             c <- base::c
[08:24:52.352]             inherits <- base::inherits
[08:24:52.352]             invokeRestart <- base::invokeRestart
[08:24:52.352]             length <- base::length
[08:24:52.352]             list <- base::list
[08:24:52.352]             seq.int <- base::seq.int
[08:24:52.352]             signalCondition <- base::signalCondition
[08:24:52.352]             sys.calls <- base::sys.calls
[08:24:52.352]             `[[` <- base::`[[`
[08:24:52.352]             `+` <- base::`+`
[08:24:52.352]             `<<-` <- base::`<<-`
[08:24:52.352]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.352]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.352]                   3L)]
[08:24:52.352]             }
[08:24:52.352]             function(cond) {
[08:24:52.352]                 is_error <- inherits(cond, "error")
[08:24:52.352]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.352]                   NULL)
[08:24:52.352]                 if (is_error) {
[08:24:52.352]                   sessionInformation <- function() {
[08:24:52.352]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.352]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.352]                       search = base::search(), system = base::Sys.info())
[08:24:52.352]                   }
[08:24:52.352]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.352]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.352]                     cond$call), session = sessionInformation(), 
[08:24:52.352]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.352]                   signalCondition(cond)
[08:24:52.352]                 }
[08:24:52.352]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.352]                 "immediateCondition"))) {
[08:24:52.352]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.352]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.352]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.352]                   if (TRUE && !signal) {
[08:24:52.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.352]                     {
[08:24:52.352]                       inherits <- base::inherits
[08:24:52.352]                       invokeRestart <- base::invokeRestart
[08:24:52.352]                       is.null <- base::is.null
[08:24:52.352]                       muffled <- FALSE
[08:24:52.352]                       if (inherits(cond, "message")) {
[08:24:52.352]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.352]                         if (muffled) 
[08:24:52.352]                           invokeRestart("muffleMessage")
[08:24:52.352]                       }
[08:24:52.352]                       else if (inherits(cond, "warning")) {
[08:24:52.352]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.352]                         if (muffled) 
[08:24:52.352]                           invokeRestart("muffleWarning")
[08:24:52.352]                       }
[08:24:52.352]                       else if (inherits(cond, "condition")) {
[08:24:52.352]                         if (!is.null(pattern)) {
[08:24:52.352]                           computeRestarts <- base::computeRestarts
[08:24:52.352]                           grepl <- base::grepl
[08:24:52.352]                           restarts <- computeRestarts(cond)
[08:24:52.352]                           for (restart in restarts) {
[08:24:52.352]                             name <- restart$name
[08:24:52.352]                             if (is.null(name)) 
[08:24:52.352]                               next
[08:24:52.352]                             if (!grepl(pattern, name)) 
[08:24:52.352]                               next
[08:24:52.352]                             invokeRestart(restart)
[08:24:52.352]                             muffled <- TRUE
[08:24:52.352]                             break
[08:24:52.352]                           }
[08:24:52.352]                         }
[08:24:52.352]                       }
[08:24:52.352]                       invisible(muffled)
[08:24:52.352]                     }
[08:24:52.352]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.352]                   }
[08:24:52.352]                 }
[08:24:52.352]                 else {
[08:24:52.352]                   if (TRUE) {
[08:24:52.352]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.352]                     {
[08:24:52.352]                       inherits <- base::inherits
[08:24:52.352]                       invokeRestart <- base::invokeRestart
[08:24:52.352]                       is.null <- base::is.null
[08:24:52.352]                       muffled <- FALSE
[08:24:52.352]                       if (inherits(cond, "message")) {
[08:24:52.352]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.352]                         if (muffled) 
[08:24:52.352]                           invokeRestart("muffleMessage")
[08:24:52.352]                       }
[08:24:52.352]                       else if (inherits(cond, "warning")) {
[08:24:52.352]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.352]                         if (muffled) 
[08:24:52.352]                           invokeRestart("muffleWarning")
[08:24:52.352]                       }
[08:24:52.352]                       else if (inherits(cond, "condition")) {
[08:24:52.352]                         if (!is.null(pattern)) {
[08:24:52.352]                           computeRestarts <- base::computeRestarts
[08:24:52.352]                           grepl <- base::grepl
[08:24:52.352]                           restarts <- computeRestarts(cond)
[08:24:52.352]                           for (restart in restarts) {
[08:24:52.352]                             name <- restart$name
[08:24:52.352]                             if (is.null(name)) 
[08:24:52.352]                               next
[08:24:52.352]                             if (!grepl(pattern, name)) 
[08:24:52.352]                               next
[08:24:52.352]                             invokeRestart(restart)
[08:24:52.352]                             muffled <- TRUE
[08:24:52.352]                             break
[08:24:52.352]                           }
[08:24:52.352]                         }
[08:24:52.352]                       }
[08:24:52.352]                       invisible(muffled)
[08:24:52.352]                     }
[08:24:52.352]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.352]                   }
[08:24:52.352]                 }
[08:24:52.352]             }
[08:24:52.352]         }))
[08:24:52.352]     }, error = function(ex) {
[08:24:52.352]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.352]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.352]                 ...future.rng), started = ...future.startTime, 
[08:24:52.352]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.352]             version = "1.8"), class = "FutureResult")
[08:24:52.352]     }, finally = {
[08:24:52.352]         if (!identical(...future.workdir, getwd())) 
[08:24:52.352]             setwd(...future.workdir)
[08:24:52.352]         {
[08:24:52.352]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.352]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.352]             }
[08:24:52.352]             base::options(...future.oldOptions)
[08:24:52.352]             if (.Platform$OS.type == "windows") {
[08:24:52.352]                 old_names <- names(...future.oldEnvVars)
[08:24:52.352]                 envs <- base::Sys.getenv()
[08:24:52.352]                 names <- names(envs)
[08:24:52.352]                 common <- intersect(names, old_names)
[08:24:52.352]                 added <- setdiff(names, old_names)
[08:24:52.352]                 removed <- setdiff(old_names, names)
[08:24:52.352]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.352]                   envs[common]]
[08:24:52.352]                 NAMES <- toupper(changed)
[08:24:52.352]                 args <- list()
[08:24:52.352]                 for (kk in seq_along(NAMES)) {
[08:24:52.352]                   name <- changed[[kk]]
[08:24:52.352]                   NAME <- NAMES[[kk]]
[08:24:52.352]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.352]                     next
[08:24:52.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.352]                 }
[08:24:52.352]                 NAMES <- toupper(added)
[08:24:52.352]                 for (kk in seq_along(NAMES)) {
[08:24:52.352]                   name <- added[[kk]]
[08:24:52.352]                   NAME <- NAMES[[kk]]
[08:24:52.352]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.352]                     next
[08:24:52.352]                   args[[name]] <- ""
[08:24:52.352]                 }
[08:24:52.352]                 NAMES <- toupper(removed)
[08:24:52.352]                 for (kk in seq_along(NAMES)) {
[08:24:52.352]                   name <- removed[[kk]]
[08:24:52.352]                   NAME <- NAMES[[kk]]
[08:24:52.352]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.352]                     next
[08:24:52.352]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.352]                 }
[08:24:52.352]                 if (length(args) > 0) 
[08:24:52.352]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.352]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.352]             }
[08:24:52.352]             else {
[08:24:52.352]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.352]             }
[08:24:52.352]             {
[08:24:52.352]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.352]                   0L) {
[08:24:52.352]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.352]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.352]                   base::options(opts)
[08:24:52.352]                 }
[08:24:52.352]                 {
[08:24:52.352]                   {
[08:24:52.352]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.352]                     NULL
[08:24:52.352]                   }
[08:24:52.352]                   options(future.plan = NULL)
[08:24:52.352]                   if (is.na(NA_character_)) 
[08:24:52.352]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.352]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.352]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.352]                     .init = FALSE)
[08:24:52.352]                 }
[08:24:52.352]             }
[08:24:52.352]         }
[08:24:52.352]     })
[08:24:52.352]     if (TRUE) {
[08:24:52.352]         base::sink(type = "output", split = FALSE)
[08:24:52.352]         if (TRUE) {
[08:24:52.352]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.352]         }
[08:24:52.352]         else {
[08:24:52.352]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.352]         }
[08:24:52.352]         base::close(...future.stdout)
[08:24:52.352]         ...future.stdout <- NULL
[08:24:52.352]     }
[08:24:52.352]     ...future.result$conditions <- ...future.conditions
[08:24:52.352]     ...future.result$finished <- base::Sys.time()
[08:24:52.352]     ...future.result
[08:24:52.352] }
[08:24:52.356] assign_globals() ...
[08:24:52.356] List of 5
[08:24:52.356]  $ future.call.arguments    : list()
[08:24:52.356]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.356]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:52.356]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:52.356]  $ ...future.elements_ii    :List of 1
[08:24:52.356]   ..$ : num [1:4] 2 4 6 8
[08:24:52.356]  $ ...future.seeds_ii       : NULL
[08:24:52.356]  $ ...future.globals.maxSize: num Inf
[08:24:52.356]  - attr(*, "resolved")= logi FALSE
[08:24:52.356]  - attr(*, "total_size")= num NA
[08:24:52.356]  - attr(*, "where")=List of 5
[08:24:52.356]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.356]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.356]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.356]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.356]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.356]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.356]  - attr(*, "already-done")= logi TRUE
[08:24:52.365] - copied ‘future.call.arguments’ to environment
[08:24:52.365] - copied ‘...future.FUN’ to environment
[08:24:52.366] - copied ‘...future.elements_ii’ to environment
[08:24:52.366] - copied ‘...future.seeds_ii’ to environment
[08:24:52.366] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.366] assign_globals() ... done
[08:24:52.366] requestCore(): workers = 2
[08:24:52.372] MulticoreFuture started
[08:24:52.373] - Launch lazy future ... done
[08:24:52.373] run() for ‘MulticoreFuture’ ... done
[08:24:52.373] plan(): Setting new future strategy stack:
[08:24:52.378] Created future:
[08:24:52.374] List of future strategies:
[08:24:52.374] 1. sequential:
[08:24:52.374]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.374]    - tweaked: FALSE
[08:24:52.374]    - call: NULL
[08:24:52.379] plan(): nbrOfWorkers() = 1
[08:24:52.383] plan(): Setting new future strategy stack:
[08:24:52.383] List of future strategies:
[08:24:52.383] 1. multicore:
[08:24:52.383]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.383]    - tweaked: FALSE
[08:24:52.383]    - call: plan(strategy)
[08:24:52.387] plan(): nbrOfWorkers() = 2
[08:24:52.378] MulticoreFuture:
[08:24:52.378] Label: ‘future_apply-2’
[08:24:52.378] Expression:
[08:24:52.378] {
[08:24:52.378]     do.call(function(...) {
[08:24:52.378]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.378]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.378]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.378]             on.exit(options(oopts), add = TRUE)
[08:24:52.378]         }
[08:24:52.378]         {
[08:24:52.378]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.378]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.378]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.378]             })
[08:24:52.378]         }
[08:24:52.378]     }, args = future.call.arguments)
[08:24:52.378] }
[08:24:52.378] Lazy evaluation: FALSE
[08:24:52.378] Asynchronous evaluation: TRUE
[08:24:52.378] Local evaluation: TRUE
[08:24:52.378] Environment: R_GlobalEnv
[08:24:52.378] Capture standard output: TRUE
[08:24:52.378] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.378] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.378] Packages: <none>
[08:24:52.378] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.378] Resolved: TRUE
[08:24:52.378] Value: <not collected>
[08:24:52.378] Conditions captured: <none>
[08:24:52.378] Early signaling: FALSE
[08:24:52.378] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.378] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.388] Chunk #2 of 2 ... DONE
[08:24:52.388] Launching 2 futures (chunks) ... DONE
[08:24:52.389] Resolving 2 futures (chunks) ...
[08:24:52.389] resolve() on list ...
[08:24:52.389]  recursive: 0
[08:24:52.389]  length: 2
[08:24:52.390] 
[08:24:52.390] Future #1
[08:24:52.391] result() for MulticoreFuture ...
[08:24:52.392] result() for MulticoreFuture ...
[08:24:52.392] result() for MulticoreFuture ... done
[08:24:52.392] result() for MulticoreFuture ... done
[08:24:52.393] result() for MulticoreFuture ...
[08:24:52.393] result() for MulticoreFuture ... done
[08:24:52.393] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:52.393] - nx: 2
[08:24:52.393] - relay: TRUE
[08:24:52.393] - stdout: TRUE
[08:24:52.394] - signal: TRUE
[08:24:52.394] - resignal: FALSE
[08:24:52.394] - force: TRUE
[08:24:52.394] - relayed: [n=2] FALSE, FALSE
[08:24:52.394] - queued futures: [n=2] FALSE, FALSE
[08:24:52.394]  - until=1
[08:24:52.394]  - relaying element #1
[08:24:52.395] result() for MulticoreFuture ...
[08:24:52.395] result() for MulticoreFuture ... done
[08:24:52.395] result() for MulticoreFuture ...
[08:24:52.395] result() for MulticoreFuture ... done
[08:24:52.395] result() for MulticoreFuture ...
[08:24:52.395] result() for MulticoreFuture ... done
[08:24:52.395] result() for MulticoreFuture ...
[08:24:52.396] result() for MulticoreFuture ... done
[08:24:52.396] - relayed: [n=2] TRUE, FALSE
[08:24:52.396] - queued futures: [n=2] TRUE, FALSE
[08:24:52.396] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:52.396]  length: 1 (resolved future 1)
[08:24:52.397] Future #2
[08:24:52.397] result() for MulticoreFuture ...
[08:24:52.397] result() for MulticoreFuture ...
[08:24:52.397] result() for MulticoreFuture ... done
[08:24:52.398] result() for MulticoreFuture ... done
[08:24:52.398] result() for MulticoreFuture ...
[08:24:52.398] result() for MulticoreFuture ... done
[08:24:52.398] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:52.398] - nx: 2
[08:24:52.398] - relay: TRUE
[08:24:52.398] - stdout: TRUE
[08:24:52.398] - signal: TRUE
[08:24:52.399] - resignal: FALSE
[08:24:52.399] - force: TRUE
[08:24:52.399] - relayed: [n=2] TRUE, FALSE
[08:24:52.399] - queued futures: [n=2] TRUE, FALSE
[08:24:52.399]  - until=2
[08:24:52.399]  - relaying element #2
[08:24:52.399] result() for MulticoreFuture ...
[08:24:52.399] result() for MulticoreFuture ... done
[08:24:52.399] result() for MulticoreFuture ...
[08:24:52.399] result() for MulticoreFuture ... done
[08:24:52.400] result() for MulticoreFuture ...
[08:24:52.400] result() for MulticoreFuture ... done
[08:24:52.400] result() for MulticoreFuture ...
[08:24:52.400] result() for MulticoreFuture ... done
[08:24:52.400] - relayed: [n=2] TRUE, TRUE
[08:24:52.400] - queued futures: [n=2] TRUE, TRUE
[08:24:52.400] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:52.400]  length: 0 (resolved future 2)
[08:24:52.401] Relaying remaining futures
[08:24:52.401] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.401] - nx: 2
[08:24:52.401] - relay: TRUE
[08:24:52.401] - stdout: TRUE
[08:24:52.401] - signal: TRUE
[08:24:52.401] - resignal: FALSE
[08:24:52.401] - force: TRUE
[08:24:52.401] - relayed: [n=2] TRUE, TRUE
[08:24:52.401] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:52.402] - relayed: [n=2] TRUE, TRUE
[08:24:52.402] - queued futures: [n=2] TRUE, TRUE
[08:24:52.402] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.402] resolve() on list ... DONE
[08:24:52.402] result() for MulticoreFuture ...
[08:24:52.402] result() for MulticoreFuture ... done
[08:24:52.402] result() for MulticoreFuture ...
[08:24:52.402] result() for MulticoreFuture ... done
[08:24:52.402] result() for MulticoreFuture ...
[08:24:52.403] result() for MulticoreFuture ... done
[08:24:52.403] result() for MulticoreFuture ...
[08:24:52.403] result() for MulticoreFuture ... done
[08:24:52.403]  - Number of value chunks collected: 2
[08:24:52.403] Resolving 2 futures (chunks) ... DONE
[08:24:52.403] Reducing values from 2 chunks ...
[08:24:52.403]  - Number of values collected after concatenation: 2
[08:24:52.403]  - Number of values expected: 2
[08:24:52.403] Reducing values from 2 chunks ... DONE
[08:24:52.404] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[08:24:52.404] getGlobalsAndPackagesXApply() ...
[08:24:52.404]  - future.globals: TRUE
[08:24:52.404] getGlobalsAndPackages() ...
[08:24:52.404] Searching for globals...
[08:24:52.442] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[08:24:52.442] Searching for globals ... DONE
[08:24:52.442] Resolving globals: FALSE
[08:24:52.444] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[08:24:52.445] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[08:24:52.445] - globals: [1] ‘FUN’
[08:24:52.445] 
[08:24:52.445] getGlobalsAndPackages() ... DONE
[08:24:52.445]  - globals found/used: [n=1] ‘FUN’
[08:24:52.445]  - needed namespaces: [n=0] 
[08:24:52.445] Finding globals ... DONE
[08:24:52.445]  - use_args: TRUE
[08:24:52.446]  - Getting '...' globals ...
[08:24:52.446] resolve() on list ...
[08:24:52.446]  recursive: 0
[08:24:52.446]  length: 1
[08:24:52.446]  elements: ‘...’
[08:24:52.446]  length: 0 (resolved future 1)
[08:24:52.446] resolve() on list ... DONE
[08:24:52.446]    - '...' content: [n=0] 
[08:24:52.447] List of 1
[08:24:52.447]  $ ...: list()
[08:24:52.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.447]  - attr(*, "where")=List of 1
[08:24:52.447]   ..$ ...:<environment: 0x56540dd41970> 
[08:24:52.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.447]  - attr(*, "resolved")= logi TRUE
[08:24:52.447]  - attr(*, "total_size")= num NA
[08:24:52.449]  - Getting '...' globals ... DONE
[08:24:52.450] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.450] List of 2
[08:24:52.450]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:52.450]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:52.450]  $ ...          : list()
[08:24:52.450]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.450]  - attr(*, "where")=List of 2
[08:24:52.450]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.450]   ..$ ...          :<environment: 0x56540dd41970> 
[08:24:52.450]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.450]  - attr(*, "resolved")= logi FALSE
[08:24:52.450]  - attr(*, "total_size")= num 65967
[08:24:52.454] Packages to be attached in all futures: [n=0] 
[08:24:52.455] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.456] future_lapply() ...
[08:24:52.491] Number of chunks: 2
[08:24:52.492] getGlobalsAndPackagesXApply() ...
[08:24:52.492]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.492]  - use_args: TRUE
[08:24:52.492] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.492] List of 2
[08:24:52.492]  $ ...          : list()
[08:24:52.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.492]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:52.492]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:52.492]  - attr(*, "where")=List of 2
[08:24:52.492]   ..$ ...          :<environment: 0x56540dd41970> 
[08:24:52.492]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:52.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.492]  - attr(*, "resolved")= logi FALSE
[08:24:52.492]  - attr(*, "total_size")= num NA
[08:24:52.496] Packages to be attached in all futures: [n=0] 
[08:24:52.496] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.496] Number of futures (= number of chunks): 2
[08:24:52.496] Launching 2 futures (chunks) ...
[08:24:52.496] Chunk #1 of 2 ...
[08:24:52.496]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.496]  - seeds: <none>
[08:24:52.497]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.497] getGlobalsAndPackages() ...
[08:24:52.497] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.497] Resolving globals: FALSE
[08:24:52.497] Tweak future expression to call with '...' arguments ...
[08:24:52.497] {
[08:24:52.497]     do.call(function(...) {
[08:24:52.497]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.497]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.497]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.497]             on.exit(options(oopts), add = TRUE)
[08:24:52.497]         }
[08:24:52.497]         {
[08:24:52.497]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.497]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.497]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.497]             })
[08:24:52.497]         }
[08:24:52.497]     }, args = future.call.arguments)
[08:24:52.497] }
[08:24:52.497] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.498] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.498] 
[08:24:52.498] getGlobalsAndPackages() ... DONE
[08:24:52.498] run() for ‘Future’ ...
[08:24:52.498] - state: ‘created’
[08:24:52.499] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.500] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.500] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.500]   - Field: ‘label’
[08:24:52.501]   - Field: ‘local’
[08:24:52.501]   - Field: ‘owner’
[08:24:52.501]   - Field: ‘envir’
[08:24:52.501]   - Field: ‘workers’
[08:24:52.501]   - Field: ‘packages’
[08:24:52.501]   - Field: ‘gc’
[08:24:52.501]   - Field: ‘job’
[08:24:52.501]   - Field: ‘conditions’
[08:24:52.501]   - Field: ‘expr’
[08:24:52.501]   - Field: ‘uuid’
[08:24:52.501]   - Field: ‘seed’
[08:24:52.501]   - Field: ‘version’
[08:24:52.502]   - Field: ‘result’
[08:24:52.502]   - Field: ‘asynchronous’
[08:24:52.502]   - Field: ‘calls’
[08:24:52.502]   - Field: ‘globals’
[08:24:52.502]   - Field: ‘stdout’
[08:24:52.502]   - Field: ‘earlySignal’
[08:24:52.502]   - Field: ‘lazy’
[08:24:52.502]   - Field: ‘state’
[08:24:52.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.502] - Launch lazy future ...
[08:24:52.503] Packages needed by the future expression (n = 0): <none>
[08:24:52.503] Packages needed by future strategies (n = 0): <none>
[08:24:52.503] {
[08:24:52.503]     {
[08:24:52.503]         {
[08:24:52.503]             ...future.startTime <- base::Sys.time()
[08:24:52.503]             {
[08:24:52.503]                 {
[08:24:52.503]                   {
[08:24:52.503]                     {
[08:24:52.503]                       base::local({
[08:24:52.503]                         has_future <- base::requireNamespace("future", 
[08:24:52.503]                           quietly = TRUE)
[08:24:52.503]                         if (has_future) {
[08:24:52.503]                           ns <- base::getNamespace("future")
[08:24:52.503]                           version <- ns[[".package"]][["version"]]
[08:24:52.503]                           if (is.null(version)) 
[08:24:52.503]                             version <- utils::packageVersion("future")
[08:24:52.503]                         }
[08:24:52.503]                         else {
[08:24:52.503]                           version <- NULL
[08:24:52.503]                         }
[08:24:52.503]                         if (!has_future || version < "1.8.0") {
[08:24:52.503]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.503]                             "", base::R.version$version.string), 
[08:24:52.503]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.503]                               "release", "version")], collapse = " "), 
[08:24:52.503]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.503]                             info)
[08:24:52.503]                           info <- base::paste(info, collapse = "; ")
[08:24:52.503]                           if (!has_future) {
[08:24:52.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.503]                               info)
[08:24:52.503]                           }
[08:24:52.503]                           else {
[08:24:52.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.503]                               info, version)
[08:24:52.503]                           }
[08:24:52.503]                           base::stop(msg)
[08:24:52.503]                         }
[08:24:52.503]                       })
[08:24:52.503]                     }
[08:24:52.503]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.503]                     base::options(mc.cores = 1L)
[08:24:52.503]                   }
[08:24:52.503]                   ...future.strategy.old <- future::plan("list")
[08:24:52.503]                   options(future.plan = NULL)
[08:24:52.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.503]                 }
[08:24:52.503]                 ...future.workdir <- getwd()
[08:24:52.503]             }
[08:24:52.503]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.503]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.503]         }
[08:24:52.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.503]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.503]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.503]             base::names(...future.oldOptions))
[08:24:52.503]     }
[08:24:52.503]     if (FALSE) {
[08:24:52.503]     }
[08:24:52.503]     else {
[08:24:52.503]         if (TRUE) {
[08:24:52.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.503]                 open = "w")
[08:24:52.503]         }
[08:24:52.503]         else {
[08:24:52.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.503]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.503]         }
[08:24:52.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.503]             base::sink(type = "output", split = FALSE)
[08:24:52.503]             base::close(...future.stdout)
[08:24:52.503]         }, add = TRUE)
[08:24:52.503]     }
[08:24:52.503]     ...future.frame <- base::sys.nframe()
[08:24:52.503]     ...future.conditions <- base::list()
[08:24:52.503]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.503]     if (FALSE) {
[08:24:52.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.503]     }
[08:24:52.503]     ...future.result <- base::tryCatch({
[08:24:52.503]         base::withCallingHandlers({
[08:24:52.503]             ...future.value <- base::withVisible(base::local({
[08:24:52.503]                 withCallingHandlers({
[08:24:52.503]                   {
[08:24:52.503]                     do.call(function(...) {
[08:24:52.503]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.503]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.503]                         ...future.globals.maxSize)) {
[08:24:52.503]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.503]                         on.exit(options(oopts), add = TRUE)
[08:24:52.503]                       }
[08:24:52.503]                       {
[08:24:52.503]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.503]                           FUN = function(jj) {
[08:24:52.503]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.503]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.503]                           })
[08:24:52.503]                       }
[08:24:52.503]                     }, args = future.call.arguments)
[08:24:52.503]                   }
[08:24:52.503]                 }, immediateCondition = function(cond) {
[08:24:52.503]                   save_rds <- function (object, pathname, ...) 
[08:24:52.503]                   {
[08:24:52.503]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.503]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.503]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.503]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.503]                         fi_tmp[["mtime"]])
[08:24:52.503]                     }
[08:24:52.503]                     tryCatch({
[08:24:52.503]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.503]                     }, error = function(ex) {
[08:24:52.503]                       msg <- conditionMessage(ex)
[08:24:52.503]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.503]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.503]                         fi_tmp[["mtime"]], msg)
[08:24:52.503]                       ex$message <- msg
[08:24:52.503]                       stop(ex)
[08:24:52.503]                     })
[08:24:52.503]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.503]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.503]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.503]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.503]                       fi <- file.info(pathname)
[08:24:52.503]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.503]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.503]                         fi[["size"]], fi[["mtime"]])
[08:24:52.503]                       stop(msg)
[08:24:52.503]                     }
[08:24:52.503]                     invisible(pathname)
[08:24:52.503]                   }
[08:24:52.503]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.503]                     rootPath = tempdir()) 
[08:24:52.503]                   {
[08:24:52.503]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.503]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.503]                       tmpdir = path, fileext = ".rds")
[08:24:52.503]                     save_rds(obj, file)
[08:24:52.503]                   }
[08:24:52.503]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.503]                   {
[08:24:52.503]                     inherits <- base::inherits
[08:24:52.503]                     invokeRestart <- base::invokeRestart
[08:24:52.503]                     is.null <- base::is.null
[08:24:52.503]                     muffled <- FALSE
[08:24:52.503]                     if (inherits(cond, "message")) {
[08:24:52.503]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.503]                       if (muffled) 
[08:24:52.503]                         invokeRestart("muffleMessage")
[08:24:52.503]                     }
[08:24:52.503]                     else if (inherits(cond, "warning")) {
[08:24:52.503]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.503]                       if (muffled) 
[08:24:52.503]                         invokeRestart("muffleWarning")
[08:24:52.503]                     }
[08:24:52.503]                     else if (inherits(cond, "condition")) {
[08:24:52.503]                       if (!is.null(pattern)) {
[08:24:52.503]                         computeRestarts <- base::computeRestarts
[08:24:52.503]                         grepl <- base::grepl
[08:24:52.503]                         restarts <- computeRestarts(cond)
[08:24:52.503]                         for (restart in restarts) {
[08:24:52.503]                           name <- restart$name
[08:24:52.503]                           if (is.null(name)) 
[08:24:52.503]                             next
[08:24:52.503]                           if (!grepl(pattern, name)) 
[08:24:52.503]                             next
[08:24:52.503]                           invokeRestart(restart)
[08:24:52.503]                           muffled <- TRUE
[08:24:52.503]                           break
[08:24:52.503]                         }
[08:24:52.503]                       }
[08:24:52.503]                     }
[08:24:52.503]                     invisible(muffled)
[08:24:52.503]                   }
[08:24:52.503]                   muffleCondition(cond)
[08:24:52.503]                 })
[08:24:52.503]             }))
[08:24:52.503]             future::FutureResult(value = ...future.value$value, 
[08:24:52.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.503]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.503]                     ...future.globalenv.names))
[08:24:52.503]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.503]         }, condition = base::local({
[08:24:52.503]             c <- base::c
[08:24:52.503]             inherits <- base::inherits
[08:24:52.503]             invokeRestart <- base::invokeRestart
[08:24:52.503]             length <- base::length
[08:24:52.503]             list <- base::list
[08:24:52.503]             seq.int <- base::seq.int
[08:24:52.503]             signalCondition <- base::signalCondition
[08:24:52.503]             sys.calls <- base::sys.calls
[08:24:52.503]             `[[` <- base::`[[`
[08:24:52.503]             `+` <- base::`+`
[08:24:52.503]             `<<-` <- base::`<<-`
[08:24:52.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.503]                   3L)]
[08:24:52.503]             }
[08:24:52.503]             function(cond) {
[08:24:52.503]                 is_error <- inherits(cond, "error")
[08:24:52.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.503]                   NULL)
[08:24:52.503]                 if (is_error) {
[08:24:52.503]                   sessionInformation <- function() {
[08:24:52.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.503]                       search = base::search(), system = base::Sys.info())
[08:24:52.503]                   }
[08:24:52.503]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.503]                     cond$call), session = sessionInformation(), 
[08:24:52.503]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.503]                   signalCondition(cond)
[08:24:52.503]                 }
[08:24:52.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.503]                 "immediateCondition"))) {
[08:24:52.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.503]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.503]                   if (TRUE && !signal) {
[08:24:52.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.503]                     {
[08:24:52.503]                       inherits <- base::inherits
[08:24:52.503]                       invokeRestart <- base::invokeRestart
[08:24:52.503]                       is.null <- base::is.null
[08:24:52.503]                       muffled <- FALSE
[08:24:52.503]                       if (inherits(cond, "message")) {
[08:24:52.503]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.503]                         if (muffled) 
[08:24:52.503]                           invokeRestart("muffleMessage")
[08:24:52.503]                       }
[08:24:52.503]                       else if (inherits(cond, "warning")) {
[08:24:52.503]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.503]                         if (muffled) 
[08:24:52.503]                           invokeRestart("muffleWarning")
[08:24:52.503]                       }
[08:24:52.503]                       else if (inherits(cond, "condition")) {
[08:24:52.503]                         if (!is.null(pattern)) {
[08:24:52.503]                           computeRestarts <- base::computeRestarts
[08:24:52.503]                           grepl <- base::grepl
[08:24:52.503]                           restarts <- computeRestarts(cond)
[08:24:52.503]                           for (restart in restarts) {
[08:24:52.503]                             name <- restart$name
[08:24:52.503]                             if (is.null(name)) 
[08:24:52.503]                               next
[08:24:52.503]                             if (!grepl(pattern, name)) 
[08:24:52.503]                               next
[08:24:52.503]                             invokeRestart(restart)
[08:24:52.503]                             muffled <- TRUE
[08:24:52.503]                             break
[08:24:52.503]                           }
[08:24:52.503]                         }
[08:24:52.503]                       }
[08:24:52.503]                       invisible(muffled)
[08:24:52.503]                     }
[08:24:52.503]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.503]                   }
[08:24:52.503]                 }
[08:24:52.503]                 else {
[08:24:52.503]                   if (TRUE) {
[08:24:52.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.503]                     {
[08:24:52.503]                       inherits <- base::inherits
[08:24:52.503]                       invokeRestart <- base::invokeRestart
[08:24:52.503]                       is.null <- base::is.null
[08:24:52.503]                       muffled <- FALSE
[08:24:52.503]                       if (inherits(cond, "message")) {
[08:24:52.503]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.503]                         if (muffled) 
[08:24:52.503]                           invokeRestart("muffleMessage")
[08:24:52.503]                       }
[08:24:52.503]                       else if (inherits(cond, "warning")) {
[08:24:52.503]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.503]                         if (muffled) 
[08:24:52.503]                           invokeRestart("muffleWarning")
[08:24:52.503]                       }
[08:24:52.503]                       else if (inherits(cond, "condition")) {
[08:24:52.503]                         if (!is.null(pattern)) {
[08:24:52.503]                           computeRestarts <- base::computeRestarts
[08:24:52.503]                           grepl <- base::grepl
[08:24:52.503]                           restarts <- computeRestarts(cond)
[08:24:52.503]                           for (restart in restarts) {
[08:24:52.503]                             name <- restart$name
[08:24:52.503]                             if (is.null(name)) 
[08:24:52.503]                               next
[08:24:52.503]                             if (!grepl(pattern, name)) 
[08:24:52.503]                               next
[08:24:52.503]                             invokeRestart(restart)
[08:24:52.503]                             muffled <- TRUE
[08:24:52.503]                             break
[08:24:52.503]                           }
[08:24:52.503]                         }
[08:24:52.503]                       }
[08:24:52.503]                       invisible(muffled)
[08:24:52.503]                     }
[08:24:52.503]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.503]                   }
[08:24:52.503]                 }
[08:24:52.503]             }
[08:24:52.503]         }))
[08:24:52.503]     }, error = function(ex) {
[08:24:52.503]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.503]                 ...future.rng), started = ...future.startTime, 
[08:24:52.503]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.503]             version = "1.8"), class = "FutureResult")
[08:24:52.503]     }, finally = {
[08:24:52.503]         if (!identical(...future.workdir, getwd())) 
[08:24:52.503]             setwd(...future.workdir)
[08:24:52.503]         {
[08:24:52.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.503]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.503]             }
[08:24:52.503]             base::options(...future.oldOptions)
[08:24:52.503]             if (.Platform$OS.type == "windows") {
[08:24:52.503]                 old_names <- names(...future.oldEnvVars)
[08:24:52.503]                 envs <- base::Sys.getenv()
[08:24:52.503]                 names <- names(envs)
[08:24:52.503]                 common <- intersect(names, old_names)
[08:24:52.503]                 added <- setdiff(names, old_names)
[08:24:52.503]                 removed <- setdiff(old_names, names)
[08:24:52.503]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.503]                   envs[common]]
[08:24:52.503]                 NAMES <- toupper(changed)
[08:24:52.503]                 args <- list()
[08:24:52.503]                 for (kk in seq_along(NAMES)) {
[08:24:52.503]                   name <- changed[[kk]]
[08:24:52.503]                   NAME <- NAMES[[kk]]
[08:24:52.503]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.503]                     next
[08:24:52.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.503]                 }
[08:24:52.503]                 NAMES <- toupper(added)
[08:24:52.503]                 for (kk in seq_along(NAMES)) {
[08:24:52.503]                   name <- added[[kk]]
[08:24:52.503]                   NAME <- NAMES[[kk]]
[08:24:52.503]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.503]                     next
[08:24:52.503]                   args[[name]] <- ""
[08:24:52.503]                 }
[08:24:52.503]                 NAMES <- toupper(removed)
[08:24:52.503]                 for (kk in seq_along(NAMES)) {
[08:24:52.503]                   name <- removed[[kk]]
[08:24:52.503]                   NAME <- NAMES[[kk]]
[08:24:52.503]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.503]                     next
[08:24:52.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.503]                 }
[08:24:52.503]                 if (length(args) > 0) 
[08:24:52.503]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.503]             }
[08:24:52.503]             else {
[08:24:52.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.503]             }
[08:24:52.503]             {
[08:24:52.503]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.503]                   0L) {
[08:24:52.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.503]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.503]                   base::options(opts)
[08:24:52.503]                 }
[08:24:52.503]                 {
[08:24:52.503]                   {
[08:24:52.503]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.503]                     NULL
[08:24:52.503]                   }
[08:24:52.503]                   options(future.plan = NULL)
[08:24:52.503]                   if (is.na(NA_character_)) 
[08:24:52.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.503]                     .init = FALSE)
[08:24:52.503]                 }
[08:24:52.503]             }
[08:24:52.503]         }
[08:24:52.503]     })
[08:24:52.503]     if (TRUE) {
[08:24:52.503]         base::sink(type = "output", split = FALSE)
[08:24:52.503]         if (TRUE) {
[08:24:52.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.503]         }
[08:24:52.503]         else {
[08:24:52.503]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.503]         }
[08:24:52.503]         base::close(...future.stdout)
[08:24:52.503]         ...future.stdout <- NULL
[08:24:52.503]     }
[08:24:52.503]     ...future.result$conditions <- ...future.conditions
[08:24:52.503]     ...future.result$finished <- base::Sys.time()
[08:24:52.503]     ...future.result
[08:24:52.503] }
[08:24:52.506] assign_globals() ...
[08:24:52.506] List of 5
[08:24:52.506]  $ future.call.arguments    : list()
[08:24:52.506]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.506]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:52.506]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:52.506]  $ ...future.elements_ii    :List of 1
[08:24:52.506]   ..$ : num [1:4] 1 3 1 7
[08:24:52.506]  $ ...future.seeds_ii       : NULL
[08:24:52.506]  $ ...future.globals.maxSize: num Inf
[08:24:52.506]  - attr(*, "resolved")= logi FALSE
[08:24:52.506]  - attr(*, "total_size")= num NA
[08:24:52.506]  - attr(*, "where")=List of 5
[08:24:52.506]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.506]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.506]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.506]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.506]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.506]  - attr(*, "already-done")= logi TRUE
[08:24:52.510] - copied ‘future.call.arguments’ to environment
[08:24:52.511] - copied ‘...future.FUN’ to environment
[08:24:52.511] - copied ‘...future.elements_ii’ to environment
[08:24:52.511] - copied ‘...future.seeds_ii’ to environment
[08:24:52.511] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.511] assign_globals() ... done
[08:24:52.511] requestCore(): workers = 2
[08:24:52.513] MulticoreFuture started
[08:24:52.514] - Launch lazy future ... done
[08:24:52.514] run() for ‘MulticoreFuture’ ... done
[08:24:52.514] Created future:
[08:24:52.514] plan(): Setting new future strategy stack:
[08:24:52.515] List of future strategies:
[08:24:52.515] 1. sequential:
[08:24:52.515]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.515]    - tweaked: FALSE
[08:24:52.515]    - call: NULL
[08:24:52.515] plan(): nbrOfWorkers() = 1
[08:24:52.521] plan(): Setting new future strategy stack:
[08:24:52.522] List of future strategies:
[08:24:52.522] 1. multicore:
[08:24:52.522]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.522]    - tweaked: FALSE
[08:24:52.522]    - call: plan(strategy)
[08:24:52.514] MulticoreFuture:
[08:24:52.514] Label: ‘future_apply-1’
[08:24:52.514] Expression:
[08:24:52.514] {
[08:24:52.514]     do.call(function(...) {
[08:24:52.514]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.514]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.514]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.514]             on.exit(options(oopts), add = TRUE)
[08:24:52.514]         }
[08:24:52.514]         {
[08:24:52.514]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.514]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.514]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.514]             })
[08:24:52.514]         }
[08:24:52.514]     }, args = future.call.arguments)
[08:24:52.514] }
[08:24:52.514] Lazy evaluation: FALSE
[08:24:52.514] Asynchronous evaluation: TRUE
[08:24:52.514] Local evaluation: TRUE
[08:24:52.514] Environment: R_GlobalEnv
[08:24:52.514] Capture standard output: TRUE
[08:24:52.514] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.514] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.514] Packages: <none>
[08:24:52.514] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.514] Resolved: FALSE
[08:24:52.514] Value: <not collected>
[08:24:52.514] Conditions captured: <none>
[08:24:52.514] Early signaling: FALSE
[08:24:52.514] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.514] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.527] Chunk #1 of 2 ... DONE
[08:24:52.527] plan(): nbrOfWorkers() = 2
[08:24:52.530] Chunk #2 of 2 ...
[08:24:52.530]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.531]  - seeds: <none>
[08:24:52.531]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.531] getGlobalsAndPackages() ...
[08:24:52.531] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.532] Resolving globals: FALSE
[08:24:52.532] Tweak future expression to call with '...' arguments ...
[08:24:52.532] {
[08:24:52.532]     do.call(function(...) {
[08:24:52.532]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.532]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.532]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.532]             on.exit(options(oopts), add = TRUE)
[08:24:52.532]         }
[08:24:52.532]         {
[08:24:52.532]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.532]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.532]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.532]             })
[08:24:52.532]         }
[08:24:52.532]     }, args = future.call.arguments)
[08:24:52.532] }
[08:24:52.533] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.534] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.534] 
[08:24:52.534] getGlobalsAndPackages() ... DONE
[08:24:52.535] run() for ‘Future’ ...
[08:24:52.535] - state: ‘created’
[08:24:52.535] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.538] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.539]   - Field: ‘label’
[08:24:52.539]   - Field: ‘local’
[08:24:52.539]   - Field: ‘owner’
[08:24:52.539]   - Field: ‘envir’
[08:24:52.539]   - Field: ‘workers’
[08:24:52.539]   - Field: ‘packages’
[08:24:52.539]   - Field: ‘gc’
[08:24:52.540]   - Field: ‘job’
[08:24:52.540]   - Field: ‘conditions’
[08:24:52.540]   - Field: ‘expr’
[08:24:52.540]   - Field: ‘uuid’
[08:24:52.540]   - Field: ‘seed’
[08:24:52.540]   - Field: ‘version’
[08:24:52.541]   - Field: ‘result’
[08:24:52.541]   - Field: ‘asynchronous’
[08:24:52.541]   - Field: ‘calls’
[08:24:52.541]   - Field: ‘globals’
[08:24:52.541]   - Field: ‘stdout’
[08:24:52.541]   - Field: ‘earlySignal’
[08:24:52.541]   - Field: ‘lazy’
[08:24:52.541]   - Field: ‘state’
[08:24:52.542] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.542] - Launch lazy future ...
[08:24:52.542] Packages needed by the future expression (n = 0): <none>
[08:24:52.542] Packages needed by future strategies (n = 0): <none>
[08:24:52.543] {
[08:24:52.543]     {
[08:24:52.543]         {
[08:24:52.543]             ...future.startTime <- base::Sys.time()
[08:24:52.543]             {
[08:24:52.543]                 {
[08:24:52.543]                   {
[08:24:52.543]                     {
[08:24:52.543]                       base::local({
[08:24:52.543]                         has_future <- base::requireNamespace("future", 
[08:24:52.543]                           quietly = TRUE)
[08:24:52.543]                         if (has_future) {
[08:24:52.543]                           ns <- base::getNamespace("future")
[08:24:52.543]                           version <- ns[[".package"]][["version"]]
[08:24:52.543]                           if (is.null(version)) 
[08:24:52.543]                             version <- utils::packageVersion("future")
[08:24:52.543]                         }
[08:24:52.543]                         else {
[08:24:52.543]                           version <- NULL
[08:24:52.543]                         }
[08:24:52.543]                         if (!has_future || version < "1.8.0") {
[08:24:52.543]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.543]                             "", base::R.version$version.string), 
[08:24:52.543]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.543]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.543]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.543]                               "release", "version")], collapse = " "), 
[08:24:52.543]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.543]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.543]                             info)
[08:24:52.543]                           info <- base::paste(info, collapse = "; ")
[08:24:52.543]                           if (!has_future) {
[08:24:52.543]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.543]                               info)
[08:24:52.543]                           }
[08:24:52.543]                           else {
[08:24:52.543]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.543]                               info, version)
[08:24:52.543]                           }
[08:24:52.543]                           base::stop(msg)
[08:24:52.543]                         }
[08:24:52.543]                       })
[08:24:52.543]                     }
[08:24:52.543]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.543]                     base::options(mc.cores = 1L)
[08:24:52.543]                   }
[08:24:52.543]                   ...future.strategy.old <- future::plan("list")
[08:24:52.543]                   options(future.plan = NULL)
[08:24:52.543]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.543]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.543]                 }
[08:24:52.543]                 ...future.workdir <- getwd()
[08:24:52.543]             }
[08:24:52.543]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.543]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.543]         }
[08:24:52.543]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.543]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.543]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.543]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.543]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.543]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.543]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.543]             base::names(...future.oldOptions))
[08:24:52.543]     }
[08:24:52.543]     if (FALSE) {
[08:24:52.543]     }
[08:24:52.543]     else {
[08:24:52.543]         if (TRUE) {
[08:24:52.543]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.543]                 open = "w")
[08:24:52.543]         }
[08:24:52.543]         else {
[08:24:52.543]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.543]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.543]         }
[08:24:52.543]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.543]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.543]             base::sink(type = "output", split = FALSE)
[08:24:52.543]             base::close(...future.stdout)
[08:24:52.543]         }, add = TRUE)
[08:24:52.543]     }
[08:24:52.543]     ...future.frame <- base::sys.nframe()
[08:24:52.543]     ...future.conditions <- base::list()
[08:24:52.543]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.543]     if (FALSE) {
[08:24:52.543]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.543]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.543]     }
[08:24:52.543]     ...future.result <- base::tryCatch({
[08:24:52.543]         base::withCallingHandlers({
[08:24:52.543]             ...future.value <- base::withVisible(base::local({
[08:24:52.543]                 withCallingHandlers({
[08:24:52.543]                   {
[08:24:52.543]                     do.call(function(...) {
[08:24:52.543]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.543]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.543]                         ...future.globals.maxSize)) {
[08:24:52.543]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.543]                         on.exit(options(oopts), add = TRUE)
[08:24:52.543]                       }
[08:24:52.543]                       {
[08:24:52.543]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.543]                           FUN = function(jj) {
[08:24:52.543]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.543]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.543]                           })
[08:24:52.543]                       }
[08:24:52.543]                     }, args = future.call.arguments)
[08:24:52.543]                   }
[08:24:52.543]                 }, immediateCondition = function(cond) {
[08:24:52.543]                   save_rds <- function (object, pathname, ...) 
[08:24:52.543]                   {
[08:24:52.543]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.543]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.543]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.543]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.543]                         fi_tmp[["mtime"]])
[08:24:52.543]                     }
[08:24:52.543]                     tryCatch({
[08:24:52.543]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.543]                     }, error = function(ex) {
[08:24:52.543]                       msg <- conditionMessage(ex)
[08:24:52.543]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.543]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.543]                         fi_tmp[["mtime"]], msg)
[08:24:52.543]                       ex$message <- msg
[08:24:52.543]                       stop(ex)
[08:24:52.543]                     })
[08:24:52.543]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.543]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.543]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.543]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.543]                       fi <- file.info(pathname)
[08:24:52.543]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.543]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.543]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.543]                         fi[["size"]], fi[["mtime"]])
[08:24:52.543]                       stop(msg)
[08:24:52.543]                     }
[08:24:52.543]                     invisible(pathname)
[08:24:52.543]                   }
[08:24:52.543]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.543]                     rootPath = tempdir()) 
[08:24:52.543]                   {
[08:24:52.543]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.543]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.543]                       tmpdir = path, fileext = ".rds")
[08:24:52.543]                     save_rds(obj, file)
[08:24:52.543]                   }
[08:24:52.543]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.543]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.543]                   {
[08:24:52.543]                     inherits <- base::inherits
[08:24:52.543]                     invokeRestart <- base::invokeRestart
[08:24:52.543]                     is.null <- base::is.null
[08:24:52.543]                     muffled <- FALSE
[08:24:52.543]                     if (inherits(cond, "message")) {
[08:24:52.543]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.543]                       if (muffled) 
[08:24:52.543]                         invokeRestart("muffleMessage")
[08:24:52.543]                     }
[08:24:52.543]                     else if (inherits(cond, "warning")) {
[08:24:52.543]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.543]                       if (muffled) 
[08:24:52.543]                         invokeRestart("muffleWarning")
[08:24:52.543]                     }
[08:24:52.543]                     else if (inherits(cond, "condition")) {
[08:24:52.543]                       if (!is.null(pattern)) {
[08:24:52.543]                         computeRestarts <- base::computeRestarts
[08:24:52.543]                         grepl <- base::grepl
[08:24:52.543]                         restarts <- computeRestarts(cond)
[08:24:52.543]                         for (restart in restarts) {
[08:24:52.543]                           name <- restart$name
[08:24:52.543]                           if (is.null(name)) 
[08:24:52.543]                             next
[08:24:52.543]                           if (!grepl(pattern, name)) 
[08:24:52.543]                             next
[08:24:52.543]                           invokeRestart(restart)
[08:24:52.543]                           muffled <- TRUE
[08:24:52.543]                           break
[08:24:52.543]                         }
[08:24:52.543]                       }
[08:24:52.543]                     }
[08:24:52.543]                     invisible(muffled)
[08:24:52.543]                   }
[08:24:52.543]                   muffleCondition(cond)
[08:24:52.543]                 })
[08:24:52.543]             }))
[08:24:52.543]             future::FutureResult(value = ...future.value$value, 
[08:24:52.543]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.543]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.543]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.543]                     ...future.globalenv.names))
[08:24:52.543]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.543]         }, condition = base::local({
[08:24:52.543]             c <- base::c
[08:24:52.543]             inherits <- base::inherits
[08:24:52.543]             invokeRestart <- base::invokeRestart
[08:24:52.543]             length <- base::length
[08:24:52.543]             list <- base::list
[08:24:52.543]             seq.int <- base::seq.int
[08:24:52.543]             signalCondition <- base::signalCondition
[08:24:52.543]             sys.calls <- base::sys.calls
[08:24:52.543]             `[[` <- base::`[[`
[08:24:52.543]             `+` <- base::`+`
[08:24:52.543]             `<<-` <- base::`<<-`
[08:24:52.543]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.543]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.543]                   3L)]
[08:24:52.543]             }
[08:24:52.543]             function(cond) {
[08:24:52.543]                 is_error <- inherits(cond, "error")
[08:24:52.543]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.543]                   NULL)
[08:24:52.543]                 if (is_error) {
[08:24:52.543]                   sessionInformation <- function() {
[08:24:52.543]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.543]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.543]                       search = base::search(), system = base::Sys.info())
[08:24:52.543]                   }
[08:24:52.543]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.543]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.543]                     cond$call), session = sessionInformation(), 
[08:24:52.543]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.543]                   signalCondition(cond)
[08:24:52.543]                 }
[08:24:52.543]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.543]                 "immediateCondition"))) {
[08:24:52.543]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.543]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.543]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.543]                   if (TRUE && !signal) {
[08:24:52.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.543]                     {
[08:24:52.543]                       inherits <- base::inherits
[08:24:52.543]                       invokeRestart <- base::invokeRestart
[08:24:52.543]                       is.null <- base::is.null
[08:24:52.543]                       muffled <- FALSE
[08:24:52.543]                       if (inherits(cond, "message")) {
[08:24:52.543]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.543]                         if (muffled) 
[08:24:52.543]                           invokeRestart("muffleMessage")
[08:24:52.543]                       }
[08:24:52.543]                       else if (inherits(cond, "warning")) {
[08:24:52.543]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.543]                         if (muffled) 
[08:24:52.543]                           invokeRestart("muffleWarning")
[08:24:52.543]                       }
[08:24:52.543]                       else if (inherits(cond, "condition")) {
[08:24:52.543]                         if (!is.null(pattern)) {
[08:24:52.543]                           computeRestarts <- base::computeRestarts
[08:24:52.543]                           grepl <- base::grepl
[08:24:52.543]                           restarts <- computeRestarts(cond)
[08:24:52.543]                           for (restart in restarts) {
[08:24:52.543]                             name <- restart$name
[08:24:52.543]                             if (is.null(name)) 
[08:24:52.543]                               next
[08:24:52.543]                             if (!grepl(pattern, name)) 
[08:24:52.543]                               next
[08:24:52.543]                             invokeRestart(restart)
[08:24:52.543]                             muffled <- TRUE
[08:24:52.543]                             break
[08:24:52.543]                           }
[08:24:52.543]                         }
[08:24:52.543]                       }
[08:24:52.543]                       invisible(muffled)
[08:24:52.543]                     }
[08:24:52.543]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.543]                   }
[08:24:52.543]                 }
[08:24:52.543]                 else {
[08:24:52.543]                   if (TRUE) {
[08:24:52.543]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.543]                     {
[08:24:52.543]                       inherits <- base::inherits
[08:24:52.543]                       invokeRestart <- base::invokeRestart
[08:24:52.543]                       is.null <- base::is.null
[08:24:52.543]                       muffled <- FALSE
[08:24:52.543]                       if (inherits(cond, "message")) {
[08:24:52.543]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.543]                         if (muffled) 
[08:24:52.543]                           invokeRestart("muffleMessage")
[08:24:52.543]                       }
[08:24:52.543]                       else if (inherits(cond, "warning")) {
[08:24:52.543]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.543]                         if (muffled) 
[08:24:52.543]                           invokeRestart("muffleWarning")
[08:24:52.543]                       }
[08:24:52.543]                       else if (inherits(cond, "condition")) {
[08:24:52.543]                         if (!is.null(pattern)) {
[08:24:52.543]                           computeRestarts <- base::computeRestarts
[08:24:52.543]                           grepl <- base::grepl
[08:24:52.543]                           restarts <- computeRestarts(cond)
[08:24:52.543]                           for (restart in restarts) {
[08:24:52.543]                             name <- restart$name
[08:24:52.543]                             if (is.null(name)) 
[08:24:52.543]                               next
[08:24:52.543]                             if (!grepl(pattern, name)) 
[08:24:52.543]                               next
[08:24:52.543]                             invokeRestart(restart)
[08:24:52.543]                             muffled <- TRUE
[08:24:52.543]                             break
[08:24:52.543]                           }
[08:24:52.543]                         }
[08:24:52.543]                       }
[08:24:52.543]                       invisible(muffled)
[08:24:52.543]                     }
[08:24:52.543]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.543]                   }
[08:24:52.543]                 }
[08:24:52.543]             }
[08:24:52.543]         }))
[08:24:52.543]     }, error = function(ex) {
[08:24:52.543]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.543]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.543]                 ...future.rng), started = ...future.startTime, 
[08:24:52.543]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.543]             version = "1.8"), class = "FutureResult")
[08:24:52.543]     }, finally = {
[08:24:52.543]         if (!identical(...future.workdir, getwd())) 
[08:24:52.543]             setwd(...future.workdir)
[08:24:52.543]         {
[08:24:52.543]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.543]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.543]             }
[08:24:52.543]             base::options(...future.oldOptions)
[08:24:52.543]             if (.Platform$OS.type == "windows") {
[08:24:52.543]                 old_names <- names(...future.oldEnvVars)
[08:24:52.543]                 envs <- base::Sys.getenv()
[08:24:52.543]                 names <- names(envs)
[08:24:52.543]                 common <- intersect(names, old_names)
[08:24:52.543]                 added <- setdiff(names, old_names)
[08:24:52.543]                 removed <- setdiff(old_names, names)
[08:24:52.543]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.543]                   envs[common]]
[08:24:52.543]                 NAMES <- toupper(changed)
[08:24:52.543]                 args <- list()
[08:24:52.543]                 for (kk in seq_along(NAMES)) {
[08:24:52.543]                   name <- changed[[kk]]
[08:24:52.543]                   NAME <- NAMES[[kk]]
[08:24:52.543]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.543]                     next
[08:24:52.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.543]                 }
[08:24:52.543]                 NAMES <- toupper(added)
[08:24:52.543]                 for (kk in seq_along(NAMES)) {
[08:24:52.543]                   name <- added[[kk]]
[08:24:52.543]                   NAME <- NAMES[[kk]]
[08:24:52.543]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.543]                     next
[08:24:52.543]                   args[[name]] <- ""
[08:24:52.543]                 }
[08:24:52.543]                 NAMES <- toupper(removed)
[08:24:52.543]                 for (kk in seq_along(NAMES)) {
[08:24:52.543]                   name <- removed[[kk]]
[08:24:52.543]                   NAME <- NAMES[[kk]]
[08:24:52.543]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.543]                     next
[08:24:52.543]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.543]                 }
[08:24:52.543]                 if (length(args) > 0) 
[08:24:52.543]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.543]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.543]             }
[08:24:52.543]             else {
[08:24:52.543]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.543]             }
[08:24:52.543]             {
[08:24:52.543]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.543]                   0L) {
[08:24:52.543]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.543]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.543]                   base::options(opts)
[08:24:52.543]                 }
[08:24:52.543]                 {
[08:24:52.543]                   {
[08:24:52.543]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.543]                     NULL
[08:24:52.543]                   }
[08:24:52.543]                   options(future.plan = NULL)
[08:24:52.543]                   if (is.na(NA_character_)) 
[08:24:52.543]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.543]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.543]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.543]                     .init = FALSE)
[08:24:52.543]                 }
[08:24:52.543]             }
[08:24:52.543]         }
[08:24:52.543]     })
[08:24:52.543]     if (TRUE) {
[08:24:52.543]         base::sink(type = "output", split = FALSE)
[08:24:52.543]         if (TRUE) {
[08:24:52.543]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.543]         }
[08:24:52.543]         else {
[08:24:52.543]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.543]         }
[08:24:52.543]         base::close(...future.stdout)
[08:24:52.543]         ...future.stdout <- NULL
[08:24:52.543]     }
[08:24:52.543]     ...future.result$conditions <- ...future.conditions
[08:24:52.543]     ...future.result$finished <- base::Sys.time()
[08:24:52.543]     ...future.result
[08:24:52.543] }
[08:24:52.546] assign_globals() ...
[08:24:52.546] List of 5
[08:24:52.546]  $ future.call.arguments    : list()
[08:24:52.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.546]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:52.546]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:52.546]  $ ...future.elements_ii    :List of 1
[08:24:52.546]   ..$ : num [1:4] 2 4 6 8
[08:24:52.546]  $ ...future.seeds_ii       : NULL
[08:24:52.546]  $ ...future.globals.maxSize: num Inf
[08:24:52.546]  - attr(*, "resolved")= logi FALSE
[08:24:52.546]  - attr(*, "total_size")= num NA
[08:24:52.546]  - attr(*, "where")=List of 5
[08:24:52.546]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.546]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.546]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.546]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.546]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.546]  - attr(*, "already-done")= logi TRUE
[08:24:52.552] - copied ‘future.call.arguments’ to environment
[08:24:52.553] - copied ‘...future.FUN’ to environment
[08:24:52.553] - copied ‘...future.elements_ii’ to environment
[08:24:52.553] - copied ‘...future.seeds_ii’ to environment
[08:24:52.553] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.553] assign_globals() ... done
[08:24:52.553] requestCore(): workers = 2
[08:24:52.556] MulticoreFuture started
[08:24:52.556] - Launch lazy future ... done
[08:24:52.556] run() for ‘MulticoreFuture’ ... done
[08:24:52.557] Created future:
[08:24:52.557] plan(): Setting new future strategy stack:
[08:24:52.557] List of future strategies:
[08:24:52.557] 1. sequential:
[08:24:52.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.557]    - tweaked: FALSE
[08:24:52.557]    - call: NULL
[08:24:52.558] plan(): nbrOfWorkers() = 1
[08:24:52.561] plan(): Setting new future strategy stack:
[08:24:52.561] List of future strategies:
[08:24:52.561] 1. multicore:
[08:24:52.561]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.561]    - tweaked: FALSE
[08:24:52.561]    - call: plan(strategy)
[08:24:52.564] plan(): nbrOfWorkers() = 2
[08:24:52.557] MulticoreFuture:
[08:24:52.557] Label: ‘future_apply-2’
[08:24:52.557] Expression:
[08:24:52.557] {
[08:24:52.557]     do.call(function(...) {
[08:24:52.557]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.557]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.557]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.557]             on.exit(options(oopts), add = TRUE)
[08:24:52.557]         }
[08:24:52.557]         {
[08:24:52.557]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.557]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.557]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.557]             })
[08:24:52.557]         }
[08:24:52.557]     }, args = future.call.arguments)
[08:24:52.557] }
[08:24:52.557] Lazy evaluation: FALSE
[08:24:52.557] Asynchronous evaluation: TRUE
[08:24:52.557] Local evaluation: TRUE
[08:24:52.557] Environment: R_GlobalEnv
[08:24:52.557] Capture standard output: TRUE
[08:24:52.557] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.557] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.557] Packages: <none>
[08:24:52.557] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.557] Resolved: TRUE
[08:24:52.557] Value: <not collected>
[08:24:52.557] Conditions captured: <none>
[08:24:52.557] Early signaling: FALSE
[08:24:52.557] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.557] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.565] Chunk #2 of 2 ... DONE
[08:24:52.565] Launching 2 futures (chunks) ... DONE
[08:24:52.565] Resolving 2 futures (chunks) ...
[08:24:52.566] resolve() on list ...
[08:24:52.566]  recursive: 0
[08:24:52.566]  length: 2
[08:24:52.566] 
[08:24:52.566] Future #1
[08:24:52.567] result() for MulticoreFuture ...
[08:24:52.568] result() for MulticoreFuture ...
[08:24:52.568] result() for MulticoreFuture ... done
[08:24:52.568] result() for MulticoreFuture ... done
[08:24:52.568] result() for MulticoreFuture ...
[08:24:52.568] result() for MulticoreFuture ... done
[08:24:52.568] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:52.569] - nx: 2
[08:24:52.569] - relay: TRUE
[08:24:52.569] - stdout: TRUE
[08:24:52.569] - signal: TRUE
[08:24:52.569] - resignal: FALSE
[08:24:52.569] - force: TRUE
[08:24:52.569] - relayed: [n=2] FALSE, FALSE
[08:24:52.569] - queued futures: [n=2] FALSE, FALSE
[08:24:52.570]  - until=1
[08:24:52.570]  - relaying element #1
[08:24:52.570] result() for MulticoreFuture ...
[08:24:52.570] result() for MulticoreFuture ... done
[08:24:52.570] result() for MulticoreFuture ...
[08:24:52.570] result() for MulticoreFuture ... done
[08:24:52.570] result() for MulticoreFuture ...
[08:24:52.571] result() for MulticoreFuture ... done
[08:24:52.571] result() for MulticoreFuture ...
[08:24:52.571] result() for MulticoreFuture ... done
[08:24:52.571] - relayed: [n=2] TRUE, FALSE
[08:24:52.571] - queued futures: [n=2] TRUE, FALSE
[08:24:52.571] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:52.571]  length: 1 (resolved future 1)
[08:24:52.572] Future #2
[08:24:52.572] result() for MulticoreFuture ...
[08:24:52.573] result() for MulticoreFuture ...
[08:24:52.573] result() for MulticoreFuture ... done
[08:24:52.573] result() for MulticoreFuture ... done
[08:24:52.573] result() for MulticoreFuture ...
[08:24:52.573] result() for MulticoreFuture ... done
[08:24:52.573] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:52.573] - nx: 2
[08:24:52.574] - relay: TRUE
[08:24:52.574] - stdout: TRUE
[08:24:52.574] - signal: TRUE
[08:24:52.574] - resignal: FALSE
[08:24:52.574] - force: TRUE
[08:24:52.574] - relayed: [n=2] TRUE, FALSE
[08:24:52.574] - queued futures: [n=2] TRUE, FALSE
[08:24:52.574]  - until=2
[08:24:52.575]  - relaying element #2
[08:24:52.575] result() for MulticoreFuture ...
[08:24:52.575] result() for MulticoreFuture ... done
[08:24:52.578] result() for MulticoreFuture ...
[08:24:52.578] result() for MulticoreFuture ... done
[08:24:52.578] result() for MulticoreFuture ...
[08:24:52.578] result() for MulticoreFuture ... done
[08:24:52.578] result() for MulticoreFuture ...
[08:24:52.579] result() for MulticoreFuture ... done
[08:24:52.579] - relayed: [n=2] TRUE, TRUE
[08:24:52.579] - queued futures: [n=2] TRUE, TRUE
[08:24:52.579] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:52.579]  length: 0 (resolved future 2)
[08:24:52.580] Relaying remaining futures
[08:24:52.580] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.580] - nx: 2
[08:24:52.580] - relay: TRUE
[08:24:52.580] - stdout: TRUE
[08:24:52.580] - signal: TRUE
[08:24:52.580] - resignal: FALSE
[08:24:52.581] - force: TRUE
[08:24:52.581] - relayed: [n=2] TRUE, TRUE
[08:24:52.581] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:52.581] - relayed: [n=2] TRUE, TRUE
[08:24:52.581] - queued futures: [n=2] TRUE, TRUE
[08:24:52.581] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.581] resolve() on list ... DONE
[08:24:52.581] result() for MulticoreFuture ...
[08:24:52.581] result() for MulticoreFuture ... done
[08:24:52.582] result() for MulticoreFuture ...
[08:24:52.582] result() for MulticoreFuture ... done
[08:24:52.582] result() for MulticoreFuture ...
[08:24:52.582] result() for MulticoreFuture ... done
[08:24:52.582] result() for MulticoreFuture ...
[08:24:52.582] result() for MulticoreFuture ... done
[08:24:52.582]  - Number of value chunks collected: 2
[08:24:52.583] Resolving 2 futures (chunks) ... DONE
[08:24:52.583] Reducing values from 2 chunks ...
[08:24:52.583]  - Number of values collected after concatenation: 2
[08:24:52.583]  - Number of values expected: 2
[08:24:52.583] Reducing values from 2 chunks ... DONE
[08:24:52.583] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[08:24:52.584] getGlobalsAndPackagesXApply() ...
[08:24:52.584]  - future.globals: TRUE
[08:24:52.584] getGlobalsAndPackages() ...
[08:24:52.585] Searching for globals...
[08:24:52.586] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:52.586] Searching for globals ... DONE
[08:24:52.586] Resolving globals: FALSE
[08:24:52.587] The total size of the 1 globals is 311 bytes (311 bytes)
[08:24:52.587] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[08:24:52.587] - globals: [1] ‘FUN’
[08:24:52.588] - packages: [1] ‘stats’
[08:24:52.588] getGlobalsAndPackages() ... DONE
[08:24:52.588]  - globals found/used: [n=1] ‘FUN’
[08:24:52.588]  - needed namespaces: [n=1] ‘stats’
[08:24:52.588] Finding globals ... DONE
[08:24:52.588]  - use_args: TRUE
[08:24:52.588]  - Getting '...' globals ...
[08:24:52.589] resolve() on list ...
[08:24:52.589]  recursive: 0
[08:24:52.589]  length: 1
[08:24:52.589]  elements: ‘...’
[08:24:52.589]  length: 0 (resolved future 1)
[08:24:52.589] resolve() on list ... DONE
[08:24:52.589]    - '...' content: [n=0] 
[08:24:52.589] List of 1
[08:24:52.589]  $ ...: list()
[08:24:52.589]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.589]  - attr(*, "where")=List of 1
[08:24:52.589]   ..$ ...:<environment: 0x56540c54cb38> 
[08:24:52.589]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.589]  - attr(*, "resolved")= logi TRUE
[08:24:52.589]  - attr(*, "total_size")= num NA
[08:24:52.592]  - Getting '...' globals ... DONE
[08:24:52.593] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.593] List of 2
[08:24:52.593]  $ ...future.FUN:function (x, ...)  
[08:24:52.593]  $ ...          : list()
[08:24:52.593]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.593]  - attr(*, "where")=List of 2
[08:24:52.593]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.593]   ..$ ...          :<environment: 0x56540c54cb38> 
[08:24:52.593]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.593]  - attr(*, "resolved")= logi FALSE
[08:24:52.593]  - attr(*, "total_size")= num 2586
[08:24:52.596] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:52.596] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.598] future_lapply() ...
[08:24:52.600] Number of chunks: 2
[08:24:52.600] getGlobalsAndPackagesXApply() ...
[08:24:52.600]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.600]  - use_args: TRUE
[08:24:52.600] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.600] List of 2
[08:24:52.600]  $ ...          : list()
[08:24:52.600]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.600]  $ ...future.FUN:function (x, ...)  
[08:24:52.600]  - attr(*, "where")=List of 2
[08:24:52.600]   ..$ ...          :<environment: 0x56540c54cb38> 
[08:24:52.600]   ..$ ...future.FUN:<environment: namespace:stats> 
[08:24:52.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.600]  - attr(*, "resolved")= logi FALSE
[08:24:52.600]  - attr(*, "total_size")= num NA
[08:24:52.605] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:52.605] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.605] Number of futures (= number of chunks): 2
[08:24:52.605] Launching 2 futures (chunks) ...
[08:24:52.606] Chunk #1 of 2 ...
[08:24:52.606]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.606]  - seeds: <none>
[08:24:52.606]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.606] getGlobalsAndPackages() ...
[08:24:52.606] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.606] Resolving globals: FALSE
[08:24:52.607] Tweak future expression to call with '...' arguments ...
[08:24:52.607] {
[08:24:52.607]     do.call(function(...) {
[08:24:52.607]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.607]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.607]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.607]             on.exit(options(oopts), add = TRUE)
[08:24:52.607]         }
[08:24:52.607]         {
[08:24:52.607]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.607]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.607]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.607]             })
[08:24:52.607]         }
[08:24:52.607]     }, args = future.call.arguments)
[08:24:52.607] }
[08:24:52.607] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.607] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.608] - packages: [1] ‘stats’
[08:24:52.608] getGlobalsAndPackages() ... DONE
[08:24:52.608] run() for ‘Future’ ...
[08:24:52.608] - state: ‘created’
[08:24:52.608] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.610] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.610]   - Field: ‘label’
[08:24:52.610]   - Field: ‘local’
[08:24:52.610]   - Field: ‘owner’
[08:24:52.611]   - Field: ‘envir’
[08:24:52.611]   - Field: ‘workers’
[08:24:52.611]   - Field: ‘packages’
[08:24:52.611]   - Field: ‘gc’
[08:24:52.611]   - Field: ‘job’
[08:24:52.611]   - Field: ‘conditions’
[08:24:52.611]   - Field: ‘expr’
[08:24:52.611]   - Field: ‘uuid’
[08:24:52.611]   - Field: ‘seed’
[08:24:52.611]   - Field: ‘version’
[08:24:52.611]   - Field: ‘result’
[08:24:52.612]   - Field: ‘asynchronous’
[08:24:52.612]   - Field: ‘calls’
[08:24:52.612]   - Field: ‘globals’
[08:24:52.612]   - Field: ‘stdout’
[08:24:52.612]   - Field: ‘earlySignal’
[08:24:52.612]   - Field: ‘lazy’
[08:24:52.612]   - Field: ‘state’
[08:24:52.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.612] - Launch lazy future ...
[08:24:52.613] Packages needed by the future expression (n = 1): ‘stats’
[08:24:52.613] Packages needed by future strategies (n = 0): <none>
[08:24:52.613] {
[08:24:52.613]     {
[08:24:52.613]         {
[08:24:52.613]             ...future.startTime <- base::Sys.time()
[08:24:52.613]             {
[08:24:52.613]                 {
[08:24:52.613]                   {
[08:24:52.613]                     {
[08:24:52.613]                       {
[08:24:52.613]                         base::local({
[08:24:52.613]                           has_future <- base::requireNamespace("future", 
[08:24:52.613]                             quietly = TRUE)
[08:24:52.613]                           if (has_future) {
[08:24:52.613]                             ns <- base::getNamespace("future")
[08:24:52.613]                             version <- ns[[".package"]][["version"]]
[08:24:52.613]                             if (is.null(version)) 
[08:24:52.613]                               version <- utils::packageVersion("future")
[08:24:52.613]                           }
[08:24:52.613]                           else {
[08:24:52.613]                             version <- NULL
[08:24:52.613]                           }
[08:24:52.613]                           if (!has_future || version < "1.8.0") {
[08:24:52.613]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.613]                               "", base::R.version$version.string), 
[08:24:52.613]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:52.613]                                 base::R.version$platform, 8 * 
[08:24:52.613]                                   base::.Machine$sizeof.pointer), 
[08:24:52.613]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.613]                                 "release", "version")], collapse = " "), 
[08:24:52.613]                               hostname = base::Sys.info()[["nodename"]])
[08:24:52.613]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.613]                               info)
[08:24:52.613]                             info <- base::paste(info, collapse = "; ")
[08:24:52.613]                             if (!has_future) {
[08:24:52.613]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.613]                                 info)
[08:24:52.613]                             }
[08:24:52.613]                             else {
[08:24:52.613]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.613]                                 info, version)
[08:24:52.613]                             }
[08:24:52.613]                             base::stop(msg)
[08:24:52.613]                           }
[08:24:52.613]                         })
[08:24:52.613]                       }
[08:24:52.613]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.613]                       base::options(mc.cores = 1L)
[08:24:52.613]                     }
[08:24:52.613]                     base::local({
[08:24:52.613]                       for (pkg in "stats") {
[08:24:52.613]                         base::loadNamespace(pkg)
[08:24:52.613]                         base::library(pkg, character.only = TRUE)
[08:24:52.613]                       }
[08:24:52.613]                     })
[08:24:52.613]                   }
[08:24:52.613]                   ...future.strategy.old <- future::plan("list")
[08:24:52.613]                   options(future.plan = NULL)
[08:24:52.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.613]                 }
[08:24:52.613]                 ...future.workdir <- getwd()
[08:24:52.613]             }
[08:24:52.613]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.613]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.613]         }
[08:24:52.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.613]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.613]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.613]             base::names(...future.oldOptions))
[08:24:52.613]     }
[08:24:52.613]     if (FALSE) {
[08:24:52.613]     }
[08:24:52.613]     else {
[08:24:52.613]         if (TRUE) {
[08:24:52.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.613]                 open = "w")
[08:24:52.613]         }
[08:24:52.613]         else {
[08:24:52.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.613]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.613]         }
[08:24:52.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.613]             base::sink(type = "output", split = FALSE)
[08:24:52.613]             base::close(...future.stdout)
[08:24:52.613]         }, add = TRUE)
[08:24:52.613]     }
[08:24:52.613]     ...future.frame <- base::sys.nframe()
[08:24:52.613]     ...future.conditions <- base::list()
[08:24:52.613]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.613]     if (FALSE) {
[08:24:52.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.613]     }
[08:24:52.613]     ...future.result <- base::tryCatch({
[08:24:52.613]         base::withCallingHandlers({
[08:24:52.613]             ...future.value <- base::withVisible(base::local({
[08:24:52.613]                 withCallingHandlers({
[08:24:52.613]                   {
[08:24:52.613]                     do.call(function(...) {
[08:24:52.613]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.613]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.613]                         ...future.globals.maxSize)) {
[08:24:52.613]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.613]                         on.exit(options(oopts), add = TRUE)
[08:24:52.613]                       }
[08:24:52.613]                       {
[08:24:52.613]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.613]                           FUN = function(jj) {
[08:24:52.613]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.613]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.613]                           })
[08:24:52.613]                       }
[08:24:52.613]                     }, args = future.call.arguments)
[08:24:52.613]                   }
[08:24:52.613]                 }, immediateCondition = function(cond) {
[08:24:52.613]                   save_rds <- function (object, pathname, ...) 
[08:24:52.613]                   {
[08:24:52.613]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.613]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.613]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.613]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.613]                         fi_tmp[["mtime"]])
[08:24:52.613]                     }
[08:24:52.613]                     tryCatch({
[08:24:52.613]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.613]                     }, error = function(ex) {
[08:24:52.613]                       msg <- conditionMessage(ex)
[08:24:52.613]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.613]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.613]                         fi_tmp[["mtime"]], msg)
[08:24:52.613]                       ex$message <- msg
[08:24:52.613]                       stop(ex)
[08:24:52.613]                     })
[08:24:52.613]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.613]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.613]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.613]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.613]                       fi <- file.info(pathname)
[08:24:52.613]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.613]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.613]                         fi[["size"]], fi[["mtime"]])
[08:24:52.613]                       stop(msg)
[08:24:52.613]                     }
[08:24:52.613]                     invisible(pathname)
[08:24:52.613]                   }
[08:24:52.613]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.613]                     rootPath = tempdir()) 
[08:24:52.613]                   {
[08:24:52.613]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.613]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.613]                       tmpdir = path, fileext = ".rds")
[08:24:52.613]                     save_rds(obj, file)
[08:24:52.613]                   }
[08:24:52.613]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.613]                   {
[08:24:52.613]                     inherits <- base::inherits
[08:24:52.613]                     invokeRestart <- base::invokeRestart
[08:24:52.613]                     is.null <- base::is.null
[08:24:52.613]                     muffled <- FALSE
[08:24:52.613]                     if (inherits(cond, "message")) {
[08:24:52.613]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.613]                       if (muffled) 
[08:24:52.613]                         invokeRestart("muffleMessage")
[08:24:52.613]                     }
[08:24:52.613]                     else if (inherits(cond, "warning")) {
[08:24:52.613]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.613]                       if (muffled) 
[08:24:52.613]                         invokeRestart("muffleWarning")
[08:24:52.613]                     }
[08:24:52.613]                     else if (inherits(cond, "condition")) {
[08:24:52.613]                       if (!is.null(pattern)) {
[08:24:52.613]                         computeRestarts <- base::computeRestarts
[08:24:52.613]                         grepl <- base::grepl
[08:24:52.613]                         restarts <- computeRestarts(cond)
[08:24:52.613]                         for (restart in restarts) {
[08:24:52.613]                           name <- restart$name
[08:24:52.613]                           if (is.null(name)) 
[08:24:52.613]                             next
[08:24:52.613]                           if (!grepl(pattern, name)) 
[08:24:52.613]                             next
[08:24:52.613]                           invokeRestart(restart)
[08:24:52.613]                           muffled <- TRUE
[08:24:52.613]                           break
[08:24:52.613]                         }
[08:24:52.613]                       }
[08:24:52.613]                     }
[08:24:52.613]                     invisible(muffled)
[08:24:52.613]                   }
[08:24:52.613]                   muffleCondition(cond)
[08:24:52.613]                 })
[08:24:52.613]             }))
[08:24:52.613]             future::FutureResult(value = ...future.value$value, 
[08:24:52.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.613]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.613]                     ...future.globalenv.names))
[08:24:52.613]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.613]         }, condition = base::local({
[08:24:52.613]             c <- base::c
[08:24:52.613]             inherits <- base::inherits
[08:24:52.613]             invokeRestart <- base::invokeRestart
[08:24:52.613]             length <- base::length
[08:24:52.613]             list <- base::list
[08:24:52.613]             seq.int <- base::seq.int
[08:24:52.613]             signalCondition <- base::signalCondition
[08:24:52.613]             sys.calls <- base::sys.calls
[08:24:52.613]             `[[` <- base::`[[`
[08:24:52.613]             `+` <- base::`+`
[08:24:52.613]             `<<-` <- base::`<<-`
[08:24:52.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.613]                   3L)]
[08:24:52.613]             }
[08:24:52.613]             function(cond) {
[08:24:52.613]                 is_error <- inherits(cond, "error")
[08:24:52.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.613]                   NULL)
[08:24:52.613]                 if (is_error) {
[08:24:52.613]                   sessionInformation <- function() {
[08:24:52.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.613]                       search = base::search(), system = base::Sys.info())
[08:24:52.613]                   }
[08:24:52.613]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.613]                     cond$call), session = sessionInformation(), 
[08:24:52.613]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.613]                   signalCondition(cond)
[08:24:52.613]                 }
[08:24:52.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.613]                 "immediateCondition"))) {
[08:24:52.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.613]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.613]                   if (TRUE && !signal) {
[08:24:52.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.613]                     {
[08:24:52.613]                       inherits <- base::inherits
[08:24:52.613]                       invokeRestart <- base::invokeRestart
[08:24:52.613]                       is.null <- base::is.null
[08:24:52.613]                       muffled <- FALSE
[08:24:52.613]                       if (inherits(cond, "message")) {
[08:24:52.613]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.613]                         if (muffled) 
[08:24:52.613]                           invokeRestart("muffleMessage")
[08:24:52.613]                       }
[08:24:52.613]                       else if (inherits(cond, "warning")) {
[08:24:52.613]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.613]                         if (muffled) 
[08:24:52.613]                           invokeRestart("muffleWarning")
[08:24:52.613]                       }
[08:24:52.613]                       else if (inherits(cond, "condition")) {
[08:24:52.613]                         if (!is.null(pattern)) {
[08:24:52.613]                           computeRestarts <- base::computeRestarts
[08:24:52.613]                           grepl <- base::grepl
[08:24:52.613]                           restarts <- computeRestarts(cond)
[08:24:52.613]                           for (restart in restarts) {
[08:24:52.613]                             name <- restart$name
[08:24:52.613]                             if (is.null(name)) 
[08:24:52.613]                               next
[08:24:52.613]                             if (!grepl(pattern, name)) 
[08:24:52.613]                               next
[08:24:52.613]                             invokeRestart(restart)
[08:24:52.613]                             muffled <- TRUE
[08:24:52.613]                             break
[08:24:52.613]                           }
[08:24:52.613]                         }
[08:24:52.613]                       }
[08:24:52.613]                       invisible(muffled)
[08:24:52.613]                     }
[08:24:52.613]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.613]                   }
[08:24:52.613]                 }
[08:24:52.613]                 else {
[08:24:52.613]                   if (TRUE) {
[08:24:52.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.613]                     {
[08:24:52.613]                       inherits <- base::inherits
[08:24:52.613]                       invokeRestart <- base::invokeRestart
[08:24:52.613]                       is.null <- base::is.null
[08:24:52.613]                       muffled <- FALSE
[08:24:52.613]                       if (inherits(cond, "message")) {
[08:24:52.613]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.613]                         if (muffled) 
[08:24:52.613]                           invokeRestart("muffleMessage")
[08:24:52.613]                       }
[08:24:52.613]                       else if (inherits(cond, "warning")) {
[08:24:52.613]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.613]                         if (muffled) 
[08:24:52.613]                           invokeRestart("muffleWarning")
[08:24:52.613]                       }
[08:24:52.613]                       else if (inherits(cond, "condition")) {
[08:24:52.613]                         if (!is.null(pattern)) {
[08:24:52.613]                           computeRestarts <- base::computeRestarts
[08:24:52.613]                           grepl <- base::grepl
[08:24:52.613]                           restarts <- computeRestarts(cond)
[08:24:52.613]                           for (restart in restarts) {
[08:24:52.613]                             name <- restart$name
[08:24:52.613]                             if (is.null(name)) 
[08:24:52.613]                               next
[08:24:52.613]                             if (!grepl(pattern, name)) 
[08:24:52.613]                               next
[08:24:52.613]                             invokeRestart(restart)
[08:24:52.613]                             muffled <- TRUE
[08:24:52.613]                             break
[08:24:52.613]                           }
[08:24:52.613]                         }
[08:24:52.613]                       }
[08:24:52.613]                       invisible(muffled)
[08:24:52.613]                     }
[08:24:52.613]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.613]                   }
[08:24:52.613]                 }
[08:24:52.613]             }
[08:24:52.613]         }))
[08:24:52.613]     }, error = function(ex) {
[08:24:52.613]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.613]                 ...future.rng), started = ...future.startTime, 
[08:24:52.613]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.613]             version = "1.8"), class = "FutureResult")
[08:24:52.613]     }, finally = {
[08:24:52.613]         if (!identical(...future.workdir, getwd())) 
[08:24:52.613]             setwd(...future.workdir)
[08:24:52.613]         {
[08:24:52.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.613]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.613]             }
[08:24:52.613]             base::options(...future.oldOptions)
[08:24:52.613]             if (.Platform$OS.type == "windows") {
[08:24:52.613]                 old_names <- names(...future.oldEnvVars)
[08:24:52.613]                 envs <- base::Sys.getenv()
[08:24:52.613]                 names <- names(envs)
[08:24:52.613]                 common <- intersect(names, old_names)
[08:24:52.613]                 added <- setdiff(names, old_names)
[08:24:52.613]                 removed <- setdiff(old_names, names)
[08:24:52.613]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.613]                   envs[common]]
[08:24:52.613]                 NAMES <- toupper(changed)
[08:24:52.613]                 args <- list()
[08:24:52.613]                 for (kk in seq_along(NAMES)) {
[08:24:52.613]                   name <- changed[[kk]]
[08:24:52.613]                   NAME <- NAMES[[kk]]
[08:24:52.613]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.613]                     next
[08:24:52.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.613]                 }
[08:24:52.613]                 NAMES <- toupper(added)
[08:24:52.613]                 for (kk in seq_along(NAMES)) {
[08:24:52.613]                   name <- added[[kk]]
[08:24:52.613]                   NAME <- NAMES[[kk]]
[08:24:52.613]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.613]                     next
[08:24:52.613]                   args[[name]] <- ""
[08:24:52.613]                 }
[08:24:52.613]                 NAMES <- toupper(removed)
[08:24:52.613]                 for (kk in seq_along(NAMES)) {
[08:24:52.613]                   name <- removed[[kk]]
[08:24:52.613]                   NAME <- NAMES[[kk]]
[08:24:52.613]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.613]                     next
[08:24:52.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.613]                 }
[08:24:52.613]                 if (length(args) > 0) 
[08:24:52.613]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.613]             }
[08:24:52.613]             else {
[08:24:52.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.613]             }
[08:24:52.613]             {
[08:24:52.613]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.613]                   0L) {
[08:24:52.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.613]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.613]                   base::options(opts)
[08:24:52.613]                 }
[08:24:52.613]                 {
[08:24:52.613]                   {
[08:24:52.613]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.613]                     NULL
[08:24:52.613]                   }
[08:24:52.613]                   options(future.plan = NULL)
[08:24:52.613]                   if (is.na(NA_character_)) 
[08:24:52.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.613]                     .init = FALSE)
[08:24:52.613]                 }
[08:24:52.613]             }
[08:24:52.613]         }
[08:24:52.613]     })
[08:24:52.613]     if (TRUE) {
[08:24:52.613]         base::sink(type = "output", split = FALSE)
[08:24:52.613]         if (TRUE) {
[08:24:52.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.613]         }
[08:24:52.613]         else {
[08:24:52.613]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.613]         }
[08:24:52.613]         base::close(...future.stdout)
[08:24:52.613]         ...future.stdout <- NULL
[08:24:52.613]     }
[08:24:52.613]     ...future.result$conditions <- ...future.conditions
[08:24:52.613]     ...future.result$finished <- base::Sys.time()
[08:24:52.613]     ...future.result
[08:24:52.613] }
[08:24:52.616] assign_globals() ...
[08:24:52.616] List of 5
[08:24:52.616]  $ future.call.arguments    : list()
[08:24:52.616]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.616]  $ ...future.FUN            :function (x, ...)  
[08:24:52.616]  $ ...future.elements_ii    :List of 1
[08:24:52.616]   ..$ : num [1:4] 1 3 1 7
[08:24:52.616]  $ ...future.seeds_ii       : NULL
[08:24:52.616]  $ ...future.globals.maxSize: num Inf
[08:24:52.616]  - attr(*, "resolved")= logi FALSE
[08:24:52.616]  - attr(*, "total_size")= num NA
[08:24:52.616]  - attr(*, "where")=List of 5
[08:24:52.616]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.616]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.616]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.616]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.616]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.616]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.616]  - attr(*, "already-done")= logi TRUE
[08:24:52.621] - copied ‘future.call.arguments’ to environment
[08:24:52.621] - copied ‘...future.FUN’ to environment
[08:24:52.621] - copied ‘...future.elements_ii’ to environment
[08:24:52.621] - copied ‘...future.seeds_ii’ to environment
[08:24:52.621] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.621] assign_globals() ... done
[08:24:52.621] requestCore(): workers = 2
[08:24:52.623] MulticoreFuture started
[08:24:52.624] - Launch lazy future ... done
[08:24:52.624] run() for ‘MulticoreFuture’ ... done
[08:24:52.624] Created future:
[08:24:52.625] plan(): Setting new future strategy stack:
[08:24:52.625] List of future strategies:
[08:24:52.625] 1. sequential:
[08:24:52.625]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.625]    - tweaked: FALSE
[08:24:52.625]    - call: NULL
[08:24:52.626] plan(): nbrOfWorkers() = 1
[08:24:52.629] plan(): Setting new future strategy stack:
[08:24:52.629] List of future strategies:
[08:24:52.629] 1. multicore:
[08:24:52.629]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.629]    - tweaked: FALSE
[08:24:52.629]    - call: plan(strategy)
[08:24:52.632] plan(): nbrOfWorkers() = 2
[08:24:52.625] MulticoreFuture:
[08:24:52.625] Label: ‘future_apply-1’
[08:24:52.625] Expression:
[08:24:52.625] {
[08:24:52.625]     do.call(function(...) {
[08:24:52.625]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.625]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.625]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.625]             on.exit(options(oopts), add = TRUE)
[08:24:52.625]         }
[08:24:52.625]         {
[08:24:52.625]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.625]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.625]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.625]             })
[08:24:52.625]         }
[08:24:52.625]     }, args = future.call.arguments)
[08:24:52.625] }
[08:24:52.625] Lazy evaluation: FALSE
[08:24:52.625] Asynchronous evaluation: TRUE
[08:24:52.625] Local evaluation: TRUE
[08:24:52.625] Environment: R_GlobalEnv
[08:24:52.625] Capture standard output: TRUE
[08:24:52.625] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.625] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.625] Packages: 1 packages (‘stats’)
[08:24:52.625] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.625] Resolved: TRUE
[08:24:52.625] Value: <not collected>
[08:24:52.625] Conditions captured: <none>
[08:24:52.625] Early signaling: FALSE
[08:24:52.625] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.625] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.633] Chunk #1 of 2 ... DONE
[08:24:52.633] Chunk #2 of 2 ...
[08:24:52.633]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.633]  - seeds: <none>
[08:24:52.634]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.634] getGlobalsAndPackages() ...
[08:24:52.634] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.634] Resolving globals: FALSE
[08:24:52.634] Tweak future expression to call with '...' arguments ...
[08:24:52.634] {
[08:24:52.634]     do.call(function(...) {
[08:24:52.634]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.634]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.634]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.634]             on.exit(options(oopts), add = TRUE)
[08:24:52.634]         }
[08:24:52.634]         {
[08:24:52.634]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.634]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.634]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.634]             })
[08:24:52.634]         }
[08:24:52.634]     }, args = future.call.arguments)
[08:24:52.634] }
[08:24:52.635] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.635] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.636] - packages: [1] ‘stats’
[08:24:52.636] getGlobalsAndPackages() ... DONE
[08:24:52.636] run() for ‘Future’ ...
[08:24:52.636] - state: ‘created’
[08:24:52.637] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.639] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.640]   - Field: ‘label’
[08:24:52.640]   - Field: ‘local’
[08:24:52.640]   - Field: ‘owner’
[08:24:52.640]   - Field: ‘envir’
[08:24:52.640]   - Field: ‘workers’
[08:24:52.640]   - Field: ‘packages’
[08:24:52.641]   - Field: ‘gc’
[08:24:52.641]   - Field: ‘job’
[08:24:52.641]   - Field: ‘conditions’
[08:24:52.641]   - Field: ‘expr’
[08:24:52.641]   - Field: ‘uuid’
[08:24:52.641]   - Field: ‘seed’
[08:24:52.641]   - Field: ‘version’
[08:24:52.641]   - Field: ‘result’
[08:24:52.642]   - Field: ‘asynchronous’
[08:24:52.642]   - Field: ‘calls’
[08:24:52.642]   - Field: ‘globals’
[08:24:52.642]   - Field: ‘stdout’
[08:24:52.642]   - Field: ‘earlySignal’
[08:24:52.642]   - Field: ‘lazy’
[08:24:52.651]   - Field: ‘state’
[08:24:52.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.652] - Launch lazy future ...
[08:24:52.652] Packages needed by the future expression (n = 1): ‘stats’
[08:24:52.652] Packages needed by future strategies (n = 0): <none>
[08:24:52.653] {
[08:24:52.653]     {
[08:24:52.653]         {
[08:24:52.653]             ...future.startTime <- base::Sys.time()
[08:24:52.653]             {
[08:24:52.653]                 {
[08:24:52.653]                   {
[08:24:52.653]                     {
[08:24:52.653]                       {
[08:24:52.653]                         base::local({
[08:24:52.653]                           has_future <- base::requireNamespace("future", 
[08:24:52.653]                             quietly = TRUE)
[08:24:52.653]                           if (has_future) {
[08:24:52.653]                             ns <- base::getNamespace("future")
[08:24:52.653]                             version <- ns[[".package"]][["version"]]
[08:24:52.653]                             if (is.null(version)) 
[08:24:52.653]                               version <- utils::packageVersion("future")
[08:24:52.653]                           }
[08:24:52.653]                           else {
[08:24:52.653]                             version <- NULL
[08:24:52.653]                           }
[08:24:52.653]                           if (!has_future || version < "1.8.0") {
[08:24:52.653]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.653]                               "", base::R.version$version.string), 
[08:24:52.653]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:52.653]                                 base::R.version$platform, 8 * 
[08:24:52.653]                                   base::.Machine$sizeof.pointer), 
[08:24:52.653]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.653]                                 "release", "version")], collapse = " "), 
[08:24:52.653]                               hostname = base::Sys.info()[["nodename"]])
[08:24:52.653]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.653]                               info)
[08:24:52.653]                             info <- base::paste(info, collapse = "; ")
[08:24:52.653]                             if (!has_future) {
[08:24:52.653]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.653]                                 info)
[08:24:52.653]                             }
[08:24:52.653]                             else {
[08:24:52.653]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.653]                                 info, version)
[08:24:52.653]                             }
[08:24:52.653]                             base::stop(msg)
[08:24:52.653]                           }
[08:24:52.653]                         })
[08:24:52.653]                       }
[08:24:52.653]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.653]                       base::options(mc.cores = 1L)
[08:24:52.653]                     }
[08:24:52.653]                     base::local({
[08:24:52.653]                       for (pkg in "stats") {
[08:24:52.653]                         base::loadNamespace(pkg)
[08:24:52.653]                         base::library(pkg, character.only = TRUE)
[08:24:52.653]                       }
[08:24:52.653]                     })
[08:24:52.653]                   }
[08:24:52.653]                   ...future.strategy.old <- future::plan("list")
[08:24:52.653]                   options(future.plan = NULL)
[08:24:52.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.653]                 }
[08:24:52.653]                 ...future.workdir <- getwd()
[08:24:52.653]             }
[08:24:52.653]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.653]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.653]         }
[08:24:52.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.653]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.653]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.653]             base::names(...future.oldOptions))
[08:24:52.653]     }
[08:24:52.653]     if (FALSE) {
[08:24:52.653]     }
[08:24:52.653]     else {
[08:24:52.653]         if (TRUE) {
[08:24:52.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.653]                 open = "w")
[08:24:52.653]         }
[08:24:52.653]         else {
[08:24:52.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.653]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.653]         }
[08:24:52.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.653]             base::sink(type = "output", split = FALSE)
[08:24:52.653]             base::close(...future.stdout)
[08:24:52.653]         }, add = TRUE)
[08:24:52.653]     }
[08:24:52.653]     ...future.frame <- base::sys.nframe()
[08:24:52.653]     ...future.conditions <- base::list()
[08:24:52.653]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.653]     if (FALSE) {
[08:24:52.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.653]     }
[08:24:52.653]     ...future.result <- base::tryCatch({
[08:24:52.653]         base::withCallingHandlers({
[08:24:52.653]             ...future.value <- base::withVisible(base::local({
[08:24:52.653]                 withCallingHandlers({
[08:24:52.653]                   {
[08:24:52.653]                     do.call(function(...) {
[08:24:52.653]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.653]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.653]                         ...future.globals.maxSize)) {
[08:24:52.653]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.653]                         on.exit(options(oopts), add = TRUE)
[08:24:52.653]                       }
[08:24:52.653]                       {
[08:24:52.653]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.653]                           FUN = function(jj) {
[08:24:52.653]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.653]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.653]                           })
[08:24:52.653]                       }
[08:24:52.653]                     }, args = future.call.arguments)
[08:24:52.653]                   }
[08:24:52.653]                 }, immediateCondition = function(cond) {
[08:24:52.653]                   save_rds <- function (object, pathname, ...) 
[08:24:52.653]                   {
[08:24:52.653]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.653]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.653]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.653]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.653]                         fi_tmp[["mtime"]])
[08:24:52.653]                     }
[08:24:52.653]                     tryCatch({
[08:24:52.653]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.653]                     }, error = function(ex) {
[08:24:52.653]                       msg <- conditionMessage(ex)
[08:24:52.653]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.653]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.653]                         fi_tmp[["mtime"]], msg)
[08:24:52.653]                       ex$message <- msg
[08:24:52.653]                       stop(ex)
[08:24:52.653]                     })
[08:24:52.653]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.653]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.653]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.653]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.653]                       fi <- file.info(pathname)
[08:24:52.653]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.653]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.653]                         fi[["size"]], fi[["mtime"]])
[08:24:52.653]                       stop(msg)
[08:24:52.653]                     }
[08:24:52.653]                     invisible(pathname)
[08:24:52.653]                   }
[08:24:52.653]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.653]                     rootPath = tempdir()) 
[08:24:52.653]                   {
[08:24:52.653]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.653]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.653]                       tmpdir = path, fileext = ".rds")
[08:24:52.653]                     save_rds(obj, file)
[08:24:52.653]                   }
[08:24:52.653]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.653]                   {
[08:24:52.653]                     inherits <- base::inherits
[08:24:52.653]                     invokeRestart <- base::invokeRestart
[08:24:52.653]                     is.null <- base::is.null
[08:24:52.653]                     muffled <- FALSE
[08:24:52.653]                     if (inherits(cond, "message")) {
[08:24:52.653]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.653]                       if (muffled) 
[08:24:52.653]                         invokeRestart("muffleMessage")
[08:24:52.653]                     }
[08:24:52.653]                     else if (inherits(cond, "warning")) {
[08:24:52.653]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.653]                       if (muffled) 
[08:24:52.653]                         invokeRestart("muffleWarning")
[08:24:52.653]                     }
[08:24:52.653]                     else if (inherits(cond, "condition")) {
[08:24:52.653]                       if (!is.null(pattern)) {
[08:24:52.653]                         computeRestarts <- base::computeRestarts
[08:24:52.653]                         grepl <- base::grepl
[08:24:52.653]                         restarts <- computeRestarts(cond)
[08:24:52.653]                         for (restart in restarts) {
[08:24:52.653]                           name <- restart$name
[08:24:52.653]                           if (is.null(name)) 
[08:24:52.653]                             next
[08:24:52.653]                           if (!grepl(pattern, name)) 
[08:24:52.653]                             next
[08:24:52.653]                           invokeRestart(restart)
[08:24:52.653]                           muffled <- TRUE
[08:24:52.653]                           break
[08:24:52.653]                         }
[08:24:52.653]                       }
[08:24:52.653]                     }
[08:24:52.653]                     invisible(muffled)
[08:24:52.653]                   }
[08:24:52.653]                   muffleCondition(cond)
[08:24:52.653]                 })
[08:24:52.653]             }))
[08:24:52.653]             future::FutureResult(value = ...future.value$value, 
[08:24:52.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.653]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.653]                     ...future.globalenv.names))
[08:24:52.653]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.653]         }, condition = base::local({
[08:24:52.653]             c <- base::c
[08:24:52.653]             inherits <- base::inherits
[08:24:52.653]             invokeRestart <- base::invokeRestart
[08:24:52.653]             length <- base::length
[08:24:52.653]             list <- base::list
[08:24:52.653]             seq.int <- base::seq.int
[08:24:52.653]             signalCondition <- base::signalCondition
[08:24:52.653]             sys.calls <- base::sys.calls
[08:24:52.653]             `[[` <- base::`[[`
[08:24:52.653]             `+` <- base::`+`
[08:24:52.653]             `<<-` <- base::`<<-`
[08:24:52.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.653]                   3L)]
[08:24:52.653]             }
[08:24:52.653]             function(cond) {
[08:24:52.653]                 is_error <- inherits(cond, "error")
[08:24:52.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.653]                   NULL)
[08:24:52.653]                 if (is_error) {
[08:24:52.653]                   sessionInformation <- function() {
[08:24:52.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.653]                       search = base::search(), system = base::Sys.info())
[08:24:52.653]                   }
[08:24:52.653]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.653]                     cond$call), session = sessionInformation(), 
[08:24:52.653]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.653]                   signalCondition(cond)
[08:24:52.653]                 }
[08:24:52.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.653]                 "immediateCondition"))) {
[08:24:52.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.653]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.653]                   if (TRUE && !signal) {
[08:24:52.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.653]                     {
[08:24:52.653]                       inherits <- base::inherits
[08:24:52.653]                       invokeRestart <- base::invokeRestart
[08:24:52.653]                       is.null <- base::is.null
[08:24:52.653]                       muffled <- FALSE
[08:24:52.653]                       if (inherits(cond, "message")) {
[08:24:52.653]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.653]                         if (muffled) 
[08:24:52.653]                           invokeRestart("muffleMessage")
[08:24:52.653]                       }
[08:24:52.653]                       else if (inherits(cond, "warning")) {
[08:24:52.653]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.653]                         if (muffled) 
[08:24:52.653]                           invokeRestart("muffleWarning")
[08:24:52.653]                       }
[08:24:52.653]                       else if (inherits(cond, "condition")) {
[08:24:52.653]                         if (!is.null(pattern)) {
[08:24:52.653]                           computeRestarts <- base::computeRestarts
[08:24:52.653]                           grepl <- base::grepl
[08:24:52.653]                           restarts <- computeRestarts(cond)
[08:24:52.653]                           for (restart in restarts) {
[08:24:52.653]                             name <- restart$name
[08:24:52.653]                             if (is.null(name)) 
[08:24:52.653]                               next
[08:24:52.653]                             if (!grepl(pattern, name)) 
[08:24:52.653]                               next
[08:24:52.653]                             invokeRestart(restart)
[08:24:52.653]                             muffled <- TRUE
[08:24:52.653]                             break
[08:24:52.653]                           }
[08:24:52.653]                         }
[08:24:52.653]                       }
[08:24:52.653]                       invisible(muffled)
[08:24:52.653]                     }
[08:24:52.653]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.653]                   }
[08:24:52.653]                 }
[08:24:52.653]                 else {
[08:24:52.653]                   if (TRUE) {
[08:24:52.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.653]                     {
[08:24:52.653]                       inherits <- base::inherits
[08:24:52.653]                       invokeRestart <- base::invokeRestart
[08:24:52.653]                       is.null <- base::is.null
[08:24:52.653]                       muffled <- FALSE
[08:24:52.653]                       if (inherits(cond, "message")) {
[08:24:52.653]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.653]                         if (muffled) 
[08:24:52.653]                           invokeRestart("muffleMessage")
[08:24:52.653]                       }
[08:24:52.653]                       else if (inherits(cond, "warning")) {
[08:24:52.653]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.653]                         if (muffled) 
[08:24:52.653]                           invokeRestart("muffleWarning")
[08:24:52.653]                       }
[08:24:52.653]                       else if (inherits(cond, "condition")) {
[08:24:52.653]                         if (!is.null(pattern)) {
[08:24:52.653]                           computeRestarts <- base::computeRestarts
[08:24:52.653]                           grepl <- base::grepl
[08:24:52.653]                           restarts <- computeRestarts(cond)
[08:24:52.653]                           for (restart in restarts) {
[08:24:52.653]                             name <- restart$name
[08:24:52.653]                             if (is.null(name)) 
[08:24:52.653]                               next
[08:24:52.653]                             if (!grepl(pattern, name)) 
[08:24:52.653]                               next
[08:24:52.653]                             invokeRestart(restart)
[08:24:52.653]                             muffled <- TRUE
[08:24:52.653]                             break
[08:24:52.653]                           }
[08:24:52.653]                         }
[08:24:52.653]                       }
[08:24:52.653]                       invisible(muffled)
[08:24:52.653]                     }
[08:24:52.653]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.653]                   }
[08:24:52.653]                 }
[08:24:52.653]             }
[08:24:52.653]         }))
[08:24:52.653]     }, error = function(ex) {
[08:24:52.653]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.653]                 ...future.rng), started = ...future.startTime, 
[08:24:52.653]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.653]             version = "1.8"), class = "FutureResult")
[08:24:52.653]     }, finally = {
[08:24:52.653]         if (!identical(...future.workdir, getwd())) 
[08:24:52.653]             setwd(...future.workdir)
[08:24:52.653]         {
[08:24:52.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.653]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.653]             }
[08:24:52.653]             base::options(...future.oldOptions)
[08:24:52.653]             if (.Platform$OS.type == "windows") {
[08:24:52.653]                 old_names <- names(...future.oldEnvVars)
[08:24:52.653]                 envs <- base::Sys.getenv()
[08:24:52.653]                 names <- names(envs)
[08:24:52.653]                 common <- intersect(names, old_names)
[08:24:52.653]                 added <- setdiff(names, old_names)
[08:24:52.653]                 removed <- setdiff(old_names, names)
[08:24:52.653]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.653]                   envs[common]]
[08:24:52.653]                 NAMES <- toupper(changed)
[08:24:52.653]                 args <- list()
[08:24:52.653]                 for (kk in seq_along(NAMES)) {
[08:24:52.653]                   name <- changed[[kk]]
[08:24:52.653]                   NAME <- NAMES[[kk]]
[08:24:52.653]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.653]                     next
[08:24:52.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.653]                 }
[08:24:52.653]                 NAMES <- toupper(added)
[08:24:52.653]                 for (kk in seq_along(NAMES)) {
[08:24:52.653]                   name <- added[[kk]]
[08:24:52.653]                   NAME <- NAMES[[kk]]
[08:24:52.653]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.653]                     next
[08:24:52.653]                   args[[name]] <- ""
[08:24:52.653]                 }
[08:24:52.653]                 NAMES <- toupper(removed)
[08:24:52.653]                 for (kk in seq_along(NAMES)) {
[08:24:52.653]                   name <- removed[[kk]]
[08:24:52.653]                   NAME <- NAMES[[kk]]
[08:24:52.653]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.653]                     next
[08:24:52.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.653]                 }
[08:24:52.653]                 if (length(args) > 0) 
[08:24:52.653]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.653]             }
[08:24:52.653]             else {
[08:24:52.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.653]             }
[08:24:52.653]             {
[08:24:52.653]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.653]                   0L) {
[08:24:52.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.653]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.653]                   base::options(opts)
[08:24:52.653]                 }
[08:24:52.653]                 {
[08:24:52.653]                   {
[08:24:52.653]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.653]                     NULL
[08:24:52.653]                   }
[08:24:52.653]                   options(future.plan = NULL)
[08:24:52.653]                   if (is.na(NA_character_)) 
[08:24:52.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.653]                     .init = FALSE)
[08:24:52.653]                 }
[08:24:52.653]             }
[08:24:52.653]         }
[08:24:52.653]     })
[08:24:52.653]     if (TRUE) {
[08:24:52.653]         base::sink(type = "output", split = FALSE)
[08:24:52.653]         if (TRUE) {
[08:24:52.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.653]         }
[08:24:52.653]         else {
[08:24:52.653]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.653]         }
[08:24:52.653]         base::close(...future.stdout)
[08:24:52.653]         ...future.stdout <- NULL
[08:24:52.653]     }
[08:24:52.653]     ...future.result$conditions <- ...future.conditions
[08:24:52.653]     ...future.result$finished <- base::Sys.time()
[08:24:52.653]     ...future.result
[08:24:52.653] }
[08:24:52.656] assign_globals() ...
[08:24:52.656] List of 5
[08:24:52.656]  $ future.call.arguments    : list()
[08:24:52.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.656]  $ ...future.FUN            :function (x, ...)  
[08:24:52.656]  $ ...future.elements_ii    :List of 1
[08:24:52.656]   ..$ : num [1:4] 2 4 6 8
[08:24:52.656]  $ ...future.seeds_ii       : NULL
[08:24:52.656]  $ ...future.globals.maxSize: num Inf
[08:24:52.656]  - attr(*, "resolved")= logi FALSE
[08:24:52.656]  - attr(*, "total_size")= num NA
[08:24:52.656]  - attr(*, "where")=List of 5
[08:24:52.656]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.656]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.656]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.656]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.656]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.656]  - attr(*, "already-done")= logi TRUE
[08:24:52.664] - copied ‘future.call.arguments’ to environment
[08:24:52.664] - copied ‘...future.FUN’ to environment
[08:24:52.664] - copied ‘...future.elements_ii’ to environment
[08:24:52.664] - copied ‘...future.seeds_ii’ to environment
[08:24:52.664] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.664] assign_globals() ... done
[08:24:52.665] requestCore(): workers = 2
[08:24:52.667] MulticoreFuture started
[08:24:52.668] - Launch lazy future ... done
[08:24:52.668] run() for ‘MulticoreFuture’ ... done
[08:24:52.668] Created future:
[08:24:52.669] plan(): Setting new future strategy stack:
[08:24:52.669] List of future strategies:
[08:24:52.669] 1. sequential:
[08:24:52.669]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.669]    - tweaked: FALSE
[08:24:52.669]    - call: NULL
[08:24:52.670] plan(): nbrOfWorkers() = 1
[08:24:52.673] plan(): Setting new future strategy stack:
[08:24:52.673] List of future strategies:
[08:24:52.673] 1. multicore:
[08:24:52.673]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.673]    - tweaked: FALSE
[08:24:52.673]    - call: plan(strategy)
[08:24:52.676] plan(): nbrOfWorkers() = 2
[08:24:52.668] MulticoreFuture:
[08:24:52.668] Label: ‘future_apply-2’
[08:24:52.668] Expression:
[08:24:52.668] {
[08:24:52.668]     do.call(function(...) {
[08:24:52.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.668]             on.exit(options(oopts), add = TRUE)
[08:24:52.668]         }
[08:24:52.668]         {
[08:24:52.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.668]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.668]             })
[08:24:52.668]         }
[08:24:52.668]     }, args = future.call.arguments)
[08:24:52.668] }
[08:24:52.668] Lazy evaluation: FALSE
[08:24:52.668] Asynchronous evaluation: TRUE
[08:24:52.668] Local evaluation: TRUE
[08:24:52.668] Environment: R_GlobalEnv
[08:24:52.668] Capture standard output: TRUE
[08:24:52.668] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.668] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.668] Packages: 1 packages (‘stats’)
[08:24:52.668] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.668] Resolved: TRUE
[08:24:52.668] Value: <not collected>
[08:24:52.668] Conditions captured: <none>
[08:24:52.668] Early signaling: FALSE
[08:24:52.668] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.668] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.677] Chunk #2 of 2 ... DONE
[08:24:52.677] Launching 2 futures (chunks) ... DONE
[08:24:52.677] Resolving 2 futures (chunks) ...
[08:24:52.678] resolve() on list ...
[08:24:52.678]  recursive: 0
[08:24:52.678]  length: 2
[08:24:52.678] 
[08:24:52.678] Future #1
[08:24:52.679] result() for MulticoreFuture ...
[08:24:52.680] result() for MulticoreFuture ...
[08:24:52.680] result() for MulticoreFuture ... done
[08:24:52.680] result() for MulticoreFuture ... done
[08:24:52.680] result() for MulticoreFuture ...
[08:24:52.680] result() for MulticoreFuture ... done
[08:24:52.680] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:52.680] - nx: 2
[08:24:52.681] - relay: TRUE
[08:24:52.681] - stdout: TRUE
[08:24:52.681] - signal: TRUE
[08:24:52.681] - resignal: FALSE
[08:24:52.681] - force: TRUE
[08:24:52.681] - relayed: [n=2] FALSE, FALSE
[08:24:52.681] - queued futures: [n=2] FALSE, FALSE
[08:24:52.681]  - until=1
[08:24:52.682]  - relaying element #1
[08:24:52.682] result() for MulticoreFuture ...
[08:24:52.682] result() for MulticoreFuture ... done
[08:24:52.682] result() for MulticoreFuture ...
[08:24:52.682] result() for MulticoreFuture ... done
[08:24:52.682] result() for MulticoreFuture ...
[08:24:52.683] result() for MulticoreFuture ... done
[08:24:52.683] result() for MulticoreFuture ...
[08:24:52.683] result() for MulticoreFuture ... done
[08:24:52.683] - relayed: [n=2] TRUE, FALSE
[08:24:52.683] - queued futures: [n=2] TRUE, FALSE
[08:24:52.683] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:52.684]  length: 1 (resolved future 1)
[08:24:52.684] Future #2
[08:24:52.684] result() for MulticoreFuture ...
[08:24:52.685] result() for MulticoreFuture ...
[08:24:52.685] result() for MulticoreFuture ... done
[08:24:52.685] result() for MulticoreFuture ... done
[08:24:52.685] result() for MulticoreFuture ...
[08:24:52.685] result() for MulticoreFuture ... done
[08:24:52.685] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:52.686] - nx: 2
[08:24:52.686] - relay: TRUE
[08:24:52.686] - stdout: TRUE
[08:24:52.686] - signal: TRUE
[08:24:52.686] - resignal: FALSE
[08:24:52.686] - force: TRUE
[08:24:52.686] - relayed: [n=2] TRUE, FALSE
[08:24:52.686] - queued futures: [n=2] TRUE, FALSE
[08:24:52.687]  - until=2
[08:24:52.687]  - relaying element #2
[08:24:52.687] result() for MulticoreFuture ...
[08:24:52.687] result() for MulticoreFuture ... done
[08:24:52.687] result() for MulticoreFuture ...
[08:24:52.687] result() for MulticoreFuture ... done
[08:24:52.687] result() for MulticoreFuture ...
[08:24:52.687] result() for MulticoreFuture ... done
[08:24:52.688] result() for MulticoreFuture ...
[08:24:52.688] result() for MulticoreFuture ... done
[08:24:52.688] - relayed: [n=2] TRUE, TRUE
[08:24:52.688] - queued futures: [n=2] TRUE, TRUE
[08:24:52.688] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:52.688]  length: 0 (resolved future 2)
[08:24:52.688] Relaying remaining futures
[08:24:52.688] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.688] - nx: 2
[08:24:52.689] - relay: TRUE
[08:24:52.689] - stdout: TRUE
[08:24:52.689] - signal: TRUE
[08:24:52.689] - resignal: FALSE
[08:24:52.689] - force: TRUE
[08:24:52.689] - relayed: [n=2] TRUE, TRUE
[08:24:52.689] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:52.689] - relayed: [n=2] TRUE, TRUE
[08:24:52.689] - queued futures: [n=2] TRUE, TRUE
[08:24:52.689] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.690] resolve() on list ... DONE
[08:24:52.690] result() for MulticoreFuture ...
[08:24:52.690] result() for MulticoreFuture ... done
[08:24:52.690] result() for MulticoreFuture ...
[08:24:52.690] result() for MulticoreFuture ... done
[08:24:52.690] result() for MulticoreFuture ...
[08:24:52.690] result() for MulticoreFuture ... done
[08:24:52.690] result() for MulticoreFuture ...
[08:24:52.690] result() for MulticoreFuture ... done
[08:24:52.691]  - Number of value chunks collected: 2
[08:24:52.691] Resolving 2 futures (chunks) ... DONE
[08:24:52.691] Reducing values from 2 chunks ...
[08:24:52.691]  - Number of values collected after concatenation: 2
[08:24:52.691]  - Number of values expected: 2
[08:24:52.691] Reducing values from 2 chunks ... DONE
[08:24:52.691] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[08:24:52.692] getGlobalsAndPackagesXApply() ...
[08:24:52.692]  - future.globals: TRUE
[08:24:52.692] getGlobalsAndPackages() ...
[08:24:52.692] Searching for globals...
[08:24:52.694] - globals found: [1] ‘FUN’
[08:24:52.694] Searching for globals ... DONE
[08:24:52.694] Resolving globals: FALSE
[08:24:52.694] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:52.695] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:52.697] - globals: [1] ‘FUN’
[08:24:52.698] 
[08:24:52.698] getGlobalsAndPackages() ... DONE
[08:24:52.698]  - globals found/used: [n=1] ‘FUN’
[08:24:52.698]  - needed namespaces: [n=0] 
[08:24:52.698] Finding globals ... DONE
[08:24:52.698]  - use_args: TRUE
[08:24:52.699]  - Getting '...' globals ...
[08:24:52.699] resolve() on list ...
[08:24:52.699]  recursive: 0
[08:24:52.699]  length: 1
[08:24:52.700]  elements: ‘...’
[08:24:52.700]  length: 0 (resolved future 1)
[08:24:52.700] resolve() on list ... DONE
[08:24:52.700]    - '...' content: [n=0] 
[08:24:52.700] List of 1
[08:24:52.700]  $ ...: list()
[08:24:52.700]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.700]  - attr(*, "where")=List of 1
[08:24:52.700]   ..$ ...:<environment: 0x56540e3236b0> 
[08:24:52.700]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.700]  - attr(*, "resolved")= logi TRUE
[08:24:52.700]  - attr(*, "total_size")= num NA
[08:24:52.704]  - Getting '...' globals ... DONE
[08:24:52.704] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.704] List of 2
[08:24:52.704]  $ ...future.FUN:function (x)  
[08:24:52.704]  $ ...          : list()
[08:24:52.704]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.704]  - attr(*, "where")=List of 2
[08:24:52.704]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.704]   ..$ ...          :<environment: 0x56540e3236b0> 
[08:24:52.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.704]  - attr(*, "resolved")= logi FALSE
[08:24:52.704]  - attr(*, "total_size")= num 2624
[08:24:52.707] Packages to be attached in all futures: [n=0] 
[08:24:52.707] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.709] future_lapply() ...
[08:24:52.711] Number of chunks: 2
[08:24:52.711] getGlobalsAndPackagesXApply() ...
[08:24:52.711]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.711]  - use_args: TRUE
[08:24:52.712] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.712] List of 2
[08:24:52.712]  $ ...          : list()
[08:24:52.712]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.712]  $ ...future.FUN:function (x)  
[08:24:52.712]  - attr(*, "where")=List of 2
[08:24:52.712]   ..$ ...          :<environment: 0x56540e3236b0> 
[08:24:52.712]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:52.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.712]  - attr(*, "resolved")= logi FALSE
[08:24:52.712]  - attr(*, "total_size")= num NA
[08:24:52.715] Packages to be attached in all futures: [n=0] 
[08:24:52.715] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.716] Number of futures (= number of chunks): 2
[08:24:52.716] Launching 2 futures (chunks) ...
[08:24:52.716] Chunk #1 of 2 ...
[08:24:52.716]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.716]  - seeds: <none>
[08:24:52.716]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.716] getGlobalsAndPackages() ...
[08:24:52.716] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.716] Resolving globals: FALSE
[08:24:52.717] Tweak future expression to call with '...' arguments ...
[08:24:52.717] {
[08:24:52.717]     do.call(function(...) {
[08:24:52.717]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.717]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.717]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.717]             on.exit(options(oopts), add = TRUE)
[08:24:52.717]         }
[08:24:52.717]         {
[08:24:52.717]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.717]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.717]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.717]             })
[08:24:52.717]         }
[08:24:52.717]     }, args = future.call.arguments)
[08:24:52.717] }
[08:24:52.717] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.717] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.717] 
[08:24:52.718] getGlobalsAndPackages() ... DONE
[08:24:52.718] run() for ‘Future’ ...
[08:24:52.718] - state: ‘created’
[08:24:52.718] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.720] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.720]   - Field: ‘label’
[08:24:52.720]   - Field: ‘local’
[08:24:52.720]   - Field: ‘owner’
[08:24:52.720]   - Field: ‘envir’
[08:24:52.720]   - Field: ‘workers’
[08:24:52.720]   - Field: ‘packages’
[08:24:52.721]   - Field: ‘gc’
[08:24:52.721]   - Field: ‘job’
[08:24:52.721]   - Field: ‘conditions’
[08:24:52.721]   - Field: ‘expr’
[08:24:52.721]   - Field: ‘uuid’
[08:24:52.721]   - Field: ‘seed’
[08:24:52.721]   - Field: ‘version’
[08:24:52.721]   - Field: ‘result’
[08:24:52.721]   - Field: ‘asynchronous’
[08:24:52.721]   - Field: ‘calls’
[08:24:52.721]   - Field: ‘globals’
[08:24:52.722]   - Field: ‘stdout’
[08:24:52.722]   - Field: ‘earlySignal’
[08:24:52.722]   - Field: ‘lazy’
[08:24:52.722]   - Field: ‘state’
[08:24:52.722] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.722] - Launch lazy future ...
[08:24:52.722] Packages needed by the future expression (n = 0): <none>
[08:24:52.722] Packages needed by future strategies (n = 0): <none>
[08:24:52.723] {
[08:24:52.723]     {
[08:24:52.723]         {
[08:24:52.723]             ...future.startTime <- base::Sys.time()
[08:24:52.723]             {
[08:24:52.723]                 {
[08:24:52.723]                   {
[08:24:52.723]                     {
[08:24:52.723]                       base::local({
[08:24:52.723]                         has_future <- base::requireNamespace("future", 
[08:24:52.723]                           quietly = TRUE)
[08:24:52.723]                         if (has_future) {
[08:24:52.723]                           ns <- base::getNamespace("future")
[08:24:52.723]                           version <- ns[[".package"]][["version"]]
[08:24:52.723]                           if (is.null(version)) 
[08:24:52.723]                             version <- utils::packageVersion("future")
[08:24:52.723]                         }
[08:24:52.723]                         else {
[08:24:52.723]                           version <- NULL
[08:24:52.723]                         }
[08:24:52.723]                         if (!has_future || version < "1.8.0") {
[08:24:52.723]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.723]                             "", base::R.version$version.string), 
[08:24:52.723]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.723]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.723]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.723]                               "release", "version")], collapse = " "), 
[08:24:52.723]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.723]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.723]                             info)
[08:24:52.723]                           info <- base::paste(info, collapse = "; ")
[08:24:52.723]                           if (!has_future) {
[08:24:52.723]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.723]                               info)
[08:24:52.723]                           }
[08:24:52.723]                           else {
[08:24:52.723]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.723]                               info, version)
[08:24:52.723]                           }
[08:24:52.723]                           base::stop(msg)
[08:24:52.723]                         }
[08:24:52.723]                       })
[08:24:52.723]                     }
[08:24:52.723]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.723]                     base::options(mc.cores = 1L)
[08:24:52.723]                   }
[08:24:52.723]                   ...future.strategy.old <- future::plan("list")
[08:24:52.723]                   options(future.plan = NULL)
[08:24:52.723]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.723]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.723]                 }
[08:24:52.723]                 ...future.workdir <- getwd()
[08:24:52.723]             }
[08:24:52.723]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.723]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.723]         }
[08:24:52.723]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.723]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.723]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.723]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.723]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.723]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.723]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.723]             base::names(...future.oldOptions))
[08:24:52.723]     }
[08:24:52.723]     if (FALSE) {
[08:24:52.723]     }
[08:24:52.723]     else {
[08:24:52.723]         if (TRUE) {
[08:24:52.723]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.723]                 open = "w")
[08:24:52.723]         }
[08:24:52.723]         else {
[08:24:52.723]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.723]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.723]         }
[08:24:52.723]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.723]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.723]             base::sink(type = "output", split = FALSE)
[08:24:52.723]             base::close(...future.stdout)
[08:24:52.723]         }, add = TRUE)
[08:24:52.723]     }
[08:24:52.723]     ...future.frame <- base::sys.nframe()
[08:24:52.723]     ...future.conditions <- base::list()
[08:24:52.723]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.723]     if (FALSE) {
[08:24:52.723]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.723]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.723]     }
[08:24:52.723]     ...future.result <- base::tryCatch({
[08:24:52.723]         base::withCallingHandlers({
[08:24:52.723]             ...future.value <- base::withVisible(base::local({
[08:24:52.723]                 withCallingHandlers({
[08:24:52.723]                   {
[08:24:52.723]                     do.call(function(...) {
[08:24:52.723]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.723]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.723]                         ...future.globals.maxSize)) {
[08:24:52.723]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.723]                         on.exit(options(oopts), add = TRUE)
[08:24:52.723]                       }
[08:24:52.723]                       {
[08:24:52.723]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.723]                           FUN = function(jj) {
[08:24:52.723]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.723]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.723]                           })
[08:24:52.723]                       }
[08:24:52.723]                     }, args = future.call.arguments)
[08:24:52.723]                   }
[08:24:52.723]                 }, immediateCondition = function(cond) {
[08:24:52.723]                   save_rds <- function (object, pathname, ...) 
[08:24:52.723]                   {
[08:24:52.723]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.723]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.723]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.723]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.723]                         fi_tmp[["mtime"]])
[08:24:52.723]                     }
[08:24:52.723]                     tryCatch({
[08:24:52.723]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.723]                     }, error = function(ex) {
[08:24:52.723]                       msg <- conditionMessage(ex)
[08:24:52.723]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.723]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.723]                         fi_tmp[["mtime"]], msg)
[08:24:52.723]                       ex$message <- msg
[08:24:52.723]                       stop(ex)
[08:24:52.723]                     })
[08:24:52.723]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.723]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.723]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.723]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.723]                       fi <- file.info(pathname)
[08:24:52.723]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.723]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.723]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.723]                         fi[["size"]], fi[["mtime"]])
[08:24:52.723]                       stop(msg)
[08:24:52.723]                     }
[08:24:52.723]                     invisible(pathname)
[08:24:52.723]                   }
[08:24:52.723]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.723]                     rootPath = tempdir()) 
[08:24:52.723]                   {
[08:24:52.723]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.723]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.723]                       tmpdir = path, fileext = ".rds")
[08:24:52.723]                     save_rds(obj, file)
[08:24:52.723]                   }
[08:24:52.723]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.723]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.723]                   {
[08:24:52.723]                     inherits <- base::inherits
[08:24:52.723]                     invokeRestart <- base::invokeRestart
[08:24:52.723]                     is.null <- base::is.null
[08:24:52.723]                     muffled <- FALSE
[08:24:52.723]                     if (inherits(cond, "message")) {
[08:24:52.723]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.723]                       if (muffled) 
[08:24:52.723]                         invokeRestart("muffleMessage")
[08:24:52.723]                     }
[08:24:52.723]                     else if (inherits(cond, "warning")) {
[08:24:52.723]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.723]                       if (muffled) 
[08:24:52.723]                         invokeRestart("muffleWarning")
[08:24:52.723]                     }
[08:24:52.723]                     else if (inherits(cond, "condition")) {
[08:24:52.723]                       if (!is.null(pattern)) {
[08:24:52.723]                         computeRestarts <- base::computeRestarts
[08:24:52.723]                         grepl <- base::grepl
[08:24:52.723]                         restarts <- computeRestarts(cond)
[08:24:52.723]                         for (restart in restarts) {
[08:24:52.723]                           name <- restart$name
[08:24:52.723]                           if (is.null(name)) 
[08:24:52.723]                             next
[08:24:52.723]                           if (!grepl(pattern, name)) 
[08:24:52.723]                             next
[08:24:52.723]                           invokeRestart(restart)
[08:24:52.723]                           muffled <- TRUE
[08:24:52.723]                           break
[08:24:52.723]                         }
[08:24:52.723]                       }
[08:24:52.723]                     }
[08:24:52.723]                     invisible(muffled)
[08:24:52.723]                   }
[08:24:52.723]                   muffleCondition(cond)
[08:24:52.723]                 })
[08:24:52.723]             }))
[08:24:52.723]             future::FutureResult(value = ...future.value$value, 
[08:24:52.723]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.723]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.723]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.723]                     ...future.globalenv.names))
[08:24:52.723]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.723]         }, condition = base::local({
[08:24:52.723]             c <- base::c
[08:24:52.723]             inherits <- base::inherits
[08:24:52.723]             invokeRestart <- base::invokeRestart
[08:24:52.723]             length <- base::length
[08:24:52.723]             list <- base::list
[08:24:52.723]             seq.int <- base::seq.int
[08:24:52.723]             signalCondition <- base::signalCondition
[08:24:52.723]             sys.calls <- base::sys.calls
[08:24:52.723]             `[[` <- base::`[[`
[08:24:52.723]             `+` <- base::`+`
[08:24:52.723]             `<<-` <- base::`<<-`
[08:24:52.723]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.723]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.723]                   3L)]
[08:24:52.723]             }
[08:24:52.723]             function(cond) {
[08:24:52.723]                 is_error <- inherits(cond, "error")
[08:24:52.723]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.723]                   NULL)
[08:24:52.723]                 if (is_error) {
[08:24:52.723]                   sessionInformation <- function() {
[08:24:52.723]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.723]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.723]                       search = base::search(), system = base::Sys.info())
[08:24:52.723]                   }
[08:24:52.723]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.723]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.723]                     cond$call), session = sessionInformation(), 
[08:24:52.723]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.723]                   signalCondition(cond)
[08:24:52.723]                 }
[08:24:52.723]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.723]                 "immediateCondition"))) {
[08:24:52.723]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.723]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.723]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.723]                   if (TRUE && !signal) {
[08:24:52.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.723]                     {
[08:24:52.723]                       inherits <- base::inherits
[08:24:52.723]                       invokeRestart <- base::invokeRestart
[08:24:52.723]                       is.null <- base::is.null
[08:24:52.723]                       muffled <- FALSE
[08:24:52.723]                       if (inherits(cond, "message")) {
[08:24:52.723]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.723]                         if (muffled) 
[08:24:52.723]                           invokeRestart("muffleMessage")
[08:24:52.723]                       }
[08:24:52.723]                       else if (inherits(cond, "warning")) {
[08:24:52.723]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.723]                         if (muffled) 
[08:24:52.723]                           invokeRestart("muffleWarning")
[08:24:52.723]                       }
[08:24:52.723]                       else if (inherits(cond, "condition")) {
[08:24:52.723]                         if (!is.null(pattern)) {
[08:24:52.723]                           computeRestarts <- base::computeRestarts
[08:24:52.723]                           grepl <- base::grepl
[08:24:52.723]                           restarts <- computeRestarts(cond)
[08:24:52.723]                           for (restart in restarts) {
[08:24:52.723]                             name <- restart$name
[08:24:52.723]                             if (is.null(name)) 
[08:24:52.723]                               next
[08:24:52.723]                             if (!grepl(pattern, name)) 
[08:24:52.723]                               next
[08:24:52.723]                             invokeRestart(restart)
[08:24:52.723]                             muffled <- TRUE
[08:24:52.723]                             break
[08:24:52.723]                           }
[08:24:52.723]                         }
[08:24:52.723]                       }
[08:24:52.723]                       invisible(muffled)
[08:24:52.723]                     }
[08:24:52.723]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.723]                   }
[08:24:52.723]                 }
[08:24:52.723]                 else {
[08:24:52.723]                   if (TRUE) {
[08:24:52.723]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.723]                     {
[08:24:52.723]                       inherits <- base::inherits
[08:24:52.723]                       invokeRestart <- base::invokeRestart
[08:24:52.723]                       is.null <- base::is.null
[08:24:52.723]                       muffled <- FALSE
[08:24:52.723]                       if (inherits(cond, "message")) {
[08:24:52.723]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.723]                         if (muffled) 
[08:24:52.723]                           invokeRestart("muffleMessage")
[08:24:52.723]                       }
[08:24:52.723]                       else if (inherits(cond, "warning")) {
[08:24:52.723]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.723]                         if (muffled) 
[08:24:52.723]                           invokeRestart("muffleWarning")
[08:24:52.723]                       }
[08:24:52.723]                       else if (inherits(cond, "condition")) {
[08:24:52.723]                         if (!is.null(pattern)) {
[08:24:52.723]                           computeRestarts <- base::computeRestarts
[08:24:52.723]                           grepl <- base::grepl
[08:24:52.723]                           restarts <- computeRestarts(cond)
[08:24:52.723]                           for (restart in restarts) {
[08:24:52.723]                             name <- restart$name
[08:24:52.723]                             if (is.null(name)) 
[08:24:52.723]                               next
[08:24:52.723]                             if (!grepl(pattern, name)) 
[08:24:52.723]                               next
[08:24:52.723]                             invokeRestart(restart)
[08:24:52.723]                             muffled <- TRUE
[08:24:52.723]                             break
[08:24:52.723]                           }
[08:24:52.723]                         }
[08:24:52.723]                       }
[08:24:52.723]                       invisible(muffled)
[08:24:52.723]                     }
[08:24:52.723]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.723]                   }
[08:24:52.723]                 }
[08:24:52.723]             }
[08:24:52.723]         }))
[08:24:52.723]     }, error = function(ex) {
[08:24:52.723]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.723]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.723]                 ...future.rng), started = ...future.startTime, 
[08:24:52.723]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.723]             version = "1.8"), class = "FutureResult")
[08:24:52.723]     }, finally = {
[08:24:52.723]         if (!identical(...future.workdir, getwd())) 
[08:24:52.723]             setwd(...future.workdir)
[08:24:52.723]         {
[08:24:52.723]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.723]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.723]             }
[08:24:52.723]             base::options(...future.oldOptions)
[08:24:52.723]             if (.Platform$OS.type == "windows") {
[08:24:52.723]                 old_names <- names(...future.oldEnvVars)
[08:24:52.723]                 envs <- base::Sys.getenv()
[08:24:52.723]                 names <- names(envs)
[08:24:52.723]                 common <- intersect(names, old_names)
[08:24:52.723]                 added <- setdiff(names, old_names)
[08:24:52.723]                 removed <- setdiff(old_names, names)
[08:24:52.723]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.723]                   envs[common]]
[08:24:52.723]                 NAMES <- toupper(changed)
[08:24:52.723]                 args <- list()
[08:24:52.723]                 for (kk in seq_along(NAMES)) {
[08:24:52.723]                   name <- changed[[kk]]
[08:24:52.723]                   NAME <- NAMES[[kk]]
[08:24:52.723]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.723]                     next
[08:24:52.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.723]                 }
[08:24:52.723]                 NAMES <- toupper(added)
[08:24:52.723]                 for (kk in seq_along(NAMES)) {
[08:24:52.723]                   name <- added[[kk]]
[08:24:52.723]                   NAME <- NAMES[[kk]]
[08:24:52.723]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.723]                     next
[08:24:52.723]                   args[[name]] <- ""
[08:24:52.723]                 }
[08:24:52.723]                 NAMES <- toupper(removed)
[08:24:52.723]                 for (kk in seq_along(NAMES)) {
[08:24:52.723]                   name <- removed[[kk]]
[08:24:52.723]                   NAME <- NAMES[[kk]]
[08:24:52.723]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.723]                     next
[08:24:52.723]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.723]                 }
[08:24:52.723]                 if (length(args) > 0) 
[08:24:52.723]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.723]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.723]             }
[08:24:52.723]             else {
[08:24:52.723]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.723]             }
[08:24:52.723]             {
[08:24:52.723]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.723]                   0L) {
[08:24:52.723]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.723]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.723]                   base::options(opts)
[08:24:52.723]                 }
[08:24:52.723]                 {
[08:24:52.723]                   {
[08:24:52.723]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.723]                     NULL
[08:24:52.723]                   }
[08:24:52.723]                   options(future.plan = NULL)
[08:24:52.723]                   if (is.na(NA_character_)) 
[08:24:52.723]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.723]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.723]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.723]                     .init = FALSE)
[08:24:52.723]                 }
[08:24:52.723]             }
[08:24:52.723]         }
[08:24:52.723]     })
[08:24:52.723]     if (TRUE) {
[08:24:52.723]         base::sink(type = "output", split = FALSE)
[08:24:52.723]         if (TRUE) {
[08:24:52.723]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.723]         }
[08:24:52.723]         else {
[08:24:52.723]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.723]         }
[08:24:52.723]         base::close(...future.stdout)
[08:24:52.723]         ...future.stdout <- NULL
[08:24:52.723]     }
[08:24:52.723]     ...future.result$conditions <- ...future.conditions
[08:24:52.723]     ...future.result$finished <- base::Sys.time()
[08:24:52.723]     ...future.result
[08:24:52.723] }
[08:24:52.725] assign_globals() ...
[08:24:52.725] List of 5
[08:24:52.725]  $ future.call.arguments    : list()
[08:24:52.725]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.725]  $ ...future.FUN            :function (x)  
[08:24:52.725]  $ ...future.elements_ii    :List of 1
[08:24:52.725]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[08:24:52.725]  $ ...future.seeds_ii       : NULL
[08:24:52.725]  $ ...future.globals.maxSize: num Inf
[08:24:52.725]  - attr(*, "resolved")= logi FALSE
[08:24:52.725]  - attr(*, "total_size")= num NA
[08:24:52.725]  - attr(*, "where")=List of 5
[08:24:52.725]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.725]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.725]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.725]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.725]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.725]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.725]  - attr(*, "already-done")= logi TRUE
[08:24:52.733] - copied ‘future.call.arguments’ to environment
[08:24:52.733] - copied ‘...future.FUN’ to environment
[08:24:52.733] - copied ‘...future.elements_ii’ to environment
[08:24:52.733] - copied ‘...future.seeds_ii’ to environment
[08:24:52.733] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.733] assign_globals() ... done
[08:24:52.733] requestCore(): workers = 2
[08:24:52.735] MulticoreFuture started
[08:24:52.736] - Launch lazy future ... done
[08:24:52.736] run() for ‘MulticoreFuture’ ... done
[08:24:52.737] Created future:
[08:24:52.737] plan(): Setting new future strategy stack:
[08:24:52.737] List of future strategies:
[08:24:52.737] 1. sequential:
[08:24:52.737]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.737]    - tweaked: FALSE
[08:24:52.737]    - call: NULL
[08:24:52.738] plan(): nbrOfWorkers() = 1
[08:24:52.740] plan(): Setting new future strategy stack:
[08:24:52.740] List of future strategies:
[08:24:52.740] 1. multicore:
[08:24:52.740]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.740]    - tweaked: FALSE
[08:24:52.740]    - call: plan(strategy)
[08:24:52.744] plan(): nbrOfWorkers() = 2
[08:24:52.737] MulticoreFuture:
[08:24:52.737] Label: ‘future_apply-1’
[08:24:52.737] Expression:
[08:24:52.737] {
[08:24:52.737]     do.call(function(...) {
[08:24:52.737]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.737]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.737]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.737]             on.exit(options(oopts), add = TRUE)
[08:24:52.737]         }
[08:24:52.737]         {
[08:24:52.737]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.737]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.737]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.737]             })
[08:24:52.737]         }
[08:24:52.737]     }, args = future.call.arguments)
[08:24:52.737] }
[08:24:52.737] Lazy evaluation: FALSE
[08:24:52.737] Asynchronous evaluation: TRUE
[08:24:52.737] Local evaluation: TRUE
[08:24:52.737] Environment: R_GlobalEnv
[08:24:52.737] Capture standard output: TRUE
[08:24:52.737] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.737] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.737] Packages: <none>
[08:24:52.737] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.737] Resolved: TRUE
[08:24:52.737] Value: <not collected>
[08:24:52.737] Conditions captured: <none>
[08:24:52.737] Early signaling: FALSE
[08:24:52.737] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.737] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.745] Chunk #1 of 2 ... DONE
[08:24:52.745] Chunk #2 of 2 ...
[08:24:52.745]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.745]  - seeds: <none>
[08:24:52.745]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.746] getGlobalsAndPackages() ...
[08:24:52.746] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.746] Resolving globals: FALSE
[08:24:52.746] Tweak future expression to call with '...' arguments ...
[08:24:52.746] {
[08:24:52.746]     do.call(function(...) {
[08:24:52.746]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.746]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.746]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.746]             on.exit(options(oopts), add = TRUE)
[08:24:52.746]         }
[08:24:52.746]         {
[08:24:52.746]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.746]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.746]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.746]             })
[08:24:52.746]         }
[08:24:52.746]     }, args = future.call.arguments)
[08:24:52.746] }
[08:24:52.747] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.747] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.747] 
[08:24:52.748] getGlobalsAndPackages() ... DONE
[08:24:52.748] run() for ‘Future’ ...
[08:24:52.748] - state: ‘created’
[08:24:52.749] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.751] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.751] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.752]   - Field: ‘label’
[08:24:52.752]   - Field: ‘local’
[08:24:52.752]   - Field: ‘owner’
[08:24:52.752]   - Field: ‘envir’
[08:24:52.752]   - Field: ‘workers’
[08:24:52.752]   - Field: ‘packages’
[08:24:52.752]   - Field: ‘gc’
[08:24:52.753]   - Field: ‘job’
[08:24:52.753]   - Field: ‘conditions’
[08:24:52.753]   - Field: ‘expr’
[08:24:52.753]   - Field: ‘uuid’
[08:24:52.753]   - Field: ‘seed’
[08:24:52.753]   - Field: ‘version’
[08:24:52.753]   - Field: ‘result’
[08:24:52.754]   - Field: ‘asynchronous’
[08:24:52.754]   - Field: ‘calls’
[08:24:52.754]   - Field: ‘globals’
[08:24:52.754]   - Field: ‘stdout’
[08:24:52.754]   - Field: ‘earlySignal’
[08:24:52.754]   - Field: ‘lazy’
[08:24:52.754]   - Field: ‘state’
[08:24:52.754] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.755] - Launch lazy future ...
[08:24:52.755] Packages needed by the future expression (n = 0): <none>
[08:24:52.755] Packages needed by future strategies (n = 0): <none>
[08:24:52.756] {
[08:24:52.756]     {
[08:24:52.756]         {
[08:24:52.756]             ...future.startTime <- base::Sys.time()
[08:24:52.756]             {
[08:24:52.756]                 {
[08:24:52.756]                   {
[08:24:52.756]                     {
[08:24:52.756]                       base::local({
[08:24:52.756]                         has_future <- base::requireNamespace("future", 
[08:24:52.756]                           quietly = TRUE)
[08:24:52.756]                         if (has_future) {
[08:24:52.756]                           ns <- base::getNamespace("future")
[08:24:52.756]                           version <- ns[[".package"]][["version"]]
[08:24:52.756]                           if (is.null(version)) 
[08:24:52.756]                             version <- utils::packageVersion("future")
[08:24:52.756]                         }
[08:24:52.756]                         else {
[08:24:52.756]                           version <- NULL
[08:24:52.756]                         }
[08:24:52.756]                         if (!has_future || version < "1.8.0") {
[08:24:52.756]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.756]                             "", base::R.version$version.string), 
[08:24:52.756]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.756]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.756]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.756]                               "release", "version")], collapse = " "), 
[08:24:52.756]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.756]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.756]                             info)
[08:24:52.756]                           info <- base::paste(info, collapse = "; ")
[08:24:52.756]                           if (!has_future) {
[08:24:52.756]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.756]                               info)
[08:24:52.756]                           }
[08:24:52.756]                           else {
[08:24:52.756]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.756]                               info, version)
[08:24:52.756]                           }
[08:24:52.756]                           base::stop(msg)
[08:24:52.756]                         }
[08:24:52.756]                       })
[08:24:52.756]                     }
[08:24:52.756]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.756]                     base::options(mc.cores = 1L)
[08:24:52.756]                   }
[08:24:52.756]                   ...future.strategy.old <- future::plan("list")
[08:24:52.756]                   options(future.plan = NULL)
[08:24:52.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.756]                 }
[08:24:52.756]                 ...future.workdir <- getwd()
[08:24:52.756]             }
[08:24:52.756]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.756]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.756]         }
[08:24:52.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.756]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.756]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.756]             base::names(...future.oldOptions))
[08:24:52.756]     }
[08:24:52.756]     if (FALSE) {
[08:24:52.756]     }
[08:24:52.756]     else {
[08:24:52.756]         if (TRUE) {
[08:24:52.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.756]                 open = "w")
[08:24:52.756]         }
[08:24:52.756]         else {
[08:24:52.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.756]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.756]         }
[08:24:52.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.756]             base::sink(type = "output", split = FALSE)
[08:24:52.756]             base::close(...future.stdout)
[08:24:52.756]         }, add = TRUE)
[08:24:52.756]     }
[08:24:52.756]     ...future.frame <- base::sys.nframe()
[08:24:52.756]     ...future.conditions <- base::list()
[08:24:52.756]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.756]     if (FALSE) {
[08:24:52.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.756]     }
[08:24:52.756]     ...future.result <- base::tryCatch({
[08:24:52.756]         base::withCallingHandlers({
[08:24:52.756]             ...future.value <- base::withVisible(base::local({
[08:24:52.756]                 withCallingHandlers({
[08:24:52.756]                   {
[08:24:52.756]                     do.call(function(...) {
[08:24:52.756]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.756]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.756]                         ...future.globals.maxSize)) {
[08:24:52.756]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.756]                         on.exit(options(oopts), add = TRUE)
[08:24:52.756]                       }
[08:24:52.756]                       {
[08:24:52.756]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.756]                           FUN = function(jj) {
[08:24:52.756]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.756]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.756]                           })
[08:24:52.756]                       }
[08:24:52.756]                     }, args = future.call.arguments)
[08:24:52.756]                   }
[08:24:52.756]                 }, immediateCondition = function(cond) {
[08:24:52.756]                   save_rds <- function (object, pathname, ...) 
[08:24:52.756]                   {
[08:24:52.756]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.756]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.756]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.756]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.756]                         fi_tmp[["mtime"]])
[08:24:52.756]                     }
[08:24:52.756]                     tryCatch({
[08:24:52.756]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.756]                     }, error = function(ex) {
[08:24:52.756]                       msg <- conditionMessage(ex)
[08:24:52.756]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.756]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.756]                         fi_tmp[["mtime"]], msg)
[08:24:52.756]                       ex$message <- msg
[08:24:52.756]                       stop(ex)
[08:24:52.756]                     })
[08:24:52.756]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.756]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.756]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.756]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.756]                       fi <- file.info(pathname)
[08:24:52.756]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.756]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.756]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.756]                         fi[["size"]], fi[["mtime"]])
[08:24:52.756]                       stop(msg)
[08:24:52.756]                     }
[08:24:52.756]                     invisible(pathname)
[08:24:52.756]                   }
[08:24:52.756]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.756]                     rootPath = tempdir()) 
[08:24:52.756]                   {
[08:24:52.756]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.756]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.756]                       tmpdir = path, fileext = ".rds")
[08:24:52.756]                     save_rds(obj, file)
[08:24:52.756]                   }
[08:24:52.756]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.756]                   {
[08:24:52.756]                     inherits <- base::inherits
[08:24:52.756]                     invokeRestart <- base::invokeRestart
[08:24:52.756]                     is.null <- base::is.null
[08:24:52.756]                     muffled <- FALSE
[08:24:52.756]                     if (inherits(cond, "message")) {
[08:24:52.756]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.756]                       if (muffled) 
[08:24:52.756]                         invokeRestart("muffleMessage")
[08:24:52.756]                     }
[08:24:52.756]                     else if (inherits(cond, "warning")) {
[08:24:52.756]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.756]                       if (muffled) 
[08:24:52.756]                         invokeRestart("muffleWarning")
[08:24:52.756]                     }
[08:24:52.756]                     else if (inherits(cond, "condition")) {
[08:24:52.756]                       if (!is.null(pattern)) {
[08:24:52.756]                         computeRestarts <- base::computeRestarts
[08:24:52.756]                         grepl <- base::grepl
[08:24:52.756]                         restarts <- computeRestarts(cond)
[08:24:52.756]                         for (restart in restarts) {
[08:24:52.756]                           name <- restart$name
[08:24:52.756]                           if (is.null(name)) 
[08:24:52.756]                             next
[08:24:52.756]                           if (!grepl(pattern, name)) 
[08:24:52.756]                             next
[08:24:52.756]                           invokeRestart(restart)
[08:24:52.756]                           muffled <- TRUE
[08:24:52.756]                           break
[08:24:52.756]                         }
[08:24:52.756]                       }
[08:24:52.756]                     }
[08:24:52.756]                     invisible(muffled)
[08:24:52.756]                   }
[08:24:52.756]                   muffleCondition(cond)
[08:24:52.756]                 })
[08:24:52.756]             }))
[08:24:52.756]             future::FutureResult(value = ...future.value$value, 
[08:24:52.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.756]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.756]                     ...future.globalenv.names))
[08:24:52.756]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.756]         }, condition = base::local({
[08:24:52.756]             c <- base::c
[08:24:52.756]             inherits <- base::inherits
[08:24:52.756]             invokeRestart <- base::invokeRestart
[08:24:52.756]             length <- base::length
[08:24:52.756]             list <- base::list
[08:24:52.756]             seq.int <- base::seq.int
[08:24:52.756]             signalCondition <- base::signalCondition
[08:24:52.756]             sys.calls <- base::sys.calls
[08:24:52.756]             `[[` <- base::`[[`
[08:24:52.756]             `+` <- base::`+`
[08:24:52.756]             `<<-` <- base::`<<-`
[08:24:52.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.756]                   3L)]
[08:24:52.756]             }
[08:24:52.756]             function(cond) {
[08:24:52.756]                 is_error <- inherits(cond, "error")
[08:24:52.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.756]                   NULL)
[08:24:52.756]                 if (is_error) {
[08:24:52.756]                   sessionInformation <- function() {
[08:24:52.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.756]                       search = base::search(), system = base::Sys.info())
[08:24:52.756]                   }
[08:24:52.756]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.756]                     cond$call), session = sessionInformation(), 
[08:24:52.756]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.756]                   signalCondition(cond)
[08:24:52.756]                 }
[08:24:52.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.756]                 "immediateCondition"))) {
[08:24:52.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.756]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.756]                   if (TRUE && !signal) {
[08:24:52.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.756]                     {
[08:24:52.756]                       inherits <- base::inherits
[08:24:52.756]                       invokeRestart <- base::invokeRestart
[08:24:52.756]                       is.null <- base::is.null
[08:24:52.756]                       muffled <- FALSE
[08:24:52.756]                       if (inherits(cond, "message")) {
[08:24:52.756]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.756]                         if (muffled) 
[08:24:52.756]                           invokeRestart("muffleMessage")
[08:24:52.756]                       }
[08:24:52.756]                       else if (inherits(cond, "warning")) {
[08:24:52.756]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.756]                         if (muffled) 
[08:24:52.756]                           invokeRestart("muffleWarning")
[08:24:52.756]                       }
[08:24:52.756]                       else if (inherits(cond, "condition")) {
[08:24:52.756]                         if (!is.null(pattern)) {
[08:24:52.756]                           computeRestarts <- base::computeRestarts
[08:24:52.756]                           grepl <- base::grepl
[08:24:52.756]                           restarts <- computeRestarts(cond)
[08:24:52.756]                           for (restart in restarts) {
[08:24:52.756]                             name <- restart$name
[08:24:52.756]                             if (is.null(name)) 
[08:24:52.756]                               next
[08:24:52.756]                             if (!grepl(pattern, name)) 
[08:24:52.756]                               next
[08:24:52.756]                             invokeRestart(restart)
[08:24:52.756]                             muffled <- TRUE
[08:24:52.756]                             break
[08:24:52.756]                           }
[08:24:52.756]                         }
[08:24:52.756]                       }
[08:24:52.756]                       invisible(muffled)
[08:24:52.756]                     }
[08:24:52.756]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.756]                   }
[08:24:52.756]                 }
[08:24:52.756]                 else {
[08:24:52.756]                   if (TRUE) {
[08:24:52.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.756]                     {
[08:24:52.756]                       inherits <- base::inherits
[08:24:52.756]                       invokeRestart <- base::invokeRestart
[08:24:52.756]                       is.null <- base::is.null
[08:24:52.756]                       muffled <- FALSE
[08:24:52.756]                       if (inherits(cond, "message")) {
[08:24:52.756]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.756]                         if (muffled) 
[08:24:52.756]                           invokeRestart("muffleMessage")
[08:24:52.756]                       }
[08:24:52.756]                       else if (inherits(cond, "warning")) {
[08:24:52.756]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.756]                         if (muffled) 
[08:24:52.756]                           invokeRestart("muffleWarning")
[08:24:52.756]                       }
[08:24:52.756]                       else if (inherits(cond, "condition")) {
[08:24:52.756]                         if (!is.null(pattern)) {
[08:24:52.756]                           computeRestarts <- base::computeRestarts
[08:24:52.756]                           grepl <- base::grepl
[08:24:52.756]                           restarts <- computeRestarts(cond)
[08:24:52.756]                           for (restart in restarts) {
[08:24:52.756]                             name <- restart$name
[08:24:52.756]                             if (is.null(name)) 
[08:24:52.756]                               next
[08:24:52.756]                             if (!grepl(pattern, name)) 
[08:24:52.756]                               next
[08:24:52.756]                             invokeRestart(restart)
[08:24:52.756]                             muffled <- TRUE
[08:24:52.756]                             break
[08:24:52.756]                           }
[08:24:52.756]                         }
[08:24:52.756]                       }
[08:24:52.756]                       invisible(muffled)
[08:24:52.756]                     }
[08:24:52.756]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.756]                   }
[08:24:52.756]                 }
[08:24:52.756]             }
[08:24:52.756]         }))
[08:24:52.756]     }, error = function(ex) {
[08:24:52.756]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.756]                 ...future.rng), started = ...future.startTime, 
[08:24:52.756]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.756]             version = "1.8"), class = "FutureResult")
[08:24:52.756]     }, finally = {
[08:24:52.756]         if (!identical(...future.workdir, getwd())) 
[08:24:52.756]             setwd(...future.workdir)
[08:24:52.756]         {
[08:24:52.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.756]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.756]             }
[08:24:52.756]             base::options(...future.oldOptions)
[08:24:52.756]             if (.Platform$OS.type == "windows") {
[08:24:52.756]                 old_names <- names(...future.oldEnvVars)
[08:24:52.756]                 envs <- base::Sys.getenv()
[08:24:52.756]                 names <- names(envs)
[08:24:52.756]                 common <- intersect(names, old_names)
[08:24:52.756]                 added <- setdiff(names, old_names)
[08:24:52.756]                 removed <- setdiff(old_names, names)
[08:24:52.756]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.756]                   envs[common]]
[08:24:52.756]                 NAMES <- toupper(changed)
[08:24:52.756]                 args <- list()
[08:24:52.756]                 for (kk in seq_along(NAMES)) {
[08:24:52.756]                   name <- changed[[kk]]
[08:24:52.756]                   NAME <- NAMES[[kk]]
[08:24:52.756]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.756]                     next
[08:24:52.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.756]                 }
[08:24:52.756]                 NAMES <- toupper(added)
[08:24:52.756]                 for (kk in seq_along(NAMES)) {
[08:24:52.756]                   name <- added[[kk]]
[08:24:52.756]                   NAME <- NAMES[[kk]]
[08:24:52.756]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.756]                     next
[08:24:52.756]                   args[[name]] <- ""
[08:24:52.756]                 }
[08:24:52.756]                 NAMES <- toupper(removed)
[08:24:52.756]                 for (kk in seq_along(NAMES)) {
[08:24:52.756]                   name <- removed[[kk]]
[08:24:52.756]                   NAME <- NAMES[[kk]]
[08:24:52.756]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.756]                     next
[08:24:52.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.756]                 }
[08:24:52.756]                 if (length(args) > 0) 
[08:24:52.756]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.756]             }
[08:24:52.756]             else {
[08:24:52.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.756]             }
[08:24:52.756]             {
[08:24:52.756]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.756]                   0L) {
[08:24:52.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.756]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.756]                   base::options(opts)
[08:24:52.756]                 }
[08:24:52.756]                 {
[08:24:52.756]                   {
[08:24:52.756]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.756]                     NULL
[08:24:52.756]                   }
[08:24:52.756]                   options(future.plan = NULL)
[08:24:52.756]                   if (is.na(NA_character_)) 
[08:24:52.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.756]                     .init = FALSE)
[08:24:52.756]                 }
[08:24:52.756]             }
[08:24:52.756]         }
[08:24:52.756]     })
[08:24:52.756]     if (TRUE) {
[08:24:52.756]         base::sink(type = "output", split = FALSE)
[08:24:52.756]         if (TRUE) {
[08:24:52.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.756]         }
[08:24:52.756]         else {
[08:24:52.756]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.756]         }
[08:24:52.756]         base::close(...future.stdout)
[08:24:52.756]         ...future.stdout <- NULL
[08:24:52.756]     }
[08:24:52.756]     ...future.result$conditions <- ...future.conditions
[08:24:52.756]     ...future.result$finished <- base::Sys.time()
[08:24:52.756]     ...future.result
[08:24:52.756] }
[08:24:52.760] assign_globals() ...
[08:24:52.760] List of 5
[08:24:52.760]  $ future.call.arguments    : list()
[08:24:52.760]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.760]  $ ...future.FUN            :function (x)  
[08:24:52.760]  $ ...future.elements_ii    :List of 1
[08:24:52.760]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[08:24:52.760]  $ ...future.seeds_ii       : NULL
[08:24:52.760]  $ ...future.globals.maxSize: num Inf
[08:24:52.760]  - attr(*, "resolved")= logi FALSE
[08:24:52.760]  - attr(*, "total_size")= num NA
[08:24:52.760]  - attr(*, "where")=List of 5
[08:24:52.760]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.760]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.760]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.760]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.760]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.760]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.760]  - attr(*, "already-done")= logi TRUE
[08:24:52.767] - copied ‘future.call.arguments’ to environment
[08:24:52.768] - copied ‘...future.FUN’ to environment
[08:24:52.768] - copied ‘...future.elements_ii’ to environment
[08:24:52.768] - copied ‘...future.seeds_ii’ to environment
[08:24:52.768] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.768] assign_globals() ... done
[08:24:52.768] requestCore(): workers = 2
[08:24:52.771] MulticoreFuture started
[08:24:52.771] - Launch lazy future ... done
[08:24:52.771] run() for ‘MulticoreFuture’ ... done
[08:24:52.772] Created future:
[08:24:52.772] plan(): Setting new future strategy stack:
[08:24:52.772] List of future strategies:
[08:24:52.772] 1. sequential:
[08:24:52.772]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.772]    - tweaked: FALSE
[08:24:52.772]    - call: NULL
[08:24:52.773] plan(): nbrOfWorkers() = 1
[08:24:52.780] plan(): Setting new future strategy stack:
[08:24:52.780] List of future strategies:
[08:24:52.780] 1. multicore:
[08:24:52.780]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.780]    - tweaked: FALSE
[08:24:52.780]    - call: plan(strategy)
[08:24:52.772] MulticoreFuture:
[08:24:52.772] Label: ‘future_apply-2’
[08:24:52.772] Expression:
[08:24:52.772] {
[08:24:52.772]     do.call(function(...) {
[08:24:52.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.772]             on.exit(options(oopts), add = TRUE)
[08:24:52.772]         }
[08:24:52.772]         {
[08:24:52.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.772]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.772]             })
[08:24:52.772]         }
[08:24:52.772]     }, args = future.call.arguments)
[08:24:52.772] }
[08:24:52.772] Lazy evaluation: FALSE
[08:24:52.772] Asynchronous evaluation: TRUE
[08:24:52.772] Local evaluation: TRUE
[08:24:52.772] Environment: R_GlobalEnv
[08:24:52.772] Capture standard output: TRUE
[08:24:52.772] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.772] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.772] Packages: <none>
[08:24:52.772] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.772] Resolved: FALSE
[08:24:52.772] Value: <not collected>
[08:24:52.772] Conditions captured: <none>
[08:24:52.772] Early signaling: FALSE
[08:24:52.772] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.772] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.785] plan(): nbrOfWorkers() = 2
[08:24:52.784] Chunk #2 of 2 ... DONE
[08:24:52.787] Launching 2 futures (chunks) ... DONE
[08:24:52.788] Resolving 2 futures (chunks) ...
[08:24:52.788] resolve() on list ...
[08:24:52.788]  recursive: 0
[08:24:52.789]  length: 2
[08:24:52.789] 
[08:24:52.790] Future #1
[08:24:52.790] result() for MulticoreFuture ...
[08:24:52.791] result() for MulticoreFuture ...
[08:24:52.791] result() for MulticoreFuture ... done
[08:24:52.792] result() for MulticoreFuture ... done
[08:24:52.792] result() for MulticoreFuture ...
[08:24:52.792] result() for MulticoreFuture ... done
[08:24:52.793] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:52.793] - nx: 2
[08:24:52.793] - relay: TRUE
[08:24:52.794] - stdout: TRUE
[08:24:52.794] - signal: TRUE
[08:24:52.794] - resignal: FALSE
[08:24:52.794] - force: TRUE
[08:24:52.794] - relayed: [n=2] FALSE, FALSE
[08:24:52.795] - queued futures: [n=2] FALSE, FALSE
[08:24:52.795]  - until=1
[08:24:52.795]  - relaying element #1
[08:24:52.796] result() for MulticoreFuture ...
[08:24:52.796] result() for MulticoreFuture ... done
[08:24:52.796] result() for MulticoreFuture ...
[08:24:52.796] result() for MulticoreFuture ... done
[08:24:52.796] result() for MulticoreFuture ...
[08:24:52.796] result() for MulticoreFuture ... done
[08:24:52.797] result() for MulticoreFuture ...
[08:24:52.797] result() for MulticoreFuture ... done
[08:24:52.797] - relayed: [n=2] TRUE, FALSE
[08:24:52.797] - queued futures: [n=2] TRUE, FALSE
[08:24:52.797] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:52.797]  length: 1 (resolved future 1)
[08:24:52.797] Future #2
[08:24:52.798] result() for MulticoreFuture ...
[08:24:52.798] result() for MulticoreFuture ...
[08:24:52.799] result() for MulticoreFuture ... done
[08:24:52.799] result() for MulticoreFuture ... done
[08:24:52.799] result() for MulticoreFuture ...
[08:24:52.799] result() for MulticoreFuture ... done
[08:24:52.799] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:52.799] - nx: 2
[08:24:52.800] - relay: TRUE
[08:24:52.800] - stdout: TRUE
[08:24:52.800] - signal: TRUE
[08:24:52.800] - resignal: FALSE
[08:24:52.800] - force: TRUE
[08:24:52.800] - relayed: [n=2] TRUE, FALSE
[08:24:52.800] - queued futures: [n=2] TRUE, FALSE
[08:24:52.800]  - until=2
[08:24:52.800]  - relaying element #2
[08:24:52.801] result() for MulticoreFuture ...
[08:24:52.801] result() for MulticoreFuture ... done
[08:24:52.801] result() for MulticoreFuture ...
[08:24:52.801] result() for MulticoreFuture ... done
[08:24:52.801] result() for MulticoreFuture ...
[08:24:52.801] result() for MulticoreFuture ... done
[08:24:52.801] result() for MulticoreFuture ...
[08:24:52.801] result() for MulticoreFuture ... done
[08:24:52.801] - relayed: [n=2] TRUE, TRUE
[08:24:52.802] - queued futures: [n=2] TRUE, TRUE
[08:24:52.802] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:52.802]  length: 0 (resolved future 2)
[08:24:52.802] Relaying remaining futures
[08:24:52.802] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.802] - nx: 2
[08:24:52.802] - relay: TRUE
[08:24:52.802] - stdout: TRUE
[08:24:52.802] - signal: TRUE
[08:24:52.802] - resignal: FALSE
[08:24:52.803] - force: TRUE
[08:24:52.803] - relayed: [n=2] TRUE, TRUE
[08:24:52.803] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:52.803] - relayed: [n=2] TRUE, TRUE
[08:24:52.803] - queued futures: [n=2] TRUE, TRUE
[08:24:52.803] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.803] resolve() on list ... DONE
[08:24:52.803] result() for MulticoreFuture ...
[08:24:52.803] result() for MulticoreFuture ... done
[08:24:52.804] result() for MulticoreFuture ...
[08:24:52.804] result() for MulticoreFuture ... done
[08:24:52.804] result() for MulticoreFuture ...
[08:24:52.804] result() for MulticoreFuture ... done
[08:24:52.804] result() for MulticoreFuture ...
[08:24:52.804] result() for MulticoreFuture ... done
[08:24:52.804]  - Number of value chunks collected: 2
[08:24:52.804] Resolving 2 futures (chunks) ... DONE
[08:24:52.804] Reducing values from 2 chunks ...
[08:24:52.805]  - Number of values collected after concatenation: 2
[08:24:52.805]  - Number of values expected: 2
[08:24:52.805] Reducing values from 2 chunks ... DONE
[08:24:52.805] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[08:24:52.805] getGlobalsAndPackagesXApply() ...
[08:24:52.805]  - future.globals: TRUE
[08:24:52.805] getGlobalsAndPackages() ...
[08:24:52.806] Searching for globals...
[08:24:52.807] - globals found: [1] ‘FUN’
[08:24:52.807] Searching for globals ... DONE
[08:24:52.807] Resolving globals: FALSE
[08:24:52.808] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:52.808] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:52.808] - globals: [1] ‘FUN’
[08:24:52.808] 
[08:24:52.808] getGlobalsAndPackages() ... DONE
[08:24:52.808]  - globals found/used: [n=1] ‘FUN’
[08:24:52.809]  - needed namespaces: [n=0] 
[08:24:52.809] Finding globals ... DONE
[08:24:52.809]  - use_args: TRUE
[08:24:52.809]  - Getting '...' globals ...
[08:24:52.809] resolve() on list ...
[08:24:52.809]  recursive: 0
[08:24:52.809]  length: 1
[08:24:52.810]  elements: ‘...’
[08:24:52.810]  length: 0 (resolved future 1)
[08:24:52.810] resolve() on list ... DONE
[08:24:52.810]    - '...' content: [n=0] 
[08:24:52.810] List of 1
[08:24:52.810]  $ ...: list()
[08:24:52.810]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.810]  - attr(*, "where")=List of 1
[08:24:52.810]   ..$ ...:<environment: 0x56540d792878> 
[08:24:52.810]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.810]  - attr(*, "resolved")= logi TRUE
[08:24:52.810]  - attr(*, "total_size")= num NA
[08:24:52.813]  - Getting '...' globals ... DONE
[08:24:52.813] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.813] List of 2
[08:24:52.813]  $ ...future.FUN:function (x)  
[08:24:52.813]  $ ...          : list()
[08:24:52.813]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.813]  - attr(*, "where")=List of 2
[08:24:52.813]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.813]   ..$ ...          :<environment: 0x56540d792878> 
[08:24:52.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.813]  - attr(*, "resolved")= logi FALSE
[08:24:52.813]  - attr(*, "total_size")= num 3563
[08:24:52.816] Packages to be attached in all futures: [n=0] 
[08:24:52.816] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.818] future_lapply() ...
[08:24:52.822] Number of chunks: 2
[08:24:52.822] getGlobalsAndPackagesXApply() ...
[08:24:52.823]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.823]  - use_args: TRUE
[08:24:52.823] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.823] List of 2
[08:24:52.823]  $ ...          : list()
[08:24:52.823]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.823]  $ ...future.FUN:function (x)  
[08:24:52.823]  - attr(*, "where")=List of 2
[08:24:52.823]   ..$ ...          :<environment: 0x56540d792878> 
[08:24:52.823]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:52.823]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.823]  - attr(*, "resolved")= logi FALSE
[08:24:52.823]  - attr(*, "total_size")= num NA
[08:24:52.827] Packages to be attached in all futures: [n=0] 
[08:24:52.827] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.827] Number of futures (= number of chunks): 2
[08:24:52.827] Launching 2 futures (chunks) ...
[08:24:52.827] Chunk #1 of 2 ...
[08:24:52.828]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.828]  - seeds: <none>
[08:24:52.828]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.828] getGlobalsAndPackages() ...
[08:24:52.828] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.828] Resolving globals: FALSE
[08:24:52.828] Tweak future expression to call with '...' arguments ...
[08:24:52.828] {
[08:24:52.828]     do.call(function(...) {
[08:24:52.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.828]             on.exit(options(oopts), add = TRUE)
[08:24:52.828]         }
[08:24:52.828]         {
[08:24:52.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.828]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.828]             })
[08:24:52.828]         }
[08:24:52.828]     }, args = future.call.arguments)
[08:24:52.828] }
[08:24:52.829] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.829] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.829] 
[08:24:52.829] getGlobalsAndPackages() ... DONE
[08:24:52.830] run() for ‘Future’ ...
[08:24:52.830] - state: ‘created’
[08:24:52.830] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.832] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.832] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.832]   - Field: ‘label’
[08:24:52.832]   - Field: ‘local’
[08:24:52.832]   - Field: ‘owner’
[08:24:52.832]   - Field: ‘envir’
[08:24:52.832]   - Field: ‘workers’
[08:24:52.832]   - Field: ‘packages’
[08:24:52.832]   - Field: ‘gc’
[08:24:52.833]   - Field: ‘job’
[08:24:52.833]   - Field: ‘conditions’
[08:24:52.833]   - Field: ‘expr’
[08:24:52.833]   - Field: ‘uuid’
[08:24:52.833]   - Field: ‘seed’
[08:24:52.833]   - Field: ‘version’
[08:24:52.833]   - Field: ‘result’
[08:24:52.833]   - Field: ‘asynchronous’
[08:24:52.833]   - Field: ‘calls’
[08:24:52.833]   - Field: ‘globals’
[08:24:52.833]   - Field: ‘stdout’
[08:24:52.833]   - Field: ‘earlySignal’
[08:24:52.834]   - Field: ‘lazy’
[08:24:52.834]   - Field: ‘state’
[08:24:52.834] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.834] - Launch lazy future ...
[08:24:52.834] Packages needed by the future expression (n = 0): <none>
[08:24:52.834] Packages needed by future strategies (n = 0): <none>
[08:24:52.835] {
[08:24:52.835]     {
[08:24:52.835]         {
[08:24:52.835]             ...future.startTime <- base::Sys.time()
[08:24:52.835]             {
[08:24:52.835]                 {
[08:24:52.835]                   {
[08:24:52.835]                     {
[08:24:52.835]                       base::local({
[08:24:52.835]                         has_future <- base::requireNamespace("future", 
[08:24:52.835]                           quietly = TRUE)
[08:24:52.835]                         if (has_future) {
[08:24:52.835]                           ns <- base::getNamespace("future")
[08:24:52.835]                           version <- ns[[".package"]][["version"]]
[08:24:52.835]                           if (is.null(version)) 
[08:24:52.835]                             version <- utils::packageVersion("future")
[08:24:52.835]                         }
[08:24:52.835]                         else {
[08:24:52.835]                           version <- NULL
[08:24:52.835]                         }
[08:24:52.835]                         if (!has_future || version < "1.8.0") {
[08:24:52.835]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.835]                             "", base::R.version$version.string), 
[08:24:52.835]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.835]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.835]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.835]                               "release", "version")], collapse = " "), 
[08:24:52.835]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.835]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.835]                             info)
[08:24:52.835]                           info <- base::paste(info, collapse = "; ")
[08:24:52.835]                           if (!has_future) {
[08:24:52.835]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.835]                               info)
[08:24:52.835]                           }
[08:24:52.835]                           else {
[08:24:52.835]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.835]                               info, version)
[08:24:52.835]                           }
[08:24:52.835]                           base::stop(msg)
[08:24:52.835]                         }
[08:24:52.835]                       })
[08:24:52.835]                     }
[08:24:52.835]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.835]                     base::options(mc.cores = 1L)
[08:24:52.835]                   }
[08:24:52.835]                   ...future.strategy.old <- future::plan("list")
[08:24:52.835]                   options(future.plan = NULL)
[08:24:52.835]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.835]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.835]                 }
[08:24:52.835]                 ...future.workdir <- getwd()
[08:24:52.835]             }
[08:24:52.835]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.835]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.835]         }
[08:24:52.835]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.835]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.835]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.835]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.835]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.835]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.835]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.835]             base::names(...future.oldOptions))
[08:24:52.835]     }
[08:24:52.835]     if (FALSE) {
[08:24:52.835]     }
[08:24:52.835]     else {
[08:24:52.835]         if (TRUE) {
[08:24:52.835]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.835]                 open = "w")
[08:24:52.835]         }
[08:24:52.835]         else {
[08:24:52.835]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.835]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.835]         }
[08:24:52.835]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.835]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.835]             base::sink(type = "output", split = FALSE)
[08:24:52.835]             base::close(...future.stdout)
[08:24:52.835]         }, add = TRUE)
[08:24:52.835]     }
[08:24:52.835]     ...future.frame <- base::sys.nframe()
[08:24:52.835]     ...future.conditions <- base::list()
[08:24:52.835]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.835]     if (FALSE) {
[08:24:52.835]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.835]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.835]     }
[08:24:52.835]     ...future.result <- base::tryCatch({
[08:24:52.835]         base::withCallingHandlers({
[08:24:52.835]             ...future.value <- base::withVisible(base::local({
[08:24:52.835]                 withCallingHandlers({
[08:24:52.835]                   {
[08:24:52.835]                     do.call(function(...) {
[08:24:52.835]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.835]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.835]                         ...future.globals.maxSize)) {
[08:24:52.835]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.835]                         on.exit(options(oopts), add = TRUE)
[08:24:52.835]                       }
[08:24:52.835]                       {
[08:24:52.835]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.835]                           FUN = function(jj) {
[08:24:52.835]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.835]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.835]                           })
[08:24:52.835]                       }
[08:24:52.835]                     }, args = future.call.arguments)
[08:24:52.835]                   }
[08:24:52.835]                 }, immediateCondition = function(cond) {
[08:24:52.835]                   save_rds <- function (object, pathname, ...) 
[08:24:52.835]                   {
[08:24:52.835]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.835]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.835]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.835]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.835]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.835]                         fi_tmp[["mtime"]])
[08:24:52.835]                     }
[08:24:52.835]                     tryCatch({
[08:24:52.835]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.835]                     }, error = function(ex) {
[08:24:52.835]                       msg <- conditionMessage(ex)
[08:24:52.835]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.835]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.835]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.835]                         fi_tmp[["mtime"]], msg)
[08:24:52.835]                       ex$message <- msg
[08:24:52.835]                       stop(ex)
[08:24:52.835]                     })
[08:24:52.835]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.835]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.835]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.835]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.835]                       fi <- file.info(pathname)
[08:24:52.835]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.835]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.835]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.835]                         fi[["size"]], fi[["mtime"]])
[08:24:52.835]                       stop(msg)
[08:24:52.835]                     }
[08:24:52.835]                     invisible(pathname)
[08:24:52.835]                   }
[08:24:52.835]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.835]                     rootPath = tempdir()) 
[08:24:52.835]                   {
[08:24:52.835]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.835]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.835]                       tmpdir = path, fileext = ".rds")
[08:24:52.835]                     save_rds(obj, file)
[08:24:52.835]                   }
[08:24:52.835]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.835]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.835]                   {
[08:24:52.835]                     inherits <- base::inherits
[08:24:52.835]                     invokeRestart <- base::invokeRestart
[08:24:52.835]                     is.null <- base::is.null
[08:24:52.835]                     muffled <- FALSE
[08:24:52.835]                     if (inherits(cond, "message")) {
[08:24:52.835]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.835]                       if (muffled) 
[08:24:52.835]                         invokeRestart("muffleMessage")
[08:24:52.835]                     }
[08:24:52.835]                     else if (inherits(cond, "warning")) {
[08:24:52.835]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.835]                       if (muffled) 
[08:24:52.835]                         invokeRestart("muffleWarning")
[08:24:52.835]                     }
[08:24:52.835]                     else if (inherits(cond, "condition")) {
[08:24:52.835]                       if (!is.null(pattern)) {
[08:24:52.835]                         computeRestarts <- base::computeRestarts
[08:24:52.835]                         grepl <- base::grepl
[08:24:52.835]                         restarts <- computeRestarts(cond)
[08:24:52.835]                         for (restart in restarts) {
[08:24:52.835]                           name <- restart$name
[08:24:52.835]                           if (is.null(name)) 
[08:24:52.835]                             next
[08:24:52.835]                           if (!grepl(pattern, name)) 
[08:24:52.835]                             next
[08:24:52.835]                           invokeRestart(restart)
[08:24:52.835]                           muffled <- TRUE
[08:24:52.835]                           break
[08:24:52.835]                         }
[08:24:52.835]                       }
[08:24:52.835]                     }
[08:24:52.835]                     invisible(muffled)
[08:24:52.835]                   }
[08:24:52.835]                   muffleCondition(cond)
[08:24:52.835]                 })
[08:24:52.835]             }))
[08:24:52.835]             future::FutureResult(value = ...future.value$value, 
[08:24:52.835]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.835]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.835]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.835]                     ...future.globalenv.names))
[08:24:52.835]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.835]         }, condition = base::local({
[08:24:52.835]             c <- base::c
[08:24:52.835]             inherits <- base::inherits
[08:24:52.835]             invokeRestart <- base::invokeRestart
[08:24:52.835]             length <- base::length
[08:24:52.835]             list <- base::list
[08:24:52.835]             seq.int <- base::seq.int
[08:24:52.835]             signalCondition <- base::signalCondition
[08:24:52.835]             sys.calls <- base::sys.calls
[08:24:52.835]             `[[` <- base::`[[`
[08:24:52.835]             `+` <- base::`+`
[08:24:52.835]             `<<-` <- base::`<<-`
[08:24:52.835]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.835]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.835]                   3L)]
[08:24:52.835]             }
[08:24:52.835]             function(cond) {
[08:24:52.835]                 is_error <- inherits(cond, "error")
[08:24:52.835]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.835]                   NULL)
[08:24:52.835]                 if (is_error) {
[08:24:52.835]                   sessionInformation <- function() {
[08:24:52.835]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.835]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.835]                       search = base::search(), system = base::Sys.info())
[08:24:52.835]                   }
[08:24:52.835]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.835]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.835]                     cond$call), session = sessionInformation(), 
[08:24:52.835]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.835]                   signalCondition(cond)
[08:24:52.835]                 }
[08:24:52.835]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.835]                 "immediateCondition"))) {
[08:24:52.835]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.835]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.835]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.835]                   if (TRUE && !signal) {
[08:24:52.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.835]                     {
[08:24:52.835]                       inherits <- base::inherits
[08:24:52.835]                       invokeRestart <- base::invokeRestart
[08:24:52.835]                       is.null <- base::is.null
[08:24:52.835]                       muffled <- FALSE
[08:24:52.835]                       if (inherits(cond, "message")) {
[08:24:52.835]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.835]                         if (muffled) 
[08:24:52.835]                           invokeRestart("muffleMessage")
[08:24:52.835]                       }
[08:24:52.835]                       else if (inherits(cond, "warning")) {
[08:24:52.835]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.835]                         if (muffled) 
[08:24:52.835]                           invokeRestart("muffleWarning")
[08:24:52.835]                       }
[08:24:52.835]                       else if (inherits(cond, "condition")) {
[08:24:52.835]                         if (!is.null(pattern)) {
[08:24:52.835]                           computeRestarts <- base::computeRestarts
[08:24:52.835]                           grepl <- base::grepl
[08:24:52.835]                           restarts <- computeRestarts(cond)
[08:24:52.835]                           for (restart in restarts) {
[08:24:52.835]                             name <- restart$name
[08:24:52.835]                             if (is.null(name)) 
[08:24:52.835]                               next
[08:24:52.835]                             if (!grepl(pattern, name)) 
[08:24:52.835]                               next
[08:24:52.835]                             invokeRestart(restart)
[08:24:52.835]                             muffled <- TRUE
[08:24:52.835]                             break
[08:24:52.835]                           }
[08:24:52.835]                         }
[08:24:52.835]                       }
[08:24:52.835]                       invisible(muffled)
[08:24:52.835]                     }
[08:24:52.835]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.835]                   }
[08:24:52.835]                 }
[08:24:52.835]                 else {
[08:24:52.835]                   if (TRUE) {
[08:24:52.835]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.835]                     {
[08:24:52.835]                       inherits <- base::inherits
[08:24:52.835]                       invokeRestart <- base::invokeRestart
[08:24:52.835]                       is.null <- base::is.null
[08:24:52.835]                       muffled <- FALSE
[08:24:52.835]                       if (inherits(cond, "message")) {
[08:24:52.835]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.835]                         if (muffled) 
[08:24:52.835]                           invokeRestart("muffleMessage")
[08:24:52.835]                       }
[08:24:52.835]                       else if (inherits(cond, "warning")) {
[08:24:52.835]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.835]                         if (muffled) 
[08:24:52.835]                           invokeRestart("muffleWarning")
[08:24:52.835]                       }
[08:24:52.835]                       else if (inherits(cond, "condition")) {
[08:24:52.835]                         if (!is.null(pattern)) {
[08:24:52.835]                           computeRestarts <- base::computeRestarts
[08:24:52.835]                           grepl <- base::grepl
[08:24:52.835]                           restarts <- computeRestarts(cond)
[08:24:52.835]                           for (restart in restarts) {
[08:24:52.835]                             name <- restart$name
[08:24:52.835]                             if (is.null(name)) 
[08:24:52.835]                               next
[08:24:52.835]                             if (!grepl(pattern, name)) 
[08:24:52.835]                               next
[08:24:52.835]                             invokeRestart(restart)
[08:24:52.835]                             muffled <- TRUE
[08:24:52.835]                             break
[08:24:52.835]                           }
[08:24:52.835]                         }
[08:24:52.835]                       }
[08:24:52.835]                       invisible(muffled)
[08:24:52.835]                     }
[08:24:52.835]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.835]                   }
[08:24:52.835]                 }
[08:24:52.835]             }
[08:24:52.835]         }))
[08:24:52.835]     }, error = function(ex) {
[08:24:52.835]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.835]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.835]                 ...future.rng), started = ...future.startTime, 
[08:24:52.835]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.835]             version = "1.8"), class = "FutureResult")
[08:24:52.835]     }, finally = {
[08:24:52.835]         if (!identical(...future.workdir, getwd())) 
[08:24:52.835]             setwd(...future.workdir)
[08:24:52.835]         {
[08:24:52.835]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.835]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.835]             }
[08:24:52.835]             base::options(...future.oldOptions)
[08:24:52.835]             if (.Platform$OS.type == "windows") {
[08:24:52.835]                 old_names <- names(...future.oldEnvVars)
[08:24:52.835]                 envs <- base::Sys.getenv()
[08:24:52.835]                 names <- names(envs)
[08:24:52.835]                 common <- intersect(names, old_names)
[08:24:52.835]                 added <- setdiff(names, old_names)
[08:24:52.835]                 removed <- setdiff(old_names, names)
[08:24:52.835]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.835]                   envs[common]]
[08:24:52.835]                 NAMES <- toupper(changed)
[08:24:52.835]                 args <- list()
[08:24:52.835]                 for (kk in seq_along(NAMES)) {
[08:24:52.835]                   name <- changed[[kk]]
[08:24:52.835]                   NAME <- NAMES[[kk]]
[08:24:52.835]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.835]                     next
[08:24:52.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.835]                 }
[08:24:52.835]                 NAMES <- toupper(added)
[08:24:52.835]                 for (kk in seq_along(NAMES)) {
[08:24:52.835]                   name <- added[[kk]]
[08:24:52.835]                   NAME <- NAMES[[kk]]
[08:24:52.835]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.835]                     next
[08:24:52.835]                   args[[name]] <- ""
[08:24:52.835]                 }
[08:24:52.835]                 NAMES <- toupper(removed)
[08:24:52.835]                 for (kk in seq_along(NAMES)) {
[08:24:52.835]                   name <- removed[[kk]]
[08:24:52.835]                   NAME <- NAMES[[kk]]
[08:24:52.835]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.835]                     next
[08:24:52.835]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.835]                 }
[08:24:52.835]                 if (length(args) > 0) 
[08:24:52.835]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.835]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.835]             }
[08:24:52.835]             else {
[08:24:52.835]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.835]             }
[08:24:52.835]             {
[08:24:52.835]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.835]                   0L) {
[08:24:52.835]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.835]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.835]                   base::options(opts)
[08:24:52.835]                 }
[08:24:52.835]                 {
[08:24:52.835]                   {
[08:24:52.835]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.835]                     NULL
[08:24:52.835]                   }
[08:24:52.835]                   options(future.plan = NULL)
[08:24:52.835]                   if (is.na(NA_character_)) 
[08:24:52.835]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.835]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.835]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.835]                     .init = FALSE)
[08:24:52.835]                 }
[08:24:52.835]             }
[08:24:52.835]         }
[08:24:52.835]     })
[08:24:52.835]     if (TRUE) {
[08:24:52.835]         base::sink(type = "output", split = FALSE)
[08:24:52.835]         if (TRUE) {
[08:24:52.835]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.835]         }
[08:24:52.835]         else {
[08:24:52.835]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.835]         }
[08:24:52.835]         base::close(...future.stdout)
[08:24:52.835]         ...future.stdout <- NULL
[08:24:52.835]     }
[08:24:52.835]     ...future.result$conditions <- ...future.conditions
[08:24:52.835]     ...future.result$finished <- base::Sys.time()
[08:24:52.835]     ...future.result
[08:24:52.835] }
[08:24:52.837] assign_globals() ...
[08:24:52.837] List of 5
[08:24:52.837]  $ future.call.arguments    : list()
[08:24:52.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.837]  $ ...future.FUN            :function (x)  
[08:24:52.837]  $ ...future.elements_ii    :List of 3
[08:24:52.837]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[08:24:52.837]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[08:24:52.837]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[08:24:52.837]  $ ...future.seeds_ii       : NULL
[08:24:52.837]  $ ...future.globals.maxSize: num Inf
[08:24:52.837]  - attr(*, "resolved")= logi FALSE
[08:24:52.837]  - attr(*, "total_size")= num NA
[08:24:52.837]  - attr(*, "where")=List of 5
[08:24:52.837]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.837]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.837]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.837]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.837]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.837]  - attr(*, "already-done")= logi TRUE
[08:24:52.843] - copied ‘future.call.arguments’ to environment
[08:24:52.843] - copied ‘...future.FUN’ to environment
[08:24:52.843] - copied ‘...future.elements_ii’ to environment
[08:24:52.843] - copied ‘...future.seeds_ii’ to environment
[08:24:52.843] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.843] assign_globals() ... done
[08:24:52.843] requestCore(): workers = 2
[08:24:52.846] MulticoreFuture started
[08:24:52.846] - Launch lazy future ... done
[08:24:52.846] run() for ‘MulticoreFuture’ ... done
[08:24:52.847] Created future:
[08:24:52.847] plan(): Setting new future strategy stack:
[08:24:52.847] List of future strategies:
[08:24:52.847] 1. sequential:
[08:24:52.847]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.847]    - tweaked: FALSE
[08:24:52.847]    - call: NULL
[08:24:52.848] plan(): nbrOfWorkers() = 1
[08:24:52.850] plan(): Setting new future strategy stack:
[08:24:52.850] List of future strategies:
[08:24:52.850] 1. multicore:
[08:24:52.850]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.850]    - tweaked: FALSE
[08:24:52.850]    - call: plan(strategy)
[08:24:52.859] plan(): nbrOfWorkers() = 2
[08:24:52.847] MulticoreFuture:
[08:24:52.847] Label: ‘future_apply-1’
[08:24:52.847] Expression:
[08:24:52.847] {
[08:24:52.847]     do.call(function(...) {
[08:24:52.847]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.847]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.847]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.847]             on.exit(options(oopts), add = TRUE)
[08:24:52.847]         }
[08:24:52.847]         {
[08:24:52.847]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.847]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.847]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.847]             })
[08:24:52.847]         }
[08:24:52.847]     }, args = future.call.arguments)
[08:24:52.847] }
[08:24:52.847] Lazy evaluation: FALSE
[08:24:52.847] Asynchronous evaluation: TRUE
[08:24:52.847] Local evaluation: TRUE
[08:24:52.847] Environment: R_GlobalEnv
[08:24:52.847] Capture standard output: TRUE
[08:24:52.847] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.847] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.847] Packages: <none>
[08:24:52.847] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.847] Resolved: FALSE
[08:24:52.847] Value: <not collected>
[08:24:52.847] Conditions captured: <none>
[08:24:52.847] Early signaling: FALSE
[08:24:52.847] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.847] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.859] Chunk #1 of 2 ... DONE
[08:24:52.859] Chunk #2 of 2 ...
[08:24:52.860]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.860]  - seeds: <none>
[08:24:52.860]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.860] getGlobalsAndPackages() ...
[08:24:52.860] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.863] Resolving globals: FALSE
[08:24:52.863] Tweak future expression to call with '...' arguments ...
[08:24:52.864] {
[08:24:52.864]     do.call(function(...) {
[08:24:52.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.864]             on.exit(options(oopts), add = TRUE)
[08:24:52.864]         }
[08:24:52.864]         {
[08:24:52.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.864]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.864]             })
[08:24:52.864]         }
[08:24:52.864]     }, args = future.call.arguments)
[08:24:52.864] }
[08:24:52.864] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.865] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.866] 
[08:24:52.866] getGlobalsAndPackages() ... DONE
[08:24:52.867] run() for ‘Future’ ...
[08:24:52.867] - state: ‘created’
[08:24:52.868] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.872] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.873]   - Field: ‘label’
[08:24:52.873]   - Field: ‘local’
[08:24:52.873]   - Field: ‘owner’
[08:24:52.873]   - Field: ‘envir’
[08:24:52.873]   - Field: ‘workers’
[08:24:52.873]   - Field: ‘packages’
[08:24:52.874]   - Field: ‘gc’
[08:24:52.874]   - Field: ‘job’
[08:24:52.874]   - Field: ‘conditions’
[08:24:52.874]   - Field: ‘expr’
[08:24:52.874]   - Field: ‘uuid’
[08:24:52.874]   - Field: ‘seed’
[08:24:52.874]   - Field: ‘version’
[08:24:52.875]   - Field: ‘result’
[08:24:52.875]   - Field: ‘asynchronous’
[08:24:52.875]   - Field: ‘calls’
[08:24:52.875]   - Field: ‘globals’
[08:24:52.875]   - Field: ‘stdout’
[08:24:52.875]   - Field: ‘earlySignal’
[08:24:52.875]   - Field: ‘lazy’
[08:24:52.876]   - Field: ‘state’
[08:24:52.876] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.876] - Launch lazy future ...
[08:24:52.876] Packages needed by the future expression (n = 0): <none>
[08:24:52.876] Packages needed by future strategies (n = 0): <none>
[08:24:52.877] {
[08:24:52.877]     {
[08:24:52.877]         {
[08:24:52.877]             ...future.startTime <- base::Sys.time()
[08:24:52.877]             {
[08:24:52.877]                 {
[08:24:52.877]                   {
[08:24:52.877]                     {
[08:24:52.877]                       base::local({
[08:24:52.877]                         has_future <- base::requireNamespace("future", 
[08:24:52.877]                           quietly = TRUE)
[08:24:52.877]                         if (has_future) {
[08:24:52.877]                           ns <- base::getNamespace("future")
[08:24:52.877]                           version <- ns[[".package"]][["version"]]
[08:24:52.877]                           if (is.null(version)) 
[08:24:52.877]                             version <- utils::packageVersion("future")
[08:24:52.877]                         }
[08:24:52.877]                         else {
[08:24:52.877]                           version <- NULL
[08:24:52.877]                         }
[08:24:52.877]                         if (!has_future || version < "1.8.0") {
[08:24:52.877]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.877]                             "", base::R.version$version.string), 
[08:24:52.877]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.877]                               "release", "version")], collapse = " "), 
[08:24:52.877]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.877]                             info)
[08:24:52.877]                           info <- base::paste(info, collapse = "; ")
[08:24:52.877]                           if (!has_future) {
[08:24:52.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.877]                               info)
[08:24:52.877]                           }
[08:24:52.877]                           else {
[08:24:52.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.877]                               info, version)
[08:24:52.877]                           }
[08:24:52.877]                           base::stop(msg)
[08:24:52.877]                         }
[08:24:52.877]                       })
[08:24:52.877]                     }
[08:24:52.877]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.877]                     base::options(mc.cores = 1L)
[08:24:52.877]                   }
[08:24:52.877]                   ...future.strategy.old <- future::plan("list")
[08:24:52.877]                   options(future.plan = NULL)
[08:24:52.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.877]                 }
[08:24:52.877]                 ...future.workdir <- getwd()
[08:24:52.877]             }
[08:24:52.877]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.877]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.877]         }
[08:24:52.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.877]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.877]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.877]             base::names(...future.oldOptions))
[08:24:52.877]     }
[08:24:52.877]     if (FALSE) {
[08:24:52.877]     }
[08:24:52.877]     else {
[08:24:52.877]         if (TRUE) {
[08:24:52.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.877]                 open = "w")
[08:24:52.877]         }
[08:24:52.877]         else {
[08:24:52.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.877]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.877]         }
[08:24:52.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.877]             base::sink(type = "output", split = FALSE)
[08:24:52.877]             base::close(...future.stdout)
[08:24:52.877]         }, add = TRUE)
[08:24:52.877]     }
[08:24:52.877]     ...future.frame <- base::sys.nframe()
[08:24:52.877]     ...future.conditions <- base::list()
[08:24:52.877]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.877]     if (FALSE) {
[08:24:52.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.877]     }
[08:24:52.877]     ...future.result <- base::tryCatch({
[08:24:52.877]         base::withCallingHandlers({
[08:24:52.877]             ...future.value <- base::withVisible(base::local({
[08:24:52.877]                 withCallingHandlers({
[08:24:52.877]                   {
[08:24:52.877]                     do.call(function(...) {
[08:24:52.877]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.877]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.877]                         ...future.globals.maxSize)) {
[08:24:52.877]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.877]                         on.exit(options(oopts), add = TRUE)
[08:24:52.877]                       }
[08:24:52.877]                       {
[08:24:52.877]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.877]                           FUN = function(jj) {
[08:24:52.877]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.877]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.877]                           })
[08:24:52.877]                       }
[08:24:52.877]                     }, args = future.call.arguments)
[08:24:52.877]                   }
[08:24:52.877]                 }, immediateCondition = function(cond) {
[08:24:52.877]                   save_rds <- function (object, pathname, ...) 
[08:24:52.877]                   {
[08:24:52.877]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.877]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.877]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.877]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.877]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.877]                         fi_tmp[["mtime"]])
[08:24:52.877]                     }
[08:24:52.877]                     tryCatch({
[08:24:52.877]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.877]                     }, error = function(ex) {
[08:24:52.877]                       msg <- conditionMessage(ex)
[08:24:52.877]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.877]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.877]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.877]                         fi_tmp[["mtime"]], msg)
[08:24:52.877]                       ex$message <- msg
[08:24:52.877]                       stop(ex)
[08:24:52.877]                     })
[08:24:52.877]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.877]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.877]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.877]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.877]                       fi <- file.info(pathname)
[08:24:52.877]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.877]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.877]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.877]                         fi[["size"]], fi[["mtime"]])
[08:24:52.877]                       stop(msg)
[08:24:52.877]                     }
[08:24:52.877]                     invisible(pathname)
[08:24:52.877]                   }
[08:24:52.877]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.877]                     rootPath = tempdir()) 
[08:24:52.877]                   {
[08:24:52.877]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.877]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.877]                       tmpdir = path, fileext = ".rds")
[08:24:52.877]                     save_rds(obj, file)
[08:24:52.877]                   }
[08:24:52.877]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.877]                   {
[08:24:52.877]                     inherits <- base::inherits
[08:24:52.877]                     invokeRestart <- base::invokeRestart
[08:24:52.877]                     is.null <- base::is.null
[08:24:52.877]                     muffled <- FALSE
[08:24:52.877]                     if (inherits(cond, "message")) {
[08:24:52.877]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.877]                       if (muffled) 
[08:24:52.877]                         invokeRestart("muffleMessage")
[08:24:52.877]                     }
[08:24:52.877]                     else if (inherits(cond, "warning")) {
[08:24:52.877]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.877]                       if (muffled) 
[08:24:52.877]                         invokeRestart("muffleWarning")
[08:24:52.877]                     }
[08:24:52.877]                     else if (inherits(cond, "condition")) {
[08:24:52.877]                       if (!is.null(pattern)) {
[08:24:52.877]                         computeRestarts <- base::computeRestarts
[08:24:52.877]                         grepl <- base::grepl
[08:24:52.877]                         restarts <- computeRestarts(cond)
[08:24:52.877]                         for (restart in restarts) {
[08:24:52.877]                           name <- restart$name
[08:24:52.877]                           if (is.null(name)) 
[08:24:52.877]                             next
[08:24:52.877]                           if (!grepl(pattern, name)) 
[08:24:52.877]                             next
[08:24:52.877]                           invokeRestart(restart)
[08:24:52.877]                           muffled <- TRUE
[08:24:52.877]                           break
[08:24:52.877]                         }
[08:24:52.877]                       }
[08:24:52.877]                     }
[08:24:52.877]                     invisible(muffled)
[08:24:52.877]                   }
[08:24:52.877]                   muffleCondition(cond)
[08:24:52.877]                 })
[08:24:52.877]             }))
[08:24:52.877]             future::FutureResult(value = ...future.value$value, 
[08:24:52.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.877]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.877]                     ...future.globalenv.names))
[08:24:52.877]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.877]         }, condition = base::local({
[08:24:52.877]             c <- base::c
[08:24:52.877]             inherits <- base::inherits
[08:24:52.877]             invokeRestart <- base::invokeRestart
[08:24:52.877]             length <- base::length
[08:24:52.877]             list <- base::list
[08:24:52.877]             seq.int <- base::seq.int
[08:24:52.877]             signalCondition <- base::signalCondition
[08:24:52.877]             sys.calls <- base::sys.calls
[08:24:52.877]             `[[` <- base::`[[`
[08:24:52.877]             `+` <- base::`+`
[08:24:52.877]             `<<-` <- base::`<<-`
[08:24:52.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.877]                   3L)]
[08:24:52.877]             }
[08:24:52.877]             function(cond) {
[08:24:52.877]                 is_error <- inherits(cond, "error")
[08:24:52.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.877]                   NULL)
[08:24:52.877]                 if (is_error) {
[08:24:52.877]                   sessionInformation <- function() {
[08:24:52.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.877]                       search = base::search(), system = base::Sys.info())
[08:24:52.877]                   }
[08:24:52.877]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.877]                     cond$call), session = sessionInformation(), 
[08:24:52.877]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.877]                   signalCondition(cond)
[08:24:52.877]                 }
[08:24:52.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.877]                 "immediateCondition"))) {
[08:24:52.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.877]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.877]                   if (TRUE && !signal) {
[08:24:52.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.877]                     {
[08:24:52.877]                       inherits <- base::inherits
[08:24:52.877]                       invokeRestart <- base::invokeRestart
[08:24:52.877]                       is.null <- base::is.null
[08:24:52.877]                       muffled <- FALSE
[08:24:52.877]                       if (inherits(cond, "message")) {
[08:24:52.877]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.877]                         if (muffled) 
[08:24:52.877]                           invokeRestart("muffleMessage")
[08:24:52.877]                       }
[08:24:52.877]                       else if (inherits(cond, "warning")) {
[08:24:52.877]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.877]                         if (muffled) 
[08:24:52.877]                           invokeRestart("muffleWarning")
[08:24:52.877]                       }
[08:24:52.877]                       else if (inherits(cond, "condition")) {
[08:24:52.877]                         if (!is.null(pattern)) {
[08:24:52.877]                           computeRestarts <- base::computeRestarts
[08:24:52.877]                           grepl <- base::grepl
[08:24:52.877]                           restarts <- computeRestarts(cond)
[08:24:52.877]                           for (restart in restarts) {
[08:24:52.877]                             name <- restart$name
[08:24:52.877]                             if (is.null(name)) 
[08:24:52.877]                               next
[08:24:52.877]                             if (!grepl(pattern, name)) 
[08:24:52.877]                               next
[08:24:52.877]                             invokeRestart(restart)
[08:24:52.877]                             muffled <- TRUE
[08:24:52.877]                             break
[08:24:52.877]                           }
[08:24:52.877]                         }
[08:24:52.877]                       }
[08:24:52.877]                       invisible(muffled)
[08:24:52.877]                     }
[08:24:52.877]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.877]                   }
[08:24:52.877]                 }
[08:24:52.877]                 else {
[08:24:52.877]                   if (TRUE) {
[08:24:52.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.877]                     {
[08:24:52.877]                       inherits <- base::inherits
[08:24:52.877]                       invokeRestart <- base::invokeRestart
[08:24:52.877]                       is.null <- base::is.null
[08:24:52.877]                       muffled <- FALSE
[08:24:52.877]                       if (inherits(cond, "message")) {
[08:24:52.877]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.877]                         if (muffled) 
[08:24:52.877]                           invokeRestart("muffleMessage")
[08:24:52.877]                       }
[08:24:52.877]                       else if (inherits(cond, "warning")) {
[08:24:52.877]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.877]                         if (muffled) 
[08:24:52.877]                           invokeRestart("muffleWarning")
[08:24:52.877]                       }
[08:24:52.877]                       else if (inherits(cond, "condition")) {
[08:24:52.877]                         if (!is.null(pattern)) {
[08:24:52.877]                           computeRestarts <- base::computeRestarts
[08:24:52.877]                           grepl <- base::grepl
[08:24:52.877]                           restarts <- computeRestarts(cond)
[08:24:52.877]                           for (restart in restarts) {
[08:24:52.877]                             name <- restart$name
[08:24:52.877]                             if (is.null(name)) 
[08:24:52.877]                               next
[08:24:52.877]                             if (!grepl(pattern, name)) 
[08:24:52.877]                               next
[08:24:52.877]                             invokeRestart(restart)
[08:24:52.877]                             muffled <- TRUE
[08:24:52.877]                             break
[08:24:52.877]                           }
[08:24:52.877]                         }
[08:24:52.877]                       }
[08:24:52.877]                       invisible(muffled)
[08:24:52.877]                     }
[08:24:52.877]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.877]                   }
[08:24:52.877]                 }
[08:24:52.877]             }
[08:24:52.877]         }))
[08:24:52.877]     }, error = function(ex) {
[08:24:52.877]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.877]                 ...future.rng), started = ...future.startTime, 
[08:24:52.877]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.877]             version = "1.8"), class = "FutureResult")
[08:24:52.877]     }, finally = {
[08:24:52.877]         if (!identical(...future.workdir, getwd())) 
[08:24:52.877]             setwd(...future.workdir)
[08:24:52.877]         {
[08:24:52.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.877]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.877]             }
[08:24:52.877]             base::options(...future.oldOptions)
[08:24:52.877]             if (.Platform$OS.type == "windows") {
[08:24:52.877]                 old_names <- names(...future.oldEnvVars)
[08:24:52.877]                 envs <- base::Sys.getenv()
[08:24:52.877]                 names <- names(envs)
[08:24:52.877]                 common <- intersect(names, old_names)
[08:24:52.877]                 added <- setdiff(names, old_names)
[08:24:52.877]                 removed <- setdiff(old_names, names)
[08:24:52.877]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.877]                   envs[common]]
[08:24:52.877]                 NAMES <- toupper(changed)
[08:24:52.877]                 args <- list()
[08:24:52.877]                 for (kk in seq_along(NAMES)) {
[08:24:52.877]                   name <- changed[[kk]]
[08:24:52.877]                   NAME <- NAMES[[kk]]
[08:24:52.877]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.877]                     next
[08:24:52.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.877]                 }
[08:24:52.877]                 NAMES <- toupper(added)
[08:24:52.877]                 for (kk in seq_along(NAMES)) {
[08:24:52.877]                   name <- added[[kk]]
[08:24:52.877]                   NAME <- NAMES[[kk]]
[08:24:52.877]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.877]                     next
[08:24:52.877]                   args[[name]] <- ""
[08:24:52.877]                 }
[08:24:52.877]                 NAMES <- toupper(removed)
[08:24:52.877]                 for (kk in seq_along(NAMES)) {
[08:24:52.877]                   name <- removed[[kk]]
[08:24:52.877]                   NAME <- NAMES[[kk]]
[08:24:52.877]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.877]                     next
[08:24:52.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.877]                 }
[08:24:52.877]                 if (length(args) > 0) 
[08:24:52.877]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.877]             }
[08:24:52.877]             else {
[08:24:52.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.877]             }
[08:24:52.877]             {
[08:24:52.877]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.877]                   0L) {
[08:24:52.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.877]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.877]                   base::options(opts)
[08:24:52.877]                 }
[08:24:52.877]                 {
[08:24:52.877]                   {
[08:24:52.877]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.877]                     NULL
[08:24:52.877]                   }
[08:24:52.877]                   options(future.plan = NULL)
[08:24:52.877]                   if (is.na(NA_character_)) 
[08:24:52.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.877]                     .init = FALSE)
[08:24:52.877]                 }
[08:24:52.877]             }
[08:24:52.877]         }
[08:24:52.877]     })
[08:24:52.877]     if (TRUE) {
[08:24:52.877]         base::sink(type = "output", split = FALSE)
[08:24:52.877]         if (TRUE) {
[08:24:52.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.877]         }
[08:24:52.877]         else {
[08:24:52.877]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.877]         }
[08:24:52.877]         base::close(...future.stdout)
[08:24:52.877]         ...future.stdout <- NULL
[08:24:52.877]     }
[08:24:52.877]     ...future.result$conditions <- ...future.conditions
[08:24:52.877]     ...future.result$finished <- base::Sys.time()
[08:24:52.877]     ...future.result
[08:24:52.877] }
[08:24:52.880] assign_globals() ...
[08:24:52.880] List of 5
[08:24:52.880]  $ future.call.arguments    : list()
[08:24:52.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.880]  $ ...future.FUN            :function (x)  
[08:24:52.880]  $ ...future.elements_ii    :List of 3
[08:24:52.880]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[08:24:52.880]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[08:24:52.880]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[08:24:52.880]  $ ...future.seeds_ii       : NULL
[08:24:52.880]  $ ...future.globals.maxSize: num Inf
[08:24:52.880]  - attr(*, "resolved")= logi FALSE
[08:24:52.880]  - attr(*, "total_size")= num NA
[08:24:52.880]  - attr(*, "where")=List of 5
[08:24:52.880]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.880]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.880]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.880]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.880]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.880]  - attr(*, "already-done")= logi TRUE
[08:24:52.887] - copied ‘future.call.arguments’ to environment
[08:24:52.888] - copied ‘...future.FUN’ to environment
[08:24:52.888] - copied ‘...future.elements_ii’ to environment
[08:24:52.888] - copied ‘...future.seeds_ii’ to environment
[08:24:52.888] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.888] assign_globals() ... done
[08:24:52.888] requestCore(): workers = 2
[08:24:52.891] MulticoreFuture started
[08:24:52.891] - Launch lazy future ... done
[08:24:52.891] run() for ‘MulticoreFuture’ ... done
[08:24:52.892] Created future:
[08:24:52.892] plan(): Setting new future strategy stack:
[08:24:52.892] List of future strategies:
[08:24:52.892] 1. sequential:
[08:24:52.892]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.892]    - tweaked: FALSE
[08:24:52.892]    - call: NULL
[08:24:52.893] plan(): nbrOfWorkers() = 1
[08:24:52.895] plan(): Setting new future strategy stack:
[08:24:52.895] List of future strategies:
[08:24:52.895] 1. multicore:
[08:24:52.895]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.895]    - tweaked: FALSE
[08:24:52.895]    - call: plan(strategy)
[08:24:52.899] plan(): nbrOfWorkers() = 2
[08:24:52.892] MulticoreFuture:
[08:24:52.892] Label: ‘future_apply-2’
[08:24:52.892] Expression:
[08:24:52.892] {
[08:24:52.892]     do.call(function(...) {
[08:24:52.892]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.892]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.892]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.892]             on.exit(options(oopts), add = TRUE)
[08:24:52.892]         }
[08:24:52.892]         {
[08:24:52.892]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.892]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.892]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.892]             })
[08:24:52.892]         }
[08:24:52.892]     }, args = future.call.arguments)
[08:24:52.892] }
[08:24:52.892] Lazy evaluation: FALSE
[08:24:52.892] Asynchronous evaluation: TRUE
[08:24:52.892] Local evaluation: TRUE
[08:24:52.892] Environment: R_GlobalEnv
[08:24:52.892] Capture standard output: TRUE
[08:24:52.892] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.892] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.892] Packages: <none>
[08:24:52.892] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.892] Resolved: TRUE
[08:24:52.892] Value: <not collected>
[08:24:52.892] Conditions captured: <none>
[08:24:52.892] Early signaling: FALSE
[08:24:52.892] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.892] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.900] Chunk #2 of 2 ... DONE
[08:24:52.900] Launching 2 futures (chunks) ... DONE
[08:24:52.900] Resolving 2 futures (chunks) ...
[08:24:52.901] resolve() on list ...
[08:24:52.901]  recursive: 0
[08:24:52.901]  length: 2
[08:24:52.901] 
[08:24:52.901] Future #1
[08:24:52.902] result() for MulticoreFuture ...
[08:24:52.902] result() for MulticoreFuture ...
[08:24:52.903] result() for MulticoreFuture ... done
[08:24:52.903] result() for MulticoreFuture ... done
[08:24:52.903] result() for MulticoreFuture ...
[08:24:52.903] result() for MulticoreFuture ... done
[08:24:52.903] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:52.903] - nx: 2
[08:24:52.903] - relay: TRUE
[08:24:52.904] - stdout: TRUE
[08:24:52.904] - signal: TRUE
[08:24:52.904] - resignal: FALSE
[08:24:52.904] - force: TRUE
[08:24:52.904] - relayed: [n=2] FALSE, FALSE
[08:24:52.904] - queued futures: [n=2] FALSE, FALSE
[08:24:52.904]  - until=1
[08:24:52.904]  - relaying element #1
[08:24:52.905] result() for MulticoreFuture ...
[08:24:52.905] result() for MulticoreFuture ... done
[08:24:52.905] result() for MulticoreFuture ...
[08:24:52.905] result() for MulticoreFuture ... done
[08:24:52.905] result() for MulticoreFuture ...
[08:24:52.905] result() for MulticoreFuture ... done
[08:24:52.906] result() for MulticoreFuture ...
[08:24:52.906] result() for MulticoreFuture ... done
[08:24:52.906] - relayed: [n=2] TRUE, FALSE
[08:24:52.906] - queued futures: [n=2] TRUE, FALSE
[08:24:52.906] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:52.906]  length: 1 (resolved future 1)
[08:24:52.907] Future #2
[08:24:52.907] result() for MulticoreFuture ...
[08:24:52.907] result() for MulticoreFuture ...
[08:24:52.908] result() for MulticoreFuture ... done
[08:24:52.908] result() for MulticoreFuture ... done
[08:24:52.908] result() for MulticoreFuture ...
[08:24:52.908] result() for MulticoreFuture ... done
[08:24:52.908] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:52.908] - nx: 2
[08:24:52.908] - relay: TRUE
[08:24:52.908] - stdout: TRUE
[08:24:52.909] - signal: TRUE
[08:24:52.909] - resignal: FALSE
[08:24:52.909] - force: TRUE
[08:24:52.909] - relayed: [n=2] TRUE, FALSE
[08:24:52.909] - queued futures: [n=2] TRUE, FALSE
[08:24:52.909]  - until=2
[08:24:52.909]  - relaying element #2
[08:24:52.909] result() for MulticoreFuture ...
[08:24:52.910] result() for MulticoreFuture ... done
[08:24:52.910] result() for MulticoreFuture ...
[08:24:52.910] result() for MulticoreFuture ... done
[08:24:52.910] result() for MulticoreFuture ...
[08:24:52.913] result() for MulticoreFuture ... done
[08:24:52.913] result() for MulticoreFuture ...
[08:24:52.913] result() for MulticoreFuture ... done
[08:24:52.913] - relayed: [n=2] TRUE, TRUE
[08:24:52.913] - queued futures: [n=2] TRUE, TRUE
[08:24:52.914] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:52.914]  length: 0 (resolved future 2)
[08:24:52.914] Relaying remaining futures
[08:24:52.914] signalConditionsASAP(NULL, pos=0) ...
[08:24:52.914] - nx: 2
[08:24:52.915] - relay: TRUE
[08:24:52.915] - stdout: TRUE
[08:24:52.915] - signal: TRUE
[08:24:52.915] - resignal: FALSE
[08:24:52.915] - force: TRUE
[08:24:52.915] - relayed: [n=2] TRUE, TRUE
[08:24:52.916] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:52.916] - relayed: [n=2] TRUE, TRUE
[08:24:52.916] - queued futures: [n=2] TRUE, TRUE
[08:24:52.916] signalConditionsASAP(NULL, pos=0) ... done
[08:24:52.916] resolve() on list ... DONE
[08:24:52.917] result() for MulticoreFuture ...
[08:24:52.917] result() for MulticoreFuture ... done
[08:24:52.917] result() for MulticoreFuture ...
[08:24:52.917] result() for MulticoreFuture ... done
[08:24:52.917] result() for MulticoreFuture ...
[08:24:52.917] result() for MulticoreFuture ... done
[08:24:52.917] result() for MulticoreFuture ...
[08:24:52.918] result() for MulticoreFuture ... done
[08:24:52.918]  - Number of value chunks collected: 2
[08:24:52.918] Resolving 2 futures (chunks) ... DONE
[08:24:52.918] Reducing values from 2 chunks ...
[08:24:52.918]  - Number of values collected after concatenation: 6
[08:24:52.918]  - Number of values expected: 6
[08:24:52.918] Reducing values from 2 chunks ... DONE
[08:24:52.918] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[08:24:52.919] getGlobalsAndPackagesXApply() ...
[08:24:52.919]  - future.globals: TRUE
[08:24:52.919] getGlobalsAndPackages() ...
[08:24:52.919] Searching for globals...
[08:24:52.921] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[08:24:52.921] Searching for globals ... DONE
[08:24:52.921] Resolving globals: FALSE
[08:24:52.922] The total size of the 1 globals is 411 bytes (411 bytes)
[08:24:52.922] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 411 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (411 bytes of class ‘function’)
[08:24:52.922] - globals: [1] ‘FUN’
[08:24:52.922] 
[08:24:52.923] getGlobalsAndPackages() ... DONE
[08:24:52.923]  - globals found/used: [n=1] ‘FUN’
[08:24:52.923]  - needed namespaces: [n=0] 
[08:24:52.923] Finding globals ... DONE
[08:24:52.923]  - use_args: TRUE
[08:24:52.923]  - Getting '...' globals ...
[08:24:52.924] resolve() on list ...
[08:24:52.924]  recursive: 0
[08:24:52.924]  length: 1
[08:24:52.924]  elements: ‘...’
[08:24:52.924]  length: 0 (resolved future 1)
[08:24:52.924] resolve() on list ... DONE
[08:24:52.924]    - '...' content: [n=0] 
[08:24:52.924] List of 1
[08:24:52.924]  $ ...: list()
[08:24:52.924]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.924]  - attr(*, "where")=List of 1
[08:24:52.924]   ..$ ...:<environment: 0x56540d3a0628> 
[08:24:52.924]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.924]  - attr(*, "resolved")= logi TRUE
[08:24:52.924]  - attr(*, "total_size")= num NA
[08:24:52.927]  - Getting '...' globals ... DONE
[08:24:52.928] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:52.928] List of 2
[08:24:52.928]  $ ...future.FUN:function (x)  
[08:24:52.928]  $ ...          : list()
[08:24:52.928]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.928]  - attr(*, "where")=List of 2
[08:24:52.928]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:52.928]   ..$ ...          :<environment: 0x56540d3a0628> 
[08:24:52.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.928]  - attr(*, "resolved")= logi FALSE
[08:24:52.928]  - attr(*, "total_size")= num 3672
[08:24:52.931] Packages to be attached in all futures: [n=0] 
[08:24:52.931] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.933] future_lapply() ...
[08:24:52.935] Number of chunks: 2
[08:24:52.935] getGlobalsAndPackagesXApply() ...
[08:24:52.935]  - future.globals: <name-value list> with names ‘list()’
[08:24:52.935]  - use_args: TRUE
[08:24:52.935] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:52.935] List of 2
[08:24:52.935]  $ ...          : list()
[08:24:52.935]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.935]  $ ...future.FUN:function (x)  
[08:24:52.935]  - attr(*, "where")=List of 2
[08:24:52.935]   ..$ ...          :<environment: 0x56540d3a0628> 
[08:24:52.935]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[08:24:52.935]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.935]  - attr(*, "resolved")= logi FALSE
[08:24:52.935]  - attr(*, "total_size")= num NA
[08:24:52.938] Packages to be attached in all futures: [n=0] 
[08:24:52.938] getGlobalsAndPackagesXApply() ... DONE
[08:24:52.938] Number of futures (= number of chunks): 2
[08:24:52.939] Launching 2 futures (chunks) ...
[08:24:52.939] Chunk #1 of 2 ...
[08:24:52.939]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.939]  - seeds: <none>
[08:24:52.941]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.941] getGlobalsAndPackages() ...
[08:24:52.941] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.942] Resolving globals: FALSE
[08:24:52.942] Tweak future expression to call with '...' arguments ...
[08:24:52.942] {
[08:24:52.942]     do.call(function(...) {
[08:24:52.942]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.942]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.942]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.942]             on.exit(options(oopts), add = TRUE)
[08:24:52.942]         }
[08:24:52.942]         {
[08:24:52.942]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.942]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.942]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.942]             })
[08:24:52.942]         }
[08:24:52.942]     }, args = future.call.arguments)
[08:24:52.942] }
[08:24:52.942] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.943] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.943] 
[08:24:52.943] getGlobalsAndPackages() ... DONE
[08:24:52.943] run() for ‘Future’ ...
[08:24:52.943] - state: ‘created’
[08:24:52.944] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.946] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.946] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.946]   - Field: ‘label’
[08:24:52.946]   - Field: ‘local’
[08:24:52.946]   - Field: ‘owner’
[08:24:52.946]   - Field: ‘envir’
[08:24:52.946]   - Field: ‘workers’
[08:24:52.946]   - Field: ‘packages’
[08:24:52.947]   - Field: ‘gc’
[08:24:52.947]   - Field: ‘job’
[08:24:52.947]   - Field: ‘conditions’
[08:24:52.947]   - Field: ‘expr’
[08:24:52.947]   - Field: ‘uuid’
[08:24:52.947]   - Field: ‘seed’
[08:24:52.947]   - Field: ‘version’
[08:24:52.947]   - Field: ‘result’
[08:24:52.947]   - Field: ‘asynchronous’
[08:24:52.947]   - Field: ‘calls’
[08:24:52.947]   - Field: ‘globals’
[08:24:52.948]   - Field: ‘stdout’
[08:24:52.948]   - Field: ‘earlySignal’
[08:24:52.948]   - Field: ‘lazy’
[08:24:52.948]   - Field: ‘state’
[08:24:52.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.948] - Launch lazy future ...
[08:24:52.948] Packages needed by the future expression (n = 0): <none>
[08:24:52.948] Packages needed by future strategies (n = 0): <none>
[08:24:52.949] {
[08:24:52.949]     {
[08:24:52.949]         {
[08:24:52.949]             ...future.startTime <- base::Sys.time()
[08:24:52.949]             {
[08:24:52.949]                 {
[08:24:52.949]                   {
[08:24:52.949]                     {
[08:24:52.949]                       base::local({
[08:24:52.949]                         has_future <- base::requireNamespace("future", 
[08:24:52.949]                           quietly = TRUE)
[08:24:52.949]                         if (has_future) {
[08:24:52.949]                           ns <- base::getNamespace("future")
[08:24:52.949]                           version <- ns[[".package"]][["version"]]
[08:24:52.949]                           if (is.null(version)) 
[08:24:52.949]                             version <- utils::packageVersion("future")
[08:24:52.949]                         }
[08:24:52.949]                         else {
[08:24:52.949]                           version <- NULL
[08:24:52.949]                         }
[08:24:52.949]                         if (!has_future || version < "1.8.0") {
[08:24:52.949]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.949]                             "", base::R.version$version.string), 
[08:24:52.949]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.949]                               "release", "version")], collapse = " "), 
[08:24:52.949]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.949]                             info)
[08:24:52.949]                           info <- base::paste(info, collapse = "; ")
[08:24:52.949]                           if (!has_future) {
[08:24:52.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.949]                               info)
[08:24:52.949]                           }
[08:24:52.949]                           else {
[08:24:52.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.949]                               info, version)
[08:24:52.949]                           }
[08:24:52.949]                           base::stop(msg)
[08:24:52.949]                         }
[08:24:52.949]                       })
[08:24:52.949]                     }
[08:24:52.949]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.949]                     base::options(mc.cores = 1L)
[08:24:52.949]                   }
[08:24:52.949]                   ...future.strategy.old <- future::plan("list")
[08:24:52.949]                   options(future.plan = NULL)
[08:24:52.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.949]                 }
[08:24:52.949]                 ...future.workdir <- getwd()
[08:24:52.949]             }
[08:24:52.949]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.949]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.949]         }
[08:24:52.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.949]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.949]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.949]             base::names(...future.oldOptions))
[08:24:52.949]     }
[08:24:52.949]     if (FALSE) {
[08:24:52.949]     }
[08:24:52.949]     else {
[08:24:52.949]         if (TRUE) {
[08:24:52.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.949]                 open = "w")
[08:24:52.949]         }
[08:24:52.949]         else {
[08:24:52.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.949]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.949]         }
[08:24:52.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.949]             base::sink(type = "output", split = FALSE)
[08:24:52.949]             base::close(...future.stdout)
[08:24:52.949]         }, add = TRUE)
[08:24:52.949]     }
[08:24:52.949]     ...future.frame <- base::sys.nframe()
[08:24:52.949]     ...future.conditions <- base::list()
[08:24:52.949]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.949]     if (FALSE) {
[08:24:52.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.949]     }
[08:24:52.949]     ...future.result <- base::tryCatch({
[08:24:52.949]         base::withCallingHandlers({
[08:24:52.949]             ...future.value <- base::withVisible(base::local({
[08:24:52.949]                 withCallingHandlers({
[08:24:52.949]                   {
[08:24:52.949]                     do.call(function(...) {
[08:24:52.949]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.949]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.949]                         ...future.globals.maxSize)) {
[08:24:52.949]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.949]                         on.exit(options(oopts), add = TRUE)
[08:24:52.949]                       }
[08:24:52.949]                       {
[08:24:52.949]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.949]                           FUN = function(jj) {
[08:24:52.949]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.949]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.949]                           })
[08:24:52.949]                       }
[08:24:52.949]                     }, args = future.call.arguments)
[08:24:52.949]                   }
[08:24:52.949]                 }, immediateCondition = function(cond) {
[08:24:52.949]                   save_rds <- function (object, pathname, ...) 
[08:24:52.949]                   {
[08:24:52.949]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.949]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.949]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.949]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.949]                         fi_tmp[["mtime"]])
[08:24:52.949]                     }
[08:24:52.949]                     tryCatch({
[08:24:52.949]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.949]                     }, error = function(ex) {
[08:24:52.949]                       msg <- conditionMessage(ex)
[08:24:52.949]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.949]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.949]                         fi_tmp[["mtime"]], msg)
[08:24:52.949]                       ex$message <- msg
[08:24:52.949]                       stop(ex)
[08:24:52.949]                     })
[08:24:52.949]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.949]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.949]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.949]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.949]                       fi <- file.info(pathname)
[08:24:52.949]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.949]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.949]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.949]                         fi[["size"]], fi[["mtime"]])
[08:24:52.949]                       stop(msg)
[08:24:52.949]                     }
[08:24:52.949]                     invisible(pathname)
[08:24:52.949]                   }
[08:24:52.949]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.949]                     rootPath = tempdir()) 
[08:24:52.949]                   {
[08:24:52.949]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.949]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.949]                       tmpdir = path, fileext = ".rds")
[08:24:52.949]                     save_rds(obj, file)
[08:24:52.949]                   }
[08:24:52.949]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.949]                   {
[08:24:52.949]                     inherits <- base::inherits
[08:24:52.949]                     invokeRestart <- base::invokeRestart
[08:24:52.949]                     is.null <- base::is.null
[08:24:52.949]                     muffled <- FALSE
[08:24:52.949]                     if (inherits(cond, "message")) {
[08:24:52.949]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.949]                       if (muffled) 
[08:24:52.949]                         invokeRestart("muffleMessage")
[08:24:52.949]                     }
[08:24:52.949]                     else if (inherits(cond, "warning")) {
[08:24:52.949]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.949]                       if (muffled) 
[08:24:52.949]                         invokeRestart("muffleWarning")
[08:24:52.949]                     }
[08:24:52.949]                     else if (inherits(cond, "condition")) {
[08:24:52.949]                       if (!is.null(pattern)) {
[08:24:52.949]                         computeRestarts <- base::computeRestarts
[08:24:52.949]                         grepl <- base::grepl
[08:24:52.949]                         restarts <- computeRestarts(cond)
[08:24:52.949]                         for (restart in restarts) {
[08:24:52.949]                           name <- restart$name
[08:24:52.949]                           if (is.null(name)) 
[08:24:52.949]                             next
[08:24:52.949]                           if (!grepl(pattern, name)) 
[08:24:52.949]                             next
[08:24:52.949]                           invokeRestart(restart)
[08:24:52.949]                           muffled <- TRUE
[08:24:52.949]                           break
[08:24:52.949]                         }
[08:24:52.949]                       }
[08:24:52.949]                     }
[08:24:52.949]                     invisible(muffled)
[08:24:52.949]                   }
[08:24:52.949]                   muffleCondition(cond)
[08:24:52.949]                 })
[08:24:52.949]             }))
[08:24:52.949]             future::FutureResult(value = ...future.value$value, 
[08:24:52.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.949]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.949]                     ...future.globalenv.names))
[08:24:52.949]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.949]         }, condition = base::local({
[08:24:52.949]             c <- base::c
[08:24:52.949]             inherits <- base::inherits
[08:24:52.949]             invokeRestart <- base::invokeRestart
[08:24:52.949]             length <- base::length
[08:24:52.949]             list <- base::list
[08:24:52.949]             seq.int <- base::seq.int
[08:24:52.949]             signalCondition <- base::signalCondition
[08:24:52.949]             sys.calls <- base::sys.calls
[08:24:52.949]             `[[` <- base::`[[`
[08:24:52.949]             `+` <- base::`+`
[08:24:52.949]             `<<-` <- base::`<<-`
[08:24:52.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.949]                   3L)]
[08:24:52.949]             }
[08:24:52.949]             function(cond) {
[08:24:52.949]                 is_error <- inherits(cond, "error")
[08:24:52.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.949]                   NULL)
[08:24:52.949]                 if (is_error) {
[08:24:52.949]                   sessionInformation <- function() {
[08:24:52.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.949]                       search = base::search(), system = base::Sys.info())
[08:24:52.949]                   }
[08:24:52.949]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.949]                     cond$call), session = sessionInformation(), 
[08:24:52.949]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.949]                   signalCondition(cond)
[08:24:52.949]                 }
[08:24:52.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.949]                 "immediateCondition"))) {
[08:24:52.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.949]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.949]                   if (TRUE && !signal) {
[08:24:52.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.949]                     {
[08:24:52.949]                       inherits <- base::inherits
[08:24:52.949]                       invokeRestart <- base::invokeRestart
[08:24:52.949]                       is.null <- base::is.null
[08:24:52.949]                       muffled <- FALSE
[08:24:52.949]                       if (inherits(cond, "message")) {
[08:24:52.949]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.949]                         if (muffled) 
[08:24:52.949]                           invokeRestart("muffleMessage")
[08:24:52.949]                       }
[08:24:52.949]                       else if (inherits(cond, "warning")) {
[08:24:52.949]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.949]                         if (muffled) 
[08:24:52.949]                           invokeRestart("muffleWarning")
[08:24:52.949]                       }
[08:24:52.949]                       else if (inherits(cond, "condition")) {
[08:24:52.949]                         if (!is.null(pattern)) {
[08:24:52.949]                           computeRestarts <- base::computeRestarts
[08:24:52.949]                           grepl <- base::grepl
[08:24:52.949]                           restarts <- computeRestarts(cond)
[08:24:52.949]                           for (restart in restarts) {
[08:24:52.949]                             name <- restart$name
[08:24:52.949]                             if (is.null(name)) 
[08:24:52.949]                               next
[08:24:52.949]                             if (!grepl(pattern, name)) 
[08:24:52.949]                               next
[08:24:52.949]                             invokeRestart(restart)
[08:24:52.949]                             muffled <- TRUE
[08:24:52.949]                             break
[08:24:52.949]                           }
[08:24:52.949]                         }
[08:24:52.949]                       }
[08:24:52.949]                       invisible(muffled)
[08:24:52.949]                     }
[08:24:52.949]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.949]                   }
[08:24:52.949]                 }
[08:24:52.949]                 else {
[08:24:52.949]                   if (TRUE) {
[08:24:52.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.949]                     {
[08:24:52.949]                       inherits <- base::inherits
[08:24:52.949]                       invokeRestart <- base::invokeRestart
[08:24:52.949]                       is.null <- base::is.null
[08:24:52.949]                       muffled <- FALSE
[08:24:52.949]                       if (inherits(cond, "message")) {
[08:24:52.949]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.949]                         if (muffled) 
[08:24:52.949]                           invokeRestart("muffleMessage")
[08:24:52.949]                       }
[08:24:52.949]                       else if (inherits(cond, "warning")) {
[08:24:52.949]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.949]                         if (muffled) 
[08:24:52.949]                           invokeRestart("muffleWarning")
[08:24:52.949]                       }
[08:24:52.949]                       else if (inherits(cond, "condition")) {
[08:24:52.949]                         if (!is.null(pattern)) {
[08:24:52.949]                           computeRestarts <- base::computeRestarts
[08:24:52.949]                           grepl <- base::grepl
[08:24:52.949]                           restarts <- computeRestarts(cond)
[08:24:52.949]                           for (restart in restarts) {
[08:24:52.949]                             name <- restart$name
[08:24:52.949]                             if (is.null(name)) 
[08:24:52.949]                               next
[08:24:52.949]                             if (!grepl(pattern, name)) 
[08:24:52.949]                               next
[08:24:52.949]                             invokeRestart(restart)
[08:24:52.949]                             muffled <- TRUE
[08:24:52.949]                             break
[08:24:52.949]                           }
[08:24:52.949]                         }
[08:24:52.949]                       }
[08:24:52.949]                       invisible(muffled)
[08:24:52.949]                     }
[08:24:52.949]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.949]                   }
[08:24:52.949]                 }
[08:24:52.949]             }
[08:24:52.949]         }))
[08:24:52.949]     }, error = function(ex) {
[08:24:52.949]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.949]                 ...future.rng), started = ...future.startTime, 
[08:24:52.949]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.949]             version = "1.8"), class = "FutureResult")
[08:24:52.949]     }, finally = {
[08:24:52.949]         if (!identical(...future.workdir, getwd())) 
[08:24:52.949]             setwd(...future.workdir)
[08:24:52.949]         {
[08:24:52.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.949]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.949]             }
[08:24:52.949]             base::options(...future.oldOptions)
[08:24:52.949]             if (.Platform$OS.type == "windows") {
[08:24:52.949]                 old_names <- names(...future.oldEnvVars)
[08:24:52.949]                 envs <- base::Sys.getenv()
[08:24:52.949]                 names <- names(envs)
[08:24:52.949]                 common <- intersect(names, old_names)
[08:24:52.949]                 added <- setdiff(names, old_names)
[08:24:52.949]                 removed <- setdiff(old_names, names)
[08:24:52.949]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.949]                   envs[common]]
[08:24:52.949]                 NAMES <- toupper(changed)
[08:24:52.949]                 args <- list()
[08:24:52.949]                 for (kk in seq_along(NAMES)) {
[08:24:52.949]                   name <- changed[[kk]]
[08:24:52.949]                   NAME <- NAMES[[kk]]
[08:24:52.949]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.949]                     next
[08:24:52.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.949]                 }
[08:24:52.949]                 NAMES <- toupper(added)
[08:24:52.949]                 for (kk in seq_along(NAMES)) {
[08:24:52.949]                   name <- added[[kk]]
[08:24:52.949]                   NAME <- NAMES[[kk]]
[08:24:52.949]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.949]                     next
[08:24:52.949]                   args[[name]] <- ""
[08:24:52.949]                 }
[08:24:52.949]                 NAMES <- toupper(removed)
[08:24:52.949]                 for (kk in seq_along(NAMES)) {
[08:24:52.949]                   name <- removed[[kk]]
[08:24:52.949]                   NAME <- NAMES[[kk]]
[08:24:52.949]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.949]                     next
[08:24:52.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.949]                 }
[08:24:52.949]                 if (length(args) > 0) 
[08:24:52.949]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.949]             }
[08:24:52.949]             else {
[08:24:52.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.949]             }
[08:24:52.949]             {
[08:24:52.949]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.949]                   0L) {
[08:24:52.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.949]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.949]                   base::options(opts)
[08:24:52.949]                 }
[08:24:52.949]                 {
[08:24:52.949]                   {
[08:24:52.949]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.949]                     NULL
[08:24:52.949]                   }
[08:24:52.949]                   options(future.plan = NULL)
[08:24:52.949]                   if (is.na(NA_character_)) 
[08:24:52.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.949]                     .init = FALSE)
[08:24:52.949]                 }
[08:24:52.949]             }
[08:24:52.949]         }
[08:24:52.949]     })
[08:24:52.949]     if (TRUE) {
[08:24:52.949]         base::sink(type = "output", split = FALSE)
[08:24:52.949]         if (TRUE) {
[08:24:52.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.949]         }
[08:24:52.949]         else {
[08:24:52.949]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.949]         }
[08:24:52.949]         base::close(...future.stdout)
[08:24:52.949]         ...future.stdout <- NULL
[08:24:52.949]     }
[08:24:52.949]     ...future.result$conditions <- ...future.conditions
[08:24:52.949]     ...future.result$finished <- base::Sys.time()
[08:24:52.949]     ...future.result
[08:24:52.949] }
[08:24:52.951] assign_globals() ...
[08:24:52.952] List of 5
[08:24:52.952]  $ future.call.arguments    : list()
[08:24:52.952]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.952]  $ ...future.FUN            :function (x)  
[08:24:52.952]  $ ...future.elements_ii    :List of 3
[08:24:52.952]   ..$ : int [1:4] 1 7 13 19
[08:24:52.952]   ..$ : int [1:4] 2 8 14 20
[08:24:52.952]   ..$ : int [1:4] 3 9 15 21
[08:24:52.952]  $ ...future.seeds_ii       : NULL
[08:24:52.952]  $ ...future.globals.maxSize: num Inf
[08:24:52.952]  - attr(*, "resolved")= logi FALSE
[08:24:52.952]  - attr(*, "total_size")= num NA
[08:24:52.952]  - attr(*, "where")=List of 5
[08:24:52.952]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.952]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.952]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.952]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.952]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.952]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.952]  - attr(*, "already-done")= logi TRUE
[08:24:52.957] - copied ‘future.call.arguments’ to environment
[08:24:52.957] - reassign environment for ‘...future.FUN’
[08:24:52.957] - copied ‘...future.FUN’ to environment
[08:24:52.957] - copied ‘...future.elements_ii’ to environment
[08:24:52.957] - copied ‘...future.seeds_ii’ to environment
[08:24:52.958] - copied ‘...future.globals.maxSize’ to environment
[08:24:52.958] assign_globals() ... done
[08:24:52.958] requestCore(): workers = 2
[08:24:52.960] MulticoreFuture started
[08:24:52.961] - Launch lazy future ... done
[08:24:52.961] run() for ‘MulticoreFuture’ ... done
[08:24:52.961] Created future:
[08:24:52.961] plan(): Setting new future strategy stack:
[08:24:52.961] List of future strategies:
[08:24:52.961] 1. sequential:
[08:24:52.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:52.961]    - tweaked: FALSE
[08:24:52.961]    - call: NULL
[08:24:52.962] plan(): nbrOfWorkers() = 1
[08:24:52.965] plan(): Setting new future strategy stack:
[08:24:52.965] List of future strategies:
[08:24:52.965] 1. multicore:
[08:24:52.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:52.965]    - tweaked: FALSE
[08:24:52.965]    - call: plan(strategy)
[08:24:52.968] plan(): nbrOfWorkers() = 2
[08:24:52.961] MulticoreFuture:
[08:24:52.961] Label: ‘future_apply-1’
[08:24:52.961] Expression:
[08:24:52.961] {
[08:24:52.961]     do.call(function(...) {
[08:24:52.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.961]             on.exit(options(oopts), add = TRUE)
[08:24:52.961]         }
[08:24:52.961]         {
[08:24:52.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.961]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.961]             })
[08:24:52.961]         }
[08:24:52.961]     }, args = future.call.arguments)
[08:24:52.961] }
[08:24:52.961] Lazy evaluation: FALSE
[08:24:52.961] Asynchronous evaluation: TRUE
[08:24:52.961] Local evaluation: TRUE
[08:24:52.961] Environment: R_GlobalEnv
[08:24:52.961] Capture standard output: TRUE
[08:24:52.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:52.961] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:52.961] Packages: <none>
[08:24:52.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:52.961] Resolved: TRUE
[08:24:52.961] Value: <not collected>
[08:24:52.961] Conditions captured: <none>
[08:24:52.961] Early signaling: FALSE
[08:24:52.961] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:52.961] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.969] Chunk #1 of 2 ... DONE
[08:24:52.970] Chunk #2 of 2 ...
[08:24:52.970]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:52.970]  - seeds: <none>
[08:24:52.970]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.970] getGlobalsAndPackages() ...
[08:24:52.971] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.971] Resolving globals: FALSE
[08:24:52.971] Tweak future expression to call with '...' arguments ...
[08:24:52.971] {
[08:24:52.971]     do.call(function(...) {
[08:24:52.971]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.971]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:52.971]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.971]             on.exit(options(oopts), add = TRUE)
[08:24:52.971]         }
[08:24:52.971]         {
[08:24:52.971]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:52.971]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.971]                 ...future.FUN(...future.X_jj, ...)
[08:24:52.971]             })
[08:24:52.971]         }
[08:24:52.971]     }, args = future.call.arguments)
[08:24:52.971] }
[08:24:52.971] Tweak future expression to call with '...' arguments ... DONE
[08:24:52.972] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:52.972] 
[08:24:52.972] getGlobalsAndPackages() ... DONE
[08:24:52.973] run() for ‘Future’ ...
[08:24:52.973] - state: ‘created’
[08:24:52.973] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:52.976] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:52.976] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:52.977]   - Field: ‘label’
[08:24:52.977]   - Field: ‘local’
[08:24:52.977]   - Field: ‘owner’
[08:24:52.977]   - Field: ‘envir’
[08:24:52.977]   - Field: ‘workers’
[08:24:52.977]   - Field: ‘packages’
[08:24:52.977]   - Field: ‘gc’
[08:24:52.978]   - Field: ‘job’
[08:24:52.978]   - Field: ‘conditions’
[08:24:52.978]   - Field: ‘expr’
[08:24:52.978]   - Field: ‘uuid’
[08:24:52.978]   - Field: ‘seed’
[08:24:52.978]   - Field: ‘version’
[08:24:52.978]   - Field: ‘result’
[08:24:52.978]   - Field: ‘asynchronous’
[08:24:52.979]   - Field: ‘calls’
[08:24:52.979]   - Field: ‘globals’
[08:24:52.979]   - Field: ‘stdout’
[08:24:52.979]   - Field: ‘earlySignal’
[08:24:52.979]   - Field: ‘lazy’
[08:24:52.979]   - Field: ‘state’
[08:24:52.979] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:52.980] - Launch lazy future ...
[08:24:52.983] Packages needed by the future expression (n = 0): <none>
[08:24:52.984] Packages needed by future strategies (n = 0): <none>
[08:24:52.986] {
[08:24:52.986]     {
[08:24:52.986]         {
[08:24:52.986]             ...future.startTime <- base::Sys.time()
[08:24:52.986]             {
[08:24:52.986]                 {
[08:24:52.986]                   {
[08:24:52.986]                     {
[08:24:52.986]                       base::local({
[08:24:52.986]                         has_future <- base::requireNamespace("future", 
[08:24:52.986]                           quietly = TRUE)
[08:24:52.986]                         if (has_future) {
[08:24:52.986]                           ns <- base::getNamespace("future")
[08:24:52.986]                           version <- ns[[".package"]][["version"]]
[08:24:52.986]                           if (is.null(version)) 
[08:24:52.986]                             version <- utils::packageVersion("future")
[08:24:52.986]                         }
[08:24:52.986]                         else {
[08:24:52.986]                           version <- NULL
[08:24:52.986]                         }
[08:24:52.986]                         if (!has_future || version < "1.8.0") {
[08:24:52.986]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:52.986]                             "", base::R.version$version.string), 
[08:24:52.986]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:52.986]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:52.986]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:52.986]                               "release", "version")], collapse = " "), 
[08:24:52.986]                             hostname = base::Sys.info()[["nodename"]])
[08:24:52.986]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:52.986]                             info)
[08:24:52.986]                           info <- base::paste(info, collapse = "; ")
[08:24:52.986]                           if (!has_future) {
[08:24:52.986]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:52.986]                               info)
[08:24:52.986]                           }
[08:24:52.986]                           else {
[08:24:52.986]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:52.986]                               info, version)
[08:24:52.986]                           }
[08:24:52.986]                           base::stop(msg)
[08:24:52.986]                         }
[08:24:52.986]                       })
[08:24:52.986]                     }
[08:24:52.986]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:52.986]                     base::options(mc.cores = 1L)
[08:24:52.986]                   }
[08:24:52.986]                   ...future.strategy.old <- future::plan("list")
[08:24:52.986]                   options(future.plan = NULL)
[08:24:52.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:52.986]                 }
[08:24:52.986]                 ...future.workdir <- getwd()
[08:24:52.986]             }
[08:24:52.986]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:52.986]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:52.986]         }
[08:24:52.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:52.986]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:52.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:52.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:52.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:52.986]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:52.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:52.986]             base::names(...future.oldOptions))
[08:24:52.986]     }
[08:24:52.986]     if (FALSE) {
[08:24:52.986]     }
[08:24:52.986]     else {
[08:24:52.986]         if (TRUE) {
[08:24:52.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:52.986]                 open = "w")
[08:24:52.986]         }
[08:24:52.986]         else {
[08:24:52.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:52.986]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:52.986]         }
[08:24:52.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:52.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:52.986]             base::sink(type = "output", split = FALSE)
[08:24:52.986]             base::close(...future.stdout)
[08:24:52.986]         }, add = TRUE)
[08:24:52.986]     }
[08:24:52.986]     ...future.frame <- base::sys.nframe()
[08:24:52.986]     ...future.conditions <- base::list()
[08:24:52.986]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:52.986]     if (FALSE) {
[08:24:52.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:52.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:52.986]     }
[08:24:52.986]     ...future.result <- base::tryCatch({
[08:24:52.986]         base::withCallingHandlers({
[08:24:52.986]             ...future.value <- base::withVisible(base::local({
[08:24:52.986]                 withCallingHandlers({
[08:24:52.986]                   {
[08:24:52.986]                     do.call(function(...) {
[08:24:52.986]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:52.986]                       if (!identical(...future.globals.maxSize.org, 
[08:24:52.986]                         ...future.globals.maxSize)) {
[08:24:52.986]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:52.986]                         on.exit(options(oopts), add = TRUE)
[08:24:52.986]                       }
[08:24:52.986]                       {
[08:24:52.986]                         lapply(seq_along(...future.elements_ii), 
[08:24:52.986]                           FUN = function(jj) {
[08:24:52.986]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:52.986]                             ...future.FUN(...future.X_jj, ...)
[08:24:52.986]                           })
[08:24:52.986]                       }
[08:24:52.986]                     }, args = future.call.arguments)
[08:24:52.986]                   }
[08:24:52.986]                 }, immediateCondition = function(cond) {
[08:24:52.986]                   save_rds <- function (object, pathname, ...) 
[08:24:52.986]                   {
[08:24:52.986]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:52.986]                     if (file_test("-f", pathname_tmp)) {
[08:24:52.986]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.986]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:52.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.986]                         fi_tmp[["mtime"]])
[08:24:52.986]                     }
[08:24:52.986]                     tryCatch({
[08:24:52.986]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:52.986]                     }, error = function(ex) {
[08:24:52.986]                       msg <- conditionMessage(ex)
[08:24:52.986]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.986]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:52.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.986]                         fi_tmp[["mtime"]], msg)
[08:24:52.986]                       ex$message <- msg
[08:24:52.986]                       stop(ex)
[08:24:52.986]                     })
[08:24:52.986]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:52.986]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:52.986]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:52.986]                       fi_tmp <- file.info(pathname_tmp)
[08:24:52.986]                       fi <- file.info(pathname)
[08:24:52.986]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:52.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:52.986]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:52.986]                         fi[["size"]], fi[["mtime"]])
[08:24:52.986]                       stop(msg)
[08:24:52.986]                     }
[08:24:52.986]                     invisible(pathname)
[08:24:52.986]                   }
[08:24:52.986]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:52.986]                     rootPath = tempdir()) 
[08:24:52.986]                   {
[08:24:52.986]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:52.986]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:52.986]                       tmpdir = path, fileext = ".rds")
[08:24:52.986]                     save_rds(obj, file)
[08:24:52.986]                   }
[08:24:52.986]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:52.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.986]                   {
[08:24:52.986]                     inherits <- base::inherits
[08:24:52.986]                     invokeRestart <- base::invokeRestart
[08:24:52.986]                     is.null <- base::is.null
[08:24:52.986]                     muffled <- FALSE
[08:24:52.986]                     if (inherits(cond, "message")) {
[08:24:52.986]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:52.986]                       if (muffled) 
[08:24:52.986]                         invokeRestart("muffleMessage")
[08:24:52.986]                     }
[08:24:52.986]                     else if (inherits(cond, "warning")) {
[08:24:52.986]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:52.986]                       if (muffled) 
[08:24:52.986]                         invokeRestart("muffleWarning")
[08:24:52.986]                     }
[08:24:52.986]                     else if (inherits(cond, "condition")) {
[08:24:52.986]                       if (!is.null(pattern)) {
[08:24:52.986]                         computeRestarts <- base::computeRestarts
[08:24:52.986]                         grepl <- base::grepl
[08:24:52.986]                         restarts <- computeRestarts(cond)
[08:24:52.986]                         for (restart in restarts) {
[08:24:52.986]                           name <- restart$name
[08:24:52.986]                           if (is.null(name)) 
[08:24:52.986]                             next
[08:24:52.986]                           if (!grepl(pattern, name)) 
[08:24:52.986]                             next
[08:24:52.986]                           invokeRestart(restart)
[08:24:52.986]                           muffled <- TRUE
[08:24:52.986]                           break
[08:24:52.986]                         }
[08:24:52.986]                       }
[08:24:52.986]                     }
[08:24:52.986]                     invisible(muffled)
[08:24:52.986]                   }
[08:24:52.986]                   muffleCondition(cond)
[08:24:52.986]                 })
[08:24:52.986]             }))
[08:24:52.986]             future::FutureResult(value = ...future.value$value, 
[08:24:52.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.986]                   ...future.rng), globalenv = if (FALSE) 
[08:24:52.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:52.986]                     ...future.globalenv.names))
[08:24:52.986]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:52.986]         }, condition = base::local({
[08:24:52.986]             c <- base::c
[08:24:52.986]             inherits <- base::inherits
[08:24:52.986]             invokeRestart <- base::invokeRestart
[08:24:52.986]             length <- base::length
[08:24:52.986]             list <- base::list
[08:24:52.986]             seq.int <- base::seq.int
[08:24:52.986]             signalCondition <- base::signalCondition
[08:24:52.986]             sys.calls <- base::sys.calls
[08:24:52.986]             `[[` <- base::`[[`
[08:24:52.986]             `+` <- base::`+`
[08:24:52.986]             `<<-` <- base::`<<-`
[08:24:52.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:52.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:52.986]                   3L)]
[08:24:52.986]             }
[08:24:52.986]             function(cond) {
[08:24:52.986]                 is_error <- inherits(cond, "error")
[08:24:52.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:52.986]                   NULL)
[08:24:52.986]                 if (is_error) {
[08:24:52.986]                   sessionInformation <- function() {
[08:24:52.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:52.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:52.986]                       search = base::search(), system = base::Sys.info())
[08:24:52.986]                   }
[08:24:52.986]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:52.986]                     cond$call), session = sessionInformation(), 
[08:24:52.986]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:52.986]                   signalCondition(cond)
[08:24:52.986]                 }
[08:24:52.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:52.986]                 "immediateCondition"))) {
[08:24:52.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:52.986]                   ...future.conditions[[length(...future.conditions) + 
[08:24:52.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:52.986]                   if (TRUE && !signal) {
[08:24:52.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.986]                     {
[08:24:52.986]                       inherits <- base::inherits
[08:24:52.986]                       invokeRestart <- base::invokeRestart
[08:24:52.986]                       is.null <- base::is.null
[08:24:52.986]                       muffled <- FALSE
[08:24:52.986]                       if (inherits(cond, "message")) {
[08:24:52.986]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.986]                         if (muffled) 
[08:24:52.986]                           invokeRestart("muffleMessage")
[08:24:52.986]                       }
[08:24:52.986]                       else if (inherits(cond, "warning")) {
[08:24:52.986]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.986]                         if (muffled) 
[08:24:52.986]                           invokeRestart("muffleWarning")
[08:24:52.986]                       }
[08:24:52.986]                       else if (inherits(cond, "condition")) {
[08:24:52.986]                         if (!is.null(pattern)) {
[08:24:52.986]                           computeRestarts <- base::computeRestarts
[08:24:52.986]                           grepl <- base::grepl
[08:24:52.986]                           restarts <- computeRestarts(cond)
[08:24:52.986]                           for (restart in restarts) {
[08:24:52.986]                             name <- restart$name
[08:24:52.986]                             if (is.null(name)) 
[08:24:52.986]                               next
[08:24:52.986]                             if (!grepl(pattern, name)) 
[08:24:52.986]                               next
[08:24:52.986]                             invokeRestart(restart)
[08:24:52.986]                             muffled <- TRUE
[08:24:52.986]                             break
[08:24:52.986]                           }
[08:24:52.986]                         }
[08:24:52.986]                       }
[08:24:52.986]                       invisible(muffled)
[08:24:52.986]                     }
[08:24:52.986]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.986]                   }
[08:24:52.986]                 }
[08:24:52.986]                 else {
[08:24:52.986]                   if (TRUE) {
[08:24:52.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:52.986]                     {
[08:24:52.986]                       inherits <- base::inherits
[08:24:52.986]                       invokeRestart <- base::invokeRestart
[08:24:52.986]                       is.null <- base::is.null
[08:24:52.986]                       muffled <- FALSE
[08:24:52.986]                       if (inherits(cond, "message")) {
[08:24:52.986]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:52.986]                         if (muffled) 
[08:24:52.986]                           invokeRestart("muffleMessage")
[08:24:52.986]                       }
[08:24:52.986]                       else if (inherits(cond, "warning")) {
[08:24:52.986]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:52.986]                         if (muffled) 
[08:24:52.986]                           invokeRestart("muffleWarning")
[08:24:52.986]                       }
[08:24:52.986]                       else if (inherits(cond, "condition")) {
[08:24:52.986]                         if (!is.null(pattern)) {
[08:24:52.986]                           computeRestarts <- base::computeRestarts
[08:24:52.986]                           grepl <- base::grepl
[08:24:52.986]                           restarts <- computeRestarts(cond)
[08:24:52.986]                           for (restart in restarts) {
[08:24:52.986]                             name <- restart$name
[08:24:52.986]                             if (is.null(name)) 
[08:24:52.986]                               next
[08:24:52.986]                             if (!grepl(pattern, name)) 
[08:24:52.986]                               next
[08:24:52.986]                             invokeRestart(restart)
[08:24:52.986]                             muffled <- TRUE
[08:24:52.986]                             break
[08:24:52.986]                           }
[08:24:52.986]                         }
[08:24:52.986]                       }
[08:24:52.986]                       invisible(muffled)
[08:24:52.986]                     }
[08:24:52.986]                     muffleCondition(cond, pattern = "^muffle")
[08:24:52.986]                   }
[08:24:52.986]                 }
[08:24:52.986]             }
[08:24:52.986]         }))
[08:24:52.986]     }, error = function(ex) {
[08:24:52.986]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:52.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:52.986]                 ...future.rng), started = ...future.startTime, 
[08:24:52.986]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:52.986]             version = "1.8"), class = "FutureResult")
[08:24:52.986]     }, finally = {
[08:24:52.986]         if (!identical(...future.workdir, getwd())) 
[08:24:52.986]             setwd(...future.workdir)
[08:24:52.986]         {
[08:24:52.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:52.986]                 ...future.oldOptions$nwarnings <- NULL
[08:24:52.986]             }
[08:24:52.986]             base::options(...future.oldOptions)
[08:24:52.986]             if (.Platform$OS.type == "windows") {
[08:24:52.986]                 old_names <- names(...future.oldEnvVars)
[08:24:52.986]                 envs <- base::Sys.getenv()
[08:24:52.986]                 names <- names(envs)
[08:24:52.986]                 common <- intersect(names, old_names)
[08:24:52.986]                 added <- setdiff(names, old_names)
[08:24:52.986]                 removed <- setdiff(old_names, names)
[08:24:52.986]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:52.986]                   envs[common]]
[08:24:52.986]                 NAMES <- toupper(changed)
[08:24:52.986]                 args <- list()
[08:24:52.986]                 for (kk in seq_along(NAMES)) {
[08:24:52.986]                   name <- changed[[kk]]
[08:24:52.986]                   NAME <- NAMES[[kk]]
[08:24:52.986]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.986]                     next
[08:24:52.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.986]                 }
[08:24:52.986]                 NAMES <- toupper(added)
[08:24:52.986]                 for (kk in seq_along(NAMES)) {
[08:24:52.986]                   name <- added[[kk]]
[08:24:52.986]                   NAME <- NAMES[[kk]]
[08:24:52.986]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.986]                     next
[08:24:52.986]                   args[[name]] <- ""
[08:24:52.986]                 }
[08:24:52.986]                 NAMES <- toupper(removed)
[08:24:52.986]                 for (kk in seq_along(NAMES)) {
[08:24:52.986]                   name <- removed[[kk]]
[08:24:52.986]                   NAME <- NAMES[[kk]]
[08:24:52.986]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:52.986]                     next
[08:24:52.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:52.986]                 }
[08:24:52.986]                 if (length(args) > 0) 
[08:24:52.986]                   base::do.call(base::Sys.setenv, args = args)
[08:24:52.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:52.986]             }
[08:24:52.986]             else {
[08:24:52.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:52.986]             }
[08:24:52.986]             {
[08:24:52.986]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:52.986]                   0L) {
[08:24:52.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:52.986]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:52.986]                   base::options(opts)
[08:24:52.986]                 }
[08:24:52.986]                 {
[08:24:52.986]                   {
[08:24:52.986]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:52.986]                     NULL
[08:24:52.986]                   }
[08:24:52.986]                   options(future.plan = NULL)
[08:24:52.986]                   if (is.na(NA_character_)) 
[08:24:52.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:52.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:52.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:52.986]                     .init = FALSE)
[08:24:52.986]                 }
[08:24:52.986]             }
[08:24:52.986]         }
[08:24:52.986]     })
[08:24:52.986]     if (TRUE) {
[08:24:52.986]         base::sink(type = "output", split = FALSE)
[08:24:52.986]         if (TRUE) {
[08:24:52.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:52.986]         }
[08:24:52.986]         else {
[08:24:52.986]             ...future.result["stdout"] <- base::list(NULL)
[08:24:52.986]         }
[08:24:52.986]         base::close(...future.stdout)
[08:24:52.986]         ...future.stdout <- NULL
[08:24:52.986]     }
[08:24:52.986]     ...future.result$conditions <- ...future.conditions
[08:24:52.986]     ...future.result$finished <- base::Sys.time()
[08:24:52.986]     ...future.result
[08:24:52.986] }
[08:24:52.989] assign_globals() ...
[08:24:52.989] List of 5
[08:24:52.989]  $ future.call.arguments    : list()
[08:24:52.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:52.989]  $ ...future.FUN            :function (x)  
[08:24:52.989]  $ ...future.elements_ii    :List of 3
[08:24:52.989]   ..$ : int [1:4] 4 10 16 22
[08:24:52.989]   ..$ : int [1:4] 5 11 17 23
[08:24:52.989]   ..$ : int [1:4] 6 12 18 24
[08:24:52.989]  $ ...future.seeds_ii       : NULL
[08:24:52.989]  $ ...future.globals.maxSize: num Inf
[08:24:52.989]  - attr(*, "resolved")= logi FALSE
[08:24:52.989]  - attr(*, "total_size")= num NA
[08:24:52.989]  - attr(*, "where")=List of 5
[08:24:52.989]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:52.989]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:52.989]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:52.989]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:52.989]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:52.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:52.989]  - attr(*, "already-done")= logi TRUE
[08:24:53.000] - copied ‘future.call.arguments’ to environment
[08:24:53.000] - reassign environment for ‘...future.FUN’
[08:24:53.000] - copied ‘...future.FUN’ to environment
[08:24:53.000] - copied ‘...future.elements_ii’ to environment
[08:24:53.000] - copied ‘...future.seeds_ii’ to environment
[08:24:53.000] - copied ‘...future.globals.maxSize’ to environment
[08:24:53.000] assign_globals() ... done
[08:24:53.001] requestCore(): workers = 2
[08:24:53.003] MulticoreFuture started
[08:24:53.004] - Launch lazy future ... done
[08:24:53.004] run() for ‘MulticoreFuture’ ... done
[08:24:53.004] Created future:
[08:24:53.005] plan(): Setting new future strategy stack:
[08:24:53.005] List of future strategies:
[08:24:53.005] 1. sequential:
[08:24:53.005]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.005]    - tweaked: FALSE
[08:24:53.005]    - call: NULL
[08:24:53.006] plan(): nbrOfWorkers() = 1
[08:24:53.008] plan(): Setting new future strategy stack:
[08:24:53.008] List of future strategies:
[08:24:53.008] 1. multicore:
[08:24:53.008]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:53.008]    - tweaked: FALSE
[08:24:53.008]    - call: plan(strategy)
[08:24:53.012] plan(): nbrOfWorkers() = 2
[08:24:53.005] MulticoreFuture:
[08:24:53.005] Label: ‘future_apply-2’
[08:24:53.005] Expression:
[08:24:53.005] {
[08:24:53.005]     do.call(function(...) {
[08:24:53.005]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.005]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.005]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.005]             on.exit(options(oopts), add = TRUE)
[08:24:53.005]         }
[08:24:53.005]         {
[08:24:53.005]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.005]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.005]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.005]             })
[08:24:53.005]         }
[08:24:53.005]     }, args = future.call.arguments)
[08:24:53.005] }
[08:24:53.005] Lazy evaluation: FALSE
[08:24:53.005] Asynchronous evaluation: TRUE
[08:24:53.005] Local evaluation: TRUE
[08:24:53.005] Environment: R_GlobalEnv
[08:24:53.005] Capture standard output: TRUE
[08:24:53.005] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:53.005] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:53.005] Packages: <none>
[08:24:53.005] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:53.005] Resolved: TRUE
[08:24:53.005] Value: <not collected>
[08:24:53.005] Conditions captured: <none>
[08:24:53.005] Early signaling: FALSE
[08:24:53.005] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:53.005] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.013] Chunk #2 of 2 ... DONE
[08:24:53.013] Launching 2 futures (chunks) ... DONE
[08:24:53.013] Resolving 2 futures (chunks) ...
[08:24:53.013] resolve() on list ...
[08:24:53.013]  recursive: 0
[08:24:53.013]  length: 2
[08:24:53.014] 
[08:24:53.014] Future #1
[08:24:53.014] result() for MulticoreFuture ...
[08:24:53.015] result() for MulticoreFuture ...
[08:24:53.015] result() for MulticoreFuture ... done
[08:24:53.015] result() for MulticoreFuture ... done
[08:24:53.016] result() for MulticoreFuture ...
[08:24:53.016] result() for MulticoreFuture ... done
[08:24:53.016] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:53.016] - nx: 2
[08:24:53.016] - relay: TRUE
[08:24:53.016] - stdout: TRUE
[08:24:53.016] - signal: TRUE
[08:24:53.017] - resignal: FALSE
[08:24:53.017] - force: TRUE
[08:24:53.017] - relayed: [n=2] FALSE, FALSE
[08:24:53.017] - queued futures: [n=2] FALSE, FALSE
[08:24:53.017]  - until=1
[08:24:53.017]  - relaying element #1
[08:24:53.017] result() for MulticoreFuture ...
[08:24:53.018] result() for MulticoreFuture ... done
[08:24:53.018] result() for MulticoreFuture ...
[08:24:53.018] result() for MulticoreFuture ... done
[08:24:53.018] result() for MulticoreFuture ...
[08:24:53.018] result() for MulticoreFuture ... done
[08:24:53.018] result() for MulticoreFuture ...
[08:24:53.019] result() for MulticoreFuture ... done
[08:24:53.019] - relayed: [n=2] TRUE, FALSE
[08:24:53.019] - queued futures: [n=2] TRUE, FALSE
[08:24:53.019] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:53.019]  length: 1 (resolved future 1)
[08:24:53.020] Future #2
[08:24:53.020] result() for MulticoreFuture ...
[08:24:53.020] result() for MulticoreFuture ...
[08:24:53.021] result() for MulticoreFuture ... done
[08:24:53.021] result() for MulticoreFuture ... done
[08:24:53.021] result() for MulticoreFuture ...
[08:24:53.021] result() for MulticoreFuture ... done
[08:24:53.021] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:53.021] - nx: 2
[08:24:53.022] - relay: TRUE
[08:24:53.022] - stdout: TRUE
[08:24:53.022] - signal: TRUE
[08:24:53.022] - resignal: FALSE
[08:24:53.022] - force: TRUE
[08:24:53.022] - relayed: [n=2] TRUE, FALSE
[08:24:53.022] - queued futures: [n=2] TRUE, FALSE
[08:24:53.023]  - until=2
[08:24:53.023]  - relaying element #2
[08:24:53.023] result() for MulticoreFuture ...
[08:24:53.023] result() for MulticoreFuture ... done
[08:24:53.023] result() for MulticoreFuture ...
[08:24:53.023] result() for MulticoreFuture ... done
[08:24:53.023] result() for MulticoreFuture ...
[08:24:53.024] result() for MulticoreFuture ... done
[08:24:53.024] result() for MulticoreFuture ...
[08:24:53.024] result() for MulticoreFuture ... done
[08:24:53.024] - relayed: [n=2] TRUE, TRUE
[08:24:53.024] - queued futures: [n=2] TRUE, TRUE
[08:24:53.024] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:53.024]  length: 0 (resolved future 2)
[08:24:53.024] Relaying remaining futures
[08:24:53.024] signalConditionsASAP(NULL, pos=0) ...
[08:24:53.025] - nx: 2
[08:24:53.025] - relay: TRUE
[08:24:53.025] - stdout: TRUE
[08:24:53.025] - signal: TRUE
[08:24:53.025] - resignal: FALSE
[08:24:53.025] - force: TRUE
[08:24:53.025] - relayed: [n=2] TRUE, TRUE
[08:24:53.025] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:53.025] - relayed: [n=2] TRUE, TRUE
[08:24:53.025] - queued futures: [n=2] TRUE, TRUE
[08:24:53.026] signalConditionsASAP(NULL, pos=0) ... done
[08:24:53.026] resolve() on list ... DONE
[08:24:53.026] result() for MulticoreFuture ...
[08:24:53.026] result() for MulticoreFuture ... done
[08:24:53.026] result() for MulticoreFuture ...
[08:24:53.026] result() for MulticoreFuture ... done
[08:24:53.026] result() for MulticoreFuture ...
[08:24:53.026] result() for MulticoreFuture ... done
[08:24:53.026] result() for MulticoreFuture ...
[08:24:53.027] result() for MulticoreFuture ... done
[08:24:53.027]  - Number of value chunks collected: 2
[08:24:53.027] Resolving 2 futures (chunks) ... DONE
[08:24:53.027] Reducing values from 2 chunks ...
[08:24:53.027]  - Number of values collected after concatenation: 6
[08:24:53.027]  - Number of values expected: 6
[08:24:53.027] Reducing values from 2 chunks ... DONE
[08:24:53.027] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[08:24:53.028] getGlobalsAndPackagesXApply() ...
[08:24:53.028]  - future.globals: TRUE
[08:24:53.028] getGlobalsAndPackages() ...
[08:24:53.028] Searching for globals...
[08:24:53.032] - globals found: [1] ‘FUN’
[08:24:53.033] Searching for globals ... DONE
[08:24:53.033] Resolving globals: FALSE
[08:24:53.033] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:53.034] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:53.034] - globals: [1] ‘FUN’
[08:24:53.034] 
[08:24:53.034] getGlobalsAndPackages() ... DONE
[08:24:53.035]  - globals found/used: [n=1] ‘FUN’
[08:24:53.035]  - needed namespaces: [n=0] 
[08:24:53.035] Finding globals ... DONE
[08:24:53.035]  - use_args: TRUE
[08:24:53.035]  - Getting '...' globals ...
[08:24:53.036] resolve() on list ...
[08:24:53.036]  recursive: 0
[08:24:53.036]  length: 1
[08:24:53.036]  elements: ‘...’
[08:24:53.037]  length: 0 (resolved future 1)
[08:24:53.037] resolve() on list ... DONE
[08:24:53.037]    - '...' content: [n=0] 
[08:24:53.037] List of 1
[08:24:53.037]  $ ...: list()
[08:24:53.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.037]  - attr(*, "where")=List of 1
[08:24:53.037]   ..$ ...:<environment: 0x56540e3558e8> 
[08:24:53.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.037]  - attr(*, "resolved")= logi TRUE
[08:24:53.037]  - attr(*, "total_size")= num NA
[08:24:53.040]  - Getting '...' globals ... DONE
[08:24:53.040] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:53.040] List of 2
[08:24:53.040]  $ ...future.FUN:function (x)  
[08:24:53.040]  $ ...          : list()
[08:24:53.040]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.040]  - attr(*, "where")=List of 2
[08:24:53.040]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:53.040]   ..$ ...          :<environment: 0x56540e3558e8> 
[08:24:53.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.040]  - attr(*, "resolved")= logi FALSE
[08:24:53.040]  - attr(*, "total_size")= num 2547
[08:24:53.043] Packages to be attached in all futures: [n=0] 
[08:24:53.044] getGlobalsAndPackagesXApply() ... DONE
[08:24:53.045] future_lapply() ...
[08:24:53.047] Number of chunks: 2
[08:24:53.048] getGlobalsAndPackagesXApply() ...
[08:24:53.048]  - future.globals: <name-value list> with names ‘list()’
[08:24:53.048]  - use_args: TRUE
[08:24:53.048] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:53.048] List of 2
[08:24:53.048]  $ ...          : list()
[08:24:53.048]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.048]  $ ...future.FUN:function (x)  
[08:24:53.048]  - attr(*, "where")=List of 2
[08:24:53.048]   ..$ ...          :<environment: 0x56540e3558e8> 
[08:24:53.048]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:53.048]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.048]  - attr(*, "resolved")= logi FALSE
[08:24:53.048]  - attr(*, "total_size")= num NA
[08:24:53.052] Packages to be attached in all futures: [n=0] 
[08:24:53.052] getGlobalsAndPackagesXApply() ... DONE
[08:24:53.052] Number of futures (= number of chunks): 2
[08:24:53.052] Launching 2 futures (chunks) ...
[08:24:53.052] Chunk #1 of 2 ...
[08:24:53.052]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:53.052]  - seeds: <none>
[08:24:53.053]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.053] getGlobalsAndPackages() ...
[08:24:53.053] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.053] Resolving globals: FALSE
[08:24:53.053] Tweak future expression to call with '...' arguments ...
[08:24:53.053] {
[08:24:53.053]     do.call(function(...) {
[08:24:53.053]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.053]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.053]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.053]             on.exit(options(oopts), add = TRUE)
[08:24:53.053]         }
[08:24:53.053]         {
[08:24:53.053]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.053]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.053]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.053]             })
[08:24:53.053]         }
[08:24:53.053]     }, args = future.call.arguments)
[08:24:53.053] }
[08:24:53.053] Tweak future expression to call with '...' arguments ... DONE
[08:24:53.054] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.054] 
[08:24:53.054] getGlobalsAndPackages() ... DONE
[08:24:53.054] run() for ‘Future’ ...
[08:24:53.054] - state: ‘created’
[08:24:53.055] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:53.056] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.056] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:53.056]   - Field: ‘label’
[08:24:53.057]   - Field: ‘local’
[08:24:53.057]   - Field: ‘owner’
[08:24:53.057]   - Field: ‘envir’
[08:24:53.057]   - Field: ‘workers’
[08:24:53.057]   - Field: ‘packages’
[08:24:53.057]   - Field: ‘gc’
[08:24:53.057]   - Field: ‘job’
[08:24:53.057]   - Field: ‘conditions’
[08:24:53.057]   - Field: ‘expr’
[08:24:53.057]   - Field: ‘uuid’
[08:24:53.057]   - Field: ‘seed’
[08:24:53.058]   - Field: ‘version’
[08:24:53.058]   - Field: ‘result’
[08:24:53.058]   - Field: ‘asynchronous’
[08:24:53.058]   - Field: ‘calls’
[08:24:53.058]   - Field: ‘globals’
[08:24:53.060]   - Field: ‘stdout’
[08:24:53.060]   - Field: ‘earlySignal’
[08:24:53.060]   - Field: ‘lazy’
[08:24:53.060]   - Field: ‘state’
[08:24:53.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:53.060] - Launch lazy future ...
[08:24:53.061] Packages needed by the future expression (n = 0): <none>
[08:24:53.061] Packages needed by future strategies (n = 0): <none>
[08:24:53.062] {
[08:24:53.062]     {
[08:24:53.062]         {
[08:24:53.062]             ...future.startTime <- base::Sys.time()
[08:24:53.062]             {
[08:24:53.062]                 {
[08:24:53.062]                   {
[08:24:53.062]                     {
[08:24:53.062]                       base::local({
[08:24:53.062]                         has_future <- base::requireNamespace("future", 
[08:24:53.062]                           quietly = TRUE)
[08:24:53.062]                         if (has_future) {
[08:24:53.062]                           ns <- base::getNamespace("future")
[08:24:53.062]                           version <- ns[[".package"]][["version"]]
[08:24:53.062]                           if (is.null(version)) 
[08:24:53.062]                             version <- utils::packageVersion("future")
[08:24:53.062]                         }
[08:24:53.062]                         else {
[08:24:53.062]                           version <- NULL
[08:24:53.062]                         }
[08:24:53.062]                         if (!has_future || version < "1.8.0") {
[08:24:53.062]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:53.062]                             "", base::R.version$version.string), 
[08:24:53.062]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:53.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:53.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:53.062]                               "release", "version")], collapse = " "), 
[08:24:53.062]                             hostname = base::Sys.info()[["nodename"]])
[08:24:53.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:53.062]                             info)
[08:24:53.062]                           info <- base::paste(info, collapse = "; ")
[08:24:53.062]                           if (!has_future) {
[08:24:53.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:53.062]                               info)
[08:24:53.062]                           }
[08:24:53.062]                           else {
[08:24:53.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:53.062]                               info, version)
[08:24:53.062]                           }
[08:24:53.062]                           base::stop(msg)
[08:24:53.062]                         }
[08:24:53.062]                       })
[08:24:53.062]                     }
[08:24:53.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:53.062]                     base::options(mc.cores = 1L)
[08:24:53.062]                   }
[08:24:53.062]                   ...future.strategy.old <- future::plan("list")
[08:24:53.062]                   options(future.plan = NULL)
[08:24:53.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:53.062]                 }
[08:24:53.062]                 ...future.workdir <- getwd()
[08:24:53.062]             }
[08:24:53.062]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:53.062]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:53.062]         }
[08:24:53.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:53.062]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:53.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:53.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:53.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:53.062]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:53.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:53.062]             base::names(...future.oldOptions))
[08:24:53.062]     }
[08:24:53.062]     if (FALSE) {
[08:24:53.062]     }
[08:24:53.062]     else {
[08:24:53.062]         if (TRUE) {
[08:24:53.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:53.062]                 open = "w")
[08:24:53.062]         }
[08:24:53.062]         else {
[08:24:53.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:53.062]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:53.062]         }
[08:24:53.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:53.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:53.062]             base::sink(type = "output", split = FALSE)
[08:24:53.062]             base::close(...future.stdout)
[08:24:53.062]         }, add = TRUE)
[08:24:53.062]     }
[08:24:53.062]     ...future.frame <- base::sys.nframe()
[08:24:53.062]     ...future.conditions <- base::list()
[08:24:53.062]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:53.062]     if (FALSE) {
[08:24:53.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:53.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:53.062]     }
[08:24:53.062]     ...future.result <- base::tryCatch({
[08:24:53.062]         base::withCallingHandlers({
[08:24:53.062]             ...future.value <- base::withVisible(base::local({
[08:24:53.062]                 withCallingHandlers({
[08:24:53.062]                   {
[08:24:53.062]                     do.call(function(...) {
[08:24:53.062]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.062]                       if (!identical(...future.globals.maxSize.org, 
[08:24:53.062]                         ...future.globals.maxSize)) {
[08:24:53.062]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.062]                         on.exit(options(oopts), add = TRUE)
[08:24:53.062]                       }
[08:24:53.062]                       {
[08:24:53.062]                         lapply(seq_along(...future.elements_ii), 
[08:24:53.062]                           FUN = function(jj) {
[08:24:53.062]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.062]                             ...future.FUN(...future.X_jj, ...)
[08:24:53.062]                           })
[08:24:53.062]                       }
[08:24:53.062]                     }, args = future.call.arguments)
[08:24:53.062]                   }
[08:24:53.062]                 }, immediateCondition = function(cond) {
[08:24:53.062]                   save_rds <- function (object, pathname, ...) 
[08:24:53.062]                   {
[08:24:53.062]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:53.062]                     if (file_test("-f", pathname_tmp)) {
[08:24:53.062]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.062]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:53.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.062]                         fi_tmp[["mtime"]])
[08:24:53.062]                     }
[08:24:53.062]                     tryCatch({
[08:24:53.062]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:53.062]                     }, error = function(ex) {
[08:24:53.062]                       msg <- conditionMessage(ex)
[08:24:53.062]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.062]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:53.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.062]                         fi_tmp[["mtime"]], msg)
[08:24:53.062]                       ex$message <- msg
[08:24:53.062]                       stop(ex)
[08:24:53.062]                     })
[08:24:53.062]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:53.062]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:53.062]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:53.062]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.062]                       fi <- file.info(pathname)
[08:24:53.062]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:53.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.062]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:53.062]                         fi[["size"]], fi[["mtime"]])
[08:24:53.062]                       stop(msg)
[08:24:53.062]                     }
[08:24:53.062]                     invisible(pathname)
[08:24:53.062]                   }
[08:24:53.062]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:53.062]                     rootPath = tempdir()) 
[08:24:53.062]                   {
[08:24:53.062]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:53.062]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:53.062]                       tmpdir = path, fileext = ".rds")
[08:24:53.062]                     save_rds(obj, file)
[08:24:53.062]                   }
[08:24:53.062]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:53.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.062]                   {
[08:24:53.062]                     inherits <- base::inherits
[08:24:53.062]                     invokeRestart <- base::invokeRestart
[08:24:53.062]                     is.null <- base::is.null
[08:24:53.062]                     muffled <- FALSE
[08:24:53.062]                     if (inherits(cond, "message")) {
[08:24:53.062]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:53.062]                       if (muffled) 
[08:24:53.062]                         invokeRestart("muffleMessage")
[08:24:53.062]                     }
[08:24:53.062]                     else if (inherits(cond, "warning")) {
[08:24:53.062]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:53.062]                       if (muffled) 
[08:24:53.062]                         invokeRestart("muffleWarning")
[08:24:53.062]                     }
[08:24:53.062]                     else if (inherits(cond, "condition")) {
[08:24:53.062]                       if (!is.null(pattern)) {
[08:24:53.062]                         computeRestarts <- base::computeRestarts
[08:24:53.062]                         grepl <- base::grepl
[08:24:53.062]                         restarts <- computeRestarts(cond)
[08:24:53.062]                         for (restart in restarts) {
[08:24:53.062]                           name <- restart$name
[08:24:53.062]                           if (is.null(name)) 
[08:24:53.062]                             next
[08:24:53.062]                           if (!grepl(pattern, name)) 
[08:24:53.062]                             next
[08:24:53.062]                           invokeRestart(restart)
[08:24:53.062]                           muffled <- TRUE
[08:24:53.062]                           break
[08:24:53.062]                         }
[08:24:53.062]                       }
[08:24:53.062]                     }
[08:24:53.062]                     invisible(muffled)
[08:24:53.062]                   }
[08:24:53.062]                   muffleCondition(cond)
[08:24:53.062]                 })
[08:24:53.062]             }))
[08:24:53.062]             future::FutureResult(value = ...future.value$value, 
[08:24:53.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.062]                   ...future.rng), globalenv = if (FALSE) 
[08:24:53.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:53.062]                     ...future.globalenv.names))
[08:24:53.062]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:53.062]         }, condition = base::local({
[08:24:53.062]             c <- base::c
[08:24:53.062]             inherits <- base::inherits
[08:24:53.062]             invokeRestart <- base::invokeRestart
[08:24:53.062]             length <- base::length
[08:24:53.062]             list <- base::list
[08:24:53.062]             seq.int <- base::seq.int
[08:24:53.062]             signalCondition <- base::signalCondition
[08:24:53.062]             sys.calls <- base::sys.calls
[08:24:53.062]             `[[` <- base::`[[`
[08:24:53.062]             `+` <- base::`+`
[08:24:53.062]             `<<-` <- base::`<<-`
[08:24:53.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:53.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:53.062]                   3L)]
[08:24:53.062]             }
[08:24:53.062]             function(cond) {
[08:24:53.062]                 is_error <- inherits(cond, "error")
[08:24:53.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:53.062]                   NULL)
[08:24:53.062]                 if (is_error) {
[08:24:53.062]                   sessionInformation <- function() {
[08:24:53.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:53.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:53.062]                       search = base::search(), system = base::Sys.info())
[08:24:53.062]                   }
[08:24:53.062]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:53.062]                     cond$call), session = sessionInformation(), 
[08:24:53.062]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:53.062]                   signalCondition(cond)
[08:24:53.062]                 }
[08:24:53.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:53.062]                 "immediateCondition"))) {
[08:24:53.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:53.062]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:53.062]                   if (TRUE && !signal) {
[08:24:53.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.062]                     {
[08:24:53.062]                       inherits <- base::inherits
[08:24:53.062]                       invokeRestart <- base::invokeRestart
[08:24:53.062]                       is.null <- base::is.null
[08:24:53.062]                       muffled <- FALSE
[08:24:53.062]                       if (inherits(cond, "message")) {
[08:24:53.062]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.062]                         if (muffled) 
[08:24:53.062]                           invokeRestart("muffleMessage")
[08:24:53.062]                       }
[08:24:53.062]                       else if (inherits(cond, "warning")) {
[08:24:53.062]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.062]                         if (muffled) 
[08:24:53.062]                           invokeRestart("muffleWarning")
[08:24:53.062]                       }
[08:24:53.062]                       else if (inherits(cond, "condition")) {
[08:24:53.062]                         if (!is.null(pattern)) {
[08:24:53.062]                           computeRestarts <- base::computeRestarts
[08:24:53.062]                           grepl <- base::grepl
[08:24:53.062]                           restarts <- computeRestarts(cond)
[08:24:53.062]                           for (restart in restarts) {
[08:24:53.062]                             name <- restart$name
[08:24:53.062]                             if (is.null(name)) 
[08:24:53.062]                               next
[08:24:53.062]                             if (!grepl(pattern, name)) 
[08:24:53.062]                               next
[08:24:53.062]                             invokeRestart(restart)
[08:24:53.062]                             muffled <- TRUE
[08:24:53.062]                             break
[08:24:53.062]                           }
[08:24:53.062]                         }
[08:24:53.062]                       }
[08:24:53.062]                       invisible(muffled)
[08:24:53.062]                     }
[08:24:53.062]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.062]                   }
[08:24:53.062]                 }
[08:24:53.062]                 else {
[08:24:53.062]                   if (TRUE) {
[08:24:53.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.062]                     {
[08:24:53.062]                       inherits <- base::inherits
[08:24:53.062]                       invokeRestart <- base::invokeRestart
[08:24:53.062]                       is.null <- base::is.null
[08:24:53.062]                       muffled <- FALSE
[08:24:53.062]                       if (inherits(cond, "message")) {
[08:24:53.062]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.062]                         if (muffled) 
[08:24:53.062]                           invokeRestart("muffleMessage")
[08:24:53.062]                       }
[08:24:53.062]                       else if (inherits(cond, "warning")) {
[08:24:53.062]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.062]                         if (muffled) 
[08:24:53.062]                           invokeRestart("muffleWarning")
[08:24:53.062]                       }
[08:24:53.062]                       else if (inherits(cond, "condition")) {
[08:24:53.062]                         if (!is.null(pattern)) {
[08:24:53.062]                           computeRestarts <- base::computeRestarts
[08:24:53.062]                           grepl <- base::grepl
[08:24:53.062]                           restarts <- computeRestarts(cond)
[08:24:53.062]                           for (restart in restarts) {
[08:24:53.062]                             name <- restart$name
[08:24:53.062]                             if (is.null(name)) 
[08:24:53.062]                               next
[08:24:53.062]                             if (!grepl(pattern, name)) 
[08:24:53.062]                               next
[08:24:53.062]                             invokeRestart(restart)
[08:24:53.062]                             muffled <- TRUE
[08:24:53.062]                             break
[08:24:53.062]                           }
[08:24:53.062]                         }
[08:24:53.062]                       }
[08:24:53.062]                       invisible(muffled)
[08:24:53.062]                     }
[08:24:53.062]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.062]                   }
[08:24:53.062]                 }
[08:24:53.062]             }
[08:24:53.062]         }))
[08:24:53.062]     }, error = function(ex) {
[08:24:53.062]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:53.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.062]                 ...future.rng), started = ...future.startTime, 
[08:24:53.062]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:53.062]             version = "1.8"), class = "FutureResult")
[08:24:53.062]     }, finally = {
[08:24:53.062]         if (!identical(...future.workdir, getwd())) 
[08:24:53.062]             setwd(...future.workdir)
[08:24:53.062]         {
[08:24:53.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:53.062]                 ...future.oldOptions$nwarnings <- NULL
[08:24:53.062]             }
[08:24:53.062]             base::options(...future.oldOptions)
[08:24:53.062]             if (.Platform$OS.type == "windows") {
[08:24:53.062]                 old_names <- names(...future.oldEnvVars)
[08:24:53.062]                 envs <- base::Sys.getenv()
[08:24:53.062]                 names <- names(envs)
[08:24:53.062]                 common <- intersect(names, old_names)
[08:24:53.062]                 added <- setdiff(names, old_names)
[08:24:53.062]                 removed <- setdiff(old_names, names)
[08:24:53.062]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:53.062]                   envs[common]]
[08:24:53.062]                 NAMES <- toupper(changed)
[08:24:53.062]                 args <- list()
[08:24:53.062]                 for (kk in seq_along(NAMES)) {
[08:24:53.062]                   name <- changed[[kk]]
[08:24:53.062]                   NAME <- NAMES[[kk]]
[08:24:53.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.062]                     next
[08:24:53.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.062]                 }
[08:24:53.062]                 NAMES <- toupper(added)
[08:24:53.062]                 for (kk in seq_along(NAMES)) {
[08:24:53.062]                   name <- added[[kk]]
[08:24:53.062]                   NAME <- NAMES[[kk]]
[08:24:53.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.062]                     next
[08:24:53.062]                   args[[name]] <- ""
[08:24:53.062]                 }
[08:24:53.062]                 NAMES <- toupper(removed)
[08:24:53.062]                 for (kk in seq_along(NAMES)) {
[08:24:53.062]                   name <- removed[[kk]]
[08:24:53.062]                   NAME <- NAMES[[kk]]
[08:24:53.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.062]                     next
[08:24:53.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.062]                 }
[08:24:53.062]                 if (length(args) > 0) 
[08:24:53.062]                   base::do.call(base::Sys.setenv, args = args)
[08:24:53.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:53.062]             }
[08:24:53.062]             else {
[08:24:53.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:53.062]             }
[08:24:53.062]             {
[08:24:53.062]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:53.062]                   0L) {
[08:24:53.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:53.062]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:53.062]                   base::options(opts)
[08:24:53.062]                 }
[08:24:53.062]                 {
[08:24:53.062]                   {
[08:24:53.062]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:53.062]                     NULL
[08:24:53.062]                   }
[08:24:53.062]                   options(future.plan = NULL)
[08:24:53.062]                   if (is.na(NA_character_)) 
[08:24:53.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:53.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:53.062]                     .init = FALSE)
[08:24:53.062]                 }
[08:24:53.062]             }
[08:24:53.062]         }
[08:24:53.062]     })
[08:24:53.062]     if (TRUE) {
[08:24:53.062]         base::sink(type = "output", split = FALSE)
[08:24:53.062]         if (TRUE) {
[08:24:53.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:53.062]         }
[08:24:53.062]         else {
[08:24:53.062]             ...future.result["stdout"] <- base::list(NULL)
[08:24:53.062]         }
[08:24:53.062]         base::close(...future.stdout)
[08:24:53.062]         ...future.stdout <- NULL
[08:24:53.062]     }
[08:24:53.062]     ...future.result$conditions <- ...future.conditions
[08:24:53.062]     ...future.result$finished <- base::Sys.time()
[08:24:53.062]     ...future.result
[08:24:53.062] }
[08:24:53.064] assign_globals() ...
[08:24:53.064] List of 5
[08:24:53.064]  $ future.call.arguments    : list()
[08:24:53.064]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.064]  $ ...future.FUN            :function (x)  
[08:24:53.064]  $ ...future.elements_ii    :List of 1
[08:24:53.064]   ..$ : int 1
[08:24:53.064]  $ ...future.seeds_ii       : NULL
[08:24:53.064]  $ ...future.globals.maxSize: num Inf
[08:24:53.064]  - attr(*, "resolved")= logi FALSE
[08:24:53.064]  - attr(*, "total_size")= num NA
[08:24:53.064]  - attr(*, "where")=List of 5
[08:24:53.064]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:53.064]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:53.064]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:53.064]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:53.064]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:53.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.064]  - attr(*, "already-done")= logi TRUE
[08:24:53.069] - copied ‘future.call.arguments’ to environment
[08:24:53.069] - copied ‘...future.FUN’ to environment
[08:24:53.069] - copied ‘...future.elements_ii’ to environment
[08:24:53.070] - copied ‘...future.seeds_ii’ to environment
[08:24:53.070] - copied ‘...future.globals.maxSize’ to environment
[08:24:53.070] assign_globals() ... done
[08:24:53.070] requestCore(): workers = 2
[08:24:53.072] MulticoreFuture started
[08:24:53.073] - Launch lazy future ... done
[08:24:53.073] run() for ‘MulticoreFuture’ ... done
[08:24:53.073] Created future:
[08:24:53.073] plan(): Setting new future strategy stack:
[08:24:53.074] List of future strategies:
[08:24:53.074] 1. sequential:
[08:24:53.074]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.074]    - tweaked: FALSE
[08:24:53.074]    - call: NULL
[08:24:53.075] plan(): nbrOfWorkers() = 1
[08:24:53.077] plan(): Setting new future strategy stack:
[08:24:53.077] List of future strategies:
[08:24:53.077] 1. multicore:
[08:24:53.077]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:53.077]    - tweaked: FALSE
[08:24:53.077]    - call: plan(strategy)
[08:24:53.080] plan(): nbrOfWorkers() = 2
[08:24:53.073] MulticoreFuture:
[08:24:53.073] Label: ‘future_apply-1’
[08:24:53.073] Expression:
[08:24:53.073] {
[08:24:53.073]     do.call(function(...) {
[08:24:53.073]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.073]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.073]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.073]             on.exit(options(oopts), add = TRUE)
[08:24:53.073]         }
[08:24:53.073]         {
[08:24:53.073]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.073]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.073]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.073]             })
[08:24:53.073]         }
[08:24:53.073]     }, args = future.call.arguments)
[08:24:53.073] }
[08:24:53.073] Lazy evaluation: FALSE
[08:24:53.073] Asynchronous evaluation: TRUE
[08:24:53.073] Local evaluation: TRUE
[08:24:53.073] Environment: R_GlobalEnv
[08:24:53.073] Capture standard output: TRUE
[08:24:53.073] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:53.073] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:53.073] Packages: <none>
[08:24:53.073] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:53.073] Resolved: TRUE
[08:24:53.073] Value: <not collected>
[08:24:53.073] Conditions captured: <none>
[08:24:53.073] Early signaling: FALSE
[08:24:53.073] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:53.073] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.082] Chunk #1 of 2 ... DONE
[08:24:53.082] Chunk #2 of 2 ...
[08:24:53.082]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:53.082]  - seeds: <none>
[08:24:53.082]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.082] getGlobalsAndPackages() ...
[08:24:53.083] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.083] Resolving globals: FALSE
[08:24:53.083] Tweak future expression to call with '...' arguments ...
[08:24:53.083] {
[08:24:53.083]     do.call(function(...) {
[08:24:53.083]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.083]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.083]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.083]             on.exit(options(oopts), add = TRUE)
[08:24:53.083]         }
[08:24:53.083]         {
[08:24:53.083]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.083]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.083]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.083]             })
[08:24:53.083]         }
[08:24:53.083]     }, args = future.call.arguments)
[08:24:53.083] }
[08:24:53.083] Tweak future expression to call with '...' arguments ... DONE
[08:24:53.084] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.084] 
[08:24:53.084] getGlobalsAndPackages() ... DONE
[08:24:53.085] run() for ‘Future’ ...
[08:24:53.085] - state: ‘created’
[08:24:53.085] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:53.088] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.088] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:53.089]   - Field: ‘label’
[08:24:53.089]   - Field: ‘local’
[08:24:53.089]   - Field: ‘owner’
[08:24:53.089]   - Field: ‘envir’
[08:24:53.089]   - Field: ‘workers’
[08:24:53.089]   - Field: ‘packages’
[08:24:53.089]   - Field: ‘gc’
[08:24:53.090]   - Field: ‘job’
[08:24:53.090]   - Field: ‘conditions’
[08:24:53.090]   - Field: ‘expr’
[08:24:53.090]   - Field: ‘uuid’
[08:24:53.090]   - Field: ‘seed’
[08:24:53.090]   - Field: ‘version’
[08:24:53.090]   - Field: ‘result’
[08:24:53.090]   - Field: ‘asynchronous’
[08:24:53.091]   - Field: ‘calls’
[08:24:53.091]   - Field: ‘globals’
[08:24:53.091]   - Field: ‘stdout’
[08:24:53.091]   - Field: ‘earlySignal’
[08:24:53.091]   - Field: ‘lazy’
[08:24:53.092]   - Field: ‘state’
[08:24:53.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:53.092] - Launch lazy future ...
[08:24:53.092] Packages needed by the future expression (n = 0): <none>
[08:24:53.093] Packages needed by future strategies (n = 0): <none>
[08:24:53.093] {
[08:24:53.093]     {
[08:24:53.093]         {
[08:24:53.093]             ...future.startTime <- base::Sys.time()
[08:24:53.093]             {
[08:24:53.093]                 {
[08:24:53.093]                   {
[08:24:53.093]                     {
[08:24:53.093]                       base::local({
[08:24:53.093]                         has_future <- base::requireNamespace("future", 
[08:24:53.093]                           quietly = TRUE)
[08:24:53.093]                         if (has_future) {
[08:24:53.093]                           ns <- base::getNamespace("future")
[08:24:53.093]                           version <- ns[[".package"]][["version"]]
[08:24:53.093]                           if (is.null(version)) 
[08:24:53.093]                             version <- utils::packageVersion("future")
[08:24:53.093]                         }
[08:24:53.093]                         else {
[08:24:53.093]                           version <- NULL
[08:24:53.093]                         }
[08:24:53.093]                         if (!has_future || version < "1.8.0") {
[08:24:53.093]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:53.093]                             "", base::R.version$version.string), 
[08:24:53.093]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:53.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:53.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:53.093]                               "release", "version")], collapse = " "), 
[08:24:53.093]                             hostname = base::Sys.info()[["nodename"]])
[08:24:53.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:53.093]                             info)
[08:24:53.093]                           info <- base::paste(info, collapse = "; ")
[08:24:53.093]                           if (!has_future) {
[08:24:53.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:53.093]                               info)
[08:24:53.093]                           }
[08:24:53.093]                           else {
[08:24:53.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:53.093]                               info, version)
[08:24:53.093]                           }
[08:24:53.093]                           base::stop(msg)
[08:24:53.093]                         }
[08:24:53.093]                       })
[08:24:53.093]                     }
[08:24:53.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:53.093]                     base::options(mc.cores = 1L)
[08:24:53.093]                   }
[08:24:53.093]                   ...future.strategy.old <- future::plan("list")
[08:24:53.093]                   options(future.plan = NULL)
[08:24:53.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:53.093]                 }
[08:24:53.093]                 ...future.workdir <- getwd()
[08:24:53.093]             }
[08:24:53.093]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:53.093]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:53.093]         }
[08:24:53.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:53.093]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:53.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:53.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:53.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:53.093]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:53.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:53.093]             base::names(...future.oldOptions))
[08:24:53.093]     }
[08:24:53.093]     if (FALSE) {
[08:24:53.093]     }
[08:24:53.093]     else {
[08:24:53.093]         if (TRUE) {
[08:24:53.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:53.093]                 open = "w")
[08:24:53.093]         }
[08:24:53.093]         else {
[08:24:53.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:53.093]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:53.093]         }
[08:24:53.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:53.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:53.093]             base::sink(type = "output", split = FALSE)
[08:24:53.093]             base::close(...future.stdout)
[08:24:53.093]         }, add = TRUE)
[08:24:53.093]     }
[08:24:53.093]     ...future.frame <- base::sys.nframe()
[08:24:53.093]     ...future.conditions <- base::list()
[08:24:53.093]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:53.093]     if (FALSE) {
[08:24:53.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:53.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:53.093]     }
[08:24:53.093]     ...future.result <- base::tryCatch({
[08:24:53.093]         base::withCallingHandlers({
[08:24:53.093]             ...future.value <- base::withVisible(base::local({
[08:24:53.093]                 withCallingHandlers({
[08:24:53.093]                   {
[08:24:53.093]                     do.call(function(...) {
[08:24:53.093]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.093]                       if (!identical(...future.globals.maxSize.org, 
[08:24:53.093]                         ...future.globals.maxSize)) {
[08:24:53.093]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.093]                         on.exit(options(oopts), add = TRUE)
[08:24:53.093]                       }
[08:24:53.093]                       {
[08:24:53.093]                         lapply(seq_along(...future.elements_ii), 
[08:24:53.093]                           FUN = function(jj) {
[08:24:53.093]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.093]                             ...future.FUN(...future.X_jj, ...)
[08:24:53.093]                           })
[08:24:53.093]                       }
[08:24:53.093]                     }, args = future.call.arguments)
[08:24:53.093]                   }
[08:24:53.093]                 }, immediateCondition = function(cond) {
[08:24:53.093]                   save_rds <- function (object, pathname, ...) 
[08:24:53.093]                   {
[08:24:53.093]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:53.093]                     if (file_test("-f", pathname_tmp)) {
[08:24:53.093]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.093]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:53.093]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.093]                         fi_tmp[["mtime"]])
[08:24:53.093]                     }
[08:24:53.093]                     tryCatch({
[08:24:53.093]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:53.093]                     }, error = function(ex) {
[08:24:53.093]                       msg <- conditionMessage(ex)
[08:24:53.093]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.093]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:53.093]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.093]                         fi_tmp[["mtime"]], msg)
[08:24:53.093]                       ex$message <- msg
[08:24:53.093]                       stop(ex)
[08:24:53.093]                     })
[08:24:53.093]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:53.093]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:53.093]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:53.093]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.093]                       fi <- file.info(pathname)
[08:24:53.093]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:53.093]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.093]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:53.093]                         fi[["size"]], fi[["mtime"]])
[08:24:53.093]                       stop(msg)
[08:24:53.093]                     }
[08:24:53.093]                     invisible(pathname)
[08:24:53.093]                   }
[08:24:53.093]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:53.093]                     rootPath = tempdir()) 
[08:24:53.093]                   {
[08:24:53.093]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:53.093]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:53.093]                       tmpdir = path, fileext = ".rds")
[08:24:53.093]                     save_rds(obj, file)
[08:24:53.093]                   }
[08:24:53.093]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:53.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.093]                   {
[08:24:53.093]                     inherits <- base::inherits
[08:24:53.093]                     invokeRestart <- base::invokeRestart
[08:24:53.093]                     is.null <- base::is.null
[08:24:53.093]                     muffled <- FALSE
[08:24:53.093]                     if (inherits(cond, "message")) {
[08:24:53.093]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:53.093]                       if (muffled) 
[08:24:53.093]                         invokeRestart("muffleMessage")
[08:24:53.093]                     }
[08:24:53.093]                     else if (inherits(cond, "warning")) {
[08:24:53.093]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:53.093]                       if (muffled) 
[08:24:53.093]                         invokeRestart("muffleWarning")
[08:24:53.093]                     }
[08:24:53.093]                     else if (inherits(cond, "condition")) {
[08:24:53.093]                       if (!is.null(pattern)) {
[08:24:53.093]                         computeRestarts <- base::computeRestarts
[08:24:53.093]                         grepl <- base::grepl
[08:24:53.093]                         restarts <- computeRestarts(cond)
[08:24:53.093]                         for (restart in restarts) {
[08:24:53.093]                           name <- restart$name
[08:24:53.093]                           if (is.null(name)) 
[08:24:53.093]                             next
[08:24:53.093]                           if (!grepl(pattern, name)) 
[08:24:53.093]                             next
[08:24:53.093]                           invokeRestart(restart)
[08:24:53.093]                           muffled <- TRUE
[08:24:53.093]                           break
[08:24:53.093]                         }
[08:24:53.093]                       }
[08:24:53.093]                     }
[08:24:53.093]                     invisible(muffled)
[08:24:53.093]                   }
[08:24:53.093]                   muffleCondition(cond)
[08:24:53.093]                 })
[08:24:53.093]             }))
[08:24:53.093]             future::FutureResult(value = ...future.value$value, 
[08:24:53.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.093]                   ...future.rng), globalenv = if (FALSE) 
[08:24:53.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:53.093]                     ...future.globalenv.names))
[08:24:53.093]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:53.093]         }, condition = base::local({
[08:24:53.093]             c <- base::c
[08:24:53.093]             inherits <- base::inherits
[08:24:53.093]             invokeRestart <- base::invokeRestart
[08:24:53.093]             length <- base::length
[08:24:53.093]             list <- base::list
[08:24:53.093]             seq.int <- base::seq.int
[08:24:53.093]             signalCondition <- base::signalCondition
[08:24:53.093]             sys.calls <- base::sys.calls
[08:24:53.093]             `[[` <- base::`[[`
[08:24:53.093]             `+` <- base::`+`
[08:24:53.093]             `<<-` <- base::`<<-`
[08:24:53.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:53.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:53.093]                   3L)]
[08:24:53.093]             }
[08:24:53.093]             function(cond) {
[08:24:53.093]                 is_error <- inherits(cond, "error")
[08:24:53.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:53.093]                   NULL)
[08:24:53.093]                 if (is_error) {
[08:24:53.093]                   sessionInformation <- function() {
[08:24:53.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:53.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:53.093]                       search = base::search(), system = base::Sys.info())
[08:24:53.093]                   }
[08:24:53.093]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:53.093]                     cond$call), session = sessionInformation(), 
[08:24:53.093]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:53.093]                   signalCondition(cond)
[08:24:53.093]                 }
[08:24:53.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:53.093]                 "immediateCondition"))) {
[08:24:53.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:53.093]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:53.093]                   if (TRUE && !signal) {
[08:24:53.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.093]                     {
[08:24:53.093]                       inherits <- base::inherits
[08:24:53.093]                       invokeRestart <- base::invokeRestart
[08:24:53.093]                       is.null <- base::is.null
[08:24:53.093]                       muffled <- FALSE
[08:24:53.093]                       if (inherits(cond, "message")) {
[08:24:53.093]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.093]                         if (muffled) 
[08:24:53.093]                           invokeRestart("muffleMessage")
[08:24:53.093]                       }
[08:24:53.093]                       else if (inherits(cond, "warning")) {
[08:24:53.093]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.093]                         if (muffled) 
[08:24:53.093]                           invokeRestart("muffleWarning")
[08:24:53.093]                       }
[08:24:53.093]                       else if (inherits(cond, "condition")) {
[08:24:53.093]                         if (!is.null(pattern)) {
[08:24:53.093]                           computeRestarts <- base::computeRestarts
[08:24:53.093]                           grepl <- base::grepl
[08:24:53.093]                           restarts <- computeRestarts(cond)
[08:24:53.093]                           for (restart in restarts) {
[08:24:53.093]                             name <- restart$name
[08:24:53.093]                             if (is.null(name)) 
[08:24:53.093]                               next
[08:24:53.093]                             if (!grepl(pattern, name)) 
[08:24:53.093]                               next
[08:24:53.093]                             invokeRestart(restart)
[08:24:53.093]                             muffled <- TRUE
[08:24:53.093]                             break
[08:24:53.093]                           }
[08:24:53.093]                         }
[08:24:53.093]                       }
[08:24:53.093]                       invisible(muffled)
[08:24:53.093]                     }
[08:24:53.093]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.093]                   }
[08:24:53.093]                 }
[08:24:53.093]                 else {
[08:24:53.093]                   if (TRUE) {
[08:24:53.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.093]                     {
[08:24:53.093]                       inherits <- base::inherits
[08:24:53.093]                       invokeRestart <- base::invokeRestart
[08:24:53.093]                       is.null <- base::is.null
[08:24:53.093]                       muffled <- FALSE
[08:24:53.093]                       if (inherits(cond, "message")) {
[08:24:53.093]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.093]                         if (muffled) 
[08:24:53.093]                           invokeRestart("muffleMessage")
[08:24:53.093]                       }
[08:24:53.093]                       else if (inherits(cond, "warning")) {
[08:24:53.093]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.093]                         if (muffled) 
[08:24:53.093]                           invokeRestart("muffleWarning")
[08:24:53.093]                       }
[08:24:53.093]                       else if (inherits(cond, "condition")) {
[08:24:53.093]                         if (!is.null(pattern)) {
[08:24:53.093]                           computeRestarts <- base::computeRestarts
[08:24:53.093]                           grepl <- base::grepl
[08:24:53.093]                           restarts <- computeRestarts(cond)
[08:24:53.093]                           for (restart in restarts) {
[08:24:53.093]                             name <- restart$name
[08:24:53.093]                             if (is.null(name)) 
[08:24:53.093]                               next
[08:24:53.093]                             if (!grepl(pattern, name)) 
[08:24:53.093]                               next
[08:24:53.093]                             invokeRestart(restart)
[08:24:53.093]                             muffled <- TRUE
[08:24:53.093]                             break
[08:24:53.093]                           }
[08:24:53.093]                         }
[08:24:53.093]                       }
[08:24:53.093]                       invisible(muffled)
[08:24:53.093]                     }
[08:24:53.093]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.093]                   }
[08:24:53.093]                 }
[08:24:53.093]             }
[08:24:53.093]         }))
[08:24:53.093]     }, error = function(ex) {
[08:24:53.093]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:53.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.093]                 ...future.rng), started = ...future.startTime, 
[08:24:53.093]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:53.093]             version = "1.8"), class = "FutureResult")
[08:24:53.093]     }, finally = {
[08:24:53.093]         if (!identical(...future.workdir, getwd())) 
[08:24:53.093]             setwd(...future.workdir)
[08:24:53.093]         {
[08:24:53.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:53.093]                 ...future.oldOptions$nwarnings <- NULL
[08:24:53.093]             }
[08:24:53.093]             base::options(...future.oldOptions)
[08:24:53.093]             if (.Platform$OS.type == "windows") {
[08:24:53.093]                 old_names <- names(...future.oldEnvVars)
[08:24:53.093]                 envs <- base::Sys.getenv()
[08:24:53.093]                 names <- names(envs)
[08:24:53.093]                 common <- intersect(names, old_names)
[08:24:53.093]                 added <- setdiff(names, old_names)
[08:24:53.093]                 removed <- setdiff(old_names, names)
[08:24:53.093]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:53.093]                   envs[common]]
[08:24:53.093]                 NAMES <- toupper(changed)
[08:24:53.093]                 args <- list()
[08:24:53.093]                 for (kk in seq_along(NAMES)) {
[08:24:53.093]                   name <- changed[[kk]]
[08:24:53.093]                   NAME <- NAMES[[kk]]
[08:24:53.093]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.093]                     next
[08:24:53.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.093]                 }
[08:24:53.093]                 NAMES <- toupper(added)
[08:24:53.093]                 for (kk in seq_along(NAMES)) {
[08:24:53.093]                   name <- added[[kk]]
[08:24:53.093]                   NAME <- NAMES[[kk]]
[08:24:53.093]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.093]                     next
[08:24:53.093]                   args[[name]] <- ""
[08:24:53.093]                 }
[08:24:53.093]                 NAMES <- toupper(removed)
[08:24:53.093]                 for (kk in seq_along(NAMES)) {
[08:24:53.093]                   name <- removed[[kk]]
[08:24:53.093]                   NAME <- NAMES[[kk]]
[08:24:53.093]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.093]                     next
[08:24:53.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.093]                 }
[08:24:53.093]                 if (length(args) > 0) 
[08:24:53.093]                   base::do.call(base::Sys.setenv, args = args)
[08:24:53.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:53.093]             }
[08:24:53.093]             else {
[08:24:53.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:53.093]             }
[08:24:53.093]             {
[08:24:53.093]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:53.093]                   0L) {
[08:24:53.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:53.093]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:53.093]                   base::options(opts)
[08:24:53.093]                 }
[08:24:53.093]                 {
[08:24:53.093]                   {
[08:24:53.093]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:53.093]                     NULL
[08:24:53.093]                   }
[08:24:53.093]                   options(future.plan = NULL)
[08:24:53.093]                   if (is.na(NA_character_)) 
[08:24:53.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:53.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:53.093]                     .init = FALSE)
[08:24:53.093]                 }
[08:24:53.093]             }
[08:24:53.093]         }
[08:24:53.093]     })
[08:24:53.093]     if (TRUE) {
[08:24:53.093]         base::sink(type = "output", split = FALSE)
[08:24:53.093]         if (TRUE) {
[08:24:53.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:53.093]         }
[08:24:53.093]         else {
[08:24:53.093]             ...future.result["stdout"] <- base::list(NULL)
[08:24:53.093]         }
[08:24:53.093]         base::close(...future.stdout)
[08:24:53.093]         ...future.stdout <- NULL
[08:24:53.093]     }
[08:24:53.093]     ...future.result$conditions <- ...future.conditions
[08:24:53.093]     ...future.result$finished <- base::Sys.time()
[08:24:53.093]     ...future.result
[08:24:53.093] }
[08:24:53.097] assign_globals() ...
[08:24:53.097] List of 5
[08:24:53.097]  $ future.call.arguments    : list()
[08:24:53.097]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.097]  $ ...future.FUN            :function (x)  
[08:24:53.097]  $ ...future.elements_ii    :List of 1
[08:24:53.097]   ..$ : int 2
[08:24:53.097]  $ ...future.seeds_ii       : NULL
[08:24:53.097]  $ ...future.globals.maxSize: num Inf
[08:24:53.097]  - attr(*, "resolved")= logi FALSE
[08:24:53.097]  - attr(*, "total_size")= num NA
[08:24:53.097]  - attr(*, "where")=List of 5
[08:24:53.097]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:53.097]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:53.097]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:53.097]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:53.097]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:53.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.097]  - attr(*, "already-done")= logi TRUE
[08:24:53.109] - copied ‘future.call.arguments’ to environment
[08:24:53.109] - copied ‘...future.FUN’ to environment
[08:24:53.109] - copied ‘...future.elements_ii’ to environment
[08:24:53.109] - copied ‘...future.seeds_ii’ to environment
[08:24:53.110] - copied ‘...future.globals.maxSize’ to environment
[08:24:53.110] assign_globals() ... done
[08:24:53.110] requestCore(): workers = 2
[08:24:53.113] MulticoreFuture started
[08:24:53.114] - Launch lazy future ... done
[08:24:53.114] run() for ‘MulticoreFuture’ ... done
[08:24:53.115] plan(): Setting new future strategy stack:
[08:24:53.115] Created future:
[08:24:53.115] List of future strategies:
[08:24:53.115] 1. sequential:
[08:24:53.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.115]    - tweaked: FALSE
[08:24:53.115]    - call: NULL
[08:24:53.117] plan(): nbrOfWorkers() = 1
[08:24:53.119] plan(): Setting new future strategy stack:
[08:24:53.120] List of future strategies:
[08:24:53.120] 1. multicore:
[08:24:53.120]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:53.120]    - tweaked: FALSE
[08:24:53.120]    - call: plan(strategy)
[08:24:53.123] plan(): nbrOfWorkers() = 2
[08:24:53.115] MulticoreFuture:
[08:24:53.115] Label: ‘future_apply-2’
[08:24:53.115] Expression:
[08:24:53.115] {
[08:24:53.115]     do.call(function(...) {
[08:24:53.115]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.115]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.115]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.115]             on.exit(options(oopts), add = TRUE)
[08:24:53.115]         }
[08:24:53.115]         {
[08:24:53.115]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.115]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.115]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.115]             })
[08:24:53.115]         }
[08:24:53.115]     }, args = future.call.arguments)
[08:24:53.115] }
[08:24:53.115] Lazy evaluation: FALSE
[08:24:53.115] Asynchronous evaluation: TRUE
[08:24:53.115] Local evaluation: TRUE
[08:24:53.115] Environment: R_GlobalEnv
[08:24:53.115] Capture standard output: TRUE
[08:24:53.115] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:53.115] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:53.115] Packages: <none>
[08:24:53.115] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:53.115] Resolved: TRUE
[08:24:53.115] Value: <not collected>
[08:24:53.115] Conditions captured: <none>
[08:24:53.115] Early signaling: FALSE
[08:24:53.115] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:53.115] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.124] Chunk #2 of 2 ... DONE
[08:24:53.125] Launching 2 futures (chunks) ... DONE
[08:24:53.125] Resolving 2 futures (chunks) ...
[08:24:53.125] resolve() on list ...
[08:24:53.125]  recursive: 0
[08:24:53.125]  length: 2
[08:24:53.126] 
[08:24:53.126] Future #1
[08:24:53.126] result() for MulticoreFuture ...
[08:24:53.127] result() for MulticoreFuture ...
[08:24:53.127] result() for MulticoreFuture ... done
[08:24:53.128] result() for MulticoreFuture ... done
[08:24:53.128] result() for MulticoreFuture ...
[08:24:53.128] result() for MulticoreFuture ... done
[08:24:53.128] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:53.128] - nx: 2
[08:24:53.128] - relay: TRUE
[08:24:53.129] - stdout: TRUE
[08:24:53.129] - signal: TRUE
[08:24:53.129] - resignal: FALSE
[08:24:53.129] - force: TRUE
[08:24:53.129] - relayed: [n=2] FALSE, FALSE
[08:24:53.129] - queued futures: [n=2] FALSE, FALSE
[08:24:53.130]  - until=1
[08:24:53.130]  - relaying element #1
[08:24:53.130] result() for MulticoreFuture ...
[08:24:53.130] result() for MulticoreFuture ... done
[08:24:53.130] result() for MulticoreFuture ...
[08:24:53.130] result() for MulticoreFuture ... done
[08:24:53.131] result() for MulticoreFuture ...
[08:24:53.131] result() for MulticoreFuture ... done
[08:24:53.131] result() for MulticoreFuture ...
[08:24:53.131] result() for MulticoreFuture ... done
[08:24:53.131] - relayed: [n=2] TRUE, FALSE
[08:24:53.131] - queued futures: [n=2] TRUE, FALSE
[08:24:53.132] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:53.132]  length: 1 (resolved future 1)
[08:24:53.132] Future #2
[08:24:53.132] result() for MulticoreFuture ...
[08:24:53.133] result() for MulticoreFuture ...
[08:24:53.133] result() for MulticoreFuture ... done
[08:24:53.133] result() for MulticoreFuture ... done
[08:24:53.133] result() for MulticoreFuture ...
[08:24:53.134] result() for MulticoreFuture ... done
[08:24:53.134] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:53.134] - nx: 2
[08:24:53.134] - relay: TRUE
[08:24:53.134] - stdout: TRUE
[08:24:53.134] - signal: TRUE
[08:24:53.134] - resignal: FALSE
[08:24:53.134] - force: TRUE
[08:24:53.135] - relayed: [n=2] TRUE, FALSE
[08:24:53.135] - queued futures: [n=2] TRUE, FALSE
[08:24:53.135]  - until=2
[08:24:53.135]  - relaying element #2
[08:24:53.135] result() for MulticoreFuture ...
[08:24:53.135] result() for MulticoreFuture ... done
[08:24:53.135] result() for MulticoreFuture ...
[08:24:53.135] result() for MulticoreFuture ... done
[08:24:53.136] result() for MulticoreFuture ...
[08:24:53.136] result() for MulticoreFuture ... done
[08:24:53.136] result() for MulticoreFuture ...
[08:24:53.136] result() for MulticoreFuture ... done
[08:24:53.136] - relayed: [n=2] TRUE, TRUE
[08:24:53.136] - queued futures: [n=2] TRUE, TRUE
[08:24:53.136] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:53.136]  length: 0 (resolved future 2)
[08:24:53.137] Relaying remaining futures
[08:24:53.137] signalConditionsASAP(NULL, pos=0) ...
[08:24:53.137] - nx: 2
[08:24:53.137] - relay: TRUE
[08:24:53.137] - stdout: TRUE
[08:24:53.137] - signal: TRUE
[08:24:53.137] - resignal: FALSE
[08:24:53.137] - force: TRUE
[08:24:53.137] - relayed: [n=2] TRUE, TRUE
[08:24:53.137] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:53.138] - relayed: [n=2] TRUE, TRUE
[08:24:53.138] - queued futures: [n=2] TRUE, TRUE
[08:24:53.138] signalConditionsASAP(NULL, pos=0) ... done
[08:24:53.138] resolve() on list ... DONE
[08:24:53.138] result() for MulticoreFuture ...
[08:24:53.138] result() for MulticoreFuture ... done
[08:24:53.138] result() for MulticoreFuture ...
[08:24:53.138] result() for MulticoreFuture ... done
[08:24:53.138] result() for MulticoreFuture ...
[08:24:53.139] result() for MulticoreFuture ... done
[08:24:53.139] result() for MulticoreFuture ...
[08:24:53.139] result() for MulticoreFuture ... done
[08:24:53.139]  - Number of value chunks collected: 2
[08:24:53.139] Resolving 2 futures (chunks) ... DONE
[08:24:53.139] Reducing values from 2 chunks ...
[08:24:53.139]  - Number of values collected after concatenation: 2
[08:24:53.139]  - Number of values expected: 2
[08:24:53.139] Reducing values from 2 chunks ... DONE
[08:24:53.140] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[08:24:53.140] getGlobalsAndPackagesXApply() ...
[08:24:53.140]  - future.globals: TRUE
[08:24:53.140] getGlobalsAndPackages() ...
[08:24:53.140] Searching for globals...
[08:24:53.142] - globals found: [1] ‘FUN’
[08:24:53.142] Searching for globals ... DONE
[08:24:53.142] Resolving globals: FALSE
[08:24:53.142] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:53.143] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:53.143] - globals: [1] ‘FUN’
[08:24:53.143] 
[08:24:53.143] getGlobalsAndPackages() ... DONE
[08:24:53.143]  - globals found/used: [n=1] ‘FUN’
[08:24:53.143]  - needed namespaces: [n=0] 
[08:24:53.144] Finding globals ... DONE
[08:24:53.144]  - use_args: TRUE
[08:24:53.144]  - Getting '...' globals ...
[08:24:53.144] resolve() on list ...
[08:24:53.144]  recursive: 0
[08:24:53.144]  length: 1
[08:24:53.145]  elements: ‘...’
[08:24:53.145]  length: 0 (resolved future 1)
[08:24:53.145] resolve() on list ... DONE
[08:24:53.145]    - '...' content: [n=0] 
[08:24:53.145] List of 1
[08:24:53.145]  $ ...: list()
[08:24:53.145]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.145]  - attr(*, "where")=List of 1
[08:24:53.145]   ..$ ...:<environment: 0x56540ddea3d8> 
[08:24:53.145]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.145]  - attr(*, "resolved")= logi TRUE
[08:24:53.145]  - attr(*, "total_size")= num NA
[08:24:53.148]  - Getting '...' globals ... DONE
[08:24:53.150] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:53.151] List of 2
[08:24:53.151]  $ ...future.FUN:function (x)  
[08:24:53.151]  $ ...          : list()
[08:24:53.151]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.151]  - attr(*, "where")=List of 2
[08:24:53.151]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:53.151]   ..$ ...          :<environment: 0x56540ddea3d8> 
[08:24:53.151]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.151]  - attr(*, "resolved")= logi FALSE
[08:24:53.151]  - attr(*, "total_size")= num 2274
[08:24:53.155] Packages to be attached in all futures: [n=0] 
[08:24:53.155] getGlobalsAndPackagesXApply() ... DONE
[08:24:53.157] future_lapply() ...
[08:24:53.159] Number of chunks: 2
[08:24:53.159] getGlobalsAndPackagesXApply() ...
[08:24:53.159]  - future.globals: <name-value list> with names ‘list()’
[08:24:53.159]  - use_args: TRUE
[08:24:53.159] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:53.159] List of 2
[08:24:53.159]  $ ...          : list()
[08:24:53.159]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.159]  $ ...future.FUN:function (x)  
[08:24:53.159]  - attr(*, "where")=List of 2
[08:24:53.159]   ..$ ...          :<environment: 0x56540ddea3d8> 
[08:24:53.159]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:53.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.159]  - attr(*, "resolved")= logi FALSE
[08:24:53.159]  - attr(*, "total_size")= num NA
[08:24:53.163] Packages to be attached in all futures: [n=0] 
[08:24:53.163] getGlobalsAndPackagesXApply() ... DONE
[08:24:53.163] Number of futures (= number of chunks): 2
[08:24:53.163] Launching 2 futures (chunks) ...
[08:24:53.164] Chunk #1 of 2 ...
[08:24:53.164]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:53.164]  - seeds: <none>
[08:24:53.164]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.164] getGlobalsAndPackages() ...
[08:24:53.164] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.164] Resolving globals: FALSE
[08:24:53.164] Tweak future expression to call with '...' arguments ...
[08:24:53.164] {
[08:24:53.164]     do.call(function(...) {
[08:24:53.164]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.164]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.164]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.164]             on.exit(options(oopts), add = TRUE)
[08:24:53.164]         }
[08:24:53.164]         {
[08:24:53.164]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.164]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.164]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.164]             })
[08:24:53.164]         }
[08:24:53.164]     }, args = future.call.arguments)
[08:24:53.164] }
[08:24:53.165] Tweak future expression to call with '...' arguments ... DONE
[08:24:53.165] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.165] 
[08:24:53.165] getGlobalsAndPackages() ... DONE
[08:24:53.166] run() for ‘Future’ ...
[08:24:53.166] - state: ‘created’
[08:24:53.166] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:53.168] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:53.168]   - Field: ‘label’
[08:24:53.168]   - Field: ‘local’
[08:24:53.168]   - Field: ‘owner’
[08:24:53.168]   - Field: ‘envir’
[08:24:53.168]   - Field: ‘workers’
[08:24:53.168]   - Field: ‘packages’
[08:24:53.168]   - Field: ‘gc’
[08:24:53.169]   - Field: ‘job’
[08:24:53.169]   - Field: ‘conditions’
[08:24:53.169]   - Field: ‘expr’
[08:24:53.169]   - Field: ‘uuid’
[08:24:53.169]   - Field: ‘seed’
[08:24:53.169]   - Field: ‘version’
[08:24:53.169]   - Field: ‘result’
[08:24:53.169]   - Field: ‘asynchronous’
[08:24:53.169]   - Field: ‘calls’
[08:24:53.169]   - Field: ‘globals’
[08:24:53.169]   - Field: ‘stdout’
[08:24:53.170]   - Field: ‘earlySignal’
[08:24:53.170]   - Field: ‘lazy’
[08:24:53.170]   - Field: ‘state’
[08:24:53.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:53.170] - Launch lazy future ...
[08:24:53.170] Packages needed by the future expression (n = 0): <none>
[08:24:53.170] Packages needed by future strategies (n = 0): <none>
[08:24:53.171] {
[08:24:53.171]     {
[08:24:53.171]         {
[08:24:53.171]             ...future.startTime <- base::Sys.time()
[08:24:53.171]             {
[08:24:53.171]                 {
[08:24:53.171]                   {
[08:24:53.171]                     {
[08:24:53.171]                       base::local({
[08:24:53.171]                         has_future <- base::requireNamespace("future", 
[08:24:53.171]                           quietly = TRUE)
[08:24:53.171]                         if (has_future) {
[08:24:53.171]                           ns <- base::getNamespace("future")
[08:24:53.171]                           version <- ns[[".package"]][["version"]]
[08:24:53.171]                           if (is.null(version)) 
[08:24:53.171]                             version <- utils::packageVersion("future")
[08:24:53.171]                         }
[08:24:53.171]                         else {
[08:24:53.171]                           version <- NULL
[08:24:53.171]                         }
[08:24:53.171]                         if (!has_future || version < "1.8.0") {
[08:24:53.171]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:53.171]                             "", base::R.version$version.string), 
[08:24:53.171]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:53.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:53.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:53.171]                               "release", "version")], collapse = " "), 
[08:24:53.171]                             hostname = base::Sys.info()[["nodename"]])
[08:24:53.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:53.171]                             info)
[08:24:53.171]                           info <- base::paste(info, collapse = "; ")
[08:24:53.171]                           if (!has_future) {
[08:24:53.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:53.171]                               info)
[08:24:53.171]                           }
[08:24:53.171]                           else {
[08:24:53.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:53.171]                               info, version)
[08:24:53.171]                           }
[08:24:53.171]                           base::stop(msg)
[08:24:53.171]                         }
[08:24:53.171]                       })
[08:24:53.171]                     }
[08:24:53.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:53.171]                     base::options(mc.cores = 1L)
[08:24:53.171]                   }
[08:24:53.171]                   ...future.strategy.old <- future::plan("list")
[08:24:53.171]                   options(future.plan = NULL)
[08:24:53.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:53.171]                 }
[08:24:53.171]                 ...future.workdir <- getwd()
[08:24:53.171]             }
[08:24:53.171]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:53.171]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:53.171]         }
[08:24:53.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:53.171]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:53.171]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:53.171]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:53.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:53.171]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:53.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:53.171]             base::names(...future.oldOptions))
[08:24:53.171]     }
[08:24:53.171]     if (FALSE) {
[08:24:53.171]     }
[08:24:53.171]     else {
[08:24:53.171]         if (TRUE) {
[08:24:53.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:53.171]                 open = "w")
[08:24:53.171]         }
[08:24:53.171]         else {
[08:24:53.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:53.171]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:53.171]         }
[08:24:53.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:53.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:53.171]             base::sink(type = "output", split = FALSE)
[08:24:53.171]             base::close(...future.stdout)
[08:24:53.171]         }, add = TRUE)
[08:24:53.171]     }
[08:24:53.171]     ...future.frame <- base::sys.nframe()
[08:24:53.171]     ...future.conditions <- base::list()
[08:24:53.171]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:53.171]     if (FALSE) {
[08:24:53.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:53.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:53.171]     }
[08:24:53.171]     ...future.result <- base::tryCatch({
[08:24:53.171]         base::withCallingHandlers({
[08:24:53.171]             ...future.value <- base::withVisible(base::local({
[08:24:53.171]                 withCallingHandlers({
[08:24:53.171]                   {
[08:24:53.171]                     do.call(function(...) {
[08:24:53.171]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.171]                       if (!identical(...future.globals.maxSize.org, 
[08:24:53.171]                         ...future.globals.maxSize)) {
[08:24:53.171]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.171]                         on.exit(options(oopts), add = TRUE)
[08:24:53.171]                       }
[08:24:53.171]                       {
[08:24:53.171]                         lapply(seq_along(...future.elements_ii), 
[08:24:53.171]                           FUN = function(jj) {
[08:24:53.171]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.171]                             ...future.FUN(...future.X_jj, ...)
[08:24:53.171]                           })
[08:24:53.171]                       }
[08:24:53.171]                     }, args = future.call.arguments)
[08:24:53.171]                   }
[08:24:53.171]                 }, immediateCondition = function(cond) {
[08:24:53.171]                   save_rds <- function (object, pathname, ...) 
[08:24:53.171]                   {
[08:24:53.171]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:53.171]                     if (file_test("-f", pathname_tmp)) {
[08:24:53.171]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.171]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:53.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.171]                         fi_tmp[["mtime"]])
[08:24:53.171]                     }
[08:24:53.171]                     tryCatch({
[08:24:53.171]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:53.171]                     }, error = function(ex) {
[08:24:53.171]                       msg <- conditionMessage(ex)
[08:24:53.171]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.171]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:53.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.171]                         fi_tmp[["mtime"]], msg)
[08:24:53.171]                       ex$message <- msg
[08:24:53.171]                       stop(ex)
[08:24:53.171]                     })
[08:24:53.171]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:53.171]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:53.171]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:53.171]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.171]                       fi <- file.info(pathname)
[08:24:53.171]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:53.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.171]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:53.171]                         fi[["size"]], fi[["mtime"]])
[08:24:53.171]                       stop(msg)
[08:24:53.171]                     }
[08:24:53.171]                     invisible(pathname)
[08:24:53.171]                   }
[08:24:53.171]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:53.171]                     rootPath = tempdir()) 
[08:24:53.171]                   {
[08:24:53.171]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:53.171]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:53.171]                       tmpdir = path, fileext = ".rds")
[08:24:53.171]                     save_rds(obj, file)
[08:24:53.171]                   }
[08:24:53.171]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:53.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.171]                   {
[08:24:53.171]                     inherits <- base::inherits
[08:24:53.171]                     invokeRestart <- base::invokeRestart
[08:24:53.171]                     is.null <- base::is.null
[08:24:53.171]                     muffled <- FALSE
[08:24:53.171]                     if (inherits(cond, "message")) {
[08:24:53.171]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:53.171]                       if (muffled) 
[08:24:53.171]                         invokeRestart("muffleMessage")
[08:24:53.171]                     }
[08:24:53.171]                     else if (inherits(cond, "warning")) {
[08:24:53.171]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:53.171]                       if (muffled) 
[08:24:53.171]                         invokeRestart("muffleWarning")
[08:24:53.171]                     }
[08:24:53.171]                     else if (inherits(cond, "condition")) {
[08:24:53.171]                       if (!is.null(pattern)) {
[08:24:53.171]                         computeRestarts <- base::computeRestarts
[08:24:53.171]                         grepl <- base::grepl
[08:24:53.171]                         restarts <- computeRestarts(cond)
[08:24:53.171]                         for (restart in restarts) {
[08:24:53.171]                           name <- restart$name
[08:24:53.171]                           if (is.null(name)) 
[08:24:53.171]                             next
[08:24:53.171]                           if (!grepl(pattern, name)) 
[08:24:53.171]                             next
[08:24:53.171]                           invokeRestart(restart)
[08:24:53.171]                           muffled <- TRUE
[08:24:53.171]                           break
[08:24:53.171]                         }
[08:24:53.171]                       }
[08:24:53.171]                     }
[08:24:53.171]                     invisible(muffled)
[08:24:53.171]                   }
[08:24:53.171]                   muffleCondition(cond)
[08:24:53.171]                 })
[08:24:53.171]             }))
[08:24:53.171]             future::FutureResult(value = ...future.value$value, 
[08:24:53.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.171]                   ...future.rng), globalenv = if (FALSE) 
[08:24:53.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:53.171]                     ...future.globalenv.names))
[08:24:53.171]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:53.171]         }, condition = base::local({
[08:24:53.171]             c <- base::c
[08:24:53.171]             inherits <- base::inherits
[08:24:53.171]             invokeRestart <- base::invokeRestart
[08:24:53.171]             length <- base::length
[08:24:53.171]             list <- base::list
[08:24:53.171]             seq.int <- base::seq.int
[08:24:53.171]             signalCondition <- base::signalCondition
[08:24:53.171]             sys.calls <- base::sys.calls
[08:24:53.171]             `[[` <- base::`[[`
[08:24:53.171]             `+` <- base::`+`
[08:24:53.171]             `<<-` <- base::`<<-`
[08:24:53.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:53.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:53.171]                   3L)]
[08:24:53.171]             }
[08:24:53.171]             function(cond) {
[08:24:53.171]                 is_error <- inherits(cond, "error")
[08:24:53.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:53.171]                   NULL)
[08:24:53.171]                 if (is_error) {
[08:24:53.171]                   sessionInformation <- function() {
[08:24:53.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:53.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:53.171]                       search = base::search(), system = base::Sys.info())
[08:24:53.171]                   }
[08:24:53.171]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:53.171]                     cond$call), session = sessionInformation(), 
[08:24:53.171]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:53.171]                   signalCondition(cond)
[08:24:53.171]                 }
[08:24:53.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:53.171]                 "immediateCondition"))) {
[08:24:53.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:53.171]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:53.171]                   if (TRUE && !signal) {
[08:24:53.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.171]                     {
[08:24:53.171]                       inherits <- base::inherits
[08:24:53.171]                       invokeRestart <- base::invokeRestart
[08:24:53.171]                       is.null <- base::is.null
[08:24:53.171]                       muffled <- FALSE
[08:24:53.171]                       if (inherits(cond, "message")) {
[08:24:53.171]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.171]                         if (muffled) 
[08:24:53.171]                           invokeRestart("muffleMessage")
[08:24:53.171]                       }
[08:24:53.171]                       else if (inherits(cond, "warning")) {
[08:24:53.171]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.171]                         if (muffled) 
[08:24:53.171]                           invokeRestart("muffleWarning")
[08:24:53.171]                       }
[08:24:53.171]                       else if (inherits(cond, "condition")) {
[08:24:53.171]                         if (!is.null(pattern)) {
[08:24:53.171]                           computeRestarts <- base::computeRestarts
[08:24:53.171]                           grepl <- base::grepl
[08:24:53.171]                           restarts <- computeRestarts(cond)
[08:24:53.171]                           for (restart in restarts) {
[08:24:53.171]                             name <- restart$name
[08:24:53.171]                             if (is.null(name)) 
[08:24:53.171]                               next
[08:24:53.171]                             if (!grepl(pattern, name)) 
[08:24:53.171]                               next
[08:24:53.171]                             invokeRestart(restart)
[08:24:53.171]                             muffled <- TRUE
[08:24:53.171]                             break
[08:24:53.171]                           }
[08:24:53.171]                         }
[08:24:53.171]                       }
[08:24:53.171]                       invisible(muffled)
[08:24:53.171]                     }
[08:24:53.171]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.171]                   }
[08:24:53.171]                 }
[08:24:53.171]                 else {
[08:24:53.171]                   if (TRUE) {
[08:24:53.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.171]                     {
[08:24:53.171]                       inherits <- base::inherits
[08:24:53.171]                       invokeRestart <- base::invokeRestart
[08:24:53.171]                       is.null <- base::is.null
[08:24:53.171]                       muffled <- FALSE
[08:24:53.171]                       if (inherits(cond, "message")) {
[08:24:53.171]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.171]                         if (muffled) 
[08:24:53.171]                           invokeRestart("muffleMessage")
[08:24:53.171]                       }
[08:24:53.171]                       else if (inherits(cond, "warning")) {
[08:24:53.171]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.171]                         if (muffled) 
[08:24:53.171]                           invokeRestart("muffleWarning")
[08:24:53.171]                       }
[08:24:53.171]                       else if (inherits(cond, "condition")) {
[08:24:53.171]                         if (!is.null(pattern)) {
[08:24:53.171]                           computeRestarts <- base::computeRestarts
[08:24:53.171]                           grepl <- base::grepl
[08:24:53.171]                           restarts <- computeRestarts(cond)
[08:24:53.171]                           for (restart in restarts) {
[08:24:53.171]                             name <- restart$name
[08:24:53.171]                             if (is.null(name)) 
[08:24:53.171]                               next
[08:24:53.171]                             if (!grepl(pattern, name)) 
[08:24:53.171]                               next
[08:24:53.171]                             invokeRestart(restart)
[08:24:53.171]                             muffled <- TRUE
[08:24:53.171]                             break
[08:24:53.171]                           }
[08:24:53.171]                         }
[08:24:53.171]                       }
[08:24:53.171]                       invisible(muffled)
[08:24:53.171]                     }
[08:24:53.171]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.171]                   }
[08:24:53.171]                 }
[08:24:53.171]             }
[08:24:53.171]         }))
[08:24:53.171]     }, error = function(ex) {
[08:24:53.171]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:53.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.171]                 ...future.rng), started = ...future.startTime, 
[08:24:53.171]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:53.171]             version = "1.8"), class = "FutureResult")
[08:24:53.171]     }, finally = {
[08:24:53.171]         if (!identical(...future.workdir, getwd())) 
[08:24:53.171]             setwd(...future.workdir)
[08:24:53.171]         {
[08:24:53.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:53.171]                 ...future.oldOptions$nwarnings <- NULL
[08:24:53.171]             }
[08:24:53.171]             base::options(...future.oldOptions)
[08:24:53.171]             if (.Platform$OS.type == "windows") {
[08:24:53.171]                 old_names <- names(...future.oldEnvVars)
[08:24:53.171]                 envs <- base::Sys.getenv()
[08:24:53.171]                 names <- names(envs)
[08:24:53.171]                 common <- intersect(names, old_names)
[08:24:53.171]                 added <- setdiff(names, old_names)
[08:24:53.171]                 removed <- setdiff(old_names, names)
[08:24:53.171]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:53.171]                   envs[common]]
[08:24:53.171]                 NAMES <- toupper(changed)
[08:24:53.171]                 args <- list()
[08:24:53.171]                 for (kk in seq_along(NAMES)) {
[08:24:53.171]                   name <- changed[[kk]]
[08:24:53.171]                   NAME <- NAMES[[kk]]
[08:24:53.171]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.171]                     next
[08:24:53.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.171]                 }
[08:24:53.171]                 NAMES <- toupper(added)
[08:24:53.171]                 for (kk in seq_along(NAMES)) {
[08:24:53.171]                   name <- added[[kk]]
[08:24:53.171]                   NAME <- NAMES[[kk]]
[08:24:53.171]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.171]                     next
[08:24:53.171]                   args[[name]] <- ""
[08:24:53.171]                 }
[08:24:53.171]                 NAMES <- toupper(removed)
[08:24:53.171]                 for (kk in seq_along(NAMES)) {
[08:24:53.171]                   name <- removed[[kk]]
[08:24:53.171]                   NAME <- NAMES[[kk]]
[08:24:53.171]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.171]                     next
[08:24:53.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.171]                 }
[08:24:53.171]                 if (length(args) > 0) 
[08:24:53.171]                   base::do.call(base::Sys.setenv, args = args)
[08:24:53.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:53.171]             }
[08:24:53.171]             else {
[08:24:53.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:53.171]             }
[08:24:53.171]             {
[08:24:53.171]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:53.171]                   0L) {
[08:24:53.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:53.171]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:53.171]                   base::options(opts)
[08:24:53.171]                 }
[08:24:53.171]                 {
[08:24:53.171]                   {
[08:24:53.171]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:53.171]                     NULL
[08:24:53.171]                   }
[08:24:53.171]                   options(future.plan = NULL)
[08:24:53.171]                   if (is.na(NA_character_)) 
[08:24:53.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:53.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:53.171]                     .init = FALSE)
[08:24:53.171]                 }
[08:24:53.171]             }
[08:24:53.171]         }
[08:24:53.171]     })
[08:24:53.171]     if (TRUE) {
[08:24:53.171]         base::sink(type = "output", split = FALSE)
[08:24:53.171]         if (TRUE) {
[08:24:53.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:53.171]         }
[08:24:53.171]         else {
[08:24:53.171]             ...future.result["stdout"] <- base::list(NULL)
[08:24:53.171]         }
[08:24:53.171]         base::close(...future.stdout)
[08:24:53.171]         ...future.stdout <- NULL
[08:24:53.171]     }
[08:24:53.171]     ...future.result$conditions <- ...future.conditions
[08:24:53.171]     ...future.result$finished <- base::Sys.time()
[08:24:53.171]     ...future.result
[08:24:53.171] }
[08:24:53.173] assign_globals() ...
[08:24:53.174] List of 5
[08:24:53.174]  $ future.call.arguments    : list()
[08:24:53.174]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.174]  $ ...future.FUN            :function (x)  
[08:24:53.174]  $ ...future.elements_ii    :List of 1
[08:24:53.174]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[08:24:53.174]  $ ...future.seeds_ii       : NULL
[08:24:53.174]  $ ...future.globals.maxSize: num Inf
[08:24:53.174]  - attr(*, "resolved")= logi FALSE
[08:24:53.174]  - attr(*, "total_size")= num NA
[08:24:53.174]  - attr(*, "where")=List of 5
[08:24:53.174]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:53.174]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:53.174]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:53.174]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:53.174]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:53.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.174]  - attr(*, "already-done")= logi TRUE
[08:24:53.181] - copied ‘future.call.arguments’ to environment
[08:24:53.181] - copied ‘...future.FUN’ to environment
[08:24:53.182] - copied ‘...future.elements_ii’ to environment
[08:24:53.182] - copied ‘...future.seeds_ii’ to environment
[08:24:53.182] - copied ‘...future.globals.maxSize’ to environment
[08:24:53.182] assign_globals() ... done
[08:24:53.182] requestCore(): workers = 2
[08:24:53.185] MulticoreFuture started
[08:24:53.185] - Launch lazy future ... done
[08:24:53.185] run() for ‘MulticoreFuture’ ... done
[08:24:53.186] plan(): Setting new future strategy stack:
[08:24:53.186] Created future:
[08:24:53.186] List of future strategies:
[08:24:53.186] 1. sequential:
[08:24:53.186]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.186]    - tweaked: FALSE
[08:24:53.186]    - call: NULL
[08:24:53.187] plan(): nbrOfWorkers() = 1
[08:24:53.190] plan(): Setting new future strategy stack:
[08:24:53.190] List of future strategies:
[08:24:53.190] 1. multicore:
[08:24:53.190]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:53.190]    - tweaked: FALSE
[08:24:53.190]    - call: plan(strategy)
[08:24:53.194] plan(): nbrOfWorkers() = 2
[08:24:53.186] MulticoreFuture:
[08:24:53.186] Label: ‘future_apply-1’
[08:24:53.186] Expression:
[08:24:53.186] {
[08:24:53.186]     do.call(function(...) {
[08:24:53.186]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.186]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.186]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.186]             on.exit(options(oopts), add = TRUE)
[08:24:53.186]         }
[08:24:53.186]         {
[08:24:53.186]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.186]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.186]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.186]             })
[08:24:53.186]         }
[08:24:53.186]     }, args = future.call.arguments)
[08:24:53.186] }
[08:24:53.186] Lazy evaluation: FALSE
[08:24:53.186] Asynchronous evaluation: TRUE
[08:24:53.186] Local evaluation: TRUE
[08:24:53.186] Environment: R_GlobalEnv
[08:24:53.186] Capture standard output: TRUE
[08:24:53.186] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:53.186] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:53.186] Packages: <none>
[08:24:53.186] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:53.186] Resolved: TRUE
[08:24:53.186] Value: <not collected>
[08:24:53.186] Conditions captured: <none>
[08:24:53.186] Early signaling: FALSE
[08:24:53.186] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:53.186] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.195] Chunk #1 of 2 ... DONE
[08:24:53.195] Chunk #2 of 2 ...
[08:24:53.195]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:53.195]  - seeds: <none>
[08:24:53.196]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.196] getGlobalsAndPackages() ...
[08:24:53.196] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.196] Resolving globals: FALSE
[08:24:53.196] Tweak future expression to call with '...' arguments ...
[08:24:53.197] {
[08:24:53.197]     do.call(function(...) {
[08:24:53.197]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.197]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.197]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.197]             on.exit(options(oopts), add = TRUE)
[08:24:53.197]         }
[08:24:53.197]         {
[08:24:53.197]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.197]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.197]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.197]             })
[08:24:53.197]         }
[08:24:53.197]     }, args = future.call.arguments)
[08:24:53.197] }
[08:24:53.197] Tweak future expression to call with '...' arguments ... DONE
[08:24:53.198] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.198] 
[08:24:53.198] getGlobalsAndPackages() ... DONE
[08:24:53.198] run() for ‘Future’ ...
[08:24:53.199] - state: ‘created’
[08:24:53.199] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:53.202] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:53.202]   - Field: ‘label’
[08:24:53.202]   - Field: ‘local’
[08:24:53.202]   - Field: ‘owner’
[08:24:53.202]   - Field: ‘envir’
[08:24:53.203]   - Field: ‘workers’
[08:24:53.203]   - Field: ‘packages’
[08:24:53.203]   - Field: ‘gc’
[08:24:53.203]   - Field: ‘job’
[08:24:53.203]   - Field: ‘conditions’
[08:24:53.203]   - Field: ‘expr’
[08:24:53.203]   - Field: ‘uuid’
[08:24:53.204]   - Field: ‘seed’
[08:24:53.204]   - Field: ‘version’
[08:24:53.204]   - Field: ‘result’
[08:24:53.204]   - Field: ‘asynchronous’
[08:24:53.204]   - Field: ‘calls’
[08:24:53.204]   - Field: ‘globals’
[08:24:53.204]   - Field: ‘stdout’
[08:24:53.205]   - Field: ‘earlySignal’
[08:24:53.205]   - Field: ‘lazy’
[08:24:53.205]   - Field: ‘state’
[08:24:53.205] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:53.205] - Launch lazy future ...
[08:24:53.206] Packages needed by the future expression (n = 0): <none>
[08:24:53.206] Packages needed by future strategies (n = 0): <none>
[08:24:53.207] {
[08:24:53.207]     {
[08:24:53.207]         {
[08:24:53.207]             ...future.startTime <- base::Sys.time()
[08:24:53.207]             {
[08:24:53.207]                 {
[08:24:53.207]                   {
[08:24:53.207]                     {
[08:24:53.207]                       base::local({
[08:24:53.207]                         has_future <- base::requireNamespace("future", 
[08:24:53.207]                           quietly = TRUE)
[08:24:53.207]                         if (has_future) {
[08:24:53.207]                           ns <- base::getNamespace("future")
[08:24:53.207]                           version <- ns[[".package"]][["version"]]
[08:24:53.207]                           if (is.null(version)) 
[08:24:53.207]                             version <- utils::packageVersion("future")
[08:24:53.207]                         }
[08:24:53.207]                         else {
[08:24:53.207]                           version <- NULL
[08:24:53.207]                         }
[08:24:53.207]                         if (!has_future || version < "1.8.0") {
[08:24:53.207]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:53.207]                             "", base::R.version$version.string), 
[08:24:53.207]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:53.207]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:53.207]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:53.207]                               "release", "version")], collapse = " "), 
[08:24:53.207]                             hostname = base::Sys.info()[["nodename"]])
[08:24:53.207]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:53.207]                             info)
[08:24:53.207]                           info <- base::paste(info, collapse = "; ")
[08:24:53.207]                           if (!has_future) {
[08:24:53.207]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:53.207]                               info)
[08:24:53.207]                           }
[08:24:53.207]                           else {
[08:24:53.207]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:53.207]                               info, version)
[08:24:53.207]                           }
[08:24:53.207]                           base::stop(msg)
[08:24:53.207]                         }
[08:24:53.207]                       })
[08:24:53.207]                     }
[08:24:53.207]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:53.207]                     base::options(mc.cores = 1L)
[08:24:53.207]                   }
[08:24:53.207]                   ...future.strategy.old <- future::plan("list")
[08:24:53.207]                   options(future.plan = NULL)
[08:24:53.207]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.207]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:53.207]                 }
[08:24:53.207]                 ...future.workdir <- getwd()
[08:24:53.207]             }
[08:24:53.207]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:53.207]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:53.207]         }
[08:24:53.207]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:53.207]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:53.207]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:53.207]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:53.207]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:53.207]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:53.207]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:53.207]             base::names(...future.oldOptions))
[08:24:53.207]     }
[08:24:53.207]     if (FALSE) {
[08:24:53.207]     }
[08:24:53.207]     else {
[08:24:53.207]         if (TRUE) {
[08:24:53.207]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:53.207]                 open = "w")
[08:24:53.207]         }
[08:24:53.207]         else {
[08:24:53.207]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:53.207]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:53.207]         }
[08:24:53.207]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:53.207]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:53.207]             base::sink(type = "output", split = FALSE)
[08:24:53.207]             base::close(...future.stdout)
[08:24:53.207]         }, add = TRUE)
[08:24:53.207]     }
[08:24:53.207]     ...future.frame <- base::sys.nframe()
[08:24:53.207]     ...future.conditions <- base::list()
[08:24:53.207]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:53.207]     if (FALSE) {
[08:24:53.207]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:53.207]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:53.207]     }
[08:24:53.207]     ...future.result <- base::tryCatch({
[08:24:53.207]         base::withCallingHandlers({
[08:24:53.207]             ...future.value <- base::withVisible(base::local({
[08:24:53.207]                 withCallingHandlers({
[08:24:53.207]                   {
[08:24:53.207]                     do.call(function(...) {
[08:24:53.207]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.207]                       if (!identical(...future.globals.maxSize.org, 
[08:24:53.207]                         ...future.globals.maxSize)) {
[08:24:53.207]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.207]                         on.exit(options(oopts), add = TRUE)
[08:24:53.207]                       }
[08:24:53.207]                       {
[08:24:53.207]                         lapply(seq_along(...future.elements_ii), 
[08:24:53.207]                           FUN = function(jj) {
[08:24:53.207]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.207]                             ...future.FUN(...future.X_jj, ...)
[08:24:53.207]                           })
[08:24:53.207]                       }
[08:24:53.207]                     }, args = future.call.arguments)
[08:24:53.207]                   }
[08:24:53.207]                 }, immediateCondition = function(cond) {
[08:24:53.207]                   save_rds <- function (object, pathname, ...) 
[08:24:53.207]                   {
[08:24:53.207]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:53.207]                     if (file_test("-f", pathname_tmp)) {
[08:24:53.207]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.207]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:53.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.207]                         fi_tmp[["mtime"]])
[08:24:53.207]                     }
[08:24:53.207]                     tryCatch({
[08:24:53.207]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:53.207]                     }, error = function(ex) {
[08:24:53.207]                       msg <- conditionMessage(ex)
[08:24:53.207]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.207]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:53.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.207]                         fi_tmp[["mtime"]], msg)
[08:24:53.207]                       ex$message <- msg
[08:24:53.207]                       stop(ex)
[08:24:53.207]                     })
[08:24:53.207]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:53.207]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:53.207]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:53.207]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.207]                       fi <- file.info(pathname)
[08:24:53.207]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:53.207]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.207]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:53.207]                         fi[["size"]], fi[["mtime"]])
[08:24:53.207]                       stop(msg)
[08:24:53.207]                     }
[08:24:53.207]                     invisible(pathname)
[08:24:53.207]                   }
[08:24:53.207]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:53.207]                     rootPath = tempdir()) 
[08:24:53.207]                   {
[08:24:53.207]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:53.207]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:53.207]                       tmpdir = path, fileext = ".rds")
[08:24:53.207]                     save_rds(obj, file)
[08:24:53.207]                   }
[08:24:53.207]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:53.207]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.207]                   {
[08:24:53.207]                     inherits <- base::inherits
[08:24:53.207]                     invokeRestart <- base::invokeRestart
[08:24:53.207]                     is.null <- base::is.null
[08:24:53.207]                     muffled <- FALSE
[08:24:53.207]                     if (inherits(cond, "message")) {
[08:24:53.207]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:53.207]                       if (muffled) 
[08:24:53.207]                         invokeRestart("muffleMessage")
[08:24:53.207]                     }
[08:24:53.207]                     else if (inherits(cond, "warning")) {
[08:24:53.207]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:53.207]                       if (muffled) 
[08:24:53.207]                         invokeRestart("muffleWarning")
[08:24:53.207]                     }
[08:24:53.207]                     else if (inherits(cond, "condition")) {
[08:24:53.207]                       if (!is.null(pattern)) {
[08:24:53.207]                         computeRestarts <- base::computeRestarts
[08:24:53.207]                         grepl <- base::grepl
[08:24:53.207]                         restarts <- computeRestarts(cond)
[08:24:53.207]                         for (restart in restarts) {
[08:24:53.207]                           name <- restart$name
[08:24:53.207]                           if (is.null(name)) 
[08:24:53.207]                             next
[08:24:53.207]                           if (!grepl(pattern, name)) 
[08:24:53.207]                             next
[08:24:53.207]                           invokeRestart(restart)
[08:24:53.207]                           muffled <- TRUE
[08:24:53.207]                           break
[08:24:53.207]                         }
[08:24:53.207]                       }
[08:24:53.207]                     }
[08:24:53.207]                     invisible(muffled)
[08:24:53.207]                   }
[08:24:53.207]                   muffleCondition(cond)
[08:24:53.207]                 })
[08:24:53.207]             }))
[08:24:53.207]             future::FutureResult(value = ...future.value$value, 
[08:24:53.207]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.207]                   ...future.rng), globalenv = if (FALSE) 
[08:24:53.207]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:53.207]                     ...future.globalenv.names))
[08:24:53.207]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:53.207]         }, condition = base::local({
[08:24:53.207]             c <- base::c
[08:24:53.207]             inherits <- base::inherits
[08:24:53.207]             invokeRestart <- base::invokeRestart
[08:24:53.207]             length <- base::length
[08:24:53.207]             list <- base::list
[08:24:53.207]             seq.int <- base::seq.int
[08:24:53.207]             signalCondition <- base::signalCondition
[08:24:53.207]             sys.calls <- base::sys.calls
[08:24:53.207]             `[[` <- base::`[[`
[08:24:53.207]             `+` <- base::`+`
[08:24:53.207]             `<<-` <- base::`<<-`
[08:24:53.207]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:53.207]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:53.207]                   3L)]
[08:24:53.207]             }
[08:24:53.207]             function(cond) {
[08:24:53.207]                 is_error <- inherits(cond, "error")
[08:24:53.207]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:53.207]                   NULL)
[08:24:53.207]                 if (is_error) {
[08:24:53.207]                   sessionInformation <- function() {
[08:24:53.207]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:53.207]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:53.207]                       search = base::search(), system = base::Sys.info())
[08:24:53.207]                   }
[08:24:53.207]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.207]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:53.207]                     cond$call), session = sessionInformation(), 
[08:24:53.207]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:53.207]                   signalCondition(cond)
[08:24:53.207]                 }
[08:24:53.207]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:53.207]                 "immediateCondition"))) {
[08:24:53.207]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:53.207]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.207]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:53.207]                   if (TRUE && !signal) {
[08:24:53.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.207]                     {
[08:24:53.207]                       inherits <- base::inherits
[08:24:53.207]                       invokeRestart <- base::invokeRestart
[08:24:53.207]                       is.null <- base::is.null
[08:24:53.207]                       muffled <- FALSE
[08:24:53.207]                       if (inherits(cond, "message")) {
[08:24:53.207]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.207]                         if (muffled) 
[08:24:53.207]                           invokeRestart("muffleMessage")
[08:24:53.207]                       }
[08:24:53.207]                       else if (inherits(cond, "warning")) {
[08:24:53.207]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.207]                         if (muffled) 
[08:24:53.207]                           invokeRestart("muffleWarning")
[08:24:53.207]                       }
[08:24:53.207]                       else if (inherits(cond, "condition")) {
[08:24:53.207]                         if (!is.null(pattern)) {
[08:24:53.207]                           computeRestarts <- base::computeRestarts
[08:24:53.207]                           grepl <- base::grepl
[08:24:53.207]                           restarts <- computeRestarts(cond)
[08:24:53.207]                           for (restart in restarts) {
[08:24:53.207]                             name <- restart$name
[08:24:53.207]                             if (is.null(name)) 
[08:24:53.207]                               next
[08:24:53.207]                             if (!grepl(pattern, name)) 
[08:24:53.207]                               next
[08:24:53.207]                             invokeRestart(restart)
[08:24:53.207]                             muffled <- TRUE
[08:24:53.207]                             break
[08:24:53.207]                           }
[08:24:53.207]                         }
[08:24:53.207]                       }
[08:24:53.207]                       invisible(muffled)
[08:24:53.207]                     }
[08:24:53.207]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.207]                   }
[08:24:53.207]                 }
[08:24:53.207]                 else {
[08:24:53.207]                   if (TRUE) {
[08:24:53.207]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.207]                     {
[08:24:53.207]                       inherits <- base::inherits
[08:24:53.207]                       invokeRestart <- base::invokeRestart
[08:24:53.207]                       is.null <- base::is.null
[08:24:53.207]                       muffled <- FALSE
[08:24:53.207]                       if (inherits(cond, "message")) {
[08:24:53.207]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.207]                         if (muffled) 
[08:24:53.207]                           invokeRestart("muffleMessage")
[08:24:53.207]                       }
[08:24:53.207]                       else if (inherits(cond, "warning")) {
[08:24:53.207]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.207]                         if (muffled) 
[08:24:53.207]                           invokeRestart("muffleWarning")
[08:24:53.207]                       }
[08:24:53.207]                       else if (inherits(cond, "condition")) {
[08:24:53.207]                         if (!is.null(pattern)) {
[08:24:53.207]                           computeRestarts <- base::computeRestarts
[08:24:53.207]                           grepl <- base::grepl
[08:24:53.207]                           restarts <- computeRestarts(cond)
[08:24:53.207]                           for (restart in restarts) {
[08:24:53.207]                             name <- restart$name
[08:24:53.207]                             if (is.null(name)) 
[08:24:53.207]                               next
[08:24:53.207]                             if (!grepl(pattern, name)) 
[08:24:53.207]                               next
[08:24:53.207]                             invokeRestart(restart)
[08:24:53.207]                             muffled <- TRUE
[08:24:53.207]                             break
[08:24:53.207]                           }
[08:24:53.207]                         }
[08:24:53.207]                       }
[08:24:53.207]                       invisible(muffled)
[08:24:53.207]                     }
[08:24:53.207]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.207]                   }
[08:24:53.207]                 }
[08:24:53.207]             }
[08:24:53.207]         }))
[08:24:53.207]     }, error = function(ex) {
[08:24:53.207]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:53.207]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.207]                 ...future.rng), started = ...future.startTime, 
[08:24:53.207]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:53.207]             version = "1.8"), class = "FutureResult")
[08:24:53.207]     }, finally = {
[08:24:53.207]         if (!identical(...future.workdir, getwd())) 
[08:24:53.207]             setwd(...future.workdir)
[08:24:53.207]         {
[08:24:53.207]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:53.207]                 ...future.oldOptions$nwarnings <- NULL
[08:24:53.207]             }
[08:24:53.207]             base::options(...future.oldOptions)
[08:24:53.207]             if (.Platform$OS.type == "windows") {
[08:24:53.207]                 old_names <- names(...future.oldEnvVars)
[08:24:53.207]                 envs <- base::Sys.getenv()
[08:24:53.207]                 names <- names(envs)
[08:24:53.207]                 common <- intersect(names, old_names)
[08:24:53.207]                 added <- setdiff(names, old_names)
[08:24:53.207]                 removed <- setdiff(old_names, names)
[08:24:53.207]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:53.207]                   envs[common]]
[08:24:53.207]                 NAMES <- toupper(changed)
[08:24:53.207]                 args <- list()
[08:24:53.207]                 for (kk in seq_along(NAMES)) {
[08:24:53.207]                   name <- changed[[kk]]
[08:24:53.207]                   NAME <- NAMES[[kk]]
[08:24:53.207]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.207]                     next
[08:24:53.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.207]                 }
[08:24:53.207]                 NAMES <- toupper(added)
[08:24:53.207]                 for (kk in seq_along(NAMES)) {
[08:24:53.207]                   name <- added[[kk]]
[08:24:53.207]                   NAME <- NAMES[[kk]]
[08:24:53.207]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.207]                     next
[08:24:53.207]                   args[[name]] <- ""
[08:24:53.207]                 }
[08:24:53.207]                 NAMES <- toupper(removed)
[08:24:53.207]                 for (kk in seq_along(NAMES)) {
[08:24:53.207]                   name <- removed[[kk]]
[08:24:53.207]                   NAME <- NAMES[[kk]]
[08:24:53.207]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.207]                     next
[08:24:53.207]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.207]                 }
[08:24:53.207]                 if (length(args) > 0) 
[08:24:53.207]                   base::do.call(base::Sys.setenv, args = args)
[08:24:53.207]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:53.207]             }
[08:24:53.207]             else {
[08:24:53.207]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:53.207]             }
[08:24:53.207]             {
[08:24:53.207]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:53.207]                   0L) {
[08:24:53.207]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:53.207]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:53.207]                   base::options(opts)
[08:24:53.207]                 }
[08:24:53.207]                 {
[08:24:53.207]                   {
[08:24:53.207]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:53.207]                     NULL
[08:24:53.207]                   }
[08:24:53.207]                   options(future.plan = NULL)
[08:24:53.207]                   if (is.na(NA_character_)) 
[08:24:53.207]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.207]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:53.207]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:53.207]                     .init = FALSE)
[08:24:53.207]                 }
[08:24:53.207]             }
[08:24:53.207]         }
[08:24:53.207]     })
[08:24:53.207]     if (TRUE) {
[08:24:53.207]         base::sink(type = "output", split = FALSE)
[08:24:53.207]         if (TRUE) {
[08:24:53.207]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:53.207]         }
[08:24:53.207]         else {
[08:24:53.207]             ...future.result["stdout"] <- base::list(NULL)
[08:24:53.207]         }
[08:24:53.207]         base::close(...future.stdout)
[08:24:53.207]         ...future.stdout <- NULL
[08:24:53.207]     }
[08:24:53.207]     ...future.result$conditions <- ...future.conditions
[08:24:53.207]     ...future.result$finished <- base::Sys.time()
[08:24:53.207]     ...future.result
[08:24:53.207] }
[08:24:53.210] assign_globals() ...
[08:24:53.210] List of 5
[08:24:53.210]  $ future.call.arguments    : list()
[08:24:53.210]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.210]  $ ...future.FUN            :function (x)  
[08:24:53.210]  $ ...future.elements_ii    :List of 1
[08:24:53.210]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[08:24:53.210]  $ ...future.seeds_ii       : NULL
[08:24:53.210]  $ ...future.globals.maxSize: num Inf
[08:24:53.210]  - attr(*, "resolved")= logi FALSE
[08:24:53.210]  - attr(*, "total_size")= num NA
[08:24:53.210]  - attr(*, "where")=List of 5
[08:24:53.210]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:53.210]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:53.210]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:53.210]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:53.210]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:53.210]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.210]  - attr(*, "already-done")= logi TRUE
[08:24:53.218] - copied ‘future.call.arguments’ to environment
[08:24:53.218] - copied ‘...future.FUN’ to environment
[08:24:53.218] - copied ‘...future.elements_ii’ to environment
[08:24:53.218] - copied ‘...future.seeds_ii’ to environment
[08:24:53.219] - copied ‘...future.globals.maxSize’ to environment
[08:24:53.219] assign_globals() ... done
[08:24:53.219] requestCore(): workers = 2
[08:24:53.221] MulticoreFuture started
[08:24:53.222] - Launch lazy future ... done
[08:24:53.222] run() for ‘MulticoreFuture’ ... done
[08:24:53.222] Created future:
[08:24:53.223] plan(): Setting new future strategy stack:
[08:24:53.223] List of future strategies:
[08:24:53.223] 1. sequential:
[08:24:53.223]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.223]    - tweaked: FALSE
[08:24:53.223]    - call: NULL
[08:24:53.224] plan(): nbrOfWorkers() = 1
[08:24:53.226] plan(): Setting new future strategy stack:
[08:24:53.226] List of future strategies:
[08:24:53.226] 1. multicore:
[08:24:53.226]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:53.226]    - tweaked: FALSE
[08:24:53.226]    - call: plan(strategy)
[08:24:53.234] plan(): nbrOfWorkers() = 2
[08:24:53.223] MulticoreFuture:
[08:24:53.223] Label: ‘future_apply-2’
[08:24:53.223] Expression:
[08:24:53.223] {
[08:24:53.223]     do.call(function(...) {
[08:24:53.223]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.223]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.223]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.223]             on.exit(options(oopts), add = TRUE)
[08:24:53.223]         }
[08:24:53.223]         {
[08:24:53.223]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.223]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.223]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.223]             })
[08:24:53.223]         }
[08:24:53.223]     }, args = future.call.arguments)
[08:24:53.223] }
[08:24:53.223] Lazy evaluation: FALSE
[08:24:53.223] Asynchronous evaluation: TRUE
[08:24:53.223] Local evaluation: TRUE
[08:24:53.223] Environment: R_GlobalEnv
[08:24:53.223] Capture standard output: TRUE
[08:24:53.223] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:53.223] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:53.223] Packages: <none>
[08:24:53.223] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:53.223] Resolved: FALSE
[08:24:53.223] Value: <not collected>
[08:24:53.223] Conditions captured: <none>
[08:24:53.223] Early signaling: FALSE
[08:24:53.223] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:53.223] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.235] Chunk #2 of 2 ... DONE
[08:24:53.235] Launching 2 futures (chunks) ... DONE
[08:24:53.235] Resolving 2 futures (chunks) ...
[08:24:53.236] resolve() on list ...
[08:24:53.236]  recursive: 0
[08:24:53.236]  length: 2
[08:24:53.236] 
[08:24:53.236] Future #1
[08:24:53.237] result() for MulticoreFuture ...
[08:24:53.240] result() for MulticoreFuture ...
[08:24:53.241] result() for MulticoreFuture ... done
[08:24:53.241] result() for MulticoreFuture ... done
[08:24:53.241] result() for MulticoreFuture ...
[08:24:53.242] result() for MulticoreFuture ... done
[08:24:53.242] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:53.243] - nx: 2
[08:24:53.243] - relay: TRUE
[08:24:53.243] - stdout: TRUE
[08:24:53.244] - signal: TRUE
[08:24:53.244] - resignal: FALSE
[08:24:53.244] - force: TRUE
[08:24:53.244] - relayed: [n=2] FALSE, FALSE
[08:24:53.245] - queued futures: [n=2] FALSE, FALSE
[08:24:53.245]  - until=1
[08:24:53.245]  - relaying element #1
[08:24:53.246] result() for MulticoreFuture ...
[08:24:53.246] result() for MulticoreFuture ... done
[08:24:53.246] result() for MulticoreFuture ...
[08:24:53.247] result() for MulticoreFuture ... done
[08:24:53.247] result() for MulticoreFuture ...
[08:24:53.247] result() for MulticoreFuture ... done
[08:24:53.248] result() for MulticoreFuture ...
[08:24:53.248] result() for MulticoreFuture ... done
[08:24:53.248] - relayed: [n=2] TRUE, FALSE
[08:24:53.248] - queued futures: [n=2] TRUE, FALSE
[08:24:53.248] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:53.249]  length: 1 (resolved future 1)
[08:24:53.249] Future #2
[08:24:53.249] result() for MulticoreFuture ...
[08:24:53.250] result() for MulticoreFuture ...
[08:24:53.250] result() for MulticoreFuture ... done
[08:24:53.250] result() for MulticoreFuture ... done
[08:24:53.250] result() for MulticoreFuture ...
[08:24:53.251] result() for MulticoreFuture ... done
[08:24:53.251] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:53.251] - nx: 2
[08:24:53.251] - relay: TRUE
[08:24:53.251] - stdout: TRUE
[08:24:53.251] - signal: TRUE
[08:24:53.252] - resignal: FALSE
[08:24:53.252] - force: TRUE
[08:24:53.252] - relayed: [n=2] TRUE, FALSE
[08:24:53.252] - queued futures: [n=2] TRUE, FALSE
[08:24:53.252]  - until=2
[08:24:53.252]  - relaying element #2
[08:24:53.252] result() for MulticoreFuture ...
[08:24:53.252] result() for MulticoreFuture ... done
[08:24:53.252] result() for MulticoreFuture ...
[08:24:53.253] result() for MulticoreFuture ... done
[08:24:53.253] result() for MulticoreFuture ...
[08:24:53.253] result() for MulticoreFuture ... done
[08:24:53.253] result() for MulticoreFuture ...
[08:24:53.253] result() for MulticoreFuture ... done
[08:24:53.253] - relayed: [n=2] TRUE, TRUE
[08:24:53.253] - queued futures: [n=2] TRUE, TRUE
[08:24:53.253] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:53.254]  length: 0 (resolved future 2)
[08:24:53.254] Relaying remaining futures
[08:24:53.254] signalConditionsASAP(NULL, pos=0) ...
[08:24:53.254] - nx: 2
[08:24:53.254] - relay: TRUE
[08:24:53.254] - stdout: TRUE
[08:24:53.254] - signal: TRUE
[08:24:53.254] - resignal: FALSE
[08:24:53.254] - force: TRUE
[08:24:53.254] - relayed: [n=2] TRUE, TRUE
[08:24:53.255] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:53.255] - relayed: [n=2] TRUE, TRUE
[08:24:53.255] - queued futures: [n=2] TRUE, TRUE
[08:24:53.255] signalConditionsASAP(NULL, pos=0) ... done
[08:24:53.255] resolve() on list ... DONE
[08:24:53.255] result() for MulticoreFuture ...
[08:24:53.255] result() for MulticoreFuture ... done
[08:24:53.255] result() for MulticoreFuture ...
[08:24:53.255] result() for MulticoreFuture ... done
[08:24:53.256] result() for MulticoreFuture ...
[08:24:53.256] result() for MulticoreFuture ... done
[08:24:53.256] result() for MulticoreFuture ...
[08:24:53.256] result() for MulticoreFuture ... done
[08:24:53.256]  - Number of value chunks collected: 2
[08:24:53.256] Resolving 2 futures (chunks) ... DONE
[08:24:53.256] Reducing values from 2 chunks ...
[08:24:53.256]  - Number of values collected after concatenation: 2
[08:24:53.256]  - Number of values expected: 2
[08:24:53.257] Reducing values from 2 chunks ... DONE
[08:24:53.257] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[08:24:53.257] getGlobalsAndPackagesXApply() ...
[08:24:53.257]  - future.globals: TRUE
[08:24:53.257] getGlobalsAndPackages() ...
[08:24:53.257] Searching for globals...
[08:24:53.260] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[08:24:53.261] Searching for globals ... DONE
[08:24:53.261] Resolving globals: FALSE
[08:24:53.261] The total size of the 1 globals is 1.28 KiB (1311 bytes)
[08:24:53.262] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 1.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.28 KiB of class ‘function’)
[08:24:53.262] - globals: [1] ‘FUN’
[08:24:53.262] 
[08:24:53.262] getGlobalsAndPackages() ... DONE
[08:24:53.262]  - globals found/used: [n=1] ‘FUN’
[08:24:53.262]  - needed namespaces: [n=0] 
[08:24:53.262] Finding globals ... DONE
[08:24:53.263]  - use_args: TRUE
[08:24:53.263]  - Getting '...' globals ...
[08:24:53.263] resolve() on list ...
[08:24:53.263]  recursive: 0
[08:24:53.263]  length: 1
[08:24:53.263]  elements: ‘...’
[08:24:53.264]  length: 0 (resolved future 1)
[08:24:53.264] resolve() on list ... DONE
[08:24:53.264]    - '...' content: [n=0] 
[08:24:53.264] List of 1
[08:24:53.264]  $ ...: list()
[08:24:53.264]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.264]  - attr(*, "where")=List of 1
[08:24:53.264]   ..$ ...:<environment: 0x56540d6e2710> 
[08:24:53.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.264]  - attr(*, "resolved")= logi TRUE
[08:24:53.264]  - attr(*, "total_size")= num NA
[08:24:53.267]  - Getting '...' globals ... DONE
[08:24:53.267] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:53.267] List of 2
[08:24:53.267]  $ ...future.FUN:function (x)  
[08:24:53.267]  $ ...          : list()
[08:24:53.267]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.267]  - attr(*, "where")=List of 2
[08:24:53.267]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:53.267]   ..$ ...          :<environment: 0x56540d6e2710> 
[08:24:53.267]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.267]  - attr(*, "resolved")= logi FALSE
[08:24:53.267]  - attr(*, "total_size")= num 4449
[08:24:53.272] Packages to be attached in all futures: [n=0] 
[08:24:53.272] getGlobalsAndPackagesXApply() ... DONE
[08:24:53.275] future_lapply() ...
[08:24:53.278] Number of chunks: 2
[08:24:53.278] getGlobalsAndPackagesXApply() ...
[08:24:53.278]  - future.globals: <name-value list> with names ‘list()’
[08:24:53.279]  - use_args: TRUE
[08:24:53.279] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:53.279] List of 2
[08:24:53.279]  $ ...          : list()
[08:24:53.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.279]  $ ...future.FUN:function (x)  
[08:24:53.279]  - attr(*, "where")=List of 2
[08:24:53.279]   ..$ ...          :<environment: 0x56540d6e2710> 
[08:24:53.279]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[08:24:53.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.279]  - attr(*, "resolved")= logi FALSE
[08:24:53.279]  - attr(*, "total_size")= num NA
[08:24:53.282] Packages to be attached in all futures: [n=0] 
[08:24:53.282] getGlobalsAndPackagesXApply() ... DONE
[08:24:53.282] Number of futures (= number of chunks): 2
[08:24:53.282] Launching 2 futures (chunks) ...
[08:24:53.282] Chunk #1 of 2 ...
[08:24:53.282]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:53.282]  - seeds: <none>
[08:24:53.283]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.283] getGlobalsAndPackages() ...
[08:24:53.283] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.283] Resolving globals: FALSE
[08:24:53.283] Tweak future expression to call with '...' arguments ...
[08:24:53.283] {
[08:24:53.283]     do.call(function(...) {
[08:24:53.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.283]             on.exit(options(oopts), add = TRUE)
[08:24:53.283]         }
[08:24:53.283]         {
[08:24:53.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.283]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.283]             })
[08:24:53.283]         }
[08:24:53.283]     }, args = future.call.arguments)
[08:24:53.283] }
[08:24:53.283] Tweak future expression to call with '...' arguments ... DONE
[08:24:53.284] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.284] 
[08:24:53.284] getGlobalsAndPackages() ... DONE
[08:24:53.284] run() for ‘Future’ ...
[08:24:53.284] - state: ‘created’
[08:24:53.285] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:53.286] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:53.286]   - Field: ‘label’
[08:24:53.287]   - Field: ‘local’
[08:24:53.287]   - Field: ‘owner’
[08:24:53.287]   - Field: ‘envir’
[08:24:53.287]   - Field: ‘workers’
[08:24:53.287]   - Field: ‘packages’
[08:24:53.287]   - Field: ‘gc’
[08:24:53.287]   - Field: ‘job’
[08:24:53.287]   - Field: ‘conditions’
[08:24:53.287]   - Field: ‘expr’
[08:24:53.287]   - Field: ‘uuid’
[08:24:53.287]   - Field: ‘seed’
[08:24:53.288]   - Field: ‘version’
[08:24:53.288]   - Field: ‘result’
[08:24:53.288]   - Field: ‘asynchronous’
[08:24:53.288]   - Field: ‘calls’
[08:24:53.288]   - Field: ‘globals’
[08:24:53.288]   - Field: ‘stdout’
[08:24:53.288]   - Field: ‘earlySignal’
[08:24:53.288]   - Field: ‘lazy’
[08:24:53.288]   - Field: ‘state’
[08:24:53.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:53.288] - Launch lazy future ...
[08:24:53.289] Packages needed by the future expression (n = 0): <none>
[08:24:53.289] Packages needed by future strategies (n = 0): <none>
[08:24:53.289] {
[08:24:53.289]     {
[08:24:53.289]         {
[08:24:53.289]             ...future.startTime <- base::Sys.time()
[08:24:53.289]             {
[08:24:53.289]                 {
[08:24:53.289]                   {
[08:24:53.289]                     {
[08:24:53.289]                       base::local({
[08:24:53.289]                         has_future <- base::requireNamespace("future", 
[08:24:53.289]                           quietly = TRUE)
[08:24:53.289]                         if (has_future) {
[08:24:53.289]                           ns <- base::getNamespace("future")
[08:24:53.289]                           version <- ns[[".package"]][["version"]]
[08:24:53.289]                           if (is.null(version)) 
[08:24:53.289]                             version <- utils::packageVersion("future")
[08:24:53.289]                         }
[08:24:53.289]                         else {
[08:24:53.289]                           version <- NULL
[08:24:53.289]                         }
[08:24:53.289]                         if (!has_future || version < "1.8.0") {
[08:24:53.289]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:53.289]                             "", base::R.version$version.string), 
[08:24:53.289]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:53.289]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:53.289]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:53.289]                               "release", "version")], collapse = " "), 
[08:24:53.289]                             hostname = base::Sys.info()[["nodename"]])
[08:24:53.289]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:53.289]                             info)
[08:24:53.289]                           info <- base::paste(info, collapse = "; ")
[08:24:53.289]                           if (!has_future) {
[08:24:53.289]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:53.289]                               info)
[08:24:53.289]                           }
[08:24:53.289]                           else {
[08:24:53.289]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:53.289]                               info, version)
[08:24:53.289]                           }
[08:24:53.289]                           base::stop(msg)
[08:24:53.289]                         }
[08:24:53.289]                       })
[08:24:53.289]                     }
[08:24:53.289]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:53.289]                     base::options(mc.cores = 1L)
[08:24:53.289]                   }
[08:24:53.289]                   ...future.strategy.old <- future::plan("list")
[08:24:53.289]                   options(future.plan = NULL)
[08:24:53.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:53.289]                 }
[08:24:53.289]                 ...future.workdir <- getwd()
[08:24:53.289]             }
[08:24:53.289]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:53.289]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:53.289]         }
[08:24:53.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:53.289]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:53.289]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:53.289]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:53.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:53.289]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:53.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:53.289]             base::names(...future.oldOptions))
[08:24:53.289]     }
[08:24:53.289]     if (FALSE) {
[08:24:53.289]     }
[08:24:53.289]     else {
[08:24:53.289]         if (TRUE) {
[08:24:53.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:53.289]                 open = "w")
[08:24:53.289]         }
[08:24:53.289]         else {
[08:24:53.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:53.289]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:53.289]         }
[08:24:53.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:53.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:53.289]             base::sink(type = "output", split = FALSE)
[08:24:53.289]             base::close(...future.stdout)
[08:24:53.289]         }, add = TRUE)
[08:24:53.289]     }
[08:24:53.289]     ...future.frame <- base::sys.nframe()
[08:24:53.289]     ...future.conditions <- base::list()
[08:24:53.289]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:53.289]     if (FALSE) {
[08:24:53.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:53.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:53.289]     }
[08:24:53.289]     ...future.result <- base::tryCatch({
[08:24:53.289]         base::withCallingHandlers({
[08:24:53.289]             ...future.value <- base::withVisible(base::local({
[08:24:53.289]                 withCallingHandlers({
[08:24:53.289]                   {
[08:24:53.289]                     do.call(function(...) {
[08:24:53.289]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.289]                       if (!identical(...future.globals.maxSize.org, 
[08:24:53.289]                         ...future.globals.maxSize)) {
[08:24:53.289]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.289]                         on.exit(options(oopts), add = TRUE)
[08:24:53.289]                       }
[08:24:53.289]                       {
[08:24:53.289]                         lapply(seq_along(...future.elements_ii), 
[08:24:53.289]                           FUN = function(jj) {
[08:24:53.289]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.289]                             ...future.FUN(...future.X_jj, ...)
[08:24:53.289]                           })
[08:24:53.289]                       }
[08:24:53.289]                     }, args = future.call.arguments)
[08:24:53.289]                   }
[08:24:53.289]                 }, immediateCondition = function(cond) {
[08:24:53.289]                   save_rds <- function (object, pathname, ...) 
[08:24:53.289]                   {
[08:24:53.289]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:53.289]                     if (file_test("-f", pathname_tmp)) {
[08:24:53.289]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.289]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:53.289]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.289]                         fi_tmp[["mtime"]])
[08:24:53.289]                     }
[08:24:53.289]                     tryCatch({
[08:24:53.289]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:53.289]                     }, error = function(ex) {
[08:24:53.289]                       msg <- conditionMessage(ex)
[08:24:53.289]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.289]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:53.289]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.289]                         fi_tmp[["mtime"]], msg)
[08:24:53.289]                       ex$message <- msg
[08:24:53.289]                       stop(ex)
[08:24:53.289]                     })
[08:24:53.289]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:53.289]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:53.289]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:53.289]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.289]                       fi <- file.info(pathname)
[08:24:53.289]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:53.289]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.289]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:53.289]                         fi[["size"]], fi[["mtime"]])
[08:24:53.289]                       stop(msg)
[08:24:53.289]                     }
[08:24:53.289]                     invisible(pathname)
[08:24:53.289]                   }
[08:24:53.289]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:53.289]                     rootPath = tempdir()) 
[08:24:53.289]                   {
[08:24:53.289]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:53.289]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:53.289]                       tmpdir = path, fileext = ".rds")
[08:24:53.289]                     save_rds(obj, file)
[08:24:53.289]                   }
[08:24:53.289]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:53.289]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.289]                   {
[08:24:53.289]                     inherits <- base::inherits
[08:24:53.289]                     invokeRestart <- base::invokeRestart
[08:24:53.289]                     is.null <- base::is.null
[08:24:53.289]                     muffled <- FALSE
[08:24:53.289]                     if (inherits(cond, "message")) {
[08:24:53.289]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:53.289]                       if (muffled) 
[08:24:53.289]                         invokeRestart("muffleMessage")
[08:24:53.289]                     }
[08:24:53.289]                     else if (inherits(cond, "warning")) {
[08:24:53.289]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:53.289]                       if (muffled) 
[08:24:53.289]                         invokeRestart("muffleWarning")
[08:24:53.289]                     }
[08:24:53.289]                     else if (inherits(cond, "condition")) {
[08:24:53.289]                       if (!is.null(pattern)) {
[08:24:53.289]                         computeRestarts <- base::computeRestarts
[08:24:53.289]                         grepl <- base::grepl
[08:24:53.289]                         restarts <- computeRestarts(cond)
[08:24:53.289]                         for (restart in restarts) {
[08:24:53.289]                           name <- restart$name
[08:24:53.289]                           if (is.null(name)) 
[08:24:53.289]                             next
[08:24:53.289]                           if (!grepl(pattern, name)) 
[08:24:53.289]                             next
[08:24:53.289]                           invokeRestart(restart)
[08:24:53.289]                           muffled <- TRUE
[08:24:53.289]                           break
[08:24:53.289]                         }
[08:24:53.289]                       }
[08:24:53.289]                     }
[08:24:53.289]                     invisible(muffled)
[08:24:53.289]                   }
[08:24:53.289]                   muffleCondition(cond)
[08:24:53.289]                 })
[08:24:53.289]             }))
[08:24:53.289]             future::FutureResult(value = ...future.value$value, 
[08:24:53.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.289]                   ...future.rng), globalenv = if (FALSE) 
[08:24:53.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:53.289]                     ...future.globalenv.names))
[08:24:53.289]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:53.289]         }, condition = base::local({
[08:24:53.289]             c <- base::c
[08:24:53.289]             inherits <- base::inherits
[08:24:53.289]             invokeRestart <- base::invokeRestart
[08:24:53.289]             length <- base::length
[08:24:53.289]             list <- base::list
[08:24:53.289]             seq.int <- base::seq.int
[08:24:53.289]             signalCondition <- base::signalCondition
[08:24:53.289]             sys.calls <- base::sys.calls
[08:24:53.289]             `[[` <- base::`[[`
[08:24:53.289]             `+` <- base::`+`
[08:24:53.289]             `<<-` <- base::`<<-`
[08:24:53.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:53.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:53.289]                   3L)]
[08:24:53.289]             }
[08:24:53.289]             function(cond) {
[08:24:53.289]                 is_error <- inherits(cond, "error")
[08:24:53.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:53.289]                   NULL)
[08:24:53.289]                 if (is_error) {
[08:24:53.289]                   sessionInformation <- function() {
[08:24:53.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:53.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:53.289]                       search = base::search(), system = base::Sys.info())
[08:24:53.289]                   }
[08:24:53.289]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:53.289]                     cond$call), session = sessionInformation(), 
[08:24:53.289]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:53.289]                   signalCondition(cond)
[08:24:53.289]                 }
[08:24:53.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:53.289]                 "immediateCondition"))) {
[08:24:53.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:53.289]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:53.289]                   if (TRUE && !signal) {
[08:24:53.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.289]                     {
[08:24:53.289]                       inherits <- base::inherits
[08:24:53.289]                       invokeRestart <- base::invokeRestart
[08:24:53.289]                       is.null <- base::is.null
[08:24:53.289]                       muffled <- FALSE
[08:24:53.289]                       if (inherits(cond, "message")) {
[08:24:53.289]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.289]                         if (muffled) 
[08:24:53.289]                           invokeRestart("muffleMessage")
[08:24:53.289]                       }
[08:24:53.289]                       else if (inherits(cond, "warning")) {
[08:24:53.289]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.289]                         if (muffled) 
[08:24:53.289]                           invokeRestart("muffleWarning")
[08:24:53.289]                       }
[08:24:53.289]                       else if (inherits(cond, "condition")) {
[08:24:53.289]                         if (!is.null(pattern)) {
[08:24:53.289]                           computeRestarts <- base::computeRestarts
[08:24:53.289]                           grepl <- base::grepl
[08:24:53.289]                           restarts <- computeRestarts(cond)
[08:24:53.289]                           for (restart in restarts) {
[08:24:53.289]                             name <- restart$name
[08:24:53.289]                             if (is.null(name)) 
[08:24:53.289]                               next
[08:24:53.289]                             if (!grepl(pattern, name)) 
[08:24:53.289]                               next
[08:24:53.289]                             invokeRestart(restart)
[08:24:53.289]                             muffled <- TRUE
[08:24:53.289]                             break
[08:24:53.289]                           }
[08:24:53.289]                         }
[08:24:53.289]                       }
[08:24:53.289]                       invisible(muffled)
[08:24:53.289]                     }
[08:24:53.289]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.289]                   }
[08:24:53.289]                 }
[08:24:53.289]                 else {
[08:24:53.289]                   if (TRUE) {
[08:24:53.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.289]                     {
[08:24:53.289]                       inherits <- base::inherits
[08:24:53.289]                       invokeRestart <- base::invokeRestart
[08:24:53.289]                       is.null <- base::is.null
[08:24:53.289]                       muffled <- FALSE
[08:24:53.289]                       if (inherits(cond, "message")) {
[08:24:53.289]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.289]                         if (muffled) 
[08:24:53.289]                           invokeRestart("muffleMessage")
[08:24:53.289]                       }
[08:24:53.289]                       else if (inherits(cond, "warning")) {
[08:24:53.289]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.289]                         if (muffled) 
[08:24:53.289]                           invokeRestart("muffleWarning")
[08:24:53.289]                       }
[08:24:53.289]                       else if (inherits(cond, "condition")) {
[08:24:53.289]                         if (!is.null(pattern)) {
[08:24:53.289]                           computeRestarts <- base::computeRestarts
[08:24:53.289]                           grepl <- base::grepl
[08:24:53.289]                           restarts <- computeRestarts(cond)
[08:24:53.289]                           for (restart in restarts) {
[08:24:53.289]                             name <- restart$name
[08:24:53.289]                             if (is.null(name)) 
[08:24:53.289]                               next
[08:24:53.289]                             if (!grepl(pattern, name)) 
[08:24:53.289]                               next
[08:24:53.289]                             invokeRestart(restart)
[08:24:53.289]                             muffled <- TRUE
[08:24:53.289]                             break
[08:24:53.289]                           }
[08:24:53.289]                         }
[08:24:53.289]                       }
[08:24:53.289]                       invisible(muffled)
[08:24:53.289]                     }
[08:24:53.289]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.289]                   }
[08:24:53.289]                 }
[08:24:53.289]             }
[08:24:53.289]         }))
[08:24:53.289]     }, error = function(ex) {
[08:24:53.289]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:53.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.289]                 ...future.rng), started = ...future.startTime, 
[08:24:53.289]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:53.289]             version = "1.8"), class = "FutureResult")
[08:24:53.289]     }, finally = {
[08:24:53.289]         if (!identical(...future.workdir, getwd())) 
[08:24:53.289]             setwd(...future.workdir)
[08:24:53.289]         {
[08:24:53.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:53.289]                 ...future.oldOptions$nwarnings <- NULL
[08:24:53.289]             }
[08:24:53.289]             base::options(...future.oldOptions)
[08:24:53.289]             if (.Platform$OS.type == "windows") {
[08:24:53.289]                 old_names <- names(...future.oldEnvVars)
[08:24:53.289]                 envs <- base::Sys.getenv()
[08:24:53.289]                 names <- names(envs)
[08:24:53.289]                 common <- intersect(names, old_names)
[08:24:53.289]                 added <- setdiff(names, old_names)
[08:24:53.289]                 removed <- setdiff(old_names, names)
[08:24:53.289]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:53.289]                   envs[common]]
[08:24:53.289]                 NAMES <- toupper(changed)
[08:24:53.289]                 args <- list()
[08:24:53.289]                 for (kk in seq_along(NAMES)) {
[08:24:53.289]                   name <- changed[[kk]]
[08:24:53.289]                   NAME <- NAMES[[kk]]
[08:24:53.289]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.289]                     next
[08:24:53.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.289]                 }
[08:24:53.289]                 NAMES <- toupper(added)
[08:24:53.289]                 for (kk in seq_along(NAMES)) {
[08:24:53.289]                   name <- added[[kk]]
[08:24:53.289]                   NAME <- NAMES[[kk]]
[08:24:53.289]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.289]                     next
[08:24:53.289]                   args[[name]] <- ""
[08:24:53.289]                 }
[08:24:53.289]                 NAMES <- toupper(removed)
[08:24:53.289]                 for (kk in seq_along(NAMES)) {
[08:24:53.289]                   name <- removed[[kk]]
[08:24:53.289]                   NAME <- NAMES[[kk]]
[08:24:53.289]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.289]                     next
[08:24:53.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.289]                 }
[08:24:53.289]                 if (length(args) > 0) 
[08:24:53.289]                   base::do.call(base::Sys.setenv, args = args)
[08:24:53.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:53.289]             }
[08:24:53.289]             else {
[08:24:53.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:53.289]             }
[08:24:53.289]             {
[08:24:53.289]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:53.289]                   0L) {
[08:24:53.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:53.289]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:53.289]                   base::options(opts)
[08:24:53.289]                 }
[08:24:53.289]                 {
[08:24:53.289]                   {
[08:24:53.289]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:53.289]                     NULL
[08:24:53.289]                   }
[08:24:53.289]                   options(future.plan = NULL)
[08:24:53.289]                   if (is.na(NA_character_)) 
[08:24:53.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:53.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:53.289]                     .init = FALSE)
[08:24:53.289]                 }
[08:24:53.289]             }
[08:24:53.289]         }
[08:24:53.289]     })
[08:24:53.289]     if (TRUE) {
[08:24:53.289]         base::sink(type = "output", split = FALSE)
[08:24:53.289]         if (TRUE) {
[08:24:53.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:53.289]         }
[08:24:53.289]         else {
[08:24:53.289]             ...future.result["stdout"] <- base::list(NULL)
[08:24:53.289]         }
[08:24:53.289]         base::close(...future.stdout)
[08:24:53.289]         ...future.stdout <- NULL
[08:24:53.289]     }
[08:24:53.289]     ...future.result$conditions <- ...future.conditions
[08:24:53.289]     ...future.result$finished <- base::Sys.time()
[08:24:53.289]     ...future.result
[08:24:53.289] }
[08:24:53.292] assign_globals() ...
[08:24:53.292] List of 5
[08:24:53.292]  $ future.call.arguments    : list()
[08:24:53.292]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.292]  $ ...future.FUN            :function (x)  
[08:24:53.292]  $ ...future.elements_ii    :List of 1
[08:24:53.292]   ..$ : int [1:2] 1 3
[08:24:53.292]  $ ...future.seeds_ii       : NULL
[08:24:53.292]  $ ...future.globals.maxSize: num Inf
[08:24:53.292]  - attr(*, "resolved")= logi FALSE
[08:24:53.292]  - attr(*, "total_size")= num NA
[08:24:53.292]  - attr(*, "where")=List of 5
[08:24:53.292]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:53.292]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:53.292]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:53.292]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:53.292]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:53.292]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.292]  - attr(*, "already-done")= logi TRUE
[08:24:53.299] - copied ‘future.call.arguments’ to environment
[08:24:53.300] - reassign environment for ‘...future.FUN’
[08:24:53.300] - copied ‘...future.FUN’ to environment
[08:24:53.300] - copied ‘...future.elements_ii’ to environment
[08:24:53.300] - copied ‘...future.seeds_ii’ to environment
[08:24:53.300] - copied ‘...future.globals.maxSize’ to environment
[08:24:53.300] assign_globals() ... done
[08:24:53.300] requestCore(): workers = 2
[08:24:53.303] MulticoreFuture started
[08:24:53.303] - Launch lazy future ... done
[08:24:53.303] run() for ‘MulticoreFuture’ ... done
[08:24:53.304] plan(): Setting new future strategy stack:
[08:24:53.304] Created future:
[08:24:53.304] List of future strategies:
[08:24:53.304] 1. sequential:
[08:24:53.304]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.304]    - tweaked: FALSE
[08:24:53.304]    - call: NULL
[08:24:53.305] plan(): nbrOfWorkers() = 1
[08:24:53.308] plan(): Setting new future strategy stack:
[08:24:53.308] List of future strategies:
[08:24:53.308] 1. multicore:
[08:24:53.308]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:53.308]    - tweaked: FALSE
[08:24:53.308]    - call: plan(strategy)
[08:24:53.311] plan(): nbrOfWorkers() = 2
[08:24:53.304] MulticoreFuture:
[08:24:53.304] Label: ‘future_apply-1’
[08:24:53.304] Expression:
[08:24:53.304] {
[08:24:53.304]     do.call(function(...) {
[08:24:53.304]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.304]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.304]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.304]             on.exit(options(oopts), add = TRUE)
[08:24:53.304]         }
[08:24:53.304]         {
[08:24:53.304]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.304]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.304]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.304]             })
[08:24:53.304]         }
[08:24:53.304]     }, args = future.call.arguments)
[08:24:53.304] }
[08:24:53.304] Lazy evaluation: FALSE
[08:24:53.304] Asynchronous evaluation: TRUE
[08:24:53.304] Local evaluation: TRUE
[08:24:53.304] Environment: R_GlobalEnv
[08:24:53.304] Capture standard output: TRUE
[08:24:53.304] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:53.304] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:53.304] Packages: <none>
[08:24:53.304] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:53.304] Resolved: TRUE
[08:24:53.304] Value: <not collected>
[08:24:53.304] Conditions captured: <none>
[08:24:53.304] Early signaling: FALSE
[08:24:53.304] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:53.304] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.313] Chunk #1 of 2 ... DONE
[08:24:53.313] Chunk #2 of 2 ...
[08:24:53.313]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:53.313]  - seeds: <none>
[08:24:53.313]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.314] getGlobalsAndPackages() ...
[08:24:53.314] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.314] Resolving globals: FALSE
[08:24:53.314] Tweak future expression to call with '...' arguments ...
[08:24:53.314] {
[08:24:53.314]     do.call(function(...) {
[08:24:53.314]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.314]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.314]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.314]             on.exit(options(oopts), add = TRUE)
[08:24:53.314]         }
[08:24:53.314]         {
[08:24:53.314]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.314]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.314]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.314]             })
[08:24:53.314]         }
[08:24:53.314]     }, args = future.call.arguments)
[08:24:53.314] }
[08:24:53.315] Tweak future expression to call with '...' arguments ... DONE
[08:24:53.315] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.315] 
[08:24:53.316] getGlobalsAndPackages() ... DONE
[08:24:53.316] run() for ‘Future’ ...
[08:24:53.316] - state: ‘created’
[08:24:53.317] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:53.319] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.319] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:53.320]   - Field: ‘label’
[08:24:53.320]   - Field: ‘local’
[08:24:53.320]   - Field: ‘owner’
[08:24:53.320]   - Field: ‘envir’
[08:24:53.320]   - Field: ‘workers’
[08:24:53.320]   - Field: ‘packages’
[08:24:53.320]   - Field: ‘gc’
[08:24:53.321]   - Field: ‘job’
[08:24:53.321]   - Field: ‘conditions’
[08:24:53.321]   - Field: ‘expr’
[08:24:53.321]   - Field: ‘uuid’
[08:24:53.321]   - Field: ‘seed’
[08:24:53.321]   - Field: ‘version’
[08:24:53.321]   - Field: ‘result’
[08:24:53.322]   - Field: ‘asynchronous’
[08:24:53.322]   - Field: ‘calls’
[08:24:53.322]   - Field: ‘globals’
[08:24:53.322]   - Field: ‘stdout’
[08:24:53.322]   - Field: ‘earlySignal’
[08:24:53.322]   - Field: ‘lazy’
[08:24:53.323]   - Field: ‘state’
[08:24:53.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:53.323] - Launch lazy future ...
[08:24:53.323] Packages needed by the future expression (n = 0): <none>
[08:24:53.323] Packages needed by future strategies (n = 0): <none>
[08:24:53.324] {
[08:24:53.324]     {
[08:24:53.324]         {
[08:24:53.324]             ...future.startTime <- base::Sys.time()
[08:24:53.324]             {
[08:24:53.324]                 {
[08:24:53.324]                   {
[08:24:53.324]                     {
[08:24:53.324]                       base::local({
[08:24:53.324]                         has_future <- base::requireNamespace("future", 
[08:24:53.324]                           quietly = TRUE)
[08:24:53.324]                         if (has_future) {
[08:24:53.324]                           ns <- base::getNamespace("future")
[08:24:53.324]                           version <- ns[[".package"]][["version"]]
[08:24:53.324]                           if (is.null(version)) 
[08:24:53.324]                             version <- utils::packageVersion("future")
[08:24:53.324]                         }
[08:24:53.324]                         else {
[08:24:53.324]                           version <- NULL
[08:24:53.324]                         }
[08:24:53.324]                         if (!has_future || version < "1.8.0") {
[08:24:53.324]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:53.324]                             "", base::R.version$version.string), 
[08:24:53.324]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:53.324]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:53.324]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:53.324]                               "release", "version")], collapse = " "), 
[08:24:53.324]                             hostname = base::Sys.info()[["nodename"]])
[08:24:53.324]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:53.324]                             info)
[08:24:53.324]                           info <- base::paste(info, collapse = "; ")
[08:24:53.324]                           if (!has_future) {
[08:24:53.324]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:53.324]                               info)
[08:24:53.324]                           }
[08:24:53.324]                           else {
[08:24:53.324]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:53.324]                               info, version)
[08:24:53.324]                           }
[08:24:53.324]                           base::stop(msg)
[08:24:53.324]                         }
[08:24:53.324]                       })
[08:24:53.324]                     }
[08:24:53.324]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:53.324]                     base::options(mc.cores = 1L)
[08:24:53.324]                   }
[08:24:53.324]                   ...future.strategy.old <- future::plan("list")
[08:24:53.324]                   options(future.plan = NULL)
[08:24:53.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:53.324]                 }
[08:24:53.324]                 ...future.workdir <- getwd()
[08:24:53.324]             }
[08:24:53.324]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:53.324]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:53.324]         }
[08:24:53.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:53.324]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:53.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:53.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:53.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:53.324]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:53.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:53.324]             base::names(...future.oldOptions))
[08:24:53.324]     }
[08:24:53.324]     if (FALSE) {
[08:24:53.324]     }
[08:24:53.324]     else {
[08:24:53.324]         if (TRUE) {
[08:24:53.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:53.324]                 open = "w")
[08:24:53.324]         }
[08:24:53.324]         else {
[08:24:53.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:53.324]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:53.324]         }
[08:24:53.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:53.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:53.324]             base::sink(type = "output", split = FALSE)
[08:24:53.324]             base::close(...future.stdout)
[08:24:53.324]         }, add = TRUE)
[08:24:53.324]     }
[08:24:53.324]     ...future.frame <- base::sys.nframe()
[08:24:53.324]     ...future.conditions <- base::list()
[08:24:53.324]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:53.324]     if (FALSE) {
[08:24:53.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:53.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:53.324]     }
[08:24:53.324]     ...future.result <- base::tryCatch({
[08:24:53.324]         base::withCallingHandlers({
[08:24:53.324]             ...future.value <- base::withVisible(base::local({
[08:24:53.324]                 withCallingHandlers({
[08:24:53.324]                   {
[08:24:53.324]                     do.call(function(...) {
[08:24:53.324]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.324]                       if (!identical(...future.globals.maxSize.org, 
[08:24:53.324]                         ...future.globals.maxSize)) {
[08:24:53.324]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.324]                         on.exit(options(oopts), add = TRUE)
[08:24:53.324]                       }
[08:24:53.324]                       {
[08:24:53.324]                         lapply(seq_along(...future.elements_ii), 
[08:24:53.324]                           FUN = function(jj) {
[08:24:53.324]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.324]                             ...future.FUN(...future.X_jj, ...)
[08:24:53.324]                           })
[08:24:53.324]                       }
[08:24:53.324]                     }, args = future.call.arguments)
[08:24:53.324]                   }
[08:24:53.324]                 }, immediateCondition = function(cond) {
[08:24:53.324]                   save_rds <- function (object, pathname, ...) 
[08:24:53.324]                   {
[08:24:53.324]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:53.324]                     if (file_test("-f", pathname_tmp)) {
[08:24:53.324]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.324]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:53.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.324]                         fi_tmp[["mtime"]])
[08:24:53.324]                     }
[08:24:53.324]                     tryCatch({
[08:24:53.324]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:53.324]                     }, error = function(ex) {
[08:24:53.324]                       msg <- conditionMessage(ex)
[08:24:53.324]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.324]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:53.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.324]                         fi_tmp[["mtime"]], msg)
[08:24:53.324]                       ex$message <- msg
[08:24:53.324]                       stop(ex)
[08:24:53.324]                     })
[08:24:53.324]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:53.324]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:53.324]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:53.324]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.324]                       fi <- file.info(pathname)
[08:24:53.324]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:53.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.324]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:53.324]                         fi[["size"]], fi[["mtime"]])
[08:24:53.324]                       stop(msg)
[08:24:53.324]                     }
[08:24:53.324]                     invisible(pathname)
[08:24:53.324]                   }
[08:24:53.324]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:53.324]                     rootPath = tempdir()) 
[08:24:53.324]                   {
[08:24:53.324]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:53.324]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:53.324]                       tmpdir = path, fileext = ".rds")
[08:24:53.324]                     save_rds(obj, file)
[08:24:53.324]                   }
[08:24:53.324]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:53.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.324]                   {
[08:24:53.324]                     inherits <- base::inherits
[08:24:53.324]                     invokeRestart <- base::invokeRestart
[08:24:53.324]                     is.null <- base::is.null
[08:24:53.324]                     muffled <- FALSE
[08:24:53.324]                     if (inherits(cond, "message")) {
[08:24:53.324]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:53.324]                       if (muffled) 
[08:24:53.324]                         invokeRestart("muffleMessage")
[08:24:53.324]                     }
[08:24:53.324]                     else if (inherits(cond, "warning")) {
[08:24:53.324]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:53.324]                       if (muffled) 
[08:24:53.324]                         invokeRestart("muffleWarning")
[08:24:53.324]                     }
[08:24:53.324]                     else if (inherits(cond, "condition")) {
[08:24:53.324]                       if (!is.null(pattern)) {
[08:24:53.324]                         computeRestarts <- base::computeRestarts
[08:24:53.324]                         grepl <- base::grepl
[08:24:53.324]                         restarts <- computeRestarts(cond)
[08:24:53.324]                         for (restart in restarts) {
[08:24:53.324]                           name <- restart$name
[08:24:53.324]                           if (is.null(name)) 
[08:24:53.324]                             next
[08:24:53.324]                           if (!grepl(pattern, name)) 
[08:24:53.324]                             next
[08:24:53.324]                           invokeRestart(restart)
[08:24:53.324]                           muffled <- TRUE
[08:24:53.324]                           break
[08:24:53.324]                         }
[08:24:53.324]                       }
[08:24:53.324]                     }
[08:24:53.324]                     invisible(muffled)
[08:24:53.324]                   }
[08:24:53.324]                   muffleCondition(cond)
[08:24:53.324]                 })
[08:24:53.324]             }))
[08:24:53.324]             future::FutureResult(value = ...future.value$value, 
[08:24:53.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.324]                   ...future.rng), globalenv = if (FALSE) 
[08:24:53.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:53.324]                     ...future.globalenv.names))
[08:24:53.324]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:53.324]         }, condition = base::local({
[08:24:53.324]             c <- base::c
[08:24:53.324]             inherits <- base::inherits
[08:24:53.324]             invokeRestart <- base::invokeRestart
[08:24:53.324]             length <- base::length
[08:24:53.324]             list <- base::list
[08:24:53.324]             seq.int <- base::seq.int
[08:24:53.324]             signalCondition <- base::signalCondition
[08:24:53.324]             sys.calls <- base::sys.calls
[08:24:53.324]             `[[` <- base::`[[`
[08:24:53.324]             `+` <- base::`+`
[08:24:53.324]             `<<-` <- base::`<<-`
[08:24:53.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:53.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:53.324]                   3L)]
[08:24:53.324]             }
[08:24:53.324]             function(cond) {
[08:24:53.324]                 is_error <- inherits(cond, "error")
[08:24:53.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:53.324]                   NULL)
[08:24:53.324]                 if (is_error) {
[08:24:53.324]                   sessionInformation <- function() {
[08:24:53.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:53.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:53.324]                       search = base::search(), system = base::Sys.info())
[08:24:53.324]                   }
[08:24:53.324]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:53.324]                     cond$call), session = sessionInformation(), 
[08:24:53.324]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:53.324]                   signalCondition(cond)
[08:24:53.324]                 }
[08:24:53.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:53.324]                 "immediateCondition"))) {
[08:24:53.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:53.324]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:53.324]                   if (TRUE && !signal) {
[08:24:53.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.324]                     {
[08:24:53.324]                       inherits <- base::inherits
[08:24:53.324]                       invokeRestart <- base::invokeRestart
[08:24:53.324]                       is.null <- base::is.null
[08:24:53.324]                       muffled <- FALSE
[08:24:53.324]                       if (inherits(cond, "message")) {
[08:24:53.324]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.324]                         if (muffled) 
[08:24:53.324]                           invokeRestart("muffleMessage")
[08:24:53.324]                       }
[08:24:53.324]                       else if (inherits(cond, "warning")) {
[08:24:53.324]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.324]                         if (muffled) 
[08:24:53.324]                           invokeRestart("muffleWarning")
[08:24:53.324]                       }
[08:24:53.324]                       else if (inherits(cond, "condition")) {
[08:24:53.324]                         if (!is.null(pattern)) {
[08:24:53.324]                           computeRestarts <- base::computeRestarts
[08:24:53.324]                           grepl <- base::grepl
[08:24:53.324]                           restarts <- computeRestarts(cond)
[08:24:53.324]                           for (restart in restarts) {
[08:24:53.324]                             name <- restart$name
[08:24:53.324]                             if (is.null(name)) 
[08:24:53.324]                               next
[08:24:53.324]                             if (!grepl(pattern, name)) 
[08:24:53.324]                               next
[08:24:53.324]                             invokeRestart(restart)
[08:24:53.324]                             muffled <- TRUE
[08:24:53.324]                             break
[08:24:53.324]                           }
[08:24:53.324]                         }
[08:24:53.324]                       }
[08:24:53.324]                       invisible(muffled)
[08:24:53.324]                     }
[08:24:53.324]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.324]                   }
[08:24:53.324]                 }
[08:24:53.324]                 else {
[08:24:53.324]                   if (TRUE) {
[08:24:53.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.324]                     {
[08:24:53.324]                       inherits <- base::inherits
[08:24:53.324]                       invokeRestart <- base::invokeRestart
[08:24:53.324]                       is.null <- base::is.null
[08:24:53.324]                       muffled <- FALSE
[08:24:53.324]                       if (inherits(cond, "message")) {
[08:24:53.324]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.324]                         if (muffled) 
[08:24:53.324]                           invokeRestart("muffleMessage")
[08:24:53.324]                       }
[08:24:53.324]                       else if (inherits(cond, "warning")) {
[08:24:53.324]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.324]                         if (muffled) 
[08:24:53.324]                           invokeRestart("muffleWarning")
[08:24:53.324]                       }
[08:24:53.324]                       else if (inherits(cond, "condition")) {
[08:24:53.324]                         if (!is.null(pattern)) {
[08:24:53.324]                           computeRestarts <- base::computeRestarts
[08:24:53.324]                           grepl <- base::grepl
[08:24:53.324]                           restarts <- computeRestarts(cond)
[08:24:53.324]                           for (restart in restarts) {
[08:24:53.324]                             name <- restart$name
[08:24:53.324]                             if (is.null(name)) 
[08:24:53.324]                               next
[08:24:53.324]                             if (!grepl(pattern, name)) 
[08:24:53.324]                               next
[08:24:53.324]                             invokeRestart(restart)
[08:24:53.324]                             muffled <- TRUE
[08:24:53.324]                             break
[08:24:53.324]                           }
[08:24:53.324]                         }
[08:24:53.324]                       }
[08:24:53.324]                       invisible(muffled)
[08:24:53.324]                     }
[08:24:53.324]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.324]                   }
[08:24:53.324]                 }
[08:24:53.324]             }
[08:24:53.324]         }))
[08:24:53.324]     }, error = function(ex) {
[08:24:53.324]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:53.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.324]                 ...future.rng), started = ...future.startTime, 
[08:24:53.324]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:53.324]             version = "1.8"), class = "FutureResult")
[08:24:53.324]     }, finally = {
[08:24:53.324]         if (!identical(...future.workdir, getwd())) 
[08:24:53.324]             setwd(...future.workdir)
[08:24:53.324]         {
[08:24:53.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:53.324]                 ...future.oldOptions$nwarnings <- NULL
[08:24:53.324]             }
[08:24:53.324]             base::options(...future.oldOptions)
[08:24:53.324]             if (.Platform$OS.type == "windows") {
[08:24:53.324]                 old_names <- names(...future.oldEnvVars)
[08:24:53.324]                 envs <- base::Sys.getenv()
[08:24:53.324]                 names <- names(envs)
[08:24:53.324]                 common <- intersect(names, old_names)
[08:24:53.324]                 added <- setdiff(names, old_names)
[08:24:53.324]                 removed <- setdiff(old_names, names)
[08:24:53.324]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:53.324]                   envs[common]]
[08:24:53.324]                 NAMES <- toupper(changed)
[08:24:53.324]                 args <- list()
[08:24:53.324]                 for (kk in seq_along(NAMES)) {
[08:24:53.324]                   name <- changed[[kk]]
[08:24:53.324]                   NAME <- NAMES[[kk]]
[08:24:53.324]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.324]                     next
[08:24:53.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.324]                 }
[08:24:53.324]                 NAMES <- toupper(added)
[08:24:53.324]                 for (kk in seq_along(NAMES)) {
[08:24:53.324]                   name <- added[[kk]]
[08:24:53.324]                   NAME <- NAMES[[kk]]
[08:24:53.324]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.324]                     next
[08:24:53.324]                   args[[name]] <- ""
[08:24:53.324]                 }
[08:24:53.324]                 NAMES <- toupper(removed)
[08:24:53.324]                 for (kk in seq_along(NAMES)) {
[08:24:53.324]                   name <- removed[[kk]]
[08:24:53.324]                   NAME <- NAMES[[kk]]
[08:24:53.324]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.324]                     next
[08:24:53.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.324]                 }
[08:24:53.324]                 if (length(args) > 0) 
[08:24:53.324]                   base::do.call(base::Sys.setenv, args = args)
[08:24:53.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:53.324]             }
[08:24:53.324]             else {
[08:24:53.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:53.324]             }
[08:24:53.324]             {
[08:24:53.324]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:53.324]                   0L) {
[08:24:53.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:53.324]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:53.324]                   base::options(opts)
[08:24:53.324]                 }
[08:24:53.324]                 {
[08:24:53.324]                   {
[08:24:53.324]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:53.324]                     NULL
[08:24:53.324]                   }
[08:24:53.324]                   options(future.plan = NULL)
[08:24:53.324]                   if (is.na(NA_character_)) 
[08:24:53.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:53.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:53.324]                     .init = FALSE)
[08:24:53.324]                 }
[08:24:53.324]             }
[08:24:53.324]         }
[08:24:53.324]     })
[08:24:53.324]     if (TRUE) {
[08:24:53.324]         base::sink(type = "output", split = FALSE)
[08:24:53.324]         if (TRUE) {
[08:24:53.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:53.324]         }
[08:24:53.324]         else {
[08:24:53.324]             ...future.result["stdout"] <- base::list(NULL)
[08:24:53.324]         }
[08:24:53.324]         base::close(...future.stdout)
[08:24:53.324]         ...future.stdout <- NULL
[08:24:53.324]     }
[08:24:53.324]     ...future.result$conditions <- ...future.conditions
[08:24:53.324]     ...future.result$finished <- base::Sys.time()
[08:24:53.324]     ...future.result
[08:24:53.324] }
[08:24:53.328] assign_globals() ...
[08:24:53.328] List of 5
[08:24:53.328]  $ future.call.arguments    : list()
[08:24:53.328]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.328]  $ ...future.FUN            :function (x)  
[08:24:53.328]  $ ...future.elements_ii    :List of 1
[08:24:53.328]   ..$ : int [1:2] 2 4
[08:24:53.328]  $ ...future.seeds_ii       : NULL
[08:24:53.328]  $ ...future.globals.maxSize: num Inf
[08:24:53.328]  - attr(*, "resolved")= logi FALSE
[08:24:53.328]  - attr(*, "total_size")= num NA
[08:24:53.328]  - attr(*, "where")=List of 5
[08:24:53.328]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:53.328]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:53.328]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:53.328]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:53.328]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:53.328]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.328]  - attr(*, "already-done")= logi TRUE
[08:24:53.336] - copied ‘future.call.arguments’ to environment
[08:24:53.336] - reassign environment for ‘...future.FUN’
[08:24:53.336] - copied ‘...future.FUN’ to environment
[08:24:53.336] - copied ‘...future.elements_ii’ to environment
[08:24:53.336] - copied ‘...future.seeds_ii’ to environment
[08:24:53.336] - copied ‘...future.globals.maxSize’ to environment
[08:24:53.337] assign_globals() ... done
[08:24:53.337] requestCore(): workers = 2
[08:24:53.339] MulticoreFuture started
[08:24:53.340] - Launch lazy future ... done
[08:24:53.340] run() for ‘MulticoreFuture’ ... done
[08:24:53.340] Created future:
[08:24:53.340] plan(): Setting new future strategy stack:
[08:24:53.341] List of future strategies:
[08:24:53.341] 1. sequential:
[08:24:53.341]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.341]    - tweaked: FALSE
[08:24:53.341]    - call: NULL
[08:24:53.342] plan(): nbrOfWorkers() = 1
[08:24:53.344] plan(): Setting new future strategy stack:
[08:24:53.344] List of future strategies:
[08:24:53.344] 1. multicore:
[08:24:53.344]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:53.344]    - tweaked: FALSE
[08:24:53.344]    - call: plan(strategy)
[08:24:53.340] MulticoreFuture:
[08:24:53.340] Label: ‘future_apply-2’
[08:24:53.340] Expression:
[08:24:53.340] {
[08:24:53.340]     do.call(function(...) {
[08:24:53.340]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.340]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.340]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.340]             on.exit(options(oopts), add = TRUE)
[08:24:53.340]         }
[08:24:53.340]         {
[08:24:53.340]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.340]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.340]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.340]             })
[08:24:53.340]         }
[08:24:53.340]     }, args = future.call.arguments)
[08:24:53.340] }
[08:24:53.340] Lazy evaluation: FALSE
[08:24:53.340] Asynchronous evaluation: TRUE
[08:24:53.340] Local evaluation: TRUE
[08:24:53.340] Environment: R_GlobalEnv
[08:24:53.340] Capture standard output: TRUE
[08:24:53.340] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:53.340] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:53.340] Packages: <none>
[08:24:53.340] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:53.340] Resolved: FALSE
[08:24:53.340] Value: <not collected>
[08:24:53.340] Conditions captured: <none>
[08:24:53.340] Early signaling: FALSE
[08:24:53.340] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:53.340] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.353] Chunk #2 of 2 ... DONE
[08:24:53.353] Launching 2 futures (chunks) ... DONE
[08:24:53.353] Resolving 2 futures (chunks) ...
[08:24:53.353] resolve() on list ...
[08:24:53.353] plan(): nbrOfWorkers() = 2
[08:24:53.353]  recursive: 0
[08:24:53.357]  length: 2
[08:24:53.357] 
[08:24:53.357] Future #1
[08:24:53.358] result() for MulticoreFuture ...
[08:24:53.359] result() for MulticoreFuture ...
[08:24:53.360] result() for MulticoreFuture ... done
[08:24:53.360] result() for MulticoreFuture ... done
[08:24:53.360] result() for MulticoreFuture ...
[08:24:53.360] result() for MulticoreFuture ... done
[08:24:53.361] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:53.361] - nx: 2
[08:24:53.361] - relay: TRUE
[08:24:53.361] - stdout: TRUE
[08:24:53.362] - signal: TRUE
[08:24:53.362] - resignal: FALSE
[08:24:53.362] - force: TRUE
[08:24:53.363] - relayed: [n=2] FALSE, FALSE
[08:24:53.363] - queued futures: [n=2] FALSE, FALSE
[08:24:53.363]  - until=1
[08:24:53.363]  - relaying element #1
[08:24:53.364] result() for MulticoreFuture ...
[08:24:53.364] result() for MulticoreFuture ... done
[08:24:53.364] result() for MulticoreFuture ...
[08:24:53.364] result() for MulticoreFuture ... done
[08:24:53.365] result() for MulticoreFuture ...
[08:24:53.365] result() for MulticoreFuture ... done
[08:24:53.365] result() for MulticoreFuture ...
[08:24:53.365] result() for MulticoreFuture ... done
[08:24:53.365] - relayed: [n=2] TRUE, FALSE
[08:24:53.365] - queued futures: [n=2] TRUE, FALSE
[08:24:53.365] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:53.365]  length: 1 (resolved future 1)
[08:24:53.366] Future #2
[08:24:53.366] result() for MulticoreFuture ...
[08:24:53.367] result() for MulticoreFuture ...
[08:24:53.367] result() for MulticoreFuture ... done
[08:24:53.367] result() for MulticoreFuture ... done
[08:24:53.367] result() for MulticoreFuture ...
[08:24:53.367] result() for MulticoreFuture ... done
[08:24:53.368] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:53.368] - nx: 2
[08:24:53.368] - relay: TRUE
[08:24:53.368] - stdout: TRUE
[08:24:53.368] - signal: TRUE
[08:24:53.368] - resignal: FALSE
[08:24:53.368] - force: TRUE
[08:24:53.368] - relayed: [n=2] TRUE, FALSE
[08:24:53.368] - queued futures: [n=2] TRUE, FALSE
[08:24:53.369]  - until=2
[08:24:53.369]  - relaying element #2
[08:24:53.369] result() for MulticoreFuture ...
[08:24:53.369] result() for MulticoreFuture ... done
[08:24:53.369] result() for MulticoreFuture ...
[08:24:53.369] result() for MulticoreFuture ... done
[08:24:53.369] result() for MulticoreFuture ...
[08:24:53.369] result() for MulticoreFuture ... done
[08:24:53.370] result() for MulticoreFuture ...
[08:24:53.370] result() for MulticoreFuture ... done
[08:24:53.370] - relayed: [n=2] TRUE, TRUE
[08:24:53.370] - queued futures: [n=2] TRUE, TRUE
[08:24:53.370] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:53.370]  length: 0 (resolved future 2)
[08:24:53.370] Relaying remaining futures
[08:24:53.370] signalConditionsASAP(NULL, pos=0) ...
[08:24:53.370] - nx: 2
[08:24:53.371] - relay: TRUE
[08:24:53.371] - stdout: TRUE
[08:24:53.371] - signal: TRUE
[08:24:53.371] - resignal: FALSE
[08:24:53.371] - force: TRUE
[08:24:53.371] - relayed: [n=2] TRUE, TRUE
[08:24:53.371] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:53.371] - relayed: [n=2] TRUE, TRUE
[08:24:53.371] - queued futures: [n=2] TRUE, TRUE
[08:24:53.371] signalConditionsASAP(NULL, pos=0) ... done
[08:24:53.372] resolve() on list ... DONE
[08:24:53.372] result() for MulticoreFuture ...
[08:24:53.372] result() for MulticoreFuture ... done
[08:24:53.372] result() for MulticoreFuture ...
[08:24:53.372] result() for MulticoreFuture ... done
[08:24:53.372] result() for MulticoreFuture ...
[08:24:53.372] result() for MulticoreFuture ... done
[08:24:53.372] result() for MulticoreFuture ...
[08:24:53.372] result() for MulticoreFuture ... done
[08:24:53.373]  - Number of value chunks collected: 2
[08:24:53.373] Resolving 2 futures (chunks) ... DONE
[08:24:53.373] Reducing values from 2 chunks ...
[08:24:53.373]  - Number of values collected after concatenation: 2
[08:24:53.373]  - Number of values expected: 2
[08:24:53.373] Reducing values from 2 chunks ... DONE
[08:24:53.373] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[08:24:53.374] getGlobalsAndPackagesXApply() ...
[08:24:53.374]  - future.globals: TRUE
[08:24:53.374] getGlobalsAndPackages() ...
[08:24:53.374] Searching for globals...
[08:24:53.377] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[08:24:53.378] Searching for globals ... DONE
[08:24:53.378] Resolving globals: FALSE
[08:24:53.378] The total size of the 1 globals is 3.66 KiB (3746 bytes)
[08:24:53.379] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 3.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.66 KiB of class ‘function’)
[08:24:53.379] - globals: [1] ‘FUN’
[08:24:53.379] 
[08:24:53.379] getGlobalsAndPackages() ... DONE
[08:24:53.379]  - globals found/used: [n=1] ‘FUN’
[08:24:53.379]  - needed namespaces: [n=0] 
[08:24:53.379] Finding globals ... DONE
[08:24:53.380]  - use_args: TRUE
[08:24:53.380]  - Getting '...' globals ...
[08:24:53.380] resolve() on list ...
[08:24:53.380]  recursive: 0
[08:24:53.380]  length: 1
[08:24:53.380]  elements: ‘...’
[08:24:53.381]  length: 0 (resolved future 1)
[08:24:53.381] resolve() on list ... DONE
[08:24:53.381]    - '...' content: [n=0] 
[08:24:53.381] List of 1
[08:24:53.381]  $ ...: list()
[08:24:53.381]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.381]  - attr(*, "where")=List of 1
[08:24:53.381]   ..$ ...:<environment: 0x56540d78e0d0> 
[08:24:53.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.381]  - attr(*, "resolved")= logi TRUE
[08:24:53.381]  - attr(*, "total_size")= num NA
[08:24:53.386]  - Getting '...' globals ... DONE
[08:24:53.386] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:53.386] List of 2
[08:24:53.386]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[08:24:53.386]  $ ...          : list()
[08:24:53.386]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.386]  - attr(*, "where")=List of 2
[08:24:53.386]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:53.386]   ..$ ...          :<environment: 0x56540d78e0d0> 
[08:24:53.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.386]  - attr(*, "resolved")= logi FALSE
[08:24:53.386]  - attr(*, "total_size")= num 9424
[08:24:53.389] Packages to be attached in all futures: [n=0] 
[08:24:53.390] getGlobalsAndPackagesXApply() ... DONE
[08:24:53.391] future_lapply() ...
[08:24:53.393] Generating random seeds ...
[08:24:53.393] Generating random seed streams for 2 elements ...
[08:24:53.394] Generating random seed streams for 2 elements ... DONE
[08:24:53.394] Generating random seeds ... DONE
[08:24:53.394] Will set RNG state on exit: 10407, -2008890217, -851977015, -1067895724, -761549667, 1903814256, 231252184
[08:24:53.395] Number of chunks: 2
[08:24:53.396] getGlobalsAndPackagesXApply() ...
[08:24:53.396]  - future.globals: <name-value list> with names ‘list()’
[08:24:53.396]  - use_args: TRUE
[08:24:53.396] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:53.396] List of 2
[08:24:53.396]  $ ...          : list()
[08:24:53.396]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.396]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[08:24:53.396]  - attr(*, "where")=List of 2
[08:24:53.396]   ..$ ...          :<environment: 0x56540d78e0d0> 
[08:24:53.396]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:53.396]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.396]  - attr(*, "resolved")= logi FALSE
[08:24:53.396]  - attr(*, "total_size")= num NA
[08:24:53.400] Packages to be attached in all futures: [n=0] 
[08:24:53.400] getGlobalsAndPackagesXApply() ... DONE
[08:24:53.400] Number of futures (= number of chunks): 2
[08:24:53.400] Launching 2 futures (chunks) ...
[08:24:53.400] Chunk #1 of 2 ...
[08:24:53.400]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:53.400]  - seeds: [1] <seeds>
[08:24:53.401]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.401] getGlobalsAndPackages() ...
[08:24:53.401] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.401] Resolving globals: FALSE
[08:24:53.401] Tweak future expression to call with '...' arguments ...
[08:24:53.401] {
[08:24:53.401]     do.call(function(...) {
[08:24:53.401]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.401]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.401]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.401]             on.exit(options(oopts), add = TRUE)
[08:24:53.401]         }
[08:24:53.401]         {
[08:24:53.401]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.401]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.401]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:53.401]                   envir = globalenv(), inherits = FALSE)
[08:24:53.401]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.401]             })
[08:24:53.401]         }
[08:24:53.401]     }, args = future.call.arguments)
[08:24:53.401] }
[08:24:53.401] Tweak future expression to call with '...' arguments ... DONE
[08:24:53.402] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.402] 
[08:24:53.402] getGlobalsAndPackages() ... DONE
[08:24:53.402] run() for ‘Future’ ...
[08:24:53.403] - state: ‘created’
[08:24:53.403] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:53.404] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.404] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:53.405]   - Field: ‘label’
[08:24:53.405]   - Field: ‘local’
[08:24:53.405]   - Field: ‘owner’
[08:24:53.405]   - Field: ‘envir’
[08:24:53.405]   - Field: ‘workers’
[08:24:53.405]   - Field: ‘packages’
[08:24:53.405]   - Field: ‘gc’
[08:24:53.405]   - Field: ‘job’
[08:24:53.405]   - Field: ‘conditions’
[08:24:53.405]   - Field: ‘expr’
[08:24:53.406]   - Field: ‘uuid’
[08:24:53.406]   - Field: ‘seed’
[08:24:53.406]   - Field: ‘version’
[08:24:53.406]   - Field: ‘result’
[08:24:53.406]   - Field: ‘asynchronous’
[08:24:53.406]   - Field: ‘calls’
[08:24:53.406]   - Field: ‘globals’
[08:24:53.406]   - Field: ‘stdout’
[08:24:53.406]   - Field: ‘earlySignal’
[08:24:53.406]   - Field: ‘lazy’
[08:24:53.406]   - Field: ‘state’
[08:24:53.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:53.407] - Launch lazy future ...
[08:24:53.407] Packages needed by the future expression (n = 0): <none>
[08:24:53.407] Packages needed by future strategies (n = 0): <none>
[08:24:53.409] {
[08:24:53.409]     {
[08:24:53.409]         {
[08:24:53.409]             ...future.startTime <- base::Sys.time()
[08:24:53.409]             {
[08:24:53.409]                 {
[08:24:53.409]                   {
[08:24:53.409]                     {
[08:24:53.409]                       base::local({
[08:24:53.409]                         has_future <- base::requireNamespace("future", 
[08:24:53.409]                           quietly = TRUE)
[08:24:53.409]                         if (has_future) {
[08:24:53.409]                           ns <- base::getNamespace("future")
[08:24:53.409]                           version <- ns[[".package"]][["version"]]
[08:24:53.409]                           if (is.null(version)) 
[08:24:53.409]                             version <- utils::packageVersion("future")
[08:24:53.409]                         }
[08:24:53.409]                         else {
[08:24:53.409]                           version <- NULL
[08:24:53.409]                         }
[08:24:53.409]                         if (!has_future || version < "1.8.0") {
[08:24:53.409]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:53.409]                             "", base::R.version$version.string), 
[08:24:53.409]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:53.409]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:53.409]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:53.409]                               "release", "version")], collapse = " "), 
[08:24:53.409]                             hostname = base::Sys.info()[["nodename"]])
[08:24:53.409]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:53.409]                             info)
[08:24:53.409]                           info <- base::paste(info, collapse = "; ")
[08:24:53.409]                           if (!has_future) {
[08:24:53.409]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:53.409]                               info)
[08:24:53.409]                           }
[08:24:53.409]                           else {
[08:24:53.409]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:53.409]                               info, version)
[08:24:53.409]                           }
[08:24:53.409]                           base::stop(msg)
[08:24:53.409]                         }
[08:24:53.409]                       })
[08:24:53.409]                     }
[08:24:53.409]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:53.409]                     base::options(mc.cores = 1L)
[08:24:53.409]                   }
[08:24:53.409]                   ...future.strategy.old <- future::plan("list")
[08:24:53.409]                   options(future.plan = NULL)
[08:24:53.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:53.409]                 }
[08:24:53.409]                 ...future.workdir <- getwd()
[08:24:53.409]             }
[08:24:53.409]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:53.409]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:53.409]         }
[08:24:53.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:53.409]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:53.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:53.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:53.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:53.409]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:53.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:53.409]             base::names(...future.oldOptions))
[08:24:53.409]     }
[08:24:53.409]     if (FALSE) {
[08:24:53.409]     }
[08:24:53.409]     else {
[08:24:53.409]         if (TRUE) {
[08:24:53.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:53.409]                 open = "w")
[08:24:53.409]         }
[08:24:53.409]         else {
[08:24:53.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:53.409]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:53.409]         }
[08:24:53.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:53.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:53.409]             base::sink(type = "output", split = FALSE)
[08:24:53.409]             base::close(...future.stdout)
[08:24:53.409]         }, add = TRUE)
[08:24:53.409]     }
[08:24:53.409]     ...future.frame <- base::sys.nframe()
[08:24:53.409]     ...future.conditions <- base::list()
[08:24:53.409]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:53.409]     if (FALSE) {
[08:24:53.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:53.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:53.409]     }
[08:24:53.409]     ...future.result <- base::tryCatch({
[08:24:53.409]         base::withCallingHandlers({
[08:24:53.409]             ...future.value <- base::withVisible(base::local({
[08:24:53.409]                 withCallingHandlers({
[08:24:53.409]                   {
[08:24:53.409]                     do.call(function(...) {
[08:24:53.409]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.409]                       if (!identical(...future.globals.maxSize.org, 
[08:24:53.409]                         ...future.globals.maxSize)) {
[08:24:53.409]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.409]                         on.exit(options(oopts), add = TRUE)
[08:24:53.409]                       }
[08:24:53.409]                       {
[08:24:53.409]                         lapply(seq_along(...future.elements_ii), 
[08:24:53.409]                           FUN = function(jj) {
[08:24:53.409]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.409]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:53.409]                               envir = globalenv(), inherits = FALSE)
[08:24:53.409]                             ...future.FUN(...future.X_jj, ...)
[08:24:53.409]                           })
[08:24:53.409]                       }
[08:24:53.409]                     }, args = future.call.arguments)
[08:24:53.409]                   }
[08:24:53.409]                 }, immediateCondition = function(cond) {
[08:24:53.409]                   save_rds <- function (object, pathname, ...) 
[08:24:53.409]                   {
[08:24:53.409]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:53.409]                     if (file_test("-f", pathname_tmp)) {
[08:24:53.409]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.409]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:53.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.409]                         fi_tmp[["mtime"]])
[08:24:53.409]                     }
[08:24:53.409]                     tryCatch({
[08:24:53.409]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:53.409]                     }, error = function(ex) {
[08:24:53.409]                       msg <- conditionMessage(ex)
[08:24:53.409]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.409]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:53.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.409]                         fi_tmp[["mtime"]], msg)
[08:24:53.409]                       ex$message <- msg
[08:24:53.409]                       stop(ex)
[08:24:53.409]                     })
[08:24:53.409]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:53.409]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:53.409]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:53.409]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.409]                       fi <- file.info(pathname)
[08:24:53.409]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:53.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.409]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:53.409]                         fi[["size"]], fi[["mtime"]])
[08:24:53.409]                       stop(msg)
[08:24:53.409]                     }
[08:24:53.409]                     invisible(pathname)
[08:24:53.409]                   }
[08:24:53.409]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:53.409]                     rootPath = tempdir()) 
[08:24:53.409]                   {
[08:24:53.409]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:53.409]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:53.409]                       tmpdir = path, fileext = ".rds")
[08:24:53.409]                     save_rds(obj, file)
[08:24:53.409]                   }
[08:24:53.409]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:53.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.409]                   {
[08:24:53.409]                     inherits <- base::inherits
[08:24:53.409]                     invokeRestart <- base::invokeRestart
[08:24:53.409]                     is.null <- base::is.null
[08:24:53.409]                     muffled <- FALSE
[08:24:53.409]                     if (inherits(cond, "message")) {
[08:24:53.409]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:53.409]                       if (muffled) 
[08:24:53.409]                         invokeRestart("muffleMessage")
[08:24:53.409]                     }
[08:24:53.409]                     else if (inherits(cond, "warning")) {
[08:24:53.409]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:53.409]                       if (muffled) 
[08:24:53.409]                         invokeRestart("muffleWarning")
[08:24:53.409]                     }
[08:24:53.409]                     else if (inherits(cond, "condition")) {
[08:24:53.409]                       if (!is.null(pattern)) {
[08:24:53.409]                         computeRestarts <- base::computeRestarts
[08:24:53.409]                         grepl <- base::grepl
[08:24:53.409]                         restarts <- computeRestarts(cond)
[08:24:53.409]                         for (restart in restarts) {
[08:24:53.409]                           name <- restart$name
[08:24:53.409]                           if (is.null(name)) 
[08:24:53.409]                             next
[08:24:53.409]                           if (!grepl(pattern, name)) 
[08:24:53.409]                             next
[08:24:53.409]                           invokeRestart(restart)
[08:24:53.409]                           muffled <- TRUE
[08:24:53.409]                           break
[08:24:53.409]                         }
[08:24:53.409]                       }
[08:24:53.409]                     }
[08:24:53.409]                     invisible(muffled)
[08:24:53.409]                   }
[08:24:53.409]                   muffleCondition(cond)
[08:24:53.409]                 })
[08:24:53.409]             }))
[08:24:53.409]             future::FutureResult(value = ...future.value$value, 
[08:24:53.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.409]                   ...future.rng), globalenv = if (FALSE) 
[08:24:53.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:53.409]                     ...future.globalenv.names))
[08:24:53.409]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:53.409]         }, condition = base::local({
[08:24:53.409]             c <- base::c
[08:24:53.409]             inherits <- base::inherits
[08:24:53.409]             invokeRestart <- base::invokeRestart
[08:24:53.409]             length <- base::length
[08:24:53.409]             list <- base::list
[08:24:53.409]             seq.int <- base::seq.int
[08:24:53.409]             signalCondition <- base::signalCondition
[08:24:53.409]             sys.calls <- base::sys.calls
[08:24:53.409]             `[[` <- base::`[[`
[08:24:53.409]             `+` <- base::`+`
[08:24:53.409]             `<<-` <- base::`<<-`
[08:24:53.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:53.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:53.409]                   3L)]
[08:24:53.409]             }
[08:24:53.409]             function(cond) {
[08:24:53.409]                 is_error <- inherits(cond, "error")
[08:24:53.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:53.409]                   NULL)
[08:24:53.409]                 if (is_error) {
[08:24:53.409]                   sessionInformation <- function() {
[08:24:53.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:53.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:53.409]                       search = base::search(), system = base::Sys.info())
[08:24:53.409]                   }
[08:24:53.409]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:53.409]                     cond$call), session = sessionInformation(), 
[08:24:53.409]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:53.409]                   signalCondition(cond)
[08:24:53.409]                 }
[08:24:53.409]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[08:24:53.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:53.409]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:53.409]                   if (TRUE && !signal) {
[08:24:53.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.409]                     {
[08:24:53.409]                       inherits <- base::inherits
[08:24:53.409]                       invokeRestart <- base::invokeRestart
[08:24:53.409]                       is.null <- base::is.null
[08:24:53.409]                       muffled <- FALSE
[08:24:53.409]                       if (inherits(cond, "message")) {
[08:24:53.409]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.409]                         if (muffled) 
[08:24:53.409]                           invokeRestart("muffleMessage")
[08:24:53.409]                       }
[08:24:53.409]                       else if (inherits(cond, "warning")) {
[08:24:53.409]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.409]                         if (muffled) 
[08:24:53.409]                           invokeRestart("muffleWarning")
[08:24:53.409]                       }
[08:24:53.409]                       else if (inherits(cond, "condition")) {
[08:24:53.409]                         if (!is.null(pattern)) {
[08:24:53.409]                           computeRestarts <- base::computeRestarts
[08:24:53.409]                           grepl <- base::grepl
[08:24:53.409]                           restarts <- computeRestarts(cond)
[08:24:53.409]                           for (restart in restarts) {
[08:24:53.409]                             name <- restart$name
[08:24:53.409]                             if (is.null(name)) 
[08:24:53.409]                               next
[08:24:53.409]                             if (!grepl(pattern, name)) 
[08:24:53.409]                               next
[08:24:53.409]                             invokeRestart(restart)
[08:24:53.409]                             muffled <- TRUE
[08:24:53.409]                             break
[08:24:53.409]                           }
[08:24:53.409]                         }
[08:24:53.409]                       }
[08:24:53.409]                       invisible(muffled)
[08:24:53.409]                     }
[08:24:53.409]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.409]                   }
[08:24:53.409]                 }
[08:24:53.409]                 else {
[08:24:53.409]                   if (TRUE) {
[08:24:53.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.409]                     {
[08:24:53.409]                       inherits <- base::inherits
[08:24:53.409]                       invokeRestart <- base::invokeRestart
[08:24:53.409]                       is.null <- base::is.null
[08:24:53.409]                       muffled <- FALSE
[08:24:53.409]                       if (inherits(cond, "message")) {
[08:24:53.409]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.409]                         if (muffled) 
[08:24:53.409]                           invokeRestart("muffleMessage")
[08:24:53.409]                       }
[08:24:53.409]                       else if (inherits(cond, "warning")) {
[08:24:53.409]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.409]                         if (muffled) 
[08:24:53.409]                           invokeRestart("muffleWarning")
[08:24:53.409]                       }
[08:24:53.409]                       else if (inherits(cond, "condition")) {
[08:24:53.409]                         if (!is.null(pattern)) {
[08:24:53.409]                           computeRestarts <- base::computeRestarts
[08:24:53.409]                           grepl <- base::grepl
[08:24:53.409]                           restarts <- computeRestarts(cond)
[08:24:53.409]                           for (restart in restarts) {
[08:24:53.409]                             name <- restart$name
[08:24:53.409]                             if (is.null(name)) 
[08:24:53.409]                               next
[08:24:53.409]                             if (!grepl(pattern, name)) 
[08:24:53.409]                               next
[08:24:53.409]                             invokeRestart(restart)
[08:24:53.409]                             muffled <- TRUE
[08:24:53.409]                             break
[08:24:53.409]                           }
[08:24:53.409]                         }
[08:24:53.409]                       }
[08:24:53.409]                       invisible(muffled)
[08:24:53.409]                     }
[08:24:53.409]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.409]                   }
[08:24:53.409]                 }
[08:24:53.409]             }
[08:24:53.409]         }))
[08:24:53.409]     }, error = function(ex) {
[08:24:53.409]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:53.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.409]                 ...future.rng), started = ...future.startTime, 
[08:24:53.409]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:53.409]             version = "1.8"), class = "FutureResult")
[08:24:53.409]     }, finally = {
[08:24:53.409]         if (!identical(...future.workdir, getwd())) 
[08:24:53.409]             setwd(...future.workdir)
[08:24:53.409]         {
[08:24:53.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:53.409]                 ...future.oldOptions$nwarnings <- NULL
[08:24:53.409]             }
[08:24:53.409]             base::options(...future.oldOptions)
[08:24:53.409]             if (.Platform$OS.type == "windows") {
[08:24:53.409]                 old_names <- names(...future.oldEnvVars)
[08:24:53.409]                 envs <- base::Sys.getenv()
[08:24:53.409]                 names <- names(envs)
[08:24:53.409]                 common <- intersect(names, old_names)
[08:24:53.409]                 added <- setdiff(names, old_names)
[08:24:53.409]                 removed <- setdiff(old_names, names)
[08:24:53.409]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:53.409]                   envs[common]]
[08:24:53.409]                 NAMES <- toupper(changed)
[08:24:53.409]                 args <- list()
[08:24:53.409]                 for (kk in seq_along(NAMES)) {
[08:24:53.409]                   name <- changed[[kk]]
[08:24:53.409]                   NAME <- NAMES[[kk]]
[08:24:53.409]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.409]                     next
[08:24:53.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.409]                 }
[08:24:53.409]                 NAMES <- toupper(added)
[08:24:53.409]                 for (kk in seq_along(NAMES)) {
[08:24:53.409]                   name <- added[[kk]]
[08:24:53.409]                   NAME <- NAMES[[kk]]
[08:24:53.409]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.409]                     next
[08:24:53.409]                   args[[name]] <- ""
[08:24:53.409]                 }
[08:24:53.409]                 NAMES <- toupper(removed)
[08:24:53.409]                 for (kk in seq_along(NAMES)) {
[08:24:53.409]                   name <- removed[[kk]]
[08:24:53.409]                   NAME <- NAMES[[kk]]
[08:24:53.409]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.409]                     next
[08:24:53.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.409]                 }
[08:24:53.409]                 if (length(args) > 0) 
[08:24:53.409]                   base::do.call(base::Sys.setenv, args = args)
[08:24:53.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:53.409]             }
[08:24:53.409]             else {
[08:24:53.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:53.409]             }
[08:24:53.409]             {
[08:24:53.409]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:53.409]                   0L) {
[08:24:53.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:53.409]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:53.409]                   base::options(opts)
[08:24:53.409]                 }
[08:24:53.409]                 {
[08:24:53.409]                   {
[08:24:53.409]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:53.409]                     NULL
[08:24:53.409]                   }
[08:24:53.409]                   options(future.plan = NULL)
[08:24:53.409]                   if (is.na(NA_character_)) 
[08:24:53.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:53.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:53.409]                     .init = FALSE)
[08:24:53.409]                 }
[08:24:53.409]             }
[08:24:53.409]         }
[08:24:53.409]     })
[08:24:53.409]     if (TRUE) {
[08:24:53.409]         base::sink(type = "output", split = FALSE)
[08:24:53.409]         if (TRUE) {
[08:24:53.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:53.409]         }
[08:24:53.409]         else {
[08:24:53.409]             ...future.result["stdout"] <- base::list(NULL)
[08:24:53.409]         }
[08:24:53.409]         base::close(...future.stdout)
[08:24:53.409]         ...future.stdout <- NULL
[08:24:53.409]     }
[08:24:53.409]     ...future.result$conditions <- ...future.conditions
[08:24:53.409]     ...future.result$finished <- base::Sys.time()
[08:24:53.409]     ...future.result
[08:24:53.409] }
[08:24:53.412] assign_globals() ...
[08:24:53.412] List of 5
[08:24:53.412]  $ future.call.arguments    : list()
[08:24:53.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.412]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[08:24:53.412]  $ ...future.elements_ii    :List of 1
[08:24:53.412]   ..$ : int [1:2] 1 3
[08:24:53.412]  $ ...future.seeds_ii       :List of 1
[08:24:53.412]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[08:24:53.412]  $ ...future.globals.maxSize: num Inf
[08:24:53.412]  - attr(*, "resolved")= logi FALSE
[08:24:53.412]  - attr(*, "total_size")= num NA
[08:24:53.412]  - attr(*, "where")=List of 5
[08:24:53.412]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:53.412]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:53.412]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:53.412]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:53.412]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:53.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.412]  - attr(*, "already-done")= logi TRUE
[08:24:53.418] - copied ‘future.call.arguments’ to environment
[08:24:53.418] - copied ‘...future.FUN’ to environment
[08:24:53.418] - copied ‘...future.elements_ii’ to environment
[08:24:53.418] - copied ‘...future.seeds_ii’ to environment
[08:24:53.418] - copied ‘...future.globals.maxSize’ to environment
[08:24:53.418] assign_globals() ... done
[08:24:53.418] requestCore(): workers = 2
[08:24:53.421] MulticoreFuture started
[08:24:53.421] - Launch lazy future ... done
[08:24:53.421] run() for ‘MulticoreFuture’ ... done
[08:24:53.422] Created future:
[08:24:53.422] plan(): Setting new future strategy stack:
[08:24:53.422] List of future strategies:
[08:24:53.422] 1. sequential:
[08:24:53.422]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.422]    - tweaked: FALSE
[08:24:53.422]    - call: NULL
[08:24:53.423] plan(): nbrOfWorkers() = 1
[08:24:53.425] plan(): Setting new future strategy stack:
[08:24:53.426] List of future strategies:
[08:24:53.426] 1. multicore:
[08:24:53.426]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:53.426]    - tweaked: FALSE
[08:24:53.426]    - call: plan(strategy)
[08:24:53.429] plan(): nbrOfWorkers() = 2
[08:24:53.422] MulticoreFuture:
[08:24:53.422] Label: ‘future_apply-1’
[08:24:53.422] Expression:
[08:24:53.422] {
[08:24:53.422]     do.call(function(...) {
[08:24:53.422]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.422]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.422]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.422]             on.exit(options(oopts), add = TRUE)
[08:24:53.422]         }
[08:24:53.422]         {
[08:24:53.422]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.422]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.422]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:53.422]                   envir = globalenv(), inherits = FALSE)
[08:24:53.422]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.422]             })
[08:24:53.422]         }
[08:24:53.422]     }, args = future.call.arguments)
[08:24:53.422] }
[08:24:53.422] Lazy evaluation: FALSE
[08:24:53.422] Asynchronous evaluation: TRUE
[08:24:53.422] Local evaluation: TRUE
[08:24:53.422] Environment: R_GlobalEnv
[08:24:53.422] Capture standard output: TRUE
[08:24:53.422] Capture condition classes: <none>
[08:24:53.422] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:53.422] Packages: <none>
[08:24:53.422] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:24:53.422] Resolved: TRUE
[08:24:53.422] Value: <not collected>
[08:24:53.422] Conditions captured: <none>
[08:24:53.422] Early signaling: FALSE
[08:24:53.422] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:53.422] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.430] Chunk #1 of 2 ... DONE
[08:24:53.430] Chunk #2 of 2 ...
[08:24:53.431]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:53.431]  - seeds: [1] <seeds>
[08:24:53.431]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.431] getGlobalsAndPackages() ...
[08:24:53.431] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.431] Resolving globals: FALSE
[08:24:53.432] Tweak future expression to call with '...' arguments ...
[08:24:53.432] {
[08:24:53.432]     do.call(function(...) {
[08:24:53.432]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.432]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.432]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.432]             on.exit(options(oopts), add = TRUE)
[08:24:53.432]         }
[08:24:53.432]         {
[08:24:53.432]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.432]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.432]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:53.432]                   envir = globalenv(), inherits = FALSE)
[08:24:53.432]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.432]             })
[08:24:53.432]         }
[08:24:53.432]     }, args = future.call.arguments)
[08:24:53.432] }
[08:24:53.432] Tweak future expression to call with '...' arguments ... DONE
[08:24:53.433] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:53.433] 
[08:24:53.433] getGlobalsAndPackages() ... DONE
[08:24:53.434] run() for ‘Future’ ...
[08:24:53.434] - state: ‘created’
[08:24:53.434] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:24:53.438] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.438] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:24:53.438]   - Field: ‘label’
[08:24:53.438]   - Field: ‘local’
[08:24:53.439]   - Field: ‘owner’
[08:24:53.439]   - Field: ‘envir’
[08:24:53.439]   - Field: ‘workers’
[08:24:53.439]   - Field: ‘packages’
[08:24:53.439]   - Field: ‘gc’
[08:24:53.439]   - Field: ‘job’
[08:24:53.440]   - Field: ‘conditions’
[08:24:53.440]   - Field: ‘expr’
[08:24:53.440]   - Field: ‘uuid’
[08:24:53.440]   - Field: ‘seed’
[08:24:53.440]   - Field: ‘version’
[08:24:53.440]   - Field: ‘result’
[08:24:53.441]   - Field: ‘asynchronous’
[08:24:53.441]   - Field: ‘calls’
[08:24:53.441]   - Field: ‘globals’
[08:24:53.441]   - Field: ‘stdout’
[08:24:53.441]   - Field: ‘earlySignal’
[08:24:53.441]   - Field: ‘lazy’
[08:24:53.441]   - Field: ‘state’
[08:24:53.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:24:53.442] - Launch lazy future ...
[08:24:53.442] Packages needed by the future expression (n = 0): <none>
[08:24:53.442] Packages needed by future strategies (n = 0): <none>
[08:24:53.443] {
[08:24:53.443]     {
[08:24:53.443]         {
[08:24:53.443]             ...future.startTime <- base::Sys.time()
[08:24:53.443]             {
[08:24:53.443]                 {
[08:24:53.443]                   {
[08:24:53.443]                     {
[08:24:53.443]                       base::local({
[08:24:53.443]                         has_future <- base::requireNamespace("future", 
[08:24:53.443]                           quietly = TRUE)
[08:24:53.443]                         if (has_future) {
[08:24:53.443]                           ns <- base::getNamespace("future")
[08:24:53.443]                           version <- ns[[".package"]][["version"]]
[08:24:53.443]                           if (is.null(version)) 
[08:24:53.443]                             version <- utils::packageVersion("future")
[08:24:53.443]                         }
[08:24:53.443]                         else {
[08:24:53.443]                           version <- NULL
[08:24:53.443]                         }
[08:24:53.443]                         if (!has_future || version < "1.8.0") {
[08:24:53.443]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:53.443]                             "", base::R.version$version.string), 
[08:24:53.443]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:53.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:53.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:53.443]                               "release", "version")], collapse = " "), 
[08:24:53.443]                             hostname = base::Sys.info()[["nodename"]])
[08:24:53.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:53.443]                             info)
[08:24:53.443]                           info <- base::paste(info, collapse = "; ")
[08:24:53.443]                           if (!has_future) {
[08:24:53.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:53.443]                               info)
[08:24:53.443]                           }
[08:24:53.443]                           else {
[08:24:53.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:53.443]                               info, version)
[08:24:53.443]                           }
[08:24:53.443]                           base::stop(msg)
[08:24:53.443]                         }
[08:24:53.443]                       })
[08:24:53.443]                     }
[08:24:53.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:53.443]                     base::options(mc.cores = 1L)
[08:24:53.443]                   }
[08:24:53.443]                   ...future.strategy.old <- future::plan("list")
[08:24:53.443]                   options(future.plan = NULL)
[08:24:53.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:53.443]                 }
[08:24:53.443]                 ...future.workdir <- getwd()
[08:24:53.443]             }
[08:24:53.443]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:53.443]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:53.443]         }
[08:24:53.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:53.443]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:53.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:53.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:53.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:53.443]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:53.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:53.443]             base::names(...future.oldOptions))
[08:24:53.443]     }
[08:24:53.443]     if (FALSE) {
[08:24:53.443]     }
[08:24:53.443]     else {
[08:24:53.443]         if (TRUE) {
[08:24:53.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:53.443]                 open = "w")
[08:24:53.443]         }
[08:24:53.443]         else {
[08:24:53.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:53.443]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:53.443]         }
[08:24:53.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:53.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:53.443]             base::sink(type = "output", split = FALSE)
[08:24:53.443]             base::close(...future.stdout)
[08:24:53.443]         }, add = TRUE)
[08:24:53.443]     }
[08:24:53.443]     ...future.frame <- base::sys.nframe()
[08:24:53.443]     ...future.conditions <- base::list()
[08:24:53.443]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:53.443]     if (FALSE) {
[08:24:53.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:53.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:53.443]     }
[08:24:53.443]     ...future.result <- base::tryCatch({
[08:24:53.443]         base::withCallingHandlers({
[08:24:53.443]             ...future.value <- base::withVisible(base::local({
[08:24:53.443]                 withCallingHandlers({
[08:24:53.443]                   {
[08:24:53.443]                     do.call(function(...) {
[08:24:53.443]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.443]                       if (!identical(...future.globals.maxSize.org, 
[08:24:53.443]                         ...future.globals.maxSize)) {
[08:24:53.443]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.443]                         on.exit(options(oopts), add = TRUE)
[08:24:53.443]                       }
[08:24:53.443]                       {
[08:24:53.443]                         lapply(seq_along(...future.elements_ii), 
[08:24:53.443]                           FUN = function(jj) {
[08:24:53.443]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.443]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:53.443]                               envir = globalenv(), inherits = FALSE)
[08:24:53.443]                             ...future.FUN(...future.X_jj, ...)
[08:24:53.443]                           })
[08:24:53.443]                       }
[08:24:53.443]                     }, args = future.call.arguments)
[08:24:53.443]                   }
[08:24:53.443]                 }, immediateCondition = function(cond) {
[08:24:53.443]                   save_rds <- function (object, pathname, ...) 
[08:24:53.443]                   {
[08:24:53.443]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:24:53.443]                     if (file_test("-f", pathname_tmp)) {
[08:24:53.443]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.443]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:24:53.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.443]                         fi_tmp[["mtime"]])
[08:24:53.443]                     }
[08:24:53.443]                     tryCatch({
[08:24:53.443]                       saveRDS(object, file = pathname_tmp, ...)
[08:24:53.443]                     }, error = function(ex) {
[08:24:53.443]                       msg <- conditionMessage(ex)
[08:24:53.443]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.443]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:24:53.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.443]                         fi_tmp[["mtime"]], msg)
[08:24:53.443]                       ex$message <- msg
[08:24:53.443]                       stop(ex)
[08:24:53.443]                     })
[08:24:53.443]                     stopifnot(file_test("-f", pathname_tmp))
[08:24:53.443]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:24:53.443]                     if (!res || file_test("-f", pathname_tmp)) {
[08:24:53.443]                       fi_tmp <- file.info(pathname_tmp)
[08:24:53.443]                       fi <- file.info(pathname)
[08:24:53.443]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:24:53.443]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:24:53.443]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:24:53.443]                         fi[["size"]], fi[["mtime"]])
[08:24:53.443]                       stop(msg)
[08:24:53.443]                     }
[08:24:53.443]                     invisible(pathname)
[08:24:53.443]                   }
[08:24:53.443]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:24:53.443]                     rootPath = tempdir()) 
[08:24:53.443]                   {
[08:24:53.443]                     obj <- list(time = Sys.time(), condition = cond)
[08:24:53.443]                     file <- tempfile(pattern = class(cond)[1], 
[08:24:53.443]                       tmpdir = path, fileext = ".rds")
[08:24:53.443]                     save_rds(obj, file)
[08:24:53.443]                   }
[08:24:53.443]                   saveImmediateCondition(cond, path = "/tmp/Rtmpz5rxsi/.future/immediateConditions")
[08:24:53.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.443]                   {
[08:24:53.443]                     inherits <- base::inherits
[08:24:53.443]                     invokeRestart <- base::invokeRestart
[08:24:53.443]                     is.null <- base::is.null
[08:24:53.443]                     muffled <- FALSE
[08:24:53.443]                     if (inherits(cond, "message")) {
[08:24:53.443]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:53.443]                       if (muffled) 
[08:24:53.443]                         invokeRestart("muffleMessage")
[08:24:53.443]                     }
[08:24:53.443]                     else if (inherits(cond, "warning")) {
[08:24:53.443]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:53.443]                       if (muffled) 
[08:24:53.443]                         invokeRestart("muffleWarning")
[08:24:53.443]                     }
[08:24:53.443]                     else if (inherits(cond, "condition")) {
[08:24:53.443]                       if (!is.null(pattern)) {
[08:24:53.443]                         computeRestarts <- base::computeRestarts
[08:24:53.443]                         grepl <- base::grepl
[08:24:53.443]                         restarts <- computeRestarts(cond)
[08:24:53.443]                         for (restart in restarts) {
[08:24:53.443]                           name <- restart$name
[08:24:53.443]                           if (is.null(name)) 
[08:24:53.443]                             next
[08:24:53.443]                           if (!grepl(pattern, name)) 
[08:24:53.443]                             next
[08:24:53.443]                           invokeRestart(restart)
[08:24:53.443]                           muffled <- TRUE
[08:24:53.443]                           break
[08:24:53.443]                         }
[08:24:53.443]                       }
[08:24:53.443]                     }
[08:24:53.443]                     invisible(muffled)
[08:24:53.443]                   }
[08:24:53.443]                   muffleCondition(cond)
[08:24:53.443]                 })
[08:24:53.443]             }))
[08:24:53.443]             future::FutureResult(value = ...future.value$value, 
[08:24:53.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.443]                   ...future.rng), globalenv = if (FALSE) 
[08:24:53.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:53.443]                     ...future.globalenv.names))
[08:24:53.443]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:53.443]         }, condition = base::local({
[08:24:53.443]             c <- base::c
[08:24:53.443]             inherits <- base::inherits
[08:24:53.443]             invokeRestart <- base::invokeRestart
[08:24:53.443]             length <- base::length
[08:24:53.443]             list <- base::list
[08:24:53.443]             seq.int <- base::seq.int
[08:24:53.443]             signalCondition <- base::signalCondition
[08:24:53.443]             sys.calls <- base::sys.calls
[08:24:53.443]             `[[` <- base::`[[`
[08:24:53.443]             `+` <- base::`+`
[08:24:53.443]             `<<-` <- base::`<<-`
[08:24:53.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:53.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:53.443]                   3L)]
[08:24:53.443]             }
[08:24:53.443]             function(cond) {
[08:24:53.443]                 is_error <- inherits(cond, "error")
[08:24:53.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:53.443]                   NULL)
[08:24:53.443]                 if (is_error) {
[08:24:53.443]                   sessionInformation <- function() {
[08:24:53.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:53.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:53.443]                       search = base::search(), system = base::Sys.info())
[08:24:53.443]                   }
[08:24:53.443]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:53.443]                     cond$call), session = sessionInformation(), 
[08:24:53.443]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:53.443]                   signalCondition(cond)
[08:24:53.443]                 }
[08:24:53.443]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[08:24:53.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:53.443]                   ...future.conditions[[length(...future.conditions) + 
[08:24:53.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:53.443]                   if (TRUE && !signal) {
[08:24:53.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.443]                     {
[08:24:53.443]                       inherits <- base::inherits
[08:24:53.443]                       invokeRestart <- base::invokeRestart
[08:24:53.443]                       is.null <- base::is.null
[08:24:53.443]                       muffled <- FALSE
[08:24:53.443]                       if (inherits(cond, "message")) {
[08:24:53.443]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.443]                         if (muffled) 
[08:24:53.443]                           invokeRestart("muffleMessage")
[08:24:53.443]                       }
[08:24:53.443]                       else if (inherits(cond, "warning")) {
[08:24:53.443]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.443]                         if (muffled) 
[08:24:53.443]                           invokeRestart("muffleWarning")
[08:24:53.443]                       }
[08:24:53.443]                       else if (inherits(cond, "condition")) {
[08:24:53.443]                         if (!is.null(pattern)) {
[08:24:53.443]                           computeRestarts <- base::computeRestarts
[08:24:53.443]                           grepl <- base::grepl
[08:24:53.443]                           restarts <- computeRestarts(cond)
[08:24:53.443]                           for (restart in restarts) {
[08:24:53.443]                             name <- restart$name
[08:24:53.443]                             if (is.null(name)) 
[08:24:53.443]                               next
[08:24:53.443]                             if (!grepl(pattern, name)) 
[08:24:53.443]                               next
[08:24:53.443]                             invokeRestart(restart)
[08:24:53.443]                             muffled <- TRUE
[08:24:53.443]                             break
[08:24:53.443]                           }
[08:24:53.443]                         }
[08:24:53.443]                       }
[08:24:53.443]                       invisible(muffled)
[08:24:53.443]                     }
[08:24:53.443]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.443]                   }
[08:24:53.443]                 }
[08:24:53.443]                 else {
[08:24:53.443]                   if (TRUE) {
[08:24:53.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:53.443]                     {
[08:24:53.443]                       inherits <- base::inherits
[08:24:53.443]                       invokeRestart <- base::invokeRestart
[08:24:53.443]                       is.null <- base::is.null
[08:24:53.443]                       muffled <- FALSE
[08:24:53.443]                       if (inherits(cond, "message")) {
[08:24:53.443]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:53.443]                         if (muffled) 
[08:24:53.443]                           invokeRestart("muffleMessage")
[08:24:53.443]                       }
[08:24:53.443]                       else if (inherits(cond, "warning")) {
[08:24:53.443]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:53.443]                         if (muffled) 
[08:24:53.443]                           invokeRestart("muffleWarning")
[08:24:53.443]                       }
[08:24:53.443]                       else if (inherits(cond, "condition")) {
[08:24:53.443]                         if (!is.null(pattern)) {
[08:24:53.443]                           computeRestarts <- base::computeRestarts
[08:24:53.443]                           grepl <- base::grepl
[08:24:53.443]                           restarts <- computeRestarts(cond)
[08:24:53.443]                           for (restart in restarts) {
[08:24:53.443]                             name <- restart$name
[08:24:53.443]                             if (is.null(name)) 
[08:24:53.443]                               next
[08:24:53.443]                             if (!grepl(pattern, name)) 
[08:24:53.443]                               next
[08:24:53.443]                             invokeRestart(restart)
[08:24:53.443]                             muffled <- TRUE
[08:24:53.443]                             break
[08:24:53.443]                           }
[08:24:53.443]                         }
[08:24:53.443]                       }
[08:24:53.443]                       invisible(muffled)
[08:24:53.443]                     }
[08:24:53.443]                     muffleCondition(cond, pattern = "^muffle")
[08:24:53.443]                   }
[08:24:53.443]                 }
[08:24:53.443]             }
[08:24:53.443]         }))
[08:24:53.443]     }, error = function(ex) {
[08:24:53.443]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:53.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:53.443]                 ...future.rng), started = ...future.startTime, 
[08:24:53.443]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:53.443]             version = "1.8"), class = "FutureResult")
[08:24:53.443]     }, finally = {
[08:24:53.443]         if (!identical(...future.workdir, getwd())) 
[08:24:53.443]             setwd(...future.workdir)
[08:24:53.443]         {
[08:24:53.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:53.443]                 ...future.oldOptions$nwarnings <- NULL
[08:24:53.443]             }
[08:24:53.443]             base::options(...future.oldOptions)
[08:24:53.443]             if (.Platform$OS.type == "windows") {
[08:24:53.443]                 old_names <- names(...future.oldEnvVars)
[08:24:53.443]                 envs <- base::Sys.getenv()
[08:24:53.443]                 names <- names(envs)
[08:24:53.443]                 common <- intersect(names, old_names)
[08:24:53.443]                 added <- setdiff(names, old_names)
[08:24:53.443]                 removed <- setdiff(old_names, names)
[08:24:53.443]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:53.443]                   envs[common]]
[08:24:53.443]                 NAMES <- toupper(changed)
[08:24:53.443]                 args <- list()
[08:24:53.443]                 for (kk in seq_along(NAMES)) {
[08:24:53.443]                   name <- changed[[kk]]
[08:24:53.443]                   NAME <- NAMES[[kk]]
[08:24:53.443]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.443]                     next
[08:24:53.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.443]                 }
[08:24:53.443]                 NAMES <- toupper(added)
[08:24:53.443]                 for (kk in seq_along(NAMES)) {
[08:24:53.443]                   name <- added[[kk]]
[08:24:53.443]                   NAME <- NAMES[[kk]]
[08:24:53.443]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.443]                     next
[08:24:53.443]                   args[[name]] <- ""
[08:24:53.443]                 }
[08:24:53.443]                 NAMES <- toupper(removed)
[08:24:53.443]                 for (kk in seq_along(NAMES)) {
[08:24:53.443]                   name <- removed[[kk]]
[08:24:53.443]                   NAME <- NAMES[[kk]]
[08:24:53.443]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:53.443]                     next
[08:24:53.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:53.443]                 }
[08:24:53.443]                 if (length(args) > 0) 
[08:24:53.443]                   base::do.call(base::Sys.setenv, args = args)
[08:24:53.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:53.443]             }
[08:24:53.443]             else {
[08:24:53.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:53.443]             }
[08:24:53.443]             {
[08:24:53.443]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:53.443]                   0L) {
[08:24:53.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:53.443]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:53.443]                   base::options(opts)
[08:24:53.443]                 }
[08:24:53.443]                 {
[08:24:53.443]                   {
[08:24:53.443]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:53.443]                     NULL
[08:24:53.443]                   }
[08:24:53.443]                   options(future.plan = NULL)
[08:24:53.443]                   if (is.na(NA_character_)) 
[08:24:53.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:53.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:53.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:53.443]                     .init = FALSE)
[08:24:53.443]                 }
[08:24:53.443]             }
[08:24:53.443]         }
[08:24:53.443]     })
[08:24:53.443]     if (TRUE) {
[08:24:53.443]         base::sink(type = "output", split = FALSE)
[08:24:53.443]         if (TRUE) {
[08:24:53.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:53.443]         }
[08:24:53.443]         else {
[08:24:53.443]             ...future.result["stdout"] <- base::list(NULL)
[08:24:53.443]         }
[08:24:53.443]         base::close(...future.stdout)
[08:24:53.443]         ...future.stdout <- NULL
[08:24:53.443]     }
[08:24:53.443]     ...future.result$conditions <- ...future.conditions
[08:24:53.443]     ...future.result$finished <- base::Sys.time()
[08:24:53.443]     ...future.result
[08:24:53.443] }
[08:24:53.447] assign_globals() ...
[08:24:53.447] List of 5
[08:24:53.447]  $ future.call.arguments    : list()
[08:24:53.447]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:53.447]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[08:24:53.447]  $ ...future.elements_ii    :List of 1
[08:24:53.447]   ..$ : int [1:2] 2 4
[08:24:53.447]  $ ...future.seeds_ii       :List of 1
[08:24:53.447]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[08:24:53.447]  $ ...future.globals.maxSize: num Inf
[08:24:53.447]  - attr(*, "resolved")= logi FALSE
[08:24:53.447]  - attr(*, "total_size")= num NA
[08:24:53.447]  - attr(*, "where")=List of 5
[08:24:53.447]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[08:24:53.447]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[08:24:53.447]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[08:24:53.447]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[08:24:53.447]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[08:24:53.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:53.447]  - attr(*, "already-done")= logi TRUE
[08:24:53.461] - copied ‘future.call.arguments’ to environment
[08:24:53.461] - copied ‘...future.FUN’ to environment
[08:24:53.461] - copied ‘...future.elements_ii’ to environment
[08:24:53.461] - copied ‘...future.seeds_ii’ to environment
[08:24:53.462] - copied ‘...future.globals.maxSize’ to environment
[08:24:53.462] assign_globals() ... done
[08:24:53.462] requestCore(): workers = 2
[08:24:53.465] MulticoreFuture started
[08:24:53.465] - Launch lazy future ... done
[08:24:53.466] run() for ‘MulticoreFuture’ ... done
[08:24:53.466] Created future:
[08:24:53.466] plan(): Setting new future strategy stack:
[08:24:53.466] List of future strategies:
[08:24:53.466] 1. sequential:
[08:24:53.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.466]    - tweaked: FALSE
[08:24:53.466]    - call: NULL
[08:24:53.467] plan(): nbrOfWorkers() = 1
[08:24:53.470] plan(): Setting new future strategy stack:
[08:24:53.470] List of future strategies:
[08:24:53.470] 1. multicore:
[08:24:53.470]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:24:53.470]    - tweaked: FALSE
[08:24:53.470]    - call: plan(strategy)
[08:24:53.474] plan(): nbrOfWorkers() = 2
[08:24:53.466] MulticoreFuture:
[08:24:53.466] Label: ‘future_apply-2’
[08:24:53.466] Expression:
[08:24:53.466] {
[08:24:53.466]     do.call(function(...) {
[08:24:53.466]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:53.466]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:53.466]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:53.466]             on.exit(options(oopts), add = TRUE)
[08:24:53.466]         }
[08:24:53.466]         {
[08:24:53.466]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:53.466]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:53.466]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:53.466]                   envir = globalenv(), inherits = FALSE)
[08:24:53.466]                 ...future.FUN(...future.X_jj, ...)
[08:24:53.466]             })
[08:24:53.466]         }
[08:24:53.466]     }, args = future.call.arguments)
[08:24:53.466] }
[08:24:53.466] Lazy evaluation: FALSE
[08:24:53.466] Asynchronous evaluation: TRUE
[08:24:53.466] Local evaluation: TRUE
[08:24:53.466] Environment: R_GlobalEnv
[08:24:53.466] Capture standard output: TRUE
[08:24:53.466] Capture condition classes: <none>
[08:24:53.466] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:53.466] Packages: <none>
[08:24:53.466] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:24:53.466] Resolved: TRUE
[08:24:53.466] Value: <not collected>
[08:24:53.466] Conditions captured: <none>
[08:24:53.466] Early signaling: FALSE
[08:24:53.466] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:53.466] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:53.475] Chunk #2 of 2 ... DONE
[08:24:53.475] Launching 2 futures (chunks) ... DONE
[08:24:53.476] Resolving 2 futures (chunks) ...
[08:24:53.476] resolve() on list ...
[08:24:53.476]  recursive: 0
[08:24:53.476]  length: 2
[08:24:53.476] 
[08:24:53.477] Future #1
[08:24:53.477] result() for MulticoreFuture ...
[08:24:53.478] result() for MulticoreFuture ...
[08:24:53.478] result() for MulticoreFuture ... done
[08:24:53.478] result() for MulticoreFuture ... done
[08:24:53.479] result() for MulticoreFuture ...
[08:24:53.479] result() for MulticoreFuture ... done
[08:24:53.479] signalConditionsASAP(MulticoreFuture, pos=1) ...
[08:24:53.479] - nx: 2
[08:24:53.479] - relay: TRUE
[08:24:53.479] - stdout: TRUE
[08:24:53.480] - signal: TRUE
[08:24:53.480] - resignal: FALSE
[08:24:53.480] - force: TRUE
[08:24:53.480] - relayed: [n=2] FALSE, FALSE
[08:24:53.480] - queued futures: [n=2] FALSE, FALSE
[08:24:53.480]  - until=1
[08:24:53.480]  - relaying element #1
[08:24:53.481] result() for MulticoreFuture ...
[08:24:53.481] result() for MulticoreFuture ... done
[08:24:53.481] result() for MulticoreFuture ...
[08:24:53.481] result() for MulticoreFuture ... done
[08:24:53.481] result() for MulticoreFuture ...
[08:24:53.481] result() for MulticoreFuture ... done
[08:24:53.482] result() for MulticoreFuture ...
[08:24:53.482] result() for MulticoreFuture ... done
[08:24:53.482] - relayed: [n=2] TRUE, FALSE
[08:24:53.482] - queued futures: [n=2] TRUE, FALSE
[08:24:53.482] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[08:24:53.482]  length: 1 (resolved future 1)
[08:24:53.483] Future #2
[08:24:53.483] result() for MulticoreFuture ...
[08:24:53.484] result() for MulticoreFuture ...
[08:24:53.484] result() for MulticoreFuture ... done
[08:24:53.484] result() for MulticoreFuture ... done
[08:24:53.484] result() for MulticoreFuture ...
[08:24:53.484] result() for MulticoreFuture ... done
[08:24:53.484] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:24:53.485] - nx: 2
[08:24:53.485] - relay: TRUE
[08:24:53.485] - stdout: TRUE
[08:24:53.485] - signal: TRUE
[08:24:53.485] - resignal: FALSE
[08:24:53.485] - force: TRUE
[08:24:53.485] - relayed: [n=2] TRUE, FALSE
[08:24:53.485] - queued futures: [n=2] TRUE, FALSE
[08:24:53.485]  - until=2
[08:24:53.486]  - relaying element #2
[08:24:53.486] result() for MulticoreFuture ...
[08:24:53.486] result() for MulticoreFuture ... done
[08:24:53.486] result() for MulticoreFuture ...
[08:24:53.486] result() for MulticoreFuture ... done
[08:24:53.486] result() for MulticoreFuture ...
[08:24:53.486] result() for MulticoreFuture ... done
[08:24:53.487] result() for MulticoreFuture ...
[08:24:53.487] result() for MulticoreFuture ... done
[08:24:53.487] - relayed: [n=2] TRUE, TRUE
[08:24:53.487] - queued futures: [n=2] TRUE, TRUE
[08:24:53.487] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:24:53.487]  length: 0 (resolved future 2)
[08:24:53.487] Relaying remaining futures
[08:24:53.487] signalConditionsASAP(NULL, pos=0) ...
[08:24:53.487] - nx: 2
[08:24:53.488] - relay: TRUE
[08:24:53.488] - stdout: TRUE
[08:24:53.488] - signal: TRUE
[08:24:53.488] - resignal: FALSE
[08:24:53.488] - force: TRUE
[08:24:53.488] - relayed: [n=2] TRUE, TRUE
[08:24:53.488] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:53.488] - relayed: [n=2] TRUE, TRUE
[08:24:53.488] - queued futures: [n=2] TRUE, TRUE
[08:24:53.488] signalConditionsASAP(NULL, pos=0) ... done
[08:24:53.489] resolve() on list ... DONE
[08:24:53.489] result() for MulticoreFuture ...
[08:24:53.489] result() for MulticoreFuture ... done
[08:24:53.489] result() for MulticoreFuture ...
[08:24:53.489] result() for MulticoreFuture ... done
[08:24:53.489] result() for MulticoreFuture ...
[08:24:53.489] result() for MulticoreFuture ... done
[08:24:53.489] result() for MulticoreFuture ...
[08:24:53.490] result() for MulticoreFuture ... done
[08:24:53.490]  - Number of value chunks collected: 2
[08:24:53.490] Resolving 2 futures (chunks) ... DONE
[08:24:53.490] Reducing values from 2 chunks ...
[08:24:53.490]  - Number of values collected after concatenation: 2
[08:24:53.490]  - Number of values expected: 2
[08:24:53.490] Reducing values from 2 chunks ... DONE
[08:24:53.490] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[08:24:53.491] plan(): Setting new future strategy stack:
[08:24:53.491] List of future strategies:
[08:24:53.491] 1. sequential:
[08:24:53.491]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:53.491]    - tweaked: FALSE
[08:24:53.491]    - call: plan(sequential)
[08:24:53.492] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[08:24:53.492] plan(): Setting new future strategy stack:
[08:24:53.492] List of future strategies:
[08:24:53.492] 1. multisession:
[08:24:53.492]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:53.492]    - tweaked: FALSE
[08:24:53.492]    - call: plan(strategy)
[08:24:53.493] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:24:53.493] multisession:
[08:24:53.493] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:24:53.493] - tweaked: FALSE
[08:24:53.493] - call: plan(strategy)
[08:24:53.497] getGlobalsAndPackages() ...
[08:24:53.498] Not searching for globals
[08:24:53.498] - globals: [0] <none>
[08:24:53.498] getGlobalsAndPackages() ... DONE
[08:24:54.001] Packages needed by the future expression (n = 0): <none>
[08:24:54.001] Packages needed by future strategies (n = 0): <none>
[08:24:54.001] {
[08:24:54.001]     {
[08:24:54.001]         {
[08:24:54.001]             ...future.startTime <- base::Sys.time()
[08:24:54.001]             {
[08:24:54.001]                 {
[08:24:54.001]                   {
[08:24:54.001]                     {
[08:24:54.001]                       base::local({
[08:24:54.001]                         has_future <- base::requireNamespace("future", 
[08:24:54.001]                           quietly = TRUE)
[08:24:54.001]                         if (has_future) {
[08:24:54.001]                           ns <- base::getNamespace("future")
[08:24:54.001]                           version <- ns[[".package"]][["version"]]
[08:24:54.001]                           if (is.null(version)) 
[08:24:54.001]                             version <- utils::packageVersion("future")
[08:24:54.001]                         }
[08:24:54.001]                         else {
[08:24:54.001]                           version <- NULL
[08:24:54.001]                         }
[08:24:54.001]                         if (!has_future || version < "1.8.0") {
[08:24:54.001]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:54.001]                             "", base::R.version$version.string), 
[08:24:54.001]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:54.001]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:54.001]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:54.001]                               "release", "version")], collapse = " "), 
[08:24:54.001]                             hostname = base::Sys.info()[["nodename"]])
[08:24:54.001]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:54.001]                             info)
[08:24:54.001]                           info <- base::paste(info, collapse = "; ")
[08:24:54.001]                           if (!has_future) {
[08:24:54.001]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:54.001]                               info)
[08:24:54.001]                           }
[08:24:54.001]                           else {
[08:24:54.001]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:54.001]                               info, version)
[08:24:54.001]                           }
[08:24:54.001]                           base::stop(msg)
[08:24:54.001]                         }
[08:24:54.001]                       })
[08:24:54.001]                     }
[08:24:54.001]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:54.001]                     base::options(mc.cores = 1L)
[08:24:54.001]                   }
[08:24:54.001]                   ...future.strategy.old <- future::plan("list")
[08:24:54.001]                   options(future.plan = NULL)
[08:24:54.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:54.001]                 }
[08:24:54.001]                 ...future.workdir <- getwd()
[08:24:54.001]             }
[08:24:54.001]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:54.001]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:54.001]         }
[08:24:54.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:54.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:24:54.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:54.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:54.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:54.001]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:54.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:54.001]             base::names(...future.oldOptions))
[08:24:54.001]     }
[08:24:54.001]     if (FALSE) {
[08:24:54.001]     }
[08:24:54.001]     else {
[08:24:54.001]         if (TRUE) {
[08:24:54.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:54.001]                 open = "w")
[08:24:54.001]         }
[08:24:54.001]         else {
[08:24:54.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:54.001]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:54.001]         }
[08:24:54.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:54.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:54.001]             base::sink(type = "output", split = FALSE)
[08:24:54.001]             base::close(...future.stdout)
[08:24:54.001]         }, add = TRUE)
[08:24:54.001]     }
[08:24:54.001]     ...future.frame <- base::sys.nframe()
[08:24:54.001]     ...future.conditions <- base::list()
[08:24:54.001]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:54.001]     if (FALSE) {
[08:24:54.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:54.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:54.001]     }
[08:24:54.001]     ...future.result <- base::tryCatch({
[08:24:54.001]         base::withCallingHandlers({
[08:24:54.001]             ...future.value <- base::withVisible(base::local({
[08:24:54.001]                 ...future.makeSendCondition <- base::local({
[08:24:54.001]                   sendCondition <- NULL
[08:24:54.001]                   function(frame = 1L) {
[08:24:54.001]                     if (is.function(sendCondition)) 
[08:24:54.001]                       return(sendCondition)
[08:24:54.001]                     ns <- getNamespace("parallel")
[08:24:54.001]                     if (exists("sendData", mode = "function", 
[08:24:54.001]                       envir = ns)) {
[08:24:54.001]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:54.001]                         envir = ns)
[08:24:54.001]                       envir <- sys.frame(frame)
[08:24:54.001]                       master <- NULL
[08:24:54.001]                       while (!identical(envir, .GlobalEnv) && 
[08:24:54.001]                         !identical(envir, emptyenv())) {
[08:24:54.001]                         if (exists("master", mode = "list", envir = envir, 
[08:24:54.001]                           inherits = FALSE)) {
[08:24:54.001]                           master <- get("master", mode = "list", 
[08:24:54.001]                             envir = envir, inherits = FALSE)
[08:24:54.001]                           if (inherits(master, c("SOCKnode", 
[08:24:54.001]                             "SOCK0node"))) {
[08:24:54.001]                             sendCondition <<- function(cond) {
[08:24:54.001]                               data <- list(type = "VALUE", value = cond, 
[08:24:54.001]                                 success = TRUE)
[08:24:54.001]                               parallel_sendData(master, data)
[08:24:54.001]                             }
[08:24:54.001]                             return(sendCondition)
[08:24:54.001]                           }
[08:24:54.001]                         }
[08:24:54.001]                         frame <- frame + 1L
[08:24:54.001]                         envir <- sys.frame(frame)
[08:24:54.001]                       }
[08:24:54.001]                     }
[08:24:54.001]                     sendCondition <<- function(cond) NULL
[08:24:54.001]                   }
[08:24:54.001]                 })
[08:24:54.001]                 withCallingHandlers({
[08:24:54.001]                   NA
[08:24:54.001]                 }, immediateCondition = function(cond) {
[08:24:54.001]                   sendCondition <- ...future.makeSendCondition()
[08:24:54.001]                   sendCondition(cond)
[08:24:54.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.001]                   {
[08:24:54.001]                     inherits <- base::inherits
[08:24:54.001]                     invokeRestart <- base::invokeRestart
[08:24:54.001]                     is.null <- base::is.null
[08:24:54.001]                     muffled <- FALSE
[08:24:54.001]                     if (inherits(cond, "message")) {
[08:24:54.001]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:54.001]                       if (muffled) 
[08:24:54.001]                         invokeRestart("muffleMessage")
[08:24:54.001]                     }
[08:24:54.001]                     else if (inherits(cond, "warning")) {
[08:24:54.001]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:54.001]                       if (muffled) 
[08:24:54.001]                         invokeRestart("muffleWarning")
[08:24:54.001]                     }
[08:24:54.001]                     else if (inherits(cond, "condition")) {
[08:24:54.001]                       if (!is.null(pattern)) {
[08:24:54.001]                         computeRestarts <- base::computeRestarts
[08:24:54.001]                         grepl <- base::grepl
[08:24:54.001]                         restarts <- computeRestarts(cond)
[08:24:54.001]                         for (restart in restarts) {
[08:24:54.001]                           name <- restart$name
[08:24:54.001]                           if (is.null(name)) 
[08:24:54.001]                             next
[08:24:54.001]                           if (!grepl(pattern, name)) 
[08:24:54.001]                             next
[08:24:54.001]                           invokeRestart(restart)
[08:24:54.001]                           muffled <- TRUE
[08:24:54.001]                           break
[08:24:54.001]                         }
[08:24:54.001]                       }
[08:24:54.001]                     }
[08:24:54.001]                     invisible(muffled)
[08:24:54.001]                   }
[08:24:54.001]                   muffleCondition(cond)
[08:24:54.001]                 })
[08:24:54.001]             }))
[08:24:54.001]             future::FutureResult(value = ...future.value$value, 
[08:24:54.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.001]                   ...future.rng), globalenv = if (FALSE) 
[08:24:54.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:54.001]                     ...future.globalenv.names))
[08:24:54.001]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:54.001]         }, condition = base::local({
[08:24:54.001]             c <- base::c
[08:24:54.001]             inherits <- base::inherits
[08:24:54.001]             invokeRestart <- base::invokeRestart
[08:24:54.001]             length <- base::length
[08:24:54.001]             list <- base::list
[08:24:54.001]             seq.int <- base::seq.int
[08:24:54.001]             signalCondition <- base::signalCondition
[08:24:54.001]             sys.calls <- base::sys.calls
[08:24:54.001]             `[[` <- base::`[[`
[08:24:54.001]             `+` <- base::`+`
[08:24:54.001]             `<<-` <- base::`<<-`
[08:24:54.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:54.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:54.001]                   3L)]
[08:24:54.001]             }
[08:24:54.001]             function(cond) {
[08:24:54.001]                 is_error <- inherits(cond, "error")
[08:24:54.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:54.001]                   NULL)
[08:24:54.001]                 if (is_error) {
[08:24:54.001]                   sessionInformation <- function() {
[08:24:54.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:54.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:54.001]                       search = base::search(), system = base::Sys.info())
[08:24:54.001]                   }
[08:24:54.001]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:54.001]                     cond$call), session = sessionInformation(), 
[08:24:54.001]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:54.001]                   signalCondition(cond)
[08:24:54.001]                 }
[08:24:54.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:54.001]                 "immediateCondition"))) {
[08:24:54.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:54.001]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:54.001]                   if (TRUE && !signal) {
[08:24:54.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.001]                     {
[08:24:54.001]                       inherits <- base::inherits
[08:24:54.001]                       invokeRestart <- base::invokeRestart
[08:24:54.001]                       is.null <- base::is.null
[08:24:54.001]                       muffled <- FALSE
[08:24:54.001]                       if (inherits(cond, "message")) {
[08:24:54.001]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.001]                         if (muffled) 
[08:24:54.001]                           invokeRestart("muffleMessage")
[08:24:54.001]                       }
[08:24:54.001]                       else if (inherits(cond, "warning")) {
[08:24:54.001]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.001]                         if (muffled) 
[08:24:54.001]                           invokeRestart("muffleWarning")
[08:24:54.001]                       }
[08:24:54.001]                       else if (inherits(cond, "condition")) {
[08:24:54.001]                         if (!is.null(pattern)) {
[08:24:54.001]                           computeRestarts <- base::computeRestarts
[08:24:54.001]                           grepl <- base::grepl
[08:24:54.001]                           restarts <- computeRestarts(cond)
[08:24:54.001]                           for (restart in restarts) {
[08:24:54.001]                             name <- restart$name
[08:24:54.001]                             if (is.null(name)) 
[08:24:54.001]                               next
[08:24:54.001]                             if (!grepl(pattern, name)) 
[08:24:54.001]                               next
[08:24:54.001]                             invokeRestart(restart)
[08:24:54.001]                             muffled <- TRUE
[08:24:54.001]                             break
[08:24:54.001]                           }
[08:24:54.001]                         }
[08:24:54.001]                       }
[08:24:54.001]                       invisible(muffled)
[08:24:54.001]                     }
[08:24:54.001]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.001]                   }
[08:24:54.001]                 }
[08:24:54.001]                 else {
[08:24:54.001]                   if (TRUE) {
[08:24:54.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.001]                     {
[08:24:54.001]                       inherits <- base::inherits
[08:24:54.001]                       invokeRestart <- base::invokeRestart
[08:24:54.001]                       is.null <- base::is.null
[08:24:54.001]                       muffled <- FALSE
[08:24:54.001]                       if (inherits(cond, "message")) {
[08:24:54.001]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.001]                         if (muffled) 
[08:24:54.001]                           invokeRestart("muffleMessage")
[08:24:54.001]                       }
[08:24:54.001]                       else if (inherits(cond, "warning")) {
[08:24:54.001]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.001]                         if (muffled) 
[08:24:54.001]                           invokeRestart("muffleWarning")
[08:24:54.001]                       }
[08:24:54.001]                       else if (inherits(cond, "condition")) {
[08:24:54.001]                         if (!is.null(pattern)) {
[08:24:54.001]                           computeRestarts <- base::computeRestarts
[08:24:54.001]                           grepl <- base::grepl
[08:24:54.001]                           restarts <- computeRestarts(cond)
[08:24:54.001]                           for (restart in restarts) {
[08:24:54.001]                             name <- restart$name
[08:24:54.001]                             if (is.null(name)) 
[08:24:54.001]                               next
[08:24:54.001]                             if (!grepl(pattern, name)) 
[08:24:54.001]                               next
[08:24:54.001]                             invokeRestart(restart)
[08:24:54.001]                             muffled <- TRUE
[08:24:54.001]                             break
[08:24:54.001]                           }
[08:24:54.001]                         }
[08:24:54.001]                       }
[08:24:54.001]                       invisible(muffled)
[08:24:54.001]                     }
[08:24:54.001]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.001]                   }
[08:24:54.001]                 }
[08:24:54.001]             }
[08:24:54.001]         }))
[08:24:54.001]     }, error = function(ex) {
[08:24:54.001]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:54.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.001]                 ...future.rng), started = ...future.startTime, 
[08:24:54.001]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:54.001]             version = "1.8"), class = "FutureResult")
[08:24:54.001]     }, finally = {
[08:24:54.001]         if (!identical(...future.workdir, getwd())) 
[08:24:54.001]             setwd(...future.workdir)
[08:24:54.001]         {
[08:24:54.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:54.001]                 ...future.oldOptions$nwarnings <- NULL
[08:24:54.001]             }
[08:24:54.001]             base::options(...future.oldOptions)
[08:24:54.001]             if (.Platform$OS.type == "windows") {
[08:24:54.001]                 old_names <- names(...future.oldEnvVars)
[08:24:54.001]                 envs <- base::Sys.getenv()
[08:24:54.001]                 names <- names(envs)
[08:24:54.001]                 common <- intersect(names, old_names)
[08:24:54.001]                 added <- setdiff(names, old_names)
[08:24:54.001]                 removed <- setdiff(old_names, names)
[08:24:54.001]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:54.001]                   envs[common]]
[08:24:54.001]                 NAMES <- toupper(changed)
[08:24:54.001]                 args <- list()
[08:24:54.001]                 for (kk in seq_along(NAMES)) {
[08:24:54.001]                   name <- changed[[kk]]
[08:24:54.001]                   NAME <- NAMES[[kk]]
[08:24:54.001]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.001]                     next
[08:24:54.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.001]                 }
[08:24:54.001]                 NAMES <- toupper(added)
[08:24:54.001]                 for (kk in seq_along(NAMES)) {
[08:24:54.001]                   name <- added[[kk]]
[08:24:54.001]                   NAME <- NAMES[[kk]]
[08:24:54.001]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.001]                     next
[08:24:54.001]                   args[[name]] <- ""
[08:24:54.001]                 }
[08:24:54.001]                 NAMES <- toupper(removed)
[08:24:54.001]                 for (kk in seq_along(NAMES)) {
[08:24:54.001]                   name <- removed[[kk]]
[08:24:54.001]                   NAME <- NAMES[[kk]]
[08:24:54.001]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.001]                     next
[08:24:54.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.001]                 }
[08:24:54.001]                 if (length(args) > 0) 
[08:24:54.001]                   base::do.call(base::Sys.setenv, args = args)
[08:24:54.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:54.001]             }
[08:24:54.001]             else {
[08:24:54.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:54.001]             }
[08:24:54.001]             {
[08:24:54.001]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:54.001]                   0L) {
[08:24:54.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:54.001]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:54.001]                   base::options(opts)
[08:24:54.001]                 }
[08:24:54.001]                 {
[08:24:54.001]                   {
[08:24:54.001]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:54.001]                     NULL
[08:24:54.001]                   }
[08:24:54.001]                   options(future.plan = NULL)
[08:24:54.001]                   if (is.na(NA_character_)) 
[08:24:54.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:54.001]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:54.001]                     .init = FALSE)
[08:24:54.001]                 }
[08:24:54.001]             }
[08:24:54.001]         }
[08:24:54.001]     })
[08:24:54.001]     if (TRUE) {
[08:24:54.001]         base::sink(type = "output", split = FALSE)
[08:24:54.001]         if (TRUE) {
[08:24:54.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:54.001]         }
[08:24:54.001]         else {
[08:24:54.001]             ...future.result["stdout"] <- base::list(NULL)
[08:24:54.001]         }
[08:24:54.001]         base::close(...future.stdout)
[08:24:54.001]         ...future.stdout <- NULL
[08:24:54.001]     }
[08:24:54.001]     ...future.result$conditions <- ...future.conditions
[08:24:54.001]     ...future.result$finished <- base::Sys.time()
[08:24:54.001]     ...future.result
[08:24:54.001] }
[08:24:54.056] MultisessionFuture started
[08:24:54.056] result() for ClusterFuture ...
[08:24:54.057] receiveMessageFromWorker() for ClusterFuture ...
[08:24:54.057] - Validating connection of MultisessionFuture
[08:24:54.088] - received message: FutureResult
[08:24:54.088] - Received FutureResult
[08:24:54.088] - Erased future from FutureRegistry
[08:24:54.088] result() for ClusterFuture ...
[08:24:54.088] - result already collected: FutureResult
[08:24:54.088] result() for ClusterFuture ... done
[08:24:54.088] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:54.088] result() for ClusterFuture ... done
[08:24:54.089] result() for ClusterFuture ...
[08:24:54.089] - result already collected: FutureResult
[08:24:54.089] result() for ClusterFuture ... done
[08:24:54.089] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:24:54.090] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[08:24:54.091] getGlobalsAndPackagesXApply() ...
[08:24:54.091]  - future.globals: TRUE
[08:24:54.091] getGlobalsAndPackages() ...
[08:24:54.091] Searching for globals...
[08:24:54.129] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[08:24:54.129] Searching for globals ... DONE
[08:24:54.129] Resolving globals: FALSE
[08:24:54.131] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[08:24:54.132] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[08:24:54.132] - globals: [1] ‘FUN’
[08:24:54.132] 
[08:24:54.132] getGlobalsAndPackages() ... DONE
[08:24:54.133]  - globals found/used: [n=1] ‘FUN’
[08:24:54.133]  - needed namespaces: [n=0] 
[08:24:54.133] Finding globals ... DONE
[08:24:54.133]  - use_args: TRUE
[08:24:54.133]  - Getting '...' globals ...
[08:24:54.133] resolve() on list ...
[08:24:54.134]  recursive: 0
[08:24:54.134]  length: 1
[08:24:54.134]  elements: ‘...’
[08:24:54.134]  length: 0 (resolved future 1)
[08:24:54.134] resolve() on list ... DONE
[08:24:54.134]    - '...' content: [n=0] 
[08:24:54.134] List of 1
[08:24:54.134]  $ ...: list()
[08:24:54.134]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.134]  - attr(*, "where")=List of 1
[08:24:54.134]   ..$ ...:<environment: 0x56540e0b1b18> 
[08:24:54.134]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.134]  - attr(*, "resolved")= logi TRUE
[08:24:54.134]  - attr(*, "total_size")= num NA
[08:24:54.138]  - Getting '...' globals ... DONE
[08:24:54.138] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:54.138] List of 2
[08:24:54.138]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:54.138]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:54.138]  $ ...          : list()
[08:24:54.138]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.138]  - attr(*, "where")=List of 2
[08:24:54.138]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:54.138]   ..$ ...          :<environment: 0x56540e0b1b18> 
[08:24:54.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.138]  - attr(*, "resolved")= logi FALSE
[08:24:54.138]  - attr(*, "total_size")= num 65963
[08:24:54.141] Packages to be attached in all futures: [n=0] 
[08:24:54.141] getGlobalsAndPackagesXApply() ... DONE
[08:24:54.143] future_lapply() ...
[08:24:54.180] Number of chunks: 2
[08:24:54.180] getGlobalsAndPackagesXApply() ...
[08:24:54.180]  - future.globals: <name-value list> with names ‘list()’
[08:24:54.180]  - use_args: TRUE
[08:24:54.181] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:54.181] List of 2
[08:24:54.181]  $ ...          : list()
[08:24:54.181]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.181]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:54.181]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:54.181]  - attr(*, "where")=List of 2
[08:24:54.181]   ..$ ...          :<environment: 0x56540e0b1b18> 
[08:24:54.181]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:54.181]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.181]  - attr(*, "resolved")= logi FALSE
[08:24:54.181]  - attr(*, "total_size")= num NA
[08:24:54.184] Packages to be attached in all futures: [n=0] 
[08:24:54.185] getGlobalsAndPackagesXApply() ... DONE
[08:24:54.185] Number of futures (= number of chunks): 2
[08:24:54.185] Launching 2 futures (chunks) ...
[08:24:54.185] Chunk #1 of 2 ...
[08:24:54.185]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:54.185]  - seeds: <none>
[08:24:54.185]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.185] getGlobalsAndPackages() ...
[08:24:54.185] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.186] Resolving globals: FALSE
[08:24:54.186] Tweak future expression to call with '...' arguments ...
[08:24:54.186] {
[08:24:54.186]     do.call(function(...) {
[08:24:54.186]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.186]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.186]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.186]             on.exit(options(oopts), add = TRUE)
[08:24:54.186]         }
[08:24:54.186]         {
[08:24:54.186]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.186]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.186]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.186]             })
[08:24:54.186]         }
[08:24:54.186]     }, args = future.call.arguments)
[08:24:54.186] }
[08:24:54.186] Tweak future expression to call with '...' arguments ... DONE
[08:24:54.186] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.187] 
[08:24:54.187] getGlobalsAndPackages() ... DONE
[08:24:54.187] run() for ‘Future’ ...
[08:24:54.187] - state: ‘created’
[08:24:54.187] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:54.201] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.201] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:54.202]   - Field: ‘node’
[08:24:54.202]   - Field: ‘label’
[08:24:54.202]   - Field: ‘local’
[08:24:54.202]   - Field: ‘owner’
[08:24:54.202]   - Field: ‘envir’
[08:24:54.202]   - Field: ‘workers’
[08:24:54.202]   - Field: ‘packages’
[08:24:54.202]   - Field: ‘gc’
[08:24:54.202]   - Field: ‘conditions’
[08:24:54.202]   - Field: ‘persistent’
[08:24:54.202]   - Field: ‘expr’
[08:24:54.203]   - Field: ‘uuid’
[08:24:54.203]   - Field: ‘seed’
[08:24:54.203]   - Field: ‘version’
[08:24:54.203]   - Field: ‘result’
[08:24:54.203]   - Field: ‘asynchronous’
[08:24:54.203]   - Field: ‘calls’
[08:24:54.203]   - Field: ‘globals’
[08:24:54.203]   - Field: ‘stdout’
[08:24:54.203]   - Field: ‘earlySignal’
[08:24:54.203]   - Field: ‘lazy’
[08:24:54.203]   - Field: ‘state’
[08:24:54.204] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:54.204] - Launch lazy future ...
[08:24:54.204] Packages needed by the future expression (n = 0): <none>
[08:24:54.204] Packages needed by future strategies (n = 0): <none>
[08:24:54.204] {
[08:24:54.204]     {
[08:24:54.204]         {
[08:24:54.204]             ...future.startTime <- base::Sys.time()
[08:24:54.204]             {
[08:24:54.204]                 {
[08:24:54.204]                   {
[08:24:54.204]                     {
[08:24:54.204]                       base::local({
[08:24:54.204]                         has_future <- base::requireNamespace("future", 
[08:24:54.204]                           quietly = TRUE)
[08:24:54.204]                         if (has_future) {
[08:24:54.204]                           ns <- base::getNamespace("future")
[08:24:54.204]                           version <- ns[[".package"]][["version"]]
[08:24:54.204]                           if (is.null(version)) 
[08:24:54.204]                             version <- utils::packageVersion("future")
[08:24:54.204]                         }
[08:24:54.204]                         else {
[08:24:54.204]                           version <- NULL
[08:24:54.204]                         }
[08:24:54.204]                         if (!has_future || version < "1.8.0") {
[08:24:54.204]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:54.204]                             "", base::R.version$version.string), 
[08:24:54.204]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:54.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:54.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:54.204]                               "release", "version")], collapse = " "), 
[08:24:54.204]                             hostname = base::Sys.info()[["nodename"]])
[08:24:54.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:54.204]                             info)
[08:24:54.204]                           info <- base::paste(info, collapse = "; ")
[08:24:54.204]                           if (!has_future) {
[08:24:54.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:54.204]                               info)
[08:24:54.204]                           }
[08:24:54.204]                           else {
[08:24:54.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:54.204]                               info, version)
[08:24:54.204]                           }
[08:24:54.204]                           base::stop(msg)
[08:24:54.204]                         }
[08:24:54.204]                       })
[08:24:54.204]                     }
[08:24:54.204]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:54.204]                     base::options(mc.cores = 1L)
[08:24:54.204]                   }
[08:24:54.204]                   ...future.strategy.old <- future::plan("list")
[08:24:54.204]                   options(future.plan = NULL)
[08:24:54.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:54.204]                 }
[08:24:54.204]                 ...future.workdir <- getwd()
[08:24:54.204]             }
[08:24:54.204]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:54.204]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:54.204]         }
[08:24:54.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:54.204]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:54.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:54.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:54.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:54.204]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:54.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:54.204]             base::names(...future.oldOptions))
[08:24:54.204]     }
[08:24:54.204]     if (FALSE) {
[08:24:54.204]     }
[08:24:54.204]     else {
[08:24:54.204]         if (TRUE) {
[08:24:54.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:54.204]                 open = "w")
[08:24:54.204]         }
[08:24:54.204]         else {
[08:24:54.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:54.204]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:54.204]         }
[08:24:54.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:54.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:54.204]             base::sink(type = "output", split = FALSE)
[08:24:54.204]             base::close(...future.stdout)
[08:24:54.204]         }, add = TRUE)
[08:24:54.204]     }
[08:24:54.204]     ...future.frame <- base::sys.nframe()
[08:24:54.204]     ...future.conditions <- base::list()
[08:24:54.204]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:54.204]     if (FALSE) {
[08:24:54.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:54.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:54.204]     }
[08:24:54.204]     ...future.result <- base::tryCatch({
[08:24:54.204]         base::withCallingHandlers({
[08:24:54.204]             ...future.value <- base::withVisible(base::local({
[08:24:54.204]                 ...future.makeSendCondition <- base::local({
[08:24:54.204]                   sendCondition <- NULL
[08:24:54.204]                   function(frame = 1L) {
[08:24:54.204]                     if (is.function(sendCondition)) 
[08:24:54.204]                       return(sendCondition)
[08:24:54.204]                     ns <- getNamespace("parallel")
[08:24:54.204]                     if (exists("sendData", mode = "function", 
[08:24:54.204]                       envir = ns)) {
[08:24:54.204]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:54.204]                         envir = ns)
[08:24:54.204]                       envir <- sys.frame(frame)
[08:24:54.204]                       master <- NULL
[08:24:54.204]                       while (!identical(envir, .GlobalEnv) && 
[08:24:54.204]                         !identical(envir, emptyenv())) {
[08:24:54.204]                         if (exists("master", mode = "list", envir = envir, 
[08:24:54.204]                           inherits = FALSE)) {
[08:24:54.204]                           master <- get("master", mode = "list", 
[08:24:54.204]                             envir = envir, inherits = FALSE)
[08:24:54.204]                           if (inherits(master, c("SOCKnode", 
[08:24:54.204]                             "SOCK0node"))) {
[08:24:54.204]                             sendCondition <<- function(cond) {
[08:24:54.204]                               data <- list(type = "VALUE", value = cond, 
[08:24:54.204]                                 success = TRUE)
[08:24:54.204]                               parallel_sendData(master, data)
[08:24:54.204]                             }
[08:24:54.204]                             return(sendCondition)
[08:24:54.204]                           }
[08:24:54.204]                         }
[08:24:54.204]                         frame <- frame + 1L
[08:24:54.204]                         envir <- sys.frame(frame)
[08:24:54.204]                       }
[08:24:54.204]                     }
[08:24:54.204]                     sendCondition <<- function(cond) NULL
[08:24:54.204]                   }
[08:24:54.204]                 })
[08:24:54.204]                 withCallingHandlers({
[08:24:54.204]                   {
[08:24:54.204]                     do.call(function(...) {
[08:24:54.204]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.204]                       if (!identical(...future.globals.maxSize.org, 
[08:24:54.204]                         ...future.globals.maxSize)) {
[08:24:54.204]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.204]                         on.exit(options(oopts), add = TRUE)
[08:24:54.204]                       }
[08:24:54.204]                       {
[08:24:54.204]                         lapply(seq_along(...future.elements_ii), 
[08:24:54.204]                           FUN = function(jj) {
[08:24:54.204]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.204]                             ...future.FUN(...future.X_jj, ...)
[08:24:54.204]                           })
[08:24:54.204]                       }
[08:24:54.204]                     }, args = future.call.arguments)
[08:24:54.204]                   }
[08:24:54.204]                 }, immediateCondition = function(cond) {
[08:24:54.204]                   sendCondition <- ...future.makeSendCondition()
[08:24:54.204]                   sendCondition(cond)
[08:24:54.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.204]                   {
[08:24:54.204]                     inherits <- base::inherits
[08:24:54.204]                     invokeRestart <- base::invokeRestart
[08:24:54.204]                     is.null <- base::is.null
[08:24:54.204]                     muffled <- FALSE
[08:24:54.204]                     if (inherits(cond, "message")) {
[08:24:54.204]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:54.204]                       if (muffled) 
[08:24:54.204]                         invokeRestart("muffleMessage")
[08:24:54.204]                     }
[08:24:54.204]                     else if (inherits(cond, "warning")) {
[08:24:54.204]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:54.204]                       if (muffled) 
[08:24:54.204]                         invokeRestart("muffleWarning")
[08:24:54.204]                     }
[08:24:54.204]                     else if (inherits(cond, "condition")) {
[08:24:54.204]                       if (!is.null(pattern)) {
[08:24:54.204]                         computeRestarts <- base::computeRestarts
[08:24:54.204]                         grepl <- base::grepl
[08:24:54.204]                         restarts <- computeRestarts(cond)
[08:24:54.204]                         for (restart in restarts) {
[08:24:54.204]                           name <- restart$name
[08:24:54.204]                           if (is.null(name)) 
[08:24:54.204]                             next
[08:24:54.204]                           if (!grepl(pattern, name)) 
[08:24:54.204]                             next
[08:24:54.204]                           invokeRestart(restart)
[08:24:54.204]                           muffled <- TRUE
[08:24:54.204]                           break
[08:24:54.204]                         }
[08:24:54.204]                       }
[08:24:54.204]                     }
[08:24:54.204]                     invisible(muffled)
[08:24:54.204]                   }
[08:24:54.204]                   muffleCondition(cond)
[08:24:54.204]                 })
[08:24:54.204]             }))
[08:24:54.204]             future::FutureResult(value = ...future.value$value, 
[08:24:54.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.204]                   ...future.rng), globalenv = if (FALSE) 
[08:24:54.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:54.204]                     ...future.globalenv.names))
[08:24:54.204]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:54.204]         }, condition = base::local({
[08:24:54.204]             c <- base::c
[08:24:54.204]             inherits <- base::inherits
[08:24:54.204]             invokeRestart <- base::invokeRestart
[08:24:54.204]             length <- base::length
[08:24:54.204]             list <- base::list
[08:24:54.204]             seq.int <- base::seq.int
[08:24:54.204]             signalCondition <- base::signalCondition
[08:24:54.204]             sys.calls <- base::sys.calls
[08:24:54.204]             `[[` <- base::`[[`
[08:24:54.204]             `+` <- base::`+`
[08:24:54.204]             `<<-` <- base::`<<-`
[08:24:54.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:54.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:54.204]                   3L)]
[08:24:54.204]             }
[08:24:54.204]             function(cond) {
[08:24:54.204]                 is_error <- inherits(cond, "error")
[08:24:54.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:54.204]                   NULL)
[08:24:54.204]                 if (is_error) {
[08:24:54.204]                   sessionInformation <- function() {
[08:24:54.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:54.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:54.204]                       search = base::search(), system = base::Sys.info())
[08:24:54.204]                   }
[08:24:54.204]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:54.204]                     cond$call), session = sessionInformation(), 
[08:24:54.204]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:54.204]                   signalCondition(cond)
[08:24:54.204]                 }
[08:24:54.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:54.204]                 "immediateCondition"))) {
[08:24:54.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:54.204]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:54.204]                   if (TRUE && !signal) {
[08:24:54.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.204]                     {
[08:24:54.204]                       inherits <- base::inherits
[08:24:54.204]                       invokeRestart <- base::invokeRestart
[08:24:54.204]                       is.null <- base::is.null
[08:24:54.204]                       muffled <- FALSE
[08:24:54.204]                       if (inherits(cond, "message")) {
[08:24:54.204]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.204]                         if (muffled) 
[08:24:54.204]                           invokeRestart("muffleMessage")
[08:24:54.204]                       }
[08:24:54.204]                       else if (inherits(cond, "warning")) {
[08:24:54.204]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.204]                         if (muffled) 
[08:24:54.204]                           invokeRestart("muffleWarning")
[08:24:54.204]                       }
[08:24:54.204]                       else if (inherits(cond, "condition")) {
[08:24:54.204]                         if (!is.null(pattern)) {
[08:24:54.204]                           computeRestarts <- base::computeRestarts
[08:24:54.204]                           grepl <- base::grepl
[08:24:54.204]                           restarts <- computeRestarts(cond)
[08:24:54.204]                           for (restart in restarts) {
[08:24:54.204]                             name <- restart$name
[08:24:54.204]                             if (is.null(name)) 
[08:24:54.204]                               next
[08:24:54.204]                             if (!grepl(pattern, name)) 
[08:24:54.204]                               next
[08:24:54.204]                             invokeRestart(restart)
[08:24:54.204]                             muffled <- TRUE
[08:24:54.204]                             break
[08:24:54.204]                           }
[08:24:54.204]                         }
[08:24:54.204]                       }
[08:24:54.204]                       invisible(muffled)
[08:24:54.204]                     }
[08:24:54.204]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.204]                   }
[08:24:54.204]                 }
[08:24:54.204]                 else {
[08:24:54.204]                   if (TRUE) {
[08:24:54.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.204]                     {
[08:24:54.204]                       inherits <- base::inherits
[08:24:54.204]                       invokeRestart <- base::invokeRestart
[08:24:54.204]                       is.null <- base::is.null
[08:24:54.204]                       muffled <- FALSE
[08:24:54.204]                       if (inherits(cond, "message")) {
[08:24:54.204]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.204]                         if (muffled) 
[08:24:54.204]                           invokeRestart("muffleMessage")
[08:24:54.204]                       }
[08:24:54.204]                       else if (inherits(cond, "warning")) {
[08:24:54.204]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.204]                         if (muffled) 
[08:24:54.204]                           invokeRestart("muffleWarning")
[08:24:54.204]                       }
[08:24:54.204]                       else if (inherits(cond, "condition")) {
[08:24:54.204]                         if (!is.null(pattern)) {
[08:24:54.204]                           computeRestarts <- base::computeRestarts
[08:24:54.204]                           grepl <- base::grepl
[08:24:54.204]                           restarts <- computeRestarts(cond)
[08:24:54.204]                           for (restart in restarts) {
[08:24:54.204]                             name <- restart$name
[08:24:54.204]                             if (is.null(name)) 
[08:24:54.204]                               next
[08:24:54.204]                             if (!grepl(pattern, name)) 
[08:24:54.204]                               next
[08:24:54.204]                             invokeRestart(restart)
[08:24:54.204]                             muffled <- TRUE
[08:24:54.204]                             break
[08:24:54.204]                           }
[08:24:54.204]                         }
[08:24:54.204]                       }
[08:24:54.204]                       invisible(muffled)
[08:24:54.204]                     }
[08:24:54.204]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.204]                   }
[08:24:54.204]                 }
[08:24:54.204]             }
[08:24:54.204]         }))
[08:24:54.204]     }, error = function(ex) {
[08:24:54.204]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:54.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.204]                 ...future.rng), started = ...future.startTime, 
[08:24:54.204]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:54.204]             version = "1.8"), class = "FutureResult")
[08:24:54.204]     }, finally = {
[08:24:54.204]         if (!identical(...future.workdir, getwd())) 
[08:24:54.204]             setwd(...future.workdir)
[08:24:54.204]         {
[08:24:54.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:54.204]                 ...future.oldOptions$nwarnings <- NULL
[08:24:54.204]             }
[08:24:54.204]             base::options(...future.oldOptions)
[08:24:54.204]             if (.Platform$OS.type == "windows") {
[08:24:54.204]                 old_names <- names(...future.oldEnvVars)
[08:24:54.204]                 envs <- base::Sys.getenv()
[08:24:54.204]                 names <- names(envs)
[08:24:54.204]                 common <- intersect(names, old_names)
[08:24:54.204]                 added <- setdiff(names, old_names)
[08:24:54.204]                 removed <- setdiff(old_names, names)
[08:24:54.204]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:54.204]                   envs[common]]
[08:24:54.204]                 NAMES <- toupper(changed)
[08:24:54.204]                 args <- list()
[08:24:54.204]                 for (kk in seq_along(NAMES)) {
[08:24:54.204]                   name <- changed[[kk]]
[08:24:54.204]                   NAME <- NAMES[[kk]]
[08:24:54.204]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.204]                     next
[08:24:54.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.204]                 }
[08:24:54.204]                 NAMES <- toupper(added)
[08:24:54.204]                 for (kk in seq_along(NAMES)) {
[08:24:54.204]                   name <- added[[kk]]
[08:24:54.204]                   NAME <- NAMES[[kk]]
[08:24:54.204]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.204]                     next
[08:24:54.204]                   args[[name]] <- ""
[08:24:54.204]                 }
[08:24:54.204]                 NAMES <- toupper(removed)
[08:24:54.204]                 for (kk in seq_along(NAMES)) {
[08:24:54.204]                   name <- removed[[kk]]
[08:24:54.204]                   NAME <- NAMES[[kk]]
[08:24:54.204]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.204]                     next
[08:24:54.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.204]                 }
[08:24:54.204]                 if (length(args) > 0) 
[08:24:54.204]                   base::do.call(base::Sys.setenv, args = args)
[08:24:54.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:54.204]             }
[08:24:54.204]             else {
[08:24:54.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:54.204]             }
[08:24:54.204]             {
[08:24:54.204]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:54.204]                   0L) {
[08:24:54.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:54.204]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:54.204]                   base::options(opts)
[08:24:54.204]                 }
[08:24:54.204]                 {
[08:24:54.204]                   {
[08:24:54.204]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:54.204]                     NULL
[08:24:54.204]                   }
[08:24:54.204]                   options(future.plan = NULL)
[08:24:54.204]                   if (is.na(NA_character_)) 
[08:24:54.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:54.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:54.204]                     .init = FALSE)
[08:24:54.204]                 }
[08:24:54.204]             }
[08:24:54.204]         }
[08:24:54.204]     })
[08:24:54.204]     if (TRUE) {
[08:24:54.204]         base::sink(type = "output", split = FALSE)
[08:24:54.204]         if (TRUE) {
[08:24:54.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:54.204]         }
[08:24:54.204]         else {
[08:24:54.204]             ...future.result["stdout"] <- base::list(NULL)
[08:24:54.204]         }
[08:24:54.204]         base::close(...future.stdout)
[08:24:54.204]         ...future.stdout <- NULL
[08:24:54.204]     }
[08:24:54.204]     ...future.result$conditions <- ...future.conditions
[08:24:54.204]     ...future.result$finished <- base::Sys.time()
[08:24:54.204]     ...future.result
[08:24:54.204] }
[08:24:54.208] Exporting 5 global objects (31.96 KiB) to cluster node #1 ...
[08:24:54.208] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:54.208] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:54.209] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ...
[08:24:54.250] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ... DONE
[08:24:54.250] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[08:24:54.250] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[08:24:54.251] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:54.251] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:54.251] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:54.251] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:54.251] Exporting 5 global objects (31.96 KiB) to cluster node #1 ... DONE
[08:24:54.252] MultisessionFuture started
[08:24:54.252] - Launch lazy future ... done
[08:24:54.252] run() for ‘MultisessionFuture’ ... done
[08:24:54.252] Created future:
[08:24:54.252] MultisessionFuture:
[08:24:54.252] Label: ‘future_apply-1’
[08:24:54.252] Expression:
[08:24:54.252] {
[08:24:54.252]     do.call(function(...) {
[08:24:54.252]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.252]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.252]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.252]             on.exit(options(oopts), add = TRUE)
[08:24:54.252]         }
[08:24:54.252]         {
[08:24:54.252]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.252]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.252]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.252]             })
[08:24:54.252]         }
[08:24:54.252]     }, args = future.call.arguments)
[08:24:54.252] }
[08:24:54.252] Lazy evaluation: FALSE
[08:24:54.252] Asynchronous evaluation: TRUE
[08:24:54.252] Local evaluation: TRUE
[08:24:54.252] Environment: R_GlobalEnv
[08:24:54.252] Capture standard output: TRUE
[08:24:54.252] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:54.252] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:54.252] Packages: <none>
[08:24:54.252] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:54.252] Resolved: FALSE
[08:24:54.252] Value: <not collected>
[08:24:54.252] Conditions captured: <none>
[08:24:54.252] Early signaling: FALSE
[08:24:54.252] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:54.252] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.265] Chunk #1 of 2 ... DONE
[08:24:54.265] Chunk #2 of 2 ...
[08:24:54.265]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:54.265]  - seeds: <none>
[08:24:54.265]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.265] getGlobalsAndPackages() ...
[08:24:54.265] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.265] Resolving globals: FALSE
[08:24:54.266] Tweak future expression to call with '...' arguments ...
[08:24:54.266] {
[08:24:54.266]     do.call(function(...) {
[08:24:54.266]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.266]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.266]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.266]             on.exit(options(oopts), add = TRUE)
[08:24:54.266]         }
[08:24:54.266]         {
[08:24:54.266]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.266]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.266]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.266]             })
[08:24:54.266]         }
[08:24:54.266]     }, args = future.call.arguments)
[08:24:54.266] }
[08:24:54.266] Tweak future expression to call with '...' arguments ... DONE
[08:24:54.266] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.267] 
[08:24:54.267] getGlobalsAndPackages() ... DONE
[08:24:54.267] run() for ‘Future’ ...
[08:24:54.267] - state: ‘created’
[08:24:54.267] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:54.281] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:54.282]   - Field: ‘node’
[08:24:54.282]   - Field: ‘label’
[08:24:54.282]   - Field: ‘local’
[08:24:54.282]   - Field: ‘owner’
[08:24:54.282]   - Field: ‘envir’
[08:24:54.282]   - Field: ‘workers’
[08:24:54.282]   - Field: ‘packages’
[08:24:54.282]   - Field: ‘gc’
[08:24:54.283]   - Field: ‘conditions’
[08:24:54.283]   - Field: ‘persistent’
[08:24:54.283]   - Field: ‘expr’
[08:24:54.283]   - Field: ‘uuid’
[08:24:54.283]   - Field: ‘seed’
[08:24:54.283]   - Field: ‘version’
[08:24:54.283]   - Field: ‘result’
[08:24:54.283]   - Field: ‘asynchronous’
[08:24:54.283]   - Field: ‘calls’
[08:24:54.283]   - Field: ‘globals’
[08:24:54.283]   - Field: ‘stdout’
[08:24:54.283]   - Field: ‘earlySignal’
[08:24:54.284]   - Field: ‘lazy’
[08:24:54.284]   - Field: ‘state’
[08:24:54.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:54.284] - Launch lazy future ...
[08:24:54.284] Packages needed by the future expression (n = 0): <none>
[08:24:54.284] Packages needed by future strategies (n = 0): <none>
[08:24:54.285] {
[08:24:54.285]     {
[08:24:54.285]         {
[08:24:54.285]             ...future.startTime <- base::Sys.time()
[08:24:54.285]             {
[08:24:54.285]                 {
[08:24:54.285]                   {
[08:24:54.285]                     {
[08:24:54.285]                       base::local({
[08:24:54.285]                         has_future <- base::requireNamespace("future", 
[08:24:54.285]                           quietly = TRUE)
[08:24:54.285]                         if (has_future) {
[08:24:54.285]                           ns <- base::getNamespace("future")
[08:24:54.285]                           version <- ns[[".package"]][["version"]]
[08:24:54.285]                           if (is.null(version)) 
[08:24:54.285]                             version <- utils::packageVersion("future")
[08:24:54.285]                         }
[08:24:54.285]                         else {
[08:24:54.285]                           version <- NULL
[08:24:54.285]                         }
[08:24:54.285]                         if (!has_future || version < "1.8.0") {
[08:24:54.285]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:54.285]                             "", base::R.version$version.string), 
[08:24:54.285]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:54.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:54.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:54.285]                               "release", "version")], collapse = " "), 
[08:24:54.285]                             hostname = base::Sys.info()[["nodename"]])
[08:24:54.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:54.285]                             info)
[08:24:54.285]                           info <- base::paste(info, collapse = "; ")
[08:24:54.285]                           if (!has_future) {
[08:24:54.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:54.285]                               info)
[08:24:54.285]                           }
[08:24:54.285]                           else {
[08:24:54.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:54.285]                               info, version)
[08:24:54.285]                           }
[08:24:54.285]                           base::stop(msg)
[08:24:54.285]                         }
[08:24:54.285]                       })
[08:24:54.285]                     }
[08:24:54.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:54.285]                     base::options(mc.cores = 1L)
[08:24:54.285]                   }
[08:24:54.285]                   ...future.strategy.old <- future::plan("list")
[08:24:54.285]                   options(future.plan = NULL)
[08:24:54.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:54.285]                 }
[08:24:54.285]                 ...future.workdir <- getwd()
[08:24:54.285]             }
[08:24:54.285]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:54.285]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:54.285]         }
[08:24:54.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:54.285]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:54.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:54.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:54.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:54.285]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:54.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:54.285]             base::names(...future.oldOptions))
[08:24:54.285]     }
[08:24:54.285]     if (FALSE) {
[08:24:54.285]     }
[08:24:54.285]     else {
[08:24:54.285]         if (TRUE) {
[08:24:54.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:54.285]                 open = "w")
[08:24:54.285]         }
[08:24:54.285]         else {
[08:24:54.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:54.285]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:54.285]         }
[08:24:54.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:54.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:54.285]             base::sink(type = "output", split = FALSE)
[08:24:54.285]             base::close(...future.stdout)
[08:24:54.285]         }, add = TRUE)
[08:24:54.285]     }
[08:24:54.285]     ...future.frame <- base::sys.nframe()
[08:24:54.285]     ...future.conditions <- base::list()
[08:24:54.285]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:54.285]     if (FALSE) {
[08:24:54.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:54.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:54.285]     }
[08:24:54.285]     ...future.result <- base::tryCatch({
[08:24:54.285]         base::withCallingHandlers({
[08:24:54.285]             ...future.value <- base::withVisible(base::local({
[08:24:54.285]                 ...future.makeSendCondition <- base::local({
[08:24:54.285]                   sendCondition <- NULL
[08:24:54.285]                   function(frame = 1L) {
[08:24:54.285]                     if (is.function(sendCondition)) 
[08:24:54.285]                       return(sendCondition)
[08:24:54.285]                     ns <- getNamespace("parallel")
[08:24:54.285]                     if (exists("sendData", mode = "function", 
[08:24:54.285]                       envir = ns)) {
[08:24:54.285]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:54.285]                         envir = ns)
[08:24:54.285]                       envir <- sys.frame(frame)
[08:24:54.285]                       master <- NULL
[08:24:54.285]                       while (!identical(envir, .GlobalEnv) && 
[08:24:54.285]                         !identical(envir, emptyenv())) {
[08:24:54.285]                         if (exists("master", mode = "list", envir = envir, 
[08:24:54.285]                           inherits = FALSE)) {
[08:24:54.285]                           master <- get("master", mode = "list", 
[08:24:54.285]                             envir = envir, inherits = FALSE)
[08:24:54.285]                           if (inherits(master, c("SOCKnode", 
[08:24:54.285]                             "SOCK0node"))) {
[08:24:54.285]                             sendCondition <<- function(cond) {
[08:24:54.285]                               data <- list(type = "VALUE", value = cond, 
[08:24:54.285]                                 success = TRUE)
[08:24:54.285]                               parallel_sendData(master, data)
[08:24:54.285]                             }
[08:24:54.285]                             return(sendCondition)
[08:24:54.285]                           }
[08:24:54.285]                         }
[08:24:54.285]                         frame <- frame + 1L
[08:24:54.285]                         envir <- sys.frame(frame)
[08:24:54.285]                       }
[08:24:54.285]                     }
[08:24:54.285]                     sendCondition <<- function(cond) NULL
[08:24:54.285]                   }
[08:24:54.285]                 })
[08:24:54.285]                 withCallingHandlers({
[08:24:54.285]                   {
[08:24:54.285]                     do.call(function(...) {
[08:24:54.285]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.285]                       if (!identical(...future.globals.maxSize.org, 
[08:24:54.285]                         ...future.globals.maxSize)) {
[08:24:54.285]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.285]                         on.exit(options(oopts), add = TRUE)
[08:24:54.285]                       }
[08:24:54.285]                       {
[08:24:54.285]                         lapply(seq_along(...future.elements_ii), 
[08:24:54.285]                           FUN = function(jj) {
[08:24:54.285]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.285]                             ...future.FUN(...future.X_jj, ...)
[08:24:54.285]                           })
[08:24:54.285]                       }
[08:24:54.285]                     }, args = future.call.arguments)
[08:24:54.285]                   }
[08:24:54.285]                 }, immediateCondition = function(cond) {
[08:24:54.285]                   sendCondition <- ...future.makeSendCondition()
[08:24:54.285]                   sendCondition(cond)
[08:24:54.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.285]                   {
[08:24:54.285]                     inherits <- base::inherits
[08:24:54.285]                     invokeRestart <- base::invokeRestart
[08:24:54.285]                     is.null <- base::is.null
[08:24:54.285]                     muffled <- FALSE
[08:24:54.285]                     if (inherits(cond, "message")) {
[08:24:54.285]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:54.285]                       if (muffled) 
[08:24:54.285]                         invokeRestart("muffleMessage")
[08:24:54.285]                     }
[08:24:54.285]                     else if (inherits(cond, "warning")) {
[08:24:54.285]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:54.285]                       if (muffled) 
[08:24:54.285]                         invokeRestart("muffleWarning")
[08:24:54.285]                     }
[08:24:54.285]                     else if (inherits(cond, "condition")) {
[08:24:54.285]                       if (!is.null(pattern)) {
[08:24:54.285]                         computeRestarts <- base::computeRestarts
[08:24:54.285]                         grepl <- base::grepl
[08:24:54.285]                         restarts <- computeRestarts(cond)
[08:24:54.285]                         for (restart in restarts) {
[08:24:54.285]                           name <- restart$name
[08:24:54.285]                           if (is.null(name)) 
[08:24:54.285]                             next
[08:24:54.285]                           if (!grepl(pattern, name)) 
[08:24:54.285]                             next
[08:24:54.285]                           invokeRestart(restart)
[08:24:54.285]                           muffled <- TRUE
[08:24:54.285]                           break
[08:24:54.285]                         }
[08:24:54.285]                       }
[08:24:54.285]                     }
[08:24:54.285]                     invisible(muffled)
[08:24:54.285]                   }
[08:24:54.285]                   muffleCondition(cond)
[08:24:54.285]                 })
[08:24:54.285]             }))
[08:24:54.285]             future::FutureResult(value = ...future.value$value, 
[08:24:54.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.285]                   ...future.rng), globalenv = if (FALSE) 
[08:24:54.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:54.285]                     ...future.globalenv.names))
[08:24:54.285]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:54.285]         }, condition = base::local({
[08:24:54.285]             c <- base::c
[08:24:54.285]             inherits <- base::inherits
[08:24:54.285]             invokeRestart <- base::invokeRestart
[08:24:54.285]             length <- base::length
[08:24:54.285]             list <- base::list
[08:24:54.285]             seq.int <- base::seq.int
[08:24:54.285]             signalCondition <- base::signalCondition
[08:24:54.285]             sys.calls <- base::sys.calls
[08:24:54.285]             `[[` <- base::`[[`
[08:24:54.285]             `+` <- base::`+`
[08:24:54.285]             `<<-` <- base::`<<-`
[08:24:54.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:54.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:54.285]                   3L)]
[08:24:54.285]             }
[08:24:54.285]             function(cond) {
[08:24:54.285]                 is_error <- inherits(cond, "error")
[08:24:54.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:54.285]                   NULL)
[08:24:54.285]                 if (is_error) {
[08:24:54.285]                   sessionInformation <- function() {
[08:24:54.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:54.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:54.285]                       search = base::search(), system = base::Sys.info())
[08:24:54.285]                   }
[08:24:54.285]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:54.285]                     cond$call), session = sessionInformation(), 
[08:24:54.285]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:54.285]                   signalCondition(cond)
[08:24:54.285]                 }
[08:24:54.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:54.285]                 "immediateCondition"))) {
[08:24:54.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:54.285]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:54.285]                   if (TRUE && !signal) {
[08:24:54.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.285]                     {
[08:24:54.285]                       inherits <- base::inherits
[08:24:54.285]                       invokeRestart <- base::invokeRestart
[08:24:54.285]                       is.null <- base::is.null
[08:24:54.285]                       muffled <- FALSE
[08:24:54.285]                       if (inherits(cond, "message")) {
[08:24:54.285]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.285]                         if (muffled) 
[08:24:54.285]                           invokeRestart("muffleMessage")
[08:24:54.285]                       }
[08:24:54.285]                       else if (inherits(cond, "warning")) {
[08:24:54.285]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.285]                         if (muffled) 
[08:24:54.285]                           invokeRestart("muffleWarning")
[08:24:54.285]                       }
[08:24:54.285]                       else if (inherits(cond, "condition")) {
[08:24:54.285]                         if (!is.null(pattern)) {
[08:24:54.285]                           computeRestarts <- base::computeRestarts
[08:24:54.285]                           grepl <- base::grepl
[08:24:54.285]                           restarts <- computeRestarts(cond)
[08:24:54.285]                           for (restart in restarts) {
[08:24:54.285]                             name <- restart$name
[08:24:54.285]                             if (is.null(name)) 
[08:24:54.285]                               next
[08:24:54.285]                             if (!grepl(pattern, name)) 
[08:24:54.285]                               next
[08:24:54.285]                             invokeRestart(restart)
[08:24:54.285]                             muffled <- TRUE
[08:24:54.285]                             break
[08:24:54.285]                           }
[08:24:54.285]                         }
[08:24:54.285]                       }
[08:24:54.285]                       invisible(muffled)
[08:24:54.285]                     }
[08:24:54.285]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.285]                   }
[08:24:54.285]                 }
[08:24:54.285]                 else {
[08:24:54.285]                   if (TRUE) {
[08:24:54.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.285]                     {
[08:24:54.285]                       inherits <- base::inherits
[08:24:54.285]                       invokeRestart <- base::invokeRestart
[08:24:54.285]                       is.null <- base::is.null
[08:24:54.285]                       muffled <- FALSE
[08:24:54.285]                       if (inherits(cond, "message")) {
[08:24:54.285]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.285]                         if (muffled) 
[08:24:54.285]                           invokeRestart("muffleMessage")
[08:24:54.285]                       }
[08:24:54.285]                       else if (inherits(cond, "warning")) {
[08:24:54.285]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.285]                         if (muffled) 
[08:24:54.285]                           invokeRestart("muffleWarning")
[08:24:54.285]                       }
[08:24:54.285]                       else if (inherits(cond, "condition")) {
[08:24:54.285]                         if (!is.null(pattern)) {
[08:24:54.285]                           computeRestarts <- base::computeRestarts
[08:24:54.285]                           grepl <- base::grepl
[08:24:54.285]                           restarts <- computeRestarts(cond)
[08:24:54.285]                           for (restart in restarts) {
[08:24:54.285]                             name <- restart$name
[08:24:54.285]                             if (is.null(name)) 
[08:24:54.285]                               next
[08:24:54.285]                             if (!grepl(pattern, name)) 
[08:24:54.285]                               next
[08:24:54.285]                             invokeRestart(restart)
[08:24:54.285]                             muffled <- TRUE
[08:24:54.285]                             break
[08:24:54.285]                           }
[08:24:54.285]                         }
[08:24:54.285]                       }
[08:24:54.285]                       invisible(muffled)
[08:24:54.285]                     }
[08:24:54.285]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.285]                   }
[08:24:54.285]                 }
[08:24:54.285]             }
[08:24:54.285]         }))
[08:24:54.285]     }, error = function(ex) {
[08:24:54.285]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:54.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.285]                 ...future.rng), started = ...future.startTime, 
[08:24:54.285]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:54.285]             version = "1.8"), class = "FutureResult")
[08:24:54.285]     }, finally = {
[08:24:54.285]         if (!identical(...future.workdir, getwd())) 
[08:24:54.285]             setwd(...future.workdir)
[08:24:54.285]         {
[08:24:54.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:54.285]                 ...future.oldOptions$nwarnings <- NULL
[08:24:54.285]             }
[08:24:54.285]             base::options(...future.oldOptions)
[08:24:54.285]             if (.Platform$OS.type == "windows") {
[08:24:54.285]                 old_names <- names(...future.oldEnvVars)
[08:24:54.285]                 envs <- base::Sys.getenv()
[08:24:54.285]                 names <- names(envs)
[08:24:54.285]                 common <- intersect(names, old_names)
[08:24:54.285]                 added <- setdiff(names, old_names)
[08:24:54.285]                 removed <- setdiff(old_names, names)
[08:24:54.285]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:54.285]                   envs[common]]
[08:24:54.285]                 NAMES <- toupper(changed)
[08:24:54.285]                 args <- list()
[08:24:54.285]                 for (kk in seq_along(NAMES)) {
[08:24:54.285]                   name <- changed[[kk]]
[08:24:54.285]                   NAME <- NAMES[[kk]]
[08:24:54.285]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.285]                     next
[08:24:54.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.285]                 }
[08:24:54.285]                 NAMES <- toupper(added)
[08:24:54.285]                 for (kk in seq_along(NAMES)) {
[08:24:54.285]                   name <- added[[kk]]
[08:24:54.285]                   NAME <- NAMES[[kk]]
[08:24:54.285]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.285]                     next
[08:24:54.285]                   args[[name]] <- ""
[08:24:54.285]                 }
[08:24:54.285]                 NAMES <- toupper(removed)
[08:24:54.285]                 for (kk in seq_along(NAMES)) {
[08:24:54.285]                   name <- removed[[kk]]
[08:24:54.285]                   NAME <- NAMES[[kk]]
[08:24:54.285]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.285]                     next
[08:24:54.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.285]                 }
[08:24:54.285]                 if (length(args) > 0) 
[08:24:54.285]                   base::do.call(base::Sys.setenv, args = args)
[08:24:54.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:54.285]             }
[08:24:54.285]             else {
[08:24:54.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:54.285]             }
[08:24:54.285]             {
[08:24:54.285]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:54.285]                   0L) {
[08:24:54.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:54.285]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:54.285]                   base::options(opts)
[08:24:54.285]                 }
[08:24:54.285]                 {
[08:24:54.285]                   {
[08:24:54.285]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:54.285]                     NULL
[08:24:54.285]                   }
[08:24:54.285]                   options(future.plan = NULL)
[08:24:54.285]                   if (is.na(NA_character_)) 
[08:24:54.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:54.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:54.285]                     .init = FALSE)
[08:24:54.285]                 }
[08:24:54.285]             }
[08:24:54.285]         }
[08:24:54.285]     })
[08:24:54.285]     if (TRUE) {
[08:24:54.285]         base::sink(type = "output", split = FALSE)
[08:24:54.285]         if (TRUE) {
[08:24:54.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:54.285]         }
[08:24:54.285]         else {
[08:24:54.285]             ...future.result["stdout"] <- base::list(NULL)
[08:24:54.285]         }
[08:24:54.285]         base::close(...future.stdout)
[08:24:54.285]         ...future.stdout <- NULL
[08:24:54.285]     }
[08:24:54.285]     ...future.result$conditions <- ...future.conditions
[08:24:54.285]     ...future.result$finished <- base::Sys.time()
[08:24:54.285]     ...future.result
[08:24:54.285] }
[08:24:54.339] Exporting 5 global objects (31.96 KiB) to cluster node #2 ...
[08:24:54.340] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:54.340] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:54.341] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ...
[08:24:54.382] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ... DONE
[08:24:54.382] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[08:24:54.383] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[08:24:54.383] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:54.383] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:54.383] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:54.384] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:54.384] Exporting 5 global objects (31.96 KiB) to cluster node #2 ... DONE
[08:24:54.385] MultisessionFuture started
[08:24:54.385] - Launch lazy future ... done
[08:24:54.385] run() for ‘MultisessionFuture’ ... done
[08:24:54.385] Created future:
[08:24:54.385] MultisessionFuture:
[08:24:54.385] Label: ‘future_apply-2’
[08:24:54.385] Expression:
[08:24:54.385] {
[08:24:54.385]     do.call(function(...) {
[08:24:54.385]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.385]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.385]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.385]             on.exit(options(oopts), add = TRUE)
[08:24:54.385]         }
[08:24:54.385]         {
[08:24:54.385]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.385]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.385]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.385]             })
[08:24:54.385]         }
[08:24:54.385]     }, args = future.call.arguments)
[08:24:54.385] }
[08:24:54.385] Lazy evaluation: FALSE
[08:24:54.385] Asynchronous evaluation: TRUE
[08:24:54.385] Local evaluation: TRUE
[08:24:54.385] Environment: R_GlobalEnv
[08:24:54.385] Capture standard output: TRUE
[08:24:54.385] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:54.385] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:54.385] Packages: <none>
[08:24:54.385] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:54.385] Resolved: FALSE
[08:24:54.385] Value: <not collected>
[08:24:54.385] Conditions captured: <none>
[08:24:54.385] Early signaling: FALSE
[08:24:54.385] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:54.385] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.397] Chunk #2 of 2 ... DONE
[08:24:54.397] Launching 2 futures (chunks) ... DONE
[08:24:54.397] Resolving 2 futures (chunks) ...
[08:24:54.398] resolve() on list ...
[08:24:54.398]  recursive: 0
[08:24:54.398]  length: 2
[08:24:54.398] 
[08:24:54.398] receiveMessageFromWorker() for ClusterFuture ...
[08:24:54.399] - Validating connection of MultisessionFuture
[08:24:54.399] - received message: FutureResult
[08:24:54.399] - Received FutureResult
[08:24:54.399] - Erased future from FutureRegistry
[08:24:54.399] result() for ClusterFuture ...
[08:24:54.399] - result already collected: FutureResult
[08:24:54.399] result() for ClusterFuture ... done
[08:24:54.399] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:54.399] Future #1
[08:24:54.400] result() for ClusterFuture ...
[08:24:54.400] - result already collected: FutureResult
[08:24:54.400] result() for ClusterFuture ... done
[08:24:54.400] result() for ClusterFuture ...
[08:24:54.400] - result already collected: FutureResult
[08:24:54.400] result() for ClusterFuture ... done
[08:24:54.400] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:54.400] - nx: 2
[08:24:54.400] - relay: TRUE
[08:24:54.400] - stdout: TRUE
[08:24:54.400] - signal: TRUE
[08:24:54.400] - resignal: FALSE
[08:24:54.401] - force: TRUE
[08:24:54.401] - relayed: [n=2] FALSE, FALSE
[08:24:54.401] - queued futures: [n=2] FALSE, FALSE
[08:24:54.401]  - until=1
[08:24:54.401]  - relaying element #1
[08:24:54.401] result() for ClusterFuture ...
[08:24:54.401] - result already collected: FutureResult
[08:24:54.401] result() for ClusterFuture ... done
[08:24:54.401] result() for ClusterFuture ...
[08:24:54.401] - result already collected: FutureResult
[08:24:54.401] result() for ClusterFuture ... done
[08:24:54.402] result() for ClusterFuture ...
[08:24:54.402] - result already collected: FutureResult
[08:24:54.402] result() for ClusterFuture ... done
[08:24:54.402] result() for ClusterFuture ...
[08:24:54.402] - result already collected: FutureResult
[08:24:54.402] result() for ClusterFuture ... done
[08:24:54.402] - relayed: [n=2] TRUE, FALSE
[08:24:54.402] - queued futures: [n=2] TRUE, FALSE
[08:24:54.402] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:54.402]  length: 1 (resolved future 1)
[08:24:54.466] receiveMessageFromWorker() for ClusterFuture ...
[08:24:54.466] - Validating connection of MultisessionFuture
[08:24:54.466] - received message: FutureResult
[08:24:54.466] - Received FutureResult
[08:24:54.466] - Erased future from FutureRegistry
[08:24:54.466] result() for ClusterFuture ...
[08:24:54.466] - result already collected: FutureResult
[08:24:54.467] result() for ClusterFuture ... done
[08:24:54.467] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:54.467] Future #2
[08:24:54.467] result() for ClusterFuture ...
[08:24:54.467] - result already collected: FutureResult
[08:24:54.467] result() for ClusterFuture ... done
[08:24:54.467] result() for ClusterFuture ...
[08:24:54.467] - result already collected: FutureResult
[08:24:54.467] result() for ClusterFuture ... done
[08:24:54.467] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:54.467] - nx: 2
[08:24:54.468] - relay: TRUE
[08:24:54.468] - stdout: TRUE
[08:24:54.468] - signal: TRUE
[08:24:54.468] - resignal: FALSE
[08:24:54.468] - force: TRUE
[08:24:54.468] - relayed: [n=2] TRUE, FALSE
[08:24:54.468] - queued futures: [n=2] TRUE, FALSE
[08:24:54.468]  - until=2
[08:24:54.468]  - relaying element #2
[08:24:54.468] result() for ClusterFuture ...
[08:24:54.468] - result already collected: FutureResult
[08:24:54.468] result() for ClusterFuture ... done
[08:24:54.469] result() for ClusterFuture ...
[08:24:54.469] - result already collected: FutureResult
[08:24:54.469] result() for ClusterFuture ... done
[08:24:54.469] result() for ClusterFuture ...
[08:24:54.469] - result already collected: FutureResult
[08:24:54.469] result() for ClusterFuture ... done
[08:24:54.469] result() for ClusterFuture ...
[08:24:54.469] - result already collected: FutureResult
[08:24:54.469] result() for ClusterFuture ... done
[08:24:54.469] - relayed: [n=2] TRUE, TRUE
[08:24:54.469] - queued futures: [n=2] TRUE, TRUE
[08:24:54.470] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:54.470]  length: 0 (resolved future 2)
[08:24:54.470] Relaying remaining futures
[08:24:54.470] signalConditionsASAP(NULL, pos=0) ...
[08:24:54.470] - nx: 2
[08:24:54.470] - relay: TRUE
[08:24:54.470] - stdout: TRUE
[08:24:54.470] - signal: TRUE
[08:24:54.470] - resignal: FALSE
[08:24:54.470] - force: TRUE
[08:24:54.470] - relayed: [n=2] TRUE, TRUE
[08:24:54.470] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:54.471] - relayed: [n=2] TRUE, TRUE
[08:24:54.471] - queued futures: [n=2] TRUE, TRUE
[08:24:54.471] signalConditionsASAP(NULL, pos=0) ... done
[08:24:54.471] resolve() on list ... DONE
[08:24:54.471] result() for ClusterFuture ...
[08:24:54.471] - result already collected: FutureResult
[08:24:54.471] result() for ClusterFuture ... done
[08:24:54.471] result() for ClusterFuture ...
[08:24:54.471] - result already collected: FutureResult
[08:24:54.471] result() for ClusterFuture ... done
[08:24:54.471] result() for ClusterFuture ...
[08:24:54.472] - result already collected: FutureResult
[08:24:54.472] result() for ClusterFuture ... done
[08:24:54.472] result() for ClusterFuture ...
[08:24:54.472] - result already collected: FutureResult
[08:24:54.472] result() for ClusterFuture ... done
[08:24:54.472]  - Number of value chunks collected: 2
[08:24:54.472] Resolving 2 futures (chunks) ... DONE
[08:24:54.472] Reducing values from 2 chunks ...
[08:24:54.472]  - Number of values collected after concatenation: 2
[08:24:54.472]  - Number of values expected: 2
[08:24:54.472] Reducing values from 2 chunks ... DONE
[08:24:54.473] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[08:24:54.473] getGlobalsAndPackagesXApply() ...
[08:24:54.473]  - future.globals: TRUE
[08:24:54.473] getGlobalsAndPackages() ...
[08:24:54.473] Searching for globals...
[08:24:54.507] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[08:24:54.508] Searching for globals ... DONE
[08:24:54.508] Resolving globals: FALSE
[08:24:54.510] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[08:24:54.510] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[08:24:54.510] - globals: [1] ‘FUN’
[08:24:54.510] 
[08:24:54.510] getGlobalsAndPackages() ... DONE
[08:24:54.510]  - globals found/used: [n=1] ‘FUN’
[08:24:54.511]  - needed namespaces: [n=0] 
[08:24:54.511] Finding globals ... DONE
[08:24:54.511]  - use_args: TRUE
[08:24:54.511]  - Getting '...' globals ...
[08:24:54.511] resolve() on list ...
[08:24:54.511]  recursive: 0
[08:24:54.511]  length: 1
[08:24:54.511]  elements: ‘...’
[08:24:54.512]  length: 0 (resolved future 1)
[08:24:54.512] resolve() on list ... DONE
[08:24:54.512]    - '...' content: [n=0] 
[08:24:54.512] List of 1
[08:24:54.512]  $ ...: list()
[08:24:54.512]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.512]  - attr(*, "where")=List of 1
[08:24:54.512]   ..$ ...:<environment: 0x565410426648> 
[08:24:54.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.512]  - attr(*, "resolved")= logi TRUE
[08:24:54.512]  - attr(*, "total_size")= num NA
[08:24:54.515]  - Getting '...' globals ... DONE
[08:24:54.515] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:54.515] List of 2
[08:24:54.515]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:54.515]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:54.515]  $ ...          : list()
[08:24:54.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.515]  - attr(*, "where")=List of 2
[08:24:54.515]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:54.515]   ..$ ...          :<environment: 0x565410426648> 
[08:24:54.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.515]  - attr(*, "resolved")= logi FALSE
[08:24:54.515]  - attr(*, "total_size")= num 65967
[08:24:54.517] Packages to be attached in all futures: [n=0] 
[08:24:54.518] getGlobalsAndPackagesXApply() ... DONE
[08:24:54.519] future_lapply() ...
[08:24:54.552] Number of chunks: 2
[08:24:54.552] getGlobalsAndPackagesXApply() ...
[08:24:54.552]  - future.globals: <name-value list> with names ‘list()’
[08:24:54.553]  - use_args: TRUE
[08:24:54.553] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:54.553] List of 2
[08:24:54.553]  $ ...          : list()
[08:24:54.553]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.553]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[08:24:54.553]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[08:24:54.553]  - attr(*, "where")=List of 2
[08:24:54.553]   ..$ ...          :<environment: 0x565410426648> 
[08:24:54.553]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:54.553]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.553]  - attr(*, "resolved")= logi FALSE
[08:24:54.553]  - attr(*, "total_size")= num NA
[08:24:54.557] Packages to be attached in all futures: [n=0] 
[08:24:54.557] getGlobalsAndPackagesXApply() ... DONE
[08:24:54.557] Number of futures (= number of chunks): 2
[08:24:54.557] Launching 2 futures (chunks) ...
[08:24:54.557] Chunk #1 of 2 ...
[08:24:54.557]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:54.557]  - seeds: <none>
[08:24:54.557]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.557] getGlobalsAndPackages() ...
[08:24:54.558] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.558] Resolving globals: FALSE
[08:24:54.558] Tweak future expression to call with '...' arguments ...
[08:24:54.558] {
[08:24:54.558]     do.call(function(...) {
[08:24:54.558]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.558]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.558]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.558]             on.exit(options(oopts), add = TRUE)
[08:24:54.558]         }
[08:24:54.558]         {
[08:24:54.558]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.558]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.558]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.558]             })
[08:24:54.558]         }
[08:24:54.558]     }, args = future.call.arguments)
[08:24:54.558] }
[08:24:54.558] Tweak future expression to call with '...' arguments ... DONE
[08:24:54.559] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.559] 
[08:24:54.559] getGlobalsAndPackages() ... DONE
[08:24:54.559] run() for ‘Future’ ...
[08:24:54.559] - state: ‘created’
[08:24:54.559] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:54.574] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.574] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:54.574]   - Field: ‘node’
[08:24:54.574]   - Field: ‘label’
[08:24:54.574]   - Field: ‘local’
[08:24:54.574]   - Field: ‘owner’
[08:24:54.574]   - Field: ‘envir’
[08:24:54.574]   - Field: ‘workers’
[08:24:54.574]   - Field: ‘packages’
[08:24:54.575]   - Field: ‘gc’
[08:24:54.575]   - Field: ‘conditions’
[08:24:54.575]   - Field: ‘persistent’
[08:24:54.575]   - Field: ‘expr’
[08:24:54.575]   - Field: ‘uuid’
[08:24:54.575]   - Field: ‘seed’
[08:24:54.575]   - Field: ‘version’
[08:24:54.575]   - Field: ‘result’
[08:24:54.575]   - Field: ‘asynchronous’
[08:24:54.575]   - Field: ‘calls’
[08:24:54.575]   - Field: ‘globals’
[08:24:54.575]   - Field: ‘stdout’
[08:24:54.576]   - Field: ‘earlySignal’
[08:24:54.576]   - Field: ‘lazy’
[08:24:54.576]   - Field: ‘state’
[08:24:54.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:54.576] - Launch lazy future ...
[08:24:54.576] Packages needed by the future expression (n = 0): <none>
[08:24:54.576] Packages needed by future strategies (n = 0): <none>
[08:24:54.577] {
[08:24:54.577]     {
[08:24:54.577]         {
[08:24:54.577]             ...future.startTime <- base::Sys.time()
[08:24:54.577]             {
[08:24:54.577]                 {
[08:24:54.577]                   {
[08:24:54.577]                     {
[08:24:54.577]                       base::local({
[08:24:54.577]                         has_future <- base::requireNamespace("future", 
[08:24:54.577]                           quietly = TRUE)
[08:24:54.577]                         if (has_future) {
[08:24:54.577]                           ns <- base::getNamespace("future")
[08:24:54.577]                           version <- ns[[".package"]][["version"]]
[08:24:54.577]                           if (is.null(version)) 
[08:24:54.577]                             version <- utils::packageVersion("future")
[08:24:54.577]                         }
[08:24:54.577]                         else {
[08:24:54.577]                           version <- NULL
[08:24:54.577]                         }
[08:24:54.577]                         if (!has_future || version < "1.8.0") {
[08:24:54.577]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:54.577]                             "", base::R.version$version.string), 
[08:24:54.577]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:54.577]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:54.577]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:54.577]                               "release", "version")], collapse = " "), 
[08:24:54.577]                             hostname = base::Sys.info()[["nodename"]])
[08:24:54.577]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:54.577]                             info)
[08:24:54.577]                           info <- base::paste(info, collapse = "; ")
[08:24:54.577]                           if (!has_future) {
[08:24:54.577]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:54.577]                               info)
[08:24:54.577]                           }
[08:24:54.577]                           else {
[08:24:54.577]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:54.577]                               info, version)
[08:24:54.577]                           }
[08:24:54.577]                           base::stop(msg)
[08:24:54.577]                         }
[08:24:54.577]                       })
[08:24:54.577]                     }
[08:24:54.577]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:54.577]                     base::options(mc.cores = 1L)
[08:24:54.577]                   }
[08:24:54.577]                   ...future.strategy.old <- future::plan("list")
[08:24:54.577]                   options(future.plan = NULL)
[08:24:54.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:54.577]                 }
[08:24:54.577]                 ...future.workdir <- getwd()
[08:24:54.577]             }
[08:24:54.577]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:54.577]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:54.577]         }
[08:24:54.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:54.577]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:54.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:54.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:54.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:54.577]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:54.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:54.577]             base::names(...future.oldOptions))
[08:24:54.577]     }
[08:24:54.577]     if (FALSE) {
[08:24:54.577]     }
[08:24:54.577]     else {
[08:24:54.577]         if (TRUE) {
[08:24:54.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:54.577]                 open = "w")
[08:24:54.577]         }
[08:24:54.577]         else {
[08:24:54.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:54.577]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:54.577]         }
[08:24:54.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:54.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:54.577]             base::sink(type = "output", split = FALSE)
[08:24:54.577]             base::close(...future.stdout)
[08:24:54.577]         }, add = TRUE)
[08:24:54.577]     }
[08:24:54.577]     ...future.frame <- base::sys.nframe()
[08:24:54.577]     ...future.conditions <- base::list()
[08:24:54.577]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:54.577]     if (FALSE) {
[08:24:54.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:54.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:54.577]     }
[08:24:54.577]     ...future.result <- base::tryCatch({
[08:24:54.577]         base::withCallingHandlers({
[08:24:54.577]             ...future.value <- base::withVisible(base::local({
[08:24:54.577]                 ...future.makeSendCondition <- base::local({
[08:24:54.577]                   sendCondition <- NULL
[08:24:54.577]                   function(frame = 1L) {
[08:24:54.577]                     if (is.function(sendCondition)) 
[08:24:54.577]                       return(sendCondition)
[08:24:54.577]                     ns <- getNamespace("parallel")
[08:24:54.577]                     if (exists("sendData", mode = "function", 
[08:24:54.577]                       envir = ns)) {
[08:24:54.577]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:54.577]                         envir = ns)
[08:24:54.577]                       envir <- sys.frame(frame)
[08:24:54.577]                       master <- NULL
[08:24:54.577]                       while (!identical(envir, .GlobalEnv) && 
[08:24:54.577]                         !identical(envir, emptyenv())) {
[08:24:54.577]                         if (exists("master", mode = "list", envir = envir, 
[08:24:54.577]                           inherits = FALSE)) {
[08:24:54.577]                           master <- get("master", mode = "list", 
[08:24:54.577]                             envir = envir, inherits = FALSE)
[08:24:54.577]                           if (inherits(master, c("SOCKnode", 
[08:24:54.577]                             "SOCK0node"))) {
[08:24:54.577]                             sendCondition <<- function(cond) {
[08:24:54.577]                               data <- list(type = "VALUE", value = cond, 
[08:24:54.577]                                 success = TRUE)
[08:24:54.577]                               parallel_sendData(master, data)
[08:24:54.577]                             }
[08:24:54.577]                             return(sendCondition)
[08:24:54.577]                           }
[08:24:54.577]                         }
[08:24:54.577]                         frame <- frame + 1L
[08:24:54.577]                         envir <- sys.frame(frame)
[08:24:54.577]                       }
[08:24:54.577]                     }
[08:24:54.577]                     sendCondition <<- function(cond) NULL
[08:24:54.577]                   }
[08:24:54.577]                 })
[08:24:54.577]                 withCallingHandlers({
[08:24:54.577]                   {
[08:24:54.577]                     do.call(function(...) {
[08:24:54.577]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.577]                       if (!identical(...future.globals.maxSize.org, 
[08:24:54.577]                         ...future.globals.maxSize)) {
[08:24:54.577]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.577]                         on.exit(options(oopts), add = TRUE)
[08:24:54.577]                       }
[08:24:54.577]                       {
[08:24:54.577]                         lapply(seq_along(...future.elements_ii), 
[08:24:54.577]                           FUN = function(jj) {
[08:24:54.577]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.577]                             ...future.FUN(...future.X_jj, ...)
[08:24:54.577]                           })
[08:24:54.577]                       }
[08:24:54.577]                     }, args = future.call.arguments)
[08:24:54.577]                   }
[08:24:54.577]                 }, immediateCondition = function(cond) {
[08:24:54.577]                   sendCondition <- ...future.makeSendCondition()
[08:24:54.577]                   sendCondition(cond)
[08:24:54.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.577]                   {
[08:24:54.577]                     inherits <- base::inherits
[08:24:54.577]                     invokeRestart <- base::invokeRestart
[08:24:54.577]                     is.null <- base::is.null
[08:24:54.577]                     muffled <- FALSE
[08:24:54.577]                     if (inherits(cond, "message")) {
[08:24:54.577]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:54.577]                       if (muffled) 
[08:24:54.577]                         invokeRestart("muffleMessage")
[08:24:54.577]                     }
[08:24:54.577]                     else if (inherits(cond, "warning")) {
[08:24:54.577]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:54.577]                       if (muffled) 
[08:24:54.577]                         invokeRestart("muffleWarning")
[08:24:54.577]                     }
[08:24:54.577]                     else if (inherits(cond, "condition")) {
[08:24:54.577]                       if (!is.null(pattern)) {
[08:24:54.577]                         computeRestarts <- base::computeRestarts
[08:24:54.577]                         grepl <- base::grepl
[08:24:54.577]                         restarts <- computeRestarts(cond)
[08:24:54.577]                         for (restart in restarts) {
[08:24:54.577]                           name <- restart$name
[08:24:54.577]                           if (is.null(name)) 
[08:24:54.577]                             next
[08:24:54.577]                           if (!grepl(pattern, name)) 
[08:24:54.577]                             next
[08:24:54.577]                           invokeRestart(restart)
[08:24:54.577]                           muffled <- TRUE
[08:24:54.577]                           break
[08:24:54.577]                         }
[08:24:54.577]                       }
[08:24:54.577]                     }
[08:24:54.577]                     invisible(muffled)
[08:24:54.577]                   }
[08:24:54.577]                   muffleCondition(cond)
[08:24:54.577]                 })
[08:24:54.577]             }))
[08:24:54.577]             future::FutureResult(value = ...future.value$value, 
[08:24:54.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.577]                   ...future.rng), globalenv = if (FALSE) 
[08:24:54.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:54.577]                     ...future.globalenv.names))
[08:24:54.577]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:54.577]         }, condition = base::local({
[08:24:54.577]             c <- base::c
[08:24:54.577]             inherits <- base::inherits
[08:24:54.577]             invokeRestart <- base::invokeRestart
[08:24:54.577]             length <- base::length
[08:24:54.577]             list <- base::list
[08:24:54.577]             seq.int <- base::seq.int
[08:24:54.577]             signalCondition <- base::signalCondition
[08:24:54.577]             sys.calls <- base::sys.calls
[08:24:54.577]             `[[` <- base::`[[`
[08:24:54.577]             `+` <- base::`+`
[08:24:54.577]             `<<-` <- base::`<<-`
[08:24:54.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:54.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:54.577]                   3L)]
[08:24:54.577]             }
[08:24:54.577]             function(cond) {
[08:24:54.577]                 is_error <- inherits(cond, "error")
[08:24:54.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:54.577]                   NULL)
[08:24:54.577]                 if (is_error) {
[08:24:54.577]                   sessionInformation <- function() {
[08:24:54.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:54.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:54.577]                       search = base::search(), system = base::Sys.info())
[08:24:54.577]                   }
[08:24:54.577]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:54.577]                     cond$call), session = sessionInformation(), 
[08:24:54.577]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:54.577]                   signalCondition(cond)
[08:24:54.577]                 }
[08:24:54.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:54.577]                 "immediateCondition"))) {
[08:24:54.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:54.577]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:54.577]                   if (TRUE && !signal) {
[08:24:54.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.577]                     {
[08:24:54.577]                       inherits <- base::inherits
[08:24:54.577]                       invokeRestart <- base::invokeRestart
[08:24:54.577]                       is.null <- base::is.null
[08:24:54.577]                       muffled <- FALSE
[08:24:54.577]                       if (inherits(cond, "message")) {
[08:24:54.577]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.577]                         if (muffled) 
[08:24:54.577]                           invokeRestart("muffleMessage")
[08:24:54.577]                       }
[08:24:54.577]                       else if (inherits(cond, "warning")) {
[08:24:54.577]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.577]                         if (muffled) 
[08:24:54.577]                           invokeRestart("muffleWarning")
[08:24:54.577]                       }
[08:24:54.577]                       else if (inherits(cond, "condition")) {
[08:24:54.577]                         if (!is.null(pattern)) {
[08:24:54.577]                           computeRestarts <- base::computeRestarts
[08:24:54.577]                           grepl <- base::grepl
[08:24:54.577]                           restarts <- computeRestarts(cond)
[08:24:54.577]                           for (restart in restarts) {
[08:24:54.577]                             name <- restart$name
[08:24:54.577]                             if (is.null(name)) 
[08:24:54.577]                               next
[08:24:54.577]                             if (!grepl(pattern, name)) 
[08:24:54.577]                               next
[08:24:54.577]                             invokeRestart(restart)
[08:24:54.577]                             muffled <- TRUE
[08:24:54.577]                             break
[08:24:54.577]                           }
[08:24:54.577]                         }
[08:24:54.577]                       }
[08:24:54.577]                       invisible(muffled)
[08:24:54.577]                     }
[08:24:54.577]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.577]                   }
[08:24:54.577]                 }
[08:24:54.577]                 else {
[08:24:54.577]                   if (TRUE) {
[08:24:54.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.577]                     {
[08:24:54.577]                       inherits <- base::inherits
[08:24:54.577]                       invokeRestart <- base::invokeRestart
[08:24:54.577]                       is.null <- base::is.null
[08:24:54.577]                       muffled <- FALSE
[08:24:54.577]                       if (inherits(cond, "message")) {
[08:24:54.577]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.577]                         if (muffled) 
[08:24:54.577]                           invokeRestart("muffleMessage")
[08:24:54.577]                       }
[08:24:54.577]                       else if (inherits(cond, "warning")) {
[08:24:54.577]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.577]                         if (muffled) 
[08:24:54.577]                           invokeRestart("muffleWarning")
[08:24:54.577]                       }
[08:24:54.577]                       else if (inherits(cond, "condition")) {
[08:24:54.577]                         if (!is.null(pattern)) {
[08:24:54.577]                           computeRestarts <- base::computeRestarts
[08:24:54.577]                           grepl <- base::grepl
[08:24:54.577]                           restarts <- computeRestarts(cond)
[08:24:54.577]                           for (restart in restarts) {
[08:24:54.577]                             name <- restart$name
[08:24:54.577]                             if (is.null(name)) 
[08:24:54.577]                               next
[08:24:54.577]                             if (!grepl(pattern, name)) 
[08:24:54.577]                               next
[08:24:54.577]                             invokeRestart(restart)
[08:24:54.577]                             muffled <- TRUE
[08:24:54.577]                             break
[08:24:54.577]                           }
[08:24:54.577]                         }
[08:24:54.577]                       }
[08:24:54.577]                       invisible(muffled)
[08:24:54.577]                     }
[08:24:54.577]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.577]                   }
[08:24:54.577]                 }
[08:24:54.577]             }
[08:24:54.577]         }))
[08:24:54.577]     }, error = function(ex) {
[08:24:54.577]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:54.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.577]                 ...future.rng), started = ...future.startTime, 
[08:24:54.577]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:54.577]             version = "1.8"), class = "FutureResult")
[08:24:54.577]     }, finally = {
[08:24:54.577]         if (!identical(...future.workdir, getwd())) 
[08:24:54.577]             setwd(...future.workdir)
[08:24:54.577]         {
[08:24:54.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:54.577]                 ...future.oldOptions$nwarnings <- NULL
[08:24:54.577]             }
[08:24:54.577]             base::options(...future.oldOptions)
[08:24:54.577]             if (.Platform$OS.type == "windows") {
[08:24:54.577]                 old_names <- names(...future.oldEnvVars)
[08:24:54.577]                 envs <- base::Sys.getenv()
[08:24:54.577]                 names <- names(envs)
[08:24:54.577]                 common <- intersect(names, old_names)
[08:24:54.577]                 added <- setdiff(names, old_names)
[08:24:54.577]                 removed <- setdiff(old_names, names)
[08:24:54.577]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:54.577]                   envs[common]]
[08:24:54.577]                 NAMES <- toupper(changed)
[08:24:54.577]                 args <- list()
[08:24:54.577]                 for (kk in seq_along(NAMES)) {
[08:24:54.577]                   name <- changed[[kk]]
[08:24:54.577]                   NAME <- NAMES[[kk]]
[08:24:54.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.577]                     next
[08:24:54.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.577]                 }
[08:24:54.577]                 NAMES <- toupper(added)
[08:24:54.577]                 for (kk in seq_along(NAMES)) {
[08:24:54.577]                   name <- added[[kk]]
[08:24:54.577]                   NAME <- NAMES[[kk]]
[08:24:54.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.577]                     next
[08:24:54.577]                   args[[name]] <- ""
[08:24:54.577]                 }
[08:24:54.577]                 NAMES <- toupper(removed)
[08:24:54.577]                 for (kk in seq_along(NAMES)) {
[08:24:54.577]                   name <- removed[[kk]]
[08:24:54.577]                   NAME <- NAMES[[kk]]
[08:24:54.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.577]                     next
[08:24:54.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.577]                 }
[08:24:54.577]                 if (length(args) > 0) 
[08:24:54.577]                   base::do.call(base::Sys.setenv, args = args)
[08:24:54.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:54.577]             }
[08:24:54.577]             else {
[08:24:54.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:54.577]             }
[08:24:54.577]             {
[08:24:54.577]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:54.577]                   0L) {
[08:24:54.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:54.577]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:54.577]                   base::options(opts)
[08:24:54.577]                 }
[08:24:54.577]                 {
[08:24:54.577]                   {
[08:24:54.577]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:54.577]                     NULL
[08:24:54.577]                   }
[08:24:54.577]                   options(future.plan = NULL)
[08:24:54.577]                   if (is.na(NA_character_)) 
[08:24:54.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:54.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:54.577]                     .init = FALSE)
[08:24:54.577]                 }
[08:24:54.577]             }
[08:24:54.577]         }
[08:24:54.577]     })
[08:24:54.577]     if (TRUE) {
[08:24:54.577]         base::sink(type = "output", split = FALSE)
[08:24:54.577]         if (TRUE) {
[08:24:54.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:54.577]         }
[08:24:54.577]         else {
[08:24:54.577]             ...future.result["stdout"] <- base::list(NULL)
[08:24:54.577]         }
[08:24:54.577]         base::close(...future.stdout)
[08:24:54.577]         ...future.stdout <- NULL
[08:24:54.577]     }
[08:24:54.577]     ...future.result$conditions <- ...future.conditions
[08:24:54.577]     ...future.result$finished <- base::Sys.time()
[08:24:54.577]     ...future.result
[08:24:54.577] }
[08:24:54.580] Exporting 5 global objects (31.96 KiB) to cluster node #1 ...
[08:24:54.580] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:54.581] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:54.581] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ...
[08:24:54.623] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ... DONE
[08:24:54.623] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[08:24:54.624] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[08:24:54.624] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:54.624] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:54.624] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:54.625] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:54.625] Exporting 5 global objects (31.96 KiB) to cluster node #1 ... DONE
[08:24:54.625] MultisessionFuture started
[08:24:54.625] - Launch lazy future ... done
[08:24:54.626] run() for ‘MultisessionFuture’ ... done
[08:24:54.626] Created future:
[08:24:54.626] MultisessionFuture:
[08:24:54.626] Label: ‘future_apply-1’
[08:24:54.626] Expression:
[08:24:54.626] {
[08:24:54.626]     do.call(function(...) {
[08:24:54.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.626]             on.exit(options(oopts), add = TRUE)
[08:24:54.626]         }
[08:24:54.626]         {
[08:24:54.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.626]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.626]             })
[08:24:54.626]         }
[08:24:54.626]     }, args = future.call.arguments)
[08:24:54.626] }
[08:24:54.626] Lazy evaluation: FALSE
[08:24:54.626] Asynchronous evaluation: TRUE
[08:24:54.626] Local evaluation: TRUE
[08:24:54.626] Environment: R_GlobalEnv
[08:24:54.626] Capture standard output: TRUE
[08:24:54.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:54.626] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:54.626] Packages: <none>
[08:24:54.626] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:54.626] Resolved: FALSE
[08:24:54.626] Value: <not collected>
[08:24:54.626] Conditions captured: <none>
[08:24:54.626] Early signaling: FALSE
[08:24:54.626] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:54.626] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.638] Chunk #1 of 2 ... DONE
[08:24:54.638] Chunk #2 of 2 ...
[08:24:54.638]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:54.638]  - seeds: <none>
[08:24:54.638]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.638] getGlobalsAndPackages() ...
[08:24:54.639] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.639] Resolving globals: FALSE
[08:24:54.639] Tweak future expression to call with '...' arguments ...
[08:24:54.639] {
[08:24:54.639]     do.call(function(...) {
[08:24:54.639]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.639]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.639]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.639]             on.exit(options(oopts), add = TRUE)
[08:24:54.639]         }
[08:24:54.639]         {
[08:24:54.639]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.639]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.639]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.639]             })
[08:24:54.639]         }
[08:24:54.639]     }, args = future.call.arguments)
[08:24:54.639] }
[08:24:54.639] Tweak future expression to call with '...' arguments ... DONE
[08:24:54.640] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.640] 
[08:24:54.640] getGlobalsAndPackages() ... DONE
[08:24:54.640] run() for ‘Future’ ...
[08:24:54.640] - state: ‘created’
[08:24:54.640] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:54.654] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.655] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:54.655]   - Field: ‘node’
[08:24:54.655]   - Field: ‘label’
[08:24:54.655]   - Field: ‘local’
[08:24:54.655]   - Field: ‘owner’
[08:24:54.655]   - Field: ‘envir’
[08:24:54.655]   - Field: ‘workers’
[08:24:54.655]   - Field: ‘packages’
[08:24:54.655]   - Field: ‘gc’
[08:24:54.655]   - Field: ‘conditions’
[08:24:54.655]   - Field: ‘persistent’
[08:24:54.656]   - Field: ‘expr’
[08:24:54.656]   - Field: ‘uuid’
[08:24:54.656]   - Field: ‘seed’
[08:24:54.656]   - Field: ‘version’
[08:24:54.656]   - Field: ‘result’
[08:24:54.656]   - Field: ‘asynchronous’
[08:24:54.656]   - Field: ‘calls’
[08:24:54.656]   - Field: ‘globals’
[08:24:54.656]   - Field: ‘stdout’
[08:24:54.656]   - Field: ‘earlySignal’
[08:24:54.656]   - Field: ‘lazy’
[08:24:54.656]   - Field: ‘state’
[08:24:54.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:54.657] - Launch lazy future ...
[08:24:54.657] Packages needed by the future expression (n = 0): <none>
[08:24:54.657] Packages needed by future strategies (n = 0): <none>
[08:24:54.658] {
[08:24:54.658]     {
[08:24:54.658]         {
[08:24:54.658]             ...future.startTime <- base::Sys.time()
[08:24:54.658]             {
[08:24:54.658]                 {
[08:24:54.658]                   {
[08:24:54.658]                     {
[08:24:54.658]                       base::local({
[08:24:54.658]                         has_future <- base::requireNamespace("future", 
[08:24:54.658]                           quietly = TRUE)
[08:24:54.658]                         if (has_future) {
[08:24:54.658]                           ns <- base::getNamespace("future")
[08:24:54.658]                           version <- ns[[".package"]][["version"]]
[08:24:54.658]                           if (is.null(version)) 
[08:24:54.658]                             version <- utils::packageVersion("future")
[08:24:54.658]                         }
[08:24:54.658]                         else {
[08:24:54.658]                           version <- NULL
[08:24:54.658]                         }
[08:24:54.658]                         if (!has_future || version < "1.8.0") {
[08:24:54.658]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:54.658]                             "", base::R.version$version.string), 
[08:24:54.658]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:54.658]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:54.658]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:54.658]                               "release", "version")], collapse = " "), 
[08:24:54.658]                             hostname = base::Sys.info()[["nodename"]])
[08:24:54.658]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:54.658]                             info)
[08:24:54.658]                           info <- base::paste(info, collapse = "; ")
[08:24:54.658]                           if (!has_future) {
[08:24:54.658]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:54.658]                               info)
[08:24:54.658]                           }
[08:24:54.658]                           else {
[08:24:54.658]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:54.658]                               info, version)
[08:24:54.658]                           }
[08:24:54.658]                           base::stop(msg)
[08:24:54.658]                         }
[08:24:54.658]                       })
[08:24:54.658]                     }
[08:24:54.658]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:54.658]                     base::options(mc.cores = 1L)
[08:24:54.658]                   }
[08:24:54.658]                   ...future.strategy.old <- future::plan("list")
[08:24:54.658]                   options(future.plan = NULL)
[08:24:54.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:54.658]                 }
[08:24:54.658]                 ...future.workdir <- getwd()
[08:24:54.658]             }
[08:24:54.658]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:54.658]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:54.658]         }
[08:24:54.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:54.658]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:54.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:54.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:54.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:54.658]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:54.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:54.658]             base::names(...future.oldOptions))
[08:24:54.658]     }
[08:24:54.658]     if (FALSE) {
[08:24:54.658]     }
[08:24:54.658]     else {
[08:24:54.658]         if (TRUE) {
[08:24:54.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:54.658]                 open = "w")
[08:24:54.658]         }
[08:24:54.658]         else {
[08:24:54.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:54.658]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:54.658]         }
[08:24:54.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:54.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:54.658]             base::sink(type = "output", split = FALSE)
[08:24:54.658]             base::close(...future.stdout)
[08:24:54.658]         }, add = TRUE)
[08:24:54.658]     }
[08:24:54.658]     ...future.frame <- base::sys.nframe()
[08:24:54.658]     ...future.conditions <- base::list()
[08:24:54.658]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:54.658]     if (FALSE) {
[08:24:54.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:54.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:54.658]     }
[08:24:54.658]     ...future.result <- base::tryCatch({
[08:24:54.658]         base::withCallingHandlers({
[08:24:54.658]             ...future.value <- base::withVisible(base::local({
[08:24:54.658]                 ...future.makeSendCondition <- base::local({
[08:24:54.658]                   sendCondition <- NULL
[08:24:54.658]                   function(frame = 1L) {
[08:24:54.658]                     if (is.function(sendCondition)) 
[08:24:54.658]                       return(sendCondition)
[08:24:54.658]                     ns <- getNamespace("parallel")
[08:24:54.658]                     if (exists("sendData", mode = "function", 
[08:24:54.658]                       envir = ns)) {
[08:24:54.658]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:54.658]                         envir = ns)
[08:24:54.658]                       envir <- sys.frame(frame)
[08:24:54.658]                       master <- NULL
[08:24:54.658]                       while (!identical(envir, .GlobalEnv) && 
[08:24:54.658]                         !identical(envir, emptyenv())) {
[08:24:54.658]                         if (exists("master", mode = "list", envir = envir, 
[08:24:54.658]                           inherits = FALSE)) {
[08:24:54.658]                           master <- get("master", mode = "list", 
[08:24:54.658]                             envir = envir, inherits = FALSE)
[08:24:54.658]                           if (inherits(master, c("SOCKnode", 
[08:24:54.658]                             "SOCK0node"))) {
[08:24:54.658]                             sendCondition <<- function(cond) {
[08:24:54.658]                               data <- list(type = "VALUE", value = cond, 
[08:24:54.658]                                 success = TRUE)
[08:24:54.658]                               parallel_sendData(master, data)
[08:24:54.658]                             }
[08:24:54.658]                             return(sendCondition)
[08:24:54.658]                           }
[08:24:54.658]                         }
[08:24:54.658]                         frame <- frame + 1L
[08:24:54.658]                         envir <- sys.frame(frame)
[08:24:54.658]                       }
[08:24:54.658]                     }
[08:24:54.658]                     sendCondition <<- function(cond) NULL
[08:24:54.658]                   }
[08:24:54.658]                 })
[08:24:54.658]                 withCallingHandlers({
[08:24:54.658]                   {
[08:24:54.658]                     do.call(function(...) {
[08:24:54.658]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.658]                       if (!identical(...future.globals.maxSize.org, 
[08:24:54.658]                         ...future.globals.maxSize)) {
[08:24:54.658]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.658]                         on.exit(options(oopts), add = TRUE)
[08:24:54.658]                       }
[08:24:54.658]                       {
[08:24:54.658]                         lapply(seq_along(...future.elements_ii), 
[08:24:54.658]                           FUN = function(jj) {
[08:24:54.658]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.658]                             ...future.FUN(...future.X_jj, ...)
[08:24:54.658]                           })
[08:24:54.658]                       }
[08:24:54.658]                     }, args = future.call.arguments)
[08:24:54.658]                   }
[08:24:54.658]                 }, immediateCondition = function(cond) {
[08:24:54.658]                   sendCondition <- ...future.makeSendCondition()
[08:24:54.658]                   sendCondition(cond)
[08:24:54.658]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.658]                   {
[08:24:54.658]                     inherits <- base::inherits
[08:24:54.658]                     invokeRestart <- base::invokeRestart
[08:24:54.658]                     is.null <- base::is.null
[08:24:54.658]                     muffled <- FALSE
[08:24:54.658]                     if (inherits(cond, "message")) {
[08:24:54.658]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:54.658]                       if (muffled) 
[08:24:54.658]                         invokeRestart("muffleMessage")
[08:24:54.658]                     }
[08:24:54.658]                     else if (inherits(cond, "warning")) {
[08:24:54.658]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:54.658]                       if (muffled) 
[08:24:54.658]                         invokeRestart("muffleWarning")
[08:24:54.658]                     }
[08:24:54.658]                     else if (inherits(cond, "condition")) {
[08:24:54.658]                       if (!is.null(pattern)) {
[08:24:54.658]                         computeRestarts <- base::computeRestarts
[08:24:54.658]                         grepl <- base::grepl
[08:24:54.658]                         restarts <- computeRestarts(cond)
[08:24:54.658]                         for (restart in restarts) {
[08:24:54.658]                           name <- restart$name
[08:24:54.658]                           if (is.null(name)) 
[08:24:54.658]                             next
[08:24:54.658]                           if (!grepl(pattern, name)) 
[08:24:54.658]                             next
[08:24:54.658]                           invokeRestart(restart)
[08:24:54.658]                           muffled <- TRUE
[08:24:54.658]                           break
[08:24:54.658]                         }
[08:24:54.658]                       }
[08:24:54.658]                     }
[08:24:54.658]                     invisible(muffled)
[08:24:54.658]                   }
[08:24:54.658]                   muffleCondition(cond)
[08:24:54.658]                 })
[08:24:54.658]             }))
[08:24:54.658]             future::FutureResult(value = ...future.value$value, 
[08:24:54.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.658]                   ...future.rng), globalenv = if (FALSE) 
[08:24:54.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:54.658]                     ...future.globalenv.names))
[08:24:54.658]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:54.658]         }, condition = base::local({
[08:24:54.658]             c <- base::c
[08:24:54.658]             inherits <- base::inherits
[08:24:54.658]             invokeRestart <- base::invokeRestart
[08:24:54.658]             length <- base::length
[08:24:54.658]             list <- base::list
[08:24:54.658]             seq.int <- base::seq.int
[08:24:54.658]             signalCondition <- base::signalCondition
[08:24:54.658]             sys.calls <- base::sys.calls
[08:24:54.658]             `[[` <- base::`[[`
[08:24:54.658]             `+` <- base::`+`
[08:24:54.658]             `<<-` <- base::`<<-`
[08:24:54.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:54.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:54.658]                   3L)]
[08:24:54.658]             }
[08:24:54.658]             function(cond) {
[08:24:54.658]                 is_error <- inherits(cond, "error")
[08:24:54.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:54.658]                   NULL)
[08:24:54.658]                 if (is_error) {
[08:24:54.658]                   sessionInformation <- function() {
[08:24:54.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:54.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:54.658]                       search = base::search(), system = base::Sys.info())
[08:24:54.658]                   }
[08:24:54.658]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:54.658]                     cond$call), session = sessionInformation(), 
[08:24:54.658]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:54.658]                   signalCondition(cond)
[08:24:54.658]                 }
[08:24:54.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:54.658]                 "immediateCondition"))) {
[08:24:54.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:54.658]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:54.658]                   if (TRUE && !signal) {
[08:24:54.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.658]                     {
[08:24:54.658]                       inherits <- base::inherits
[08:24:54.658]                       invokeRestart <- base::invokeRestart
[08:24:54.658]                       is.null <- base::is.null
[08:24:54.658]                       muffled <- FALSE
[08:24:54.658]                       if (inherits(cond, "message")) {
[08:24:54.658]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.658]                         if (muffled) 
[08:24:54.658]                           invokeRestart("muffleMessage")
[08:24:54.658]                       }
[08:24:54.658]                       else if (inherits(cond, "warning")) {
[08:24:54.658]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.658]                         if (muffled) 
[08:24:54.658]                           invokeRestart("muffleWarning")
[08:24:54.658]                       }
[08:24:54.658]                       else if (inherits(cond, "condition")) {
[08:24:54.658]                         if (!is.null(pattern)) {
[08:24:54.658]                           computeRestarts <- base::computeRestarts
[08:24:54.658]                           grepl <- base::grepl
[08:24:54.658]                           restarts <- computeRestarts(cond)
[08:24:54.658]                           for (restart in restarts) {
[08:24:54.658]                             name <- restart$name
[08:24:54.658]                             if (is.null(name)) 
[08:24:54.658]                               next
[08:24:54.658]                             if (!grepl(pattern, name)) 
[08:24:54.658]                               next
[08:24:54.658]                             invokeRestart(restart)
[08:24:54.658]                             muffled <- TRUE
[08:24:54.658]                             break
[08:24:54.658]                           }
[08:24:54.658]                         }
[08:24:54.658]                       }
[08:24:54.658]                       invisible(muffled)
[08:24:54.658]                     }
[08:24:54.658]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.658]                   }
[08:24:54.658]                 }
[08:24:54.658]                 else {
[08:24:54.658]                   if (TRUE) {
[08:24:54.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.658]                     {
[08:24:54.658]                       inherits <- base::inherits
[08:24:54.658]                       invokeRestart <- base::invokeRestart
[08:24:54.658]                       is.null <- base::is.null
[08:24:54.658]                       muffled <- FALSE
[08:24:54.658]                       if (inherits(cond, "message")) {
[08:24:54.658]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.658]                         if (muffled) 
[08:24:54.658]                           invokeRestart("muffleMessage")
[08:24:54.658]                       }
[08:24:54.658]                       else if (inherits(cond, "warning")) {
[08:24:54.658]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.658]                         if (muffled) 
[08:24:54.658]                           invokeRestart("muffleWarning")
[08:24:54.658]                       }
[08:24:54.658]                       else if (inherits(cond, "condition")) {
[08:24:54.658]                         if (!is.null(pattern)) {
[08:24:54.658]                           computeRestarts <- base::computeRestarts
[08:24:54.658]                           grepl <- base::grepl
[08:24:54.658]                           restarts <- computeRestarts(cond)
[08:24:54.658]                           for (restart in restarts) {
[08:24:54.658]                             name <- restart$name
[08:24:54.658]                             if (is.null(name)) 
[08:24:54.658]                               next
[08:24:54.658]                             if (!grepl(pattern, name)) 
[08:24:54.658]                               next
[08:24:54.658]                             invokeRestart(restart)
[08:24:54.658]                             muffled <- TRUE
[08:24:54.658]                             break
[08:24:54.658]                           }
[08:24:54.658]                         }
[08:24:54.658]                       }
[08:24:54.658]                       invisible(muffled)
[08:24:54.658]                     }
[08:24:54.658]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.658]                   }
[08:24:54.658]                 }
[08:24:54.658]             }
[08:24:54.658]         }))
[08:24:54.658]     }, error = function(ex) {
[08:24:54.658]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:54.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.658]                 ...future.rng), started = ...future.startTime, 
[08:24:54.658]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:54.658]             version = "1.8"), class = "FutureResult")
[08:24:54.658]     }, finally = {
[08:24:54.658]         if (!identical(...future.workdir, getwd())) 
[08:24:54.658]             setwd(...future.workdir)
[08:24:54.658]         {
[08:24:54.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:54.658]                 ...future.oldOptions$nwarnings <- NULL
[08:24:54.658]             }
[08:24:54.658]             base::options(...future.oldOptions)
[08:24:54.658]             if (.Platform$OS.type == "windows") {
[08:24:54.658]                 old_names <- names(...future.oldEnvVars)
[08:24:54.658]                 envs <- base::Sys.getenv()
[08:24:54.658]                 names <- names(envs)
[08:24:54.658]                 common <- intersect(names, old_names)
[08:24:54.658]                 added <- setdiff(names, old_names)
[08:24:54.658]                 removed <- setdiff(old_names, names)
[08:24:54.658]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:54.658]                   envs[common]]
[08:24:54.658]                 NAMES <- toupper(changed)
[08:24:54.658]                 args <- list()
[08:24:54.658]                 for (kk in seq_along(NAMES)) {
[08:24:54.658]                   name <- changed[[kk]]
[08:24:54.658]                   NAME <- NAMES[[kk]]
[08:24:54.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.658]                     next
[08:24:54.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.658]                 }
[08:24:54.658]                 NAMES <- toupper(added)
[08:24:54.658]                 for (kk in seq_along(NAMES)) {
[08:24:54.658]                   name <- added[[kk]]
[08:24:54.658]                   NAME <- NAMES[[kk]]
[08:24:54.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.658]                     next
[08:24:54.658]                   args[[name]] <- ""
[08:24:54.658]                 }
[08:24:54.658]                 NAMES <- toupper(removed)
[08:24:54.658]                 for (kk in seq_along(NAMES)) {
[08:24:54.658]                   name <- removed[[kk]]
[08:24:54.658]                   NAME <- NAMES[[kk]]
[08:24:54.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.658]                     next
[08:24:54.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.658]                 }
[08:24:54.658]                 if (length(args) > 0) 
[08:24:54.658]                   base::do.call(base::Sys.setenv, args = args)
[08:24:54.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:54.658]             }
[08:24:54.658]             else {
[08:24:54.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:54.658]             }
[08:24:54.658]             {
[08:24:54.658]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:54.658]                   0L) {
[08:24:54.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:54.658]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:54.658]                   base::options(opts)
[08:24:54.658]                 }
[08:24:54.658]                 {
[08:24:54.658]                   {
[08:24:54.658]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:54.658]                     NULL
[08:24:54.658]                   }
[08:24:54.658]                   options(future.plan = NULL)
[08:24:54.658]                   if (is.na(NA_character_)) 
[08:24:54.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:54.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:54.658]                     .init = FALSE)
[08:24:54.658]                 }
[08:24:54.658]             }
[08:24:54.658]         }
[08:24:54.658]     })
[08:24:54.658]     if (TRUE) {
[08:24:54.658]         base::sink(type = "output", split = FALSE)
[08:24:54.658]         if (TRUE) {
[08:24:54.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:54.658]         }
[08:24:54.658]         else {
[08:24:54.658]             ...future.result["stdout"] <- base::list(NULL)
[08:24:54.658]         }
[08:24:54.658]         base::close(...future.stdout)
[08:24:54.658]         ...future.stdout <- NULL
[08:24:54.658]     }
[08:24:54.658]     ...future.result$conditions <- ...future.conditions
[08:24:54.658]     ...future.result$finished <- base::Sys.time()
[08:24:54.658]     ...future.result
[08:24:54.658] }
[08:24:54.661] Exporting 5 global objects (31.96 KiB) to cluster node #2 ...
[08:24:54.661] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:54.661] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:54.662] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ...
[08:24:54.703] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ... DONE
[08:24:54.703] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[08:24:54.704] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[08:24:54.704] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:54.704] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:54.704] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:54.705] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:54.705] Exporting 5 global objects (31.96 KiB) to cluster node #2 ... DONE
[08:24:54.706] MultisessionFuture started
[08:24:54.706] - Launch lazy future ... done
[08:24:54.706] run() for ‘MultisessionFuture’ ... done
[08:24:54.706] Created future:
[08:24:54.706] MultisessionFuture:
[08:24:54.706] Label: ‘future_apply-2’
[08:24:54.706] Expression:
[08:24:54.706] {
[08:24:54.706]     do.call(function(...) {
[08:24:54.706]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.706]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.706]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.706]             on.exit(options(oopts), add = TRUE)
[08:24:54.706]         }
[08:24:54.706]         {
[08:24:54.706]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.706]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.706]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.706]             })
[08:24:54.706]         }
[08:24:54.706]     }, args = future.call.arguments)
[08:24:54.706] }
[08:24:54.706] Lazy evaluation: FALSE
[08:24:54.706] Asynchronous evaluation: TRUE
[08:24:54.706] Local evaluation: TRUE
[08:24:54.706] Environment: R_GlobalEnv
[08:24:54.706] Capture standard output: TRUE
[08:24:54.706] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:54.706] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:54.706] Packages: <none>
[08:24:54.706] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:54.706] Resolved: FALSE
[08:24:54.706] Value: <not collected>
[08:24:54.706] Conditions captured: <none>
[08:24:54.706] Early signaling: FALSE
[08:24:54.706] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:54.706] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.719] Chunk #2 of 2 ... DONE
[08:24:54.719] Launching 2 futures (chunks) ... DONE
[08:24:54.719] Resolving 2 futures (chunks) ...
[08:24:54.719] resolve() on list ...
[08:24:54.719]  recursive: 0
[08:24:54.720]  length: 2
[08:24:54.720] 
[08:24:54.720] receiveMessageFromWorker() for ClusterFuture ...
[08:24:54.720] - Validating connection of MultisessionFuture
[08:24:54.720] - received message: FutureResult
[08:24:54.721] - Received FutureResult
[08:24:54.721] - Erased future from FutureRegistry
[08:24:54.721] result() for ClusterFuture ...
[08:24:54.721] - result already collected: FutureResult
[08:24:54.721] result() for ClusterFuture ... done
[08:24:54.721] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:54.721] Future #1
[08:24:54.721] result() for ClusterFuture ...
[08:24:54.721] - result already collected: FutureResult
[08:24:54.721] result() for ClusterFuture ... done
[08:24:54.721] result() for ClusterFuture ...
[08:24:54.722] - result already collected: FutureResult
[08:24:54.722] result() for ClusterFuture ... done
[08:24:54.722] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:54.722] - nx: 2
[08:24:54.722] - relay: TRUE
[08:24:54.722] - stdout: TRUE
[08:24:54.722] - signal: TRUE
[08:24:54.722] - resignal: FALSE
[08:24:54.722] - force: TRUE
[08:24:54.722] - relayed: [n=2] FALSE, FALSE
[08:24:54.722] - queued futures: [n=2] FALSE, FALSE
[08:24:54.722]  - until=1
[08:24:54.722]  - relaying element #1
[08:24:54.723] result() for ClusterFuture ...
[08:24:54.723] - result already collected: FutureResult
[08:24:54.723] result() for ClusterFuture ... done
[08:24:54.723] result() for ClusterFuture ...
[08:24:54.723] - result already collected: FutureResult
[08:24:54.723] result() for ClusterFuture ... done
[08:24:54.723] result() for ClusterFuture ...
[08:24:54.723] - result already collected: FutureResult
[08:24:54.723] result() for ClusterFuture ... done
[08:24:54.723] result() for ClusterFuture ...
[08:24:54.723] - result already collected: FutureResult
[08:24:54.724] result() for ClusterFuture ... done
[08:24:54.724] - relayed: [n=2] TRUE, FALSE
[08:24:54.724] - queued futures: [n=2] TRUE, FALSE
[08:24:54.724] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:54.724]  length: 1 (resolved future 1)
[08:24:54.748] receiveMessageFromWorker() for ClusterFuture ...
[08:24:54.749] - Validating connection of MultisessionFuture
[08:24:54.749] - received message: FutureResult
[08:24:54.749] - Received FutureResult
[08:24:54.749] - Erased future from FutureRegistry
[08:24:54.749] result() for ClusterFuture ...
[08:24:54.749] - result already collected: FutureResult
[08:24:54.749] result() for ClusterFuture ... done
[08:24:54.749] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:54.750] Future #2
[08:24:54.750] result() for ClusterFuture ...
[08:24:54.750] - result already collected: FutureResult
[08:24:54.750] result() for ClusterFuture ... done
[08:24:54.750] result() for ClusterFuture ...
[08:24:54.750] - result already collected: FutureResult
[08:24:54.750] result() for ClusterFuture ... done
[08:24:54.750] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:54.750] - nx: 2
[08:24:54.750] - relay: TRUE
[08:24:54.750] - stdout: TRUE
[08:24:54.751] - signal: TRUE
[08:24:54.751] - resignal: FALSE
[08:24:54.751] - force: TRUE
[08:24:54.751] - relayed: [n=2] TRUE, FALSE
[08:24:54.751] - queued futures: [n=2] TRUE, FALSE
[08:24:54.751]  - until=2
[08:24:54.751]  - relaying element #2
[08:24:54.751] result() for ClusterFuture ...
[08:24:54.751] - result already collected: FutureResult
[08:24:54.751] result() for ClusterFuture ... done
[08:24:54.751] result() for ClusterFuture ...
[08:24:54.751] - result already collected: FutureResult
[08:24:54.752] result() for ClusterFuture ... done
[08:24:54.752] result() for ClusterFuture ...
[08:24:54.752] - result already collected: FutureResult
[08:24:54.752] result() for ClusterFuture ... done
[08:24:54.752] result() for ClusterFuture ...
[08:24:54.752] - result already collected: FutureResult
[08:24:54.752] result() for ClusterFuture ... done
[08:24:54.752] - relayed: [n=2] TRUE, TRUE
[08:24:54.752] - queued futures: [n=2] TRUE, TRUE
[08:24:54.752] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:54.752]  length: 0 (resolved future 2)
[08:24:54.752] Relaying remaining futures
[08:24:54.753] signalConditionsASAP(NULL, pos=0) ...
[08:24:54.753] - nx: 2
[08:24:54.753] - relay: TRUE
[08:24:54.753] - stdout: TRUE
[08:24:54.753] - signal: TRUE
[08:24:54.753] - resignal: FALSE
[08:24:54.753] - force: TRUE
[08:24:54.753] - relayed: [n=2] TRUE, TRUE
[08:24:54.753] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:54.753] - relayed: [n=2] TRUE, TRUE
[08:24:54.753] - queued futures: [n=2] TRUE, TRUE
[08:24:54.753] signalConditionsASAP(NULL, pos=0) ... done
[08:24:54.754] resolve() on list ... DONE
[08:24:54.754] result() for ClusterFuture ...
[08:24:54.754] - result already collected: FutureResult
[08:24:54.754] result() for ClusterFuture ... done
[08:24:54.754] result() for ClusterFuture ...
[08:24:54.754] - result already collected: FutureResult
[08:24:54.754] result() for ClusterFuture ... done
[08:24:54.754] result() for ClusterFuture ...
[08:24:54.754] - result already collected: FutureResult
[08:24:54.754] result() for ClusterFuture ... done
[08:24:54.754] result() for ClusterFuture ...
[08:24:54.754] - result already collected: FutureResult
[08:24:54.755] result() for ClusterFuture ... done
[08:24:54.755]  - Number of value chunks collected: 2
[08:24:54.755] Resolving 2 futures (chunks) ... DONE
[08:24:54.755] Reducing values from 2 chunks ...
[08:24:54.755]  - Number of values collected after concatenation: 2
[08:24:54.755]  - Number of values expected: 2
[08:24:54.755] Reducing values from 2 chunks ... DONE
[08:24:54.755] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[08:24:54.756] getGlobalsAndPackagesXApply() ...
[08:24:54.756]  - future.globals: TRUE
[08:24:54.756] getGlobalsAndPackages() ...
[08:24:54.756] Searching for globals...
[08:24:54.757] - globals found: [2] ‘FUN’, ‘UseMethod’
[08:24:54.758] Searching for globals ... DONE
[08:24:54.758] Resolving globals: FALSE
[08:24:54.758] The total size of the 1 globals is 311 bytes (311 bytes)
[08:24:54.758] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[08:24:54.759] - globals: [1] ‘FUN’
[08:24:54.759] - packages: [1] ‘stats’
[08:24:54.759] getGlobalsAndPackages() ... DONE
[08:24:54.759]  - globals found/used: [n=1] ‘FUN’
[08:24:54.759]  - needed namespaces: [n=1] ‘stats’
[08:24:54.759] Finding globals ... DONE
[08:24:54.759]  - use_args: TRUE
[08:24:54.759]  - Getting '...' globals ...
[08:24:54.760] resolve() on list ...
[08:24:54.760]  recursive: 0
[08:24:54.760]  length: 1
[08:24:54.760]  elements: ‘...’
[08:24:54.760]  length: 0 (resolved future 1)
[08:24:54.760] resolve() on list ... DONE
[08:24:54.760]    - '...' content: [n=0] 
[08:24:54.760] List of 1
[08:24:54.760]  $ ...: list()
[08:24:54.760]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.760]  - attr(*, "where")=List of 1
[08:24:54.760]   ..$ ...:<environment: 0x56540fb64368> 
[08:24:54.760]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.760]  - attr(*, "resolved")= logi TRUE
[08:24:54.760]  - attr(*, "total_size")= num NA
[08:24:54.763]  - Getting '...' globals ... DONE
[08:24:54.763] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:54.763] List of 2
[08:24:54.763]  $ ...future.FUN:function (x, ...)  
[08:24:54.763]  $ ...          : list()
[08:24:54.763]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.763]  - attr(*, "where")=List of 2
[08:24:54.763]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:54.763]   ..$ ...          :<environment: 0x56540fb64368> 
[08:24:54.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.763]  - attr(*, "resolved")= logi FALSE
[08:24:54.763]  - attr(*, "total_size")= num 2586
[08:24:54.765] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:54.766] getGlobalsAndPackagesXApply() ... DONE
[08:24:54.767] future_lapply() ...
[08:24:54.769] Number of chunks: 2
[08:24:54.769] getGlobalsAndPackagesXApply() ...
[08:24:54.769]  - future.globals: <name-value list> with names ‘list()’
[08:24:54.769]  - use_args: TRUE
[08:24:54.769] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:54.770] List of 2
[08:24:54.770]  $ ...          : list()
[08:24:54.770]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.770]  $ ...future.FUN:function (x, ...)  
[08:24:54.770]  - attr(*, "where")=List of 2
[08:24:54.770]   ..$ ...          :<environment: 0x56540fb64368> 
[08:24:54.770]   ..$ ...future.FUN:<environment: namespace:stats> 
[08:24:54.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.770]  - attr(*, "resolved")= logi FALSE
[08:24:54.770]  - attr(*, "total_size")= num NA
[08:24:54.772] Packages to be attached in all futures: [n=1] ‘stats’
[08:24:54.772] getGlobalsAndPackagesXApply() ... DONE
[08:24:54.772] Number of futures (= number of chunks): 2
[08:24:54.773] Launching 2 futures (chunks) ...
[08:24:54.773] Chunk #1 of 2 ...
[08:24:54.773]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:54.773]  - seeds: <none>
[08:24:54.773]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.773] getGlobalsAndPackages() ...
[08:24:54.773] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.773] Resolving globals: FALSE
[08:24:54.773] Tweak future expression to call with '...' arguments ...
[08:24:54.774] {
[08:24:54.774]     do.call(function(...) {
[08:24:54.774]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.774]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.774]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.774]             on.exit(options(oopts), add = TRUE)
[08:24:54.774]         }
[08:24:54.774]         {
[08:24:54.774]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.774]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.774]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.774]             })
[08:24:54.774]         }
[08:24:54.774]     }, args = future.call.arguments)
[08:24:54.774] }
[08:24:54.774] Tweak future expression to call with '...' arguments ... DONE
[08:24:54.774] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.774] - packages: [1] ‘stats’
[08:24:54.774] getGlobalsAndPackages() ... DONE
[08:24:54.775] run() for ‘Future’ ...
[08:24:54.775] - state: ‘created’
[08:24:54.775] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:54.790] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.790] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:54.790]   - Field: ‘node’
[08:24:54.790]   - Field: ‘label’
[08:24:54.790]   - Field: ‘local’
[08:24:54.790]   - Field: ‘owner’
[08:24:54.790]   - Field: ‘envir’
[08:24:54.790]   - Field: ‘workers’
[08:24:54.790]   - Field: ‘packages’
[08:24:54.791]   - Field: ‘gc’
[08:24:54.791]   - Field: ‘conditions’
[08:24:54.791]   - Field: ‘persistent’
[08:24:54.791]   - Field: ‘expr’
[08:24:54.791]   - Field: ‘uuid’
[08:24:54.791]   - Field: ‘seed’
[08:24:54.791]   - Field: ‘version’
[08:24:54.791]   - Field: ‘result’
[08:24:54.791]   - Field: ‘asynchronous’
[08:24:54.791]   - Field: ‘calls’
[08:24:54.791]   - Field: ‘globals’
[08:24:54.792]   - Field: ‘stdout’
[08:24:54.792]   - Field: ‘earlySignal’
[08:24:54.792]   - Field: ‘lazy’
[08:24:54.792]   - Field: ‘state’
[08:24:54.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:54.792] - Launch lazy future ...
[08:24:54.792] Packages needed by the future expression (n = 1): ‘stats’
[08:24:54.792] Packages needed by future strategies (n = 0): <none>
[08:24:54.793] {
[08:24:54.793]     {
[08:24:54.793]         {
[08:24:54.793]             ...future.startTime <- base::Sys.time()
[08:24:54.793]             {
[08:24:54.793]                 {
[08:24:54.793]                   {
[08:24:54.793]                     {
[08:24:54.793]                       {
[08:24:54.793]                         base::local({
[08:24:54.793]                           has_future <- base::requireNamespace("future", 
[08:24:54.793]                             quietly = TRUE)
[08:24:54.793]                           if (has_future) {
[08:24:54.793]                             ns <- base::getNamespace("future")
[08:24:54.793]                             version <- ns[[".package"]][["version"]]
[08:24:54.793]                             if (is.null(version)) 
[08:24:54.793]                               version <- utils::packageVersion("future")
[08:24:54.793]                           }
[08:24:54.793]                           else {
[08:24:54.793]                             version <- NULL
[08:24:54.793]                           }
[08:24:54.793]                           if (!has_future || version < "1.8.0") {
[08:24:54.793]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:54.793]                               "", base::R.version$version.string), 
[08:24:54.793]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:54.793]                                 base::R.version$platform, 8 * 
[08:24:54.793]                                   base::.Machine$sizeof.pointer), 
[08:24:54.793]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:54.793]                                 "release", "version")], collapse = " "), 
[08:24:54.793]                               hostname = base::Sys.info()[["nodename"]])
[08:24:54.793]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:54.793]                               info)
[08:24:54.793]                             info <- base::paste(info, collapse = "; ")
[08:24:54.793]                             if (!has_future) {
[08:24:54.793]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:54.793]                                 info)
[08:24:54.793]                             }
[08:24:54.793]                             else {
[08:24:54.793]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:54.793]                                 info, version)
[08:24:54.793]                             }
[08:24:54.793]                             base::stop(msg)
[08:24:54.793]                           }
[08:24:54.793]                         })
[08:24:54.793]                       }
[08:24:54.793]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:54.793]                       base::options(mc.cores = 1L)
[08:24:54.793]                     }
[08:24:54.793]                     base::local({
[08:24:54.793]                       for (pkg in "stats") {
[08:24:54.793]                         base::loadNamespace(pkg)
[08:24:54.793]                         base::library(pkg, character.only = TRUE)
[08:24:54.793]                       }
[08:24:54.793]                     })
[08:24:54.793]                   }
[08:24:54.793]                   ...future.strategy.old <- future::plan("list")
[08:24:54.793]                   options(future.plan = NULL)
[08:24:54.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:54.793]                 }
[08:24:54.793]                 ...future.workdir <- getwd()
[08:24:54.793]             }
[08:24:54.793]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:54.793]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:54.793]         }
[08:24:54.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:54.793]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:54.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:54.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:54.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:54.793]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:54.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:54.793]             base::names(...future.oldOptions))
[08:24:54.793]     }
[08:24:54.793]     if (FALSE) {
[08:24:54.793]     }
[08:24:54.793]     else {
[08:24:54.793]         if (TRUE) {
[08:24:54.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:54.793]                 open = "w")
[08:24:54.793]         }
[08:24:54.793]         else {
[08:24:54.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:54.793]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:54.793]         }
[08:24:54.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:54.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:54.793]             base::sink(type = "output", split = FALSE)
[08:24:54.793]             base::close(...future.stdout)
[08:24:54.793]         }, add = TRUE)
[08:24:54.793]     }
[08:24:54.793]     ...future.frame <- base::sys.nframe()
[08:24:54.793]     ...future.conditions <- base::list()
[08:24:54.793]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:54.793]     if (FALSE) {
[08:24:54.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:54.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:54.793]     }
[08:24:54.793]     ...future.result <- base::tryCatch({
[08:24:54.793]         base::withCallingHandlers({
[08:24:54.793]             ...future.value <- base::withVisible(base::local({
[08:24:54.793]                 ...future.makeSendCondition <- base::local({
[08:24:54.793]                   sendCondition <- NULL
[08:24:54.793]                   function(frame = 1L) {
[08:24:54.793]                     if (is.function(sendCondition)) 
[08:24:54.793]                       return(sendCondition)
[08:24:54.793]                     ns <- getNamespace("parallel")
[08:24:54.793]                     if (exists("sendData", mode = "function", 
[08:24:54.793]                       envir = ns)) {
[08:24:54.793]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:54.793]                         envir = ns)
[08:24:54.793]                       envir <- sys.frame(frame)
[08:24:54.793]                       master <- NULL
[08:24:54.793]                       while (!identical(envir, .GlobalEnv) && 
[08:24:54.793]                         !identical(envir, emptyenv())) {
[08:24:54.793]                         if (exists("master", mode = "list", envir = envir, 
[08:24:54.793]                           inherits = FALSE)) {
[08:24:54.793]                           master <- get("master", mode = "list", 
[08:24:54.793]                             envir = envir, inherits = FALSE)
[08:24:54.793]                           if (inherits(master, c("SOCKnode", 
[08:24:54.793]                             "SOCK0node"))) {
[08:24:54.793]                             sendCondition <<- function(cond) {
[08:24:54.793]                               data <- list(type = "VALUE", value = cond, 
[08:24:54.793]                                 success = TRUE)
[08:24:54.793]                               parallel_sendData(master, data)
[08:24:54.793]                             }
[08:24:54.793]                             return(sendCondition)
[08:24:54.793]                           }
[08:24:54.793]                         }
[08:24:54.793]                         frame <- frame + 1L
[08:24:54.793]                         envir <- sys.frame(frame)
[08:24:54.793]                       }
[08:24:54.793]                     }
[08:24:54.793]                     sendCondition <<- function(cond) NULL
[08:24:54.793]                   }
[08:24:54.793]                 })
[08:24:54.793]                 withCallingHandlers({
[08:24:54.793]                   {
[08:24:54.793]                     do.call(function(...) {
[08:24:54.793]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.793]                       if (!identical(...future.globals.maxSize.org, 
[08:24:54.793]                         ...future.globals.maxSize)) {
[08:24:54.793]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.793]                         on.exit(options(oopts), add = TRUE)
[08:24:54.793]                       }
[08:24:54.793]                       {
[08:24:54.793]                         lapply(seq_along(...future.elements_ii), 
[08:24:54.793]                           FUN = function(jj) {
[08:24:54.793]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.793]                             ...future.FUN(...future.X_jj, ...)
[08:24:54.793]                           })
[08:24:54.793]                       }
[08:24:54.793]                     }, args = future.call.arguments)
[08:24:54.793]                   }
[08:24:54.793]                 }, immediateCondition = function(cond) {
[08:24:54.793]                   sendCondition <- ...future.makeSendCondition()
[08:24:54.793]                   sendCondition(cond)
[08:24:54.793]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.793]                   {
[08:24:54.793]                     inherits <- base::inherits
[08:24:54.793]                     invokeRestart <- base::invokeRestart
[08:24:54.793]                     is.null <- base::is.null
[08:24:54.793]                     muffled <- FALSE
[08:24:54.793]                     if (inherits(cond, "message")) {
[08:24:54.793]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:54.793]                       if (muffled) 
[08:24:54.793]                         invokeRestart("muffleMessage")
[08:24:54.793]                     }
[08:24:54.793]                     else if (inherits(cond, "warning")) {
[08:24:54.793]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:54.793]                       if (muffled) 
[08:24:54.793]                         invokeRestart("muffleWarning")
[08:24:54.793]                     }
[08:24:54.793]                     else if (inherits(cond, "condition")) {
[08:24:54.793]                       if (!is.null(pattern)) {
[08:24:54.793]                         computeRestarts <- base::computeRestarts
[08:24:54.793]                         grepl <- base::grepl
[08:24:54.793]                         restarts <- computeRestarts(cond)
[08:24:54.793]                         for (restart in restarts) {
[08:24:54.793]                           name <- restart$name
[08:24:54.793]                           if (is.null(name)) 
[08:24:54.793]                             next
[08:24:54.793]                           if (!grepl(pattern, name)) 
[08:24:54.793]                             next
[08:24:54.793]                           invokeRestart(restart)
[08:24:54.793]                           muffled <- TRUE
[08:24:54.793]                           break
[08:24:54.793]                         }
[08:24:54.793]                       }
[08:24:54.793]                     }
[08:24:54.793]                     invisible(muffled)
[08:24:54.793]                   }
[08:24:54.793]                   muffleCondition(cond)
[08:24:54.793]                 })
[08:24:54.793]             }))
[08:24:54.793]             future::FutureResult(value = ...future.value$value, 
[08:24:54.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.793]                   ...future.rng), globalenv = if (FALSE) 
[08:24:54.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:54.793]                     ...future.globalenv.names))
[08:24:54.793]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:54.793]         }, condition = base::local({
[08:24:54.793]             c <- base::c
[08:24:54.793]             inherits <- base::inherits
[08:24:54.793]             invokeRestart <- base::invokeRestart
[08:24:54.793]             length <- base::length
[08:24:54.793]             list <- base::list
[08:24:54.793]             seq.int <- base::seq.int
[08:24:54.793]             signalCondition <- base::signalCondition
[08:24:54.793]             sys.calls <- base::sys.calls
[08:24:54.793]             `[[` <- base::`[[`
[08:24:54.793]             `+` <- base::`+`
[08:24:54.793]             `<<-` <- base::`<<-`
[08:24:54.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:54.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:54.793]                   3L)]
[08:24:54.793]             }
[08:24:54.793]             function(cond) {
[08:24:54.793]                 is_error <- inherits(cond, "error")
[08:24:54.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:54.793]                   NULL)
[08:24:54.793]                 if (is_error) {
[08:24:54.793]                   sessionInformation <- function() {
[08:24:54.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:54.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:54.793]                       search = base::search(), system = base::Sys.info())
[08:24:54.793]                   }
[08:24:54.793]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:54.793]                     cond$call), session = sessionInformation(), 
[08:24:54.793]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:54.793]                   signalCondition(cond)
[08:24:54.793]                 }
[08:24:54.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:54.793]                 "immediateCondition"))) {
[08:24:54.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:54.793]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:54.793]                   if (TRUE && !signal) {
[08:24:54.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.793]                     {
[08:24:54.793]                       inherits <- base::inherits
[08:24:54.793]                       invokeRestart <- base::invokeRestart
[08:24:54.793]                       is.null <- base::is.null
[08:24:54.793]                       muffled <- FALSE
[08:24:54.793]                       if (inherits(cond, "message")) {
[08:24:54.793]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.793]                         if (muffled) 
[08:24:54.793]                           invokeRestart("muffleMessage")
[08:24:54.793]                       }
[08:24:54.793]                       else if (inherits(cond, "warning")) {
[08:24:54.793]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.793]                         if (muffled) 
[08:24:54.793]                           invokeRestart("muffleWarning")
[08:24:54.793]                       }
[08:24:54.793]                       else if (inherits(cond, "condition")) {
[08:24:54.793]                         if (!is.null(pattern)) {
[08:24:54.793]                           computeRestarts <- base::computeRestarts
[08:24:54.793]                           grepl <- base::grepl
[08:24:54.793]                           restarts <- computeRestarts(cond)
[08:24:54.793]                           for (restart in restarts) {
[08:24:54.793]                             name <- restart$name
[08:24:54.793]                             if (is.null(name)) 
[08:24:54.793]                               next
[08:24:54.793]                             if (!grepl(pattern, name)) 
[08:24:54.793]                               next
[08:24:54.793]                             invokeRestart(restart)
[08:24:54.793]                             muffled <- TRUE
[08:24:54.793]                             break
[08:24:54.793]                           }
[08:24:54.793]                         }
[08:24:54.793]                       }
[08:24:54.793]                       invisible(muffled)
[08:24:54.793]                     }
[08:24:54.793]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.793]                   }
[08:24:54.793]                 }
[08:24:54.793]                 else {
[08:24:54.793]                   if (TRUE) {
[08:24:54.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.793]                     {
[08:24:54.793]                       inherits <- base::inherits
[08:24:54.793]                       invokeRestart <- base::invokeRestart
[08:24:54.793]                       is.null <- base::is.null
[08:24:54.793]                       muffled <- FALSE
[08:24:54.793]                       if (inherits(cond, "message")) {
[08:24:54.793]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.793]                         if (muffled) 
[08:24:54.793]                           invokeRestart("muffleMessage")
[08:24:54.793]                       }
[08:24:54.793]                       else if (inherits(cond, "warning")) {
[08:24:54.793]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.793]                         if (muffled) 
[08:24:54.793]                           invokeRestart("muffleWarning")
[08:24:54.793]                       }
[08:24:54.793]                       else if (inherits(cond, "condition")) {
[08:24:54.793]                         if (!is.null(pattern)) {
[08:24:54.793]                           computeRestarts <- base::computeRestarts
[08:24:54.793]                           grepl <- base::grepl
[08:24:54.793]                           restarts <- computeRestarts(cond)
[08:24:54.793]                           for (restart in restarts) {
[08:24:54.793]                             name <- restart$name
[08:24:54.793]                             if (is.null(name)) 
[08:24:54.793]                               next
[08:24:54.793]                             if (!grepl(pattern, name)) 
[08:24:54.793]                               next
[08:24:54.793]                             invokeRestart(restart)
[08:24:54.793]                             muffled <- TRUE
[08:24:54.793]                             break
[08:24:54.793]                           }
[08:24:54.793]                         }
[08:24:54.793]                       }
[08:24:54.793]                       invisible(muffled)
[08:24:54.793]                     }
[08:24:54.793]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.793]                   }
[08:24:54.793]                 }
[08:24:54.793]             }
[08:24:54.793]         }))
[08:24:54.793]     }, error = function(ex) {
[08:24:54.793]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:54.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.793]                 ...future.rng), started = ...future.startTime, 
[08:24:54.793]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:54.793]             version = "1.8"), class = "FutureResult")
[08:24:54.793]     }, finally = {
[08:24:54.793]         if (!identical(...future.workdir, getwd())) 
[08:24:54.793]             setwd(...future.workdir)
[08:24:54.793]         {
[08:24:54.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:54.793]                 ...future.oldOptions$nwarnings <- NULL
[08:24:54.793]             }
[08:24:54.793]             base::options(...future.oldOptions)
[08:24:54.793]             if (.Platform$OS.type == "windows") {
[08:24:54.793]                 old_names <- names(...future.oldEnvVars)
[08:24:54.793]                 envs <- base::Sys.getenv()
[08:24:54.793]                 names <- names(envs)
[08:24:54.793]                 common <- intersect(names, old_names)
[08:24:54.793]                 added <- setdiff(names, old_names)
[08:24:54.793]                 removed <- setdiff(old_names, names)
[08:24:54.793]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:54.793]                   envs[common]]
[08:24:54.793]                 NAMES <- toupper(changed)
[08:24:54.793]                 args <- list()
[08:24:54.793]                 for (kk in seq_along(NAMES)) {
[08:24:54.793]                   name <- changed[[kk]]
[08:24:54.793]                   NAME <- NAMES[[kk]]
[08:24:54.793]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.793]                     next
[08:24:54.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.793]                 }
[08:24:54.793]                 NAMES <- toupper(added)
[08:24:54.793]                 for (kk in seq_along(NAMES)) {
[08:24:54.793]                   name <- added[[kk]]
[08:24:54.793]                   NAME <- NAMES[[kk]]
[08:24:54.793]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.793]                     next
[08:24:54.793]                   args[[name]] <- ""
[08:24:54.793]                 }
[08:24:54.793]                 NAMES <- toupper(removed)
[08:24:54.793]                 for (kk in seq_along(NAMES)) {
[08:24:54.793]                   name <- removed[[kk]]
[08:24:54.793]                   NAME <- NAMES[[kk]]
[08:24:54.793]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.793]                     next
[08:24:54.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.793]                 }
[08:24:54.793]                 if (length(args) > 0) 
[08:24:54.793]                   base::do.call(base::Sys.setenv, args = args)
[08:24:54.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:54.793]             }
[08:24:54.793]             else {
[08:24:54.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:54.793]             }
[08:24:54.793]             {
[08:24:54.793]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:54.793]                   0L) {
[08:24:54.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:54.793]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:54.793]                   base::options(opts)
[08:24:54.793]                 }
[08:24:54.793]                 {
[08:24:54.793]                   {
[08:24:54.793]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:54.793]                     NULL
[08:24:54.793]                   }
[08:24:54.793]                   options(future.plan = NULL)
[08:24:54.793]                   if (is.na(NA_character_)) 
[08:24:54.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:54.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:54.793]                     .init = FALSE)
[08:24:54.793]                 }
[08:24:54.793]             }
[08:24:54.793]         }
[08:24:54.793]     })
[08:24:54.793]     if (TRUE) {
[08:24:54.793]         base::sink(type = "output", split = FALSE)
[08:24:54.793]         if (TRUE) {
[08:24:54.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:54.793]         }
[08:24:54.793]         else {
[08:24:54.793]             ...future.result["stdout"] <- base::list(NULL)
[08:24:54.793]         }
[08:24:54.793]         base::close(...future.stdout)
[08:24:54.793]         ...future.stdout <- NULL
[08:24:54.793]     }
[08:24:54.793]     ...future.result$conditions <- ...future.conditions
[08:24:54.793]     ...future.result$finished <- base::Sys.time()
[08:24:54.793]     ...future.result
[08:24:54.793] }
[08:24:54.796] Exporting 5 global objects (0.98 KiB) to cluster node #1 ...
[08:24:54.796] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:54.797] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:54.797] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ...
[08:24:54.797] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ... DONE
[08:24:54.797] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[08:24:54.798] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[08:24:54.798] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:54.798] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:54.798] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:54.799] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:54.799] Exporting 5 global objects (0.98 KiB) to cluster node #1 ... DONE
[08:24:54.799] MultisessionFuture started
[08:24:54.800] - Launch lazy future ... done
[08:24:54.800] run() for ‘MultisessionFuture’ ... done
[08:24:54.800] Created future:
[08:24:54.800] MultisessionFuture:
[08:24:54.800] Label: ‘future_apply-1’
[08:24:54.800] Expression:
[08:24:54.800] {
[08:24:54.800]     do.call(function(...) {
[08:24:54.800]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.800]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.800]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.800]             on.exit(options(oopts), add = TRUE)
[08:24:54.800]         }
[08:24:54.800]         {
[08:24:54.800]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.800]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.800]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.800]             })
[08:24:54.800]         }
[08:24:54.800]     }, args = future.call.arguments)
[08:24:54.800] }
[08:24:54.800] Lazy evaluation: FALSE
[08:24:54.800] Asynchronous evaluation: TRUE
[08:24:54.800] Local evaluation: TRUE
[08:24:54.800] Environment: R_GlobalEnv
[08:24:54.800] Capture standard output: TRUE
[08:24:54.800] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:54.800] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:54.800] Packages: 1 packages (‘stats’)
[08:24:54.800] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:54.800] Resolved: FALSE
[08:24:54.800] Value: <not collected>
[08:24:54.800] Conditions captured: <none>
[08:24:54.800] Early signaling: FALSE
[08:24:54.800] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:54.800] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.814] Chunk #1 of 2 ... DONE
[08:24:54.814] Chunk #2 of 2 ...
[08:24:54.814]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:54.814]  - seeds: <none>
[08:24:54.814]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.814] getGlobalsAndPackages() ...
[08:24:54.814] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.814] Resolving globals: FALSE
[08:24:54.814] Tweak future expression to call with '...' arguments ...
[08:24:54.815] {
[08:24:54.815]     do.call(function(...) {
[08:24:54.815]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.815]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.815]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.815]             on.exit(options(oopts), add = TRUE)
[08:24:54.815]         }
[08:24:54.815]         {
[08:24:54.815]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.815]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.815]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.815]             })
[08:24:54.815]         }
[08:24:54.815]     }, args = future.call.arguments)
[08:24:54.815] }
[08:24:54.815] Tweak future expression to call with '...' arguments ... DONE
[08:24:54.815] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.815] - packages: [1] ‘stats’
[08:24:54.816] getGlobalsAndPackages() ... DONE
[08:24:54.816] run() for ‘Future’ ...
[08:24:54.816] - state: ‘created’
[08:24:54.816] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:54.830] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:54.831]   - Field: ‘node’
[08:24:54.831]   - Field: ‘label’
[08:24:54.831]   - Field: ‘local’
[08:24:54.831]   - Field: ‘owner’
[08:24:54.831]   - Field: ‘envir’
[08:24:54.831]   - Field: ‘workers’
[08:24:54.831]   - Field: ‘packages’
[08:24:54.831]   - Field: ‘gc’
[08:24:54.831]   - Field: ‘conditions’
[08:24:54.832]   - Field: ‘persistent’
[08:24:54.832]   - Field: ‘expr’
[08:24:54.832]   - Field: ‘uuid’
[08:24:54.832]   - Field: ‘seed’
[08:24:54.832]   - Field: ‘version’
[08:24:54.832]   - Field: ‘result’
[08:24:54.832]   - Field: ‘asynchronous’
[08:24:54.832]   - Field: ‘calls’
[08:24:54.832]   - Field: ‘globals’
[08:24:54.832]   - Field: ‘stdout’
[08:24:54.832]   - Field: ‘earlySignal’
[08:24:54.832]   - Field: ‘lazy’
[08:24:54.833]   - Field: ‘state’
[08:24:54.833] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:54.833] - Launch lazy future ...
[08:24:54.833] Packages needed by the future expression (n = 1): ‘stats’
[08:24:54.833] Packages needed by future strategies (n = 0): <none>
[08:24:54.834] {
[08:24:54.834]     {
[08:24:54.834]         {
[08:24:54.834]             ...future.startTime <- base::Sys.time()
[08:24:54.834]             {
[08:24:54.834]                 {
[08:24:54.834]                   {
[08:24:54.834]                     {
[08:24:54.834]                       {
[08:24:54.834]                         base::local({
[08:24:54.834]                           has_future <- base::requireNamespace("future", 
[08:24:54.834]                             quietly = TRUE)
[08:24:54.834]                           if (has_future) {
[08:24:54.834]                             ns <- base::getNamespace("future")
[08:24:54.834]                             version <- ns[[".package"]][["version"]]
[08:24:54.834]                             if (is.null(version)) 
[08:24:54.834]                               version <- utils::packageVersion("future")
[08:24:54.834]                           }
[08:24:54.834]                           else {
[08:24:54.834]                             version <- NULL
[08:24:54.834]                           }
[08:24:54.834]                           if (!has_future || version < "1.8.0") {
[08:24:54.834]                             info <- base::c(r_version = base::gsub("R version ", 
[08:24:54.834]                               "", base::R.version$version.string), 
[08:24:54.834]                               platform = base::sprintf("%s (%s-bit)", 
[08:24:54.834]                                 base::R.version$platform, 8 * 
[08:24:54.834]                                   base::.Machine$sizeof.pointer), 
[08:24:54.834]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:54.834]                                 "release", "version")], collapse = " "), 
[08:24:54.834]                               hostname = base::Sys.info()[["nodename"]])
[08:24:54.834]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:24:54.834]                               info)
[08:24:54.834]                             info <- base::paste(info, collapse = "; ")
[08:24:54.834]                             if (!has_future) {
[08:24:54.834]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:54.834]                                 info)
[08:24:54.834]                             }
[08:24:54.834]                             else {
[08:24:54.834]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:54.834]                                 info, version)
[08:24:54.834]                             }
[08:24:54.834]                             base::stop(msg)
[08:24:54.834]                           }
[08:24:54.834]                         })
[08:24:54.834]                       }
[08:24:54.834]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:54.834]                       base::options(mc.cores = 1L)
[08:24:54.834]                     }
[08:24:54.834]                     base::local({
[08:24:54.834]                       for (pkg in "stats") {
[08:24:54.834]                         base::loadNamespace(pkg)
[08:24:54.834]                         base::library(pkg, character.only = TRUE)
[08:24:54.834]                       }
[08:24:54.834]                     })
[08:24:54.834]                   }
[08:24:54.834]                   ...future.strategy.old <- future::plan("list")
[08:24:54.834]                   options(future.plan = NULL)
[08:24:54.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:54.834]                 }
[08:24:54.834]                 ...future.workdir <- getwd()
[08:24:54.834]             }
[08:24:54.834]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:54.834]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:54.834]         }
[08:24:54.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:54.834]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:54.834]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:54.834]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:54.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:54.834]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:54.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:54.834]             base::names(...future.oldOptions))
[08:24:54.834]     }
[08:24:54.834]     if (FALSE) {
[08:24:54.834]     }
[08:24:54.834]     else {
[08:24:54.834]         if (TRUE) {
[08:24:54.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:54.834]                 open = "w")
[08:24:54.834]         }
[08:24:54.834]         else {
[08:24:54.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:54.834]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:54.834]         }
[08:24:54.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:54.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:54.834]             base::sink(type = "output", split = FALSE)
[08:24:54.834]             base::close(...future.stdout)
[08:24:54.834]         }, add = TRUE)
[08:24:54.834]     }
[08:24:54.834]     ...future.frame <- base::sys.nframe()
[08:24:54.834]     ...future.conditions <- base::list()
[08:24:54.834]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:54.834]     if (FALSE) {
[08:24:54.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:54.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:54.834]     }
[08:24:54.834]     ...future.result <- base::tryCatch({
[08:24:54.834]         base::withCallingHandlers({
[08:24:54.834]             ...future.value <- base::withVisible(base::local({
[08:24:54.834]                 ...future.makeSendCondition <- base::local({
[08:24:54.834]                   sendCondition <- NULL
[08:24:54.834]                   function(frame = 1L) {
[08:24:54.834]                     if (is.function(sendCondition)) 
[08:24:54.834]                       return(sendCondition)
[08:24:54.834]                     ns <- getNamespace("parallel")
[08:24:54.834]                     if (exists("sendData", mode = "function", 
[08:24:54.834]                       envir = ns)) {
[08:24:54.834]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:54.834]                         envir = ns)
[08:24:54.834]                       envir <- sys.frame(frame)
[08:24:54.834]                       master <- NULL
[08:24:54.834]                       while (!identical(envir, .GlobalEnv) && 
[08:24:54.834]                         !identical(envir, emptyenv())) {
[08:24:54.834]                         if (exists("master", mode = "list", envir = envir, 
[08:24:54.834]                           inherits = FALSE)) {
[08:24:54.834]                           master <- get("master", mode = "list", 
[08:24:54.834]                             envir = envir, inherits = FALSE)
[08:24:54.834]                           if (inherits(master, c("SOCKnode", 
[08:24:54.834]                             "SOCK0node"))) {
[08:24:54.834]                             sendCondition <<- function(cond) {
[08:24:54.834]                               data <- list(type = "VALUE", value = cond, 
[08:24:54.834]                                 success = TRUE)
[08:24:54.834]                               parallel_sendData(master, data)
[08:24:54.834]                             }
[08:24:54.834]                             return(sendCondition)
[08:24:54.834]                           }
[08:24:54.834]                         }
[08:24:54.834]                         frame <- frame + 1L
[08:24:54.834]                         envir <- sys.frame(frame)
[08:24:54.834]                       }
[08:24:54.834]                     }
[08:24:54.834]                     sendCondition <<- function(cond) NULL
[08:24:54.834]                   }
[08:24:54.834]                 })
[08:24:54.834]                 withCallingHandlers({
[08:24:54.834]                   {
[08:24:54.834]                     do.call(function(...) {
[08:24:54.834]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.834]                       if (!identical(...future.globals.maxSize.org, 
[08:24:54.834]                         ...future.globals.maxSize)) {
[08:24:54.834]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.834]                         on.exit(options(oopts), add = TRUE)
[08:24:54.834]                       }
[08:24:54.834]                       {
[08:24:54.834]                         lapply(seq_along(...future.elements_ii), 
[08:24:54.834]                           FUN = function(jj) {
[08:24:54.834]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.834]                             ...future.FUN(...future.X_jj, ...)
[08:24:54.834]                           })
[08:24:54.834]                       }
[08:24:54.834]                     }, args = future.call.arguments)
[08:24:54.834]                   }
[08:24:54.834]                 }, immediateCondition = function(cond) {
[08:24:54.834]                   sendCondition <- ...future.makeSendCondition()
[08:24:54.834]                   sendCondition(cond)
[08:24:54.834]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.834]                   {
[08:24:54.834]                     inherits <- base::inherits
[08:24:54.834]                     invokeRestart <- base::invokeRestart
[08:24:54.834]                     is.null <- base::is.null
[08:24:54.834]                     muffled <- FALSE
[08:24:54.834]                     if (inherits(cond, "message")) {
[08:24:54.834]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:54.834]                       if (muffled) 
[08:24:54.834]                         invokeRestart("muffleMessage")
[08:24:54.834]                     }
[08:24:54.834]                     else if (inherits(cond, "warning")) {
[08:24:54.834]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:54.834]                       if (muffled) 
[08:24:54.834]                         invokeRestart("muffleWarning")
[08:24:54.834]                     }
[08:24:54.834]                     else if (inherits(cond, "condition")) {
[08:24:54.834]                       if (!is.null(pattern)) {
[08:24:54.834]                         computeRestarts <- base::computeRestarts
[08:24:54.834]                         grepl <- base::grepl
[08:24:54.834]                         restarts <- computeRestarts(cond)
[08:24:54.834]                         for (restart in restarts) {
[08:24:54.834]                           name <- restart$name
[08:24:54.834]                           if (is.null(name)) 
[08:24:54.834]                             next
[08:24:54.834]                           if (!grepl(pattern, name)) 
[08:24:54.834]                             next
[08:24:54.834]                           invokeRestart(restart)
[08:24:54.834]                           muffled <- TRUE
[08:24:54.834]                           break
[08:24:54.834]                         }
[08:24:54.834]                       }
[08:24:54.834]                     }
[08:24:54.834]                     invisible(muffled)
[08:24:54.834]                   }
[08:24:54.834]                   muffleCondition(cond)
[08:24:54.834]                 })
[08:24:54.834]             }))
[08:24:54.834]             future::FutureResult(value = ...future.value$value, 
[08:24:54.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.834]                   ...future.rng), globalenv = if (FALSE) 
[08:24:54.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:54.834]                     ...future.globalenv.names))
[08:24:54.834]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:54.834]         }, condition = base::local({
[08:24:54.834]             c <- base::c
[08:24:54.834]             inherits <- base::inherits
[08:24:54.834]             invokeRestart <- base::invokeRestart
[08:24:54.834]             length <- base::length
[08:24:54.834]             list <- base::list
[08:24:54.834]             seq.int <- base::seq.int
[08:24:54.834]             signalCondition <- base::signalCondition
[08:24:54.834]             sys.calls <- base::sys.calls
[08:24:54.834]             `[[` <- base::`[[`
[08:24:54.834]             `+` <- base::`+`
[08:24:54.834]             `<<-` <- base::`<<-`
[08:24:54.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:54.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:54.834]                   3L)]
[08:24:54.834]             }
[08:24:54.834]             function(cond) {
[08:24:54.834]                 is_error <- inherits(cond, "error")
[08:24:54.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:54.834]                   NULL)
[08:24:54.834]                 if (is_error) {
[08:24:54.834]                   sessionInformation <- function() {
[08:24:54.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:54.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:54.834]                       search = base::search(), system = base::Sys.info())
[08:24:54.834]                   }
[08:24:54.834]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:54.834]                     cond$call), session = sessionInformation(), 
[08:24:54.834]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:54.834]                   signalCondition(cond)
[08:24:54.834]                 }
[08:24:54.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:54.834]                 "immediateCondition"))) {
[08:24:54.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:54.834]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:54.834]                   if (TRUE && !signal) {
[08:24:54.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.834]                     {
[08:24:54.834]                       inherits <- base::inherits
[08:24:54.834]                       invokeRestart <- base::invokeRestart
[08:24:54.834]                       is.null <- base::is.null
[08:24:54.834]                       muffled <- FALSE
[08:24:54.834]                       if (inherits(cond, "message")) {
[08:24:54.834]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.834]                         if (muffled) 
[08:24:54.834]                           invokeRestart("muffleMessage")
[08:24:54.834]                       }
[08:24:54.834]                       else if (inherits(cond, "warning")) {
[08:24:54.834]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.834]                         if (muffled) 
[08:24:54.834]                           invokeRestart("muffleWarning")
[08:24:54.834]                       }
[08:24:54.834]                       else if (inherits(cond, "condition")) {
[08:24:54.834]                         if (!is.null(pattern)) {
[08:24:54.834]                           computeRestarts <- base::computeRestarts
[08:24:54.834]                           grepl <- base::grepl
[08:24:54.834]                           restarts <- computeRestarts(cond)
[08:24:54.834]                           for (restart in restarts) {
[08:24:54.834]                             name <- restart$name
[08:24:54.834]                             if (is.null(name)) 
[08:24:54.834]                               next
[08:24:54.834]                             if (!grepl(pattern, name)) 
[08:24:54.834]                               next
[08:24:54.834]                             invokeRestart(restart)
[08:24:54.834]                             muffled <- TRUE
[08:24:54.834]                             break
[08:24:54.834]                           }
[08:24:54.834]                         }
[08:24:54.834]                       }
[08:24:54.834]                       invisible(muffled)
[08:24:54.834]                     }
[08:24:54.834]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.834]                   }
[08:24:54.834]                 }
[08:24:54.834]                 else {
[08:24:54.834]                   if (TRUE) {
[08:24:54.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.834]                     {
[08:24:54.834]                       inherits <- base::inherits
[08:24:54.834]                       invokeRestart <- base::invokeRestart
[08:24:54.834]                       is.null <- base::is.null
[08:24:54.834]                       muffled <- FALSE
[08:24:54.834]                       if (inherits(cond, "message")) {
[08:24:54.834]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.834]                         if (muffled) 
[08:24:54.834]                           invokeRestart("muffleMessage")
[08:24:54.834]                       }
[08:24:54.834]                       else if (inherits(cond, "warning")) {
[08:24:54.834]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.834]                         if (muffled) 
[08:24:54.834]                           invokeRestart("muffleWarning")
[08:24:54.834]                       }
[08:24:54.834]                       else if (inherits(cond, "condition")) {
[08:24:54.834]                         if (!is.null(pattern)) {
[08:24:54.834]                           computeRestarts <- base::computeRestarts
[08:24:54.834]                           grepl <- base::grepl
[08:24:54.834]                           restarts <- computeRestarts(cond)
[08:24:54.834]                           for (restart in restarts) {
[08:24:54.834]                             name <- restart$name
[08:24:54.834]                             if (is.null(name)) 
[08:24:54.834]                               next
[08:24:54.834]                             if (!grepl(pattern, name)) 
[08:24:54.834]                               next
[08:24:54.834]                             invokeRestart(restart)
[08:24:54.834]                             muffled <- TRUE
[08:24:54.834]                             break
[08:24:54.834]                           }
[08:24:54.834]                         }
[08:24:54.834]                       }
[08:24:54.834]                       invisible(muffled)
[08:24:54.834]                     }
[08:24:54.834]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.834]                   }
[08:24:54.834]                 }
[08:24:54.834]             }
[08:24:54.834]         }))
[08:24:54.834]     }, error = function(ex) {
[08:24:54.834]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:54.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.834]                 ...future.rng), started = ...future.startTime, 
[08:24:54.834]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:54.834]             version = "1.8"), class = "FutureResult")
[08:24:54.834]     }, finally = {
[08:24:54.834]         if (!identical(...future.workdir, getwd())) 
[08:24:54.834]             setwd(...future.workdir)
[08:24:54.834]         {
[08:24:54.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:54.834]                 ...future.oldOptions$nwarnings <- NULL
[08:24:54.834]             }
[08:24:54.834]             base::options(...future.oldOptions)
[08:24:54.834]             if (.Platform$OS.type == "windows") {
[08:24:54.834]                 old_names <- names(...future.oldEnvVars)
[08:24:54.834]                 envs <- base::Sys.getenv()
[08:24:54.834]                 names <- names(envs)
[08:24:54.834]                 common <- intersect(names, old_names)
[08:24:54.834]                 added <- setdiff(names, old_names)
[08:24:54.834]                 removed <- setdiff(old_names, names)
[08:24:54.834]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:54.834]                   envs[common]]
[08:24:54.834]                 NAMES <- toupper(changed)
[08:24:54.834]                 args <- list()
[08:24:54.834]                 for (kk in seq_along(NAMES)) {
[08:24:54.834]                   name <- changed[[kk]]
[08:24:54.834]                   NAME <- NAMES[[kk]]
[08:24:54.834]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.834]                     next
[08:24:54.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.834]                 }
[08:24:54.834]                 NAMES <- toupper(added)
[08:24:54.834]                 for (kk in seq_along(NAMES)) {
[08:24:54.834]                   name <- added[[kk]]
[08:24:54.834]                   NAME <- NAMES[[kk]]
[08:24:54.834]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.834]                     next
[08:24:54.834]                   args[[name]] <- ""
[08:24:54.834]                 }
[08:24:54.834]                 NAMES <- toupper(removed)
[08:24:54.834]                 for (kk in seq_along(NAMES)) {
[08:24:54.834]                   name <- removed[[kk]]
[08:24:54.834]                   NAME <- NAMES[[kk]]
[08:24:54.834]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.834]                     next
[08:24:54.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.834]                 }
[08:24:54.834]                 if (length(args) > 0) 
[08:24:54.834]                   base::do.call(base::Sys.setenv, args = args)
[08:24:54.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:54.834]             }
[08:24:54.834]             else {
[08:24:54.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:54.834]             }
[08:24:54.834]             {
[08:24:54.834]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:54.834]                   0L) {
[08:24:54.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:54.834]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:54.834]                   base::options(opts)
[08:24:54.834]                 }
[08:24:54.834]                 {
[08:24:54.834]                   {
[08:24:54.834]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:54.834]                     NULL
[08:24:54.834]                   }
[08:24:54.834]                   options(future.plan = NULL)
[08:24:54.834]                   if (is.na(NA_character_)) 
[08:24:54.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:54.834]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:54.834]                     .init = FALSE)
[08:24:54.834]                 }
[08:24:54.834]             }
[08:24:54.834]         }
[08:24:54.834]     })
[08:24:54.834]     if (TRUE) {
[08:24:54.834]         base::sink(type = "output", split = FALSE)
[08:24:54.834]         if (TRUE) {
[08:24:54.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:54.834]         }
[08:24:54.834]         else {
[08:24:54.834]             ...future.result["stdout"] <- base::list(NULL)
[08:24:54.834]         }
[08:24:54.834]         base::close(...future.stdout)
[08:24:54.834]         ...future.stdout <- NULL
[08:24:54.834]     }
[08:24:54.834]     ...future.result$conditions <- ...future.conditions
[08:24:54.834]     ...future.result$finished <- base::Sys.time()
[08:24:54.834]     ...future.result
[08:24:54.834] }
[08:24:54.837] Exporting 5 global objects (0.98 KiB) to cluster node #2 ...
[08:24:54.837] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:54.837] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:54.837] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ...
[08:24:54.838] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ... DONE
[08:24:54.838] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[08:24:54.838] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[08:24:54.838] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:54.839] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:54.839] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:54.839] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:54.839] Exporting 5 global objects (0.98 KiB) to cluster node #2 ... DONE
[08:24:54.840] MultisessionFuture started
[08:24:54.840] - Launch lazy future ... done
[08:24:54.840] run() for ‘MultisessionFuture’ ... done
[08:24:54.840] Created future:
[08:24:54.840] MultisessionFuture:
[08:24:54.840] Label: ‘future_apply-2’
[08:24:54.840] Expression:
[08:24:54.840] {
[08:24:54.840]     do.call(function(...) {
[08:24:54.840]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.840]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.840]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.840]             on.exit(options(oopts), add = TRUE)
[08:24:54.840]         }
[08:24:54.840]         {
[08:24:54.840]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.840]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.840]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.840]             })
[08:24:54.840]         }
[08:24:54.840]     }, args = future.call.arguments)
[08:24:54.840] }
[08:24:54.840] Lazy evaluation: FALSE
[08:24:54.840] Asynchronous evaluation: TRUE
[08:24:54.840] Local evaluation: TRUE
[08:24:54.840] Environment: R_GlobalEnv
[08:24:54.840] Capture standard output: TRUE
[08:24:54.840] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:54.840] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:54.840] Packages: 1 packages (‘stats’)
[08:24:54.840] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:54.840] Resolved: FALSE
[08:24:54.840] Value: <not collected>
[08:24:54.840] Conditions captured: <none>
[08:24:54.840] Early signaling: FALSE
[08:24:54.840] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:54.840] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.852] Chunk #2 of 2 ... DONE
[08:24:54.852] Launching 2 futures (chunks) ... DONE
[08:24:54.852] Resolving 2 futures (chunks) ...
[08:24:54.852] resolve() on list ...
[08:24:54.852]  recursive: 0
[08:24:54.852]  length: 2
[08:24:54.852] 
[08:24:54.853] receiveMessageFromWorker() for ClusterFuture ...
[08:24:54.853] - Validating connection of MultisessionFuture
[08:24:54.853] - received message: FutureResult
[08:24:54.853] - Received FutureResult
[08:24:54.853] - Erased future from FutureRegistry
[08:24:54.854] result() for ClusterFuture ...
[08:24:54.854] - result already collected: FutureResult
[08:24:54.854] result() for ClusterFuture ... done
[08:24:54.854] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:54.854] Future #1
[08:24:54.854] result() for ClusterFuture ...
[08:24:54.854] - result already collected: FutureResult
[08:24:54.854] result() for ClusterFuture ... done
[08:24:54.854] result() for ClusterFuture ...
[08:24:54.854] - result already collected: FutureResult
[08:24:54.854] result() for ClusterFuture ... done
[08:24:54.854] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:54.855] - nx: 2
[08:24:54.855] - relay: TRUE
[08:24:54.855] - stdout: TRUE
[08:24:54.855] - signal: TRUE
[08:24:54.855] - resignal: FALSE
[08:24:54.855] - force: TRUE
[08:24:54.855] - relayed: [n=2] FALSE, FALSE
[08:24:54.855] - queued futures: [n=2] FALSE, FALSE
[08:24:54.855]  - until=1
[08:24:54.855]  - relaying element #1
[08:24:54.855] result() for ClusterFuture ...
[08:24:54.855] - result already collected: FutureResult
[08:24:54.855] result() for ClusterFuture ... done
[08:24:54.856] result() for ClusterFuture ...
[08:24:54.856] - result already collected: FutureResult
[08:24:54.856] result() for ClusterFuture ... done
[08:24:54.856] result() for ClusterFuture ...
[08:24:54.856] - result already collected: FutureResult
[08:24:54.856] result() for ClusterFuture ... done
[08:24:54.856] result() for ClusterFuture ...
[08:24:54.856] - result already collected: FutureResult
[08:24:54.856] result() for ClusterFuture ... done
[08:24:54.856] - relayed: [n=2] TRUE, FALSE
[08:24:54.856] - queued futures: [n=2] TRUE, FALSE
[08:24:54.857] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:54.857]  length: 1 (resolved future 1)
[08:24:54.884] receiveMessageFromWorker() for ClusterFuture ...
[08:24:54.884] - Validating connection of MultisessionFuture
[08:24:54.884] - received message: FutureResult
[08:24:54.885] - Received FutureResult
[08:24:54.885] - Erased future from FutureRegistry
[08:24:54.885] result() for ClusterFuture ...
[08:24:54.885] - result already collected: FutureResult
[08:24:54.885] result() for ClusterFuture ... done
[08:24:54.885] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:54.885] Future #2
[08:24:54.885] result() for ClusterFuture ...
[08:24:54.885] - result already collected: FutureResult
[08:24:54.885] result() for ClusterFuture ... done
[08:24:54.886] result() for ClusterFuture ...
[08:24:54.886] - result already collected: FutureResult
[08:24:54.886] result() for ClusterFuture ... done
[08:24:54.886] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:54.886] - nx: 2
[08:24:54.886] - relay: TRUE
[08:24:54.886] - stdout: TRUE
[08:24:54.886] - signal: TRUE
[08:24:54.886] - resignal: FALSE
[08:24:54.886] - force: TRUE
[08:24:54.886] - relayed: [n=2] TRUE, FALSE
[08:24:54.886] - queued futures: [n=2] TRUE, FALSE
[08:24:54.887]  - until=2
[08:24:54.887]  - relaying element #2
[08:24:54.887] result() for ClusterFuture ...
[08:24:54.887] - result already collected: FutureResult
[08:24:54.887] result() for ClusterFuture ... done
[08:24:54.887] result() for ClusterFuture ...
[08:24:54.887] - result already collected: FutureResult
[08:24:54.887] result() for ClusterFuture ... done
[08:24:54.887] result() for ClusterFuture ...
[08:24:54.887] - result already collected: FutureResult
[08:24:54.887] result() for ClusterFuture ... done
[08:24:54.888] result() for ClusterFuture ...
[08:24:54.888] - result already collected: FutureResult
[08:24:54.888] result() for ClusterFuture ... done
[08:24:54.888] - relayed: [n=2] TRUE, TRUE
[08:24:54.888] - queued futures: [n=2] TRUE, TRUE
[08:24:54.888] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:54.888]  length: 0 (resolved future 2)
[08:24:54.888] Relaying remaining futures
[08:24:54.888] signalConditionsASAP(NULL, pos=0) ...
[08:24:54.888] - nx: 2
[08:24:54.888] - relay: TRUE
[08:24:54.888] - stdout: TRUE
[08:24:54.888] - signal: TRUE
[08:24:54.889] - resignal: FALSE
[08:24:54.889] - force: TRUE
[08:24:54.889] - relayed: [n=2] TRUE, TRUE
[08:24:54.889] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:54.889] - relayed: [n=2] TRUE, TRUE
[08:24:54.889] - queued futures: [n=2] TRUE, TRUE
[08:24:54.889] signalConditionsASAP(NULL, pos=0) ... done
[08:24:54.889] resolve() on list ... DONE
[08:24:54.889] result() for ClusterFuture ...
[08:24:54.889] - result already collected: FutureResult
[08:24:54.889] result() for ClusterFuture ... done
[08:24:54.890] result() for ClusterFuture ...
[08:24:54.890] - result already collected: FutureResult
[08:24:54.890] result() for ClusterFuture ... done
[08:24:54.890] result() for ClusterFuture ...
[08:24:54.890] - result already collected: FutureResult
[08:24:54.890] result() for ClusterFuture ... done
[08:24:54.890] result() for ClusterFuture ...
[08:24:54.890] - result already collected: FutureResult
[08:24:54.890] result() for ClusterFuture ... done
[08:24:54.890]  - Number of value chunks collected: 2
[08:24:54.890] Resolving 2 futures (chunks) ... DONE
[08:24:54.890] Reducing values from 2 chunks ...
[08:24:54.891]  - Number of values collected after concatenation: 2
[08:24:54.891]  - Number of values expected: 2
[08:24:54.891] Reducing values from 2 chunks ... DONE
[08:24:54.891] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[08:24:54.891] getGlobalsAndPackagesXApply() ...
[08:24:54.891]  - future.globals: TRUE
[08:24:54.892] getGlobalsAndPackages() ...
[08:24:54.892] Searching for globals...
[08:24:54.893] - globals found: [1] ‘FUN’
[08:24:54.893] Searching for globals ... DONE
[08:24:54.893] Resolving globals: FALSE
[08:24:54.893] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:54.894] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:54.894] - globals: [1] ‘FUN’
[08:24:54.894] 
[08:24:54.894] getGlobalsAndPackages() ... DONE
[08:24:54.894]  - globals found/used: [n=1] ‘FUN’
[08:24:54.894]  - needed namespaces: [n=0] 
[08:24:54.894] Finding globals ... DONE
[08:24:54.894]  - use_args: TRUE
[08:24:54.894]  - Getting '...' globals ...
[08:24:54.895] resolve() on list ...
[08:24:54.895]  recursive: 0
[08:24:54.895]  length: 1
[08:24:54.895]  elements: ‘...’
[08:24:54.895]  length: 0 (resolved future 1)
[08:24:54.895] resolve() on list ... DONE
[08:24:54.895]    - '...' content: [n=0] 
[08:24:54.895] List of 1
[08:24:54.895]  $ ...: list()
[08:24:54.895]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.895]  - attr(*, "where")=List of 1
[08:24:54.895]   ..$ ...:<environment: 0x56540ed997a8> 
[08:24:54.895]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.895]  - attr(*, "resolved")= logi TRUE
[08:24:54.895]  - attr(*, "total_size")= num NA
[08:24:54.898]  - Getting '...' globals ... DONE
[08:24:54.898] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:54.898] List of 2
[08:24:54.898]  $ ...future.FUN:function (x)  
[08:24:54.898]  $ ...          : list()
[08:24:54.898]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.898]  - attr(*, "where")=List of 2
[08:24:54.898]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:54.898]   ..$ ...          :<environment: 0x56540ed997a8> 
[08:24:54.898]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.898]  - attr(*, "resolved")= logi FALSE
[08:24:54.898]  - attr(*, "total_size")= num 2624
[08:24:54.901] Packages to be attached in all futures: [n=0] 
[08:24:54.901] getGlobalsAndPackagesXApply() ... DONE
[08:24:54.902] future_lapply() ...
[08:24:54.904] Number of chunks: 2
[08:24:54.904] getGlobalsAndPackagesXApply() ...
[08:24:54.905]  - future.globals: <name-value list> with names ‘list()’
[08:24:54.905]  - use_args: TRUE
[08:24:54.905] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:54.905] List of 2
[08:24:54.905]  $ ...          : list()
[08:24:54.905]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:54.905]  $ ...future.FUN:function (x)  
[08:24:54.905]  - attr(*, "where")=List of 2
[08:24:54.905]   ..$ ...          :<environment: 0x56540ed997a8> 
[08:24:54.905]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:54.905]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:54.905]  - attr(*, "resolved")= logi FALSE
[08:24:54.905]  - attr(*, "total_size")= num NA
[08:24:54.908] Packages to be attached in all futures: [n=0] 
[08:24:54.908] getGlobalsAndPackagesXApply() ... DONE
[08:24:54.909] Number of futures (= number of chunks): 2
[08:24:54.909] Launching 2 futures (chunks) ...
[08:24:54.909] Chunk #1 of 2 ...
[08:24:54.909]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:54.909]  - seeds: <none>
[08:24:54.909]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.909] getGlobalsAndPackages() ...
[08:24:54.909] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.910] Resolving globals: FALSE
[08:24:54.910] Tweak future expression to call with '...' arguments ...
[08:24:54.910] {
[08:24:54.910]     do.call(function(...) {
[08:24:54.910]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.910]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.910]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.910]             on.exit(options(oopts), add = TRUE)
[08:24:54.910]         }
[08:24:54.910]         {
[08:24:54.910]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.910]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.910]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.910]             })
[08:24:54.910]         }
[08:24:54.910]     }, args = future.call.arguments)
[08:24:54.910] }
[08:24:54.910] Tweak future expression to call with '...' arguments ... DONE
[08:24:54.910] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.910] 
[08:24:54.911] getGlobalsAndPackages() ... DONE
[08:24:54.911] run() for ‘Future’ ...
[08:24:54.911] - state: ‘created’
[08:24:54.911] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:54.925] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.925] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:54.925]   - Field: ‘node’
[08:24:54.925]   - Field: ‘label’
[08:24:54.925]   - Field: ‘local’
[08:24:54.926]   - Field: ‘owner’
[08:24:54.926]   - Field: ‘envir’
[08:24:54.926]   - Field: ‘workers’
[08:24:54.926]   - Field: ‘packages’
[08:24:54.926]   - Field: ‘gc’
[08:24:54.926]   - Field: ‘conditions’
[08:24:54.926]   - Field: ‘persistent’
[08:24:54.926]   - Field: ‘expr’
[08:24:54.926]   - Field: ‘uuid’
[08:24:54.926]   - Field: ‘seed’
[08:24:54.926]   - Field: ‘version’
[08:24:54.927]   - Field: ‘result’
[08:24:54.927]   - Field: ‘asynchronous’
[08:24:54.927]   - Field: ‘calls’
[08:24:54.927]   - Field: ‘globals’
[08:24:54.927]   - Field: ‘stdout’
[08:24:54.927]   - Field: ‘earlySignal’
[08:24:54.927]   - Field: ‘lazy’
[08:24:54.927]   - Field: ‘state’
[08:24:54.927] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:54.927] - Launch lazy future ...
[08:24:54.928] Packages needed by the future expression (n = 0): <none>
[08:24:54.928] Packages needed by future strategies (n = 0): <none>
[08:24:54.928] {
[08:24:54.928]     {
[08:24:54.928]         {
[08:24:54.928]             ...future.startTime <- base::Sys.time()
[08:24:54.928]             {
[08:24:54.928]                 {
[08:24:54.928]                   {
[08:24:54.928]                     {
[08:24:54.928]                       base::local({
[08:24:54.928]                         has_future <- base::requireNamespace("future", 
[08:24:54.928]                           quietly = TRUE)
[08:24:54.928]                         if (has_future) {
[08:24:54.928]                           ns <- base::getNamespace("future")
[08:24:54.928]                           version <- ns[[".package"]][["version"]]
[08:24:54.928]                           if (is.null(version)) 
[08:24:54.928]                             version <- utils::packageVersion("future")
[08:24:54.928]                         }
[08:24:54.928]                         else {
[08:24:54.928]                           version <- NULL
[08:24:54.928]                         }
[08:24:54.928]                         if (!has_future || version < "1.8.0") {
[08:24:54.928]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:54.928]                             "", base::R.version$version.string), 
[08:24:54.928]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:54.928]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:54.928]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:54.928]                               "release", "version")], collapse = " "), 
[08:24:54.928]                             hostname = base::Sys.info()[["nodename"]])
[08:24:54.928]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:54.928]                             info)
[08:24:54.928]                           info <- base::paste(info, collapse = "; ")
[08:24:54.928]                           if (!has_future) {
[08:24:54.928]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:54.928]                               info)
[08:24:54.928]                           }
[08:24:54.928]                           else {
[08:24:54.928]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:54.928]                               info, version)
[08:24:54.928]                           }
[08:24:54.928]                           base::stop(msg)
[08:24:54.928]                         }
[08:24:54.928]                       })
[08:24:54.928]                     }
[08:24:54.928]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:54.928]                     base::options(mc.cores = 1L)
[08:24:54.928]                   }
[08:24:54.928]                   ...future.strategy.old <- future::plan("list")
[08:24:54.928]                   options(future.plan = NULL)
[08:24:54.928]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.928]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:54.928]                 }
[08:24:54.928]                 ...future.workdir <- getwd()
[08:24:54.928]             }
[08:24:54.928]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:54.928]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:54.928]         }
[08:24:54.928]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:54.928]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:54.928]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:54.928]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:54.928]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:54.928]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:54.928]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:54.928]             base::names(...future.oldOptions))
[08:24:54.928]     }
[08:24:54.928]     if (FALSE) {
[08:24:54.928]     }
[08:24:54.928]     else {
[08:24:54.928]         if (TRUE) {
[08:24:54.928]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:54.928]                 open = "w")
[08:24:54.928]         }
[08:24:54.928]         else {
[08:24:54.928]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:54.928]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:54.928]         }
[08:24:54.928]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:54.928]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:54.928]             base::sink(type = "output", split = FALSE)
[08:24:54.928]             base::close(...future.stdout)
[08:24:54.928]         }, add = TRUE)
[08:24:54.928]     }
[08:24:54.928]     ...future.frame <- base::sys.nframe()
[08:24:54.928]     ...future.conditions <- base::list()
[08:24:54.928]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:54.928]     if (FALSE) {
[08:24:54.928]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:54.928]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:54.928]     }
[08:24:54.928]     ...future.result <- base::tryCatch({
[08:24:54.928]         base::withCallingHandlers({
[08:24:54.928]             ...future.value <- base::withVisible(base::local({
[08:24:54.928]                 ...future.makeSendCondition <- base::local({
[08:24:54.928]                   sendCondition <- NULL
[08:24:54.928]                   function(frame = 1L) {
[08:24:54.928]                     if (is.function(sendCondition)) 
[08:24:54.928]                       return(sendCondition)
[08:24:54.928]                     ns <- getNamespace("parallel")
[08:24:54.928]                     if (exists("sendData", mode = "function", 
[08:24:54.928]                       envir = ns)) {
[08:24:54.928]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:54.928]                         envir = ns)
[08:24:54.928]                       envir <- sys.frame(frame)
[08:24:54.928]                       master <- NULL
[08:24:54.928]                       while (!identical(envir, .GlobalEnv) && 
[08:24:54.928]                         !identical(envir, emptyenv())) {
[08:24:54.928]                         if (exists("master", mode = "list", envir = envir, 
[08:24:54.928]                           inherits = FALSE)) {
[08:24:54.928]                           master <- get("master", mode = "list", 
[08:24:54.928]                             envir = envir, inherits = FALSE)
[08:24:54.928]                           if (inherits(master, c("SOCKnode", 
[08:24:54.928]                             "SOCK0node"))) {
[08:24:54.928]                             sendCondition <<- function(cond) {
[08:24:54.928]                               data <- list(type = "VALUE", value = cond, 
[08:24:54.928]                                 success = TRUE)
[08:24:54.928]                               parallel_sendData(master, data)
[08:24:54.928]                             }
[08:24:54.928]                             return(sendCondition)
[08:24:54.928]                           }
[08:24:54.928]                         }
[08:24:54.928]                         frame <- frame + 1L
[08:24:54.928]                         envir <- sys.frame(frame)
[08:24:54.928]                       }
[08:24:54.928]                     }
[08:24:54.928]                     sendCondition <<- function(cond) NULL
[08:24:54.928]                   }
[08:24:54.928]                 })
[08:24:54.928]                 withCallingHandlers({
[08:24:54.928]                   {
[08:24:54.928]                     do.call(function(...) {
[08:24:54.928]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.928]                       if (!identical(...future.globals.maxSize.org, 
[08:24:54.928]                         ...future.globals.maxSize)) {
[08:24:54.928]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.928]                         on.exit(options(oopts), add = TRUE)
[08:24:54.928]                       }
[08:24:54.928]                       {
[08:24:54.928]                         lapply(seq_along(...future.elements_ii), 
[08:24:54.928]                           FUN = function(jj) {
[08:24:54.928]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.928]                             ...future.FUN(...future.X_jj, ...)
[08:24:54.928]                           })
[08:24:54.928]                       }
[08:24:54.928]                     }, args = future.call.arguments)
[08:24:54.928]                   }
[08:24:54.928]                 }, immediateCondition = function(cond) {
[08:24:54.928]                   sendCondition <- ...future.makeSendCondition()
[08:24:54.928]                   sendCondition(cond)
[08:24:54.928]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.928]                   {
[08:24:54.928]                     inherits <- base::inherits
[08:24:54.928]                     invokeRestart <- base::invokeRestart
[08:24:54.928]                     is.null <- base::is.null
[08:24:54.928]                     muffled <- FALSE
[08:24:54.928]                     if (inherits(cond, "message")) {
[08:24:54.928]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:54.928]                       if (muffled) 
[08:24:54.928]                         invokeRestart("muffleMessage")
[08:24:54.928]                     }
[08:24:54.928]                     else if (inherits(cond, "warning")) {
[08:24:54.928]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:54.928]                       if (muffled) 
[08:24:54.928]                         invokeRestart("muffleWarning")
[08:24:54.928]                     }
[08:24:54.928]                     else if (inherits(cond, "condition")) {
[08:24:54.928]                       if (!is.null(pattern)) {
[08:24:54.928]                         computeRestarts <- base::computeRestarts
[08:24:54.928]                         grepl <- base::grepl
[08:24:54.928]                         restarts <- computeRestarts(cond)
[08:24:54.928]                         for (restart in restarts) {
[08:24:54.928]                           name <- restart$name
[08:24:54.928]                           if (is.null(name)) 
[08:24:54.928]                             next
[08:24:54.928]                           if (!grepl(pattern, name)) 
[08:24:54.928]                             next
[08:24:54.928]                           invokeRestart(restart)
[08:24:54.928]                           muffled <- TRUE
[08:24:54.928]                           break
[08:24:54.928]                         }
[08:24:54.928]                       }
[08:24:54.928]                     }
[08:24:54.928]                     invisible(muffled)
[08:24:54.928]                   }
[08:24:54.928]                   muffleCondition(cond)
[08:24:54.928]                 })
[08:24:54.928]             }))
[08:24:54.928]             future::FutureResult(value = ...future.value$value, 
[08:24:54.928]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.928]                   ...future.rng), globalenv = if (FALSE) 
[08:24:54.928]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:54.928]                     ...future.globalenv.names))
[08:24:54.928]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:54.928]         }, condition = base::local({
[08:24:54.928]             c <- base::c
[08:24:54.928]             inherits <- base::inherits
[08:24:54.928]             invokeRestart <- base::invokeRestart
[08:24:54.928]             length <- base::length
[08:24:54.928]             list <- base::list
[08:24:54.928]             seq.int <- base::seq.int
[08:24:54.928]             signalCondition <- base::signalCondition
[08:24:54.928]             sys.calls <- base::sys.calls
[08:24:54.928]             `[[` <- base::`[[`
[08:24:54.928]             `+` <- base::`+`
[08:24:54.928]             `<<-` <- base::`<<-`
[08:24:54.928]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:54.928]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:54.928]                   3L)]
[08:24:54.928]             }
[08:24:54.928]             function(cond) {
[08:24:54.928]                 is_error <- inherits(cond, "error")
[08:24:54.928]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:54.928]                   NULL)
[08:24:54.928]                 if (is_error) {
[08:24:54.928]                   sessionInformation <- function() {
[08:24:54.928]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:54.928]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:54.928]                       search = base::search(), system = base::Sys.info())
[08:24:54.928]                   }
[08:24:54.928]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.928]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:54.928]                     cond$call), session = sessionInformation(), 
[08:24:54.928]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:54.928]                   signalCondition(cond)
[08:24:54.928]                 }
[08:24:54.928]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:54.928]                 "immediateCondition"))) {
[08:24:54.928]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:54.928]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.928]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:54.928]                   if (TRUE && !signal) {
[08:24:54.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.928]                     {
[08:24:54.928]                       inherits <- base::inherits
[08:24:54.928]                       invokeRestart <- base::invokeRestart
[08:24:54.928]                       is.null <- base::is.null
[08:24:54.928]                       muffled <- FALSE
[08:24:54.928]                       if (inherits(cond, "message")) {
[08:24:54.928]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.928]                         if (muffled) 
[08:24:54.928]                           invokeRestart("muffleMessage")
[08:24:54.928]                       }
[08:24:54.928]                       else if (inherits(cond, "warning")) {
[08:24:54.928]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.928]                         if (muffled) 
[08:24:54.928]                           invokeRestart("muffleWarning")
[08:24:54.928]                       }
[08:24:54.928]                       else if (inherits(cond, "condition")) {
[08:24:54.928]                         if (!is.null(pattern)) {
[08:24:54.928]                           computeRestarts <- base::computeRestarts
[08:24:54.928]                           grepl <- base::grepl
[08:24:54.928]                           restarts <- computeRestarts(cond)
[08:24:54.928]                           for (restart in restarts) {
[08:24:54.928]                             name <- restart$name
[08:24:54.928]                             if (is.null(name)) 
[08:24:54.928]                               next
[08:24:54.928]                             if (!grepl(pattern, name)) 
[08:24:54.928]                               next
[08:24:54.928]                             invokeRestart(restart)
[08:24:54.928]                             muffled <- TRUE
[08:24:54.928]                             break
[08:24:54.928]                           }
[08:24:54.928]                         }
[08:24:54.928]                       }
[08:24:54.928]                       invisible(muffled)
[08:24:54.928]                     }
[08:24:54.928]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.928]                   }
[08:24:54.928]                 }
[08:24:54.928]                 else {
[08:24:54.928]                   if (TRUE) {
[08:24:54.928]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.928]                     {
[08:24:54.928]                       inherits <- base::inherits
[08:24:54.928]                       invokeRestart <- base::invokeRestart
[08:24:54.928]                       is.null <- base::is.null
[08:24:54.928]                       muffled <- FALSE
[08:24:54.928]                       if (inherits(cond, "message")) {
[08:24:54.928]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.928]                         if (muffled) 
[08:24:54.928]                           invokeRestart("muffleMessage")
[08:24:54.928]                       }
[08:24:54.928]                       else if (inherits(cond, "warning")) {
[08:24:54.928]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.928]                         if (muffled) 
[08:24:54.928]                           invokeRestart("muffleWarning")
[08:24:54.928]                       }
[08:24:54.928]                       else if (inherits(cond, "condition")) {
[08:24:54.928]                         if (!is.null(pattern)) {
[08:24:54.928]                           computeRestarts <- base::computeRestarts
[08:24:54.928]                           grepl <- base::grepl
[08:24:54.928]                           restarts <- computeRestarts(cond)
[08:24:54.928]                           for (restart in restarts) {
[08:24:54.928]                             name <- restart$name
[08:24:54.928]                             if (is.null(name)) 
[08:24:54.928]                               next
[08:24:54.928]                             if (!grepl(pattern, name)) 
[08:24:54.928]                               next
[08:24:54.928]                             invokeRestart(restart)
[08:24:54.928]                             muffled <- TRUE
[08:24:54.928]                             break
[08:24:54.928]                           }
[08:24:54.928]                         }
[08:24:54.928]                       }
[08:24:54.928]                       invisible(muffled)
[08:24:54.928]                     }
[08:24:54.928]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.928]                   }
[08:24:54.928]                 }
[08:24:54.928]             }
[08:24:54.928]         }))
[08:24:54.928]     }, error = function(ex) {
[08:24:54.928]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:54.928]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.928]                 ...future.rng), started = ...future.startTime, 
[08:24:54.928]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:54.928]             version = "1.8"), class = "FutureResult")
[08:24:54.928]     }, finally = {
[08:24:54.928]         if (!identical(...future.workdir, getwd())) 
[08:24:54.928]             setwd(...future.workdir)
[08:24:54.928]         {
[08:24:54.928]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:54.928]                 ...future.oldOptions$nwarnings <- NULL
[08:24:54.928]             }
[08:24:54.928]             base::options(...future.oldOptions)
[08:24:54.928]             if (.Platform$OS.type == "windows") {
[08:24:54.928]                 old_names <- names(...future.oldEnvVars)
[08:24:54.928]                 envs <- base::Sys.getenv()
[08:24:54.928]                 names <- names(envs)
[08:24:54.928]                 common <- intersect(names, old_names)
[08:24:54.928]                 added <- setdiff(names, old_names)
[08:24:54.928]                 removed <- setdiff(old_names, names)
[08:24:54.928]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:54.928]                   envs[common]]
[08:24:54.928]                 NAMES <- toupper(changed)
[08:24:54.928]                 args <- list()
[08:24:54.928]                 for (kk in seq_along(NAMES)) {
[08:24:54.928]                   name <- changed[[kk]]
[08:24:54.928]                   NAME <- NAMES[[kk]]
[08:24:54.928]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.928]                     next
[08:24:54.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.928]                 }
[08:24:54.928]                 NAMES <- toupper(added)
[08:24:54.928]                 for (kk in seq_along(NAMES)) {
[08:24:54.928]                   name <- added[[kk]]
[08:24:54.928]                   NAME <- NAMES[[kk]]
[08:24:54.928]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.928]                     next
[08:24:54.928]                   args[[name]] <- ""
[08:24:54.928]                 }
[08:24:54.928]                 NAMES <- toupper(removed)
[08:24:54.928]                 for (kk in seq_along(NAMES)) {
[08:24:54.928]                   name <- removed[[kk]]
[08:24:54.928]                   NAME <- NAMES[[kk]]
[08:24:54.928]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.928]                     next
[08:24:54.928]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.928]                 }
[08:24:54.928]                 if (length(args) > 0) 
[08:24:54.928]                   base::do.call(base::Sys.setenv, args = args)
[08:24:54.928]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:54.928]             }
[08:24:54.928]             else {
[08:24:54.928]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:54.928]             }
[08:24:54.928]             {
[08:24:54.928]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:54.928]                   0L) {
[08:24:54.928]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:54.928]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:54.928]                   base::options(opts)
[08:24:54.928]                 }
[08:24:54.928]                 {
[08:24:54.928]                   {
[08:24:54.928]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:54.928]                     NULL
[08:24:54.928]                   }
[08:24:54.928]                   options(future.plan = NULL)
[08:24:54.928]                   if (is.na(NA_character_)) 
[08:24:54.928]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.928]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:54.928]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:54.928]                     .init = FALSE)
[08:24:54.928]                 }
[08:24:54.928]             }
[08:24:54.928]         }
[08:24:54.928]     })
[08:24:54.928]     if (TRUE) {
[08:24:54.928]         base::sink(type = "output", split = FALSE)
[08:24:54.928]         if (TRUE) {
[08:24:54.928]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:54.928]         }
[08:24:54.928]         else {
[08:24:54.928]             ...future.result["stdout"] <- base::list(NULL)
[08:24:54.928]         }
[08:24:54.928]         base::close(...future.stdout)
[08:24:54.928]         ...future.stdout <- NULL
[08:24:54.928]     }
[08:24:54.928]     ...future.result$conditions <- ...future.conditions
[08:24:54.928]     ...future.result$finished <- base::Sys.time()
[08:24:54.928]     ...future.result
[08:24:54.928] }
[08:24:54.931] Exporting 5 global objects (914 bytes) to cluster node #1 ...
[08:24:54.931] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:54.932] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:54.932] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[08:24:54.932] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[08:24:54.932] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ...
[08:24:54.933] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ... DONE
[08:24:54.933] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:54.933] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:54.933] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:54.934] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:54.934] Exporting 5 global objects (914 bytes) to cluster node #1 ... DONE
[08:24:54.934] MultisessionFuture started
[08:24:54.934] - Launch lazy future ... done
[08:24:54.934] run() for ‘MultisessionFuture’ ... done
[08:24:54.934] Created future:
[08:24:54.935] MultisessionFuture:
[08:24:54.935] Label: ‘future_apply-1’
[08:24:54.935] Expression:
[08:24:54.935] {
[08:24:54.935]     do.call(function(...) {
[08:24:54.935]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.935]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.935]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.935]             on.exit(options(oopts), add = TRUE)
[08:24:54.935]         }
[08:24:54.935]         {
[08:24:54.935]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.935]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.935]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.935]             })
[08:24:54.935]         }
[08:24:54.935]     }, args = future.call.arguments)
[08:24:54.935] }
[08:24:54.935] Lazy evaluation: FALSE
[08:24:54.935] Asynchronous evaluation: TRUE
[08:24:54.935] Local evaluation: TRUE
[08:24:54.935] Environment: R_GlobalEnv
[08:24:54.935] Capture standard output: TRUE
[08:24:54.935] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:54.935] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:54.935] Packages: <none>
[08:24:54.935] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:54.935] Resolved: FALSE
[08:24:54.935] Value: <not collected>
[08:24:54.935] Conditions captured: <none>
[08:24:54.935] Early signaling: FALSE
[08:24:54.935] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:54.935] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.946] Chunk #1 of 2 ... DONE
[08:24:54.946] Chunk #2 of 2 ...
[08:24:54.946]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:54.946]  - seeds: <none>
[08:24:54.946]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.947] getGlobalsAndPackages() ...
[08:24:54.947] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.947] Resolving globals: FALSE
[08:24:54.947] Tweak future expression to call with '...' arguments ...
[08:24:54.947] {
[08:24:54.947]     do.call(function(...) {
[08:24:54.947]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.947]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.947]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.947]             on.exit(options(oopts), add = TRUE)
[08:24:54.947]         }
[08:24:54.947]         {
[08:24:54.947]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.947]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.947]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.947]             })
[08:24:54.947]         }
[08:24:54.947]     }, args = future.call.arguments)
[08:24:54.947] }
[08:24:54.947] Tweak future expression to call with '...' arguments ... DONE
[08:24:54.948] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:54.948] 
[08:24:54.948] getGlobalsAndPackages() ... DONE
[08:24:54.948] run() for ‘Future’ ...
[08:24:54.948] - state: ‘created’
[08:24:54.948] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:54.962] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.962] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:54.963]   - Field: ‘node’
[08:24:54.963]   - Field: ‘label’
[08:24:54.963]   - Field: ‘local’
[08:24:54.963]   - Field: ‘owner’
[08:24:54.963]   - Field: ‘envir’
[08:24:54.963]   - Field: ‘workers’
[08:24:54.963]   - Field: ‘packages’
[08:24:54.963]   - Field: ‘gc’
[08:24:54.963]   - Field: ‘conditions’
[08:24:54.963]   - Field: ‘persistent’
[08:24:54.964]   - Field: ‘expr’
[08:24:54.964]   - Field: ‘uuid’
[08:24:54.964]   - Field: ‘seed’
[08:24:54.964]   - Field: ‘version’
[08:24:54.964]   - Field: ‘result’
[08:24:54.964]   - Field: ‘asynchronous’
[08:24:54.964]   - Field: ‘calls’
[08:24:54.964]   - Field: ‘globals’
[08:24:54.964]   - Field: ‘stdout’
[08:24:54.964]   - Field: ‘earlySignal’
[08:24:54.964]   - Field: ‘lazy’
[08:24:54.964]   - Field: ‘state’
[08:24:54.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:54.965] - Launch lazy future ...
[08:24:54.965] Packages needed by the future expression (n = 0): <none>
[08:24:54.965] Packages needed by future strategies (n = 0): <none>
[08:24:54.965] {
[08:24:54.965]     {
[08:24:54.965]         {
[08:24:54.965]             ...future.startTime <- base::Sys.time()
[08:24:54.965]             {
[08:24:54.965]                 {
[08:24:54.965]                   {
[08:24:54.965]                     {
[08:24:54.965]                       base::local({
[08:24:54.965]                         has_future <- base::requireNamespace("future", 
[08:24:54.965]                           quietly = TRUE)
[08:24:54.965]                         if (has_future) {
[08:24:54.965]                           ns <- base::getNamespace("future")
[08:24:54.965]                           version <- ns[[".package"]][["version"]]
[08:24:54.965]                           if (is.null(version)) 
[08:24:54.965]                             version <- utils::packageVersion("future")
[08:24:54.965]                         }
[08:24:54.965]                         else {
[08:24:54.965]                           version <- NULL
[08:24:54.965]                         }
[08:24:54.965]                         if (!has_future || version < "1.8.0") {
[08:24:54.965]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:54.965]                             "", base::R.version$version.string), 
[08:24:54.965]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:54.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:54.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:54.965]                               "release", "version")], collapse = " "), 
[08:24:54.965]                             hostname = base::Sys.info()[["nodename"]])
[08:24:54.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:54.965]                             info)
[08:24:54.965]                           info <- base::paste(info, collapse = "; ")
[08:24:54.965]                           if (!has_future) {
[08:24:54.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:54.965]                               info)
[08:24:54.965]                           }
[08:24:54.965]                           else {
[08:24:54.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:54.965]                               info, version)
[08:24:54.965]                           }
[08:24:54.965]                           base::stop(msg)
[08:24:54.965]                         }
[08:24:54.965]                       })
[08:24:54.965]                     }
[08:24:54.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:54.965]                     base::options(mc.cores = 1L)
[08:24:54.965]                   }
[08:24:54.965]                   ...future.strategy.old <- future::plan("list")
[08:24:54.965]                   options(future.plan = NULL)
[08:24:54.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:54.965]                 }
[08:24:54.965]                 ...future.workdir <- getwd()
[08:24:54.965]             }
[08:24:54.965]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:54.965]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:54.965]         }
[08:24:54.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:54.965]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:54.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:54.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:54.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:54.965]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:54.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:54.965]             base::names(...future.oldOptions))
[08:24:54.965]     }
[08:24:54.965]     if (FALSE) {
[08:24:54.965]     }
[08:24:54.965]     else {
[08:24:54.965]         if (TRUE) {
[08:24:54.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:54.965]                 open = "w")
[08:24:54.965]         }
[08:24:54.965]         else {
[08:24:54.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:54.965]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:54.965]         }
[08:24:54.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:54.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:54.965]             base::sink(type = "output", split = FALSE)
[08:24:54.965]             base::close(...future.stdout)
[08:24:54.965]         }, add = TRUE)
[08:24:54.965]     }
[08:24:54.965]     ...future.frame <- base::sys.nframe()
[08:24:54.965]     ...future.conditions <- base::list()
[08:24:54.965]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:54.965]     if (FALSE) {
[08:24:54.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:54.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:54.965]     }
[08:24:54.965]     ...future.result <- base::tryCatch({
[08:24:54.965]         base::withCallingHandlers({
[08:24:54.965]             ...future.value <- base::withVisible(base::local({
[08:24:54.965]                 ...future.makeSendCondition <- base::local({
[08:24:54.965]                   sendCondition <- NULL
[08:24:54.965]                   function(frame = 1L) {
[08:24:54.965]                     if (is.function(sendCondition)) 
[08:24:54.965]                       return(sendCondition)
[08:24:54.965]                     ns <- getNamespace("parallel")
[08:24:54.965]                     if (exists("sendData", mode = "function", 
[08:24:54.965]                       envir = ns)) {
[08:24:54.965]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:54.965]                         envir = ns)
[08:24:54.965]                       envir <- sys.frame(frame)
[08:24:54.965]                       master <- NULL
[08:24:54.965]                       while (!identical(envir, .GlobalEnv) && 
[08:24:54.965]                         !identical(envir, emptyenv())) {
[08:24:54.965]                         if (exists("master", mode = "list", envir = envir, 
[08:24:54.965]                           inherits = FALSE)) {
[08:24:54.965]                           master <- get("master", mode = "list", 
[08:24:54.965]                             envir = envir, inherits = FALSE)
[08:24:54.965]                           if (inherits(master, c("SOCKnode", 
[08:24:54.965]                             "SOCK0node"))) {
[08:24:54.965]                             sendCondition <<- function(cond) {
[08:24:54.965]                               data <- list(type = "VALUE", value = cond, 
[08:24:54.965]                                 success = TRUE)
[08:24:54.965]                               parallel_sendData(master, data)
[08:24:54.965]                             }
[08:24:54.965]                             return(sendCondition)
[08:24:54.965]                           }
[08:24:54.965]                         }
[08:24:54.965]                         frame <- frame + 1L
[08:24:54.965]                         envir <- sys.frame(frame)
[08:24:54.965]                       }
[08:24:54.965]                     }
[08:24:54.965]                     sendCondition <<- function(cond) NULL
[08:24:54.965]                   }
[08:24:54.965]                 })
[08:24:54.965]                 withCallingHandlers({
[08:24:54.965]                   {
[08:24:54.965]                     do.call(function(...) {
[08:24:54.965]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.965]                       if (!identical(...future.globals.maxSize.org, 
[08:24:54.965]                         ...future.globals.maxSize)) {
[08:24:54.965]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.965]                         on.exit(options(oopts), add = TRUE)
[08:24:54.965]                       }
[08:24:54.965]                       {
[08:24:54.965]                         lapply(seq_along(...future.elements_ii), 
[08:24:54.965]                           FUN = function(jj) {
[08:24:54.965]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.965]                             ...future.FUN(...future.X_jj, ...)
[08:24:54.965]                           })
[08:24:54.965]                       }
[08:24:54.965]                     }, args = future.call.arguments)
[08:24:54.965]                   }
[08:24:54.965]                 }, immediateCondition = function(cond) {
[08:24:54.965]                   sendCondition <- ...future.makeSendCondition()
[08:24:54.965]                   sendCondition(cond)
[08:24:54.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.965]                   {
[08:24:54.965]                     inherits <- base::inherits
[08:24:54.965]                     invokeRestart <- base::invokeRestart
[08:24:54.965]                     is.null <- base::is.null
[08:24:54.965]                     muffled <- FALSE
[08:24:54.965]                     if (inherits(cond, "message")) {
[08:24:54.965]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:54.965]                       if (muffled) 
[08:24:54.965]                         invokeRestart("muffleMessage")
[08:24:54.965]                     }
[08:24:54.965]                     else if (inherits(cond, "warning")) {
[08:24:54.965]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:54.965]                       if (muffled) 
[08:24:54.965]                         invokeRestart("muffleWarning")
[08:24:54.965]                     }
[08:24:54.965]                     else if (inherits(cond, "condition")) {
[08:24:54.965]                       if (!is.null(pattern)) {
[08:24:54.965]                         computeRestarts <- base::computeRestarts
[08:24:54.965]                         grepl <- base::grepl
[08:24:54.965]                         restarts <- computeRestarts(cond)
[08:24:54.965]                         for (restart in restarts) {
[08:24:54.965]                           name <- restart$name
[08:24:54.965]                           if (is.null(name)) 
[08:24:54.965]                             next
[08:24:54.965]                           if (!grepl(pattern, name)) 
[08:24:54.965]                             next
[08:24:54.965]                           invokeRestart(restart)
[08:24:54.965]                           muffled <- TRUE
[08:24:54.965]                           break
[08:24:54.965]                         }
[08:24:54.965]                       }
[08:24:54.965]                     }
[08:24:54.965]                     invisible(muffled)
[08:24:54.965]                   }
[08:24:54.965]                   muffleCondition(cond)
[08:24:54.965]                 })
[08:24:54.965]             }))
[08:24:54.965]             future::FutureResult(value = ...future.value$value, 
[08:24:54.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.965]                   ...future.rng), globalenv = if (FALSE) 
[08:24:54.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:54.965]                     ...future.globalenv.names))
[08:24:54.965]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:54.965]         }, condition = base::local({
[08:24:54.965]             c <- base::c
[08:24:54.965]             inherits <- base::inherits
[08:24:54.965]             invokeRestart <- base::invokeRestart
[08:24:54.965]             length <- base::length
[08:24:54.965]             list <- base::list
[08:24:54.965]             seq.int <- base::seq.int
[08:24:54.965]             signalCondition <- base::signalCondition
[08:24:54.965]             sys.calls <- base::sys.calls
[08:24:54.965]             `[[` <- base::`[[`
[08:24:54.965]             `+` <- base::`+`
[08:24:54.965]             `<<-` <- base::`<<-`
[08:24:54.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:54.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:54.965]                   3L)]
[08:24:54.965]             }
[08:24:54.965]             function(cond) {
[08:24:54.965]                 is_error <- inherits(cond, "error")
[08:24:54.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:54.965]                   NULL)
[08:24:54.965]                 if (is_error) {
[08:24:54.965]                   sessionInformation <- function() {
[08:24:54.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:54.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:54.965]                       search = base::search(), system = base::Sys.info())
[08:24:54.965]                   }
[08:24:54.965]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:54.965]                     cond$call), session = sessionInformation(), 
[08:24:54.965]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:54.965]                   signalCondition(cond)
[08:24:54.965]                 }
[08:24:54.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:54.965]                 "immediateCondition"))) {
[08:24:54.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:54.965]                   ...future.conditions[[length(...future.conditions) + 
[08:24:54.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:54.965]                   if (TRUE && !signal) {
[08:24:54.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.965]                     {
[08:24:54.965]                       inherits <- base::inherits
[08:24:54.965]                       invokeRestart <- base::invokeRestart
[08:24:54.965]                       is.null <- base::is.null
[08:24:54.965]                       muffled <- FALSE
[08:24:54.965]                       if (inherits(cond, "message")) {
[08:24:54.965]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.965]                         if (muffled) 
[08:24:54.965]                           invokeRestart("muffleMessage")
[08:24:54.965]                       }
[08:24:54.965]                       else if (inherits(cond, "warning")) {
[08:24:54.965]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.965]                         if (muffled) 
[08:24:54.965]                           invokeRestart("muffleWarning")
[08:24:54.965]                       }
[08:24:54.965]                       else if (inherits(cond, "condition")) {
[08:24:54.965]                         if (!is.null(pattern)) {
[08:24:54.965]                           computeRestarts <- base::computeRestarts
[08:24:54.965]                           grepl <- base::grepl
[08:24:54.965]                           restarts <- computeRestarts(cond)
[08:24:54.965]                           for (restart in restarts) {
[08:24:54.965]                             name <- restart$name
[08:24:54.965]                             if (is.null(name)) 
[08:24:54.965]                               next
[08:24:54.965]                             if (!grepl(pattern, name)) 
[08:24:54.965]                               next
[08:24:54.965]                             invokeRestart(restart)
[08:24:54.965]                             muffled <- TRUE
[08:24:54.965]                             break
[08:24:54.965]                           }
[08:24:54.965]                         }
[08:24:54.965]                       }
[08:24:54.965]                       invisible(muffled)
[08:24:54.965]                     }
[08:24:54.965]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.965]                   }
[08:24:54.965]                 }
[08:24:54.965]                 else {
[08:24:54.965]                   if (TRUE) {
[08:24:54.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:54.965]                     {
[08:24:54.965]                       inherits <- base::inherits
[08:24:54.965]                       invokeRestart <- base::invokeRestart
[08:24:54.965]                       is.null <- base::is.null
[08:24:54.965]                       muffled <- FALSE
[08:24:54.965]                       if (inherits(cond, "message")) {
[08:24:54.965]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:54.965]                         if (muffled) 
[08:24:54.965]                           invokeRestart("muffleMessage")
[08:24:54.965]                       }
[08:24:54.965]                       else if (inherits(cond, "warning")) {
[08:24:54.965]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:54.965]                         if (muffled) 
[08:24:54.965]                           invokeRestart("muffleWarning")
[08:24:54.965]                       }
[08:24:54.965]                       else if (inherits(cond, "condition")) {
[08:24:54.965]                         if (!is.null(pattern)) {
[08:24:54.965]                           computeRestarts <- base::computeRestarts
[08:24:54.965]                           grepl <- base::grepl
[08:24:54.965]                           restarts <- computeRestarts(cond)
[08:24:54.965]                           for (restart in restarts) {
[08:24:54.965]                             name <- restart$name
[08:24:54.965]                             if (is.null(name)) 
[08:24:54.965]                               next
[08:24:54.965]                             if (!grepl(pattern, name)) 
[08:24:54.965]                               next
[08:24:54.965]                             invokeRestart(restart)
[08:24:54.965]                             muffled <- TRUE
[08:24:54.965]                             break
[08:24:54.965]                           }
[08:24:54.965]                         }
[08:24:54.965]                       }
[08:24:54.965]                       invisible(muffled)
[08:24:54.965]                     }
[08:24:54.965]                     muffleCondition(cond, pattern = "^muffle")
[08:24:54.965]                   }
[08:24:54.965]                 }
[08:24:54.965]             }
[08:24:54.965]         }))
[08:24:54.965]     }, error = function(ex) {
[08:24:54.965]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:54.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:54.965]                 ...future.rng), started = ...future.startTime, 
[08:24:54.965]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:54.965]             version = "1.8"), class = "FutureResult")
[08:24:54.965]     }, finally = {
[08:24:54.965]         if (!identical(...future.workdir, getwd())) 
[08:24:54.965]             setwd(...future.workdir)
[08:24:54.965]         {
[08:24:54.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:54.965]                 ...future.oldOptions$nwarnings <- NULL
[08:24:54.965]             }
[08:24:54.965]             base::options(...future.oldOptions)
[08:24:54.965]             if (.Platform$OS.type == "windows") {
[08:24:54.965]                 old_names <- names(...future.oldEnvVars)
[08:24:54.965]                 envs <- base::Sys.getenv()
[08:24:54.965]                 names <- names(envs)
[08:24:54.965]                 common <- intersect(names, old_names)
[08:24:54.965]                 added <- setdiff(names, old_names)
[08:24:54.965]                 removed <- setdiff(old_names, names)
[08:24:54.965]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:54.965]                   envs[common]]
[08:24:54.965]                 NAMES <- toupper(changed)
[08:24:54.965]                 args <- list()
[08:24:54.965]                 for (kk in seq_along(NAMES)) {
[08:24:54.965]                   name <- changed[[kk]]
[08:24:54.965]                   NAME <- NAMES[[kk]]
[08:24:54.965]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.965]                     next
[08:24:54.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.965]                 }
[08:24:54.965]                 NAMES <- toupper(added)
[08:24:54.965]                 for (kk in seq_along(NAMES)) {
[08:24:54.965]                   name <- added[[kk]]
[08:24:54.965]                   NAME <- NAMES[[kk]]
[08:24:54.965]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.965]                     next
[08:24:54.965]                   args[[name]] <- ""
[08:24:54.965]                 }
[08:24:54.965]                 NAMES <- toupper(removed)
[08:24:54.965]                 for (kk in seq_along(NAMES)) {
[08:24:54.965]                   name <- removed[[kk]]
[08:24:54.965]                   NAME <- NAMES[[kk]]
[08:24:54.965]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:54.965]                     next
[08:24:54.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:54.965]                 }
[08:24:54.965]                 if (length(args) > 0) 
[08:24:54.965]                   base::do.call(base::Sys.setenv, args = args)
[08:24:54.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:54.965]             }
[08:24:54.965]             else {
[08:24:54.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:54.965]             }
[08:24:54.965]             {
[08:24:54.965]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:54.965]                   0L) {
[08:24:54.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:54.965]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:54.965]                   base::options(opts)
[08:24:54.965]                 }
[08:24:54.965]                 {
[08:24:54.965]                   {
[08:24:54.965]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:54.965]                     NULL
[08:24:54.965]                   }
[08:24:54.965]                   options(future.plan = NULL)
[08:24:54.965]                   if (is.na(NA_character_)) 
[08:24:54.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:54.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:54.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:54.965]                     .init = FALSE)
[08:24:54.965]                 }
[08:24:54.965]             }
[08:24:54.965]         }
[08:24:54.965]     })
[08:24:54.965]     if (TRUE) {
[08:24:54.965]         base::sink(type = "output", split = FALSE)
[08:24:54.965]         if (TRUE) {
[08:24:54.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:54.965]         }
[08:24:54.965]         else {
[08:24:54.965]             ...future.result["stdout"] <- base::list(NULL)
[08:24:54.965]         }
[08:24:54.965]         base::close(...future.stdout)
[08:24:54.965]         ...future.stdout <- NULL
[08:24:54.965]     }
[08:24:54.965]     ...future.result$conditions <- ...future.conditions
[08:24:54.965]     ...future.result$finished <- base::Sys.time()
[08:24:54.965]     ...future.result
[08:24:54.965] }
[08:24:54.968] Exporting 5 global objects (914 bytes) to cluster node #2 ...
[08:24:54.969] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:54.969] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:54.969] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[08:24:54.969] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[08:24:54.970] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ...
[08:24:54.970] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ... DONE
[08:24:54.970] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:54.971] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:54.971] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:54.971] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:54.971] Exporting 5 global objects (914 bytes) to cluster node #2 ... DONE
[08:24:54.972] MultisessionFuture started
[08:24:54.972] - Launch lazy future ... done
[08:24:54.972] run() for ‘MultisessionFuture’ ... done
[08:24:54.972] Created future:
[08:24:54.972] MultisessionFuture:
[08:24:54.972] Label: ‘future_apply-2’
[08:24:54.972] Expression:
[08:24:54.972] {
[08:24:54.972]     do.call(function(...) {
[08:24:54.972]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:54.972]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:54.972]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:54.972]             on.exit(options(oopts), add = TRUE)
[08:24:54.972]         }
[08:24:54.972]         {
[08:24:54.972]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:54.972]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:54.972]                 ...future.FUN(...future.X_jj, ...)
[08:24:54.972]             })
[08:24:54.972]         }
[08:24:54.972]     }, args = future.call.arguments)
[08:24:54.972] }
[08:24:54.972] Lazy evaluation: FALSE
[08:24:54.972] Asynchronous evaluation: TRUE
[08:24:54.972] Local evaluation: TRUE
[08:24:54.972] Environment: R_GlobalEnv
[08:24:54.972] Capture standard output: TRUE
[08:24:54.972] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:54.972] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:54.972] Packages: <none>
[08:24:54.972] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:54.972] Resolved: FALSE
[08:24:54.972] Value: <not collected>
[08:24:54.972] Conditions captured: <none>
[08:24:54.972] Early signaling: FALSE
[08:24:54.972] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:54.972] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:54.983] Chunk #2 of 2 ... DONE
[08:24:54.984] Launching 2 futures (chunks) ... DONE
[08:24:54.984] Resolving 2 futures (chunks) ...
[08:24:54.984] resolve() on list ...
[08:24:54.984]  recursive: 0
[08:24:54.984]  length: 2
[08:24:54.984] 
[08:24:54.985] receiveMessageFromWorker() for ClusterFuture ...
[08:24:54.985] - Validating connection of MultisessionFuture
[08:24:54.985] - received message: FutureResult
[08:24:54.985] - Received FutureResult
[08:24:54.985] - Erased future from FutureRegistry
[08:24:54.985] result() for ClusterFuture ...
[08:24:54.985] - result already collected: FutureResult
[08:24:54.985] result() for ClusterFuture ... done
[08:24:54.985] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:54.986] Future #1
[08:24:54.986] result() for ClusterFuture ...
[08:24:54.986] - result already collected: FutureResult
[08:24:54.986] result() for ClusterFuture ... done
[08:24:54.986] result() for ClusterFuture ...
[08:24:54.986] - result already collected: FutureResult
[08:24:54.986] result() for ClusterFuture ... done
[08:24:54.986] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:54.986] - nx: 2
[08:24:54.986] - relay: TRUE
[08:24:54.986] - stdout: TRUE
[08:24:54.987] - signal: TRUE
[08:24:54.987] - resignal: FALSE
[08:24:54.987] - force: TRUE
[08:24:54.987] - relayed: [n=2] FALSE, FALSE
[08:24:54.987] - queued futures: [n=2] FALSE, FALSE
[08:24:54.987]  - until=1
[08:24:54.987]  - relaying element #1
[08:24:54.987] result() for ClusterFuture ...
[08:24:54.987] - result already collected: FutureResult
[08:24:54.987] result() for ClusterFuture ... done
[08:24:54.987] result() for ClusterFuture ...
[08:24:54.987] - result already collected: FutureResult
[08:24:54.987] result() for ClusterFuture ... done
[08:24:54.988] result() for ClusterFuture ...
[08:24:54.988] - result already collected: FutureResult
[08:24:54.988] result() for ClusterFuture ... done
[08:24:54.988] result() for ClusterFuture ...
[08:24:54.988] - result already collected: FutureResult
[08:24:54.988] result() for ClusterFuture ... done
[08:24:54.988] - relayed: [n=2] TRUE, FALSE
[08:24:54.988] - queued futures: [n=2] TRUE, FALSE
[08:24:54.988] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:54.988]  length: 1 (resolved future 1)
[08:24:55.014] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.014] - Validating connection of MultisessionFuture
[08:24:55.015] - received message: FutureResult
[08:24:55.015] - Received FutureResult
[08:24:55.015] - Erased future from FutureRegistry
[08:24:55.015] result() for ClusterFuture ...
[08:24:55.015] - result already collected: FutureResult
[08:24:55.015] result() for ClusterFuture ... done
[08:24:55.015] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.015] Future #2
[08:24:55.016] result() for ClusterFuture ...
[08:24:55.016] - result already collected: FutureResult
[08:24:55.016] result() for ClusterFuture ... done
[08:24:55.016] result() for ClusterFuture ...
[08:24:55.016] - result already collected: FutureResult
[08:24:55.016] result() for ClusterFuture ... done
[08:24:55.016] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:55.016] - nx: 2
[08:24:55.016] - relay: TRUE
[08:24:55.016] - stdout: TRUE
[08:24:55.016] - signal: TRUE
[08:24:55.016] - resignal: FALSE
[08:24:55.017] - force: TRUE
[08:24:55.017] - relayed: [n=2] TRUE, FALSE
[08:24:55.017] - queued futures: [n=2] TRUE, FALSE
[08:24:55.017]  - until=2
[08:24:55.017]  - relaying element #2
[08:24:55.017] result() for ClusterFuture ...
[08:24:55.017] - result already collected: FutureResult
[08:24:55.017] result() for ClusterFuture ... done
[08:24:55.017] result() for ClusterFuture ...
[08:24:55.017] - result already collected: FutureResult
[08:24:55.017] result() for ClusterFuture ... done
[08:24:55.017] result() for ClusterFuture ...
[08:24:55.018] - result already collected: FutureResult
[08:24:55.018] result() for ClusterFuture ... done
[08:24:55.018] result() for ClusterFuture ...
[08:24:55.018] - result already collected: FutureResult
[08:24:55.018] result() for ClusterFuture ... done
[08:24:55.018] - relayed: [n=2] TRUE, TRUE
[08:24:55.018] - queued futures: [n=2] TRUE, TRUE
[08:24:55.018] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:55.018]  length: 0 (resolved future 2)
[08:24:55.018] Relaying remaining futures
[08:24:55.018] signalConditionsASAP(NULL, pos=0) ...
[08:24:55.018] - nx: 2
[08:24:55.019] - relay: TRUE
[08:24:55.019] - stdout: TRUE
[08:24:55.019] - signal: TRUE
[08:24:55.019] - resignal: FALSE
[08:24:55.019] - force: TRUE
[08:24:55.019] - relayed: [n=2] TRUE, TRUE
[08:24:55.019] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:55.019] - relayed: [n=2] TRUE, TRUE
[08:24:55.019] - queued futures: [n=2] TRUE, TRUE
[08:24:55.019] signalConditionsASAP(NULL, pos=0) ... done
[08:24:55.019] resolve() on list ... DONE
[08:24:55.020] result() for ClusterFuture ...
[08:24:55.020] - result already collected: FutureResult
[08:24:55.020] result() for ClusterFuture ... done
[08:24:55.020] result() for ClusterFuture ...
[08:24:55.020] - result already collected: FutureResult
[08:24:55.020] result() for ClusterFuture ... done
[08:24:55.022] result() for ClusterFuture ...
[08:24:55.023] - result already collected: FutureResult
[08:24:55.023] result() for ClusterFuture ... done
[08:24:55.023] result() for ClusterFuture ...
[08:24:55.023] - result already collected: FutureResult
[08:24:55.023] result() for ClusterFuture ... done
[08:24:55.023]  - Number of value chunks collected: 2
[08:24:55.023] Resolving 2 futures (chunks) ... DONE
[08:24:55.023] Reducing values from 2 chunks ...
[08:24:55.023]  - Number of values collected after concatenation: 2
[08:24:55.023]  - Number of values expected: 2
[08:24:55.023] Reducing values from 2 chunks ... DONE
[08:24:55.023] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[08:24:55.024] getGlobalsAndPackagesXApply() ...
[08:24:55.024]  - future.globals: TRUE
[08:24:55.024] getGlobalsAndPackages() ...
[08:24:55.024] Searching for globals...
[08:24:55.025] - globals found: [1] ‘FUN’
[08:24:55.025] Searching for globals ... DONE
[08:24:55.026] Resolving globals: FALSE
[08:24:55.026] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:55.026] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:55.026] - globals: [1] ‘FUN’
[08:24:55.026] 
[08:24:55.027] getGlobalsAndPackages() ... DONE
[08:24:55.027]  - globals found/used: [n=1] ‘FUN’
[08:24:55.027]  - needed namespaces: [n=0] 
[08:24:55.027] Finding globals ... DONE
[08:24:55.027]  - use_args: TRUE
[08:24:55.027]  - Getting '...' globals ...
[08:24:55.027] resolve() on list ...
[08:24:55.027]  recursive: 0
[08:24:55.027]  length: 1
[08:24:55.028]  elements: ‘...’
[08:24:55.028]  length: 0 (resolved future 1)
[08:24:55.028] resolve() on list ... DONE
[08:24:55.028]    - '...' content: [n=0] 
[08:24:55.028] List of 1
[08:24:55.028]  $ ...: list()
[08:24:55.028]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.028]  - attr(*, "where")=List of 1
[08:24:55.028]   ..$ ...:<environment: 0x56540e9ea880> 
[08:24:55.028]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.028]  - attr(*, "resolved")= logi TRUE
[08:24:55.028]  - attr(*, "total_size")= num NA
[08:24:55.030]  - Getting '...' globals ... DONE
[08:24:55.031] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:55.031] List of 2
[08:24:55.031]  $ ...future.FUN:function (x)  
[08:24:55.031]  $ ...          : list()
[08:24:55.031]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.031]  - attr(*, "where")=List of 2
[08:24:55.031]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:55.031]   ..$ ...          :<environment: 0x56540e9ea880> 
[08:24:55.031]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.031]  - attr(*, "resolved")= logi FALSE
[08:24:55.031]  - attr(*, "total_size")= num 3563
[08:24:55.033] Packages to be attached in all futures: [n=0] 
[08:24:55.033] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.035] future_lapply() ...
[08:24:55.037] Number of chunks: 2
[08:24:55.037] getGlobalsAndPackagesXApply() ...
[08:24:55.037]  - future.globals: <name-value list> with names ‘list()’
[08:24:55.037]  - use_args: TRUE
[08:24:55.037] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:55.037] List of 2
[08:24:55.037]  $ ...          : list()
[08:24:55.037]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.037]  $ ...future.FUN:function (x)  
[08:24:55.037]  - attr(*, "where")=List of 2
[08:24:55.037]   ..$ ...          :<environment: 0x56540e9ea880> 
[08:24:55.037]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:55.037]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.037]  - attr(*, "resolved")= logi FALSE
[08:24:55.037]  - attr(*, "total_size")= num NA
[08:24:55.041] Packages to be attached in all futures: [n=0] 
[08:24:55.041] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.041] Number of futures (= number of chunks): 2
[08:24:55.041] Launching 2 futures (chunks) ...
[08:24:55.041] Chunk #1 of 2 ...
[08:24:55.042]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.042]  - seeds: <none>
[08:24:55.042]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.042] getGlobalsAndPackages() ...
[08:24:55.042] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.042] Resolving globals: FALSE
[08:24:55.042] Tweak future expression to call with '...' arguments ...
[08:24:55.042] {
[08:24:55.042]     do.call(function(...) {
[08:24:55.042]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.042]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.042]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.042]             on.exit(options(oopts), add = TRUE)
[08:24:55.042]         }
[08:24:55.042]         {
[08:24:55.042]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.042]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.042]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.042]             })
[08:24:55.042]         }
[08:24:55.042]     }, args = future.call.arguments)
[08:24:55.042] }
[08:24:55.043] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.043] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.043] 
[08:24:55.043] getGlobalsAndPackages() ... DONE
[08:24:55.043] run() for ‘Future’ ...
[08:24:55.043] - state: ‘created’
[08:24:55.044] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.059] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.059]   - Field: ‘node’
[08:24:55.059]   - Field: ‘label’
[08:24:55.059]   - Field: ‘local’
[08:24:55.059]   - Field: ‘owner’
[08:24:55.059]   - Field: ‘envir’
[08:24:55.059]   - Field: ‘workers’
[08:24:55.060]   - Field: ‘packages’
[08:24:55.060]   - Field: ‘gc’
[08:24:55.060]   - Field: ‘conditions’
[08:24:55.060]   - Field: ‘persistent’
[08:24:55.060]   - Field: ‘expr’
[08:24:55.060]   - Field: ‘uuid’
[08:24:55.060]   - Field: ‘seed’
[08:24:55.060]   - Field: ‘version’
[08:24:55.060]   - Field: ‘result’
[08:24:55.060]   - Field: ‘asynchronous’
[08:24:55.060]   - Field: ‘calls’
[08:24:55.061]   - Field: ‘globals’
[08:24:55.061]   - Field: ‘stdout’
[08:24:55.061]   - Field: ‘earlySignal’
[08:24:55.061]   - Field: ‘lazy’
[08:24:55.061]   - Field: ‘state’
[08:24:55.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.061] - Launch lazy future ...
[08:24:55.061] Packages needed by the future expression (n = 0): <none>
[08:24:55.061] Packages needed by future strategies (n = 0): <none>
[08:24:55.062] {
[08:24:55.062]     {
[08:24:55.062]         {
[08:24:55.062]             ...future.startTime <- base::Sys.time()
[08:24:55.062]             {
[08:24:55.062]                 {
[08:24:55.062]                   {
[08:24:55.062]                     {
[08:24:55.062]                       base::local({
[08:24:55.062]                         has_future <- base::requireNamespace("future", 
[08:24:55.062]                           quietly = TRUE)
[08:24:55.062]                         if (has_future) {
[08:24:55.062]                           ns <- base::getNamespace("future")
[08:24:55.062]                           version <- ns[[".package"]][["version"]]
[08:24:55.062]                           if (is.null(version)) 
[08:24:55.062]                             version <- utils::packageVersion("future")
[08:24:55.062]                         }
[08:24:55.062]                         else {
[08:24:55.062]                           version <- NULL
[08:24:55.062]                         }
[08:24:55.062]                         if (!has_future || version < "1.8.0") {
[08:24:55.062]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.062]                             "", base::R.version$version.string), 
[08:24:55.062]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.062]                               "release", "version")], collapse = " "), 
[08:24:55.062]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.062]                             info)
[08:24:55.062]                           info <- base::paste(info, collapse = "; ")
[08:24:55.062]                           if (!has_future) {
[08:24:55.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.062]                               info)
[08:24:55.062]                           }
[08:24:55.062]                           else {
[08:24:55.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.062]                               info, version)
[08:24:55.062]                           }
[08:24:55.062]                           base::stop(msg)
[08:24:55.062]                         }
[08:24:55.062]                       })
[08:24:55.062]                     }
[08:24:55.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.062]                     base::options(mc.cores = 1L)
[08:24:55.062]                   }
[08:24:55.062]                   ...future.strategy.old <- future::plan("list")
[08:24:55.062]                   options(future.plan = NULL)
[08:24:55.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.062]                 }
[08:24:55.062]                 ...future.workdir <- getwd()
[08:24:55.062]             }
[08:24:55.062]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.062]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.062]         }
[08:24:55.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.062]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.062]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.062]             base::names(...future.oldOptions))
[08:24:55.062]     }
[08:24:55.062]     if (FALSE) {
[08:24:55.062]     }
[08:24:55.062]     else {
[08:24:55.062]         if (TRUE) {
[08:24:55.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.062]                 open = "w")
[08:24:55.062]         }
[08:24:55.062]         else {
[08:24:55.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.062]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.062]         }
[08:24:55.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.062]             base::sink(type = "output", split = FALSE)
[08:24:55.062]             base::close(...future.stdout)
[08:24:55.062]         }, add = TRUE)
[08:24:55.062]     }
[08:24:55.062]     ...future.frame <- base::sys.nframe()
[08:24:55.062]     ...future.conditions <- base::list()
[08:24:55.062]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.062]     if (FALSE) {
[08:24:55.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.062]     }
[08:24:55.062]     ...future.result <- base::tryCatch({
[08:24:55.062]         base::withCallingHandlers({
[08:24:55.062]             ...future.value <- base::withVisible(base::local({
[08:24:55.062]                 ...future.makeSendCondition <- base::local({
[08:24:55.062]                   sendCondition <- NULL
[08:24:55.062]                   function(frame = 1L) {
[08:24:55.062]                     if (is.function(sendCondition)) 
[08:24:55.062]                       return(sendCondition)
[08:24:55.062]                     ns <- getNamespace("parallel")
[08:24:55.062]                     if (exists("sendData", mode = "function", 
[08:24:55.062]                       envir = ns)) {
[08:24:55.062]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.062]                         envir = ns)
[08:24:55.062]                       envir <- sys.frame(frame)
[08:24:55.062]                       master <- NULL
[08:24:55.062]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.062]                         !identical(envir, emptyenv())) {
[08:24:55.062]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.062]                           inherits = FALSE)) {
[08:24:55.062]                           master <- get("master", mode = "list", 
[08:24:55.062]                             envir = envir, inherits = FALSE)
[08:24:55.062]                           if (inherits(master, c("SOCKnode", 
[08:24:55.062]                             "SOCK0node"))) {
[08:24:55.062]                             sendCondition <<- function(cond) {
[08:24:55.062]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.062]                                 success = TRUE)
[08:24:55.062]                               parallel_sendData(master, data)
[08:24:55.062]                             }
[08:24:55.062]                             return(sendCondition)
[08:24:55.062]                           }
[08:24:55.062]                         }
[08:24:55.062]                         frame <- frame + 1L
[08:24:55.062]                         envir <- sys.frame(frame)
[08:24:55.062]                       }
[08:24:55.062]                     }
[08:24:55.062]                     sendCondition <<- function(cond) NULL
[08:24:55.062]                   }
[08:24:55.062]                 })
[08:24:55.062]                 withCallingHandlers({
[08:24:55.062]                   {
[08:24:55.062]                     do.call(function(...) {
[08:24:55.062]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.062]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.062]                         ...future.globals.maxSize)) {
[08:24:55.062]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.062]                         on.exit(options(oopts), add = TRUE)
[08:24:55.062]                       }
[08:24:55.062]                       {
[08:24:55.062]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.062]                           FUN = function(jj) {
[08:24:55.062]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.062]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.062]                           })
[08:24:55.062]                       }
[08:24:55.062]                     }, args = future.call.arguments)
[08:24:55.062]                   }
[08:24:55.062]                 }, immediateCondition = function(cond) {
[08:24:55.062]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.062]                   sendCondition(cond)
[08:24:55.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.062]                   {
[08:24:55.062]                     inherits <- base::inherits
[08:24:55.062]                     invokeRestart <- base::invokeRestart
[08:24:55.062]                     is.null <- base::is.null
[08:24:55.062]                     muffled <- FALSE
[08:24:55.062]                     if (inherits(cond, "message")) {
[08:24:55.062]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.062]                       if (muffled) 
[08:24:55.062]                         invokeRestart("muffleMessage")
[08:24:55.062]                     }
[08:24:55.062]                     else if (inherits(cond, "warning")) {
[08:24:55.062]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.062]                       if (muffled) 
[08:24:55.062]                         invokeRestart("muffleWarning")
[08:24:55.062]                     }
[08:24:55.062]                     else if (inherits(cond, "condition")) {
[08:24:55.062]                       if (!is.null(pattern)) {
[08:24:55.062]                         computeRestarts <- base::computeRestarts
[08:24:55.062]                         grepl <- base::grepl
[08:24:55.062]                         restarts <- computeRestarts(cond)
[08:24:55.062]                         for (restart in restarts) {
[08:24:55.062]                           name <- restart$name
[08:24:55.062]                           if (is.null(name)) 
[08:24:55.062]                             next
[08:24:55.062]                           if (!grepl(pattern, name)) 
[08:24:55.062]                             next
[08:24:55.062]                           invokeRestart(restart)
[08:24:55.062]                           muffled <- TRUE
[08:24:55.062]                           break
[08:24:55.062]                         }
[08:24:55.062]                       }
[08:24:55.062]                     }
[08:24:55.062]                     invisible(muffled)
[08:24:55.062]                   }
[08:24:55.062]                   muffleCondition(cond)
[08:24:55.062]                 })
[08:24:55.062]             }))
[08:24:55.062]             future::FutureResult(value = ...future.value$value, 
[08:24:55.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.062]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.062]                     ...future.globalenv.names))
[08:24:55.062]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.062]         }, condition = base::local({
[08:24:55.062]             c <- base::c
[08:24:55.062]             inherits <- base::inherits
[08:24:55.062]             invokeRestart <- base::invokeRestart
[08:24:55.062]             length <- base::length
[08:24:55.062]             list <- base::list
[08:24:55.062]             seq.int <- base::seq.int
[08:24:55.062]             signalCondition <- base::signalCondition
[08:24:55.062]             sys.calls <- base::sys.calls
[08:24:55.062]             `[[` <- base::`[[`
[08:24:55.062]             `+` <- base::`+`
[08:24:55.062]             `<<-` <- base::`<<-`
[08:24:55.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.062]                   3L)]
[08:24:55.062]             }
[08:24:55.062]             function(cond) {
[08:24:55.062]                 is_error <- inherits(cond, "error")
[08:24:55.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.062]                   NULL)
[08:24:55.062]                 if (is_error) {
[08:24:55.062]                   sessionInformation <- function() {
[08:24:55.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.062]                       search = base::search(), system = base::Sys.info())
[08:24:55.062]                   }
[08:24:55.062]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.062]                     cond$call), session = sessionInformation(), 
[08:24:55.062]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.062]                   signalCondition(cond)
[08:24:55.062]                 }
[08:24:55.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.062]                 "immediateCondition"))) {
[08:24:55.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.062]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.062]                   if (TRUE && !signal) {
[08:24:55.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.062]                     {
[08:24:55.062]                       inherits <- base::inherits
[08:24:55.062]                       invokeRestart <- base::invokeRestart
[08:24:55.062]                       is.null <- base::is.null
[08:24:55.062]                       muffled <- FALSE
[08:24:55.062]                       if (inherits(cond, "message")) {
[08:24:55.062]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.062]                         if (muffled) 
[08:24:55.062]                           invokeRestart("muffleMessage")
[08:24:55.062]                       }
[08:24:55.062]                       else if (inherits(cond, "warning")) {
[08:24:55.062]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.062]                         if (muffled) 
[08:24:55.062]                           invokeRestart("muffleWarning")
[08:24:55.062]                       }
[08:24:55.062]                       else if (inherits(cond, "condition")) {
[08:24:55.062]                         if (!is.null(pattern)) {
[08:24:55.062]                           computeRestarts <- base::computeRestarts
[08:24:55.062]                           grepl <- base::grepl
[08:24:55.062]                           restarts <- computeRestarts(cond)
[08:24:55.062]                           for (restart in restarts) {
[08:24:55.062]                             name <- restart$name
[08:24:55.062]                             if (is.null(name)) 
[08:24:55.062]                               next
[08:24:55.062]                             if (!grepl(pattern, name)) 
[08:24:55.062]                               next
[08:24:55.062]                             invokeRestart(restart)
[08:24:55.062]                             muffled <- TRUE
[08:24:55.062]                             break
[08:24:55.062]                           }
[08:24:55.062]                         }
[08:24:55.062]                       }
[08:24:55.062]                       invisible(muffled)
[08:24:55.062]                     }
[08:24:55.062]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.062]                   }
[08:24:55.062]                 }
[08:24:55.062]                 else {
[08:24:55.062]                   if (TRUE) {
[08:24:55.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.062]                     {
[08:24:55.062]                       inherits <- base::inherits
[08:24:55.062]                       invokeRestart <- base::invokeRestart
[08:24:55.062]                       is.null <- base::is.null
[08:24:55.062]                       muffled <- FALSE
[08:24:55.062]                       if (inherits(cond, "message")) {
[08:24:55.062]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.062]                         if (muffled) 
[08:24:55.062]                           invokeRestart("muffleMessage")
[08:24:55.062]                       }
[08:24:55.062]                       else if (inherits(cond, "warning")) {
[08:24:55.062]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.062]                         if (muffled) 
[08:24:55.062]                           invokeRestart("muffleWarning")
[08:24:55.062]                       }
[08:24:55.062]                       else if (inherits(cond, "condition")) {
[08:24:55.062]                         if (!is.null(pattern)) {
[08:24:55.062]                           computeRestarts <- base::computeRestarts
[08:24:55.062]                           grepl <- base::grepl
[08:24:55.062]                           restarts <- computeRestarts(cond)
[08:24:55.062]                           for (restart in restarts) {
[08:24:55.062]                             name <- restart$name
[08:24:55.062]                             if (is.null(name)) 
[08:24:55.062]                               next
[08:24:55.062]                             if (!grepl(pattern, name)) 
[08:24:55.062]                               next
[08:24:55.062]                             invokeRestart(restart)
[08:24:55.062]                             muffled <- TRUE
[08:24:55.062]                             break
[08:24:55.062]                           }
[08:24:55.062]                         }
[08:24:55.062]                       }
[08:24:55.062]                       invisible(muffled)
[08:24:55.062]                     }
[08:24:55.062]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.062]                   }
[08:24:55.062]                 }
[08:24:55.062]             }
[08:24:55.062]         }))
[08:24:55.062]     }, error = function(ex) {
[08:24:55.062]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.062]                 ...future.rng), started = ...future.startTime, 
[08:24:55.062]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.062]             version = "1.8"), class = "FutureResult")
[08:24:55.062]     }, finally = {
[08:24:55.062]         if (!identical(...future.workdir, getwd())) 
[08:24:55.062]             setwd(...future.workdir)
[08:24:55.062]         {
[08:24:55.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.062]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.062]             }
[08:24:55.062]             base::options(...future.oldOptions)
[08:24:55.062]             if (.Platform$OS.type == "windows") {
[08:24:55.062]                 old_names <- names(...future.oldEnvVars)
[08:24:55.062]                 envs <- base::Sys.getenv()
[08:24:55.062]                 names <- names(envs)
[08:24:55.062]                 common <- intersect(names, old_names)
[08:24:55.062]                 added <- setdiff(names, old_names)
[08:24:55.062]                 removed <- setdiff(old_names, names)
[08:24:55.062]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.062]                   envs[common]]
[08:24:55.062]                 NAMES <- toupper(changed)
[08:24:55.062]                 args <- list()
[08:24:55.062]                 for (kk in seq_along(NAMES)) {
[08:24:55.062]                   name <- changed[[kk]]
[08:24:55.062]                   NAME <- NAMES[[kk]]
[08:24:55.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.062]                     next
[08:24:55.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.062]                 }
[08:24:55.062]                 NAMES <- toupper(added)
[08:24:55.062]                 for (kk in seq_along(NAMES)) {
[08:24:55.062]                   name <- added[[kk]]
[08:24:55.062]                   NAME <- NAMES[[kk]]
[08:24:55.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.062]                     next
[08:24:55.062]                   args[[name]] <- ""
[08:24:55.062]                 }
[08:24:55.062]                 NAMES <- toupper(removed)
[08:24:55.062]                 for (kk in seq_along(NAMES)) {
[08:24:55.062]                   name <- removed[[kk]]
[08:24:55.062]                   NAME <- NAMES[[kk]]
[08:24:55.062]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.062]                     next
[08:24:55.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.062]                 }
[08:24:55.062]                 if (length(args) > 0) 
[08:24:55.062]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.062]             }
[08:24:55.062]             else {
[08:24:55.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.062]             }
[08:24:55.062]             {
[08:24:55.062]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.062]                   0L) {
[08:24:55.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.062]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.062]                   base::options(opts)
[08:24:55.062]                 }
[08:24:55.062]                 {
[08:24:55.062]                   {
[08:24:55.062]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.062]                     NULL
[08:24:55.062]                   }
[08:24:55.062]                   options(future.plan = NULL)
[08:24:55.062]                   if (is.na(NA_character_)) 
[08:24:55.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.062]                     .init = FALSE)
[08:24:55.062]                 }
[08:24:55.062]             }
[08:24:55.062]         }
[08:24:55.062]     })
[08:24:55.062]     if (TRUE) {
[08:24:55.062]         base::sink(type = "output", split = FALSE)
[08:24:55.062]         if (TRUE) {
[08:24:55.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.062]         }
[08:24:55.062]         else {
[08:24:55.062]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.062]         }
[08:24:55.062]         base::close(...future.stdout)
[08:24:55.062]         ...future.stdout <- NULL
[08:24:55.062]     }
[08:24:55.062]     ...future.result$conditions <- ...future.conditions
[08:24:55.062]     ...future.result$finished <- base::Sys.time()
[08:24:55.062]     ...future.result
[08:24:55.062] }
[08:24:55.065] Exporting 5 global objects (1.03 KiB) to cluster node #1 ...
[08:24:55.065] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:55.065] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:55.066] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[08:24:55.066] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[08:24:55.066] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #1 ...
[08:24:55.066] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #1 ... DONE
[08:24:55.067] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:55.067] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:55.067] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:55.067] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:55.068] Exporting 5 global objects (1.03 KiB) to cluster node #1 ... DONE
[08:24:55.068] MultisessionFuture started
[08:24:55.068] - Launch lazy future ... done
[08:24:55.068] run() for ‘MultisessionFuture’ ... done
[08:24:55.068] Created future:
[08:24:55.068] MultisessionFuture:
[08:24:55.068] Label: ‘future_apply-1’
[08:24:55.068] Expression:
[08:24:55.068] {
[08:24:55.068]     do.call(function(...) {
[08:24:55.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.068]             on.exit(options(oopts), add = TRUE)
[08:24:55.068]         }
[08:24:55.068]         {
[08:24:55.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.068]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.068]             })
[08:24:55.068]         }
[08:24:55.068]     }, args = future.call.arguments)
[08:24:55.068] }
[08:24:55.068] Lazy evaluation: FALSE
[08:24:55.068] Asynchronous evaluation: TRUE
[08:24:55.068] Local evaluation: TRUE
[08:24:55.068] Environment: R_GlobalEnv
[08:24:55.068] Capture standard output: TRUE
[08:24:55.068] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.068] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.068] Packages: <none>
[08:24:55.068] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.068] Resolved: FALSE
[08:24:55.068] Value: <not collected>
[08:24:55.068] Conditions captured: <none>
[08:24:55.068] Early signaling: FALSE
[08:24:55.068] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.068] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.080] Chunk #1 of 2 ... DONE
[08:24:55.080] Chunk #2 of 2 ...
[08:24:55.080]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.080]  - seeds: <none>
[08:24:55.080]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.081] getGlobalsAndPackages() ...
[08:24:55.081] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.081] Resolving globals: FALSE
[08:24:55.081] Tweak future expression to call with '...' arguments ...
[08:24:55.081] {
[08:24:55.081]     do.call(function(...) {
[08:24:55.081]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.081]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.081]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.081]             on.exit(options(oopts), add = TRUE)
[08:24:55.081]         }
[08:24:55.081]         {
[08:24:55.081]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.081]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.081]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.081]             })
[08:24:55.081]         }
[08:24:55.081]     }, args = future.call.arguments)
[08:24:55.081] }
[08:24:55.081] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.082] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.082] 
[08:24:55.082] getGlobalsAndPackages() ... DONE
[08:24:55.082] run() for ‘Future’ ...
[08:24:55.082] - state: ‘created’
[08:24:55.082] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.097] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.097] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.097]   - Field: ‘node’
[08:24:55.097]   - Field: ‘label’
[08:24:55.097]   - Field: ‘local’
[08:24:55.097]   - Field: ‘owner’
[08:24:55.097]   - Field: ‘envir’
[08:24:55.097]   - Field: ‘workers’
[08:24:55.097]   - Field: ‘packages’
[08:24:55.097]   - Field: ‘gc’
[08:24:55.098]   - Field: ‘conditions’
[08:24:55.098]   - Field: ‘persistent’
[08:24:55.098]   - Field: ‘expr’
[08:24:55.098]   - Field: ‘uuid’
[08:24:55.098]   - Field: ‘seed’
[08:24:55.098]   - Field: ‘version’
[08:24:55.098]   - Field: ‘result’
[08:24:55.098]   - Field: ‘asynchronous’
[08:24:55.098]   - Field: ‘calls’
[08:24:55.098]   - Field: ‘globals’
[08:24:55.098]   - Field: ‘stdout’
[08:24:55.098]   - Field: ‘earlySignal’
[08:24:55.099]   - Field: ‘lazy’
[08:24:55.099]   - Field: ‘state’
[08:24:55.099] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.099] - Launch lazy future ...
[08:24:55.099] Packages needed by the future expression (n = 0): <none>
[08:24:55.099] Packages needed by future strategies (n = 0): <none>
[08:24:55.100] {
[08:24:55.100]     {
[08:24:55.100]         {
[08:24:55.100]             ...future.startTime <- base::Sys.time()
[08:24:55.100]             {
[08:24:55.100]                 {
[08:24:55.100]                   {
[08:24:55.100]                     {
[08:24:55.100]                       base::local({
[08:24:55.100]                         has_future <- base::requireNamespace("future", 
[08:24:55.100]                           quietly = TRUE)
[08:24:55.100]                         if (has_future) {
[08:24:55.100]                           ns <- base::getNamespace("future")
[08:24:55.100]                           version <- ns[[".package"]][["version"]]
[08:24:55.100]                           if (is.null(version)) 
[08:24:55.100]                             version <- utils::packageVersion("future")
[08:24:55.100]                         }
[08:24:55.100]                         else {
[08:24:55.100]                           version <- NULL
[08:24:55.100]                         }
[08:24:55.100]                         if (!has_future || version < "1.8.0") {
[08:24:55.100]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.100]                             "", base::R.version$version.string), 
[08:24:55.100]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.100]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.100]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.100]                               "release", "version")], collapse = " "), 
[08:24:55.100]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.100]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.100]                             info)
[08:24:55.100]                           info <- base::paste(info, collapse = "; ")
[08:24:55.100]                           if (!has_future) {
[08:24:55.100]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.100]                               info)
[08:24:55.100]                           }
[08:24:55.100]                           else {
[08:24:55.100]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.100]                               info, version)
[08:24:55.100]                           }
[08:24:55.100]                           base::stop(msg)
[08:24:55.100]                         }
[08:24:55.100]                       })
[08:24:55.100]                     }
[08:24:55.100]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.100]                     base::options(mc.cores = 1L)
[08:24:55.100]                   }
[08:24:55.100]                   ...future.strategy.old <- future::plan("list")
[08:24:55.100]                   options(future.plan = NULL)
[08:24:55.100]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.100]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.100]                 }
[08:24:55.100]                 ...future.workdir <- getwd()
[08:24:55.100]             }
[08:24:55.100]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.100]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.100]         }
[08:24:55.100]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.100]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.100]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.100]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.100]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.100]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.100]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.100]             base::names(...future.oldOptions))
[08:24:55.100]     }
[08:24:55.100]     if (FALSE) {
[08:24:55.100]     }
[08:24:55.100]     else {
[08:24:55.100]         if (TRUE) {
[08:24:55.100]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.100]                 open = "w")
[08:24:55.100]         }
[08:24:55.100]         else {
[08:24:55.100]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.100]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.100]         }
[08:24:55.100]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.100]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.100]             base::sink(type = "output", split = FALSE)
[08:24:55.100]             base::close(...future.stdout)
[08:24:55.100]         }, add = TRUE)
[08:24:55.100]     }
[08:24:55.100]     ...future.frame <- base::sys.nframe()
[08:24:55.100]     ...future.conditions <- base::list()
[08:24:55.100]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.100]     if (FALSE) {
[08:24:55.100]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.100]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.100]     }
[08:24:55.100]     ...future.result <- base::tryCatch({
[08:24:55.100]         base::withCallingHandlers({
[08:24:55.100]             ...future.value <- base::withVisible(base::local({
[08:24:55.100]                 ...future.makeSendCondition <- base::local({
[08:24:55.100]                   sendCondition <- NULL
[08:24:55.100]                   function(frame = 1L) {
[08:24:55.100]                     if (is.function(sendCondition)) 
[08:24:55.100]                       return(sendCondition)
[08:24:55.100]                     ns <- getNamespace("parallel")
[08:24:55.100]                     if (exists("sendData", mode = "function", 
[08:24:55.100]                       envir = ns)) {
[08:24:55.100]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.100]                         envir = ns)
[08:24:55.100]                       envir <- sys.frame(frame)
[08:24:55.100]                       master <- NULL
[08:24:55.100]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.100]                         !identical(envir, emptyenv())) {
[08:24:55.100]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.100]                           inherits = FALSE)) {
[08:24:55.100]                           master <- get("master", mode = "list", 
[08:24:55.100]                             envir = envir, inherits = FALSE)
[08:24:55.100]                           if (inherits(master, c("SOCKnode", 
[08:24:55.100]                             "SOCK0node"))) {
[08:24:55.100]                             sendCondition <<- function(cond) {
[08:24:55.100]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.100]                                 success = TRUE)
[08:24:55.100]                               parallel_sendData(master, data)
[08:24:55.100]                             }
[08:24:55.100]                             return(sendCondition)
[08:24:55.100]                           }
[08:24:55.100]                         }
[08:24:55.100]                         frame <- frame + 1L
[08:24:55.100]                         envir <- sys.frame(frame)
[08:24:55.100]                       }
[08:24:55.100]                     }
[08:24:55.100]                     sendCondition <<- function(cond) NULL
[08:24:55.100]                   }
[08:24:55.100]                 })
[08:24:55.100]                 withCallingHandlers({
[08:24:55.100]                   {
[08:24:55.100]                     do.call(function(...) {
[08:24:55.100]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.100]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.100]                         ...future.globals.maxSize)) {
[08:24:55.100]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.100]                         on.exit(options(oopts), add = TRUE)
[08:24:55.100]                       }
[08:24:55.100]                       {
[08:24:55.100]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.100]                           FUN = function(jj) {
[08:24:55.100]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.100]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.100]                           })
[08:24:55.100]                       }
[08:24:55.100]                     }, args = future.call.arguments)
[08:24:55.100]                   }
[08:24:55.100]                 }, immediateCondition = function(cond) {
[08:24:55.100]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.100]                   sendCondition(cond)
[08:24:55.100]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.100]                   {
[08:24:55.100]                     inherits <- base::inherits
[08:24:55.100]                     invokeRestart <- base::invokeRestart
[08:24:55.100]                     is.null <- base::is.null
[08:24:55.100]                     muffled <- FALSE
[08:24:55.100]                     if (inherits(cond, "message")) {
[08:24:55.100]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.100]                       if (muffled) 
[08:24:55.100]                         invokeRestart("muffleMessage")
[08:24:55.100]                     }
[08:24:55.100]                     else if (inherits(cond, "warning")) {
[08:24:55.100]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.100]                       if (muffled) 
[08:24:55.100]                         invokeRestart("muffleWarning")
[08:24:55.100]                     }
[08:24:55.100]                     else if (inherits(cond, "condition")) {
[08:24:55.100]                       if (!is.null(pattern)) {
[08:24:55.100]                         computeRestarts <- base::computeRestarts
[08:24:55.100]                         grepl <- base::grepl
[08:24:55.100]                         restarts <- computeRestarts(cond)
[08:24:55.100]                         for (restart in restarts) {
[08:24:55.100]                           name <- restart$name
[08:24:55.100]                           if (is.null(name)) 
[08:24:55.100]                             next
[08:24:55.100]                           if (!grepl(pattern, name)) 
[08:24:55.100]                             next
[08:24:55.100]                           invokeRestart(restart)
[08:24:55.100]                           muffled <- TRUE
[08:24:55.100]                           break
[08:24:55.100]                         }
[08:24:55.100]                       }
[08:24:55.100]                     }
[08:24:55.100]                     invisible(muffled)
[08:24:55.100]                   }
[08:24:55.100]                   muffleCondition(cond)
[08:24:55.100]                 })
[08:24:55.100]             }))
[08:24:55.100]             future::FutureResult(value = ...future.value$value, 
[08:24:55.100]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.100]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.100]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.100]                     ...future.globalenv.names))
[08:24:55.100]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.100]         }, condition = base::local({
[08:24:55.100]             c <- base::c
[08:24:55.100]             inherits <- base::inherits
[08:24:55.100]             invokeRestart <- base::invokeRestart
[08:24:55.100]             length <- base::length
[08:24:55.100]             list <- base::list
[08:24:55.100]             seq.int <- base::seq.int
[08:24:55.100]             signalCondition <- base::signalCondition
[08:24:55.100]             sys.calls <- base::sys.calls
[08:24:55.100]             `[[` <- base::`[[`
[08:24:55.100]             `+` <- base::`+`
[08:24:55.100]             `<<-` <- base::`<<-`
[08:24:55.100]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.100]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.100]                   3L)]
[08:24:55.100]             }
[08:24:55.100]             function(cond) {
[08:24:55.100]                 is_error <- inherits(cond, "error")
[08:24:55.100]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.100]                   NULL)
[08:24:55.100]                 if (is_error) {
[08:24:55.100]                   sessionInformation <- function() {
[08:24:55.100]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.100]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.100]                       search = base::search(), system = base::Sys.info())
[08:24:55.100]                   }
[08:24:55.100]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.100]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.100]                     cond$call), session = sessionInformation(), 
[08:24:55.100]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.100]                   signalCondition(cond)
[08:24:55.100]                 }
[08:24:55.100]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.100]                 "immediateCondition"))) {
[08:24:55.100]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.100]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.100]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.100]                   if (TRUE && !signal) {
[08:24:55.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.100]                     {
[08:24:55.100]                       inherits <- base::inherits
[08:24:55.100]                       invokeRestart <- base::invokeRestart
[08:24:55.100]                       is.null <- base::is.null
[08:24:55.100]                       muffled <- FALSE
[08:24:55.100]                       if (inherits(cond, "message")) {
[08:24:55.100]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.100]                         if (muffled) 
[08:24:55.100]                           invokeRestart("muffleMessage")
[08:24:55.100]                       }
[08:24:55.100]                       else if (inherits(cond, "warning")) {
[08:24:55.100]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.100]                         if (muffled) 
[08:24:55.100]                           invokeRestart("muffleWarning")
[08:24:55.100]                       }
[08:24:55.100]                       else if (inherits(cond, "condition")) {
[08:24:55.100]                         if (!is.null(pattern)) {
[08:24:55.100]                           computeRestarts <- base::computeRestarts
[08:24:55.100]                           grepl <- base::grepl
[08:24:55.100]                           restarts <- computeRestarts(cond)
[08:24:55.100]                           for (restart in restarts) {
[08:24:55.100]                             name <- restart$name
[08:24:55.100]                             if (is.null(name)) 
[08:24:55.100]                               next
[08:24:55.100]                             if (!grepl(pattern, name)) 
[08:24:55.100]                               next
[08:24:55.100]                             invokeRestart(restart)
[08:24:55.100]                             muffled <- TRUE
[08:24:55.100]                             break
[08:24:55.100]                           }
[08:24:55.100]                         }
[08:24:55.100]                       }
[08:24:55.100]                       invisible(muffled)
[08:24:55.100]                     }
[08:24:55.100]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.100]                   }
[08:24:55.100]                 }
[08:24:55.100]                 else {
[08:24:55.100]                   if (TRUE) {
[08:24:55.100]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.100]                     {
[08:24:55.100]                       inherits <- base::inherits
[08:24:55.100]                       invokeRestart <- base::invokeRestart
[08:24:55.100]                       is.null <- base::is.null
[08:24:55.100]                       muffled <- FALSE
[08:24:55.100]                       if (inherits(cond, "message")) {
[08:24:55.100]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.100]                         if (muffled) 
[08:24:55.100]                           invokeRestart("muffleMessage")
[08:24:55.100]                       }
[08:24:55.100]                       else if (inherits(cond, "warning")) {
[08:24:55.100]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.100]                         if (muffled) 
[08:24:55.100]                           invokeRestart("muffleWarning")
[08:24:55.100]                       }
[08:24:55.100]                       else if (inherits(cond, "condition")) {
[08:24:55.100]                         if (!is.null(pattern)) {
[08:24:55.100]                           computeRestarts <- base::computeRestarts
[08:24:55.100]                           grepl <- base::grepl
[08:24:55.100]                           restarts <- computeRestarts(cond)
[08:24:55.100]                           for (restart in restarts) {
[08:24:55.100]                             name <- restart$name
[08:24:55.100]                             if (is.null(name)) 
[08:24:55.100]                               next
[08:24:55.100]                             if (!grepl(pattern, name)) 
[08:24:55.100]                               next
[08:24:55.100]                             invokeRestart(restart)
[08:24:55.100]                             muffled <- TRUE
[08:24:55.100]                             break
[08:24:55.100]                           }
[08:24:55.100]                         }
[08:24:55.100]                       }
[08:24:55.100]                       invisible(muffled)
[08:24:55.100]                     }
[08:24:55.100]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.100]                   }
[08:24:55.100]                 }
[08:24:55.100]             }
[08:24:55.100]         }))
[08:24:55.100]     }, error = function(ex) {
[08:24:55.100]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.100]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.100]                 ...future.rng), started = ...future.startTime, 
[08:24:55.100]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.100]             version = "1.8"), class = "FutureResult")
[08:24:55.100]     }, finally = {
[08:24:55.100]         if (!identical(...future.workdir, getwd())) 
[08:24:55.100]             setwd(...future.workdir)
[08:24:55.100]         {
[08:24:55.100]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.100]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.100]             }
[08:24:55.100]             base::options(...future.oldOptions)
[08:24:55.100]             if (.Platform$OS.type == "windows") {
[08:24:55.100]                 old_names <- names(...future.oldEnvVars)
[08:24:55.100]                 envs <- base::Sys.getenv()
[08:24:55.100]                 names <- names(envs)
[08:24:55.100]                 common <- intersect(names, old_names)
[08:24:55.100]                 added <- setdiff(names, old_names)
[08:24:55.100]                 removed <- setdiff(old_names, names)
[08:24:55.100]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.100]                   envs[common]]
[08:24:55.100]                 NAMES <- toupper(changed)
[08:24:55.100]                 args <- list()
[08:24:55.100]                 for (kk in seq_along(NAMES)) {
[08:24:55.100]                   name <- changed[[kk]]
[08:24:55.100]                   NAME <- NAMES[[kk]]
[08:24:55.100]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.100]                     next
[08:24:55.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.100]                 }
[08:24:55.100]                 NAMES <- toupper(added)
[08:24:55.100]                 for (kk in seq_along(NAMES)) {
[08:24:55.100]                   name <- added[[kk]]
[08:24:55.100]                   NAME <- NAMES[[kk]]
[08:24:55.100]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.100]                     next
[08:24:55.100]                   args[[name]] <- ""
[08:24:55.100]                 }
[08:24:55.100]                 NAMES <- toupper(removed)
[08:24:55.100]                 for (kk in seq_along(NAMES)) {
[08:24:55.100]                   name <- removed[[kk]]
[08:24:55.100]                   NAME <- NAMES[[kk]]
[08:24:55.100]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.100]                     next
[08:24:55.100]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.100]                 }
[08:24:55.100]                 if (length(args) > 0) 
[08:24:55.100]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.100]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.100]             }
[08:24:55.100]             else {
[08:24:55.100]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.100]             }
[08:24:55.100]             {
[08:24:55.100]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.100]                   0L) {
[08:24:55.100]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.100]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.100]                   base::options(opts)
[08:24:55.100]                 }
[08:24:55.100]                 {
[08:24:55.100]                   {
[08:24:55.100]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.100]                     NULL
[08:24:55.100]                   }
[08:24:55.100]                   options(future.plan = NULL)
[08:24:55.100]                   if (is.na(NA_character_)) 
[08:24:55.100]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.100]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.100]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.100]                     .init = FALSE)
[08:24:55.100]                 }
[08:24:55.100]             }
[08:24:55.100]         }
[08:24:55.100]     })
[08:24:55.100]     if (TRUE) {
[08:24:55.100]         base::sink(type = "output", split = FALSE)
[08:24:55.100]         if (TRUE) {
[08:24:55.100]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.100]         }
[08:24:55.100]         else {
[08:24:55.100]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.100]         }
[08:24:55.100]         base::close(...future.stdout)
[08:24:55.100]         ...future.stdout <- NULL
[08:24:55.100]     }
[08:24:55.100]     ...future.result$conditions <- ...future.conditions
[08:24:55.100]     ...future.result$finished <- base::Sys.time()
[08:24:55.100]     ...future.result
[08:24:55.100] }
[08:24:55.103] Exporting 5 global objects (1.03 KiB) to cluster node #2 ...
[08:24:55.103] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:55.103] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:55.104] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[08:24:55.104] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[08:24:55.104] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #2 ...
[08:24:55.105] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #2 ... DONE
[08:24:55.105] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:55.105] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:55.105] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:55.106] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:55.106] Exporting 5 global objects (1.03 KiB) to cluster node #2 ... DONE
[08:24:55.106] MultisessionFuture started
[08:24:55.106] - Launch lazy future ... done
[08:24:55.106] run() for ‘MultisessionFuture’ ... done
[08:24:55.106] Created future:
[08:24:55.107] MultisessionFuture:
[08:24:55.107] Label: ‘future_apply-2’
[08:24:55.107] Expression:
[08:24:55.107] {
[08:24:55.107]     do.call(function(...) {
[08:24:55.107]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.107]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.107]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.107]             on.exit(options(oopts), add = TRUE)
[08:24:55.107]         }
[08:24:55.107]         {
[08:24:55.107]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.107]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.107]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.107]             })
[08:24:55.107]         }
[08:24:55.107]     }, args = future.call.arguments)
[08:24:55.107] }
[08:24:55.107] Lazy evaluation: FALSE
[08:24:55.107] Asynchronous evaluation: TRUE
[08:24:55.107] Local evaluation: TRUE
[08:24:55.107] Environment: R_GlobalEnv
[08:24:55.107] Capture standard output: TRUE
[08:24:55.107] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.107] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.107] Packages: <none>
[08:24:55.107] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.107] Resolved: FALSE
[08:24:55.107] Value: <not collected>
[08:24:55.107] Conditions captured: <none>
[08:24:55.107] Early signaling: FALSE
[08:24:55.107] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.107] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.118] Chunk #2 of 2 ... DONE
[08:24:55.118] Launching 2 futures (chunks) ... DONE
[08:24:55.118] Resolving 2 futures (chunks) ...
[08:24:55.119] resolve() on list ...
[08:24:55.119]  recursive: 0
[08:24:55.119]  length: 2
[08:24:55.119] 
[08:24:55.119] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.119] - Validating connection of MultisessionFuture
[08:24:55.120] - received message: FutureResult
[08:24:55.120] - Received FutureResult
[08:24:55.120] - Erased future from FutureRegistry
[08:24:55.120] result() for ClusterFuture ...
[08:24:55.120] - result already collected: FutureResult
[08:24:55.120] result() for ClusterFuture ... done
[08:24:55.120] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.120] Future #1
[08:24:55.120] result() for ClusterFuture ...
[08:24:55.120] - result already collected: FutureResult
[08:24:55.121] result() for ClusterFuture ... done
[08:24:55.121] result() for ClusterFuture ...
[08:24:55.121] - result already collected: FutureResult
[08:24:55.121] result() for ClusterFuture ... done
[08:24:55.121] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:55.121] - nx: 2
[08:24:55.121] - relay: TRUE
[08:24:55.121] - stdout: TRUE
[08:24:55.121] - signal: TRUE
[08:24:55.121] - resignal: FALSE
[08:24:55.121] - force: TRUE
[08:24:55.121] - relayed: [n=2] FALSE, FALSE
[08:24:55.122] - queued futures: [n=2] FALSE, FALSE
[08:24:55.122]  - until=1
[08:24:55.122]  - relaying element #1
[08:24:55.122] result() for ClusterFuture ...
[08:24:55.122] - result already collected: FutureResult
[08:24:55.122] result() for ClusterFuture ... done
[08:24:55.122] result() for ClusterFuture ...
[08:24:55.122] - result already collected: FutureResult
[08:24:55.122] result() for ClusterFuture ... done
[08:24:55.122] result() for ClusterFuture ...
[08:24:55.122] - result already collected: FutureResult
[08:24:55.123] result() for ClusterFuture ... done
[08:24:55.123] result() for ClusterFuture ...
[08:24:55.123] - result already collected: FutureResult
[08:24:55.123] result() for ClusterFuture ... done
[08:24:55.123] - relayed: [n=2] TRUE, FALSE
[08:24:55.123] - queued futures: [n=2] TRUE, FALSE
[08:24:55.123] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:55.123]  length: 1 (resolved future 1)
[08:24:55.148] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.149] - Validating connection of MultisessionFuture
[08:24:55.149] - received message: FutureResult
[08:24:55.149] - Received FutureResult
[08:24:55.149] - Erased future from FutureRegistry
[08:24:55.149] result() for ClusterFuture ...
[08:24:55.149] - result already collected: FutureResult
[08:24:55.149] result() for ClusterFuture ... done
[08:24:55.149] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.149] Future #2
[08:24:55.150] result() for ClusterFuture ...
[08:24:55.150] - result already collected: FutureResult
[08:24:55.150] result() for ClusterFuture ... done
[08:24:55.150] result() for ClusterFuture ...
[08:24:55.150] - result already collected: FutureResult
[08:24:55.150] result() for ClusterFuture ... done
[08:24:55.150] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:55.150] - nx: 2
[08:24:55.150] - relay: TRUE
[08:24:55.150] - stdout: TRUE
[08:24:55.150] - signal: TRUE
[08:24:55.151] - resignal: FALSE
[08:24:55.151] - force: TRUE
[08:24:55.151] - relayed: [n=2] TRUE, FALSE
[08:24:55.151] - queued futures: [n=2] TRUE, FALSE
[08:24:55.151]  - until=2
[08:24:55.151]  - relaying element #2
[08:24:55.151] result() for ClusterFuture ...
[08:24:55.151] - result already collected: FutureResult
[08:24:55.151] result() for ClusterFuture ... done
[08:24:55.151] result() for ClusterFuture ...
[08:24:55.151] - result already collected: FutureResult
[08:24:55.151] result() for ClusterFuture ... done
[08:24:55.152] result() for ClusterFuture ...
[08:24:55.152] - result already collected: FutureResult
[08:24:55.152] result() for ClusterFuture ... done
[08:24:55.152] result() for ClusterFuture ...
[08:24:55.152] - result already collected: FutureResult
[08:24:55.152] result() for ClusterFuture ... done
[08:24:55.152] - relayed: [n=2] TRUE, TRUE
[08:24:55.152] - queued futures: [n=2] TRUE, TRUE
[08:24:55.152] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:55.152]  length: 0 (resolved future 2)
[08:24:55.152] Relaying remaining futures
[08:24:55.153] signalConditionsASAP(NULL, pos=0) ...
[08:24:55.153] - nx: 2
[08:24:55.153] - relay: TRUE
[08:24:55.153] - stdout: TRUE
[08:24:55.153] - signal: TRUE
[08:24:55.153] - resignal: FALSE
[08:24:55.153] - force: TRUE
[08:24:55.153] - relayed: [n=2] TRUE, TRUE
[08:24:55.153] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:55.153] - relayed: [n=2] TRUE, TRUE
[08:24:55.153] - queued futures: [n=2] TRUE, TRUE
[08:24:55.153] signalConditionsASAP(NULL, pos=0) ... done
[08:24:55.154] resolve() on list ... DONE
[08:24:55.154] result() for ClusterFuture ...
[08:24:55.154] - result already collected: FutureResult
[08:24:55.154] result() for ClusterFuture ... done
[08:24:55.154] result() for ClusterFuture ...
[08:24:55.154] - result already collected: FutureResult
[08:24:55.154] result() for ClusterFuture ... done
[08:24:55.154] result() for ClusterFuture ...
[08:24:55.154] - result already collected: FutureResult
[08:24:55.154] result() for ClusterFuture ... done
[08:24:55.154] result() for ClusterFuture ...
[08:24:55.154] - result already collected: FutureResult
[08:24:55.155] result() for ClusterFuture ... done
[08:24:55.155]  - Number of value chunks collected: 2
[08:24:55.155] Resolving 2 futures (chunks) ... DONE
[08:24:55.155] Reducing values from 2 chunks ...
[08:24:55.155]  - Number of values collected after concatenation: 6
[08:24:55.155]  - Number of values expected: 6
[08:24:55.155] Reducing values from 2 chunks ... DONE
[08:24:55.155] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[08:24:55.156] getGlobalsAndPackagesXApply() ...
[08:24:55.156]  - future.globals: TRUE
[08:24:55.156] getGlobalsAndPackages() ...
[08:24:55.156] Searching for globals...
[08:24:55.157] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[08:24:55.157] Searching for globals ... DONE
[08:24:55.157] Resolving globals: FALSE
[08:24:55.158] The total size of the 1 globals is 411 bytes (411 bytes)
[08:24:55.158] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 411 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (411 bytes of class ‘function’)
[08:24:55.158] - globals: [1] ‘FUN’
[08:24:55.158] 
[08:24:55.158] getGlobalsAndPackages() ... DONE
[08:24:55.159]  - globals found/used: [n=1] ‘FUN’
[08:24:55.159]  - needed namespaces: [n=0] 
[08:24:55.159] Finding globals ... DONE
[08:24:55.159]  - use_args: TRUE
[08:24:55.159]  - Getting '...' globals ...
[08:24:55.159] resolve() on list ...
[08:24:55.159]  recursive: 0
[08:24:55.159]  length: 1
[08:24:55.159]  elements: ‘...’
[08:24:55.160]  length: 0 (resolved future 1)
[08:24:55.160] resolve() on list ... DONE
[08:24:55.160]    - '...' content: [n=0] 
[08:24:55.160] List of 1
[08:24:55.160]  $ ...: list()
[08:24:55.160]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.160]  - attr(*, "where")=List of 1
[08:24:55.160]   ..$ ...:<environment: 0x56540fd105a0> 
[08:24:55.160]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.160]  - attr(*, "resolved")= logi TRUE
[08:24:55.160]  - attr(*, "total_size")= num NA
[08:24:55.162]  - Getting '...' globals ... DONE
[08:24:55.162] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:55.163] List of 2
[08:24:55.163]  $ ...future.FUN:function (x)  
[08:24:55.163]  $ ...          : list()
[08:24:55.163]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.163]  - attr(*, "where")=List of 2
[08:24:55.163]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:55.163]   ..$ ...          :<environment: 0x56540fd105a0> 
[08:24:55.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.163]  - attr(*, "resolved")= logi FALSE
[08:24:55.163]  - attr(*, "total_size")= num 3672
[08:24:55.165] Packages to be attached in all futures: [n=0] 
[08:24:55.165] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.167] future_lapply() ...
[08:24:55.169] Number of chunks: 2
[08:24:55.169] getGlobalsAndPackagesXApply() ...
[08:24:55.169]  - future.globals: <name-value list> with names ‘list()’
[08:24:55.169]  - use_args: TRUE
[08:24:55.169] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:55.169] List of 2
[08:24:55.169]  $ ...          : list()
[08:24:55.169]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.169]  $ ...future.FUN:function (x)  
[08:24:55.169]  - attr(*, "where")=List of 2
[08:24:55.169]   ..$ ...          :<environment: 0x56540fd105a0> 
[08:24:55.169]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[08:24:55.169]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.169]  - attr(*, "resolved")= logi FALSE
[08:24:55.169]  - attr(*, "total_size")= num NA
[08:24:55.172] Packages to be attached in all futures: [n=0] 
[08:24:55.172] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.172] Number of futures (= number of chunks): 2
[08:24:55.172] Launching 2 futures (chunks) ...
[08:24:55.173] Chunk #1 of 2 ...
[08:24:55.173]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.173]  - seeds: <none>
[08:24:55.173]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.173] getGlobalsAndPackages() ...
[08:24:55.173] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.173] Resolving globals: FALSE
[08:24:55.173] Tweak future expression to call with '...' arguments ...
[08:24:55.173] {
[08:24:55.173]     do.call(function(...) {
[08:24:55.173]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.173]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.173]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.173]             on.exit(options(oopts), add = TRUE)
[08:24:55.173]         }
[08:24:55.173]         {
[08:24:55.173]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.173]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.173]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.173]             })
[08:24:55.173]         }
[08:24:55.173]     }, args = future.call.arguments)
[08:24:55.173] }
[08:24:55.174] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.174] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.174] 
[08:24:55.174] getGlobalsAndPackages() ... DONE
[08:24:55.175] run() for ‘Future’ ...
[08:24:55.175] - state: ‘created’
[08:24:55.175] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.189] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.189] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.189]   - Field: ‘node’
[08:24:55.189]   - Field: ‘label’
[08:24:55.189]   - Field: ‘local’
[08:24:55.189]   - Field: ‘owner’
[08:24:55.189]   - Field: ‘envir’
[08:24:55.190]   - Field: ‘workers’
[08:24:55.190]   - Field: ‘packages’
[08:24:55.190]   - Field: ‘gc’
[08:24:55.190]   - Field: ‘conditions’
[08:24:55.190]   - Field: ‘persistent’
[08:24:55.190]   - Field: ‘expr’
[08:24:55.190]   - Field: ‘uuid’
[08:24:55.190]   - Field: ‘seed’
[08:24:55.190]   - Field: ‘version’
[08:24:55.190]   - Field: ‘result’
[08:24:55.190]   - Field: ‘asynchronous’
[08:24:55.191]   - Field: ‘calls’
[08:24:55.193]   - Field: ‘globals’
[08:24:55.193]   - Field: ‘stdout’
[08:24:55.193]   - Field: ‘earlySignal’
[08:24:55.193]   - Field: ‘lazy’
[08:24:55.193]   - Field: ‘state’
[08:24:55.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.193] - Launch lazy future ...
[08:24:55.194] Packages needed by the future expression (n = 0): <none>
[08:24:55.194] Packages needed by future strategies (n = 0): <none>
[08:24:55.194] {
[08:24:55.194]     {
[08:24:55.194]         {
[08:24:55.194]             ...future.startTime <- base::Sys.time()
[08:24:55.194]             {
[08:24:55.194]                 {
[08:24:55.194]                   {
[08:24:55.194]                     {
[08:24:55.194]                       base::local({
[08:24:55.194]                         has_future <- base::requireNamespace("future", 
[08:24:55.194]                           quietly = TRUE)
[08:24:55.194]                         if (has_future) {
[08:24:55.194]                           ns <- base::getNamespace("future")
[08:24:55.194]                           version <- ns[[".package"]][["version"]]
[08:24:55.194]                           if (is.null(version)) 
[08:24:55.194]                             version <- utils::packageVersion("future")
[08:24:55.194]                         }
[08:24:55.194]                         else {
[08:24:55.194]                           version <- NULL
[08:24:55.194]                         }
[08:24:55.194]                         if (!has_future || version < "1.8.0") {
[08:24:55.194]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.194]                             "", base::R.version$version.string), 
[08:24:55.194]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.194]                               "release", "version")], collapse = " "), 
[08:24:55.194]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.194]                             info)
[08:24:55.194]                           info <- base::paste(info, collapse = "; ")
[08:24:55.194]                           if (!has_future) {
[08:24:55.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.194]                               info)
[08:24:55.194]                           }
[08:24:55.194]                           else {
[08:24:55.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.194]                               info, version)
[08:24:55.194]                           }
[08:24:55.194]                           base::stop(msg)
[08:24:55.194]                         }
[08:24:55.194]                       })
[08:24:55.194]                     }
[08:24:55.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.194]                     base::options(mc.cores = 1L)
[08:24:55.194]                   }
[08:24:55.194]                   ...future.strategy.old <- future::plan("list")
[08:24:55.194]                   options(future.plan = NULL)
[08:24:55.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.194]                 }
[08:24:55.194]                 ...future.workdir <- getwd()
[08:24:55.194]             }
[08:24:55.194]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.194]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.194]         }
[08:24:55.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.194]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.194]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.194]             base::names(...future.oldOptions))
[08:24:55.194]     }
[08:24:55.194]     if (FALSE) {
[08:24:55.194]     }
[08:24:55.194]     else {
[08:24:55.194]         if (TRUE) {
[08:24:55.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.194]                 open = "w")
[08:24:55.194]         }
[08:24:55.194]         else {
[08:24:55.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.194]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.194]         }
[08:24:55.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.194]             base::sink(type = "output", split = FALSE)
[08:24:55.194]             base::close(...future.stdout)
[08:24:55.194]         }, add = TRUE)
[08:24:55.194]     }
[08:24:55.194]     ...future.frame <- base::sys.nframe()
[08:24:55.194]     ...future.conditions <- base::list()
[08:24:55.194]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.194]     if (FALSE) {
[08:24:55.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.194]     }
[08:24:55.194]     ...future.result <- base::tryCatch({
[08:24:55.194]         base::withCallingHandlers({
[08:24:55.194]             ...future.value <- base::withVisible(base::local({
[08:24:55.194]                 ...future.makeSendCondition <- base::local({
[08:24:55.194]                   sendCondition <- NULL
[08:24:55.194]                   function(frame = 1L) {
[08:24:55.194]                     if (is.function(sendCondition)) 
[08:24:55.194]                       return(sendCondition)
[08:24:55.194]                     ns <- getNamespace("parallel")
[08:24:55.194]                     if (exists("sendData", mode = "function", 
[08:24:55.194]                       envir = ns)) {
[08:24:55.194]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.194]                         envir = ns)
[08:24:55.194]                       envir <- sys.frame(frame)
[08:24:55.194]                       master <- NULL
[08:24:55.194]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.194]                         !identical(envir, emptyenv())) {
[08:24:55.194]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.194]                           inherits = FALSE)) {
[08:24:55.194]                           master <- get("master", mode = "list", 
[08:24:55.194]                             envir = envir, inherits = FALSE)
[08:24:55.194]                           if (inherits(master, c("SOCKnode", 
[08:24:55.194]                             "SOCK0node"))) {
[08:24:55.194]                             sendCondition <<- function(cond) {
[08:24:55.194]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.194]                                 success = TRUE)
[08:24:55.194]                               parallel_sendData(master, data)
[08:24:55.194]                             }
[08:24:55.194]                             return(sendCondition)
[08:24:55.194]                           }
[08:24:55.194]                         }
[08:24:55.194]                         frame <- frame + 1L
[08:24:55.194]                         envir <- sys.frame(frame)
[08:24:55.194]                       }
[08:24:55.194]                     }
[08:24:55.194]                     sendCondition <<- function(cond) NULL
[08:24:55.194]                   }
[08:24:55.194]                 })
[08:24:55.194]                 withCallingHandlers({
[08:24:55.194]                   {
[08:24:55.194]                     do.call(function(...) {
[08:24:55.194]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.194]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.194]                         ...future.globals.maxSize)) {
[08:24:55.194]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.194]                         on.exit(options(oopts), add = TRUE)
[08:24:55.194]                       }
[08:24:55.194]                       {
[08:24:55.194]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.194]                           FUN = function(jj) {
[08:24:55.194]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.194]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.194]                           })
[08:24:55.194]                       }
[08:24:55.194]                     }, args = future.call.arguments)
[08:24:55.194]                   }
[08:24:55.194]                 }, immediateCondition = function(cond) {
[08:24:55.194]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.194]                   sendCondition(cond)
[08:24:55.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.194]                   {
[08:24:55.194]                     inherits <- base::inherits
[08:24:55.194]                     invokeRestart <- base::invokeRestart
[08:24:55.194]                     is.null <- base::is.null
[08:24:55.194]                     muffled <- FALSE
[08:24:55.194]                     if (inherits(cond, "message")) {
[08:24:55.194]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.194]                       if (muffled) 
[08:24:55.194]                         invokeRestart("muffleMessage")
[08:24:55.194]                     }
[08:24:55.194]                     else if (inherits(cond, "warning")) {
[08:24:55.194]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.194]                       if (muffled) 
[08:24:55.194]                         invokeRestart("muffleWarning")
[08:24:55.194]                     }
[08:24:55.194]                     else if (inherits(cond, "condition")) {
[08:24:55.194]                       if (!is.null(pattern)) {
[08:24:55.194]                         computeRestarts <- base::computeRestarts
[08:24:55.194]                         grepl <- base::grepl
[08:24:55.194]                         restarts <- computeRestarts(cond)
[08:24:55.194]                         for (restart in restarts) {
[08:24:55.194]                           name <- restart$name
[08:24:55.194]                           if (is.null(name)) 
[08:24:55.194]                             next
[08:24:55.194]                           if (!grepl(pattern, name)) 
[08:24:55.194]                             next
[08:24:55.194]                           invokeRestart(restart)
[08:24:55.194]                           muffled <- TRUE
[08:24:55.194]                           break
[08:24:55.194]                         }
[08:24:55.194]                       }
[08:24:55.194]                     }
[08:24:55.194]                     invisible(muffled)
[08:24:55.194]                   }
[08:24:55.194]                   muffleCondition(cond)
[08:24:55.194]                 })
[08:24:55.194]             }))
[08:24:55.194]             future::FutureResult(value = ...future.value$value, 
[08:24:55.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.194]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.194]                     ...future.globalenv.names))
[08:24:55.194]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.194]         }, condition = base::local({
[08:24:55.194]             c <- base::c
[08:24:55.194]             inherits <- base::inherits
[08:24:55.194]             invokeRestart <- base::invokeRestart
[08:24:55.194]             length <- base::length
[08:24:55.194]             list <- base::list
[08:24:55.194]             seq.int <- base::seq.int
[08:24:55.194]             signalCondition <- base::signalCondition
[08:24:55.194]             sys.calls <- base::sys.calls
[08:24:55.194]             `[[` <- base::`[[`
[08:24:55.194]             `+` <- base::`+`
[08:24:55.194]             `<<-` <- base::`<<-`
[08:24:55.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.194]                   3L)]
[08:24:55.194]             }
[08:24:55.194]             function(cond) {
[08:24:55.194]                 is_error <- inherits(cond, "error")
[08:24:55.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.194]                   NULL)
[08:24:55.194]                 if (is_error) {
[08:24:55.194]                   sessionInformation <- function() {
[08:24:55.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.194]                       search = base::search(), system = base::Sys.info())
[08:24:55.194]                   }
[08:24:55.194]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.194]                     cond$call), session = sessionInformation(), 
[08:24:55.194]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.194]                   signalCondition(cond)
[08:24:55.194]                 }
[08:24:55.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.194]                 "immediateCondition"))) {
[08:24:55.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.194]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.194]                   if (TRUE && !signal) {
[08:24:55.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.194]                     {
[08:24:55.194]                       inherits <- base::inherits
[08:24:55.194]                       invokeRestart <- base::invokeRestart
[08:24:55.194]                       is.null <- base::is.null
[08:24:55.194]                       muffled <- FALSE
[08:24:55.194]                       if (inherits(cond, "message")) {
[08:24:55.194]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.194]                         if (muffled) 
[08:24:55.194]                           invokeRestart("muffleMessage")
[08:24:55.194]                       }
[08:24:55.194]                       else if (inherits(cond, "warning")) {
[08:24:55.194]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.194]                         if (muffled) 
[08:24:55.194]                           invokeRestart("muffleWarning")
[08:24:55.194]                       }
[08:24:55.194]                       else if (inherits(cond, "condition")) {
[08:24:55.194]                         if (!is.null(pattern)) {
[08:24:55.194]                           computeRestarts <- base::computeRestarts
[08:24:55.194]                           grepl <- base::grepl
[08:24:55.194]                           restarts <- computeRestarts(cond)
[08:24:55.194]                           for (restart in restarts) {
[08:24:55.194]                             name <- restart$name
[08:24:55.194]                             if (is.null(name)) 
[08:24:55.194]                               next
[08:24:55.194]                             if (!grepl(pattern, name)) 
[08:24:55.194]                               next
[08:24:55.194]                             invokeRestart(restart)
[08:24:55.194]                             muffled <- TRUE
[08:24:55.194]                             break
[08:24:55.194]                           }
[08:24:55.194]                         }
[08:24:55.194]                       }
[08:24:55.194]                       invisible(muffled)
[08:24:55.194]                     }
[08:24:55.194]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.194]                   }
[08:24:55.194]                 }
[08:24:55.194]                 else {
[08:24:55.194]                   if (TRUE) {
[08:24:55.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.194]                     {
[08:24:55.194]                       inherits <- base::inherits
[08:24:55.194]                       invokeRestart <- base::invokeRestart
[08:24:55.194]                       is.null <- base::is.null
[08:24:55.194]                       muffled <- FALSE
[08:24:55.194]                       if (inherits(cond, "message")) {
[08:24:55.194]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.194]                         if (muffled) 
[08:24:55.194]                           invokeRestart("muffleMessage")
[08:24:55.194]                       }
[08:24:55.194]                       else if (inherits(cond, "warning")) {
[08:24:55.194]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.194]                         if (muffled) 
[08:24:55.194]                           invokeRestart("muffleWarning")
[08:24:55.194]                       }
[08:24:55.194]                       else if (inherits(cond, "condition")) {
[08:24:55.194]                         if (!is.null(pattern)) {
[08:24:55.194]                           computeRestarts <- base::computeRestarts
[08:24:55.194]                           grepl <- base::grepl
[08:24:55.194]                           restarts <- computeRestarts(cond)
[08:24:55.194]                           for (restart in restarts) {
[08:24:55.194]                             name <- restart$name
[08:24:55.194]                             if (is.null(name)) 
[08:24:55.194]                               next
[08:24:55.194]                             if (!grepl(pattern, name)) 
[08:24:55.194]                               next
[08:24:55.194]                             invokeRestart(restart)
[08:24:55.194]                             muffled <- TRUE
[08:24:55.194]                             break
[08:24:55.194]                           }
[08:24:55.194]                         }
[08:24:55.194]                       }
[08:24:55.194]                       invisible(muffled)
[08:24:55.194]                     }
[08:24:55.194]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.194]                   }
[08:24:55.194]                 }
[08:24:55.194]             }
[08:24:55.194]         }))
[08:24:55.194]     }, error = function(ex) {
[08:24:55.194]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.194]                 ...future.rng), started = ...future.startTime, 
[08:24:55.194]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.194]             version = "1.8"), class = "FutureResult")
[08:24:55.194]     }, finally = {
[08:24:55.194]         if (!identical(...future.workdir, getwd())) 
[08:24:55.194]             setwd(...future.workdir)
[08:24:55.194]         {
[08:24:55.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.194]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.194]             }
[08:24:55.194]             base::options(...future.oldOptions)
[08:24:55.194]             if (.Platform$OS.type == "windows") {
[08:24:55.194]                 old_names <- names(...future.oldEnvVars)
[08:24:55.194]                 envs <- base::Sys.getenv()
[08:24:55.194]                 names <- names(envs)
[08:24:55.194]                 common <- intersect(names, old_names)
[08:24:55.194]                 added <- setdiff(names, old_names)
[08:24:55.194]                 removed <- setdiff(old_names, names)
[08:24:55.194]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.194]                   envs[common]]
[08:24:55.194]                 NAMES <- toupper(changed)
[08:24:55.194]                 args <- list()
[08:24:55.194]                 for (kk in seq_along(NAMES)) {
[08:24:55.194]                   name <- changed[[kk]]
[08:24:55.194]                   NAME <- NAMES[[kk]]
[08:24:55.194]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.194]                     next
[08:24:55.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.194]                 }
[08:24:55.194]                 NAMES <- toupper(added)
[08:24:55.194]                 for (kk in seq_along(NAMES)) {
[08:24:55.194]                   name <- added[[kk]]
[08:24:55.194]                   NAME <- NAMES[[kk]]
[08:24:55.194]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.194]                     next
[08:24:55.194]                   args[[name]] <- ""
[08:24:55.194]                 }
[08:24:55.194]                 NAMES <- toupper(removed)
[08:24:55.194]                 for (kk in seq_along(NAMES)) {
[08:24:55.194]                   name <- removed[[kk]]
[08:24:55.194]                   NAME <- NAMES[[kk]]
[08:24:55.194]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.194]                     next
[08:24:55.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.194]                 }
[08:24:55.194]                 if (length(args) > 0) 
[08:24:55.194]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.194]             }
[08:24:55.194]             else {
[08:24:55.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.194]             }
[08:24:55.194]             {
[08:24:55.194]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.194]                   0L) {
[08:24:55.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.194]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.194]                   base::options(opts)
[08:24:55.194]                 }
[08:24:55.194]                 {
[08:24:55.194]                   {
[08:24:55.194]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.194]                     NULL
[08:24:55.194]                   }
[08:24:55.194]                   options(future.plan = NULL)
[08:24:55.194]                   if (is.na(NA_character_)) 
[08:24:55.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.194]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.194]                     .init = FALSE)
[08:24:55.194]                 }
[08:24:55.194]             }
[08:24:55.194]         }
[08:24:55.194]     })
[08:24:55.194]     if (TRUE) {
[08:24:55.194]         base::sink(type = "output", split = FALSE)
[08:24:55.194]         if (TRUE) {
[08:24:55.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.194]         }
[08:24:55.194]         else {
[08:24:55.194]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.194]         }
[08:24:55.194]         base::close(...future.stdout)
[08:24:55.194]         ...future.stdout <- NULL
[08:24:55.194]     }
[08:24:55.194]     ...future.result$conditions <- ...future.conditions
[08:24:55.194]     ...future.result$finished <- base::Sys.time()
[08:24:55.194]     ...future.result
[08:24:55.194] }
[08:24:55.197] Exporting 5 global objects (1.11 KiB) to cluster node #1 ...
[08:24:55.197] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:55.198] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:55.198] Exporting ‘...future.FUN’ (411 bytes) to cluster node #1 ...
[08:24:55.198] Exporting ‘...future.FUN’ (411 bytes) to cluster node #1 ... DONE
[08:24:55.198] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ...
[08:24:55.199] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ... DONE
[08:24:55.199] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:55.199] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:55.199] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:55.200] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:55.200] Exporting 5 global objects (1.11 KiB) to cluster node #1 ... DONE
[08:24:55.200] MultisessionFuture started
[08:24:55.200] - Launch lazy future ... done
[08:24:55.200] run() for ‘MultisessionFuture’ ... done
[08:24:55.201] Created future:
[08:24:55.201] MultisessionFuture:
[08:24:55.201] Label: ‘future_apply-1’
[08:24:55.201] Expression:
[08:24:55.201] {
[08:24:55.201]     do.call(function(...) {
[08:24:55.201]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.201]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.201]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.201]             on.exit(options(oopts), add = TRUE)
[08:24:55.201]         }
[08:24:55.201]         {
[08:24:55.201]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.201]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.201]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.201]             })
[08:24:55.201]         }
[08:24:55.201]     }, args = future.call.arguments)
[08:24:55.201] }
[08:24:55.201] Lazy evaluation: FALSE
[08:24:55.201] Asynchronous evaluation: TRUE
[08:24:55.201] Local evaluation: TRUE
[08:24:55.201] Environment: R_GlobalEnv
[08:24:55.201] Capture standard output: TRUE
[08:24:55.201] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.201] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.201] Packages: <none>
[08:24:55.201] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.201] Resolved: FALSE
[08:24:55.201] Value: <not collected>
[08:24:55.201] Conditions captured: <none>
[08:24:55.201] Early signaling: FALSE
[08:24:55.201] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.201] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.212] Chunk #1 of 2 ... DONE
[08:24:55.212] Chunk #2 of 2 ...
[08:24:55.212]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.213]  - seeds: <none>
[08:24:55.213]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.213] getGlobalsAndPackages() ...
[08:24:55.213] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.213] Resolving globals: FALSE
[08:24:55.213] Tweak future expression to call with '...' arguments ...
[08:24:55.213] {
[08:24:55.213]     do.call(function(...) {
[08:24:55.213]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.213]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.213]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.213]             on.exit(options(oopts), add = TRUE)
[08:24:55.213]         }
[08:24:55.213]         {
[08:24:55.213]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.213]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.213]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.213]             })
[08:24:55.213]         }
[08:24:55.213]     }, args = future.call.arguments)
[08:24:55.213] }
[08:24:55.213] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.214] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.214] 
[08:24:55.214] getGlobalsAndPackages() ... DONE
[08:24:55.214] run() for ‘Future’ ...
[08:24:55.214] - state: ‘created’
[08:24:55.215] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.228] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.228]   - Field: ‘node’
[08:24:55.229]   - Field: ‘label’
[08:24:55.229]   - Field: ‘local’
[08:24:55.229]   - Field: ‘owner’
[08:24:55.229]   - Field: ‘envir’
[08:24:55.229]   - Field: ‘workers’
[08:24:55.229]   - Field: ‘packages’
[08:24:55.229]   - Field: ‘gc’
[08:24:55.229]   - Field: ‘conditions’
[08:24:55.229]   - Field: ‘persistent’
[08:24:55.229]   - Field: ‘expr’
[08:24:55.229]   - Field: ‘uuid’
[08:24:55.229]   - Field: ‘seed’
[08:24:55.230]   - Field: ‘version’
[08:24:55.230]   - Field: ‘result’
[08:24:55.230]   - Field: ‘asynchronous’
[08:24:55.230]   - Field: ‘calls’
[08:24:55.230]   - Field: ‘globals’
[08:24:55.230]   - Field: ‘stdout’
[08:24:55.230]   - Field: ‘earlySignal’
[08:24:55.230]   - Field: ‘lazy’
[08:24:55.230]   - Field: ‘state’
[08:24:55.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.230] - Launch lazy future ...
[08:24:55.231] Packages needed by the future expression (n = 0): <none>
[08:24:55.231] Packages needed by future strategies (n = 0): <none>
[08:24:55.231] {
[08:24:55.231]     {
[08:24:55.231]         {
[08:24:55.231]             ...future.startTime <- base::Sys.time()
[08:24:55.231]             {
[08:24:55.231]                 {
[08:24:55.231]                   {
[08:24:55.231]                     {
[08:24:55.231]                       base::local({
[08:24:55.231]                         has_future <- base::requireNamespace("future", 
[08:24:55.231]                           quietly = TRUE)
[08:24:55.231]                         if (has_future) {
[08:24:55.231]                           ns <- base::getNamespace("future")
[08:24:55.231]                           version <- ns[[".package"]][["version"]]
[08:24:55.231]                           if (is.null(version)) 
[08:24:55.231]                             version <- utils::packageVersion("future")
[08:24:55.231]                         }
[08:24:55.231]                         else {
[08:24:55.231]                           version <- NULL
[08:24:55.231]                         }
[08:24:55.231]                         if (!has_future || version < "1.8.0") {
[08:24:55.231]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.231]                             "", base::R.version$version.string), 
[08:24:55.231]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.231]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.231]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.231]                               "release", "version")], collapse = " "), 
[08:24:55.231]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.231]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.231]                             info)
[08:24:55.231]                           info <- base::paste(info, collapse = "; ")
[08:24:55.231]                           if (!has_future) {
[08:24:55.231]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.231]                               info)
[08:24:55.231]                           }
[08:24:55.231]                           else {
[08:24:55.231]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.231]                               info, version)
[08:24:55.231]                           }
[08:24:55.231]                           base::stop(msg)
[08:24:55.231]                         }
[08:24:55.231]                       })
[08:24:55.231]                     }
[08:24:55.231]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.231]                     base::options(mc.cores = 1L)
[08:24:55.231]                   }
[08:24:55.231]                   ...future.strategy.old <- future::plan("list")
[08:24:55.231]                   options(future.plan = NULL)
[08:24:55.231]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.231]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.231]                 }
[08:24:55.231]                 ...future.workdir <- getwd()
[08:24:55.231]             }
[08:24:55.231]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.231]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.231]         }
[08:24:55.231]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.231]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.231]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.231]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.231]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.231]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.231]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.231]             base::names(...future.oldOptions))
[08:24:55.231]     }
[08:24:55.231]     if (FALSE) {
[08:24:55.231]     }
[08:24:55.231]     else {
[08:24:55.231]         if (TRUE) {
[08:24:55.231]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.231]                 open = "w")
[08:24:55.231]         }
[08:24:55.231]         else {
[08:24:55.231]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.231]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.231]         }
[08:24:55.231]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.231]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.231]             base::sink(type = "output", split = FALSE)
[08:24:55.231]             base::close(...future.stdout)
[08:24:55.231]         }, add = TRUE)
[08:24:55.231]     }
[08:24:55.231]     ...future.frame <- base::sys.nframe()
[08:24:55.231]     ...future.conditions <- base::list()
[08:24:55.231]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.231]     if (FALSE) {
[08:24:55.231]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.231]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.231]     }
[08:24:55.231]     ...future.result <- base::tryCatch({
[08:24:55.231]         base::withCallingHandlers({
[08:24:55.231]             ...future.value <- base::withVisible(base::local({
[08:24:55.231]                 ...future.makeSendCondition <- base::local({
[08:24:55.231]                   sendCondition <- NULL
[08:24:55.231]                   function(frame = 1L) {
[08:24:55.231]                     if (is.function(sendCondition)) 
[08:24:55.231]                       return(sendCondition)
[08:24:55.231]                     ns <- getNamespace("parallel")
[08:24:55.231]                     if (exists("sendData", mode = "function", 
[08:24:55.231]                       envir = ns)) {
[08:24:55.231]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.231]                         envir = ns)
[08:24:55.231]                       envir <- sys.frame(frame)
[08:24:55.231]                       master <- NULL
[08:24:55.231]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.231]                         !identical(envir, emptyenv())) {
[08:24:55.231]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.231]                           inherits = FALSE)) {
[08:24:55.231]                           master <- get("master", mode = "list", 
[08:24:55.231]                             envir = envir, inherits = FALSE)
[08:24:55.231]                           if (inherits(master, c("SOCKnode", 
[08:24:55.231]                             "SOCK0node"))) {
[08:24:55.231]                             sendCondition <<- function(cond) {
[08:24:55.231]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.231]                                 success = TRUE)
[08:24:55.231]                               parallel_sendData(master, data)
[08:24:55.231]                             }
[08:24:55.231]                             return(sendCondition)
[08:24:55.231]                           }
[08:24:55.231]                         }
[08:24:55.231]                         frame <- frame + 1L
[08:24:55.231]                         envir <- sys.frame(frame)
[08:24:55.231]                       }
[08:24:55.231]                     }
[08:24:55.231]                     sendCondition <<- function(cond) NULL
[08:24:55.231]                   }
[08:24:55.231]                 })
[08:24:55.231]                 withCallingHandlers({
[08:24:55.231]                   {
[08:24:55.231]                     do.call(function(...) {
[08:24:55.231]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.231]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.231]                         ...future.globals.maxSize)) {
[08:24:55.231]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.231]                         on.exit(options(oopts), add = TRUE)
[08:24:55.231]                       }
[08:24:55.231]                       {
[08:24:55.231]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.231]                           FUN = function(jj) {
[08:24:55.231]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.231]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.231]                           })
[08:24:55.231]                       }
[08:24:55.231]                     }, args = future.call.arguments)
[08:24:55.231]                   }
[08:24:55.231]                 }, immediateCondition = function(cond) {
[08:24:55.231]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.231]                   sendCondition(cond)
[08:24:55.231]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.231]                   {
[08:24:55.231]                     inherits <- base::inherits
[08:24:55.231]                     invokeRestart <- base::invokeRestart
[08:24:55.231]                     is.null <- base::is.null
[08:24:55.231]                     muffled <- FALSE
[08:24:55.231]                     if (inherits(cond, "message")) {
[08:24:55.231]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.231]                       if (muffled) 
[08:24:55.231]                         invokeRestart("muffleMessage")
[08:24:55.231]                     }
[08:24:55.231]                     else if (inherits(cond, "warning")) {
[08:24:55.231]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.231]                       if (muffled) 
[08:24:55.231]                         invokeRestart("muffleWarning")
[08:24:55.231]                     }
[08:24:55.231]                     else if (inherits(cond, "condition")) {
[08:24:55.231]                       if (!is.null(pattern)) {
[08:24:55.231]                         computeRestarts <- base::computeRestarts
[08:24:55.231]                         grepl <- base::grepl
[08:24:55.231]                         restarts <- computeRestarts(cond)
[08:24:55.231]                         for (restart in restarts) {
[08:24:55.231]                           name <- restart$name
[08:24:55.231]                           if (is.null(name)) 
[08:24:55.231]                             next
[08:24:55.231]                           if (!grepl(pattern, name)) 
[08:24:55.231]                             next
[08:24:55.231]                           invokeRestart(restart)
[08:24:55.231]                           muffled <- TRUE
[08:24:55.231]                           break
[08:24:55.231]                         }
[08:24:55.231]                       }
[08:24:55.231]                     }
[08:24:55.231]                     invisible(muffled)
[08:24:55.231]                   }
[08:24:55.231]                   muffleCondition(cond)
[08:24:55.231]                 })
[08:24:55.231]             }))
[08:24:55.231]             future::FutureResult(value = ...future.value$value, 
[08:24:55.231]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.231]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.231]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.231]                     ...future.globalenv.names))
[08:24:55.231]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.231]         }, condition = base::local({
[08:24:55.231]             c <- base::c
[08:24:55.231]             inherits <- base::inherits
[08:24:55.231]             invokeRestart <- base::invokeRestart
[08:24:55.231]             length <- base::length
[08:24:55.231]             list <- base::list
[08:24:55.231]             seq.int <- base::seq.int
[08:24:55.231]             signalCondition <- base::signalCondition
[08:24:55.231]             sys.calls <- base::sys.calls
[08:24:55.231]             `[[` <- base::`[[`
[08:24:55.231]             `+` <- base::`+`
[08:24:55.231]             `<<-` <- base::`<<-`
[08:24:55.231]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.231]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.231]                   3L)]
[08:24:55.231]             }
[08:24:55.231]             function(cond) {
[08:24:55.231]                 is_error <- inherits(cond, "error")
[08:24:55.231]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.231]                   NULL)
[08:24:55.231]                 if (is_error) {
[08:24:55.231]                   sessionInformation <- function() {
[08:24:55.231]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.231]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.231]                       search = base::search(), system = base::Sys.info())
[08:24:55.231]                   }
[08:24:55.231]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.231]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.231]                     cond$call), session = sessionInformation(), 
[08:24:55.231]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.231]                   signalCondition(cond)
[08:24:55.231]                 }
[08:24:55.231]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.231]                 "immediateCondition"))) {
[08:24:55.231]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.231]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.231]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.231]                   if (TRUE && !signal) {
[08:24:55.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.231]                     {
[08:24:55.231]                       inherits <- base::inherits
[08:24:55.231]                       invokeRestart <- base::invokeRestart
[08:24:55.231]                       is.null <- base::is.null
[08:24:55.231]                       muffled <- FALSE
[08:24:55.231]                       if (inherits(cond, "message")) {
[08:24:55.231]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.231]                         if (muffled) 
[08:24:55.231]                           invokeRestart("muffleMessage")
[08:24:55.231]                       }
[08:24:55.231]                       else if (inherits(cond, "warning")) {
[08:24:55.231]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.231]                         if (muffled) 
[08:24:55.231]                           invokeRestart("muffleWarning")
[08:24:55.231]                       }
[08:24:55.231]                       else if (inherits(cond, "condition")) {
[08:24:55.231]                         if (!is.null(pattern)) {
[08:24:55.231]                           computeRestarts <- base::computeRestarts
[08:24:55.231]                           grepl <- base::grepl
[08:24:55.231]                           restarts <- computeRestarts(cond)
[08:24:55.231]                           for (restart in restarts) {
[08:24:55.231]                             name <- restart$name
[08:24:55.231]                             if (is.null(name)) 
[08:24:55.231]                               next
[08:24:55.231]                             if (!grepl(pattern, name)) 
[08:24:55.231]                               next
[08:24:55.231]                             invokeRestart(restart)
[08:24:55.231]                             muffled <- TRUE
[08:24:55.231]                             break
[08:24:55.231]                           }
[08:24:55.231]                         }
[08:24:55.231]                       }
[08:24:55.231]                       invisible(muffled)
[08:24:55.231]                     }
[08:24:55.231]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.231]                   }
[08:24:55.231]                 }
[08:24:55.231]                 else {
[08:24:55.231]                   if (TRUE) {
[08:24:55.231]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.231]                     {
[08:24:55.231]                       inherits <- base::inherits
[08:24:55.231]                       invokeRestart <- base::invokeRestart
[08:24:55.231]                       is.null <- base::is.null
[08:24:55.231]                       muffled <- FALSE
[08:24:55.231]                       if (inherits(cond, "message")) {
[08:24:55.231]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.231]                         if (muffled) 
[08:24:55.231]                           invokeRestart("muffleMessage")
[08:24:55.231]                       }
[08:24:55.231]                       else if (inherits(cond, "warning")) {
[08:24:55.231]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.231]                         if (muffled) 
[08:24:55.231]                           invokeRestart("muffleWarning")
[08:24:55.231]                       }
[08:24:55.231]                       else if (inherits(cond, "condition")) {
[08:24:55.231]                         if (!is.null(pattern)) {
[08:24:55.231]                           computeRestarts <- base::computeRestarts
[08:24:55.231]                           grepl <- base::grepl
[08:24:55.231]                           restarts <- computeRestarts(cond)
[08:24:55.231]                           for (restart in restarts) {
[08:24:55.231]                             name <- restart$name
[08:24:55.231]                             if (is.null(name)) 
[08:24:55.231]                               next
[08:24:55.231]                             if (!grepl(pattern, name)) 
[08:24:55.231]                               next
[08:24:55.231]                             invokeRestart(restart)
[08:24:55.231]                             muffled <- TRUE
[08:24:55.231]                             break
[08:24:55.231]                           }
[08:24:55.231]                         }
[08:24:55.231]                       }
[08:24:55.231]                       invisible(muffled)
[08:24:55.231]                     }
[08:24:55.231]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.231]                   }
[08:24:55.231]                 }
[08:24:55.231]             }
[08:24:55.231]         }))
[08:24:55.231]     }, error = function(ex) {
[08:24:55.231]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.231]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.231]                 ...future.rng), started = ...future.startTime, 
[08:24:55.231]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.231]             version = "1.8"), class = "FutureResult")
[08:24:55.231]     }, finally = {
[08:24:55.231]         if (!identical(...future.workdir, getwd())) 
[08:24:55.231]             setwd(...future.workdir)
[08:24:55.231]         {
[08:24:55.231]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.231]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.231]             }
[08:24:55.231]             base::options(...future.oldOptions)
[08:24:55.231]             if (.Platform$OS.type == "windows") {
[08:24:55.231]                 old_names <- names(...future.oldEnvVars)
[08:24:55.231]                 envs <- base::Sys.getenv()
[08:24:55.231]                 names <- names(envs)
[08:24:55.231]                 common <- intersect(names, old_names)
[08:24:55.231]                 added <- setdiff(names, old_names)
[08:24:55.231]                 removed <- setdiff(old_names, names)
[08:24:55.231]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.231]                   envs[common]]
[08:24:55.231]                 NAMES <- toupper(changed)
[08:24:55.231]                 args <- list()
[08:24:55.231]                 for (kk in seq_along(NAMES)) {
[08:24:55.231]                   name <- changed[[kk]]
[08:24:55.231]                   NAME <- NAMES[[kk]]
[08:24:55.231]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.231]                     next
[08:24:55.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.231]                 }
[08:24:55.231]                 NAMES <- toupper(added)
[08:24:55.231]                 for (kk in seq_along(NAMES)) {
[08:24:55.231]                   name <- added[[kk]]
[08:24:55.231]                   NAME <- NAMES[[kk]]
[08:24:55.231]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.231]                     next
[08:24:55.231]                   args[[name]] <- ""
[08:24:55.231]                 }
[08:24:55.231]                 NAMES <- toupper(removed)
[08:24:55.231]                 for (kk in seq_along(NAMES)) {
[08:24:55.231]                   name <- removed[[kk]]
[08:24:55.231]                   NAME <- NAMES[[kk]]
[08:24:55.231]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.231]                     next
[08:24:55.231]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.231]                 }
[08:24:55.231]                 if (length(args) > 0) 
[08:24:55.231]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.231]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.231]             }
[08:24:55.231]             else {
[08:24:55.231]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.231]             }
[08:24:55.231]             {
[08:24:55.231]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.231]                   0L) {
[08:24:55.231]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.231]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.231]                   base::options(opts)
[08:24:55.231]                 }
[08:24:55.231]                 {
[08:24:55.231]                   {
[08:24:55.231]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.231]                     NULL
[08:24:55.231]                   }
[08:24:55.231]                   options(future.plan = NULL)
[08:24:55.231]                   if (is.na(NA_character_)) 
[08:24:55.231]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.231]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.231]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.231]                     .init = FALSE)
[08:24:55.231]                 }
[08:24:55.231]             }
[08:24:55.231]         }
[08:24:55.231]     })
[08:24:55.231]     if (TRUE) {
[08:24:55.231]         base::sink(type = "output", split = FALSE)
[08:24:55.231]         if (TRUE) {
[08:24:55.231]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.231]         }
[08:24:55.231]         else {
[08:24:55.231]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.231]         }
[08:24:55.231]         base::close(...future.stdout)
[08:24:55.231]         ...future.stdout <- NULL
[08:24:55.231]     }
[08:24:55.231]     ...future.result$conditions <- ...future.conditions
[08:24:55.231]     ...future.result$finished <- base::Sys.time()
[08:24:55.231]     ...future.result
[08:24:55.231] }
[08:24:55.234] Exporting 5 global objects (1.11 KiB) to cluster node #2 ...
[08:24:55.234] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:55.235] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:55.235] Exporting ‘...future.FUN’ (411 bytes) to cluster node #2 ...
[08:24:55.235] Exporting ‘...future.FUN’ (411 bytes) to cluster node #2 ... DONE
[08:24:55.235] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ...
[08:24:55.236] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ... DONE
[08:24:55.236] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:55.236] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:55.236] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:55.237] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:55.237] Exporting 5 global objects (1.11 KiB) to cluster node #2 ... DONE
[08:24:55.237] MultisessionFuture started
[08:24:55.238] - Launch lazy future ... done
[08:24:55.238] run() for ‘MultisessionFuture’ ... done
[08:24:55.238] Created future:
[08:24:55.238] MultisessionFuture:
[08:24:55.238] Label: ‘future_apply-2’
[08:24:55.238] Expression:
[08:24:55.238] {
[08:24:55.238]     do.call(function(...) {
[08:24:55.238]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.238]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.238]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.238]             on.exit(options(oopts), add = TRUE)
[08:24:55.238]         }
[08:24:55.238]         {
[08:24:55.238]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.238]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.238]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.238]             })
[08:24:55.238]         }
[08:24:55.238]     }, args = future.call.arguments)
[08:24:55.238] }
[08:24:55.238] Lazy evaluation: FALSE
[08:24:55.238] Asynchronous evaluation: TRUE
[08:24:55.238] Local evaluation: TRUE
[08:24:55.238] Environment: R_GlobalEnv
[08:24:55.238] Capture standard output: TRUE
[08:24:55.238] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.238] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.238] Packages: <none>
[08:24:55.238] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.238] Resolved: FALSE
[08:24:55.238] Value: <not collected>
[08:24:55.238] Conditions captured: <none>
[08:24:55.238] Early signaling: FALSE
[08:24:55.238] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.238] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.249] Chunk #2 of 2 ... DONE
[08:24:55.249] Launching 2 futures (chunks) ... DONE
[08:24:55.250] Resolving 2 futures (chunks) ...
[08:24:55.250] resolve() on list ...
[08:24:55.250]  recursive: 0
[08:24:55.250]  length: 2
[08:24:55.250] 
[08:24:55.250] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.251] - Validating connection of MultisessionFuture
[08:24:55.251] - received message: FutureResult
[08:24:55.251] - Received FutureResult
[08:24:55.251] - Erased future from FutureRegistry
[08:24:55.251] result() for ClusterFuture ...
[08:24:55.251] - result already collected: FutureResult
[08:24:55.251] result() for ClusterFuture ... done
[08:24:55.251] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.251] Future #1
[08:24:55.252] result() for ClusterFuture ...
[08:24:55.252] - result already collected: FutureResult
[08:24:55.252] result() for ClusterFuture ... done
[08:24:55.252] result() for ClusterFuture ...
[08:24:55.252] - result already collected: FutureResult
[08:24:55.252] result() for ClusterFuture ... done
[08:24:55.252] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:55.252] - nx: 2
[08:24:55.252] - relay: TRUE
[08:24:55.252] - stdout: TRUE
[08:24:55.252] - signal: TRUE
[08:24:55.252] - resignal: FALSE
[08:24:55.253] - force: TRUE
[08:24:55.253] - relayed: [n=2] FALSE, FALSE
[08:24:55.253] - queued futures: [n=2] FALSE, FALSE
[08:24:55.253]  - until=1
[08:24:55.253]  - relaying element #1
[08:24:55.253] result() for ClusterFuture ...
[08:24:55.253] - result already collected: FutureResult
[08:24:55.253] result() for ClusterFuture ... done
[08:24:55.253] result() for ClusterFuture ...
[08:24:55.253] - result already collected: FutureResult
[08:24:55.253] result() for ClusterFuture ... done
[08:24:55.253] result() for ClusterFuture ...
[08:24:55.254] - result already collected: FutureResult
[08:24:55.254] result() for ClusterFuture ... done
[08:24:55.254] result() for ClusterFuture ...
[08:24:55.254] - result already collected: FutureResult
[08:24:55.254] result() for ClusterFuture ... done
[08:24:55.254] - relayed: [n=2] TRUE, FALSE
[08:24:55.254] - queued futures: [n=2] TRUE, FALSE
[08:24:55.254] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:55.254]  length: 1 (resolved future 1)
[08:24:55.280] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.280] - Validating connection of MultisessionFuture
[08:24:55.281] - received message: FutureResult
[08:24:55.281] - Received FutureResult
[08:24:55.281] - Erased future from FutureRegistry
[08:24:55.281] result() for ClusterFuture ...
[08:24:55.281] - result already collected: FutureResult
[08:24:55.281] result() for ClusterFuture ... done
[08:24:55.281] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.281] Future #2
[08:24:55.281] result() for ClusterFuture ...
[08:24:55.281] - result already collected: FutureResult
[08:24:55.281] result() for ClusterFuture ... done
[08:24:55.282] result() for ClusterFuture ...
[08:24:55.282] - result already collected: FutureResult
[08:24:55.282] result() for ClusterFuture ... done
[08:24:55.282] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:55.282] - nx: 2
[08:24:55.282] - relay: TRUE
[08:24:55.282] - stdout: TRUE
[08:24:55.282] - signal: TRUE
[08:24:55.282] - resignal: FALSE
[08:24:55.282] - force: TRUE
[08:24:55.282] - relayed: [n=2] TRUE, FALSE
[08:24:55.282] - queued futures: [n=2] TRUE, FALSE
[08:24:55.283]  - until=2
[08:24:55.283]  - relaying element #2
[08:24:55.283] result() for ClusterFuture ...
[08:24:55.283] - result already collected: FutureResult
[08:24:55.283] result() for ClusterFuture ... done
[08:24:55.283] result() for ClusterFuture ...
[08:24:55.283] - result already collected: FutureResult
[08:24:55.283] result() for ClusterFuture ... done
[08:24:55.283] result() for ClusterFuture ...
[08:24:55.283] - result already collected: FutureResult
[08:24:55.283] result() for ClusterFuture ... done
[08:24:55.284] result() for ClusterFuture ...
[08:24:55.284] - result already collected: FutureResult
[08:24:55.284] result() for ClusterFuture ... done
[08:24:55.284] - relayed: [n=2] TRUE, TRUE
[08:24:55.284] - queued futures: [n=2] TRUE, TRUE
[08:24:55.284] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:55.284]  length: 0 (resolved future 2)
[08:24:55.284] Relaying remaining futures
[08:24:55.284] signalConditionsASAP(NULL, pos=0) ...
[08:24:55.284] - nx: 2
[08:24:55.284] - relay: TRUE
[08:24:55.284] - stdout: TRUE
[08:24:55.285] - signal: TRUE
[08:24:55.285] - resignal: FALSE
[08:24:55.285] - force: TRUE
[08:24:55.285] - relayed: [n=2] TRUE, TRUE
[08:24:55.285] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:55.285] - relayed: [n=2] TRUE, TRUE
[08:24:55.285] - queued futures: [n=2] TRUE, TRUE
[08:24:55.285] signalConditionsASAP(NULL, pos=0) ... done
[08:24:55.285] resolve() on list ... DONE
[08:24:55.285] result() for ClusterFuture ...
[08:24:55.285] - result already collected: FutureResult
[08:24:55.285] result() for ClusterFuture ... done
[08:24:55.286] result() for ClusterFuture ...
[08:24:55.286] - result already collected: FutureResult
[08:24:55.286] result() for ClusterFuture ... done
[08:24:55.286] result() for ClusterFuture ...
[08:24:55.286] - result already collected: FutureResult
[08:24:55.286] result() for ClusterFuture ... done
[08:24:55.286] result() for ClusterFuture ...
[08:24:55.286] - result already collected: FutureResult
[08:24:55.286] result() for ClusterFuture ... done
[08:24:55.286]  - Number of value chunks collected: 2
[08:24:55.286] Resolving 2 futures (chunks) ... DONE
[08:24:55.287] Reducing values from 2 chunks ...
[08:24:55.287]  - Number of values collected after concatenation: 6
[08:24:55.287]  - Number of values expected: 6
[08:24:55.287] Reducing values from 2 chunks ... DONE
[08:24:55.287] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[08:24:55.287] getGlobalsAndPackagesXApply() ...
[08:24:55.287]  - future.globals: TRUE
[08:24:55.287] getGlobalsAndPackages() ...
[08:24:55.287] Searching for globals...
[08:24:55.289] - globals found: [1] ‘FUN’
[08:24:55.289] Searching for globals ... DONE
[08:24:55.289] Resolving globals: FALSE
[08:24:55.289] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:55.289] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:55.290] - globals: [1] ‘FUN’
[08:24:55.290] 
[08:24:55.290] getGlobalsAndPackages() ... DONE
[08:24:55.290]  - globals found/used: [n=1] ‘FUN’
[08:24:55.290]  - needed namespaces: [n=0] 
[08:24:55.290] Finding globals ... DONE
[08:24:55.290]  - use_args: TRUE
[08:24:55.290]  - Getting '...' globals ...
[08:24:55.290] resolve() on list ...
[08:24:55.291]  recursive: 0
[08:24:55.291]  length: 1
[08:24:55.291]  elements: ‘...’
[08:24:55.291]  length: 0 (resolved future 1)
[08:24:55.291] resolve() on list ... DONE
[08:24:55.291]    - '...' content: [n=0] 
[08:24:55.291] List of 1
[08:24:55.291]  $ ...: list()
[08:24:55.291]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.291]  - attr(*, "where")=List of 1
[08:24:55.291]   ..$ ...:<environment: 0x56540f1f9d30> 
[08:24:55.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.291]  - attr(*, "resolved")= logi TRUE
[08:24:55.291]  - attr(*, "total_size")= num NA
[08:24:55.294]  - Getting '...' globals ... DONE
[08:24:55.294] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:55.294] List of 2
[08:24:55.294]  $ ...future.FUN:function (x)  
[08:24:55.294]  $ ...          : list()
[08:24:55.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.294]  - attr(*, "where")=List of 2
[08:24:55.294]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:55.294]   ..$ ...          :<environment: 0x56540f1f9d30> 
[08:24:55.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.294]  - attr(*, "resolved")= logi FALSE
[08:24:55.294]  - attr(*, "total_size")= num 2547
[08:24:55.296] Packages to be attached in all futures: [n=0] 
[08:24:55.297] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.298] future_lapply() ...
[08:24:55.300] Number of chunks: 2
[08:24:55.300] getGlobalsAndPackagesXApply() ...
[08:24:55.300]  - future.globals: <name-value list> with names ‘list()’
[08:24:55.300]  - use_args: TRUE
[08:24:55.300] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:55.301] List of 2
[08:24:55.301]  $ ...          : list()
[08:24:55.301]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.301]  $ ...future.FUN:function (x)  
[08:24:55.301]  - attr(*, "where")=List of 2
[08:24:55.301]   ..$ ...          :<environment: 0x56540f1f9d30> 
[08:24:55.301]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:55.301]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.301]  - attr(*, "resolved")= logi FALSE
[08:24:55.301]  - attr(*, "total_size")= num NA
[08:24:55.304] Packages to be attached in all futures: [n=0] 
[08:24:55.304] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.304] Number of futures (= number of chunks): 2
[08:24:55.304] Launching 2 futures (chunks) ...
[08:24:55.305] Chunk #1 of 2 ...
[08:24:55.305]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.305]  - seeds: <none>
[08:24:55.305]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.305] getGlobalsAndPackages() ...
[08:24:55.305] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.305] Resolving globals: FALSE
[08:24:55.305] Tweak future expression to call with '...' arguments ...
[08:24:55.305] {
[08:24:55.305]     do.call(function(...) {
[08:24:55.305]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.305]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.305]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.305]             on.exit(options(oopts), add = TRUE)
[08:24:55.305]         }
[08:24:55.305]         {
[08:24:55.305]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.305]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.305]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.305]             })
[08:24:55.305]         }
[08:24:55.305]     }, args = future.call.arguments)
[08:24:55.305] }
[08:24:55.306] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.306] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.306] 
[08:24:55.306] getGlobalsAndPackages() ... DONE
[08:24:55.307] run() for ‘Future’ ...
[08:24:55.307] - state: ‘created’
[08:24:55.307] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.321] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.321] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.321]   - Field: ‘node’
[08:24:55.321]   - Field: ‘label’
[08:24:55.321]   - Field: ‘local’
[08:24:55.321]   - Field: ‘owner’
[08:24:55.321]   - Field: ‘envir’
[08:24:55.322]   - Field: ‘workers’
[08:24:55.322]   - Field: ‘packages’
[08:24:55.322]   - Field: ‘gc’
[08:24:55.322]   - Field: ‘conditions’
[08:24:55.322]   - Field: ‘persistent’
[08:24:55.322]   - Field: ‘expr’
[08:24:55.322]   - Field: ‘uuid’
[08:24:55.322]   - Field: ‘seed’
[08:24:55.322]   - Field: ‘version’
[08:24:55.322]   - Field: ‘result’
[08:24:55.322]   - Field: ‘asynchronous’
[08:24:55.323]   - Field: ‘calls’
[08:24:55.323]   - Field: ‘globals’
[08:24:55.323]   - Field: ‘stdout’
[08:24:55.323]   - Field: ‘earlySignal’
[08:24:55.323]   - Field: ‘lazy’
[08:24:55.323]   - Field: ‘state’
[08:24:55.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.323] - Launch lazy future ...
[08:24:55.323] Packages needed by the future expression (n = 0): <none>
[08:24:55.324] Packages needed by future strategies (n = 0): <none>
[08:24:55.324] {
[08:24:55.324]     {
[08:24:55.324]         {
[08:24:55.324]             ...future.startTime <- base::Sys.time()
[08:24:55.324]             {
[08:24:55.324]                 {
[08:24:55.324]                   {
[08:24:55.324]                     {
[08:24:55.324]                       base::local({
[08:24:55.324]                         has_future <- base::requireNamespace("future", 
[08:24:55.324]                           quietly = TRUE)
[08:24:55.324]                         if (has_future) {
[08:24:55.324]                           ns <- base::getNamespace("future")
[08:24:55.324]                           version <- ns[[".package"]][["version"]]
[08:24:55.324]                           if (is.null(version)) 
[08:24:55.324]                             version <- utils::packageVersion("future")
[08:24:55.324]                         }
[08:24:55.324]                         else {
[08:24:55.324]                           version <- NULL
[08:24:55.324]                         }
[08:24:55.324]                         if (!has_future || version < "1.8.0") {
[08:24:55.324]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.324]                             "", base::R.version$version.string), 
[08:24:55.324]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.324]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.324]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.324]                               "release", "version")], collapse = " "), 
[08:24:55.324]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.324]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.324]                             info)
[08:24:55.324]                           info <- base::paste(info, collapse = "; ")
[08:24:55.324]                           if (!has_future) {
[08:24:55.324]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.324]                               info)
[08:24:55.324]                           }
[08:24:55.324]                           else {
[08:24:55.324]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.324]                               info, version)
[08:24:55.324]                           }
[08:24:55.324]                           base::stop(msg)
[08:24:55.324]                         }
[08:24:55.324]                       })
[08:24:55.324]                     }
[08:24:55.324]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.324]                     base::options(mc.cores = 1L)
[08:24:55.324]                   }
[08:24:55.324]                   ...future.strategy.old <- future::plan("list")
[08:24:55.324]                   options(future.plan = NULL)
[08:24:55.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.324]                 }
[08:24:55.324]                 ...future.workdir <- getwd()
[08:24:55.324]             }
[08:24:55.324]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.324]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.324]         }
[08:24:55.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.324]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.324]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.324]             base::names(...future.oldOptions))
[08:24:55.324]     }
[08:24:55.324]     if (FALSE) {
[08:24:55.324]     }
[08:24:55.324]     else {
[08:24:55.324]         if (TRUE) {
[08:24:55.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.324]                 open = "w")
[08:24:55.324]         }
[08:24:55.324]         else {
[08:24:55.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.324]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.324]         }
[08:24:55.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.324]             base::sink(type = "output", split = FALSE)
[08:24:55.324]             base::close(...future.stdout)
[08:24:55.324]         }, add = TRUE)
[08:24:55.324]     }
[08:24:55.324]     ...future.frame <- base::sys.nframe()
[08:24:55.324]     ...future.conditions <- base::list()
[08:24:55.324]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.324]     if (FALSE) {
[08:24:55.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.324]     }
[08:24:55.324]     ...future.result <- base::tryCatch({
[08:24:55.324]         base::withCallingHandlers({
[08:24:55.324]             ...future.value <- base::withVisible(base::local({
[08:24:55.324]                 ...future.makeSendCondition <- base::local({
[08:24:55.324]                   sendCondition <- NULL
[08:24:55.324]                   function(frame = 1L) {
[08:24:55.324]                     if (is.function(sendCondition)) 
[08:24:55.324]                       return(sendCondition)
[08:24:55.324]                     ns <- getNamespace("parallel")
[08:24:55.324]                     if (exists("sendData", mode = "function", 
[08:24:55.324]                       envir = ns)) {
[08:24:55.324]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.324]                         envir = ns)
[08:24:55.324]                       envir <- sys.frame(frame)
[08:24:55.324]                       master <- NULL
[08:24:55.324]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.324]                         !identical(envir, emptyenv())) {
[08:24:55.324]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.324]                           inherits = FALSE)) {
[08:24:55.324]                           master <- get("master", mode = "list", 
[08:24:55.324]                             envir = envir, inherits = FALSE)
[08:24:55.324]                           if (inherits(master, c("SOCKnode", 
[08:24:55.324]                             "SOCK0node"))) {
[08:24:55.324]                             sendCondition <<- function(cond) {
[08:24:55.324]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.324]                                 success = TRUE)
[08:24:55.324]                               parallel_sendData(master, data)
[08:24:55.324]                             }
[08:24:55.324]                             return(sendCondition)
[08:24:55.324]                           }
[08:24:55.324]                         }
[08:24:55.324]                         frame <- frame + 1L
[08:24:55.324]                         envir <- sys.frame(frame)
[08:24:55.324]                       }
[08:24:55.324]                     }
[08:24:55.324]                     sendCondition <<- function(cond) NULL
[08:24:55.324]                   }
[08:24:55.324]                 })
[08:24:55.324]                 withCallingHandlers({
[08:24:55.324]                   {
[08:24:55.324]                     do.call(function(...) {
[08:24:55.324]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.324]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.324]                         ...future.globals.maxSize)) {
[08:24:55.324]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.324]                         on.exit(options(oopts), add = TRUE)
[08:24:55.324]                       }
[08:24:55.324]                       {
[08:24:55.324]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.324]                           FUN = function(jj) {
[08:24:55.324]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.324]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.324]                           })
[08:24:55.324]                       }
[08:24:55.324]                     }, args = future.call.arguments)
[08:24:55.324]                   }
[08:24:55.324]                 }, immediateCondition = function(cond) {
[08:24:55.324]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.324]                   sendCondition(cond)
[08:24:55.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.324]                   {
[08:24:55.324]                     inherits <- base::inherits
[08:24:55.324]                     invokeRestart <- base::invokeRestart
[08:24:55.324]                     is.null <- base::is.null
[08:24:55.324]                     muffled <- FALSE
[08:24:55.324]                     if (inherits(cond, "message")) {
[08:24:55.324]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.324]                       if (muffled) 
[08:24:55.324]                         invokeRestart("muffleMessage")
[08:24:55.324]                     }
[08:24:55.324]                     else if (inherits(cond, "warning")) {
[08:24:55.324]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.324]                       if (muffled) 
[08:24:55.324]                         invokeRestart("muffleWarning")
[08:24:55.324]                     }
[08:24:55.324]                     else if (inherits(cond, "condition")) {
[08:24:55.324]                       if (!is.null(pattern)) {
[08:24:55.324]                         computeRestarts <- base::computeRestarts
[08:24:55.324]                         grepl <- base::grepl
[08:24:55.324]                         restarts <- computeRestarts(cond)
[08:24:55.324]                         for (restart in restarts) {
[08:24:55.324]                           name <- restart$name
[08:24:55.324]                           if (is.null(name)) 
[08:24:55.324]                             next
[08:24:55.324]                           if (!grepl(pattern, name)) 
[08:24:55.324]                             next
[08:24:55.324]                           invokeRestart(restart)
[08:24:55.324]                           muffled <- TRUE
[08:24:55.324]                           break
[08:24:55.324]                         }
[08:24:55.324]                       }
[08:24:55.324]                     }
[08:24:55.324]                     invisible(muffled)
[08:24:55.324]                   }
[08:24:55.324]                   muffleCondition(cond)
[08:24:55.324]                 })
[08:24:55.324]             }))
[08:24:55.324]             future::FutureResult(value = ...future.value$value, 
[08:24:55.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.324]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.324]                     ...future.globalenv.names))
[08:24:55.324]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.324]         }, condition = base::local({
[08:24:55.324]             c <- base::c
[08:24:55.324]             inherits <- base::inherits
[08:24:55.324]             invokeRestart <- base::invokeRestart
[08:24:55.324]             length <- base::length
[08:24:55.324]             list <- base::list
[08:24:55.324]             seq.int <- base::seq.int
[08:24:55.324]             signalCondition <- base::signalCondition
[08:24:55.324]             sys.calls <- base::sys.calls
[08:24:55.324]             `[[` <- base::`[[`
[08:24:55.324]             `+` <- base::`+`
[08:24:55.324]             `<<-` <- base::`<<-`
[08:24:55.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.324]                   3L)]
[08:24:55.324]             }
[08:24:55.324]             function(cond) {
[08:24:55.324]                 is_error <- inherits(cond, "error")
[08:24:55.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.324]                   NULL)
[08:24:55.324]                 if (is_error) {
[08:24:55.324]                   sessionInformation <- function() {
[08:24:55.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.324]                       search = base::search(), system = base::Sys.info())
[08:24:55.324]                   }
[08:24:55.324]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.324]                     cond$call), session = sessionInformation(), 
[08:24:55.324]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.324]                   signalCondition(cond)
[08:24:55.324]                 }
[08:24:55.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.324]                 "immediateCondition"))) {
[08:24:55.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.324]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.324]                   if (TRUE && !signal) {
[08:24:55.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.324]                     {
[08:24:55.324]                       inherits <- base::inherits
[08:24:55.324]                       invokeRestart <- base::invokeRestart
[08:24:55.324]                       is.null <- base::is.null
[08:24:55.324]                       muffled <- FALSE
[08:24:55.324]                       if (inherits(cond, "message")) {
[08:24:55.324]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.324]                         if (muffled) 
[08:24:55.324]                           invokeRestart("muffleMessage")
[08:24:55.324]                       }
[08:24:55.324]                       else if (inherits(cond, "warning")) {
[08:24:55.324]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.324]                         if (muffled) 
[08:24:55.324]                           invokeRestart("muffleWarning")
[08:24:55.324]                       }
[08:24:55.324]                       else if (inherits(cond, "condition")) {
[08:24:55.324]                         if (!is.null(pattern)) {
[08:24:55.324]                           computeRestarts <- base::computeRestarts
[08:24:55.324]                           grepl <- base::grepl
[08:24:55.324]                           restarts <- computeRestarts(cond)
[08:24:55.324]                           for (restart in restarts) {
[08:24:55.324]                             name <- restart$name
[08:24:55.324]                             if (is.null(name)) 
[08:24:55.324]                               next
[08:24:55.324]                             if (!grepl(pattern, name)) 
[08:24:55.324]                               next
[08:24:55.324]                             invokeRestart(restart)
[08:24:55.324]                             muffled <- TRUE
[08:24:55.324]                             break
[08:24:55.324]                           }
[08:24:55.324]                         }
[08:24:55.324]                       }
[08:24:55.324]                       invisible(muffled)
[08:24:55.324]                     }
[08:24:55.324]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.324]                   }
[08:24:55.324]                 }
[08:24:55.324]                 else {
[08:24:55.324]                   if (TRUE) {
[08:24:55.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.324]                     {
[08:24:55.324]                       inherits <- base::inherits
[08:24:55.324]                       invokeRestart <- base::invokeRestart
[08:24:55.324]                       is.null <- base::is.null
[08:24:55.324]                       muffled <- FALSE
[08:24:55.324]                       if (inherits(cond, "message")) {
[08:24:55.324]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.324]                         if (muffled) 
[08:24:55.324]                           invokeRestart("muffleMessage")
[08:24:55.324]                       }
[08:24:55.324]                       else if (inherits(cond, "warning")) {
[08:24:55.324]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.324]                         if (muffled) 
[08:24:55.324]                           invokeRestart("muffleWarning")
[08:24:55.324]                       }
[08:24:55.324]                       else if (inherits(cond, "condition")) {
[08:24:55.324]                         if (!is.null(pattern)) {
[08:24:55.324]                           computeRestarts <- base::computeRestarts
[08:24:55.324]                           grepl <- base::grepl
[08:24:55.324]                           restarts <- computeRestarts(cond)
[08:24:55.324]                           for (restart in restarts) {
[08:24:55.324]                             name <- restart$name
[08:24:55.324]                             if (is.null(name)) 
[08:24:55.324]                               next
[08:24:55.324]                             if (!grepl(pattern, name)) 
[08:24:55.324]                               next
[08:24:55.324]                             invokeRestart(restart)
[08:24:55.324]                             muffled <- TRUE
[08:24:55.324]                             break
[08:24:55.324]                           }
[08:24:55.324]                         }
[08:24:55.324]                       }
[08:24:55.324]                       invisible(muffled)
[08:24:55.324]                     }
[08:24:55.324]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.324]                   }
[08:24:55.324]                 }
[08:24:55.324]             }
[08:24:55.324]         }))
[08:24:55.324]     }, error = function(ex) {
[08:24:55.324]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.324]                 ...future.rng), started = ...future.startTime, 
[08:24:55.324]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.324]             version = "1.8"), class = "FutureResult")
[08:24:55.324]     }, finally = {
[08:24:55.324]         if (!identical(...future.workdir, getwd())) 
[08:24:55.324]             setwd(...future.workdir)
[08:24:55.324]         {
[08:24:55.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.324]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.324]             }
[08:24:55.324]             base::options(...future.oldOptions)
[08:24:55.324]             if (.Platform$OS.type == "windows") {
[08:24:55.324]                 old_names <- names(...future.oldEnvVars)
[08:24:55.324]                 envs <- base::Sys.getenv()
[08:24:55.324]                 names <- names(envs)
[08:24:55.324]                 common <- intersect(names, old_names)
[08:24:55.324]                 added <- setdiff(names, old_names)
[08:24:55.324]                 removed <- setdiff(old_names, names)
[08:24:55.324]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.324]                   envs[common]]
[08:24:55.324]                 NAMES <- toupper(changed)
[08:24:55.324]                 args <- list()
[08:24:55.324]                 for (kk in seq_along(NAMES)) {
[08:24:55.324]                   name <- changed[[kk]]
[08:24:55.324]                   NAME <- NAMES[[kk]]
[08:24:55.324]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.324]                     next
[08:24:55.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.324]                 }
[08:24:55.324]                 NAMES <- toupper(added)
[08:24:55.324]                 for (kk in seq_along(NAMES)) {
[08:24:55.324]                   name <- added[[kk]]
[08:24:55.324]                   NAME <- NAMES[[kk]]
[08:24:55.324]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.324]                     next
[08:24:55.324]                   args[[name]] <- ""
[08:24:55.324]                 }
[08:24:55.324]                 NAMES <- toupper(removed)
[08:24:55.324]                 for (kk in seq_along(NAMES)) {
[08:24:55.324]                   name <- removed[[kk]]
[08:24:55.324]                   NAME <- NAMES[[kk]]
[08:24:55.324]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.324]                     next
[08:24:55.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.324]                 }
[08:24:55.324]                 if (length(args) > 0) 
[08:24:55.324]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.324]             }
[08:24:55.324]             else {
[08:24:55.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.324]             }
[08:24:55.324]             {
[08:24:55.324]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.324]                   0L) {
[08:24:55.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.324]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.324]                   base::options(opts)
[08:24:55.324]                 }
[08:24:55.324]                 {
[08:24:55.324]                   {
[08:24:55.324]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.324]                     NULL
[08:24:55.324]                   }
[08:24:55.324]                   options(future.plan = NULL)
[08:24:55.324]                   if (is.na(NA_character_)) 
[08:24:55.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.324]                     .init = FALSE)
[08:24:55.324]                 }
[08:24:55.324]             }
[08:24:55.324]         }
[08:24:55.324]     })
[08:24:55.324]     if (TRUE) {
[08:24:55.324]         base::sink(type = "output", split = FALSE)
[08:24:55.324]         if (TRUE) {
[08:24:55.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.324]         }
[08:24:55.324]         else {
[08:24:55.324]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.324]         }
[08:24:55.324]         base::close(...future.stdout)
[08:24:55.324]         ...future.stdout <- NULL
[08:24:55.324]     }
[08:24:55.324]     ...future.result$conditions <- ...future.conditions
[08:24:55.324]     ...future.result$finished <- base::Sys.time()
[08:24:55.324]     ...future.result
[08:24:55.324] }
[08:24:55.327] Exporting 5 global objects (854 bytes) to cluster node #1 ...
[08:24:55.327] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:55.328] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:55.328] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[08:24:55.328] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[08:24:55.328] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[08:24:55.329] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[08:24:55.329] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:55.329] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:55.329] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:55.330] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:55.330] Exporting 5 global objects (854 bytes) to cluster node #1 ... DONE
[08:24:55.330] MultisessionFuture started
[08:24:55.330] - Launch lazy future ... done
[08:24:55.330] run() for ‘MultisessionFuture’ ... done
[08:24:55.330] Created future:
[08:24:55.331] MultisessionFuture:
[08:24:55.331] Label: ‘future_apply-1’
[08:24:55.331] Expression:
[08:24:55.331] {
[08:24:55.331]     do.call(function(...) {
[08:24:55.331]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.331]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.331]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.331]             on.exit(options(oopts), add = TRUE)
[08:24:55.331]         }
[08:24:55.331]         {
[08:24:55.331]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.331]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.331]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.331]             })
[08:24:55.331]         }
[08:24:55.331]     }, args = future.call.arguments)
[08:24:55.331] }
[08:24:55.331] Lazy evaluation: FALSE
[08:24:55.331] Asynchronous evaluation: TRUE
[08:24:55.331] Local evaluation: TRUE
[08:24:55.331] Environment: R_GlobalEnv
[08:24:55.331] Capture standard output: TRUE
[08:24:55.331] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.331] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.331] Packages: <none>
[08:24:55.331] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.331] Resolved: FALSE
[08:24:55.331] Value: <not collected>
[08:24:55.331] Conditions captured: <none>
[08:24:55.331] Early signaling: FALSE
[08:24:55.331] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.331] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.342] Chunk #1 of 2 ... DONE
[08:24:55.342] Chunk #2 of 2 ...
[08:24:55.342]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.342]  - seeds: <none>
[08:24:55.343]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.343] getGlobalsAndPackages() ...
[08:24:55.343] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.343] Resolving globals: FALSE
[08:24:55.343] Tweak future expression to call with '...' arguments ...
[08:24:55.343] {
[08:24:55.343]     do.call(function(...) {
[08:24:55.343]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.343]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.343]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.343]             on.exit(options(oopts), add = TRUE)
[08:24:55.343]         }
[08:24:55.343]         {
[08:24:55.343]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.343]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.343]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.343]             })
[08:24:55.343]         }
[08:24:55.343]     }, args = future.call.arguments)
[08:24:55.343] }
[08:24:55.343] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.344] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.344] 
[08:24:55.344] getGlobalsAndPackages() ... DONE
[08:24:55.344] run() for ‘Future’ ...
[08:24:55.344] - state: ‘created’
[08:24:55.345] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.359] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.359] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.359]   - Field: ‘node’
[08:24:55.359]   - Field: ‘label’
[08:24:55.359]   - Field: ‘local’
[08:24:55.359]   - Field: ‘owner’
[08:24:55.359]   - Field: ‘envir’
[08:24:55.359]   - Field: ‘workers’
[08:24:55.359]   - Field: ‘packages’
[08:24:55.360]   - Field: ‘gc’
[08:24:55.360]   - Field: ‘conditions’
[08:24:55.360]   - Field: ‘persistent’
[08:24:55.360]   - Field: ‘expr’
[08:24:55.360]   - Field: ‘uuid’
[08:24:55.360]   - Field: ‘seed’
[08:24:55.360]   - Field: ‘version’
[08:24:55.360]   - Field: ‘result’
[08:24:55.360]   - Field: ‘asynchronous’
[08:24:55.360]   - Field: ‘calls’
[08:24:55.360]   - Field: ‘globals’
[08:24:55.360]   - Field: ‘stdout’
[08:24:55.361]   - Field: ‘earlySignal’
[08:24:55.361]   - Field: ‘lazy’
[08:24:55.361]   - Field: ‘state’
[08:24:55.361] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.361] - Launch lazy future ...
[08:24:55.361] Packages needed by the future expression (n = 0): <none>
[08:24:55.361] Packages needed by future strategies (n = 0): <none>
[08:24:55.362] {
[08:24:55.362]     {
[08:24:55.362]         {
[08:24:55.362]             ...future.startTime <- base::Sys.time()
[08:24:55.362]             {
[08:24:55.362]                 {
[08:24:55.362]                   {
[08:24:55.362]                     {
[08:24:55.362]                       base::local({
[08:24:55.362]                         has_future <- base::requireNamespace("future", 
[08:24:55.362]                           quietly = TRUE)
[08:24:55.362]                         if (has_future) {
[08:24:55.362]                           ns <- base::getNamespace("future")
[08:24:55.362]                           version <- ns[[".package"]][["version"]]
[08:24:55.362]                           if (is.null(version)) 
[08:24:55.362]                             version <- utils::packageVersion("future")
[08:24:55.362]                         }
[08:24:55.362]                         else {
[08:24:55.362]                           version <- NULL
[08:24:55.362]                         }
[08:24:55.362]                         if (!has_future || version < "1.8.0") {
[08:24:55.362]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.362]                             "", base::R.version$version.string), 
[08:24:55.362]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.362]                               "release", "version")], collapse = " "), 
[08:24:55.362]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.362]                             info)
[08:24:55.362]                           info <- base::paste(info, collapse = "; ")
[08:24:55.362]                           if (!has_future) {
[08:24:55.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.362]                               info)
[08:24:55.362]                           }
[08:24:55.362]                           else {
[08:24:55.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.362]                               info, version)
[08:24:55.362]                           }
[08:24:55.362]                           base::stop(msg)
[08:24:55.362]                         }
[08:24:55.362]                       })
[08:24:55.362]                     }
[08:24:55.362]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.362]                     base::options(mc.cores = 1L)
[08:24:55.362]                   }
[08:24:55.362]                   ...future.strategy.old <- future::plan("list")
[08:24:55.362]                   options(future.plan = NULL)
[08:24:55.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.362]                 }
[08:24:55.362]                 ...future.workdir <- getwd()
[08:24:55.362]             }
[08:24:55.362]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.362]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.362]         }
[08:24:55.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.362]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.362]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.362]             base::names(...future.oldOptions))
[08:24:55.362]     }
[08:24:55.362]     if (FALSE) {
[08:24:55.362]     }
[08:24:55.362]     else {
[08:24:55.362]         if (TRUE) {
[08:24:55.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.362]                 open = "w")
[08:24:55.362]         }
[08:24:55.362]         else {
[08:24:55.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.362]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.362]         }
[08:24:55.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.362]             base::sink(type = "output", split = FALSE)
[08:24:55.362]             base::close(...future.stdout)
[08:24:55.362]         }, add = TRUE)
[08:24:55.362]     }
[08:24:55.362]     ...future.frame <- base::sys.nframe()
[08:24:55.362]     ...future.conditions <- base::list()
[08:24:55.362]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.362]     if (FALSE) {
[08:24:55.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.362]     }
[08:24:55.362]     ...future.result <- base::tryCatch({
[08:24:55.362]         base::withCallingHandlers({
[08:24:55.362]             ...future.value <- base::withVisible(base::local({
[08:24:55.362]                 ...future.makeSendCondition <- base::local({
[08:24:55.362]                   sendCondition <- NULL
[08:24:55.362]                   function(frame = 1L) {
[08:24:55.362]                     if (is.function(sendCondition)) 
[08:24:55.362]                       return(sendCondition)
[08:24:55.362]                     ns <- getNamespace("parallel")
[08:24:55.362]                     if (exists("sendData", mode = "function", 
[08:24:55.362]                       envir = ns)) {
[08:24:55.362]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.362]                         envir = ns)
[08:24:55.362]                       envir <- sys.frame(frame)
[08:24:55.362]                       master <- NULL
[08:24:55.362]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.362]                         !identical(envir, emptyenv())) {
[08:24:55.362]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.362]                           inherits = FALSE)) {
[08:24:55.362]                           master <- get("master", mode = "list", 
[08:24:55.362]                             envir = envir, inherits = FALSE)
[08:24:55.362]                           if (inherits(master, c("SOCKnode", 
[08:24:55.362]                             "SOCK0node"))) {
[08:24:55.362]                             sendCondition <<- function(cond) {
[08:24:55.362]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.362]                                 success = TRUE)
[08:24:55.362]                               parallel_sendData(master, data)
[08:24:55.362]                             }
[08:24:55.362]                             return(sendCondition)
[08:24:55.362]                           }
[08:24:55.362]                         }
[08:24:55.362]                         frame <- frame + 1L
[08:24:55.362]                         envir <- sys.frame(frame)
[08:24:55.362]                       }
[08:24:55.362]                     }
[08:24:55.362]                     sendCondition <<- function(cond) NULL
[08:24:55.362]                   }
[08:24:55.362]                 })
[08:24:55.362]                 withCallingHandlers({
[08:24:55.362]                   {
[08:24:55.362]                     do.call(function(...) {
[08:24:55.362]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.362]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.362]                         ...future.globals.maxSize)) {
[08:24:55.362]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.362]                         on.exit(options(oopts), add = TRUE)
[08:24:55.362]                       }
[08:24:55.362]                       {
[08:24:55.362]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.362]                           FUN = function(jj) {
[08:24:55.362]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.362]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.362]                           })
[08:24:55.362]                       }
[08:24:55.362]                     }, args = future.call.arguments)
[08:24:55.362]                   }
[08:24:55.362]                 }, immediateCondition = function(cond) {
[08:24:55.362]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.362]                   sendCondition(cond)
[08:24:55.362]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.362]                   {
[08:24:55.362]                     inherits <- base::inherits
[08:24:55.362]                     invokeRestart <- base::invokeRestart
[08:24:55.362]                     is.null <- base::is.null
[08:24:55.362]                     muffled <- FALSE
[08:24:55.362]                     if (inherits(cond, "message")) {
[08:24:55.362]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.362]                       if (muffled) 
[08:24:55.362]                         invokeRestart("muffleMessage")
[08:24:55.362]                     }
[08:24:55.362]                     else if (inherits(cond, "warning")) {
[08:24:55.362]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.362]                       if (muffled) 
[08:24:55.362]                         invokeRestart("muffleWarning")
[08:24:55.362]                     }
[08:24:55.362]                     else if (inherits(cond, "condition")) {
[08:24:55.362]                       if (!is.null(pattern)) {
[08:24:55.362]                         computeRestarts <- base::computeRestarts
[08:24:55.362]                         grepl <- base::grepl
[08:24:55.362]                         restarts <- computeRestarts(cond)
[08:24:55.362]                         for (restart in restarts) {
[08:24:55.362]                           name <- restart$name
[08:24:55.362]                           if (is.null(name)) 
[08:24:55.362]                             next
[08:24:55.362]                           if (!grepl(pattern, name)) 
[08:24:55.362]                             next
[08:24:55.362]                           invokeRestart(restart)
[08:24:55.362]                           muffled <- TRUE
[08:24:55.362]                           break
[08:24:55.362]                         }
[08:24:55.362]                       }
[08:24:55.362]                     }
[08:24:55.362]                     invisible(muffled)
[08:24:55.362]                   }
[08:24:55.362]                   muffleCondition(cond)
[08:24:55.362]                 })
[08:24:55.362]             }))
[08:24:55.362]             future::FutureResult(value = ...future.value$value, 
[08:24:55.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.362]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.362]                     ...future.globalenv.names))
[08:24:55.362]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.362]         }, condition = base::local({
[08:24:55.362]             c <- base::c
[08:24:55.362]             inherits <- base::inherits
[08:24:55.362]             invokeRestart <- base::invokeRestart
[08:24:55.362]             length <- base::length
[08:24:55.362]             list <- base::list
[08:24:55.362]             seq.int <- base::seq.int
[08:24:55.362]             signalCondition <- base::signalCondition
[08:24:55.362]             sys.calls <- base::sys.calls
[08:24:55.362]             `[[` <- base::`[[`
[08:24:55.362]             `+` <- base::`+`
[08:24:55.362]             `<<-` <- base::`<<-`
[08:24:55.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.362]                   3L)]
[08:24:55.362]             }
[08:24:55.362]             function(cond) {
[08:24:55.362]                 is_error <- inherits(cond, "error")
[08:24:55.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.362]                   NULL)
[08:24:55.362]                 if (is_error) {
[08:24:55.362]                   sessionInformation <- function() {
[08:24:55.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.362]                       search = base::search(), system = base::Sys.info())
[08:24:55.362]                   }
[08:24:55.362]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.362]                     cond$call), session = sessionInformation(), 
[08:24:55.362]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.362]                   signalCondition(cond)
[08:24:55.362]                 }
[08:24:55.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.362]                 "immediateCondition"))) {
[08:24:55.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.362]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.362]                   if (TRUE && !signal) {
[08:24:55.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.362]                     {
[08:24:55.362]                       inherits <- base::inherits
[08:24:55.362]                       invokeRestart <- base::invokeRestart
[08:24:55.362]                       is.null <- base::is.null
[08:24:55.362]                       muffled <- FALSE
[08:24:55.362]                       if (inherits(cond, "message")) {
[08:24:55.362]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.362]                         if (muffled) 
[08:24:55.362]                           invokeRestart("muffleMessage")
[08:24:55.362]                       }
[08:24:55.362]                       else if (inherits(cond, "warning")) {
[08:24:55.362]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.362]                         if (muffled) 
[08:24:55.362]                           invokeRestart("muffleWarning")
[08:24:55.362]                       }
[08:24:55.362]                       else if (inherits(cond, "condition")) {
[08:24:55.362]                         if (!is.null(pattern)) {
[08:24:55.362]                           computeRestarts <- base::computeRestarts
[08:24:55.362]                           grepl <- base::grepl
[08:24:55.362]                           restarts <- computeRestarts(cond)
[08:24:55.362]                           for (restart in restarts) {
[08:24:55.362]                             name <- restart$name
[08:24:55.362]                             if (is.null(name)) 
[08:24:55.362]                               next
[08:24:55.362]                             if (!grepl(pattern, name)) 
[08:24:55.362]                               next
[08:24:55.362]                             invokeRestart(restart)
[08:24:55.362]                             muffled <- TRUE
[08:24:55.362]                             break
[08:24:55.362]                           }
[08:24:55.362]                         }
[08:24:55.362]                       }
[08:24:55.362]                       invisible(muffled)
[08:24:55.362]                     }
[08:24:55.362]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.362]                   }
[08:24:55.362]                 }
[08:24:55.362]                 else {
[08:24:55.362]                   if (TRUE) {
[08:24:55.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.362]                     {
[08:24:55.362]                       inherits <- base::inherits
[08:24:55.362]                       invokeRestart <- base::invokeRestart
[08:24:55.362]                       is.null <- base::is.null
[08:24:55.362]                       muffled <- FALSE
[08:24:55.362]                       if (inherits(cond, "message")) {
[08:24:55.362]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.362]                         if (muffled) 
[08:24:55.362]                           invokeRestart("muffleMessage")
[08:24:55.362]                       }
[08:24:55.362]                       else if (inherits(cond, "warning")) {
[08:24:55.362]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.362]                         if (muffled) 
[08:24:55.362]                           invokeRestart("muffleWarning")
[08:24:55.362]                       }
[08:24:55.362]                       else if (inherits(cond, "condition")) {
[08:24:55.362]                         if (!is.null(pattern)) {
[08:24:55.362]                           computeRestarts <- base::computeRestarts
[08:24:55.362]                           grepl <- base::grepl
[08:24:55.362]                           restarts <- computeRestarts(cond)
[08:24:55.362]                           for (restart in restarts) {
[08:24:55.362]                             name <- restart$name
[08:24:55.362]                             if (is.null(name)) 
[08:24:55.362]                               next
[08:24:55.362]                             if (!grepl(pattern, name)) 
[08:24:55.362]                               next
[08:24:55.362]                             invokeRestart(restart)
[08:24:55.362]                             muffled <- TRUE
[08:24:55.362]                             break
[08:24:55.362]                           }
[08:24:55.362]                         }
[08:24:55.362]                       }
[08:24:55.362]                       invisible(muffled)
[08:24:55.362]                     }
[08:24:55.362]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.362]                   }
[08:24:55.362]                 }
[08:24:55.362]             }
[08:24:55.362]         }))
[08:24:55.362]     }, error = function(ex) {
[08:24:55.362]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.362]                 ...future.rng), started = ...future.startTime, 
[08:24:55.362]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.362]             version = "1.8"), class = "FutureResult")
[08:24:55.362]     }, finally = {
[08:24:55.362]         if (!identical(...future.workdir, getwd())) 
[08:24:55.362]             setwd(...future.workdir)
[08:24:55.362]         {
[08:24:55.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.362]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.362]             }
[08:24:55.362]             base::options(...future.oldOptions)
[08:24:55.362]             if (.Platform$OS.type == "windows") {
[08:24:55.362]                 old_names <- names(...future.oldEnvVars)
[08:24:55.362]                 envs <- base::Sys.getenv()
[08:24:55.362]                 names <- names(envs)
[08:24:55.362]                 common <- intersect(names, old_names)
[08:24:55.362]                 added <- setdiff(names, old_names)
[08:24:55.362]                 removed <- setdiff(old_names, names)
[08:24:55.362]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.362]                   envs[common]]
[08:24:55.362]                 NAMES <- toupper(changed)
[08:24:55.362]                 args <- list()
[08:24:55.362]                 for (kk in seq_along(NAMES)) {
[08:24:55.362]                   name <- changed[[kk]]
[08:24:55.362]                   NAME <- NAMES[[kk]]
[08:24:55.362]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.362]                     next
[08:24:55.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.362]                 }
[08:24:55.362]                 NAMES <- toupper(added)
[08:24:55.362]                 for (kk in seq_along(NAMES)) {
[08:24:55.362]                   name <- added[[kk]]
[08:24:55.362]                   NAME <- NAMES[[kk]]
[08:24:55.362]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.362]                     next
[08:24:55.362]                   args[[name]] <- ""
[08:24:55.362]                 }
[08:24:55.362]                 NAMES <- toupper(removed)
[08:24:55.362]                 for (kk in seq_along(NAMES)) {
[08:24:55.362]                   name <- removed[[kk]]
[08:24:55.362]                   NAME <- NAMES[[kk]]
[08:24:55.362]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.362]                     next
[08:24:55.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.362]                 }
[08:24:55.362]                 if (length(args) > 0) 
[08:24:55.362]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.362]             }
[08:24:55.362]             else {
[08:24:55.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.362]             }
[08:24:55.362]             {
[08:24:55.362]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.362]                   0L) {
[08:24:55.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.362]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.362]                   base::options(opts)
[08:24:55.362]                 }
[08:24:55.362]                 {
[08:24:55.362]                   {
[08:24:55.362]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.362]                     NULL
[08:24:55.362]                   }
[08:24:55.362]                   options(future.plan = NULL)
[08:24:55.362]                   if (is.na(NA_character_)) 
[08:24:55.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.362]                     .init = FALSE)
[08:24:55.362]                 }
[08:24:55.362]             }
[08:24:55.362]         }
[08:24:55.362]     })
[08:24:55.362]     if (TRUE) {
[08:24:55.362]         base::sink(type = "output", split = FALSE)
[08:24:55.362]         if (TRUE) {
[08:24:55.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.362]         }
[08:24:55.362]         else {
[08:24:55.362]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.362]         }
[08:24:55.362]         base::close(...future.stdout)
[08:24:55.362]         ...future.stdout <- NULL
[08:24:55.362]     }
[08:24:55.362]     ...future.result$conditions <- ...future.conditions
[08:24:55.362]     ...future.result$finished <- base::Sys.time()
[08:24:55.362]     ...future.result
[08:24:55.362] }
[08:24:55.365] Exporting 5 global objects (854 bytes) to cluster node #2 ...
[08:24:55.365] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:55.366] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:55.366] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[08:24:55.366] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[08:24:55.366] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[08:24:55.367] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[08:24:55.367] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:55.367] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:55.367] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:55.368] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:55.368] Exporting 5 global objects (854 bytes) to cluster node #2 ... DONE
[08:24:55.368] MultisessionFuture started
[08:24:55.368] - Launch lazy future ... done
[08:24:55.369] run() for ‘MultisessionFuture’ ... done
[08:24:55.369] Created future:
[08:24:55.369] MultisessionFuture:
[08:24:55.369] Label: ‘future_apply-2’
[08:24:55.369] Expression:
[08:24:55.369] {
[08:24:55.369]     do.call(function(...) {
[08:24:55.369]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.369]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.369]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.369]             on.exit(options(oopts), add = TRUE)
[08:24:55.369]         }
[08:24:55.369]         {
[08:24:55.369]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.369]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.369]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.369]             })
[08:24:55.369]         }
[08:24:55.369]     }, args = future.call.arguments)
[08:24:55.369] }
[08:24:55.369] Lazy evaluation: FALSE
[08:24:55.369] Asynchronous evaluation: TRUE
[08:24:55.369] Local evaluation: TRUE
[08:24:55.369] Environment: R_GlobalEnv
[08:24:55.369] Capture standard output: TRUE
[08:24:55.369] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.369] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.369] Packages: <none>
[08:24:55.369] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.369] Resolved: FALSE
[08:24:55.369] Value: <not collected>
[08:24:55.369] Conditions captured: <none>
[08:24:55.369] Early signaling: FALSE
[08:24:55.369] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.369] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.380] Chunk #2 of 2 ... DONE
[08:24:55.380] Launching 2 futures (chunks) ... DONE
[08:24:55.381] Resolving 2 futures (chunks) ...
[08:24:55.381] resolve() on list ...
[08:24:55.381]  recursive: 0
[08:24:55.381]  length: 2
[08:24:55.381] 
[08:24:55.382] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.382] - Validating connection of MultisessionFuture
[08:24:55.382] - received message: FutureResult
[08:24:55.382] - Received FutureResult
[08:24:55.382] - Erased future from FutureRegistry
[08:24:55.382] result() for ClusterFuture ...
[08:24:55.382] - result already collected: FutureResult
[08:24:55.382] result() for ClusterFuture ... done
[08:24:55.382] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.382] Future #1
[08:24:55.383] result() for ClusterFuture ...
[08:24:55.383] - result already collected: FutureResult
[08:24:55.383] result() for ClusterFuture ... done
[08:24:55.383] result() for ClusterFuture ...
[08:24:55.383] - result already collected: FutureResult
[08:24:55.383] result() for ClusterFuture ... done
[08:24:55.383] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:55.383] - nx: 2
[08:24:55.383] - relay: TRUE
[08:24:55.383] - stdout: TRUE
[08:24:55.383] - signal: TRUE
[08:24:55.384] - resignal: FALSE
[08:24:55.384] - force: TRUE
[08:24:55.384] - relayed: [n=2] FALSE, FALSE
[08:24:55.384] - queued futures: [n=2] FALSE, FALSE
[08:24:55.384]  - until=1
[08:24:55.384]  - relaying element #1
[08:24:55.384] result() for ClusterFuture ...
[08:24:55.384] - result already collected: FutureResult
[08:24:55.384] result() for ClusterFuture ... done
[08:24:55.384] result() for ClusterFuture ...
[08:24:55.384] - result already collected: FutureResult
[08:24:55.384] result() for ClusterFuture ... done
[08:24:55.385] result() for ClusterFuture ...
[08:24:55.385] - result already collected: FutureResult
[08:24:55.385] result() for ClusterFuture ... done
[08:24:55.385] result() for ClusterFuture ...
[08:24:55.385] - result already collected: FutureResult
[08:24:55.385] result() for ClusterFuture ... done
[08:24:55.385] - relayed: [n=2] TRUE, FALSE
[08:24:55.385] - queued futures: [n=2] TRUE, FALSE
[08:24:55.385] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:55.385]  length: 1 (resolved future 1)
[08:24:55.410] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.410] - Validating connection of MultisessionFuture
[08:24:55.411] - received message: FutureResult
[08:24:55.411] - Received FutureResult
[08:24:55.411] - Erased future from FutureRegistry
[08:24:55.411] result() for ClusterFuture ...
[08:24:55.411] - result already collected: FutureResult
[08:24:55.411] result() for ClusterFuture ... done
[08:24:55.411] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.411] Future #2
[08:24:55.411] result() for ClusterFuture ...
[08:24:55.411] - result already collected: FutureResult
[08:24:55.412] result() for ClusterFuture ... done
[08:24:55.412] result() for ClusterFuture ...
[08:24:55.412] - result already collected: FutureResult
[08:24:55.412] result() for ClusterFuture ... done
[08:24:55.414] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:55.415] - nx: 2
[08:24:55.415] - relay: TRUE
[08:24:55.415] - stdout: TRUE
[08:24:55.415] - signal: TRUE
[08:24:55.415] - resignal: FALSE
[08:24:55.415] - force: TRUE
[08:24:55.415] - relayed: [n=2] TRUE, FALSE
[08:24:55.415] - queued futures: [n=2] TRUE, FALSE
[08:24:55.415]  - until=2
[08:24:55.415]  - relaying element #2
[08:24:55.415] result() for ClusterFuture ...
[08:24:55.415] - result already collected: FutureResult
[08:24:55.416] result() for ClusterFuture ... done
[08:24:55.416] result() for ClusterFuture ...
[08:24:55.416] - result already collected: FutureResult
[08:24:55.416] result() for ClusterFuture ... done
[08:24:55.416] result() for ClusterFuture ...
[08:24:55.416] - result already collected: FutureResult
[08:24:55.416] result() for ClusterFuture ... done
[08:24:55.416] result() for ClusterFuture ...
[08:24:55.416] - result already collected: FutureResult
[08:24:55.416] result() for ClusterFuture ... done
[08:24:55.416] - relayed: [n=2] TRUE, TRUE
[08:24:55.416] - queued futures: [n=2] TRUE, TRUE
[08:24:55.417] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:55.417]  length: 0 (resolved future 2)
[08:24:55.417] Relaying remaining futures
[08:24:55.417] signalConditionsASAP(NULL, pos=0) ...
[08:24:55.417] - nx: 2
[08:24:55.417] - relay: TRUE
[08:24:55.417] - stdout: TRUE
[08:24:55.417] - signal: TRUE
[08:24:55.417] - resignal: FALSE
[08:24:55.417] - force: TRUE
[08:24:55.417] - relayed: [n=2] TRUE, TRUE
[08:24:55.417] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:55.418] - relayed: [n=2] TRUE, TRUE
[08:24:55.418] - queued futures: [n=2] TRUE, TRUE
[08:24:55.418] signalConditionsASAP(NULL, pos=0) ... done
[08:24:55.418] resolve() on list ... DONE
[08:24:55.418] result() for ClusterFuture ...
[08:24:55.418] - result already collected: FutureResult
[08:24:55.418] result() for ClusterFuture ... done
[08:24:55.418] result() for ClusterFuture ...
[08:24:55.418] - result already collected: FutureResult
[08:24:55.418] result() for ClusterFuture ... done
[08:24:55.418] result() for ClusterFuture ...
[08:24:55.418] - result already collected: FutureResult
[08:24:55.419] result() for ClusterFuture ... done
[08:24:55.419] result() for ClusterFuture ...
[08:24:55.419] - result already collected: FutureResult
[08:24:55.419] result() for ClusterFuture ... done
[08:24:55.419]  - Number of value chunks collected: 2
[08:24:55.419] Resolving 2 futures (chunks) ... DONE
[08:24:55.419] Reducing values from 2 chunks ...
[08:24:55.419]  - Number of values collected after concatenation: 2
[08:24:55.419]  - Number of values expected: 2
[08:24:55.419] Reducing values from 2 chunks ... DONE
[08:24:55.419] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[08:24:55.420] getGlobalsAndPackagesXApply() ...
[08:24:55.420]  - future.globals: TRUE
[08:24:55.420] getGlobalsAndPackages() ...
[08:24:55.420] Searching for globals...
[08:24:55.421] - globals found: [1] ‘FUN’
[08:24:55.421] Searching for globals ... DONE
[08:24:55.421] Resolving globals: FALSE
[08:24:55.422] The total size of the 1 globals is 185 bytes (185 bytes)
[08:24:55.422] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[08:24:55.422] - globals: [1] ‘FUN’
[08:24:55.422] 
[08:24:55.422] getGlobalsAndPackages() ... DONE
[08:24:55.422]  - globals found/used: [n=1] ‘FUN’
[08:24:55.422]  - needed namespaces: [n=0] 
[08:24:55.423] Finding globals ... DONE
[08:24:55.423]  - use_args: TRUE
[08:24:55.423]  - Getting '...' globals ...
[08:24:55.423] resolve() on list ...
[08:24:55.423]  recursive: 0
[08:24:55.423]  length: 1
[08:24:55.423]  elements: ‘...’
[08:24:55.423]  length: 0 (resolved future 1)
[08:24:55.423] resolve() on list ... DONE
[08:24:55.424]    - '...' content: [n=0] 
[08:24:55.424] List of 1
[08:24:55.424]  $ ...: list()
[08:24:55.424]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.424]  - attr(*, "where")=List of 1
[08:24:55.424]   ..$ ...:<environment: 0x56540e4905b0> 
[08:24:55.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.424]  - attr(*, "resolved")= logi TRUE
[08:24:55.424]  - attr(*, "total_size")= num NA
[08:24:55.426]  - Getting '...' globals ... DONE
[08:24:55.426] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:55.426] List of 2
[08:24:55.426]  $ ...future.FUN:function (x)  
[08:24:55.426]  $ ...          : list()
[08:24:55.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.426]  - attr(*, "where")=List of 2
[08:24:55.426]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:55.426]   ..$ ...          :<environment: 0x56540e4905b0> 
[08:24:55.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.426]  - attr(*, "resolved")= logi FALSE
[08:24:55.426]  - attr(*, "total_size")= num 2274
[08:24:55.429] Packages to be attached in all futures: [n=0] 
[08:24:55.429] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.431] future_lapply() ...
[08:24:55.432] Number of chunks: 2
[08:24:55.433] getGlobalsAndPackagesXApply() ...
[08:24:55.433]  - future.globals: <name-value list> with names ‘list()’
[08:24:55.433]  - use_args: TRUE
[08:24:55.433] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:55.433] List of 2
[08:24:55.433]  $ ...          : list()
[08:24:55.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.433]  $ ...future.FUN:function (x)  
[08:24:55.433]  - attr(*, "where")=List of 2
[08:24:55.433]   ..$ ...          :<environment: 0x56540e4905b0> 
[08:24:55.433]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:55.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.433]  - attr(*, "resolved")= logi FALSE
[08:24:55.433]  - attr(*, "total_size")= num NA
[08:24:55.437] Packages to be attached in all futures: [n=0] 
[08:24:55.437] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.437] Number of futures (= number of chunks): 2
[08:24:55.437] Launching 2 futures (chunks) ...
[08:24:55.437] Chunk #1 of 2 ...
[08:24:55.437]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.437]  - seeds: <none>
[08:24:55.437]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.437] getGlobalsAndPackages() ...
[08:24:55.438] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.438] Resolving globals: FALSE
[08:24:55.438] Tweak future expression to call with '...' arguments ...
[08:24:55.438] {
[08:24:55.438]     do.call(function(...) {
[08:24:55.438]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.438]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.438]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.438]             on.exit(options(oopts), add = TRUE)
[08:24:55.438]         }
[08:24:55.438]         {
[08:24:55.438]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.438]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.438]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.438]             })
[08:24:55.438]         }
[08:24:55.438]     }, args = future.call.arguments)
[08:24:55.438] }
[08:24:55.438] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.439] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.439] 
[08:24:55.439] getGlobalsAndPackages() ... DONE
[08:24:55.439] run() for ‘Future’ ...
[08:24:55.439] - state: ‘created’
[08:24:55.439] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.453] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.454]   - Field: ‘node’
[08:24:55.454]   - Field: ‘label’
[08:24:55.454]   - Field: ‘local’
[08:24:55.454]   - Field: ‘owner’
[08:24:55.454]   - Field: ‘envir’
[08:24:55.454]   - Field: ‘workers’
[08:24:55.454]   - Field: ‘packages’
[08:24:55.454]   - Field: ‘gc’
[08:24:55.454]   - Field: ‘conditions’
[08:24:55.454]   - Field: ‘persistent’
[08:24:55.454]   - Field: ‘expr’
[08:24:55.454]   - Field: ‘uuid’
[08:24:55.455]   - Field: ‘seed’
[08:24:55.455]   - Field: ‘version’
[08:24:55.455]   - Field: ‘result’
[08:24:55.455]   - Field: ‘asynchronous’
[08:24:55.455]   - Field: ‘calls’
[08:24:55.455]   - Field: ‘globals’
[08:24:55.455]   - Field: ‘stdout’
[08:24:55.455]   - Field: ‘earlySignal’
[08:24:55.455]   - Field: ‘lazy’
[08:24:55.455]   - Field: ‘state’
[08:24:55.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.456] - Launch lazy future ...
[08:24:55.456] Packages needed by the future expression (n = 0): <none>
[08:24:55.456] Packages needed by future strategies (n = 0): <none>
[08:24:55.456] {
[08:24:55.456]     {
[08:24:55.456]         {
[08:24:55.456]             ...future.startTime <- base::Sys.time()
[08:24:55.456]             {
[08:24:55.456]                 {
[08:24:55.456]                   {
[08:24:55.456]                     {
[08:24:55.456]                       base::local({
[08:24:55.456]                         has_future <- base::requireNamespace("future", 
[08:24:55.456]                           quietly = TRUE)
[08:24:55.456]                         if (has_future) {
[08:24:55.456]                           ns <- base::getNamespace("future")
[08:24:55.456]                           version <- ns[[".package"]][["version"]]
[08:24:55.456]                           if (is.null(version)) 
[08:24:55.456]                             version <- utils::packageVersion("future")
[08:24:55.456]                         }
[08:24:55.456]                         else {
[08:24:55.456]                           version <- NULL
[08:24:55.456]                         }
[08:24:55.456]                         if (!has_future || version < "1.8.0") {
[08:24:55.456]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.456]                             "", base::R.version$version.string), 
[08:24:55.456]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.456]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.456]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.456]                               "release", "version")], collapse = " "), 
[08:24:55.456]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.456]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.456]                             info)
[08:24:55.456]                           info <- base::paste(info, collapse = "; ")
[08:24:55.456]                           if (!has_future) {
[08:24:55.456]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.456]                               info)
[08:24:55.456]                           }
[08:24:55.456]                           else {
[08:24:55.456]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.456]                               info, version)
[08:24:55.456]                           }
[08:24:55.456]                           base::stop(msg)
[08:24:55.456]                         }
[08:24:55.456]                       })
[08:24:55.456]                     }
[08:24:55.456]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.456]                     base::options(mc.cores = 1L)
[08:24:55.456]                   }
[08:24:55.456]                   ...future.strategy.old <- future::plan("list")
[08:24:55.456]                   options(future.plan = NULL)
[08:24:55.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.456]                 }
[08:24:55.456]                 ...future.workdir <- getwd()
[08:24:55.456]             }
[08:24:55.456]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.456]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.456]         }
[08:24:55.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.456]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.456]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.456]             base::names(...future.oldOptions))
[08:24:55.456]     }
[08:24:55.456]     if (FALSE) {
[08:24:55.456]     }
[08:24:55.456]     else {
[08:24:55.456]         if (TRUE) {
[08:24:55.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.456]                 open = "w")
[08:24:55.456]         }
[08:24:55.456]         else {
[08:24:55.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.456]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.456]         }
[08:24:55.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.456]             base::sink(type = "output", split = FALSE)
[08:24:55.456]             base::close(...future.stdout)
[08:24:55.456]         }, add = TRUE)
[08:24:55.456]     }
[08:24:55.456]     ...future.frame <- base::sys.nframe()
[08:24:55.456]     ...future.conditions <- base::list()
[08:24:55.456]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.456]     if (FALSE) {
[08:24:55.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.456]     }
[08:24:55.456]     ...future.result <- base::tryCatch({
[08:24:55.456]         base::withCallingHandlers({
[08:24:55.456]             ...future.value <- base::withVisible(base::local({
[08:24:55.456]                 ...future.makeSendCondition <- base::local({
[08:24:55.456]                   sendCondition <- NULL
[08:24:55.456]                   function(frame = 1L) {
[08:24:55.456]                     if (is.function(sendCondition)) 
[08:24:55.456]                       return(sendCondition)
[08:24:55.456]                     ns <- getNamespace("parallel")
[08:24:55.456]                     if (exists("sendData", mode = "function", 
[08:24:55.456]                       envir = ns)) {
[08:24:55.456]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.456]                         envir = ns)
[08:24:55.456]                       envir <- sys.frame(frame)
[08:24:55.456]                       master <- NULL
[08:24:55.456]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.456]                         !identical(envir, emptyenv())) {
[08:24:55.456]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.456]                           inherits = FALSE)) {
[08:24:55.456]                           master <- get("master", mode = "list", 
[08:24:55.456]                             envir = envir, inherits = FALSE)
[08:24:55.456]                           if (inherits(master, c("SOCKnode", 
[08:24:55.456]                             "SOCK0node"))) {
[08:24:55.456]                             sendCondition <<- function(cond) {
[08:24:55.456]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.456]                                 success = TRUE)
[08:24:55.456]                               parallel_sendData(master, data)
[08:24:55.456]                             }
[08:24:55.456]                             return(sendCondition)
[08:24:55.456]                           }
[08:24:55.456]                         }
[08:24:55.456]                         frame <- frame + 1L
[08:24:55.456]                         envir <- sys.frame(frame)
[08:24:55.456]                       }
[08:24:55.456]                     }
[08:24:55.456]                     sendCondition <<- function(cond) NULL
[08:24:55.456]                   }
[08:24:55.456]                 })
[08:24:55.456]                 withCallingHandlers({
[08:24:55.456]                   {
[08:24:55.456]                     do.call(function(...) {
[08:24:55.456]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.456]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.456]                         ...future.globals.maxSize)) {
[08:24:55.456]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.456]                         on.exit(options(oopts), add = TRUE)
[08:24:55.456]                       }
[08:24:55.456]                       {
[08:24:55.456]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.456]                           FUN = function(jj) {
[08:24:55.456]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.456]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.456]                           })
[08:24:55.456]                       }
[08:24:55.456]                     }, args = future.call.arguments)
[08:24:55.456]                   }
[08:24:55.456]                 }, immediateCondition = function(cond) {
[08:24:55.456]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.456]                   sendCondition(cond)
[08:24:55.456]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.456]                   {
[08:24:55.456]                     inherits <- base::inherits
[08:24:55.456]                     invokeRestart <- base::invokeRestart
[08:24:55.456]                     is.null <- base::is.null
[08:24:55.456]                     muffled <- FALSE
[08:24:55.456]                     if (inherits(cond, "message")) {
[08:24:55.456]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.456]                       if (muffled) 
[08:24:55.456]                         invokeRestart("muffleMessage")
[08:24:55.456]                     }
[08:24:55.456]                     else if (inherits(cond, "warning")) {
[08:24:55.456]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.456]                       if (muffled) 
[08:24:55.456]                         invokeRestart("muffleWarning")
[08:24:55.456]                     }
[08:24:55.456]                     else if (inherits(cond, "condition")) {
[08:24:55.456]                       if (!is.null(pattern)) {
[08:24:55.456]                         computeRestarts <- base::computeRestarts
[08:24:55.456]                         grepl <- base::grepl
[08:24:55.456]                         restarts <- computeRestarts(cond)
[08:24:55.456]                         for (restart in restarts) {
[08:24:55.456]                           name <- restart$name
[08:24:55.456]                           if (is.null(name)) 
[08:24:55.456]                             next
[08:24:55.456]                           if (!grepl(pattern, name)) 
[08:24:55.456]                             next
[08:24:55.456]                           invokeRestart(restart)
[08:24:55.456]                           muffled <- TRUE
[08:24:55.456]                           break
[08:24:55.456]                         }
[08:24:55.456]                       }
[08:24:55.456]                     }
[08:24:55.456]                     invisible(muffled)
[08:24:55.456]                   }
[08:24:55.456]                   muffleCondition(cond)
[08:24:55.456]                 })
[08:24:55.456]             }))
[08:24:55.456]             future::FutureResult(value = ...future.value$value, 
[08:24:55.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.456]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.456]                     ...future.globalenv.names))
[08:24:55.456]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.456]         }, condition = base::local({
[08:24:55.456]             c <- base::c
[08:24:55.456]             inherits <- base::inherits
[08:24:55.456]             invokeRestart <- base::invokeRestart
[08:24:55.456]             length <- base::length
[08:24:55.456]             list <- base::list
[08:24:55.456]             seq.int <- base::seq.int
[08:24:55.456]             signalCondition <- base::signalCondition
[08:24:55.456]             sys.calls <- base::sys.calls
[08:24:55.456]             `[[` <- base::`[[`
[08:24:55.456]             `+` <- base::`+`
[08:24:55.456]             `<<-` <- base::`<<-`
[08:24:55.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.456]                   3L)]
[08:24:55.456]             }
[08:24:55.456]             function(cond) {
[08:24:55.456]                 is_error <- inherits(cond, "error")
[08:24:55.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.456]                   NULL)
[08:24:55.456]                 if (is_error) {
[08:24:55.456]                   sessionInformation <- function() {
[08:24:55.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.456]                       search = base::search(), system = base::Sys.info())
[08:24:55.456]                   }
[08:24:55.456]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.456]                     cond$call), session = sessionInformation(), 
[08:24:55.456]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.456]                   signalCondition(cond)
[08:24:55.456]                 }
[08:24:55.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.456]                 "immediateCondition"))) {
[08:24:55.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.456]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.456]                   if (TRUE && !signal) {
[08:24:55.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.456]                     {
[08:24:55.456]                       inherits <- base::inherits
[08:24:55.456]                       invokeRestart <- base::invokeRestart
[08:24:55.456]                       is.null <- base::is.null
[08:24:55.456]                       muffled <- FALSE
[08:24:55.456]                       if (inherits(cond, "message")) {
[08:24:55.456]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.456]                         if (muffled) 
[08:24:55.456]                           invokeRestart("muffleMessage")
[08:24:55.456]                       }
[08:24:55.456]                       else if (inherits(cond, "warning")) {
[08:24:55.456]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.456]                         if (muffled) 
[08:24:55.456]                           invokeRestart("muffleWarning")
[08:24:55.456]                       }
[08:24:55.456]                       else if (inherits(cond, "condition")) {
[08:24:55.456]                         if (!is.null(pattern)) {
[08:24:55.456]                           computeRestarts <- base::computeRestarts
[08:24:55.456]                           grepl <- base::grepl
[08:24:55.456]                           restarts <- computeRestarts(cond)
[08:24:55.456]                           for (restart in restarts) {
[08:24:55.456]                             name <- restart$name
[08:24:55.456]                             if (is.null(name)) 
[08:24:55.456]                               next
[08:24:55.456]                             if (!grepl(pattern, name)) 
[08:24:55.456]                               next
[08:24:55.456]                             invokeRestart(restart)
[08:24:55.456]                             muffled <- TRUE
[08:24:55.456]                             break
[08:24:55.456]                           }
[08:24:55.456]                         }
[08:24:55.456]                       }
[08:24:55.456]                       invisible(muffled)
[08:24:55.456]                     }
[08:24:55.456]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.456]                   }
[08:24:55.456]                 }
[08:24:55.456]                 else {
[08:24:55.456]                   if (TRUE) {
[08:24:55.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.456]                     {
[08:24:55.456]                       inherits <- base::inherits
[08:24:55.456]                       invokeRestart <- base::invokeRestart
[08:24:55.456]                       is.null <- base::is.null
[08:24:55.456]                       muffled <- FALSE
[08:24:55.456]                       if (inherits(cond, "message")) {
[08:24:55.456]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.456]                         if (muffled) 
[08:24:55.456]                           invokeRestart("muffleMessage")
[08:24:55.456]                       }
[08:24:55.456]                       else if (inherits(cond, "warning")) {
[08:24:55.456]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.456]                         if (muffled) 
[08:24:55.456]                           invokeRestart("muffleWarning")
[08:24:55.456]                       }
[08:24:55.456]                       else if (inherits(cond, "condition")) {
[08:24:55.456]                         if (!is.null(pattern)) {
[08:24:55.456]                           computeRestarts <- base::computeRestarts
[08:24:55.456]                           grepl <- base::grepl
[08:24:55.456]                           restarts <- computeRestarts(cond)
[08:24:55.456]                           for (restart in restarts) {
[08:24:55.456]                             name <- restart$name
[08:24:55.456]                             if (is.null(name)) 
[08:24:55.456]                               next
[08:24:55.456]                             if (!grepl(pattern, name)) 
[08:24:55.456]                               next
[08:24:55.456]                             invokeRestart(restart)
[08:24:55.456]                             muffled <- TRUE
[08:24:55.456]                             break
[08:24:55.456]                           }
[08:24:55.456]                         }
[08:24:55.456]                       }
[08:24:55.456]                       invisible(muffled)
[08:24:55.456]                     }
[08:24:55.456]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.456]                   }
[08:24:55.456]                 }
[08:24:55.456]             }
[08:24:55.456]         }))
[08:24:55.456]     }, error = function(ex) {
[08:24:55.456]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.456]                 ...future.rng), started = ...future.startTime, 
[08:24:55.456]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.456]             version = "1.8"), class = "FutureResult")
[08:24:55.456]     }, finally = {
[08:24:55.456]         if (!identical(...future.workdir, getwd())) 
[08:24:55.456]             setwd(...future.workdir)
[08:24:55.456]         {
[08:24:55.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.456]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.456]             }
[08:24:55.456]             base::options(...future.oldOptions)
[08:24:55.456]             if (.Platform$OS.type == "windows") {
[08:24:55.456]                 old_names <- names(...future.oldEnvVars)
[08:24:55.456]                 envs <- base::Sys.getenv()
[08:24:55.456]                 names <- names(envs)
[08:24:55.456]                 common <- intersect(names, old_names)
[08:24:55.456]                 added <- setdiff(names, old_names)
[08:24:55.456]                 removed <- setdiff(old_names, names)
[08:24:55.456]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.456]                   envs[common]]
[08:24:55.456]                 NAMES <- toupper(changed)
[08:24:55.456]                 args <- list()
[08:24:55.456]                 for (kk in seq_along(NAMES)) {
[08:24:55.456]                   name <- changed[[kk]]
[08:24:55.456]                   NAME <- NAMES[[kk]]
[08:24:55.456]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.456]                     next
[08:24:55.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.456]                 }
[08:24:55.456]                 NAMES <- toupper(added)
[08:24:55.456]                 for (kk in seq_along(NAMES)) {
[08:24:55.456]                   name <- added[[kk]]
[08:24:55.456]                   NAME <- NAMES[[kk]]
[08:24:55.456]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.456]                     next
[08:24:55.456]                   args[[name]] <- ""
[08:24:55.456]                 }
[08:24:55.456]                 NAMES <- toupper(removed)
[08:24:55.456]                 for (kk in seq_along(NAMES)) {
[08:24:55.456]                   name <- removed[[kk]]
[08:24:55.456]                   NAME <- NAMES[[kk]]
[08:24:55.456]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.456]                     next
[08:24:55.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.456]                 }
[08:24:55.456]                 if (length(args) > 0) 
[08:24:55.456]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.456]             }
[08:24:55.456]             else {
[08:24:55.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.456]             }
[08:24:55.456]             {
[08:24:55.456]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.456]                   0L) {
[08:24:55.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.456]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.456]                   base::options(opts)
[08:24:55.456]                 }
[08:24:55.456]                 {
[08:24:55.456]                   {
[08:24:55.456]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.456]                     NULL
[08:24:55.456]                   }
[08:24:55.456]                   options(future.plan = NULL)
[08:24:55.456]                   if (is.na(NA_character_)) 
[08:24:55.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.456]                     .init = FALSE)
[08:24:55.456]                 }
[08:24:55.456]             }
[08:24:55.456]         }
[08:24:55.456]     })
[08:24:55.456]     if (TRUE) {
[08:24:55.456]         base::sink(type = "output", split = FALSE)
[08:24:55.456]         if (TRUE) {
[08:24:55.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.456]         }
[08:24:55.456]         else {
[08:24:55.456]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.456]         }
[08:24:55.456]         base::close(...future.stdout)
[08:24:55.456]         ...future.stdout <- NULL
[08:24:55.456]     }
[08:24:55.456]     ...future.result$conditions <- ...future.conditions
[08:24:55.456]     ...future.result$finished <- base::Sys.time()
[08:24:55.456]     ...future.result
[08:24:55.456] }
[08:24:55.459] Exporting 5 global objects (913 bytes) to cluster node #1 ...
[08:24:55.460] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:55.460] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:55.460] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[08:24:55.461] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[08:24:55.461] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #1 ...
[08:24:55.461] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #1 ... DONE
[08:24:55.461] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:55.461] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:55.462] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:55.462] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:55.462] Exporting 5 global objects (913 bytes) to cluster node #1 ... DONE
[08:24:55.463] MultisessionFuture started
[08:24:55.463] - Launch lazy future ... done
[08:24:55.463] run() for ‘MultisessionFuture’ ... done
[08:24:55.463] Created future:
[08:24:55.463] MultisessionFuture:
[08:24:55.463] Label: ‘future_apply-1’
[08:24:55.463] Expression:
[08:24:55.463] {
[08:24:55.463]     do.call(function(...) {
[08:24:55.463]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.463]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.463]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.463]             on.exit(options(oopts), add = TRUE)
[08:24:55.463]         }
[08:24:55.463]         {
[08:24:55.463]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.463]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.463]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.463]             })
[08:24:55.463]         }
[08:24:55.463]     }, args = future.call.arguments)
[08:24:55.463] }
[08:24:55.463] Lazy evaluation: FALSE
[08:24:55.463] Asynchronous evaluation: TRUE
[08:24:55.463] Local evaluation: TRUE
[08:24:55.463] Environment: R_GlobalEnv
[08:24:55.463] Capture standard output: TRUE
[08:24:55.463] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.463] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.463] Packages: <none>
[08:24:55.463] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.463] Resolved: FALSE
[08:24:55.463] Value: <not collected>
[08:24:55.463] Conditions captured: <none>
[08:24:55.463] Early signaling: FALSE
[08:24:55.463] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.463] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.474] Chunk #1 of 2 ... DONE
[08:24:55.475] Chunk #2 of 2 ...
[08:24:55.475]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.475]  - seeds: <none>
[08:24:55.475]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.475] getGlobalsAndPackages() ...
[08:24:55.475] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.475] Resolving globals: FALSE
[08:24:55.475] Tweak future expression to call with '...' arguments ...
[08:24:55.475] {
[08:24:55.475]     do.call(function(...) {
[08:24:55.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.475]             on.exit(options(oopts), add = TRUE)
[08:24:55.475]         }
[08:24:55.475]         {
[08:24:55.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.475]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.475]             })
[08:24:55.475]         }
[08:24:55.475]     }, args = future.call.arguments)
[08:24:55.475] }
[08:24:55.476] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.476] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.476] 
[08:24:55.476] getGlobalsAndPackages() ... DONE
[08:24:55.477] run() for ‘Future’ ...
[08:24:55.477] - state: ‘created’
[08:24:55.477] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.491] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.491] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.491]   - Field: ‘node’
[08:24:55.491]   - Field: ‘label’
[08:24:55.492]   - Field: ‘local’
[08:24:55.492]   - Field: ‘owner’
[08:24:55.492]   - Field: ‘envir’
[08:24:55.492]   - Field: ‘workers’
[08:24:55.492]   - Field: ‘packages’
[08:24:55.492]   - Field: ‘gc’
[08:24:55.492]   - Field: ‘conditions’
[08:24:55.492]   - Field: ‘persistent’
[08:24:55.492]   - Field: ‘expr’
[08:24:55.492]   - Field: ‘uuid’
[08:24:55.492]   - Field: ‘seed’
[08:24:55.493]   - Field: ‘version’
[08:24:55.493]   - Field: ‘result’
[08:24:55.493]   - Field: ‘asynchronous’
[08:24:55.493]   - Field: ‘calls’
[08:24:55.493]   - Field: ‘globals’
[08:24:55.493]   - Field: ‘stdout’
[08:24:55.493]   - Field: ‘earlySignal’
[08:24:55.493]   - Field: ‘lazy’
[08:24:55.493]   - Field: ‘state’
[08:24:55.493] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.493] - Launch lazy future ...
[08:24:55.494] Packages needed by the future expression (n = 0): <none>
[08:24:55.494] Packages needed by future strategies (n = 0): <none>
[08:24:55.494] {
[08:24:55.494]     {
[08:24:55.494]         {
[08:24:55.494]             ...future.startTime <- base::Sys.time()
[08:24:55.494]             {
[08:24:55.494]                 {
[08:24:55.494]                   {
[08:24:55.494]                     {
[08:24:55.494]                       base::local({
[08:24:55.494]                         has_future <- base::requireNamespace("future", 
[08:24:55.494]                           quietly = TRUE)
[08:24:55.494]                         if (has_future) {
[08:24:55.494]                           ns <- base::getNamespace("future")
[08:24:55.494]                           version <- ns[[".package"]][["version"]]
[08:24:55.494]                           if (is.null(version)) 
[08:24:55.494]                             version <- utils::packageVersion("future")
[08:24:55.494]                         }
[08:24:55.494]                         else {
[08:24:55.494]                           version <- NULL
[08:24:55.494]                         }
[08:24:55.494]                         if (!has_future || version < "1.8.0") {
[08:24:55.494]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.494]                             "", base::R.version$version.string), 
[08:24:55.494]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.494]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.494]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.494]                               "release", "version")], collapse = " "), 
[08:24:55.494]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.494]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.494]                             info)
[08:24:55.494]                           info <- base::paste(info, collapse = "; ")
[08:24:55.494]                           if (!has_future) {
[08:24:55.494]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.494]                               info)
[08:24:55.494]                           }
[08:24:55.494]                           else {
[08:24:55.494]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.494]                               info, version)
[08:24:55.494]                           }
[08:24:55.494]                           base::stop(msg)
[08:24:55.494]                         }
[08:24:55.494]                       })
[08:24:55.494]                     }
[08:24:55.494]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.494]                     base::options(mc.cores = 1L)
[08:24:55.494]                   }
[08:24:55.494]                   ...future.strategy.old <- future::plan("list")
[08:24:55.494]                   options(future.plan = NULL)
[08:24:55.494]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.494]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.494]                 }
[08:24:55.494]                 ...future.workdir <- getwd()
[08:24:55.494]             }
[08:24:55.494]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.494]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.494]         }
[08:24:55.494]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.494]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.494]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.494]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.494]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.494]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.494]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.494]             base::names(...future.oldOptions))
[08:24:55.494]     }
[08:24:55.494]     if (FALSE) {
[08:24:55.494]     }
[08:24:55.494]     else {
[08:24:55.494]         if (TRUE) {
[08:24:55.494]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.494]                 open = "w")
[08:24:55.494]         }
[08:24:55.494]         else {
[08:24:55.494]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.494]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.494]         }
[08:24:55.494]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.494]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.494]             base::sink(type = "output", split = FALSE)
[08:24:55.494]             base::close(...future.stdout)
[08:24:55.494]         }, add = TRUE)
[08:24:55.494]     }
[08:24:55.494]     ...future.frame <- base::sys.nframe()
[08:24:55.494]     ...future.conditions <- base::list()
[08:24:55.494]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.494]     if (FALSE) {
[08:24:55.494]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.494]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.494]     }
[08:24:55.494]     ...future.result <- base::tryCatch({
[08:24:55.494]         base::withCallingHandlers({
[08:24:55.494]             ...future.value <- base::withVisible(base::local({
[08:24:55.494]                 ...future.makeSendCondition <- base::local({
[08:24:55.494]                   sendCondition <- NULL
[08:24:55.494]                   function(frame = 1L) {
[08:24:55.494]                     if (is.function(sendCondition)) 
[08:24:55.494]                       return(sendCondition)
[08:24:55.494]                     ns <- getNamespace("parallel")
[08:24:55.494]                     if (exists("sendData", mode = "function", 
[08:24:55.494]                       envir = ns)) {
[08:24:55.494]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.494]                         envir = ns)
[08:24:55.494]                       envir <- sys.frame(frame)
[08:24:55.494]                       master <- NULL
[08:24:55.494]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.494]                         !identical(envir, emptyenv())) {
[08:24:55.494]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.494]                           inherits = FALSE)) {
[08:24:55.494]                           master <- get("master", mode = "list", 
[08:24:55.494]                             envir = envir, inherits = FALSE)
[08:24:55.494]                           if (inherits(master, c("SOCKnode", 
[08:24:55.494]                             "SOCK0node"))) {
[08:24:55.494]                             sendCondition <<- function(cond) {
[08:24:55.494]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.494]                                 success = TRUE)
[08:24:55.494]                               parallel_sendData(master, data)
[08:24:55.494]                             }
[08:24:55.494]                             return(sendCondition)
[08:24:55.494]                           }
[08:24:55.494]                         }
[08:24:55.494]                         frame <- frame + 1L
[08:24:55.494]                         envir <- sys.frame(frame)
[08:24:55.494]                       }
[08:24:55.494]                     }
[08:24:55.494]                     sendCondition <<- function(cond) NULL
[08:24:55.494]                   }
[08:24:55.494]                 })
[08:24:55.494]                 withCallingHandlers({
[08:24:55.494]                   {
[08:24:55.494]                     do.call(function(...) {
[08:24:55.494]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.494]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.494]                         ...future.globals.maxSize)) {
[08:24:55.494]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.494]                         on.exit(options(oopts), add = TRUE)
[08:24:55.494]                       }
[08:24:55.494]                       {
[08:24:55.494]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.494]                           FUN = function(jj) {
[08:24:55.494]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.494]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.494]                           })
[08:24:55.494]                       }
[08:24:55.494]                     }, args = future.call.arguments)
[08:24:55.494]                   }
[08:24:55.494]                 }, immediateCondition = function(cond) {
[08:24:55.494]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.494]                   sendCondition(cond)
[08:24:55.494]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.494]                   {
[08:24:55.494]                     inherits <- base::inherits
[08:24:55.494]                     invokeRestart <- base::invokeRestart
[08:24:55.494]                     is.null <- base::is.null
[08:24:55.494]                     muffled <- FALSE
[08:24:55.494]                     if (inherits(cond, "message")) {
[08:24:55.494]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.494]                       if (muffled) 
[08:24:55.494]                         invokeRestart("muffleMessage")
[08:24:55.494]                     }
[08:24:55.494]                     else if (inherits(cond, "warning")) {
[08:24:55.494]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.494]                       if (muffled) 
[08:24:55.494]                         invokeRestart("muffleWarning")
[08:24:55.494]                     }
[08:24:55.494]                     else if (inherits(cond, "condition")) {
[08:24:55.494]                       if (!is.null(pattern)) {
[08:24:55.494]                         computeRestarts <- base::computeRestarts
[08:24:55.494]                         grepl <- base::grepl
[08:24:55.494]                         restarts <- computeRestarts(cond)
[08:24:55.494]                         for (restart in restarts) {
[08:24:55.494]                           name <- restart$name
[08:24:55.494]                           if (is.null(name)) 
[08:24:55.494]                             next
[08:24:55.494]                           if (!grepl(pattern, name)) 
[08:24:55.494]                             next
[08:24:55.494]                           invokeRestart(restart)
[08:24:55.494]                           muffled <- TRUE
[08:24:55.494]                           break
[08:24:55.494]                         }
[08:24:55.494]                       }
[08:24:55.494]                     }
[08:24:55.494]                     invisible(muffled)
[08:24:55.494]                   }
[08:24:55.494]                   muffleCondition(cond)
[08:24:55.494]                 })
[08:24:55.494]             }))
[08:24:55.494]             future::FutureResult(value = ...future.value$value, 
[08:24:55.494]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.494]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.494]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.494]                     ...future.globalenv.names))
[08:24:55.494]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.494]         }, condition = base::local({
[08:24:55.494]             c <- base::c
[08:24:55.494]             inherits <- base::inherits
[08:24:55.494]             invokeRestart <- base::invokeRestart
[08:24:55.494]             length <- base::length
[08:24:55.494]             list <- base::list
[08:24:55.494]             seq.int <- base::seq.int
[08:24:55.494]             signalCondition <- base::signalCondition
[08:24:55.494]             sys.calls <- base::sys.calls
[08:24:55.494]             `[[` <- base::`[[`
[08:24:55.494]             `+` <- base::`+`
[08:24:55.494]             `<<-` <- base::`<<-`
[08:24:55.494]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.494]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.494]                   3L)]
[08:24:55.494]             }
[08:24:55.494]             function(cond) {
[08:24:55.494]                 is_error <- inherits(cond, "error")
[08:24:55.494]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.494]                   NULL)
[08:24:55.494]                 if (is_error) {
[08:24:55.494]                   sessionInformation <- function() {
[08:24:55.494]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.494]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.494]                       search = base::search(), system = base::Sys.info())
[08:24:55.494]                   }
[08:24:55.494]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.494]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.494]                     cond$call), session = sessionInformation(), 
[08:24:55.494]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.494]                   signalCondition(cond)
[08:24:55.494]                 }
[08:24:55.494]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.494]                 "immediateCondition"))) {
[08:24:55.494]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.494]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.494]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.494]                   if (TRUE && !signal) {
[08:24:55.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.494]                     {
[08:24:55.494]                       inherits <- base::inherits
[08:24:55.494]                       invokeRestart <- base::invokeRestart
[08:24:55.494]                       is.null <- base::is.null
[08:24:55.494]                       muffled <- FALSE
[08:24:55.494]                       if (inherits(cond, "message")) {
[08:24:55.494]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.494]                         if (muffled) 
[08:24:55.494]                           invokeRestart("muffleMessage")
[08:24:55.494]                       }
[08:24:55.494]                       else if (inherits(cond, "warning")) {
[08:24:55.494]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.494]                         if (muffled) 
[08:24:55.494]                           invokeRestart("muffleWarning")
[08:24:55.494]                       }
[08:24:55.494]                       else if (inherits(cond, "condition")) {
[08:24:55.494]                         if (!is.null(pattern)) {
[08:24:55.494]                           computeRestarts <- base::computeRestarts
[08:24:55.494]                           grepl <- base::grepl
[08:24:55.494]                           restarts <- computeRestarts(cond)
[08:24:55.494]                           for (restart in restarts) {
[08:24:55.494]                             name <- restart$name
[08:24:55.494]                             if (is.null(name)) 
[08:24:55.494]                               next
[08:24:55.494]                             if (!grepl(pattern, name)) 
[08:24:55.494]                               next
[08:24:55.494]                             invokeRestart(restart)
[08:24:55.494]                             muffled <- TRUE
[08:24:55.494]                             break
[08:24:55.494]                           }
[08:24:55.494]                         }
[08:24:55.494]                       }
[08:24:55.494]                       invisible(muffled)
[08:24:55.494]                     }
[08:24:55.494]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.494]                   }
[08:24:55.494]                 }
[08:24:55.494]                 else {
[08:24:55.494]                   if (TRUE) {
[08:24:55.494]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.494]                     {
[08:24:55.494]                       inherits <- base::inherits
[08:24:55.494]                       invokeRestart <- base::invokeRestart
[08:24:55.494]                       is.null <- base::is.null
[08:24:55.494]                       muffled <- FALSE
[08:24:55.494]                       if (inherits(cond, "message")) {
[08:24:55.494]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.494]                         if (muffled) 
[08:24:55.494]                           invokeRestart("muffleMessage")
[08:24:55.494]                       }
[08:24:55.494]                       else if (inherits(cond, "warning")) {
[08:24:55.494]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.494]                         if (muffled) 
[08:24:55.494]                           invokeRestart("muffleWarning")
[08:24:55.494]                       }
[08:24:55.494]                       else if (inherits(cond, "condition")) {
[08:24:55.494]                         if (!is.null(pattern)) {
[08:24:55.494]                           computeRestarts <- base::computeRestarts
[08:24:55.494]                           grepl <- base::grepl
[08:24:55.494]                           restarts <- computeRestarts(cond)
[08:24:55.494]                           for (restart in restarts) {
[08:24:55.494]                             name <- restart$name
[08:24:55.494]                             if (is.null(name)) 
[08:24:55.494]                               next
[08:24:55.494]                             if (!grepl(pattern, name)) 
[08:24:55.494]                               next
[08:24:55.494]                             invokeRestart(restart)
[08:24:55.494]                             muffled <- TRUE
[08:24:55.494]                             break
[08:24:55.494]                           }
[08:24:55.494]                         }
[08:24:55.494]                       }
[08:24:55.494]                       invisible(muffled)
[08:24:55.494]                     }
[08:24:55.494]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.494]                   }
[08:24:55.494]                 }
[08:24:55.494]             }
[08:24:55.494]         }))
[08:24:55.494]     }, error = function(ex) {
[08:24:55.494]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.494]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.494]                 ...future.rng), started = ...future.startTime, 
[08:24:55.494]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.494]             version = "1.8"), class = "FutureResult")
[08:24:55.494]     }, finally = {
[08:24:55.494]         if (!identical(...future.workdir, getwd())) 
[08:24:55.494]             setwd(...future.workdir)
[08:24:55.494]         {
[08:24:55.494]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.494]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.494]             }
[08:24:55.494]             base::options(...future.oldOptions)
[08:24:55.494]             if (.Platform$OS.type == "windows") {
[08:24:55.494]                 old_names <- names(...future.oldEnvVars)
[08:24:55.494]                 envs <- base::Sys.getenv()
[08:24:55.494]                 names <- names(envs)
[08:24:55.494]                 common <- intersect(names, old_names)
[08:24:55.494]                 added <- setdiff(names, old_names)
[08:24:55.494]                 removed <- setdiff(old_names, names)
[08:24:55.494]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.494]                   envs[common]]
[08:24:55.494]                 NAMES <- toupper(changed)
[08:24:55.494]                 args <- list()
[08:24:55.494]                 for (kk in seq_along(NAMES)) {
[08:24:55.494]                   name <- changed[[kk]]
[08:24:55.494]                   NAME <- NAMES[[kk]]
[08:24:55.494]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.494]                     next
[08:24:55.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.494]                 }
[08:24:55.494]                 NAMES <- toupper(added)
[08:24:55.494]                 for (kk in seq_along(NAMES)) {
[08:24:55.494]                   name <- added[[kk]]
[08:24:55.494]                   NAME <- NAMES[[kk]]
[08:24:55.494]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.494]                     next
[08:24:55.494]                   args[[name]] <- ""
[08:24:55.494]                 }
[08:24:55.494]                 NAMES <- toupper(removed)
[08:24:55.494]                 for (kk in seq_along(NAMES)) {
[08:24:55.494]                   name <- removed[[kk]]
[08:24:55.494]                   NAME <- NAMES[[kk]]
[08:24:55.494]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.494]                     next
[08:24:55.494]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.494]                 }
[08:24:55.494]                 if (length(args) > 0) 
[08:24:55.494]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.494]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.494]             }
[08:24:55.494]             else {
[08:24:55.494]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.494]             }
[08:24:55.494]             {
[08:24:55.494]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.494]                   0L) {
[08:24:55.494]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.494]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.494]                   base::options(opts)
[08:24:55.494]                 }
[08:24:55.494]                 {
[08:24:55.494]                   {
[08:24:55.494]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.494]                     NULL
[08:24:55.494]                   }
[08:24:55.494]                   options(future.plan = NULL)
[08:24:55.494]                   if (is.na(NA_character_)) 
[08:24:55.494]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.494]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.494]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.494]                     .init = FALSE)
[08:24:55.494]                 }
[08:24:55.494]             }
[08:24:55.494]         }
[08:24:55.494]     })
[08:24:55.494]     if (TRUE) {
[08:24:55.494]         base::sink(type = "output", split = FALSE)
[08:24:55.494]         if (TRUE) {
[08:24:55.494]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.494]         }
[08:24:55.494]         else {
[08:24:55.494]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.494]         }
[08:24:55.494]         base::close(...future.stdout)
[08:24:55.494]         ...future.stdout <- NULL
[08:24:55.494]     }
[08:24:55.494]     ...future.result$conditions <- ...future.conditions
[08:24:55.494]     ...future.result$finished <- base::Sys.time()
[08:24:55.494]     ...future.result
[08:24:55.494] }
[08:24:55.497] Exporting 5 global objects (913 bytes) to cluster node #2 ...
[08:24:55.497] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:55.498] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:55.498] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[08:24:55.498] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[08:24:55.498] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #2 ...
[08:24:55.499] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #2 ... DONE
[08:24:55.499] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:55.499] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:55.499] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:55.500] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:55.500] Exporting 5 global objects (913 bytes) to cluster node #2 ... DONE
[08:24:55.500] MultisessionFuture started
[08:24:55.501] - Launch lazy future ... done
[08:24:55.501] run() for ‘MultisessionFuture’ ... done
[08:24:55.501] Created future:
[08:24:55.501] MultisessionFuture:
[08:24:55.501] Label: ‘future_apply-2’
[08:24:55.501] Expression:
[08:24:55.501] {
[08:24:55.501]     do.call(function(...) {
[08:24:55.501]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.501]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.501]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.501]             on.exit(options(oopts), add = TRUE)
[08:24:55.501]         }
[08:24:55.501]         {
[08:24:55.501]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.501]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.501]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.501]             })
[08:24:55.501]         }
[08:24:55.501]     }, args = future.call.arguments)
[08:24:55.501] }
[08:24:55.501] Lazy evaluation: FALSE
[08:24:55.501] Asynchronous evaluation: TRUE
[08:24:55.501] Local evaluation: TRUE
[08:24:55.501] Environment: R_GlobalEnv
[08:24:55.501] Capture standard output: TRUE
[08:24:55.501] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.501] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.501] Packages: <none>
[08:24:55.501] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.501] Resolved: FALSE
[08:24:55.501] Value: <not collected>
[08:24:55.501] Conditions captured: <none>
[08:24:55.501] Early signaling: FALSE
[08:24:55.501] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.501] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.512] Chunk #2 of 2 ... DONE
[08:24:55.512] Launching 2 futures (chunks) ... DONE
[08:24:55.513] Resolving 2 futures (chunks) ...
[08:24:55.513] resolve() on list ...
[08:24:55.513]  recursive: 0
[08:24:55.513]  length: 2
[08:24:55.513] 
[08:24:55.513] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.514] - Validating connection of MultisessionFuture
[08:24:55.514] - received message: FutureResult
[08:24:55.514] - Received FutureResult
[08:24:55.514] - Erased future from FutureRegistry
[08:24:55.514] result() for ClusterFuture ...
[08:24:55.514] - result already collected: FutureResult
[08:24:55.514] result() for ClusterFuture ... done
[08:24:55.514] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.514] Future #1
[08:24:55.515] result() for ClusterFuture ...
[08:24:55.515] - result already collected: FutureResult
[08:24:55.515] result() for ClusterFuture ... done
[08:24:55.515] result() for ClusterFuture ...
[08:24:55.515] - result already collected: FutureResult
[08:24:55.515] result() for ClusterFuture ... done
[08:24:55.515] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:55.515] - nx: 2
[08:24:55.515] - relay: TRUE
[08:24:55.515] - stdout: TRUE
[08:24:55.515] - signal: TRUE
[08:24:55.515] - resignal: FALSE
[08:24:55.516] - force: TRUE
[08:24:55.516] - relayed: [n=2] FALSE, FALSE
[08:24:55.516] - queued futures: [n=2] FALSE, FALSE
[08:24:55.516]  - until=1
[08:24:55.516]  - relaying element #1
[08:24:55.516] result() for ClusterFuture ...
[08:24:55.516] - result already collected: FutureResult
[08:24:55.516] result() for ClusterFuture ... done
[08:24:55.516] result() for ClusterFuture ...
[08:24:55.516] - result already collected: FutureResult
[08:24:55.516] result() for ClusterFuture ... done
[08:24:55.516] result() for ClusterFuture ...
[08:24:55.517] - result already collected: FutureResult
[08:24:55.517] result() for ClusterFuture ... done
[08:24:55.517] result() for ClusterFuture ...
[08:24:55.517] - result already collected: FutureResult
[08:24:55.517] result() for ClusterFuture ... done
[08:24:55.517] - relayed: [n=2] TRUE, FALSE
[08:24:55.517] - queued futures: [n=2] TRUE, FALSE
[08:24:55.517] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:55.517]  length: 1 (resolved future 1)
[08:24:55.543] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.543] - Validating connection of MultisessionFuture
[08:24:55.544] - received message: FutureResult
[08:24:55.544] - Received FutureResult
[08:24:55.544] - Erased future from FutureRegistry
[08:24:55.544] result() for ClusterFuture ...
[08:24:55.544] - result already collected: FutureResult
[08:24:55.544] result() for ClusterFuture ... done
[08:24:55.544] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.544] Future #2
[08:24:55.544] result() for ClusterFuture ...
[08:24:55.545] - result already collected: FutureResult
[08:24:55.545] result() for ClusterFuture ... done
[08:24:55.545] result() for ClusterFuture ...
[08:24:55.545] - result already collected: FutureResult
[08:24:55.545] result() for ClusterFuture ... done
[08:24:55.545] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:55.545] - nx: 2
[08:24:55.545] - relay: TRUE
[08:24:55.545] - stdout: TRUE
[08:24:55.545] - signal: TRUE
[08:24:55.545] - resignal: FALSE
[08:24:55.546] - force: TRUE
[08:24:55.546] - relayed: [n=2] TRUE, FALSE
[08:24:55.546] - queued futures: [n=2] TRUE, FALSE
[08:24:55.546]  - until=2
[08:24:55.546]  - relaying element #2
[08:24:55.546] result() for ClusterFuture ...
[08:24:55.546] - result already collected: FutureResult
[08:24:55.546] result() for ClusterFuture ... done
[08:24:55.546] result() for ClusterFuture ...
[08:24:55.546] - result already collected: FutureResult
[08:24:55.546] result() for ClusterFuture ... done
[08:24:55.547] result() for ClusterFuture ...
[08:24:55.547] - result already collected: FutureResult
[08:24:55.547] result() for ClusterFuture ... done
[08:24:55.547] result() for ClusterFuture ...
[08:24:55.547] - result already collected: FutureResult
[08:24:55.547] result() for ClusterFuture ... done
[08:24:55.547] - relayed: [n=2] TRUE, TRUE
[08:24:55.547] - queued futures: [n=2] TRUE, TRUE
[08:24:55.547] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:55.547]  length: 0 (resolved future 2)
[08:24:55.547] Relaying remaining futures
[08:24:55.547] signalConditionsASAP(NULL, pos=0) ...
[08:24:55.548] - nx: 2
[08:24:55.548] - relay: TRUE
[08:24:55.548] - stdout: TRUE
[08:24:55.548] - signal: TRUE
[08:24:55.548] - resignal: FALSE
[08:24:55.548] - force: TRUE
[08:24:55.548] - relayed: [n=2] TRUE, TRUE
[08:24:55.548] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:55.548] - relayed: [n=2] TRUE, TRUE
[08:24:55.548] - queued futures: [n=2] TRUE, TRUE
[08:24:55.548] signalConditionsASAP(NULL, pos=0) ... done
[08:24:55.548] resolve() on list ... DONE
[08:24:55.549] result() for ClusterFuture ...
[08:24:55.549] - result already collected: FutureResult
[08:24:55.549] result() for ClusterFuture ... done
[08:24:55.549] result() for ClusterFuture ...
[08:24:55.549] - result already collected: FutureResult
[08:24:55.549] result() for ClusterFuture ... done
[08:24:55.549] result() for ClusterFuture ...
[08:24:55.549] - result already collected: FutureResult
[08:24:55.549] result() for ClusterFuture ... done
[08:24:55.549] result() for ClusterFuture ...
[08:24:55.549] - result already collected: FutureResult
[08:24:55.550] result() for ClusterFuture ... done
[08:24:55.550]  - Number of value chunks collected: 2
[08:24:55.550] Resolving 2 futures (chunks) ... DONE
[08:24:55.550] Reducing values from 2 chunks ...
[08:24:55.550]  - Number of values collected after concatenation: 2
[08:24:55.550]  - Number of values expected: 2
[08:24:55.550] Reducing values from 2 chunks ... DONE
[08:24:55.550] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[08:24:55.551] getGlobalsAndPackagesXApply() ...
[08:24:55.551]  - future.globals: TRUE
[08:24:55.551] getGlobalsAndPackages() ...
[08:24:55.551] Searching for globals...
[08:24:55.553] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[08:24:55.553] Searching for globals ... DONE
[08:24:55.554] Resolving globals: FALSE
[08:24:55.554] The total size of the 1 globals is 1.28 KiB (1311 bytes)
[08:24:55.555] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 1.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.28 KiB of class ‘function’)
[08:24:55.555] - globals: [1] ‘FUN’
[08:24:55.555] 
[08:24:55.555] getGlobalsAndPackages() ... DONE
[08:24:55.555]  - globals found/used: [n=1] ‘FUN’
[08:24:55.555]  - needed namespaces: [n=0] 
[08:24:55.555] Finding globals ... DONE
[08:24:55.555]  - use_args: TRUE
[08:24:55.555]  - Getting '...' globals ...
[08:24:55.556] resolve() on list ...
[08:24:55.556]  recursive: 0
[08:24:55.556]  length: 1
[08:24:55.556]  elements: ‘...’
[08:24:55.556]  length: 0 (resolved future 1)
[08:24:55.556] resolve() on list ... DONE
[08:24:55.556]    - '...' content: [n=0] 
[08:24:55.556] List of 1
[08:24:55.556]  $ ...: list()
[08:24:55.556]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.556]  - attr(*, "where")=List of 1
[08:24:55.556]   ..$ ...:<environment: 0x56540ff2f4c8> 
[08:24:55.556]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.556]  - attr(*, "resolved")= logi TRUE
[08:24:55.556]  - attr(*, "total_size")= num NA
[08:24:55.559]  - Getting '...' globals ... DONE
[08:24:55.559] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:55.559] List of 2
[08:24:55.559]  $ ...future.FUN:function (x)  
[08:24:55.559]  $ ...          : list()
[08:24:55.559]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.559]  - attr(*, "where")=List of 2
[08:24:55.559]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:55.559]   ..$ ...          :<environment: 0x56540ff2f4c8> 
[08:24:55.559]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.559]  - attr(*, "resolved")= logi FALSE
[08:24:55.559]  - attr(*, "total_size")= num 4449
[08:24:55.562] Packages to be attached in all futures: [n=0] 
[08:24:55.562] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.563] future_lapply() ...
[08:24:55.566] Number of chunks: 2
[08:24:55.566] getGlobalsAndPackagesXApply() ...
[08:24:55.566]  - future.globals: <name-value list> with names ‘list()’
[08:24:55.567]  - use_args: TRUE
[08:24:55.567] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:55.567] List of 2
[08:24:55.567]  $ ...          : list()
[08:24:55.567]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.567]  $ ...future.FUN:function (x)  
[08:24:55.567]  - attr(*, "where")=List of 2
[08:24:55.567]   ..$ ...          :<environment: 0x56540ff2f4c8> 
[08:24:55.567]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[08:24:55.567]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.567]  - attr(*, "resolved")= logi FALSE
[08:24:55.567]  - attr(*, "total_size")= num NA
[08:24:55.572] Packages to be attached in all futures: [n=0] 
[08:24:55.572] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.572] Number of futures (= number of chunks): 2
[08:24:55.572] Launching 2 futures (chunks) ...
[08:24:55.573] Chunk #1 of 2 ...
[08:24:55.573]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.573]  - seeds: <none>
[08:24:55.573]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.573] getGlobalsAndPackages() ...
[08:24:55.573] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.573] Resolving globals: FALSE
[08:24:55.573] Tweak future expression to call with '...' arguments ...
[08:24:55.573] {
[08:24:55.573]     do.call(function(...) {
[08:24:55.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.573]             on.exit(options(oopts), add = TRUE)
[08:24:55.573]         }
[08:24:55.573]         {
[08:24:55.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.573]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.573]             })
[08:24:55.573]         }
[08:24:55.573]     }, args = future.call.arguments)
[08:24:55.573] }
[08:24:55.574] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.574] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.574] 
[08:24:55.574] getGlobalsAndPackages() ... DONE
[08:24:55.574] run() for ‘Future’ ...
[08:24:55.575] - state: ‘created’
[08:24:55.575] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.589] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.589]   - Field: ‘node’
[08:24:55.589]   - Field: ‘label’
[08:24:55.589]   - Field: ‘local’
[08:24:55.589]   - Field: ‘owner’
[08:24:55.589]   - Field: ‘envir’
[08:24:55.590]   - Field: ‘workers’
[08:24:55.590]   - Field: ‘packages’
[08:24:55.590]   - Field: ‘gc’
[08:24:55.590]   - Field: ‘conditions’
[08:24:55.590]   - Field: ‘persistent’
[08:24:55.590]   - Field: ‘expr’
[08:24:55.590]   - Field: ‘uuid’
[08:24:55.590]   - Field: ‘seed’
[08:24:55.590]   - Field: ‘version’
[08:24:55.590]   - Field: ‘result’
[08:24:55.590]   - Field: ‘asynchronous’
[08:24:55.590]   - Field: ‘calls’
[08:24:55.591]   - Field: ‘globals’
[08:24:55.591]   - Field: ‘stdout’
[08:24:55.591]   - Field: ‘earlySignal’
[08:24:55.591]   - Field: ‘lazy’
[08:24:55.591]   - Field: ‘state’
[08:24:55.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.591] - Launch lazy future ...
[08:24:55.591] Packages needed by the future expression (n = 0): <none>
[08:24:55.592] Packages needed by future strategies (n = 0): <none>
[08:24:55.592] {
[08:24:55.592]     {
[08:24:55.592]         {
[08:24:55.592]             ...future.startTime <- base::Sys.time()
[08:24:55.592]             {
[08:24:55.592]                 {
[08:24:55.592]                   {
[08:24:55.592]                     {
[08:24:55.592]                       base::local({
[08:24:55.592]                         has_future <- base::requireNamespace("future", 
[08:24:55.592]                           quietly = TRUE)
[08:24:55.592]                         if (has_future) {
[08:24:55.592]                           ns <- base::getNamespace("future")
[08:24:55.592]                           version <- ns[[".package"]][["version"]]
[08:24:55.592]                           if (is.null(version)) 
[08:24:55.592]                             version <- utils::packageVersion("future")
[08:24:55.592]                         }
[08:24:55.592]                         else {
[08:24:55.592]                           version <- NULL
[08:24:55.592]                         }
[08:24:55.592]                         if (!has_future || version < "1.8.0") {
[08:24:55.592]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.592]                             "", base::R.version$version.string), 
[08:24:55.592]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.592]                               "release", "version")], collapse = " "), 
[08:24:55.592]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.592]                             info)
[08:24:55.592]                           info <- base::paste(info, collapse = "; ")
[08:24:55.592]                           if (!has_future) {
[08:24:55.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.592]                               info)
[08:24:55.592]                           }
[08:24:55.592]                           else {
[08:24:55.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.592]                               info, version)
[08:24:55.592]                           }
[08:24:55.592]                           base::stop(msg)
[08:24:55.592]                         }
[08:24:55.592]                       })
[08:24:55.592]                     }
[08:24:55.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.592]                     base::options(mc.cores = 1L)
[08:24:55.592]                   }
[08:24:55.592]                   ...future.strategy.old <- future::plan("list")
[08:24:55.592]                   options(future.plan = NULL)
[08:24:55.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.592]                 }
[08:24:55.592]                 ...future.workdir <- getwd()
[08:24:55.592]             }
[08:24:55.592]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.592]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.592]         }
[08:24:55.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.592]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.592]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.592]             base::names(...future.oldOptions))
[08:24:55.592]     }
[08:24:55.592]     if (FALSE) {
[08:24:55.592]     }
[08:24:55.592]     else {
[08:24:55.592]         if (TRUE) {
[08:24:55.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.592]                 open = "w")
[08:24:55.592]         }
[08:24:55.592]         else {
[08:24:55.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.592]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.592]         }
[08:24:55.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.592]             base::sink(type = "output", split = FALSE)
[08:24:55.592]             base::close(...future.stdout)
[08:24:55.592]         }, add = TRUE)
[08:24:55.592]     }
[08:24:55.592]     ...future.frame <- base::sys.nframe()
[08:24:55.592]     ...future.conditions <- base::list()
[08:24:55.592]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.592]     if (FALSE) {
[08:24:55.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.592]     }
[08:24:55.592]     ...future.result <- base::tryCatch({
[08:24:55.592]         base::withCallingHandlers({
[08:24:55.592]             ...future.value <- base::withVisible(base::local({
[08:24:55.592]                 ...future.makeSendCondition <- base::local({
[08:24:55.592]                   sendCondition <- NULL
[08:24:55.592]                   function(frame = 1L) {
[08:24:55.592]                     if (is.function(sendCondition)) 
[08:24:55.592]                       return(sendCondition)
[08:24:55.592]                     ns <- getNamespace("parallel")
[08:24:55.592]                     if (exists("sendData", mode = "function", 
[08:24:55.592]                       envir = ns)) {
[08:24:55.592]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.592]                         envir = ns)
[08:24:55.592]                       envir <- sys.frame(frame)
[08:24:55.592]                       master <- NULL
[08:24:55.592]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.592]                         !identical(envir, emptyenv())) {
[08:24:55.592]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.592]                           inherits = FALSE)) {
[08:24:55.592]                           master <- get("master", mode = "list", 
[08:24:55.592]                             envir = envir, inherits = FALSE)
[08:24:55.592]                           if (inherits(master, c("SOCKnode", 
[08:24:55.592]                             "SOCK0node"))) {
[08:24:55.592]                             sendCondition <<- function(cond) {
[08:24:55.592]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.592]                                 success = TRUE)
[08:24:55.592]                               parallel_sendData(master, data)
[08:24:55.592]                             }
[08:24:55.592]                             return(sendCondition)
[08:24:55.592]                           }
[08:24:55.592]                         }
[08:24:55.592]                         frame <- frame + 1L
[08:24:55.592]                         envir <- sys.frame(frame)
[08:24:55.592]                       }
[08:24:55.592]                     }
[08:24:55.592]                     sendCondition <<- function(cond) NULL
[08:24:55.592]                   }
[08:24:55.592]                 })
[08:24:55.592]                 withCallingHandlers({
[08:24:55.592]                   {
[08:24:55.592]                     do.call(function(...) {
[08:24:55.592]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.592]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.592]                         ...future.globals.maxSize)) {
[08:24:55.592]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.592]                         on.exit(options(oopts), add = TRUE)
[08:24:55.592]                       }
[08:24:55.592]                       {
[08:24:55.592]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.592]                           FUN = function(jj) {
[08:24:55.592]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.592]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.592]                           })
[08:24:55.592]                       }
[08:24:55.592]                     }, args = future.call.arguments)
[08:24:55.592]                   }
[08:24:55.592]                 }, immediateCondition = function(cond) {
[08:24:55.592]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.592]                   sendCondition(cond)
[08:24:55.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.592]                   {
[08:24:55.592]                     inherits <- base::inherits
[08:24:55.592]                     invokeRestart <- base::invokeRestart
[08:24:55.592]                     is.null <- base::is.null
[08:24:55.592]                     muffled <- FALSE
[08:24:55.592]                     if (inherits(cond, "message")) {
[08:24:55.592]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.592]                       if (muffled) 
[08:24:55.592]                         invokeRestart("muffleMessage")
[08:24:55.592]                     }
[08:24:55.592]                     else if (inherits(cond, "warning")) {
[08:24:55.592]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.592]                       if (muffled) 
[08:24:55.592]                         invokeRestart("muffleWarning")
[08:24:55.592]                     }
[08:24:55.592]                     else if (inherits(cond, "condition")) {
[08:24:55.592]                       if (!is.null(pattern)) {
[08:24:55.592]                         computeRestarts <- base::computeRestarts
[08:24:55.592]                         grepl <- base::grepl
[08:24:55.592]                         restarts <- computeRestarts(cond)
[08:24:55.592]                         for (restart in restarts) {
[08:24:55.592]                           name <- restart$name
[08:24:55.592]                           if (is.null(name)) 
[08:24:55.592]                             next
[08:24:55.592]                           if (!grepl(pattern, name)) 
[08:24:55.592]                             next
[08:24:55.592]                           invokeRestart(restart)
[08:24:55.592]                           muffled <- TRUE
[08:24:55.592]                           break
[08:24:55.592]                         }
[08:24:55.592]                       }
[08:24:55.592]                     }
[08:24:55.592]                     invisible(muffled)
[08:24:55.592]                   }
[08:24:55.592]                   muffleCondition(cond)
[08:24:55.592]                 })
[08:24:55.592]             }))
[08:24:55.592]             future::FutureResult(value = ...future.value$value, 
[08:24:55.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.592]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.592]                     ...future.globalenv.names))
[08:24:55.592]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.592]         }, condition = base::local({
[08:24:55.592]             c <- base::c
[08:24:55.592]             inherits <- base::inherits
[08:24:55.592]             invokeRestart <- base::invokeRestart
[08:24:55.592]             length <- base::length
[08:24:55.592]             list <- base::list
[08:24:55.592]             seq.int <- base::seq.int
[08:24:55.592]             signalCondition <- base::signalCondition
[08:24:55.592]             sys.calls <- base::sys.calls
[08:24:55.592]             `[[` <- base::`[[`
[08:24:55.592]             `+` <- base::`+`
[08:24:55.592]             `<<-` <- base::`<<-`
[08:24:55.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.592]                   3L)]
[08:24:55.592]             }
[08:24:55.592]             function(cond) {
[08:24:55.592]                 is_error <- inherits(cond, "error")
[08:24:55.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.592]                   NULL)
[08:24:55.592]                 if (is_error) {
[08:24:55.592]                   sessionInformation <- function() {
[08:24:55.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.592]                       search = base::search(), system = base::Sys.info())
[08:24:55.592]                   }
[08:24:55.592]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.592]                     cond$call), session = sessionInformation(), 
[08:24:55.592]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.592]                   signalCondition(cond)
[08:24:55.592]                 }
[08:24:55.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.592]                 "immediateCondition"))) {
[08:24:55.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.592]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.592]                   if (TRUE && !signal) {
[08:24:55.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.592]                     {
[08:24:55.592]                       inherits <- base::inherits
[08:24:55.592]                       invokeRestart <- base::invokeRestart
[08:24:55.592]                       is.null <- base::is.null
[08:24:55.592]                       muffled <- FALSE
[08:24:55.592]                       if (inherits(cond, "message")) {
[08:24:55.592]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.592]                         if (muffled) 
[08:24:55.592]                           invokeRestart("muffleMessage")
[08:24:55.592]                       }
[08:24:55.592]                       else if (inherits(cond, "warning")) {
[08:24:55.592]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.592]                         if (muffled) 
[08:24:55.592]                           invokeRestart("muffleWarning")
[08:24:55.592]                       }
[08:24:55.592]                       else if (inherits(cond, "condition")) {
[08:24:55.592]                         if (!is.null(pattern)) {
[08:24:55.592]                           computeRestarts <- base::computeRestarts
[08:24:55.592]                           grepl <- base::grepl
[08:24:55.592]                           restarts <- computeRestarts(cond)
[08:24:55.592]                           for (restart in restarts) {
[08:24:55.592]                             name <- restart$name
[08:24:55.592]                             if (is.null(name)) 
[08:24:55.592]                               next
[08:24:55.592]                             if (!grepl(pattern, name)) 
[08:24:55.592]                               next
[08:24:55.592]                             invokeRestart(restart)
[08:24:55.592]                             muffled <- TRUE
[08:24:55.592]                             break
[08:24:55.592]                           }
[08:24:55.592]                         }
[08:24:55.592]                       }
[08:24:55.592]                       invisible(muffled)
[08:24:55.592]                     }
[08:24:55.592]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.592]                   }
[08:24:55.592]                 }
[08:24:55.592]                 else {
[08:24:55.592]                   if (TRUE) {
[08:24:55.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.592]                     {
[08:24:55.592]                       inherits <- base::inherits
[08:24:55.592]                       invokeRestart <- base::invokeRestart
[08:24:55.592]                       is.null <- base::is.null
[08:24:55.592]                       muffled <- FALSE
[08:24:55.592]                       if (inherits(cond, "message")) {
[08:24:55.592]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.592]                         if (muffled) 
[08:24:55.592]                           invokeRestart("muffleMessage")
[08:24:55.592]                       }
[08:24:55.592]                       else if (inherits(cond, "warning")) {
[08:24:55.592]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.592]                         if (muffled) 
[08:24:55.592]                           invokeRestart("muffleWarning")
[08:24:55.592]                       }
[08:24:55.592]                       else if (inherits(cond, "condition")) {
[08:24:55.592]                         if (!is.null(pattern)) {
[08:24:55.592]                           computeRestarts <- base::computeRestarts
[08:24:55.592]                           grepl <- base::grepl
[08:24:55.592]                           restarts <- computeRestarts(cond)
[08:24:55.592]                           for (restart in restarts) {
[08:24:55.592]                             name <- restart$name
[08:24:55.592]                             if (is.null(name)) 
[08:24:55.592]                               next
[08:24:55.592]                             if (!grepl(pattern, name)) 
[08:24:55.592]                               next
[08:24:55.592]                             invokeRestart(restart)
[08:24:55.592]                             muffled <- TRUE
[08:24:55.592]                             break
[08:24:55.592]                           }
[08:24:55.592]                         }
[08:24:55.592]                       }
[08:24:55.592]                       invisible(muffled)
[08:24:55.592]                     }
[08:24:55.592]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.592]                   }
[08:24:55.592]                 }
[08:24:55.592]             }
[08:24:55.592]         }))
[08:24:55.592]     }, error = function(ex) {
[08:24:55.592]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.592]                 ...future.rng), started = ...future.startTime, 
[08:24:55.592]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.592]             version = "1.8"), class = "FutureResult")
[08:24:55.592]     }, finally = {
[08:24:55.592]         if (!identical(...future.workdir, getwd())) 
[08:24:55.592]             setwd(...future.workdir)
[08:24:55.592]         {
[08:24:55.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.592]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.592]             }
[08:24:55.592]             base::options(...future.oldOptions)
[08:24:55.592]             if (.Platform$OS.type == "windows") {
[08:24:55.592]                 old_names <- names(...future.oldEnvVars)
[08:24:55.592]                 envs <- base::Sys.getenv()
[08:24:55.592]                 names <- names(envs)
[08:24:55.592]                 common <- intersect(names, old_names)
[08:24:55.592]                 added <- setdiff(names, old_names)
[08:24:55.592]                 removed <- setdiff(old_names, names)
[08:24:55.592]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.592]                   envs[common]]
[08:24:55.592]                 NAMES <- toupper(changed)
[08:24:55.592]                 args <- list()
[08:24:55.592]                 for (kk in seq_along(NAMES)) {
[08:24:55.592]                   name <- changed[[kk]]
[08:24:55.592]                   NAME <- NAMES[[kk]]
[08:24:55.592]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.592]                     next
[08:24:55.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.592]                 }
[08:24:55.592]                 NAMES <- toupper(added)
[08:24:55.592]                 for (kk in seq_along(NAMES)) {
[08:24:55.592]                   name <- added[[kk]]
[08:24:55.592]                   NAME <- NAMES[[kk]]
[08:24:55.592]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.592]                     next
[08:24:55.592]                   args[[name]] <- ""
[08:24:55.592]                 }
[08:24:55.592]                 NAMES <- toupper(removed)
[08:24:55.592]                 for (kk in seq_along(NAMES)) {
[08:24:55.592]                   name <- removed[[kk]]
[08:24:55.592]                   NAME <- NAMES[[kk]]
[08:24:55.592]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.592]                     next
[08:24:55.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.592]                 }
[08:24:55.592]                 if (length(args) > 0) 
[08:24:55.592]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.592]             }
[08:24:55.592]             else {
[08:24:55.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.592]             }
[08:24:55.592]             {
[08:24:55.592]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.592]                   0L) {
[08:24:55.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.592]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.592]                   base::options(opts)
[08:24:55.592]                 }
[08:24:55.592]                 {
[08:24:55.592]                   {
[08:24:55.592]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.592]                     NULL
[08:24:55.592]                   }
[08:24:55.592]                   options(future.plan = NULL)
[08:24:55.592]                   if (is.na(NA_character_)) 
[08:24:55.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.592]                     .init = FALSE)
[08:24:55.592]                 }
[08:24:55.592]             }
[08:24:55.592]         }
[08:24:55.592]     })
[08:24:55.592]     if (TRUE) {
[08:24:55.592]         base::sink(type = "output", split = FALSE)
[08:24:55.592]         if (TRUE) {
[08:24:55.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.592]         }
[08:24:55.592]         else {
[08:24:55.592]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.592]         }
[08:24:55.592]         base::close(...future.stdout)
[08:24:55.592]         ...future.stdout <- NULL
[08:24:55.592]     }
[08:24:55.592]     ...future.result$conditions <- ...future.conditions
[08:24:55.592]     ...future.result$finished <- base::Sys.time()
[08:24:55.592]     ...future.result
[08:24:55.592] }
[08:24:55.595] Exporting 5 global objects (1.92 KiB) to cluster node #1 ...
[08:24:55.595] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:55.596] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:55.596] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ...
[08:24:55.596] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ... DONE
[08:24:55.596] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ...
[08:24:55.597] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ... DONE
[08:24:55.597] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[08:24:55.597] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[08:24:55.597] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:55.598] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:55.598] Exporting 5 global objects (1.92 KiB) to cluster node #1 ... DONE
[08:24:55.598] MultisessionFuture started
[08:24:55.598] - Launch lazy future ... done
[08:24:55.598] run() for ‘MultisessionFuture’ ... done
[08:24:55.598] Created future:
[08:24:55.599] MultisessionFuture:
[08:24:55.599] Label: ‘future_apply-1’
[08:24:55.599] Expression:
[08:24:55.599] {
[08:24:55.599]     do.call(function(...) {
[08:24:55.599]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.599]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.599]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.599]             on.exit(options(oopts), add = TRUE)
[08:24:55.599]         }
[08:24:55.599]         {
[08:24:55.599]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.599]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.599]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.599]             })
[08:24:55.599]         }
[08:24:55.599]     }, args = future.call.arguments)
[08:24:55.599] }
[08:24:55.599] Lazy evaluation: FALSE
[08:24:55.599] Asynchronous evaluation: TRUE
[08:24:55.599] Local evaluation: TRUE
[08:24:55.599] Environment: R_GlobalEnv
[08:24:55.599] Capture standard output: TRUE
[08:24:55.599] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.599] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.599] Packages: <none>
[08:24:55.599] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.599] Resolved: FALSE
[08:24:55.599] Value: <not collected>
[08:24:55.599] Conditions captured: <none>
[08:24:55.599] Early signaling: FALSE
[08:24:55.599] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.599] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.610] Chunk #1 of 2 ... DONE
[08:24:55.610] Chunk #2 of 2 ...
[08:24:55.610]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.610]  - seeds: <none>
[08:24:55.611]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.611] getGlobalsAndPackages() ...
[08:24:55.611] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.611] Resolving globals: FALSE
[08:24:55.611] Tweak future expression to call with '...' arguments ...
[08:24:55.611] {
[08:24:55.611]     do.call(function(...) {
[08:24:55.611]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.611]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.611]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.611]             on.exit(options(oopts), add = TRUE)
[08:24:55.611]         }
[08:24:55.611]         {
[08:24:55.611]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.611]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.611]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.611]             })
[08:24:55.611]         }
[08:24:55.611]     }, args = future.call.arguments)
[08:24:55.611] }
[08:24:55.611] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.612] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.612] 
[08:24:55.612] getGlobalsAndPackages() ... DONE
[08:24:55.612] run() for ‘Future’ ...
[08:24:55.612] - state: ‘created’
[08:24:55.612] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.627] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.628]   - Field: ‘node’
[08:24:55.628]   - Field: ‘label’
[08:24:55.628]   - Field: ‘local’
[08:24:55.628]   - Field: ‘owner’
[08:24:55.628]   - Field: ‘envir’
[08:24:55.628]   - Field: ‘workers’
[08:24:55.628]   - Field: ‘packages’
[08:24:55.628]   - Field: ‘gc’
[08:24:55.628]   - Field: ‘conditions’
[08:24:55.628]   - Field: ‘persistent’
[08:24:55.628]   - Field: ‘expr’
[08:24:55.629]   - Field: ‘uuid’
[08:24:55.629]   - Field: ‘seed’
[08:24:55.629]   - Field: ‘version’
[08:24:55.629]   - Field: ‘result’
[08:24:55.629]   - Field: ‘asynchronous’
[08:24:55.629]   - Field: ‘calls’
[08:24:55.629]   - Field: ‘globals’
[08:24:55.629]   - Field: ‘stdout’
[08:24:55.629]   - Field: ‘earlySignal’
[08:24:55.629]   - Field: ‘lazy’
[08:24:55.629]   - Field: ‘state’
[08:24:55.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.630] - Launch lazy future ...
[08:24:55.630] Packages needed by the future expression (n = 0): <none>
[08:24:55.630] Packages needed by future strategies (n = 0): <none>
[08:24:55.630] {
[08:24:55.630]     {
[08:24:55.630]         {
[08:24:55.630]             ...future.startTime <- base::Sys.time()
[08:24:55.630]             {
[08:24:55.630]                 {
[08:24:55.630]                   {
[08:24:55.630]                     {
[08:24:55.630]                       base::local({
[08:24:55.630]                         has_future <- base::requireNamespace("future", 
[08:24:55.630]                           quietly = TRUE)
[08:24:55.630]                         if (has_future) {
[08:24:55.630]                           ns <- base::getNamespace("future")
[08:24:55.630]                           version <- ns[[".package"]][["version"]]
[08:24:55.630]                           if (is.null(version)) 
[08:24:55.630]                             version <- utils::packageVersion("future")
[08:24:55.630]                         }
[08:24:55.630]                         else {
[08:24:55.630]                           version <- NULL
[08:24:55.630]                         }
[08:24:55.630]                         if (!has_future || version < "1.8.0") {
[08:24:55.630]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.630]                             "", base::R.version$version.string), 
[08:24:55.630]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.630]                               "release", "version")], collapse = " "), 
[08:24:55.630]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.630]                             info)
[08:24:55.630]                           info <- base::paste(info, collapse = "; ")
[08:24:55.630]                           if (!has_future) {
[08:24:55.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.630]                               info)
[08:24:55.630]                           }
[08:24:55.630]                           else {
[08:24:55.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.630]                               info, version)
[08:24:55.630]                           }
[08:24:55.630]                           base::stop(msg)
[08:24:55.630]                         }
[08:24:55.630]                       })
[08:24:55.630]                     }
[08:24:55.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.630]                     base::options(mc.cores = 1L)
[08:24:55.630]                   }
[08:24:55.630]                   ...future.strategy.old <- future::plan("list")
[08:24:55.630]                   options(future.plan = NULL)
[08:24:55.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.630]                 }
[08:24:55.630]                 ...future.workdir <- getwd()
[08:24:55.630]             }
[08:24:55.630]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.630]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.630]         }
[08:24:55.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.630]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.630]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.630]             base::names(...future.oldOptions))
[08:24:55.630]     }
[08:24:55.630]     if (FALSE) {
[08:24:55.630]     }
[08:24:55.630]     else {
[08:24:55.630]         if (TRUE) {
[08:24:55.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.630]                 open = "w")
[08:24:55.630]         }
[08:24:55.630]         else {
[08:24:55.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.630]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.630]         }
[08:24:55.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.630]             base::sink(type = "output", split = FALSE)
[08:24:55.630]             base::close(...future.stdout)
[08:24:55.630]         }, add = TRUE)
[08:24:55.630]     }
[08:24:55.630]     ...future.frame <- base::sys.nframe()
[08:24:55.630]     ...future.conditions <- base::list()
[08:24:55.630]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.630]     if (FALSE) {
[08:24:55.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.630]     }
[08:24:55.630]     ...future.result <- base::tryCatch({
[08:24:55.630]         base::withCallingHandlers({
[08:24:55.630]             ...future.value <- base::withVisible(base::local({
[08:24:55.630]                 ...future.makeSendCondition <- base::local({
[08:24:55.630]                   sendCondition <- NULL
[08:24:55.630]                   function(frame = 1L) {
[08:24:55.630]                     if (is.function(sendCondition)) 
[08:24:55.630]                       return(sendCondition)
[08:24:55.630]                     ns <- getNamespace("parallel")
[08:24:55.630]                     if (exists("sendData", mode = "function", 
[08:24:55.630]                       envir = ns)) {
[08:24:55.630]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.630]                         envir = ns)
[08:24:55.630]                       envir <- sys.frame(frame)
[08:24:55.630]                       master <- NULL
[08:24:55.630]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.630]                         !identical(envir, emptyenv())) {
[08:24:55.630]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.630]                           inherits = FALSE)) {
[08:24:55.630]                           master <- get("master", mode = "list", 
[08:24:55.630]                             envir = envir, inherits = FALSE)
[08:24:55.630]                           if (inherits(master, c("SOCKnode", 
[08:24:55.630]                             "SOCK0node"))) {
[08:24:55.630]                             sendCondition <<- function(cond) {
[08:24:55.630]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.630]                                 success = TRUE)
[08:24:55.630]                               parallel_sendData(master, data)
[08:24:55.630]                             }
[08:24:55.630]                             return(sendCondition)
[08:24:55.630]                           }
[08:24:55.630]                         }
[08:24:55.630]                         frame <- frame + 1L
[08:24:55.630]                         envir <- sys.frame(frame)
[08:24:55.630]                       }
[08:24:55.630]                     }
[08:24:55.630]                     sendCondition <<- function(cond) NULL
[08:24:55.630]                   }
[08:24:55.630]                 })
[08:24:55.630]                 withCallingHandlers({
[08:24:55.630]                   {
[08:24:55.630]                     do.call(function(...) {
[08:24:55.630]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.630]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.630]                         ...future.globals.maxSize)) {
[08:24:55.630]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.630]                         on.exit(options(oopts), add = TRUE)
[08:24:55.630]                       }
[08:24:55.630]                       {
[08:24:55.630]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.630]                           FUN = function(jj) {
[08:24:55.630]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.630]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.630]                           })
[08:24:55.630]                       }
[08:24:55.630]                     }, args = future.call.arguments)
[08:24:55.630]                   }
[08:24:55.630]                 }, immediateCondition = function(cond) {
[08:24:55.630]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.630]                   sendCondition(cond)
[08:24:55.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.630]                   {
[08:24:55.630]                     inherits <- base::inherits
[08:24:55.630]                     invokeRestart <- base::invokeRestart
[08:24:55.630]                     is.null <- base::is.null
[08:24:55.630]                     muffled <- FALSE
[08:24:55.630]                     if (inherits(cond, "message")) {
[08:24:55.630]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.630]                       if (muffled) 
[08:24:55.630]                         invokeRestart("muffleMessage")
[08:24:55.630]                     }
[08:24:55.630]                     else if (inherits(cond, "warning")) {
[08:24:55.630]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.630]                       if (muffled) 
[08:24:55.630]                         invokeRestart("muffleWarning")
[08:24:55.630]                     }
[08:24:55.630]                     else if (inherits(cond, "condition")) {
[08:24:55.630]                       if (!is.null(pattern)) {
[08:24:55.630]                         computeRestarts <- base::computeRestarts
[08:24:55.630]                         grepl <- base::grepl
[08:24:55.630]                         restarts <- computeRestarts(cond)
[08:24:55.630]                         for (restart in restarts) {
[08:24:55.630]                           name <- restart$name
[08:24:55.630]                           if (is.null(name)) 
[08:24:55.630]                             next
[08:24:55.630]                           if (!grepl(pattern, name)) 
[08:24:55.630]                             next
[08:24:55.630]                           invokeRestart(restart)
[08:24:55.630]                           muffled <- TRUE
[08:24:55.630]                           break
[08:24:55.630]                         }
[08:24:55.630]                       }
[08:24:55.630]                     }
[08:24:55.630]                     invisible(muffled)
[08:24:55.630]                   }
[08:24:55.630]                   muffleCondition(cond)
[08:24:55.630]                 })
[08:24:55.630]             }))
[08:24:55.630]             future::FutureResult(value = ...future.value$value, 
[08:24:55.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.630]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.630]                     ...future.globalenv.names))
[08:24:55.630]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.630]         }, condition = base::local({
[08:24:55.630]             c <- base::c
[08:24:55.630]             inherits <- base::inherits
[08:24:55.630]             invokeRestart <- base::invokeRestart
[08:24:55.630]             length <- base::length
[08:24:55.630]             list <- base::list
[08:24:55.630]             seq.int <- base::seq.int
[08:24:55.630]             signalCondition <- base::signalCondition
[08:24:55.630]             sys.calls <- base::sys.calls
[08:24:55.630]             `[[` <- base::`[[`
[08:24:55.630]             `+` <- base::`+`
[08:24:55.630]             `<<-` <- base::`<<-`
[08:24:55.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.630]                   3L)]
[08:24:55.630]             }
[08:24:55.630]             function(cond) {
[08:24:55.630]                 is_error <- inherits(cond, "error")
[08:24:55.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.630]                   NULL)
[08:24:55.630]                 if (is_error) {
[08:24:55.630]                   sessionInformation <- function() {
[08:24:55.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.630]                       search = base::search(), system = base::Sys.info())
[08:24:55.630]                   }
[08:24:55.630]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.630]                     cond$call), session = sessionInformation(), 
[08:24:55.630]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.630]                   signalCondition(cond)
[08:24:55.630]                 }
[08:24:55.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:24:55.630]                 "immediateCondition"))) {
[08:24:55.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.630]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.630]                   if (TRUE && !signal) {
[08:24:55.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.630]                     {
[08:24:55.630]                       inherits <- base::inherits
[08:24:55.630]                       invokeRestart <- base::invokeRestart
[08:24:55.630]                       is.null <- base::is.null
[08:24:55.630]                       muffled <- FALSE
[08:24:55.630]                       if (inherits(cond, "message")) {
[08:24:55.630]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.630]                         if (muffled) 
[08:24:55.630]                           invokeRestart("muffleMessage")
[08:24:55.630]                       }
[08:24:55.630]                       else if (inherits(cond, "warning")) {
[08:24:55.630]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.630]                         if (muffled) 
[08:24:55.630]                           invokeRestart("muffleWarning")
[08:24:55.630]                       }
[08:24:55.630]                       else if (inherits(cond, "condition")) {
[08:24:55.630]                         if (!is.null(pattern)) {
[08:24:55.630]                           computeRestarts <- base::computeRestarts
[08:24:55.630]                           grepl <- base::grepl
[08:24:55.630]                           restarts <- computeRestarts(cond)
[08:24:55.630]                           for (restart in restarts) {
[08:24:55.630]                             name <- restart$name
[08:24:55.630]                             if (is.null(name)) 
[08:24:55.630]                               next
[08:24:55.630]                             if (!grepl(pattern, name)) 
[08:24:55.630]                               next
[08:24:55.630]                             invokeRestart(restart)
[08:24:55.630]                             muffled <- TRUE
[08:24:55.630]                             break
[08:24:55.630]                           }
[08:24:55.630]                         }
[08:24:55.630]                       }
[08:24:55.630]                       invisible(muffled)
[08:24:55.630]                     }
[08:24:55.630]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.630]                   }
[08:24:55.630]                 }
[08:24:55.630]                 else {
[08:24:55.630]                   if (TRUE) {
[08:24:55.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.630]                     {
[08:24:55.630]                       inherits <- base::inherits
[08:24:55.630]                       invokeRestart <- base::invokeRestart
[08:24:55.630]                       is.null <- base::is.null
[08:24:55.630]                       muffled <- FALSE
[08:24:55.630]                       if (inherits(cond, "message")) {
[08:24:55.630]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.630]                         if (muffled) 
[08:24:55.630]                           invokeRestart("muffleMessage")
[08:24:55.630]                       }
[08:24:55.630]                       else if (inherits(cond, "warning")) {
[08:24:55.630]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.630]                         if (muffled) 
[08:24:55.630]                           invokeRestart("muffleWarning")
[08:24:55.630]                       }
[08:24:55.630]                       else if (inherits(cond, "condition")) {
[08:24:55.630]                         if (!is.null(pattern)) {
[08:24:55.630]                           computeRestarts <- base::computeRestarts
[08:24:55.630]                           grepl <- base::grepl
[08:24:55.630]                           restarts <- computeRestarts(cond)
[08:24:55.630]                           for (restart in restarts) {
[08:24:55.630]                             name <- restart$name
[08:24:55.630]                             if (is.null(name)) 
[08:24:55.630]                               next
[08:24:55.630]                             if (!grepl(pattern, name)) 
[08:24:55.630]                               next
[08:24:55.630]                             invokeRestart(restart)
[08:24:55.630]                             muffled <- TRUE
[08:24:55.630]                             break
[08:24:55.630]                           }
[08:24:55.630]                         }
[08:24:55.630]                       }
[08:24:55.630]                       invisible(muffled)
[08:24:55.630]                     }
[08:24:55.630]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.630]                   }
[08:24:55.630]                 }
[08:24:55.630]             }
[08:24:55.630]         }))
[08:24:55.630]     }, error = function(ex) {
[08:24:55.630]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.630]                 ...future.rng), started = ...future.startTime, 
[08:24:55.630]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.630]             version = "1.8"), class = "FutureResult")
[08:24:55.630]     }, finally = {
[08:24:55.630]         if (!identical(...future.workdir, getwd())) 
[08:24:55.630]             setwd(...future.workdir)
[08:24:55.630]         {
[08:24:55.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.630]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.630]             }
[08:24:55.630]             base::options(...future.oldOptions)
[08:24:55.630]             if (.Platform$OS.type == "windows") {
[08:24:55.630]                 old_names <- names(...future.oldEnvVars)
[08:24:55.630]                 envs <- base::Sys.getenv()
[08:24:55.630]                 names <- names(envs)
[08:24:55.630]                 common <- intersect(names, old_names)
[08:24:55.630]                 added <- setdiff(names, old_names)
[08:24:55.630]                 removed <- setdiff(old_names, names)
[08:24:55.630]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.630]                   envs[common]]
[08:24:55.630]                 NAMES <- toupper(changed)
[08:24:55.630]                 args <- list()
[08:24:55.630]                 for (kk in seq_along(NAMES)) {
[08:24:55.630]                   name <- changed[[kk]]
[08:24:55.630]                   NAME <- NAMES[[kk]]
[08:24:55.630]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.630]                     next
[08:24:55.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.630]                 }
[08:24:55.630]                 NAMES <- toupper(added)
[08:24:55.630]                 for (kk in seq_along(NAMES)) {
[08:24:55.630]                   name <- added[[kk]]
[08:24:55.630]                   NAME <- NAMES[[kk]]
[08:24:55.630]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.630]                     next
[08:24:55.630]                   args[[name]] <- ""
[08:24:55.630]                 }
[08:24:55.630]                 NAMES <- toupper(removed)
[08:24:55.630]                 for (kk in seq_along(NAMES)) {
[08:24:55.630]                   name <- removed[[kk]]
[08:24:55.630]                   NAME <- NAMES[[kk]]
[08:24:55.630]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.630]                     next
[08:24:55.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.630]                 }
[08:24:55.630]                 if (length(args) > 0) 
[08:24:55.630]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.630]             }
[08:24:55.630]             else {
[08:24:55.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.630]             }
[08:24:55.630]             {
[08:24:55.630]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.630]                   0L) {
[08:24:55.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.630]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.630]                   base::options(opts)
[08:24:55.630]                 }
[08:24:55.630]                 {
[08:24:55.630]                   {
[08:24:55.630]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.630]                     NULL
[08:24:55.630]                   }
[08:24:55.630]                   options(future.plan = NULL)
[08:24:55.630]                   if (is.na(NA_character_)) 
[08:24:55.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.630]                     .init = FALSE)
[08:24:55.630]                 }
[08:24:55.630]             }
[08:24:55.630]         }
[08:24:55.630]     })
[08:24:55.630]     if (TRUE) {
[08:24:55.630]         base::sink(type = "output", split = FALSE)
[08:24:55.630]         if (TRUE) {
[08:24:55.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.630]         }
[08:24:55.630]         else {
[08:24:55.630]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.630]         }
[08:24:55.630]         base::close(...future.stdout)
[08:24:55.630]         ...future.stdout <- NULL
[08:24:55.630]     }
[08:24:55.630]     ...future.result$conditions <- ...future.conditions
[08:24:55.630]     ...future.result$finished <- base::Sys.time()
[08:24:55.630]     ...future.result
[08:24:55.630] }
[08:24:55.633] Exporting 5 global objects (1.92 KiB) to cluster node #2 ...
[08:24:55.634] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:55.634] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:55.634] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ...
[08:24:55.635] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ... DONE
[08:24:55.635] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ...
[08:24:55.635] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ... DONE
[08:24:55.635] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[08:24:55.636] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[08:24:55.636] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:55.636] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:55.636] Exporting 5 global objects (1.92 KiB) to cluster node #2 ... DONE
[08:24:55.637] MultisessionFuture started
[08:24:55.637] - Launch lazy future ... done
[08:24:55.637] run() for ‘MultisessionFuture’ ... done
[08:24:55.637] Created future:
[08:24:55.637] MultisessionFuture:
[08:24:55.637] Label: ‘future_apply-2’
[08:24:55.637] Expression:
[08:24:55.637] {
[08:24:55.637]     do.call(function(...) {
[08:24:55.637]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.637]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.637]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.637]             on.exit(options(oopts), add = TRUE)
[08:24:55.637]         }
[08:24:55.637]         {
[08:24:55.637]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.637]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.637]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.637]             })
[08:24:55.637]         }
[08:24:55.637]     }, args = future.call.arguments)
[08:24:55.637] }
[08:24:55.637] Lazy evaluation: FALSE
[08:24:55.637] Asynchronous evaluation: TRUE
[08:24:55.637] Local evaluation: TRUE
[08:24:55.637] Environment: R_GlobalEnv
[08:24:55.637] Capture standard output: TRUE
[08:24:55.637] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[08:24:55.637] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.637] Packages: <none>
[08:24:55.637] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:24:55.637] Resolved: FALSE
[08:24:55.637] Value: <not collected>
[08:24:55.637] Conditions captured: <none>
[08:24:55.637] Early signaling: FALSE
[08:24:55.637] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.637] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.649] Chunk #2 of 2 ... DONE
[08:24:55.649] Launching 2 futures (chunks) ... DONE
[08:24:55.649] Resolving 2 futures (chunks) ...
[08:24:55.649] resolve() on list ...
[08:24:55.649]  recursive: 0
[08:24:55.649]  length: 2
[08:24:55.649] 
[08:24:55.650] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.650] - Validating connection of MultisessionFuture
[08:24:55.650] - received message: FutureResult
[08:24:55.650] - Received FutureResult
[08:24:55.650] - Erased future from FutureRegistry
[08:24:55.651] result() for ClusterFuture ...
[08:24:55.651] - result already collected: FutureResult
[08:24:55.651] result() for ClusterFuture ... done
[08:24:55.651] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.651] Future #1
[08:24:55.651] result() for ClusterFuture ...
[08:24:55.651] - result already collected: FutureResult
[08:24:55.651] result() for ClusterFuture ... done
[08:24:55.651] result() for ClusterFuture ...
[08:24:55.651] - result already collected: FutureResult
[08:24:55.651] result() for ClusterFuture ... done
[08:24:55.652] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:55.652] - nx: 2
[08:24:55.652] - relay: TRUE
[08:24:55.652] - stdout: TRUE
[08:24:55.652] - signal: TRUE
[08:24:55.652] - resignal: FALSE
[08:24:55.652] - force: TRUE
[08:24:55.652] - relayed: [n=2] FALSE, FALSE
[08:24:55.652] - queued futures: [n=2] FALSE, FALSE
[08:24:55.652]  - until=1
[08:24:55.652]  - relaying element #1
[08:24:55.652] result() for ClusterFuture ...
[08:24:55.653] - result already collected: FutureResult
[08:24:55.653] result() for ClusterFuture ... done
[08:24:55.653] result() for ClusterFuture ...
[08:24:55.653] - result already collected: FutureResult
[08:24:55.653] result() for ClusterFuture ... done
[08:24:55.653] result() for ClusterFuture ...
[08:24:55.653] - result already collected: FutureResult
[08:24:55.653] result() for ClusterFuture ... done
[08:24:55.653] result() for ClusterFuture ...
[08:24:55.653] - result already collected: FutureResult
[08:24:55.653] result() for ClusterFuture ... done
[08:24:55.653] - relayed: [n=2] TRUE, FALSE
[08:24:55.654] - queued futures: [n=2] TRUE, FALSE
[08:24:55.654] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:55.654]  length: 1 (resolved future 1)
[08:24:55.679] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.679] - Validating connection of MultisessionFuture
[08:24:55.680] - received message: FutureResult
[08:24:55.680] - Received FutureResult
[08:24:55.680] - Erased future from FutureRegistry
[08:24:55.680] result() for ClusterFuture ...
[08:24:55.680] - result already collected: FutureResult
[08:24:55.680] result() for ClusterFuture ... done
[08:24:55.680] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.680] Future #2
[08:24:55.680] result() for ClusterFuture ...
[08:24:55.681] - result already collected: FutureResult
[08:24:55.681] result() for ClusterFuture ... done
[08:24:55.681] result() for ClusterFuture ...
[08:24:55.681] - result already collected: FutureResult
[08:24:55.681] result() for ClusterFuture ... done
[08:24:55.681] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:55.681] - nx: 2
[08:24:55.681] - relay: TRUE
[08:24:55.681] - stdout: TRUE
[08:24:55.681] - signal: TRUE
[08:24:55.681] - resignal: FALSE
[08:24:55.681] - force: TRUE
[08:24:55.681] - relayed: [n=2] TRUE, FALSE
[08:24:55.682] - queued futures: [n=2] TRUE, FALSE
[08:24:55.682]  - until=2
[08:24:55.682]  - relaying element #2
[08:24:55.682] result() for ClusterFuture ...
[08:24:55.682] - result already collected: FutureResult
[08:24:55.682] result() for ClusterFuture ... done
[08:24:55.682] result() for ClusterFuture ...
[08:24:55.682] - result already collected: FutureResult
[08:24:55.682] result() for ClusterFuture ... done
[08:24:55.682] result() for ClusterFuture ...
[08:24:55.682] - result already collected: FutureResult
[08:24:55.683] result() for ClusterFuture ... done
[08:24:55.683] result() for ClusterFuture ...
[08:24:55.683] - result already collected: FutureResult
[08:24:55.683] result() for ClusterFuture ... done
[08:24:55.683] - relayed: [n=2] TRUE, TRUE
[08:24:55.683] - queued futures: [n=2] TRUE, TRUE
[08:24:55.683] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:55.683]  length: 0 (resolved future 2)
[08:24:55.683] Relaying remaining futures
[08:24:55.683] signalConditionsASAP(NULL, pos=0) ...
[08:24:55.683] - nx: 2
[08:24:55.683] - relay: TRUE
[08:24:55.684] - stdout: TRUE
[08:24:55.684] - signal: TRUE
[08:24:55.684] - resignal: FALSE
[08:24:55.684] - force: TRUE
[08:24:55.684] - relayed: [n=2] TRUE, TRUE
[08:24:55.684] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:55.684] - relayed: [n=2] TRUE, TRUE
[08:24:55.684] - queued futures: [n=2] TRUE, TRUE
[08:24:55.684] signalConditionsASAP(NULL, pos=0) ... done
[08:24:55.684] resolve() on list ... DONE
[08:24:55.684] result() for ClusterFuture ...
[08:24:55.684] - result already collected: FutureResult
[08:24:55.685] result() for ClusterFuture ... done
[08:24:55.685] result() for ClusterFuture ...
[08:24:55.685] - result already collected: FutureResult
[08:24:55.685] result() for ClusterFuture ... done
[08:24:55.685] result() for ClusterFuture ...
[08:24:55.685] - result already collected: FutureResult
[08:24:55.685] result() for ClusterFuture ... done
[08:24:55.685] result() for ClusterFuture ...
[08:24:55.685] - result already collected: FutureResult
[08:24:55.685] result() for ClusterFuture ... done
[08:24:55.685]  - Number of value chunks collected: 2
[08:24:55.686] Resolving 2 futures (chunks) ... DONE
[08:24:55.686] Reducing values from 2 chunks ...
[08:24:55.686]  - Number of values collected after concatenation: 2
[08:24:55.686]  - Number of values expected: 2
[08:24:55.686] Reducing values from 2 chunks ... DONE
[08:24:55.686] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[08:24:55.686] getGlobalsAndPackagesXApply() ...
[08:24:55.686]  - future.globals: TRUE
[08:24:55.686] getGlobalsAndPackages() ...
[08:24:55.686] Searching for globals...
[08:24:55.689] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[08:24:55.690] Searching for globals ... DONE
[08:24:55.690] Resolving globals: FALSE
[08:24:55.690] The total size of the 1 globals is 3.66 KiB (3746 bytes)
[08:24:55.691] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 3.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.66 KiB of class ‘function’)
[08:24:55.691] - globals: [1] ‘FUN’
[08:24:55.691] 
[08:24:55.691] getGlobalsAndPackages() ... DONE
[08:24:55.691]  - globals found/used: [n=1] ‘FUN’
[08:24:55.691]  - needed namespaces: [n=0] 
[08:24:55.691] Finding globals ... DONE
[08:24:55.691]  - use_args: TRUE
[08:24:55.692]  - Getting '...' globals ...
[08:24:55.692] resolve() on list ...
[08:24:55.692]  recursive: 0
[08:24:55.692]  length: 1
[08:24:55.692]  elements: ‘...’
[08:24:55.692]  length: 0 (resolved future 1)
[08:24:55.692] resolve() on list ... DONE
[08:24:55.692]    - '...' content: [n=0] 
[08:24:55.692] List of 1
[08:24:55.692]  $ ...: list()
[08:24:55.692]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.692]  - attr(*, "where")=List of 1
[08:24:55.692]   ..$ ...:<environment: 0x56540f5a9850> 
[08:24:55.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.692]  - attr(*, "resolved")= logi TRUE
[08:24:55.692]  - attr(*, "total_size")= num NA
[08:24:55.695]  - Getting '...' globals ... DONE
[08:24:55.695] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[08:24:55.695] List of 2
[08:24:55.695]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[08:24:55.695]  $ ...          : list()
[08:24:55.695]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.695]  - attr(*, "where")=List of 2
[08:24:55.695]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[08:24:55.695]   ..$ ...          :<environment: 0x56540f5a9850> 
[08:24:55.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.695]  - attr(*, "resolved")= logi FALSE
[08:24:55.695]  - attr(*, "total_size")= num 9424
[08:24:55.698] Packages to be attached in all futures: [n=0] 
[08:24:55.698] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.700] future_lapply() ...
[08:24:55.702] Generating random seeds ...
[08:24:55.702] Generating random seed streams for 2 elements ...
[08:24:55.702] Generating random seed streams for 2 elements ... DONE
[08:24:55.702] Generating random seeds ... DONE
[08:24:55.702] Will set RNG state on exit: 10407, -1067895724, -1009987725, -1442977960, 231252184, 701281222, -1406102003
[08:24:55.704] Number of chunks: 2
[08:24:55.704] getGlobalsAndPackagesXApply() ...
[08:24:55.704]  - future.globals: <name-value list> with names ‘list()’
[08:24:55.704]  - use_args: TRUE
[08:24:55.704] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[08:24:55.704] List of 2
[08:24:55.704]  $ ...          : list()
[08:24:55.704]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[08:24:55.704]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[08:24:55.704]  - attr(*, "where")=List of 2
[08:24:55.704]   ..$ ...          :<environment: 0x56540f5a9850> 
[08:24:55.704]   ..$ ...future.FUN:<environment: namespace:base> 
[08:24:55.704]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:24:55.704]  - attr(*, "resolved")= logi FALSE
[08:24:55.704]  - attr(*, "total_size")= num NA
[08:24:55.708] Packages to be attached in all futures: [n=0] 
[08:24:55.708] getGlobalsAndPackagesXApply() ... DONE
[08:24:55.708] Number of futures (= number of chunks): 2
[08:24:55.708] Launching 2 futures (chunks) ...
[08:24:55.708] Chunk #1 of 2 ...
[08:24:55.709]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.709]  - seeds: [1] <seeds>
[08:24:55.709]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.709] getGlobalsAndPackages() ...
[08:24:55.709] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.709] Resolving globals: FALSE
[08:24:55.709] Tweak future expression to call with '...' arguments ...
[08:24:55.709] {
[08:24:55.709]     do.call(function(...) {
[08:24:55.709]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.709]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.709]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.709]             on.exit(options(oopts), add = TRUE)
[08:24:55.709]         }
[08:24:55.709]         {
[08:24:55.709]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.709]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.709]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:55.709]                   envir = globalenv(), inherits = FALSE)
[08:24:55.709]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.709]             })
[08:24:55.709]         }
[08:24:55.709]     }, args = future.call.arguments)
[08:24:55.709] }
[08:24:55.710] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.710] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.710] 
[08:24:55.710] getGlobalsAndPackages() ... DONE
[08:24:55.710] run() for ‘Future’ ...
[08:24:55.711] - state: ‘created’
[08:24:55.711] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.725] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.725]   - Field: ‘node’
[08:24:55.725]   - Field: ‘label’
[08:24:55.725]   - Field: ‘local’
[08:24:55.725]   - Field: ‘owner’
[08:24:55.726]   - Field: ‘envir’
[08:24:55.726]   - Field: ‘workers’
[08:24:55.726]   - Field: ‘packages’
[08:24:55.726]   - Field: ‘gc’
[08:24:55.726]   - Field: ‘conditions’
[08:24:55.726]   - Field: ‘persistent’
[08:24:55.726]   - Field: ‘expr’
[08:24:55.726]   - Field: ‘uuid’
[08:24:55.726]   - Field: ‘seed’
[08:24:55.726]   - Field: ‘version’
[08:24:55.726]   - Field: ‘result’
[08:24:55.726]   - Field: ‘asynchronous’
[08:24:55.727]   - Field: ‘calls’
[08:24:55.727]   - Field: ‘globals’
[08:24:55.727]   - Field: ‘stdout’
[08:24:55.727]   - Field: ‘earlySignal’
[08:24:55.727]   - Field: ‘lazy’
[08:24:55.727]   - Field: ‘state’
[08:24:55.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.727] - Launch lazy future ...
[08:24:55.727] Packages needed by the future expression (n = 0): <none>
[08:24:55.728] Packages needed by future strategies (n = 0): <none>
[08:24:55.728] {
[08:24:55.728]     {
[08:24:55.728]         {
[08:24:55.728]             ...future.startTime <- base::Sys.time()
[08:24:55.728]             {
[08:24:55.728]                 {
[08:24:55.728]                   {
[08:24:55.728]                     {
[08:24:55.728]                       base::local({
[08:24:55.728]                         has_future <- base::requireNamespace("future", 
[08:24:55.728]                           quietly = TRUE)
[08:24:55.728]                         if (has_future) {
[08:24:55.728]                           ns <- base::getNamespace("future")
[08:24:55.728]                           version <- ns[[".package"]][["version"]]
[08:24:55.728]                           if (is.null(version)) 
[08:24:55.728]                             version <- utils::packageVersion("future")
[08:24:55.728]                         }
[08:24:55.728]                         else {
[08:24:55.728]                           version <- NULL
[08:24:55.728]                         }
[08:24:55.728]                         if (!has_future || version < "1.8.0") {
[08:24:55.728]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.728]                             "", base::R.version$version.string), 
[08:24:55.728]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.728]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.728]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.728]                               "release", "version")], collapse = " "), 
[08:24:55.728]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.728]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.728]                             info)
[08:24:55.728]                           info <- base::paste(info, collapse = "; ")
[08:24:55.728]                           if (!has_future) {
[08:24:55.728]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.728]                               info)
[08:24:55.728]                           }
[08:24:55.728]                           else {
[08:24:55.728]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.728]                               info, version)
[08:24:55.728]                           }
[08:24:55.728]                           base::stop(msg)
[08:24:55.728]                         }
[08:24:55.728]                       })
[08:24:55.728]                     }
[08:24:55.728]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.728]                     base::options(mc.cores = 1L)
[08:24:55.728]                   }
[08:24:55.728]                   ...future.strategy.old <- future::plan("list")
[08:24:55.728]                   options(future.plan = NULL)
[08:24:55.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.728]                 }
[08:24:55.728]                 ...future.workdir <- getwd()
[08:24:55.728]             }
[08:24:55.728]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.728]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.728]         }
[08:24:55.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.728]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.728]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.728]             base::names(...future.oldOptions))
[08:24:55.728]     }
[08:24:55.728]     if (FALSE) {
[08:24:55.728]     }
[08:24:55.728]     else {
[08:24:55.728]         if (TRUE) {
[08:24:55.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.728]                 open = "w")
[08:24:55.728]         }
[08:24:55.728]         else {
[08:24:55.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.728]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.728]         }
[08:24:55.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.728]             base::sink(type = "output", split = FALSE)
[08:24:55.728]             base::close(...future.stdout)
[08:24:55.728]         }, add = TRUE)
[08:24:55.728]     }
[08:24:55.728]     ...future.frame <- base::sys.nframe()
[08:24:55.728]     ...future.conditions <- base::list()
[08:24:55.728]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.728]     if (FALSE) {
[08:24:55.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.728]     }
[08:24:55.728]     ...future.result <- base::tryCatch({
[08:24:55.728]         base::withCallingHandlers({
[08:24:55.728]             ...future.value <- base::withVisible(base::local({
[08:24:55.728]                 ...future.makeSendCondition <- base::local({
[08:24:55.728]                   sendCondition <- NULL
[08:24:55.728]                   function(frame = 1L) {
[08:24:55.728]                     if (is.function(sendCondition)) 
[08:24:55.728]                       return(sendCondition)
[08:24:55.728]                     ns <- getNamespace("parallel")
[08:24:55.728]                     if (exists("sendData", mode = "function", 
[08:24:55.728]                       envir = ns)) {
[08:24:55.728]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.728]                         envir = ns)
[08:24:55.728]                       envir <- sys.frame(frame)
[08:24:55.728]                       master <- NULL
[08:24:55.728]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.728]                         !identical(envir, emptyenv())) {
[08:24:55.728]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.728]                           inherits = FALSE)) {
[08:24:55.728]                           master <- get("master", mode = "list", 
[08:24:55.728]                             envir = envir, inherits = FALSE)
[08:24:55.728]                           if (inherits(master, c("SOCKnode", 
[08:24:55.728]                             "SOCK0node"))) {
[08:24:55.728]                             sendCondition <<- function(cond) {
[08:24:55.728]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.728]                                 success = TRUE)
[08:24:55.728]                               parallel_sendData(master, data)
[08:24:55.728]                             }
[08:24:55.728]                             return(sendCondition)
[08:24:55.728]                           }
[08:24:55.728]                         }
[08:24:55.728]                         frame <- frame + 1L
[08:24:55.728]                         envir <- sys.frame(frame)
[08:24:55.728]                       }
[08:24:55.728]                     }
[08:24:55.728]                     sendCondition <<- function(cond) NULL
[08:24:55.728]                   }
[08:24:55.728]                 })
[08:24:55.728]                 withCallingHandlers({
[08:24:55.728]                   {
[08:24:55.728]                     do.call(function(...) {
[08:24:55.728]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.728]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.728]                         ...future.globals.maxSize)) {
[08:24:55.728]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.728]                         on.exit(options(oopts), add = TRUE)
[08:24:55.728]                       }
[08:24:55.728]                       {
[08:24:55.728]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.728]                           FUN = function(jj) {
[08:24:55.728]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.728]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:55.728]                               envir = globalenv(), inherits = FALSE)
[08:24:55.728]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.728]                           })
[08:24:55.728]                       }
[08:24:55.728]                     }, args = future.call.arguments)
[08:24:55.728]                   }
[08:24:55.728]                 }, immediateCondition = function(cond) {
[08:24:55.728]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.728]                   sendCondition(cond)
[08:24:55.728]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.728]                   {
[08:24:55.728]                     inherits <- base::inherits
[08:24:55.728]                     invokeRestart <- base::invokeRestart
[08:24:55.728]                     is.null <- base::is.null
[08:24:55.728]                     muffled <- FALSE
[08:24:55.728]                     if (inherits(cond, "message")) {
[08:24:55.728]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.728]                       if (muffled) 
[08:24:55.728]                         invokeRestart("muffleMessage")
[08:24:55.728]                     }
[08:24:55.728]                     else if (inherits(cond, "warning")) {
[08:24:55.728]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.728]                       if (muffled) 
[08:24:55.728]                         invokeRestart("muffleWarning")
[08:24:55.728]                     }
[08:24:55.728]                     else if (inherits(cond, "condition")) {
[08:24:55.728]                       if (!is.null(pattern)) {
[08:24:55.728]                         computeRestarts <- base::computeRestarts
[08:24:55.728]                         grepl <- base::grepl
[08:24:55.728]                         restarts <- computeRestarts(cond)
[08:24:55.728]                         for (restart in restarts) {
[08:24:55.728]                           name <- restart$name
[08:24:55.728]                           if (is.null(name)) 
[08:24:55.728]                             next
[08:24:55.728]                           if (!grepl(pattern, name)) 
[08:24:55.728]                             next
[08:24:55.728]                           invokeRestart(restart)
[08:24:55.728]                           muffled <- TRUE
[08:24:55.728]                           break
[08:24:55.728]                         }
[08:24:55.728]                       }
[08:24:55.728]                     }
[08:24:55.728]                     invisible(muffled)
[08:24:55.728]                   }
[08:24:55.728]                   muffleCondition(cond)
[08:24:55.728]                 })
[08:24:55.728]             }))
[08:24:55.728]             future::FutureResult(value = ...future.value$value, 
[08:24:55.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.728]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.728]                     ...future.globalenv.names))
[08:24:55.728]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.728]         }, condition = base::local({
[08:24:55.728]             c <- base::c
[08:24:55.728]             inherits <- base::inherits
[08:24:55.728]             invokeRestart <- base::invokeRestart
[08:24:55.728]             length <- base::length
[08:24:55.728]             list <- base::list
[08:24:55.728]             seq.int <- base::seq.int
[08:24:55.728]             signalCondition <- base::signalCondition
[08:24:55.728]             sys.calls <- base::sys.calls
[08:24:55.728]             `[[` <- base::`[[`
[08:24:55.728]             `+` <- base::`+`
[08:24:55.728]             `<<-` <- base::`<<-`
[08:24:55.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.728]                   3L)]
[08:24:55.728]             }
[08:24:55.728]             function(cond) {
[08:24:55.728]                 is_error <- inherits(cond, "error")
[08:24:55.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.728]                   NULL)
[08:24:55.728]                 if (is_error) {
[08:24:55.728]                   sessionInformation <- function() {
[08:24:55.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.728]                       search = base::search(), system = base::Sys.info())
[08:24:55.728]                   }
[08:24:55.728]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.728]                     cond$call), session = sessionInformation(), 
[08:24:55.728]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.728]                   signalCondition(cond)
[08:24:55.728]                 }
[08:24:55.728]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[08:24:55.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.728]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.728]                   if (TRUE && !signal) {
[08:24:55.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.728]                     {
[08:24:55.728]                       inherits <- base::inherits
[08:24:55.728]                       invokeRestart <- base::invokeRestart
[08:24:55.728]                       is.null <- base::is.null
[08:24:55.728]                       muffled <- FALSE
[08:24:55.728]                       if (inherits(cond, "message")) {
[08:24:55.728]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.728]                         if (muffled) 
[08:24:55.728]                           invokeRestart("muffleMessage")
[08:24:55.728]                       }
[08:24:55.728]                       else if (inherits(cond, "warning")) {
[08:24:55.728]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.728]                         if (muffled) 
[08:24:55.728]                           invokeRestart("muffleWarning")
[08:24:55.728]                       }
[08:24:55.728]                       else if (inherits(cond, "condition")) {
[08:24:55.728]                         if (!is.null(pattern)) {
[08:24:55.728]                           computeRestarts <- base::computeRestarts
[08:24:55.728]                           grepl <- base::grepl
[08:24:55.728]                           restarts <- computeRestarts(cond)
[08:24:55.728]                           for (restart in restarts) {
[08:24:55.728]                             name <- restart$name
[08:24:55.728]                             if (is.null(name)) 
[08:24:55.728]                               next
[08:24:55.728]                             if (!grepl(pattern, name)) 
[08:24:55.728]                               next
[08:24:55.728]                             invokeRestart(restart)
[08:24:55.728]                             muffled <- TRUE
[08:24:55.728]                             break
[08:24:55.728]                           }
[08:24:55.728]                         }
[08:24:55.728]                       }
[08:24:55.728]                       invisible(muffled)
[08:24:55.728]                     }
[08:24:55.728]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.728]                   }
[08:24:55.728]                 }
[08:24:55.728]                 else {
[08:24:55.728]                   if (TRUE) {
[08:24:55.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.728]                     {
[08:24:55.728]                       inherits <- base::inherits
[08:24:55.728]                       invokeRestart <- base::invokeRestart
[08:24:55.728]                       is.null <- base::is.null
[08:24:55.728]                       muffled <- FALSE
[08:24:55.728]                       if (inherits(cond, "message")) {
[08:24:55.728]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.728]                         if (muffled) 
[08:24:55.728]                           invokeRestart("muffleMessage")
[08:24:55.728]                       }
[08:24:55.728]                       else if (inherits(cond, "warning")) {
[08:24:55.728]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.728]                         if (muffled) 
[08:24:55.728]                           invokeRestart("muffleWarning")
[08:24:55.728]                       }
[08:24:55.728]                       else if (inherits(cond, "condition")) {
[08:24:55.728]                         if (!is.null(pattern)) {
[08:24:55.728]                           computeRestarts <- base::computeRestarts
[08:24:55.728]                           grepl <- base::grepl
[08:24:55.728]                           restarts <- computeRestarts(cond)
[08:24:55.728]                           for (restart in restarts) {
[08:24:55.728]                             name <- restart$name
[08:24:55.728]                             if (is.null(name)) 
[08:24:55.728]                               next
[08:24:55.728]                             if (!grepl(pattern, name)) 
[08:24:55.728]                               next
[08:24:55.728]                             invokeRestart(restart)
[08:24:55.728]                             muffled <- TRUE
[08:24:55.728]                             break
[08:24:55.728]                           }
[08:24:55.728]                         }
[08:24:55.728]                       }
[08:24:55.728]                       invisible(muffled)
[08:24:55.728]                     }
[08:24:55.728]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.728]                   }
[08:24:55.728]                 }
[08:24:55.728]             }
[08:24:55.728]         }))
[08:24:55.728]     }, error = function(ex) {
[08:24:55.728]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.728]                 ...future.rng), started = ...future.startTime, 
[08:24:55.728]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.728]             version = "1.8"), class = "FutureResult")
[08:24:55.728]     }, finally = {
[08:24:55.728]         if (!identical(...future.workdir, getwd())) 
[08:24:55.728]             setwd(...future.workdir)
[08:24:55.728]         {
[08:24:55.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.728]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.728]             }
[08:24:55.728]             base::options(...future.oldOptions)
[08:24:55.728]             if (.Platform$OS.type == "windows") {
[08:24:55.728]                 old_names <- names(...future.oldEnvVars)
[08:24:55.728]                 envs <- base::Sys.getenv()
[08:24:55.728]                 names <- names(envs)
[08:24:55.728]                 common <- intersect(names, old_names)
[08:24:55.728]                 added <- setdiff(names, old_names)
[08:24:55.728]                 removed <- setdiff(old_names, names)
[08:24:55.728]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.728]                   envs[common]]
[08:24:55.728]                 NAMES <- toupper(changed)
[08:24:55.728]                 args <- list()
[08:24:55.728]                 for (kk in seq_along(NAMES)) {
[08:24:55.728]                   name <- changed[[kk]]
[08:24:55.728]                   NAME <- NAMES[[kk]]
[08:24:55.728]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.728]                     next
[08:24:55.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.728]                 }
[08:24:55.728]                 NAMES <- toupper(added)
[08:24:55.728]                 for (kk in seq_along(NAMES)) {
[08:24:55.728]                   name <- added[[kk]]
[08:24:55.728]                   NAME <- NAMES[[kk]]
[08:24:55.728]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.728]                     next
[08:24:55.728]                   args[[name]] <- ""
[08:24:55.728]                 }
[08:24:55.728]                 NAMES <- toupper(removed)
[08:24:55.728]                 for (kk in seq_along(NAMES)) {
[08:24:55.728]                   name <- removed[[kk]]
[08:24:55.728]                   NAME <- NAMES[[kk]]
[08:24:55.728]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.728]                     next
[08:24:55.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.728]                 }
[08:24:55.728]                 if (length(args) > 0) 
[08:24:55.728]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.728]             }
[08:24:55.728]             else {
[08:24:55.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.728]             }
[08:24:55.728]             {
[08:24:55.728]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.728]                   0L) {
[08:24:55.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.728]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.728]                   base::options(opts)
[08:24:55.728]                 }
[08:24:55.728]                 {
[08:24:55.728]                   {
[08:24:55.728]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.728]                     NULL
[08:24:55.728]                   }
[08:24:55.728]                   options(future.plan = NULL)
[08:24:55.728]                   if (is.na(NA_character_)) 
[08:24:55.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.728]                     .init = FALSE)
[08:24:55.728]                 }
[08:24:55.728]             }
[08:24:55.728]         }
[08:24:55.728]     })
[08:24:55.728]     if (TRUE) {
[08:24:55.728]         base::sink(type = "output", split = FALSE)
[08:24:55.728]         if (TRUE) {
[08:24:55.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.728]         }
[08:24:55.728]         else {
[08:24:55.728]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.728]         }
[08:24:55.728]         base::close(...future.stdout)
[08:24:55.728]         ...future.stdout <- NULL
[08:24:55.728]     }
[08:24:55.728]     ...future.result$conditions <- ...future.conditions
[08:24:55.728]     ...future.result$finished <- base::Sys.time()
[08:24:55.728]     ...future.result
[08:24:55.728] }
[08:24:55.731] Exporting 5 global objects (4.35 KiB) to cluster node #1 ...
[08:24:55.731] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[08:24:55.732] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[08:24:55.732] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #1 ...
[08:24:55.773] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #1 ... DONE
[08:24:55.773] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ...
[08:24:55.773] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ... DONE
[08:24:55.774] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ...
[08:24:55.774] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ... DONE
[08:24:55.774] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[08:24:55.775] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[08:24:55.775] Exporting 5 global objects (4.35 KiB) to cluster node #1 ... DONE
[08:24:55.775] MultisessionFuture started
[08:24:55.775] - Launch lazy future ... done
[08:24:55.775] run() for ‘MultisessionFuture’ ... done
[08:24:55.776] Created future:
[08:24:55.776] MultisessionFuture:
[08:24:55.776] Label: ‘future_apply-1’
[08:24:55.776] Expression:
[08:24:55.776] {
[08:24:55.776]     do.call(function(...) {
[08:24:55.776]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.776]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.776]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.776]             on.exit(options(oopts), add = TRUE)
[08:24:55.776]         }
[08:24:55.776]         {
[08:24:55.776]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.776]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.776]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:55.776]                   envir = globalenv(), inherits = FALSE)
[08:24:55.776]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.776]             })
[08:24:55.776]         }
[08:24:55.776]     }, args = future.call.arguments)
[08:24:55.776] }
[08:24:55.776] Lazy evaluation: FALSE
[08:24:55.776] Asynchronous evaluation: TRUE
[08:24:55.776] Local evaluation: TRUE
[08:24:55.776] Environment: R_GlobalEnv
[08:24:55.776] Capture standard output: TRUE
[08:24:55.776] Capture condition classes: <none>
[08:24:55.776] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.776] Packages: <none>
[08:24:55.776] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:24:55.776] Resolved: FALSE
[08:24:55.776] Value: <not collected>
[08:24:55.776] Conditions captured: <none>
[08:24:55.776] Early signaling: FALSE
[08:24:55.776] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.776] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.787] Chunk #1 of 2 ... DONE
[08:24:55.787] Chunk #2 of 2 ...
[08:24:55.788]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[08:24:55.788]  - seeds: [1] <seeds>
[08:24:55.788]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.788] getGlobalsAndPackages() ...
[08:24:55.788] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.788] Resolving globals: FALSE
[08:24:55.788] Tweak future expression to call with '...' arguments ...
[08:24:55.788] {
[08:24:55.788]     do.call(function(...) {
[08:24:55.788]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.788]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.788]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.788]             on.exit(options(oopts), add = TRUE)
[08:24:55.788]         }
[08:24:55.788]         {
[08:24:55.788]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.788]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.788]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:55.788]                   envir = globalenv(), inherits = FALSE)
[08:24:55.788]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.788]             })
[08:24:55.788]         }
[08:24:55.788]     }, args = future.call.arguments)
[08:24:55.788] }
[08:24:55.789] Tweak future expression to call with '...' arguments ... DONE
[08:24:55.789] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[08:24:55.789] 
[08:24:55.789] getGlobalsAndPackages() ... DONE
[08:24:55.790] run() for ‘Future’ ...
[08:24:55.790] - state: ‘created’
[08:24:55.790] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:24:55.807] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.807] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:24:55.807]   - Field: ‘node’
[08:24:55.807]   - Field: ‘label’
[08:24:55.808]   - Field: ‘local’
[08:24:55.808]   - Field: ‘owner’
[08:24:55.808]   - Field: ‘envir’
[08:24:55.808]   - Field: ‘workers’
[08:24:55.808]   - Field: ‘packages’
[08:24:55.808]   - Field: ‘gc’
[08:24:55.808]   - Field: ‘conditions’
[08:24:55.808]   - Field: ‘persistent’
[08:24:55.808]   - Field: ‘expr’
[08:24:55.808]   - Field: ‘uuid’
[08:24:55.808]   - Field: ‘seed’
[08:24:55.808]   - Field: ‘version’
[08:24:55.809]   - Field: ‘result’
[08:24:55.809]   - Field: ‘asynchronous’
[08:24:55.809]   - Field: ‘calls’
[08:24:55.809]   - Field: ‘globals’
[08:24:55.809]   - Field: ‘stdout’
[08:24:55.809]   - Field: ‘earlySignal’
[08:24:55.809]   - Field: ‘lazy’
[08:24:55.809]   - Field: ‘state’
[08:24:55.809] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:24:55.809] - Launch lazy future ...
[08:24:55.810] Packages needed by the future expression (n = 0): <none>
[08:24:55.810] Packages needed by future strategies (n = 0): <none>
[08:24:55.810] {
[08:24:55.810]     {
[08:24:55.810]         {
[08:24:55.810]             ...future.startTime <- base::Sys.time()
[08:24:55.810]             {
[08:24:55.810]                 {
[08:24:55.810]                   {
[08:24:55.810]                     {
[08:24:55.810]                       base::local({
[08:24:55.810]                         has_future <- base::requireNamespace("future", 
[08:24:55.810]                           quietly = TRUE)
[08:24:55.810]                         if (has_future) {
[08:24:55.810]                           ns <- base::getNamespace("future")
[08:24:55.810]                           version <- ns[[".package"]][["version"]]
[08:24:55.810]                           if (is.null(version)) 
[08:24:55.810]                             version <- utils::packageVersion("future")
[08:24:55.810]                         }
[08:24:55.810]                         else {
[08:24:55.810]                           version <- NULL
[08:24:55.810]                         }
[08:24:55.810]                         if (!has_future || version < "1.8.0") {
[08:24:55.810]                           info <- base::c(r_version = base::gsub("R version ", 
[08:24:55.810]                             "", base::R.version$version.string), 
[08:24:55.810]                             platform = base::sprintf("%s (%s-bit)", 
[08:24:55.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:24:55.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:24:55.810]                               "release", "version")], collapse = " "), 
[08:24:55.810]                             hostname = base::Sys.info()[["nodename"]])
[08:24:55.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:24:55.810]                             info)
[08:24:55.810]                           info <- base::paste(info, collapse = "; ")
[08:24:55.810]                           if (!has_future) {
[08:24:55.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:24:55.810]                               info)
[08:24:55.810]                           }
[08:24:55.810]                           else {
[08:24:55.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:24:55.810]                               info, version)
[08:24:55.810]                           }
[08:24:55.810]                           base::stop(msg)
[08:24:55.810]                         }
[08:24:55.810]                       })
[08:24:55.810]                     }
[08:24:55.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:24:55.810]                     base::options(mc.cores = 1L)
[08:24:55.810]                   }
[08:24:55.810]                   ...future.strategy.old <- future::plan("list")
[08:24:55.810]                   options(future.plan = NULL)
[08:24:55.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:24:55.810]                 }
[08:24:55.810]                 ...future.workdir <- getwd()
[08:24:55.810]             }
[08:24:55.810]             ...future.oldOptions <- base::as.list(base::.Options)
[08:24:55.810]             ...future.oldEnvVars <- base::Sys.getenv()
[08:24:55.810]         }
[08:24:55.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:24:55.810]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[08:24:55.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:24:55.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:24:55.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:24:55.810]             future.stdout.windows.reencode = NULL, width = 80L)
[08:24:55.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:24:55.810]             base::names(...future.oldOptions))
[08:24:55.810]     }
[08:24:55.810]     if (FALSE) {
[08:24:55.810]     }
[08:24:55.810]     else {
[08:24:55.810]         if (TRUE) {
[08:24:55.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:24:55.810]                 open = "w")
[08:24:55.810]         }
[08:24:55.810]         else {
[08:24:55.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:24:55.810]                 windows = "NUL", "/dev/null"), open = "w")
[08:24:55.810]         }
[08:24:55.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:24:55.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:24:55.810]             base::sink(type = "output", split = FALSE)
[08:24:55.810]             base::close(...future.stdout)
[08:24:55.810]         }, add = TRUE)
[08:24:55.810]     }
[08:24:55.810]     ...future.frame <- base::sys.nframe()
[08:24:55.810]     ...future.conditions <- base::list()
[08:24:55.810]     ...future.rng <- base::globalenv()$.Random.seed
[08:24:55.810]     if (FALSE) {
[08:24:55.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:24:55.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:24:55.810]     }
[08:24:55.810]     ...future.result <- base::tryCatch({
[08:24:55.810]         base::withCallingHandlers({
[08:24:55.810]             ...future.value <- base::withVisible(base::local({
[08:24:55.810]                 ...future.makeSendCondition <- base::local({
[08:24:55.810]                   sendCondition <- NULL
[08:24:55.810]                   function(frame = 1L) {
[08:24:55.810]                     if (is.function(sendCondition)) 
[08:24:55.810]                       return(sendCondition)
[08:24:55.810]                     ns <- getNamespace("parallel")
[08:24:55.810]                     if (exists("sendData", mode = "function", 
[08:24:55.810]                       envir = ns)) {
[08:24:55.810]                       parallel_sendData <- get("sendData", mode = "function", 
[08:24:55.810]                         envir = ns)
[08:24:55.810]                       envir <- sys.frame(frame)
[08:24:55.810]                       master <- NULL
[08:24:55.810]                       while (!identical(envir, .GlobalEnv) && 
[08:24:55.810]                         !identical(envir, emptyenv())) {
[08:24:55.810]                         if (exists("master", mode = "list", envir = envir, 
[08:24:55.810]                           inherits = FALSE)) {
[08:24:55.810]                           master <- get("master", mode = "list", 
[08:24:55.810]                             envir = envir, inherits = FALSE)
[08:24:55.810]                           if (inherits(master, c("SOCKnode", 
[08:24:55.810]                             "SOCK0node"))) {
[08:24:55.810]                             sendCondition <<- function(cond) {
[08:24:55.810]                               data <- list(type = "VALUE", value = cond, 
[08:24:55.810]                                 success = TRUE)
[08:24:55.810]                               parallel_sendData(master, data)
[08:24:55.810]                             }
[08:24:55.810]                             return(sendCondition)
[08:24:55.810]                           }
[08:24:55.810]                         }
[08:24:55.810]                         frame <- frame + 1L
[08:24:55.810]                         envir <- sys.frame(frame)
[08:24:55.810]                       }
[08:24:55.810]                     }
[08:24:55.810]                     sendCondition <<- function(cond) NULL
[08:24:55.810]                   }
[08:24:55.810]                 })
[08:24:55.810]                 withCallingHandlers({
[08:24:55.810]                   {
[08:24:55.810]                     do.call(function(...) {
[08:24:55.810]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.810]                       if (!identical(...future.globals.maxSize.org, 
[08:24:55.810]                         ...future.globals.maxSize)) {
[08:24:55.810]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.810]                         on.exit(options(oopts), add = TRUE)
[08:24:55.810]                       }
[08:24:55.810]                       {
[08:24:55.810]                         lapply(seq_along(...future.elements_ii), 
[08:24:55.810]                           FUN = function(jj) {
[08:24:55.810]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.810]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:55.810]                               envir = globalenv(), inherits = FALSE)
[08:24:55.810]                             ...future.FUN(...future.X_jj, ...)
[08:24:55.810]                           })
[08:24:55.810]                       }
[08:24:55.810]                     }, args = future.call.arguments)
[08:24:55.810]                   }
[08:24:55.810]                 }, immediateCondition = function(cond) {
[08:24:55.810]                   sendCondition <- ...future.makeSendCondition()
[08:24:55.810]                   sendCondition(cond)
[08:24:55.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.810]                   {
[08:24:55.810]                     inherits <- base::inherits
[08:24:55.810]                     invokeRestart <- base::invokeRestart
[08:24:55.810]                     is.null <- base::is.null
[08:24:55.810]                     muffled <- FALSE
[08:24:55.810]                     if (inherits(cond, "message")) {
[08:24:55.810]                       muffled <- grepl(pattern, "muffleMessage")
[08:24:55.810]                       if (muffled) 
[08:24:55.810]                         invokeRestart("muffleMessage")
[08:24:55.810]                     }
[08:24:55.810]                     else if (inherits(cond, "warning")) {
[08:24:55.810]                       muffled <- grepl(pattern, "muffleWarning")
[08:24:55.810]                       if (muffled) 
[08:24:55.810]                         invokeRestart("muffleWarning")
[08:24:55.810]                     }
[08:24:55.810]                     else if (inherits(cond, "condition")) {
[08:24:55.810]                       if (!is.null(pattern)) {
[08:24:55.810]                         computeRestarts <- base::computeRestarts
[08:24:55.810]                         grepl <- base::grepl
[08:24:55.810]                         restarts <- computeRestarts(cond)
[08:24:55.810]                         for (restart in restarts) {
[08:24:55.810]                           name <- restart$name
[08:24:55.810]                           if (is.null(name)) 
[08:24:55.810]                             next
[08:24:55.810]                           if (!grepl(pattern, name)) 
[08:24:55.810]                             next
[08:24:55.810]                           invokeRestart(restart)
[08:24:55.810]                           muffled <- TRUE
[08:24:55.810]                           break
[08:24:55.810]                         }
[08:24:55.810]                       }
[08:24:55.810]                     }
[08:24:55.810]                     invisible(muffled)
[08:24:55.810]                   }
[08:24:55.810]                   muffleCondition(cond)
[08:24:55.810]                 })
[08:24:55.810]             }))
[08:24:55.810]             future::FutureResult(value = ...future.value$value, 
[08:24:55.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.810]                   ...future.rng), globalenv = if (FALSE) 
[08:24:55.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:24:55.810]                     ...future.globalenv.names))
[08:24:55.810]                 else NULL, started = ...future.startTime, version = "1.8")
[08:24:55.810]         }, condition = base::local({
[08:24:55.810]             c <- base::c
[08:24:55.810]             inherits <- base::inherits
[08:24:55.810]             invokeRestart <- base::invokeRestart
[08:24:55.810]             length <- base::length
[08:24:55.810]             list <- base::list
[08:24:55.810]             seq.int <- base::seq.int
[08:24:55.810]             signalCondition <- base::signalCondition
[08:24:55.810]             sys.calls <- base::sys.calls
[08:24:55.810]             `[[` <- base::`[[`
[08:24:55.810]             `+` <- base::`+`
[08:24:55.810]             `<<-` <- base::`<<-`
[08:24:55.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:24:55.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:24:55.810]                   3L)]
[08:24:55.810]             }
[08:24:55.810]             function(cond) {
[08:24:55.810]                 is_error <- inherits(cond, "error")
[08:24:55.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:24:55.810]                   NULL)
[08:24:55.810]                 if (is_error) {
[08:24:55.810]                   sessionInformation <- function() {
[08:24:55.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:24:55.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:24:55.810]                       search = base::search(), system = base::Sys.info())
[08:24:55.810]                   }
[08:24:55.810]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:24:55.810]                     cond$call), session = sessionInformation(), 
[08:24:55.810]                     timestamp = base::Sys.time(), signaled = 0L)
[08:24:55.810]                   signalCondition(cond)
[08:24:55.810]                 }
[08:24:55.810]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[08:24:55.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:24:55.810]                   ...future.conditions[[length(...future.conditions) + 
[08:24:55.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:24:55.810]                   if (TRUE && !signal) {
[08:24:55.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.810]                     {
[08:24:55.810]                       inherits <- base::inherits
[08:24:55.810]                       invokeRestart <- base::invokeRestart
[08:24:55.810]                       is.null <- base::is.null
[08:24:55.810]                       muffled <- FALSE
[08:24:55.810]                       if (inherits(cond, "message")) {
[08:24:55.810]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.810]                         if (muffled) 
[08:24:55.810]                           invokeRestart("muffleMessage")
[08:24:55.810]                       }
[08:24:55.810]                       else if (inherits(cond, "warning")) {
[08:24:55.810]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.810]                         if (muffled) 
[08:24:55.810]                           invokeRestart("muffleWarning")
[08:24:55.810]                       }
[08:24:55.810]                       else if (inherits(cond, "condition")) {
[08:24:55.810]                         if (!is.null(pattern)) {
[08:24:55.810]                           computeRestarts <- base::computeRestarts
[08:24:55.810]                           grepl <- base::grepl
[08:24:55.810]                           restarts <- computeRestarts(cond)
[08:24:55.810]                           for (restart in restarts) {
[08:24:55.810]                             name <- restart$name
[08:24:55.810]                             if (is.null(name)) 
[08:24:55.810]                               next
[08:24:55.810]                             if (!grepl(pattern, name)) 
[08:24:55.810]                               next
[08:24:55.810]                             invokeRestart(restart)
[08:24:55.810]                             muffled <- TRUE
[08:24:55.810]                             break
[08:24:55.810]                           }
[08:24:55.810]                         }
[08:24:55.810]                       }
[08:24:55.810]                       invisible(muffled)
[08:24:55.810]                     }
[08:24:55.810]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.810]                   }
[08:24:55.810]                 }
[08:24:55.810]                 else {
[08:24:55.810]                   if (TRUE) {
[08:24:55.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:24:55.810]                     {
[08:24:55.810]                       inherits <- base::inherits
[08:24:55.810]                       invokeRestart <- base::invokeRestart
[08:24:55.810]                       is.null <- base::is.null
[08:24:55.810]                       muffled <- FALSE
[08:24:55.810]                       if (inherits(cond, "message")) {
[08:24:55.810]                         muffled <- grepl(pattern, "muffleMessage")
[08:24:55.810]                         if (muffled) 
[08:24:55.810]                           invokeRestart("muffleMessage")
[08:24:55.810]                       }
[08:24:55.810]                       else if (inherits(cond, "warning")) {
[08:24:55.810]                         muffled <- grepl(pattern, "muffleWarning")
[08:24:55.810]                         if (muffled) 
[08:24:55.810]                           invokeRestart("muffleWarning")
[08:24:55.810]                       }
[08:24:55.810]                       else if (inherits(cond, "condition")) {
[08:24:55.810]                         if (!is.null(pattern)) {
[08:24:55.810]                           computeRestarts <- base::computeRestarts
[08:24:55.810]                           grepl <- base::grepl
[08:24:55.810]                           restarts <- computeRestarts(cond)
[08:24:55.810]                           for (restart in restarts) {
[08:24:55.810]                             name <- restart$name
[08:24:55.810]                             if (is.null(name)) 
[08:24:55.810]                               next
[08:24:55.810]                             if (!grepl(pattern, name)) 
[08:24:55.810]                               next
[08:24:55.810]                             invokeRestart(restart)
[08:24:55.810]                             muffled <- TRUE
[08:24:55.810]                             break
[08:24:55.810]                           }
[08:24:55.810]                         }
[08:24:55.810]                       }
[08:24:55.810]                       invisible(muffled)
[08:24:55.810]                     }
[08:24:55.810]                     muffleCondition(cond, pattern = "^muffle")
[08:24:55.810]                   }
[08:24:55.810]                 }
[08:24:55.810]             }
[08:24:55.810]         }))
[08:24:55.810]     }, error = function(ex) {
[08:24:55.810]         base::structure(base::list(value = NULL, visible = NULL, 
[08:24:55.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:24:55.810]                 ...future.rng), started = ...future.startTime, 
[08:24:55.810]             finished = Sys.time(), session_uuid = NA_character_, 
[08:24:55.810]             version = "1.8"), class = "FutureResult")
[08:24:55.810]     }, finally = {
[08:24:55.810]         if (!identical(...future.workdir, getwd())) 
[08:24:55.810]             setwd(...future.workdir)
[08:24:55.810]         {
[08:24:55.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:24:55.810]                 ...future.oldOptions$nwarnings <- NULL
[08:24:55.810]             }
[08:24:55.810]             base::options(...future.oldOptions)
[08:24:55.810]             if (.Platform$OS.type == "windows") {
[08:24:55.810]                 old_names <- names(...future.oldEnvVars)
[08:24:55.810]                 envs <- base::Sys.getenv()
[08:24:55.810]                 names <- names(envs)
[08:24:55.810]                 common <- intersect(names, old_names)
[08:24:55.810]                 added <- setdiff(names, old_names)
[08:24:55.810]                 removed <- setdiff(old_names, names)
[08:24:55.810]                 changed <- common[...future.oldEnvVars[common] != 
[08:24:55.810]                   envs[common]]
[08:24:55.810]                 NAMES <- toupper(changed)
[08:24:55.810]                 args <- list()
[08:24:55.810]                 for (kk in seq_along(NAMES)) {
[08:24:55.810]                   name <- changed[[kk]]
[08:24:55.810]                   NAME <- NAMES[[kk]]
[08:24:55.810]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.810]                     next
[08:24:55.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.810]                 }
[08:24:55.810]                 NAMES <- toupper(added)
[08:24:55.810]                 for (kk in seq_along(NAMES)) {
[08:24:55.810]                   name <- added[[kk]]
[08:24:55.810]                   NAME <- NAMES[[kk]]
[08:24:55.810]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.810]                     next
[08:24:55.810]                   args[[name]] <- ""
[08:24:55.810]                 }
[08:24:55.810]                 NAMES <- toupper(removed)
[08:24:55.810]                 for (kk in seq_along(NAMES)) {
[08:24:55.810]                   name <- removed[[kk]]
[08:24:55.810]                   NAME <- NAMES[[kk]]
[08:24:55.810]                   if (name != NAME && is.element(NAME, old_names)) 
[08:24:55.810]                     next
[08:24:55.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:24:55.810]                 }
[08:24:55.810]                 if (length(args) > 0) 
[08:24:55.810]                   base::do.call(base::Sys.setenv, args = args)
[08:24:55.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:24:55.810]             }
[08:24:55.810]             else {
[08:24:55.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:24:55.810]             }
[08:24:55.810]             {
[08:24:55.810]                 if (base::length(...future.futureOptionsAdded) > 
[08:24:55.810]                   0L) {
[08:24:55.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:24:55.810]                   base::names(opts) <- ...future.futureOptionsAdded
[08:24:55.810]                   base::options(opts)
[08:24:55.810]                 }
[08:24:55.810]                 {
[08:24:55.810]                   {
[08:24:55.810]                     base::options(mc.cores = ...future.mc.cores.old)
[08:24:55.810]                     NULL
[08:24:55.810]                   }
[08:24:55.810]                   options(future.plan = NULL)
[08:24:55.810]                   if (is.na(NA_character_)) 
[08:24:55.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:24:55.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:24:55.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:24:55.810]                     .init = FALSE)
[08:24:55.810]                 }
[08:24:55.810]             }
[08:24:55.810]         }
[08:24:55.810]     })
[08:24:55.810]     if (TRUE) {
[08:24:55.810]         base::sink(type = "output", split = FALSE)
[08:24:55.810]         if (TRUE) {
[08:24:55.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:24:55.810]         }
[08:24:55.810]         else {
[08:24:55.810]             ...future.result["stdout"] <- base::list(NULL)
[08:24:55.810]         }
[08:24:55.810]         base::close(...future.stdout)
[08:24:55.810]         ...future.stdout <- NULL
[08:24:55.810]     }
[08:24:55.810]     ...future.result$conditions <- ...future.conditions
[08:24:55.810]     ...future.result$finished <- base::Sys.time()
[08:24:55.810]     ...future.result
[08:24:55.810] }
[08:24:55.813] Exporting 5 global objects (4.35 KiB) to cluster node #2 ...
[08:24:55.813] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[08:24:55.814] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[08:24:55.814] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #2 ...
[08:24:55.855] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #2 ... DONE
[08:24:55.856] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ...
[08:24:55.856] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ... DONE
[08:24:55.856] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ...
[08:24:55.857] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ... DONE
[08:24:55.857] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[08:24:55.857] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[08:24:55.858] Exporting 5 global objects (4.35 KiB) to cluster node #2 ... DONE
[08:24:55.858] MultisessionFuture started
[08:24:55.858] - Launch lazy future ... done
[08:24:55.858] run() for ‘MultisessionFuture’ ... done
[08:24:55.858] Created future:
[08:24:55.859] MultisessionFuture:
[08:24:55.859] Label: ‘future_apply-2’
[08:24:55.859] Expression:
[08:24:55.859] {
[08:24:55.859]     do.call(function(...) {
[08:24:55.859]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[08:24:55.859]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[08:24:55.859]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[08:24:55.859]             on.exit(options(oopts), add = TRUE)
[08:24:55.859]         }
[08:24:55.859]         {
[08:24:55.859]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[08:24:55.859]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[08:24:55.859]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[08:24:55.859]                   envir = globalenv(), inherits = FALSE)
[08:24:55.859]                 ...future.FUN(...future.X_jj, ...)
[08:24:55.859]             })
[08:24:55.859]         }
[08:24:55.859]     }, args = future.call.arguments)
[08:24:55.859] }
[08:24:55.859] Lazy evaluation: FALSE
[08:24:55.859] Asynchronous evaluation: TRUE
[08:24:55.859] Local evaluation: TRUE
[08:24:55.859] Environment: R_GlobalEnv
[08:24:55.859] Capture standard output: TRUE
[08:24:55.859] Capture condition classes: <none>
[08:24:55.859] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[08:24:55.859] Packages: <none>
[08:24:55.859] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[08:24:55.859] Resolved: FALSE
[08:24:55.859] Value: <not collected>
[08:24:55.859] Conditions captured: <none>
[08:24:55.859] Early signaling: FALSE
[08:24:55.859] Owner process: 5598618e-4cef-6695-dcb2-de04499832bd
[08:24:55.859] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:24:55.870] Chunk #2 of 2 ... DONE
[08:24:55.870] Launching 2 futures (chunks) ... DONE
[08:24:55.870] Resolving 2 futures (chunks) ...
[08:24:55.871] resolve() on list ...
[08:24:55.871]  recursive: 0
[08:24:55.871]  length: 2
[08:24:55.871] 
[08:24:55.871] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.872] - Validating connection of MultisessionFuture
[08:24:55.872] - received message: FutureResult
[08:24:55.872] - Received FutureResult
[08:24:55.872] - Erased future from FutureRegistry
[08:24:55.872] result() for ClusterFuture ...
[08:24:55.872] - result already collected: FutureResult
[08:24:55.872] result() for ClusterFuture ... done
[08:24:55.872] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.872] Future #1
[08:24:55.872] result() for ClusterFuture ...
[08:24:55.873] - result already collected: FutureResult
[08:24:55.873] result() for ClusterFuture ... done
[08:24:55.873] result() for ClusterFuture ...
[08:24:55.873] - result already collected: FutureResult
[08:24:55.873] result() for ClusterFuture ... done
[08:24:55.873] signalConditionsASAP(MultisessionFuture, pos=1) ...
[08:24:55.873] - nx: 2
[08:24:55.873] - relay: TRUE
[08:24:55.873] - stdout: TRUE
[08:24:55.873] - signal: TRUE
[08:24:55.873] - resignal: FALSE
[08:24:55.873] - force: TRUE
[08:24:55.874] - relayed: [n=2] FALSE, FALSE
[08:24:55.874] - queued futures: [n=2] FALSE, FALSE
[08:24:55.874]  - until=1
[08:24:55.874]  - relaying element #1
[08:24:55.874] result() for ClusterFuture ...
[08:24:55.874] - result already collected: FutureResult
[08:24:55.874] result() for ClusterFuture ... done
[08:24:55.874] result() for ClusterFuture ...
[08:24:55.874] - result already collected: FutureResult
[08:24:55.874] result() for ClusterFuture ... done
[08:24:55.874] result() for ClusterFuture ...
[08:24:55.874] - result already collected: FutureResult
[08:24:55.875] result() for ClusterFuture ... done
[08:24:55.875] result() for ClusterFuture ...
[08:24:55.875] - result already collected: FutureResult
[08:24:55.875] result() for ClusterFuture ... done
[08:24:55.875] - relayed: [n=2] TRUE, FALSE
[08:24:55.875] - queued futures: [n=2] TRUE, FALSE
[08:24:55.875] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[08:24:55.875]  length: 1 (resolved future 1)
[08:24:55.900] receiveMessageFromWorker() for ClusterFuture ...
[08:24:55.900] - Validating connection of MultisessionFuture
[08:24:55.901] - received message: FutureResult
[08:24:55.901] - Received FutureResult
[08:24:55.901] - Erased future from FutureRegistry
[08:24:55.901] result() for ClusterFuture ...
[08:24:55.901] - result already collected: FutureResult
[08:24:55.901] result() for ClusterFuture ... done
[08:24:55.901] receiveMessageFromWorker() for ClusterFuture ... done
[08:24:55.901] Future #2
[08:24:55.901] result() for ClusterFuture ...
[08:24:55.902] - result already collected: FutureResult
[08:24:55.902] result() for ClusterFuture ... done
[08:24:55.902] result() for ClusterFuture ...
[08:24:55.902] - result already collected: FutureResult
[08:24:55.902] result() for ClusterFuture ... done
[08:24:55.902] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:24:55.902] - nx: 2
[08:24:55.902] - relay: TRUE
[08:24:55.902] - stdout: TRUE
[08:24:55.902] - signal: TRUE
[08:24:55.902] - resignal: FALSE
[08:24:55.902] - force: TRUE
[08:24:55.903] - relayed: [n=2] TRUE, FALSE
[08:24:55.903] - queued futures: [n=2] TRUE, FALSE
[08:24:55.903]  - until=2
[08:24:55.903]  - relaying element #2
[08:24:55.903] result() for ClusterFuture ...
[08:24:55.903] - result already collected: FutureResult
[08:24:55.903] result() for ClusterFuture ... done
[08:24:55.903] result() for ClusterFuture ...
[08:24:55.903] - result already collected: FutureResult
[08:24:55.903] result() for ClusterFuture ... done
[08:24:55.903] result() for ClusterFuture ...
[08:24:55.904] - result already collected: FutureResult
[08:24:55.904] result() for ClusterFuture ... done
[08:24:55.904] result() for ClusterFuture ...
[08:24:55.904] - result already collected: FutureResult
[08:24:55.904] result() for ClusterFuture ... done
[08:24:55.904] - relayed: [n=2] TRUE, TRUE
[08:24:55.904] - queued futures: [n=2] TRUE, TRUE
[08:24:55.904] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:24:55.904]  length: 0 (resolved future 2)
[08:24:55.904] Relaying remaining futures
[08:24:55.904] signalConditionsASAP(NULL, pos=0) ...
[08:24:55.904] - nx: 2
[08:24:55.905] - relay: TRUE
[08:24:55.905] - stdout: TRUE
[08:24:55.905] - signal: TRUE
[08:24:55.905] - resignal: FALSE
[08:24:55.905] - force: TRUE
[08:24:55.905] - relayed: [n=2] TRUE, TRUE
[08:24:55.905] - queued futures: [n=2] TRUE, TRUE
 - flush all
[08:24:55.905] - relayed: [n=2] TRUE, TRUE
[08:24:55.905] - queued futures: [n=2] TRUE, TRUE
[08:24:55.905] signalConditionsASAP(NULL, pos=0) ... done
[08:24:55.905] resolve() on list ... DONE
[08:24:55.905] result() for ClusterFuture ...
[08:24:55.906] - result already collected: FutureResult
[08:24:55.906] result() for ClusterFuture ... done
[08:24:55.906] result() for ClusterFuture ...
[08:24:55.906] - result already collected: FutureResult
[08:24:55.906] result() for ClusterFuture ... done
[08:24:55.906] result() for ClusterFuture ...
[08:24:55.906] - result already collected: FutureResult
[08:24:55.906] result() for ClusterFuture ... done
[08:24:55.906] result() for ClusterFuture ...
[08:24:55.906] - result already collected: FutureResult
[08:24:55.906] result() for ClusterFuture ... done
[08:24:55.906]  - Number of value chunks collected: 2
[08:24:55.907] Resolving 2 futures (chunks) ... DONE
[08:24:55.907] Reducing values from 2 chunks ...
[08:24:55.907]  - Number of values collected after concatenation: 2
[08:24:55.907]  - Number of values expected: 2
[08:24:55.907] Reducing values from 2 chunks ... DONE
[08:24:55.907] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[08:24:55.907] plan(): Setting new future strategy stack:
[08:24:55.907] List of future strategies:
[08:24:55.907] 1. sequential:
[08:24:55.907]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:55.907]    - tweaked: FALSE
[08:24:55.907]    - call: plan(sequential)
[08:24:55.908] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[08:24:55.910] plan(): Setting new future strategy stack:
[08:24:55.910] List of future strategies:
[08:24:55.910] 1. FutureStrategy:
[08:24:55.910]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:24:55.910]    - tweaked: FALSE
[08:24:55.910]    - call: future::plan(oplan)
[08:24:55.911] plan(): nbrOfWorkers() = 1
> 
