
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:18:25.935] plan(): Setting new future strategy stack:
[10:18:25.935] List of future strategies:
[10:18:25.935] 1. sequential:
[10:18:25.935]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:25.935]    - tweaked: FALSE
[10:18:25.935]    - call: future::plan("sequential")
[10:18:25.949] plan(): nbrOfWorkers() = 1
> 
> message("*** future_apply() ...")
*** future_apply() ...
> 
> z0 <- NULL
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+ 
+   message("- From example(apply) ...")
+   X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
+   
+   Y0 <- apply(X, MARGIN = 1L, FUN = table)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
+ 
+   Y2 <- future_apply(X, MARGIN = 1L, FUN = "table")
+   print(Y2)
+   stopifnot(identical(Y2, Y1))
+ 
+   Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
+   Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
+   print(Y1)
+   stopifnot(all.equal(Y1, Y0))
+ 
+   x <- cbind(x1 = 3, x2 = c(4:1, 2:5))
+   names(dimnames(x)) <- c("row", "col")
+   x3 <- array(x, dim = c(dim(x), 3),
+               dimnames = c(dimnames(x), list(C = paste0("cop.", 1:3))))
+   
+   y0 <- apply(x, MARGIN = 2L, FUN = identity)
+   stopifnot(identical(y0, x))
+   y1 <- future_apply(x, MARGIN = 2L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+   
+   y0 <- apply(x3, MARGIN = 2:3, FUN = identity)
+   stopifnot(identical(y0, x3))
+   y1 <- future_apply(x3, MARGIN = 2:3, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   z <- array(1:24, dim = 2:4)
+   y0 <- apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   y1 <- future_apply(z, MARGIN = 1:2, FUN = function(x) seq_len(max(x)))
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, MARGIN = <character>, ...) ...")
+   X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
+   y0 <- apply(X, MARGIN = "rows", FUN = identity)
+   y1 <- future_apply(X, MARGIN = "rows", FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - dim(X) > 2 ...")
+   X <- array(1:12, dim = c(2, 2, 3))
+   y0 <- apply(X, MARGIN = 1L, FUN = identity)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- apply(X, ...) - not all same names ...")
+   FUN <- function(x) {
+     if (x[1] == 1L) names(x) <- letters[seq_along(x)]
+     x
+   }
+   X <- matrix(1:4, nrow = 2L, ncol = 2L)
+   y0 <- apply(X, MARGIN = 1L, FUN = FUN)
+   y1 <- future_apply(X, MARGIN = 1L, FUN = FUN)
+   print(y1)
+   stopifnot(identical(y1, y0))
+ 
+   message("- example(future_apply) - reproducible RNG ...")
+   z1 <- future_apply(X, MARGIN = 1L, FUN = sample,
+           future.seed = 0xBEEF,
+           ## Test also all other 'future.*' arguments
+           future.stdout     = TRUE,
+           future.conditions = NULL,
+           future.globals    = TRUE,
+           future.packages   = NULL,
+           future.scheduling = 1.0,
+           future.chunk.size = NULL,
+           future.label      = "future_apply-%d"
+         )
+   print(z1)
+   if (is.null(z0)) {
+     z0 <- z1
+   } else {
+     stopifnot(identical(z1, z0))
+   }
+ 
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:18:26.014] plan(): Setting new future strategy stack:
[10:18:26.014] List of future strategies:
[10:18:26.014] 1. sequential:
[10:18:26.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.014]    - tweaked: FALSE
[10:18:26.014]    - call: plan(strategy)
[10:18:26.025] plan(): nbrOfWorkers() = 1
- From example(apply) ...
[10:18:26.026] getGlobalsAndPackagesXApply() ...
[10:18:26.026]  - future.globals: TRUE
[10:18:26.027] getGlobalsAndPackages() ...
[10:18:26.027] Searching for globals...
[10:18:26.067] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:18:26.067] Searching for globals ... DONE
[10:18:26.067] Resolving globals: FALSE
[10:18:26.070] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:18:26.070] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:18:26.070] - globals: [1] ‘FUN’
[10:18:26.071] 
[10:18:26.071] getGlobalsAndPackages() ... DONE
[10:18:26.071]  - globals found/used: [n=1] ‘FUN’
[10:18:26.071]  - needed namespaces: [n=0] 
[10:18:26.071] Finding globals ... DONE
[10:18:26.071]  - use_args: TRUE
[10:18:26.071]  - Getting '...' globals ...
[10:18:26.072] resolve() on list ...
[10:18:26.072]  recursive: 0
[10:18:26.072]  length: 1
[10:18:26.072]  elements: ‘...’
[10:18:26.072]  length: 0 (resolved future 1)
[10:18:26.073] resolve() on list ... DONE
[10:18:26.073]    - '...' content: [n=0] 
[10:18:26.073] List of 1
[10:18:26.073]  $ ...: list()
[10:18:26.073]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.073]  - attr(*, "where")=List of 1
[10:18:26.073]   ..$ ...:<environment: 0x556e03794b28> 
[10:18:26.073]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.073]  - attr(*, "resolved")= logi TRUE
[10:18:26.073]  - attr(*, "total_size")= num NA
[10:18:26.077]  - Getting '...' globals ... DONE
[10:18:26.077] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.078] List of 2
[10:18:26.078]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.078]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.078]  $ ...          : list()
[10:18:26.078]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.078]  - attr(*, "where")=List of 2
[10:18:26.078]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.078]   ..$ ...          :<environment: 0x556e03794b28> 
[10:18:26.078]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.078]  - attr(*, "resolved")= logi FALSE
[10:18:26.078]  - attr(*, "total_size")= num 65963
[10:18:26.080] Packages to be attached in all futures: [n=0] 
[10:18:26.080] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.081] future_lapply() ...
[10:18:26.114] Number of chunks: 1
[10:18:26.115] getGlobalsAndPackagesXApply() ...
[10:18:26.115]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.115]  - use_args: TRUE
[10:18:26.115] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.115] List of 2
[10:18:26.115]  $ ...          : list()
[10:18:26.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.115]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.115]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.115]  - attr(*, "where")=List of 2
[10:18:26.115]   ..$ ...          :<environment: 0x556e03794b28> 
[10:18:26.115]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:26.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.115]  - attr(*, "resolved")= logi FALSE
[10:18:26.115]  - attr(*, "total_size")= num NA
[10:18:26.119] Packages to be attached in all futures: [n=0] 
[10:18:26.119] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.119] Number of futures (= number of chunks): 1
[10:18:26.119] Launching 1 futures (chunks) ...
[10:18:26.119] Chunk #1 of 1 ...
[10:18:26.119]  - seeds: <none>
[10:18:26.120]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.120] getGlobalsAndPackages() ...
[10:18:26.120] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.120] Resolving globals: FALSE
[10:18:26.120] Tweak future expression to call with '...' arguments ...
[10:18:26.120] {
[10:18:26.120]     do.call(function(...) {
[10:18:26.120]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.120]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.120]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.120]             on.exit(options(oopts), add = TRUE)
[10:18:26.120]         }
[10:18:26.120]         {
[10:18:26.120]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.120]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.120]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.120]             })
[10:18:26.120]         }
[10:18:26.120]     }, args = future.call.arguments)
[10:18:26.120] }
[10:18:26.120] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.121] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.121] 
[10:18:26.121] getGlobalsAndPackages() ... DONE
[10:18:26.122] run() for ‘Future’ ...
[10:18:26.122] - state: ‘created’
[10:18:26.122] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.122] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.122] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.123]   - Field: ‘label’
[10:18:26.123]   - Field: ‘local’
[10:18:26.123]   - Field: ‘owner’
[10:18:26.123]   - Field: ‘envir’
[10:18:26.123]   - Field: ‘packages’
[10:18:26.123]   - Field: ‘gc’
[10:18:26.123]   - Field: ‘conditions’
[10:18:26.123]   - Field: ‘expr’
[10:18:26.123]   - Field: ‘uuid’
[10:18:26.123]   - Field: ‘seed’
[10:18:26.123]   - Field: ‘version’
[10:18:26.124]   - Field: ‘result’
[10:18:26.124]   - Field: ‘asynchronous’
[10:18:26.124]   - Field: ‘calls’
[10:18:26.124]   - Field: ‘globals’
[10:18:26.124]   - Field: ‘stdout’
[10:18:26.124]   - Field: ‘earlySignal’
[10:18:26.124]   - Field: ‘lazy’
[10:18:26.124]   - Field: ‘state’
[10:18:26.124] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.124] - Launch lazy future ...
[10:18:26.125] Packages needed by the future expression (n = 0): <none>
[10:18:26.125] Packages needed by future strategies (n = 0): <none>
[10:18:26.126] {
[10:18:26.126]     {
[10:18:26.126]         {
[10:18:26.126]             ...future.startTime <- base::Sys.time()
[10:18:26.126]             {
[10:18:26.126]                 {
[10:18:26.126]                   {
[10:18:26.126]                     base::local({
[10:18:26.126]                       has_future <- base::requireNamespace("future", 
[10:18:26.126]                         quietly = TRUE)
[10:18:26.126]                       if (has_future) {
[10:18:26.126]                         ns <- base::getNamespace("future")
[10:18:26.126]                         version <- ns[[".package"]][["version"]]
[10:18:26.126]                         if (is.null(version)) 
[10:18:26.126]                           version <- utils::packageVersion("future")
[10:18:26.126]                       }
[10:18:26.126]                       else {
[10:18:26.126]                         version <- NULL
[10:18:26.126]                       }
[10:18:26.126]                       if (!has_future || version < "1.8.0") {
[10:18:26.126]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.126]                           "", base::R.version$version.string), 
[10:18:26.126]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:26.126]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.126]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.126]                             "release", "version")], collapse = " "), 
[10:18:26.126]                           hostname = base::Sys.info()[["nodename"]])
[10:18:26.126]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.126]                           info)
[10:18:26.126]                         info <- base::paste(info, collapse = "; ")
[10:18:26.126]                         if (!has_future) {
[10:18:26.126]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.126]                             info)
[10:18:26.126]                         }
[10:18:26.126]                         else {
[10:18:26.126]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.126]                             info, version)
[10:18:26.126]                         }
[10:18:26.126]                         base::stop(msg)
[10:18:26.126]                       }
[10:18:26.126]                     })
[10:18:26.126]                   }
[10:18:26.126]                   ...future.strategy.old <- future::plan("list")
[10:18:26.126]                   options(future.plan = NULL)
[10:18:26.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.126]                 }
[10:18:26.126]                 ...future.workdir <- getwd()
[10:18:26.126]             }
[10:18:26.126]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.126]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.126]         }
[10:18:26.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.126]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.126]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.126]             base::names(...future.oldOptions))
[10:18:26.126]     }
[10:18:26.126]     if (FALSE) {
[10:18:26.126]     }
[10:18:26.126]     else {
[10:18:26.126]         if (TRUE) {
[10:18:26.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.126]                 open = "w")
[10:18:26.126]         }
[10:18:26.126]         else {
[10:18:26.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.126]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.126]         }
[10:18:26.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.126]             base::sink(type = "output", split = FALSE)
[10:18:26.126]             base::close(...future.stdout)
[10:18:26.126]         }, add = TRUE)
[10:18:26.126]     }
[10:18:26.126]     ...future.frame <- base::sys.nframe()
[10:18:26.126]     ...future.conditions <- base::list()
[10:18:26.126]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.126]     if (FALSE) {
[10:18:26.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.126]     }
[10:18:26.126]     ...future.result <- base::tryCatch({
[10:18:26.126]         base::withCallingHandlers({
[10:18:26.126]             ...future.value <- base::withVisible(base::local({
[10:18:26.126]                 do.call(function(...) {
[10:18:26.126]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.126]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.126]                     ...future.globals.maxSize)) {
[10:18:26.126]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.126]                     on.exit(options(oopts), add = TRUE)
[10:18:26.126]                   }
[10:18:26.126]                   {
[10:18:26.126]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.126]                       FUN = function(jj) {
[10:18:26.126]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.126]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.126]                       })
[10:18:26.126]                   }
[10:18:26.126]                 }, args = future.call.arguments)
[10:18:26.126]             }))
[10:18:26.126]             future::FutureResult(value = ...future.value$value, 
[10:18:26.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.126]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.126]                     ...future.globalenv.names))
[10:18:26.126]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.126]         }, condition = base::local({
[10:18:26.126]             c <- base::c
[10:18:26.126]             inherits <- base::inherits
[10:18:26.126]             invokeRestart <- base::invokeRestart
[10:18:26.126]             length <- base::length
[10:18:26.126]             list <- base::list
[10:18:26.126]             seq.int <- base::seq.int
[10:18:26.126]             signalCondition <- base::signalCondition
[10:18:26.126]             sys.calls <- base::sys.calls
[10:18:26.126]             `[[` <- base::`[[`
[10:18:26.126]             `+` <- base::`+`
[10:18:26.126]             `<<-` <- base::`<<-`
[10:18:26.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.126]                   3L)]
[10:18:26.126]             }
[10:18:26.126]             function(cond) {
[10:18:26.126]                 is_error <- inherits(cond, "error")
[10:18:26.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.126]                   NULL)
[10:18:26.126]                 if (is_error) {
[10:18:26.126]                   sessionInformation <- function() {
[10:18:26.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.126]                       search = base::search(), system = base::Sys.info())
[10:18:26.126]                   }
[10:18:26.126]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.126]                     cond$call), session = sessionInformation(), 
[10:18:26.126]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.126]                   signalCondition(cond)
[10:18:26.126]                 }
[10:18:26.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.126]                 "immediateCondition"))) {
[10:18:26.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.126]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.126]                   if (TRUE && !signal) {
[10:18:26.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.126]                     {
[10:18:26.126]                       inherits <- base::inherits
[10:18:26.126]                       invokeRestart <- base::invokeRestart
[10:18:26.126]                       is.null <- base::is.null
[10:18:26.126]                       muffled <- FALSE
[10:18:26.126]                       if (inherits(cond, "message")) {
[10:18:26.126]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.126]                         if (muffled) 
[10:18:26.126]                           invokeRestart("muffleMessage")
[10:18:26.126]                       }
[10:18:26.126]                       else if (inherits(cond, "warning")) {
[10:18:26.126]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.126]                         if (muffled) 
[10:18:26.126]                           invokeRestart("muffleWarning")
[10:18:26.126]                       }
[10:18:26.126]                       else if (inherits(cond, "condition")) {
[10:18:26.126]                         if (!is.null(pattern)) {
[10:18:26.126]                           computeRestarts <- base::computeRestarts
[10:18:26.126]                           grepl <- base::grepl
[10:18:26.126]                           restarts <- computeRestarts(cond)
[10:18:26.126]                           for (restart in restarts) {
[10:18:26.126]                             name <- restart$name
[10:18:26.126]                             if (is.null(name)) 
[10:18:26.126]                               next
[10:18:26.126]                             if (!grepl(pattern, name)) 
[10:18:26.126]                               next
[10:18:26.126]                             invokeRestart(restart)
[10:18:26.126]                             muffled <- TRUE
[10:18:26.126]                             break
[10:18:26.126]                           }
[10:18:26.126]                         }
[10:18:26.126]                       }
[10:18:26.126]                       invisible(muffled)
[10:18:26.126]                     }
[10:18:26.126]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.126]                   }
[10:18:26.126]                 }
[10:18:26.126]                 else {
[10:18:26.126]                   if (TRUE) {
[10:18:26.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.126]                     {
[10:18:26.126]                       inherits <- base::inherits
[10:18:26.126]                       invokeRestart <- base::invokeRestart
[10:18:26.126]                       is.null <- base::is.null
[10:18:26.126]                       muffled <- FALSE
[10:18:26.126]                       if (inherits(cond, "message")) {
[10:18:26.126]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.126]                         if (muffled) 
[10:18:26.126]                           invokeRestart("muffleMessage")
[10:18:26.126]                       }
[10:18:26.126]                       else if (inherits(cond, "warning")) {
[10:18:26.126]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.126]                         if (muffled) 
[10:18:26.126]                           invokeRestart("muffleWarning")
[10:18:26.126]                       }
[10:18:26.126]                       else if (inherits(cond, "condition")) {
[10:18:26.126]                         if (!is.null(pattern)) {
[10:18:26.126]                           computeRestarts <- base::computeRestarts
[10:18:26.126]                           grepl <- base::grepl
[10:18:26.126]                           restarts <- computeRestarts(cond)
[10:18:26.126]                           for (restart in restarts) {
[10:18:26.126]                             name <- restart$name
[10:18:26.126]                             if (is.null(name)) 
[10:18:26.126]                               next
[10:18:26.126]                             if (!grepl(pattern, name)) 
[10:18:26.126]                               next
[10:18:26.126]                             invokeRestart(restart)
[10:18:26.126]                             muffled <- TRUE
[10:18:26.126]                             break
[10:18:26.126]                           }
[10:18:26.126]                         }
[10:18:26.126]                       }
[10:18:26.126]                       invisible(muffled)
[10:18:26.126]                     }
[10:18:26.126]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.126]                   }
[10:18:26.126]                 }
[10:18:26.126]             }
[10:18:26.126]         }))
[10:18:26.126]     }, error = function(ex) {
[10:18:26.126]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.126]                 ...future.rng), started = ...future.startTime, 
[10:18:26.126]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.126]             version = "1.8"), class = "FutureResult")
[10:18:26.126]     }, finally = {
[10:18:26.126]         if (!identical(...future.workdir, getwd())) 
[10:18:26.126]             setwd(...future.workdir)
[10:18:26.126]         {
[10:18:26.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.126]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.126]             }
[10:18:26.126]             base::options(...future.oldOptions)
[10:18:26.126]             if (.Platform$OS.type == "windows") {
[10:18:26.126]                 old_names <- names(...future.oldEnvVars)
[10:18:26.126]                 envs <- base::Sys.getenv()
[10:18:26.126]                 names <- names(envs)
[10:18:26.126]                 common <- intersect(names, old_names)
[10:18:26.126]                 added <- setdiff(names, old_names)
[10:18:26.126]                 removed <- setdiff(old_names, names)
[10:18:26.126]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.126]                   envs[common]]
[10:18:26.126]                 NAMES <- toupper(changed)
[10:18:26.126]                 args <- list()
[10:18:26.126]                 for (kk in seq_along(NAMES)) {
[10:18:26.126]                   name <- changed[[kk]]
[10:18:26.126]                   NAME <- NAMES[[kk]]
[10:18:26.126]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.126]                     next
[10:18:26.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.126]                 }
[10:18:26.126]                 NAMES <- toupper(added)
[10:18:26.126]                 for (kk in seq_along(NAMES)) {
[10:18:26.126]                   name <- added[[kk]]
[10:18:26.126]                   NAME <- NAMES[[kk]]
[10:18:26.126]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.126]                     next
[10:18:26.126]                   args[[name]] <- ""
[10:18:26.126]                 }
[10:18:26.126]                 NAMES <- toupper(removed)
[10:18:26.126]                 for (kk in seq_along(NAMES)) {
[10:18:26.126]                   name <- removed[[kk]]
[10:18:26.126]                   NAME <- NAMES[[kk]]
[10:18:26.126]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.126]                     next
[10:18:26.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.126]                 }
[10:18:26.126]                 if (length(args) > 0) 
[10:18:26.126]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.126]             }
[10:18:26.126]             else {
[10:18:26.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.126]             }
[10:18:26.126]             {
[10:18:26.126]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.126]                   0L) {
[10:18:26.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.126]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.126]                   base::options(opts)
[10:18:26.126]                 }
[10:18:26.126]                 {
[10:18:26.126]                   {
[10:18:26.126]                     NULL
[10:18:26.126]                     RNGkind("Mersenne-Twister")
[10:18:26.126]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:26.126]                       inherits = FALSE)
[10:18:26.126]                   }
[10:18:26.126]                   options(future.plan = NULL)
[10:18:26.126]                   if (is.na(NA_character_)) 
[10:18:26.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.126]                     .init = FALSE)
[10:18:26.126]                 }
[10:18:26.126]             }
[10:18:26.126]         }
[10:18:26.126]     })
[10:18:26.126]     if (TRUE) {
[10:18:26.126]         base::sink(type = "output", split = FALSE)
[10:18:26.126]         if (TRUE) {
[10:18:26.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.126]         }
[10:18:26.126]         else {
[10:18:26.126]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.126]         }
[10:18:26.126]         base::close(...future.stdout)
[10:18:26.126]         ...future.stdout <- NULL
[10:18:26.126]     }
[10:18:26.126]     ...future.result$conditions <- ...future.conditions
[10:18:26.126]     ...future.result$finished <- base::Sys.time()
[10:18:26.126]     ...future.result
[10:18:26.126] }
[10:18:26.128] assign_globals() ...
[10:18:26.128] List of 5
[10:18:26.128]  $ future.call.arguments    : list()
[10:18:26.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.128]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.128]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.128]  $ ...future.elements_ii    :List of 2
[10:18:26.128]   ..$ : num [1:4] 1 3 1 7
[10:18:26.128]   ..$ : num [1:4] 2 4 6 8
[10:18:26.128]  $ ...future.seeds_ii       : NULL
[10:18:26.128]  $ ...future.globals.maxSize: num Inf
[10:18:26.128]  - attr(*, "resolved")= logi FALSE
[10:18:26.128]  - attr(*, "total_size")= num NA
[10:18:26.128]  - attr(*, "where")=List of 5
[10:18:26.128]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.128]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.128]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.128]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.128]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.128]  - attr(*, "already-done")= logi TRUE
[10:18:26.133] - copied ‘future.call.arguments’ to environment
[10:18:26.133] - copied ‘...future.FUN’ to environment
[10:18:26.133] - copied ‘...future.elements_ii’ to environment
[10:18:26.133] - copied ‘...future.seeds_ii’ to environment
[10:18:26.133] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.133] assign_globals() ... done
[10:18:26.134] plan(): Setting new future strategy stack:
[10:18:26.134] List of future strategies:
[10:18:26.134] 1. sequential:
[10:18:26.134]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.134]    - tweaked: FALSE
[10:18:26.134]    - call: NULL
[10:18:26.134] plan(): nbrOfWorkers() = 1
[10:18:26.136] plan(): Setting new future strategy stack:
[10:18:26.136] List of future strategies:
[10:18:26.136] 1. sequential:
[10:18:26.136]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.136]    - tweaked: FALSE
[10:18:26.136]    - call: plan(strategy)
[10:18:26.136] plan(): nbrOfWorkers() = 1
[10:18:26.136] SequentialFuture started (and completed)
[10:18:26.137] - Launch lazy future ... done
[10:18:26.137] run() for ‘SequentialFuture’ ... done
[10:18:26.137] Created future:
[10:18:26.137] SequentialFuture:
[10:18:26.137] Label: ‘future_apply-1’
[10:18:26.137] Expression:
[10:18:26.137] {
[10:18:26.137]     do.call(function(...) {
[10:18:26.137]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.137]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.137]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.137]             on.exit(options(oopts), add = TRUE)
[10:18:26.137]         }
[10:18:26.137]         {
[10:18:26.137]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.137]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.137]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.137]             })
[10:18:26.137]         }
[10:18:26.137]     }, args = future.call.arguments)
[10:18:26.137] }
[10:18:26.137] Lazy evaluation: FALSE
[10:18:26.137] Asynchronous evaluation: FALSE
[10:18:26.137] Local evaluation: TRUE
[10:18:26.137] Environment: R_GlobalEnv
[10:18:26.137] Capture standard output: TRUE
[10:18:26.137] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.137] Globals: 5 objects totaling 31.56 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 111 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.137] Packages: <none>
[10:18:26.137] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.137] Resolved: TRUE
[10:18:26.137] Value: 429 bytes of class ‘list’
[10:18:26.137] Early signaling: FALSE
[10:18:26.137] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.137] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.139] Chunk #1 of 1 ... DONE
[10:18:26.139] Launching 1 futures (chunks) ... DONE
[10:18:26.139] Resolving 1 futures (chunks) ...
[10:18:26.139] resolve() on list ...
[10:18:26.139]  recursive: 0
[10:18:26.139]  length: 1
[10:18:26.139] 
[10:18:26.139] resolved() for ‘SequentialFuture’ ...
[10:18:26.139] - state: ‘finished’
[10:18:26.140] - run: TRUE
[10:18:26.140] - result: ‘FutureResult’
[10:18:26.140] resolved() for ‘SequentialFuture’ ... done
[10:18:26.140] Future #1
[10:18:26.140] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.140] - nx: 1
[10:18:26.140] - relay: TRUE
[10:18:26.140] - stdout: TRUE
[10:18:26.140] - signal: TRUE
[10:18:26.141] - resignal: FALSE
[10:18:26.141] - force: TRUE
[10:18:26.141] - relayed: [n=1] FALSE
[10:18:26.143] - queued futures: [n=1] FALSE
[10:18:26.143]  - until=1
[10:18:26.143]  - relaying element #1
[10:18:26.143] - relayed: [n=1] TRUE
[10:18:26.143] - queued futures: [n=1] TRUE
[10:18:26.143] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.144]  length: 0 (resolved future 1)
[10:18:26.144] Relaying remaining futures
[10:18:26.144] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.144] - nx: 1
[10:18:26.144] - relay: TRUE
[10:18:26.144] - stdout: TRUE
[10:18:26.144] - signal: TRUE
[10:18:26.144] - resignal: FALSE
[10:18:26.144] - force: TRUE
[10:18:26.144] - relayed: [n=1] TRUE
[10:18:26.145] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.145] - relayed: [n=1] TRUE
[10:18:26.145] - queued futures: [n=1] TRUE
[10:18:26.145] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.145] resolve() on list ... DONE
[10:18:26.145]  - Number of value chunks collected: 1
[10:18:26.145] Resolving 1 futures (chunks) ... DONE
[10:18:26.145] Reducing values from 1 chunks ...
[10:18:26.145]  - Number of values collected after concatenation: 2
[10:18:26.145]  - Number of values expected: 2
[10:18:26.146] Reducing values from 1 chunks ... DONE
[10:18:26.146] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:18:26.146] getGlobalsAndPackagesXApply() ...
[10:18:26.147]  - future.globals: TRUE
[10:18:26.147] getGlobalsAndPackages() ...
[10:18:26.147] Searching for globals...
[10:18:26.181] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:18:26.181] Searching for globals ... DONE
[10:18:26.181] Resolving globals: FALSE
[10:18:26.185] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:18:26.186] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:18:26.186] - globals: [1] ‘FUN’
[10:18:26.186] 
[10:18:26.186] getGlobalsAndPackages() ... DONE
[10:18:26.186]  - globals found/used: [n=1] ‘FUN’
[10:18:26.186]  - needed namespaces: [n=0] 
[10:18:26.186] Finding globals ... DONE
[10:18:26.186]  - use_args: TRUE
[10:18:26.186]  - Getting '...' globals ...
[10:18:26.187] resolve() on list ...
[10:18:26.187]  recursive: 0
[10:18:26.187]  length: 1
[10:18:26.187]  elements: ‘...’
[10:18:26.187]  length: 0 (resolved future 1)
[10:18:26.187] resolve() on list ... DONE
[10:18:26.187]    - '...' content: [n=0] 
[10:18:26.187] List of 1
[10:18:26.187]  $ ...: list()
[10:18:26.187]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.187]  - attr(*, "where")=List of 1
[10:18:26.187]   ..$ ...:<environment: 0x556e01edb350> 
[10:18:26.187]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.187]  - attr(*, "resolved")= logi TRUE
[10:18:26.187]  - attr(*, "total_size")= num NA
[10:18:26.190]  - Getting '...' globals ... DONE
[10:18:26.190] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.191] List of 2
[10:18:26.191]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.191]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.191]  $ ...          : list()
[10:18:26.191]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.191]  - attr(*, "where")=List of 2
[10:18:26.191]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.191]   ..$ ...          :<environment: 0x556e01edb350> 
[10:18:26.191]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.191]  - attr(*, "resolved")= logi FALSE
[10:18:26.191]  - attr(*, "total_size")= num 65967
[10:18:26.193] Packages to be attached in all futures: [n=0] 
[10:18:26.193] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.194] future_lapply() ...
[10:18:26.227] Number of chunks: 1
[10:18:26.227] getGlobalsAndPackagesXApply() ...
[10:18:26.227]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.227]  - use_args: TRUE
[10:18:26.228] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.228] List of 2
[10:18:26.228]  $ ...          : list()
[10:18:26.228]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.228]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.228]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.228]  - attr(*, "where")=List of 2
[10:18:26.228]   ..$ ...          :<environment: 0x556e01edb350> 
[10:18:26.228]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:26.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.228]  - attr(*, "resolved")= logi FALSE
[10:18:26.228]  - attr(*, "total_size")= num NA
[10:18:26.231] Packages to be attached in all futures: [n=0] 
[10:18:26.231] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.231] Number of futures (= number of chunks): 1
[10:18:26.232] Launching 1 futures (chunks) ...
[10:18:26.232] Chunk #1 of 1 ...
[10:18:26.232]  - seeds: <none>
[10:18:26.232]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.232] getGlobalsAndPackages() ...
[10:18:26.232] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.232] Resolving globals: FALSE
[10:18:26.232] Tweak future expression to call with '...' arguments ...
[10:18:26.232] {
[10:18:26.232]     do.call(function(...) {
[10:18:26.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.232]             on.exit(options(oopts), add = TRUE)
[10:18:26.232]         }
[10:18:26.232]         {
[10:18:26.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.232]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.232]             })
[10:18:26.232]         }
[10:18:26.232]     }, args = future.call.arguments)
[10:18:26.232] }
[10:18:26.233] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.233] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.233] 
[10:18:26.233] getGlobalsAndPackages() ... DONE
[10:18:26.234] run() for ‘Future’ ...
[10:18:26.234] - state: ‘created’
[10:18:26.234] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.234] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.234]   - Field: ‘label’
[10:18:26.234]   - Field: ‘local’
[10:18:26.234]   - Field: ‘owner’
[10:18:26.235]   - Field: ‘envir’
[10:18:26.235]   - Field: ‘packages’
[10:18:26.235]   - Field: ‘gc’
[10:18:26.235]   - Field: ‘conditions’
[10:18:26.235]   - Field: ‘expr’
[10:18:26.235]   - Field: ‘uuid’
[10:18:26.235]   - Field: ‘seed’
[10:18:26.235]   - Field: ‘version’
[10:18:26.235]   - Field: ‘result’
[10:18:26.235]   - Field: ‘asynchronous’
[10:18:26.235]   - Field: ‘calls’
[10:18:26.235]   - Field: ‘globals’
[10:18:26.236]   - Field: ‘stdout’
[10:18:26.236]   - Field: ‘earlySignal’
[10:18:26.236]   - Field: ‘lazy’
[10:18:26.236]   - Field: ‘state’
[10:18:26.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.236] - Launch lazy future ...
[10:18:26.236] Packages needed by the future expression (n = 0): <none>
[10:18:26.236] Packages needed by future strategies (n = 0): <none>
[10:18:26.237] {
[10:18:26.237]     {
[10:18:26.237]         {
[10:18:26.237]             ...future.startTime <- base::Sys.time()
[10:18:26.237]             {
[10:18:26.237]                 {
[10:18:26.237]                   {
[10:18:26.237]                     base::local({
[10:18:26.237]                       has_future <- base::requireNamespace("future", 
[10:18:26.237]                         quietly = TRUE)
[10:18:26.237]                       if (has_future) {
[10:18:26.237]                         ns <- base::getNamespace("future")
[10:18:26.237]                         version <- ns[[".package"]][["version"]]
[10:18:26.237]                         if (is.null(version)) 
[10:18:26.237]                           version <- utils::packageVersion("future")
[10:18:26.237]                       }
[10:18:26.237]                       else {
[10:18:26.237]                         version <- NULL
[10:18:26.237]                       }
[10:18:26.237]                       if (!has_future || version < "1.8.0") {
[10:18:26.237]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.237]                           "", base::R.version$version.string), 
[10:18:26.237]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:26.237]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.237]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.237]                             "release", "version")], collapse = " "), 
[10:18:26.237]                           hostname = base::Sys.info()[["nodename"]])
[10:18:26.237]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.237]                           info)
[10:18:26.237]                         info <- base::paste(info, collapse = "; ")
[10:18:26.237]                         if (!has_future) {
[10:18:26.237]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.237]                             info)
[10:18:26.237]                         }
[10:18:26.237]                         else {
[10:18:26.237]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.237]                             info, version)
[10:18:26.237]                         }
[10:18:26.237]                         base::stop(msg)
[10:18:26.237]                       }
[10:18:26.237]                     })
[10:18:26.237]                   }
[10:18:26.237]                   ...future.strategy.old <- future::plan("list")
[10:18:26.237]                   options(future.plan = NULL)
[10:18:26.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.237]                 }
[10:18:26.237]                 ...future.workdir <- getwd()
[10:18:26.237]             }
[10:18:26.237]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.237]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.237]         }
[10:18:26.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.237]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.237]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.237]             base::names(...future.oldOptions))
[10:18:26.237]     }
[10:18:26.237]     if (FALSE) {
[10:18:26.237]     }
[10:18:26.237]     else {
[10:18:26.237]         if (TRUE) {
[10:18:26.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.237]                 open = "w")
[10:18:26.237]         }
[10:18:26.237]         else {
[10:18:26.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.237]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.237]         }
[10:18:26.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.237]             base::sink(type = "output", split = FALSE)
[10:18:26.237]             base::close(...future.stdout)
[10:18:26.237]         }, add = TRUE)
[10:18:26.237]     }
[10:18:26.237]     ...future.frame <- base::sys.nframe()
[10:18:26.237]     ...future.conditions <- base::list()
[10:18:26.237]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.237]     if (FALSE) {
[10:18:26.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.237]     }
[10:18:26.237]     ...future.result <- base::tryCatch({
[10:18:26.237]         base::withCallingHandlers({
[10:18:26.237]             ...future.value <- base::withVisible(base::local({
[10:18:26.237]                 do.call(function(...) {
[10:18:26.237]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.237]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.237]                     ...future.globals.maxSize)) {
[10:18:26.237]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.237]                     on.exit(options(oopts), add = TRUE)
[10:18:26.237]                   }
[10:18:26.237]                   {
[10:18:26.237]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.237]                       FUN = function(jj) {
[10:18:26.237]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.237]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.237]                       })
[10:18:26.237]                   }
[10:18:26.237]                 }, args = future.call.arguments)
[10:18:26.237]             }))
[10:18:26.237]             future::FutureResult(value = ...future.value$value, 
[10:18:26.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.237]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.237]                     ...future.globalenv.names))
[10:18:26.237]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.237]         }, condition = base::local({
[10:18:26.237]             c <- base::c
[10:18:26.237]             inherits <- base::inherits
[10:18:26.237]             invokeRestart <- base::invokeRestart
[10:18:26.237]             length <- base::length
[10:18:26.237]             list <- base::list
[10:18:26.237]             seq.int <- base::seq.int
[10:18:26.237]             signalCondition <- base::signalCondition
[10:18:26.237]             sys.calls <- base::sys.calls
[10:18:26.237]             `[[` <- base::`[[`
[10:18:26.237]             `+` <- base::`+`
[10:18:26.237]             `<<-` <- base::`<<-`
[10:18:26.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.237]                   3L)]
[10:18:26.237]             }
[10:18:26.237]             function(cond) {
[10:18:26.237]                 is_error <- inherits(cond, "error")
[10:18:26.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.237]                   NULL)
[10:18:26.237]                 if (is_error) {
[10:18:26.237]                   sessionInformation <- function() {
[10:18:26.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.237]                       search = base::search(), system = base::Sys.info())
[10:18:26.237]                   }
[10:18:26.237]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.237]                     cond$call), session = sessionInformation(), 
[10:18:26.237]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.237]                   signalCondition(cond)
[10:18:26.237]                 }
[10:18:26.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.237]                 "immediateCondition"))) {
[10:18:26.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.237]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.237]                   if (TRUE && !signal) {
[10:18:26.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.237]                     {
[10:18:26.237]                       inherits <- base::inherits
[10:18:26.237]                       invokeRestart <- base::invokeRestart
[10:18:26.237]                       is.null <- base::is.null
[10:18:26.237]                       muffled <- FALSE
[10:18:26.237]                       if (inherits(cond, "message")) {
[10:18:26.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.237]                         if (muffled) 
[10:18:26.237]                           invokeRestart("muffleMessage")
[10:18:26.237]                       }
[10:18:26.237]                       else if (inherits(cond, "warning")) {
[10:18:26.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.237]                         if (muffled) 
[10:18:26.237]                           invokeRestart("muffleWarning")
[10:18:26.237]                       }
[10:18:26.237]                       else if (inherits(cond, "condition")) {
[10:18:26.237]                         if (!is.null(pattern)) {
[10:18:26.237]                           computeRestarts <- base::computeRestarts
[10:18:26.237]                           grepl <- base::grepl
[10:18:26.237]                           restarts <- computeRestarts(cond)
[10:18:26.237]                           for (restart in restarts) {
[10:18:26.237]                             name <- restart$name
[10:18:26.237]                             if (is.null(name)) 
[10:18:26.237]                               next
[10:18:26.237]                             if (!grepl(pattern, name)) 
[10:18:26.237]                               next
[10:18:26.237]                             invokeRestart(restart)
[10:18:26.237]                             muffled <- TRUE
[10:18:26.237]                             break
[10:18:26.237]                           }
[10:18:26.237]                         }
[10:18:26.237]                       }
[10:18:26.237]                       invisible(muffled)
[10:18:26.237]                     }
[10:18:26.237]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.237]                   }
[10:18:26.237]                 }
[10:18:26.237]                 else {
[10:18:26.237]                   if (TRUE) {
[10:18:26.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.237]                     {
[10:18:26.237]                       inherits <- base::inherits
[10:18:26.237]                       invokeRestart <- base::invokeRestart
[10:18:26.237]                       is.null <- base::is.null
[10:18:26.237]                       muffled <- FALSE
[10:18:26.237]                       if (inherits(cond, "message")) {
[10:18:26.237]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.237]                         if (muffled) 
[10:18:26.237]                           invokeRestart("muffleMessage")
[10:18:26.237]                       }
[10:18:26.237]                       else if (inherits(cond, "warning")) {
[10:18:26.237]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.237]                         if (muffled) 
[10:18:26.237]                           invokeRestart("muffleWarning")
[10:18:26.237]                       }
[10:18:26.237]                       else if (inherits(cond, "condition")) {
[10:18:26.237]                         if (!is.null(pattern)) {
[10:18:26.237]                           computeRestarts <- base::computeRestarts
[10:18:26.237]                           grepl <- base::grepl
[10:18:26.237]                           restarts <- computeRestarts(cond)
[10:18:26.237]                           for (restart in restarts) {
[10:18:26.237]                             name <- restart$name
[10:18:26.237]                             if (is.null(name)) 
[10:18:26.237]                               next
[10:18:26.237]                             if (!grepl(pattern, name)) 
[10:18:26.237]                               next
[10:18:26.237]                             invokeRestart(restart)
[10:18:26.237]                             muffled <- TRUE
[10:18:26.237]                             break
[10:18:26.237]                           }
[10:18:26.237]                         }
[10:18:26.237]                       }
[10:18:26.237]                       invisible(muffled)
[10:18:26.237]                     }
[10:18:26.237]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.237]                   }
[10:18:26.237]                 }
[10:18:26.237]             }
[10:18:26.237]         }))
[10:18:26.237]     }, error = function(ex) {
[10:18:26.237]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.237]                 ...future.rng), started = ...future.startTime, 
[10:18:26.237]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.237]             version = "1.8"), class = "FutureResult")
[10:18:26.237]     }, finally = {
[10:18:26.237]         if (!identical(...future.workdir, getwd())) 
[10:18:26.237]             setwd(...future.workdir)
[10:18:26.237]         {
[10:18:26.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.237]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.237]             }
[10:18:26.237]             base::options(...future.oldOptions)
[10:18:26.237]             if (.Platform$OS.type == "windows") {
[10:18:26.237]                 old_names <- names(...future.oldEnvVars)
[10:18:26.237]                 envs <- base::Sys.getenv()
[10:18:26.237]                 names <- names(envs)
[10:18:26.237]                 common <- intersect(names, old_names)
[10:18:26.237]                 added <- setdiff(names, old_names)
[10:18:26.237]                 removed <- setdiff(old_names, names)
[10:18:26.237]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.237]                   envs[common]]
[10:18:26.237]                 NAMES <- toupper(changed)
[10:18:26.237]                 args <- list()
[10:18:26.237]                 for (kk in seq_along(NAMES)) {
[10:18:26.237]                   name <- changed[[kk]]
[10:18:26.237]                   NAME <- NAMES[[kk]]
[10:18:26.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.237]                     next
[10:18:26.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.237]                 }
[10:18:26.237]                 NAMES <- toupper(added)
[10:18:26.237]                 for (kk in seq_along(NAMES)) {
[10:18:26.237]                   name <- added[[kk]]
[10:18:26.237]                   NAME <- NAMES[[kk]]
[10:18:26.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.237]                     next
[10:18:26.237]                   args[[name]] <- ""
[10:18:26.237]                 }
[10:18:26.237]                 NAMES <- toupper(removed)
[10:18:26.237]                 for (kk in seq_along(NAMES)) {
[10:18:26.237]                   name <- removed[[kk]]
[10:18:26.237]                   NAME <- NAMES[[kk]]
[10:18:26.237]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.237]                     next
[10:18:26.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.237]                 }
[10:18:26.237]                 if (length(args) > 0) 
[10:18:26.237]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.237]             }
[10:18:26.237]             else {
[10:18:26.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.237]             }
[10:18:26.237]             {
[10:18:26.237]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.237]                   0L) {
[10:18:26.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.237]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.237]                   base::options(opts)
[10:18:26.237]                 }
[10:18:26.237]                 {
[10:18:26.237]                   {
[10:18:26.237]                     NULL
[10:18:26.237]                     RNGkind("Mersenne-Twister")
[10:18:26.237]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:26.237]                       inherits = FALSE)
[10:18:26.237]                   }
[10:18:26.237]                   options(future.plan = NULL)
[10:18:26.237]                   if (is.na(NA_character_)) 
[10:18:26.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.237]                     .init = FALSE)
[10:18:26.237]                 }
[10:18:26.237]             }
[10:18:26.237]         }
[10:18:26.237]     })
[10:18:26.237]     if (TRUE) {
[10:18:26.237]         base::sink(type = "output", split = FALSE)
[10:18:26.237]         if (TRUE) {
[10:18:26.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.237]         }
[10:18:26.237]         else {
[10:18:26.237]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.237]         }
[10:18:26.237]         base::close(...future.stdout)
[10:18:26.237]         ...future.stdout <- NULL
[10:18:26.237]     }
[10:18:26.237]     ...future.result$conditions <- ...future.conditions
[10:18:26.237]     ...future.result$finished <- base::Sys.time()
[10:18:26.237]     ...future.result
[10:18:26.237] }
[10:18:26.238] assign_globals() ...
[10:18:26.239] List of 5
[10:18:26.239]  $ future.call.arguments    : list()
[10:18:26.239]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.239]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.239]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.239]  $ ...future.elements_ii    :List of 2
[10:18:26.239]   ..$ : num [1:4] 1 3 1 7
[10:18:26.239]   ..$ : num [1:4] 2 4 6 8
[10:18:26.239]  $ ...future.seeds_ii       : NULL
[10:18:26.239]  $ ...future.globals.maxSize: num Inf
[10:18:26.239]  - attr(*, "resolved")= logi FALSE
[10:18:26.239]  - attr(*, "total_size")= num NA
[10:18:26.239]  - attr(*, "where")=List of 5
[10:18:26.239]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.239]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.239]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.239]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.239]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.239]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.239]  - attr(*, "already-done")= logi TRUE
[10:18:26.244] - copied ‘future.call.arguments’ to environment
[10:18:26.244] - copied ‘...future.FUN’ to environment
[10:18:26.244] - copied ‘...future.elements_ii’ to environment
[10:18:26.244] - copied ‘...future.seeds_ii’ to environment
[10:18:26.244] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.244] assign_globals() ... done
[10:18:26.244] plan(): Setting new future strategy stack:
[10:18:26.244] List of future strategies:
[10:18:26.244] 1. sequential:
[10:18:26.244]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.244]    - tweaked: FALSE
[10:18:26.244]    - call: NULL
[10:18:26.245] plan(): nbrOfWorkers() = 1
[10:18:26.246] plan(): Setting new future strategy stack:
[10:18:26.246] List of future strategies:
[10:18:26.246] 1. sequential:
[10:18:26.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.246]    - tweaked: FALSE
[10:18:26.246]    - call: plan(strategy)
[10:18:26.246] plan(): nbrOfWorkers() = 1
[10:18:26.247] SequentialFuture started (and completed)
[10:18:26.247] - Launch lazy future ... done
[10:18:26.247] run() for ‘SequentialFuture’ ... done
[10:18:26.247] Created future:
[10:18:26.247] SequentialFuture:
[10:18:26.247] Label: ‘future_apply-1’
[10:18:26.247] Expression:
[10:18:26.247] {
[10:18:26.247]     do.call(function(...) {
[10:18:26.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.247]             on.exit(options(oopts), add = TRUE)
[10:18:26.247]         }
[10:18:26.247]         {
[10:18:26.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.247]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.247]             })
[10:18:26.247]         }
[10:18:26.247]     }, args = future.call.arguments)
[10:18:26.247] }
[10:18:26.247] Lazy evaluation: FALSE
[10:18:26.247] Asynchronous evaluation: FALSE
[10:18:26.247] Local evaluation: TRUE
[10:18:26.247] Environment: R_GlobalEnv
[10:18:26.247] Capture standard output: TRUE
[10:18:26.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.247] Globals: 5 objects totaling 31.56 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 111 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.247] Packages: <none>
[10:18:26.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.247] Resolved: TRUE
[10:18:26.247] Value: 429 bytes of class ‘list’
[10:18:26.247] Early signaling: FALSE
[10:18:26.247] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.247] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.248] Chunk #1 of 1 ... DONE
[10:18:26.248] Launching 1 futures (chunks) ... DONE
[10:18:26.248] Resolving 1 futures (chunks) ...
[10:18:26.248] resolve() on list ...
[10:18:26.249]  recursive: 0
[10:18:26.249]  length: 1
[10:18:26.249] 
[10:18:26.249] resolved() for ‘SequentialFuture’ ...
[10:18:26.249] - state: ‘finished’
[10:18:26.249] - run: TRUE
[10:18:26.249] - result: ‘FutureResult’
[10:18:26.249] resolved() for ‘SequentialFuture’ ... done
[10:18:26.249] Future #1
[10:18:26.249] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.249] - nx: 1
[10:18:26.250] - relay: TRUE
[10:18:26.251] - stdout: TRUE
[10:18:26.251] - signal: TRUE
[10:18:26.251] - resignal: FALSE
[10:18:26.251] - force: TRUE
[10:18:26.251] - relayed: [n=1] FALSE
[10:18:26.251] - queued futures: [n=1] FALSE
[10:18:26.252]  - until=1
[10:18:26.252]  - relaying element #1
[10:18:26.252] - relayed: [n=1] TRUE
[10:18:26.252] - queued futures: [n=1] TRUE
[10:18:26.252] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.252]  length: 0 (resolved future 1)
[10:18:26.252] Relaying remaining futures
[10:18:26.252] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.252] - nx: 1
[10:18:26.252] - relay: TRUE
[10:18:26.253] - stdout: TRUE
[10:18:26.253] - signal: TRUE
[10:18:26.253] - resignal: FALSE
[10:18:26.253] - force: TRUE
[10:18:26.253] - relayed: [n=1] TRUE
[10:18:26.253] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.253] - relayed: [n=1] TRUE
[10:18:26.253] - queued futures: [n=1] TRUE
[10:18:26.253] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.253] resolve() on list ... DONE
[10:18:26.253]  - Number of value chunks collected: 1
[10:18:26.254] Resolving 1 futures (chunks) ... DONE
[10:18:26.254] Reducing values from 1 chunks ...
[10:18:26.254]  - Number of values collected after concatenation: 2
[10:18:26.254]  - Number of values expected: 2
[10:18:26.254] Reducing values from 1 chunks ... DONE
[10:18:26.254] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:18:26.256] getGlobalsAndPackagesXApply() ...
[10:18:26.256]  - future.globals: TRUE
[10:18:26.256] getGlobalsAndPackages() ...
[10:18:26.256] Searching for globals...
[10:18:26.257] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:26.257] Searching for globals ... DONE
[10:18:26.257] Resolving globals: FALSE
[10:18:26.258] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:26.258] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:26.258] - globals: [1] ‘FUN’
[10:18:26.258] - packages: [1] ‘stats’
[10:18:26.258] getGlobalsAndPackages() ... DONE
[10:18:26.259]  - globals found/used: [n=1] ‘FUN’
[10:18:26.259]  - needed namespaces: [n=1] ‘stats’
[10:18:26.259] Finding globals ... DONE
[10:18:26.259]  - use_args: TRUE
[10:18:26.259]  - Getting '...' globals ...
[10:18:26.259] resolve() on list ...
[10:18:26.259]  recursive: 0
[10:18:26.259]  length: 1
[10:18:26.259]  elements: ‘...’
[10:18:26.260]  length: 0 (resolved future 1)
[10:18:26.260] resolve() on list ... DONE
[10:18:26.260]    - '...' content: [n=0] 
[10:18:26.260] List of 1
[10:18:26.260]  $ ...: list()
[10:18:26.260]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.260]  - attr(*, "where")=List of 1
[10:18:26.260]   ..$ ...:<environment: 0x556e0162c2f0> 
[10:18:26.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.260]  - attr(*, "resolved")= logi TRUE
[10:18:26.260]  - attr(*, "total_size")= num NA
[10:18:26.262]  - Getting '...' globals ... DONE
[10:18:26.262] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.262] List of 2
[10:18:26.262]  $ ...future.FUN:function (x, ...)  
[10:18:26.262]  $ ...          : list()
[10:18:26.262]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.262]  - attr(*, "where")=List of 2
[10:18:26.262]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.262]   ..$ ...          :<environment: 0x556e0162c2f0> 
[10:18:26.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.262]  - attr(*, "resolved")= logi FALSE
[10:18:26.262]  - attr(*, "total_size")= num 2586
[10:18:26.265] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:26.265] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.265] future_lapply() ...
[10:18:26.266] Number of chunks: 1
[10:18:26.266] getGlobalsAndPackagesXApply() ...
[10:18:26.266]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.266]  - use_args: TRUE
[10:18:26.266] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.266] List of 2
[10:18:26.266]  $ ...          : list()
[10:18:26.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.266]  $ ...future.FUN:function (x, ...)  
[10:18:26.266]  - attr(*, "where")=List of 2
[10:18:26.266]   ..$ ...          :<environment: 0x556e0162c2f0> 
[10:18:26.266]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:18:26.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.266]  - attr(*, "resolved")= logi FALSE
[10:18:26.266]  - attr(*, "total_size")= num NA
[10:18:26.269] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:26.269] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.269] Number of futures (= number of chunks): 1
[10:18:26.269] Launching 1 futures (chunks) ...
[10:18:26.269] Chunk #1 of 1 ...
[10:18:26.270]  - seeds: <none>
[10:18:26.270]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.270] getGlobalsAndPackages() ...
[10:18:26.270] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.270] Resolving globals: FALSE
[10:18:26.270] Tweak future expression to call with '...' arguments ...
[10:18:26.270] {
[10:18:26.270]     do.call(function(...) {
[10:18:26.270]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.270]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.270]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.270]             on.exit(options(oopts), add = TRUE)
[10:18:26.270]         }
[10:18:26.270]         {
[10:18:26.270]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.270]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.270]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.270]             })
[10:18:26.270]         }
[10:18:26.270]     }, args = future.call.arguments)
[10:18:26.270] }
[10:18:26.270] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.271] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.271] - packages: [1] ‘stats’
[10:18:26.271] getGlobalsAndPackages() ... DONE
[10:18:26.271] run() for ‘Future’ ...
[10:18:26.271] - state: ‘created’
[10:18:26.271] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.272] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.272] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.272]   - Field: ‘label’
[10:18:26.272]   - Field: ‘local’
[10:18:26.272]   - Field: ‘owner’
[10:18:26.272]   - Field: ‘envir’
[10:18:26.272]   - Field: ‘packages’
[10:18:26.272]   - Field: ‘gc’
[10:18:26.272]   - Field: ‘conditions’
[10:18:26.273]   - Field: ‘expr’
[10:18:26.273]   - Field: ‘uuid’
[10:18:26.273]   - Field: ‘seed’
[10:18:26.273]   - Field: ‘version’
[10:18:26.273]   - Field: ‘result’
[10:18:26.274]   - Field: ‘asynchronous’
[10:18:26.274]   - Field: ‘calls’
[10:18:26.275]   - Field: ‘globals’
[10:18:26.275]   - Field: ‘stdout’
[10:18:26.275]   - Field: ‘earlySignal’
[10:18:26.275]   - Field: ‘lazy’
[10:18:26.275]   - Field: ‘state’
[10:18:26.275] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.275] - Launch lazy future ...
[10:18:26.275] Packages needed by the future expression (n = 1): ‘stats’
[10:18:26.275] Packages needed by future strategies (n = 0): <none>
[10:18:26.276] {
[10:18:26.276]     {
[10:18:26.276]         {
[10:18:26.276]             ...future.startTime <- base::Sys.time()
[10:18:26.276]             {
[10:18:26.276]                 {
[10:18:26.276]                   {
[10:18:26.276]                     {
[10:18:26.276]                       base::local({
[10:18:26.276]                         has_future <- base::requireNamespace("future", 
[10:18:26.276]                           quietly = TRUE)
[10:18:26.276]                         if (has_future) {
[10:18:26.276]                           ns <- base::getNamespace("future")
[10:18:26.276]                           version <- ns[[".package"]][["version"]]
[10:18:26.276]                           if (is.null(version)) 
[10:18:26.276]                             version <- utils::packageVersion("future")
[10:18:26.276]                         }
[10:18:26.276]                         else {
[10:18:26.276]                           version <- NULL
[10:18:26.276]                         }
[10:18:26.276]                         if (!has_future || version < "1.8.0") {
[10:18:26.276]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.276]                             "", base::R.version$version.string), 
[10:18:26.276]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:26.276]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.276]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.276]                               "release", "version")], collapse = " "), 
[10:18:26.276]                             hostname = base::Sys.info()[["nodename"]])
[10:18:26.276]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.276]                             info)
[10:18:26.276]                           info <- base::paste(info, collapse = "; ")
[10:18:26.276]                           if (!has_future) {
[10:18:26.276]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.276]                               info)
[10:18:26.276]                           }
[10:18:26.276]                           else {
[10:18:26.276]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.276]                               info, version)
[10:18:26.276]                           }
[10:18:26.276]                           base::stop(msg)
[10:18:26.276]                         }
[10:18:26.276]                       })
[10:18:26.276]                     }
[10:18:26.276]                     base::local({
[10:18:26.276]                       for (pkg in "stats") {
[10:18:26.276]                         base::loadNamespace(pkg)
[10:18:26.276]                         base::library(pkg, character.only = TRUE)
[10:18:26.276]                       }
[10:18:26.276]                     })
[10:18:26.276]                   }
[10:18:26.276]                   ...future.strategy.old <- future::plan("list")
[10:18:26.276]                   options(future.plan = NULL)
[10:18:26.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.276]                 }
[10:18:26.276]                 ...future.workdir <- getwd()
[10:18:26.276]             }
[10:18:26.276]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.276]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.276]         }
[10:18:26.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.276]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.276]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.276]             base::names(...future.oldOptions))
[10:18:26.276]     }
[10:18:26.276]     if (FALSE) {
[10:18:26.276]     }
[10:18:26.276]     else {
[10:18:26.276]         if (TRUE) {
[10:18:26.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.276]                 open = "w")
[10:18:26.276]         }
[10:18:26.276]         else {
[10:18:26.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.276]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.276]         }
[10:18:26.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.276]             base::sink(type = "output", split = FALSE)
[10:18:26.276]             base::close(...future.stdout)
[10:18:26.276]         }, add = TRUE)
[10:18:26.276]     }
[10:18:26.276]     ...future.frame <- base::sys.nframe()
[10:18:26.276]     ...future.conditions <- base::list()
[10:18:26.276]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.276]     if (FALSE) {
[10:18:26.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.276]     }
[10:18:26.276]     ...future.result <- base::tryCatch({
[10:18:26.276]         base::withCallingHandlers({
[10:18:26.276]             ...future.value <- base::withVisible(base::local({
[10:18:26.276]                 do.call(function(...) {
[10:18:26.276]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.276]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.276]                     ...future.globals.maxSize)) {
[10:18:26.276]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.276]                     on.exit(options(oopts), add = TRUE)
[10:18:26.276]                   }
[10:18:26.276]                   {
[10:18:26.276]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.276]                       FUN = function(jj) {
[10:18:26.276]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.276]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.276]                       })
[10:18:26.276]                   }
[10:18:26.276]                 }, args = future.call.arguments)
[10:18:26.276]             }))
[10:18:26.276]             future::FutureResult(value = ...future.value$value, 
[10:18:26.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.276]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.276]                     ...future.globalenv.names))
[10:18:26.276]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.276]         }, condition = base::local({
[10:18:26.276]             c <- base::c
[10:18:26.276]             inherits <- base::inherits
[10:18:26.276]             invokeRestart <- base::invokeRestart
[10:18:26.276]             length <- base::length
[10:18:26.276]             list <- base::list
[10:18:26.276]             seq.int <- base::seq.int
[10:18:26.276]             signalCondition <- base::signalCondition
[10:18:26.276]             sys.calls <- base::sys.calls
[10:18:26.276]             `[[` <- base::`[[`
[10:18:26.276]             `+` <- base::`+`
[10:18:26.276]             `<<-` <- base::`<<-`
[10:18:26.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.276]                   3L)]
[10:18:26.276]             }
[10:18:26.276]             function(cond) {
[10:18:26.276]                 is_error <- inherits(cond, "error")
[10:18:26.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.276]                   NULL)
[10:18:26.276]                 if (is_error) {
[10:18:26.276]                   sessionInformation <- function() {
[10:18:26.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.276]                       search = base::search(), system = base::Sys.info())
[10:18:26.276]                   }
[10:18:26.276]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.276]                     cond$call), session = sessionInformation(), 
[10:18:26.276]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.276]                   signalCondition(cond)
[10:18:26.276]                 }
[10:18:26.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.276]                 "immediateCondition"))) {
[10:18:26.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.276]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.276]                   if (TRUE && !signal) {
[10:18:26.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.276]                     {
[10:18:26.276]                       inherits <- base::inherits
[10:18:26.276]                       invokeRestart <- base::invokeRestart
[10:18:26.276]                       is.null <- base::is.null
[10:18:26.276]                       muffled <- FALSE
[10:18:26.276]                       if (inherits(cond, "message")) {
[10:18:26.276]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.276]                         if (muffled) 
[10:18:26.276]                           invokeRestart("muffleMessage")
[10:18:26.276]                       }
[10:18:26.276]                       else if (inherits(cond, "warning")) {
[10:18:26.276]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.276]                         if (muffled) 
[10:18:26.276]                           invokeRestart("muffleWarning")
[10:18:26.276]                       }
[10:18:26.276]                       else if (inherits(cond, "condition")) {
[10:18:26.276]                         if (!is.null(pattern)) {
[10:18:26.276]                           computeRestarts <- base::computeRestarts
[10:18:26.276]                           grepl <- base::grepl
[10:18:26.276]                           restarts <- computeRestarts(cond)
[10:18:26.276]                           for (restart in restarts) {
[10:18:26.276]                             name <- restart$name
[10:18:26.276]                             if (is.null(name)) 
[10:18:26.276]                               next
[10:18:26.276]                             if (!grepl(pattern, name)) 
[10:18:26.276]                               next
[10:18:26.276]                             invokeRestart(restart)
[10:18:26.276]                             muffled <- TRUE
[10:18:26.276]                             break
[10:18:26.276]                           }
[10:18:26.276]                         }
[10:18:26.276]                       }
[10:18:26.276]                       invisible(muffled)
[10:18:26.276]                     }
[10:18:26.276]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.276]                   }
[10:18:26.276]                 }
[10:18:26.276]                 else {
[10:18:26.276]                   if (TRUE) {
[10:18:26.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.276]                     {
[10:18:26.276]                       inherits <- base::inherits
[10:18:26.276]                       invokeRestart <- base::invokeRestart
[10:18:26.276]                       is.null <- base::is.null
[10:18:26.276]                       muffled <- FALSE
[10:18:26.276]                       if (inherits(cond, "message")) {
[10:18:26.276]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.276]                         if (muffled) 
[10:18:26.276]                           invokeRestart("muffleMessage")
[10:18:26.276]                       }
[10:18:26.276]                       else if (inherits(cond, "warning")) {
[10:18:26.276]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.276]                         if (muffled) 
[10:18:26.276]                           invokeRestart("muffleWarning")
[10:18:26.276]                       }
[10:18:26.276]                       else if (inherits(cond, "condition")) {
[10:18:26.276]                         if (!is.null(pattern)) {
[10:18:26.276]                           computeRestarts <- base::computeRestarts
[10:18:26.276]                           grepl <- base::grepl
[10:18:26.276]                           restarts <- computeRestarts(cond)
[10:18:26.276]                           for (restart in restarts) {
[10:18:26.276]                             name <- restart$name
[10:18:26.276]                             if (is.null(name)) 
[10:18:26.276]                               next
[10:18:26.276]                             if (!grepl(pattern, name)) 
[10:18:26.276]                               next
[10:18:26.276]                             invokeRestart(restart)
[10:18:26.276]                             muffled <- TRUE
[10:18:26.276]                             break
[10:18:26.276]                           }
[10:18:26.276]                         }
[10:18:26.276]                       }
[10:18:26.276]                       invisible(muffled)
[10:18:26.276]                     }
[10:18:26.276]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.276]                   }
[10:18:26.276]                 }
[10:18:26.276]             }
[10:18:26.276]         }))
[10:18:26.276]     }, error = function(ex) {
[10:18:26.276]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.276]                 ...future.rng), started = ...future.startTime, 
[10:18:26.276]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.276]             version = "1.8"), class = "FutureResult")
[10:18:26.276]     }, finally = {
[10:18:26.276]         if (!identical(...future.workdir, getwd())) 
[10:18:26.276]             setwd(...future.workdir)
[10:18:26.276]         {
[10:18:26.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.276]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.276]             }
[10:18:26.276]             base::options(...future.oldOptions)
[10:18:26.276]             if (.Platform$OS.type == "windows") {
[10:18:26.276]                 old_names <- names(...future.oldEnvVars)
[10:18:26.276]                 envs <- base::Sys.getenv()
[10:18:26.276]                 names <- names(envs)
[10:18:26.276]                 common <- intersect(names, old_names)
[10:18:26.276]                 added <- setdiff(names, old_names)
[10:18:26.276]                 removed <- setdiff(old_names, names)
[10:18:26.276]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.276]                   envs[common]]
[10:18:26.276]                 NAMES <- toupper(changed)
[10:18:26.276]                 args <- list()
[10:18:26.276]                 for (kk in seq_along(NAMES)) {
[10:18:26.276]                   name <- changed[[kk]]
[10:18:26.276]                   NAME <- NAMES[[kk]]
[10:18:26.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.276]                     next
[10:18:26.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.276]                 }
[10:18:26.276]                 NAMES <- toupper(added)
[10:18:26.276]                 for (kk in seq_along(NAMES)) {
[10:18:26.276]                   name <- added[[kk]]
[10:18:26.276]                   NAME <- NAMES[[kk]]
[10:18:26.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.276]                     next
[10:18:26.276]                   args[[name]] <- ""
[10:18:26.276]                 }
[10:18:26.276]                 NAMES <- toupper(removed)
[10:18:26.276]                 for (kk in seq_along(NAMES)) {
[10:18:26.276]                   name <- removed[[kk]]
[10:18:26.276]                   NAME <- NAMES[[kk]]
[10:18:26.276]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.276]                     next
[10:18:26.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.276]                 }
[10:18:26.276]                 if (length(args) > 0) 
[10:18:26.276]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.276]             }
[10:18:26.276]             else {
[10:18:26.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.276]             }
[10:18:26.276]             {
[10:18:26.276]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.276]                   0L) {
[10:18:26.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.276]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.276]                   base::options(opts)
[10:18:26.276]                 }
[10:18:26.276]                 {
[10:18:26.276]                   {
[10:18:26.276]                     NULL
[10:18:26.276]                     RNGkind("Mersenne-Twister")
[10:18:26.276]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:26.276]                       inherits = FALSE)
[10:18:26.276]                   }
[10:18:26.276]                   options(future.plan = NULL)
[10:18:26.276]                   if (is.na(NA_character_)) 
[10:18:26.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.276]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.276]                     .init = FALSE)
[10:18:26.276]                 }
[10:18:26.276]             }
[10:18:26.276]         }
[10:18:26.276]     })
[10:18:26.276]     if (TRUE) {
[10:18:26.276]         base::sink(type = "output", split = FALSE)
[10:18:26.276]         if (TRUE) {
[10:18:26.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.276]         }
[10:18:26.276]         else {
[10:18:26.276]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.276]         }
[10:18:26.276]         base::close(...future.stdout)
[10:18:26.276]         ...future.stdout <- NULL
[10:18:26.276]     }
[10:18:26.276]     ...future.result$conditions <- ...future.conditions
[10:18:26.276]     ...future.result$finished <- base::Sys.time()
[10:18:26.276]     ...future.result
[10:18:26.276] }
[10:18:26.278] assign_globals() ...
[10:18:26.278] List of 5
[10:18:26.278]  $ future.call.arguments    : list()
[10:18:26.278]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.278]  $ ...future.FUN            :function (x, ...)  
[10:18:26.278]  $ ...future.elements_ii    :List of 2
[10:18:26.278]   ..$ : num [1:4] 1 3 1 7
[10:18:26.278]   ..$ : num [1:4] 2 4 6 8
[10:18:26.278]  $ ...future.seeds_ii       : NULL
[10:18:26.278]  $ ...future.globals.maxSize: num Inf
[10:18:26.278]  - attr(*, "resolved")= logi FALSE
[10:18:26.278]  - attr(*, "total_size")= num NA
[10:18:26.278]  - attr(*, "where")=List of 5
[10:18:26.278]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.278]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.278]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.278]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.278]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.278]  - attr(*, "already-done")= logi TRUE
[10:18:26.283] - copied ‘future.call.arguments’ to environment
[10:18:26.283] - copied ‘...future.FUN’ to environment
[10:18:26.283] - copied ‘...future.elements_ii’ to environment
[10:18:26.283] - copied ‘...future.seeds_ii’ to environment
[10:18:26.283] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.283] assign_globals() ... done
[10:18:26.283] plan(): Setting new future strategy stack:
[10:18:26.283] List of future strategies:
[10:18:26.283] 1. sequential:
[10:18:26.283]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.283]    - tweaked: FALSE
[10:18:26.283]    - call: NULL
[10:18:26.284] plan(): nbrOfWorkers() = 1
[10:18:26.285] plan(): Setting new future strategy stack:
[10:18:26.285] List of future strategies:
[10:18:26.285] 1. sequential:
[10:18:26.285]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.285]    - tweaked: FALSE
[10:18:26.285]    - call: plan(strategy)
[10:18:26.285] plan(): nbrOfWorkers() = 1
[10:18:26.286] SequentialFuture started (and completed)
[10:18:26.286] - Launch lazy future ... done
[10:18:26.286] run() for ‘SequentialFuture’ ... done
[10:18:26.286] Created future:
[10:18:26.286] SequentialFuture:
[10:18:26.286] Label: ‘future_apply-1’
[10:18:26.286] Expression:
[10:18:26.286] {
[10:18:26.286]     do.call(function(...) {
[10:18:26.286]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.286]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.286]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.286]             on.exit(options(oopts), add = TRUE)
[10:18:26.286]         }
[10:18:26.286]         {
[10:18:26.286]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.286]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.286]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.286]             })
[10:18:26.286]         }
[10:18:26.286]     }, args = future.call.arguments)
[10:18:26.286] }
[10:18:26.286] Lazy evaluation: FALSE
[10:18:26.286] Asynchronous evaluation: FALSE
[10:18:26.286] Local evaluation: TRUE
[10:18:26.286] Environment: R_GlobalEnv
[10:18:26.286] Capture standard output: TRUE
[10:18:26.286] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.286] Globals: 5 objects totaling 585 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 111 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.286] Packages: 1 packages (‘stats’)
[10:18:26.286] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.286] Resolved: TRUE
[10:18:26.286] Value: 290 bytes of class ‘list’
[10:18:26.286] Early signaling: FALSE
[10:18:26.286] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.286] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.287] Chunk #1 of 1 ... DONE
[10:18:26.287] Launching 1 futures (chunks) ... DONE
[10:18:26.287] Resolving 1 futures (chunks) ...
[10:18:26.287] resolve() on list ...
[10:18:26.287]  recursive: 0
[10:18:26.287]  length: 1
[10:18:26.287] 
[10:18:26.287] resolved() for ‘SequentialFuture’ ...
[10:18:26.288] - state: ‘finished’
[10:18:26.288] - run: TRUE
[10:18:26.288] - result: ‘FutureResult’
[10:18:26.288] resolved() for ‘SequentialFuture’ ... done
[10:18:26.288] Future #1
[10:18:26.288] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.288] - nx: 1
[10:18:26.288] - relay: TRUE
[10:18:26.288] - stdout: TRUE
[10:18:26.288] - signal: TRUE
[10:18:26.288] - resignal: FALSE
[10:18:26.288] - force: TRUE
[10:18:26.289] - relayed: [n=1] FALSE
[10:18:26.289] - queued futures: [n=1] FALSE
[10:18:26.289]  - until=1
[10:18:26.289]  - relaying element #1
[10:18:26.289] - relayed: [n=1] TRUE
[10:18:26.289] - queued futures: [n=1] TRUE
[10:18:26.289] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.289]  length: 0 (resolved future 1)
[10:18:26.289] Relaying remaining futures
[10:18:26.289] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.289] - nx: 1
[10:18:26.290] - relay: TRUE
[10:18:26.290] - stdout: TRUE
[10:18:26.290] - signal: TRUE
[10:18:26.290] - resignal: FALSE
[10:18:26.290] - force: TRUE
[10:18:26.290] - relayed: [n=1] TRUE
[10:18:26.290] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.290] - relayed: [n=1] TRUE
[10:18:26.290] - queued futures: [n=1] TRUE
[10:18:26.290] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.290] resolve() on list ... DONE
[10:18:26.291]  - Number of value chunks collected: 1
[10:18:26.291] Resolving 1 futures (chunks) ... DONE
[10:18:26.291] Reducing values from 1 chunks ...
[10:18:26.291]  - Number of values collected after concatenation: 2
[10:18:26.291]  - Number of values expected: 2
[10:18:26.291] Reducing values from 1 chunks ... DONE
[10:18:26.291] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:18:26.292] getGlobalsAndPackagesXApply() ...
[10:18:26.292]  - future.globals: TRUE
[10:18:26.292] getGlobalsAndPackages() ...
[10:18:26.292] Searching for globals...
[10:18:26.293] - globals found: [1] ‘FUN’
[10:18:26.293] Searching for globals ... DONE
[10:18:26.293] Resolving globals: FALSE
[10:18:26.293] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:26.294] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:26.294] - globals: [1] ‘FUN’
[10:18:26.294] 
[10:18:26.294] getGlobalsAndPackages() ... DONE
[10:18:26.294]  - globals found/used: [n=1] ‘FUN’
[10:18:26.294]  - needed namespaces: [n=0] 
[10:18:26.294] Finding globals ... DONE
[10:18:26.294]  - use_args: TRUE
[10:18:26.294]  - Getting '...' globals ...
[10:18:26.295] resolve() on list ...
[10:18:26.295]  recursive: 0
[10:18:26.295]  length: 1
[10:18:26.295]  elements: ‘...’
[10:18:26.295]  length: 0 (resolved future 1)
[10:18:26.295] resolve() on list ... DONE
[10:18:26.295]    - '...' content: [n=0] 
[10:18:26.295] List of 1
[10:18:26.295]  $ ...: list()
[10:18:26.295]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.295]  - attr(*, "where")=List of 1
[10:18:26.295]   ..$ ...:<environment: 0x556e03b41db0> 
[10:18:26.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.295]  - attr(*, "resolved")= logi TRUE
[10:18:26.295]  - attr(*, "total_size")= num NA
[10:18:26.299]  - Getting '...' globals ... DONE
[10:18:26.299] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.299] List of 2
[10:18:26.299]  $ ...future.FUN:function (x)  
[10:18:26.299]  $ ...          : list()
[10:18:26.299]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.299]  - attr(*, "where")=List of 2
[10:18:26.299]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.299]   ..$ ...          :<environment: 0x556e03b41db0> 
[10:18:26.299]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.299]  - attr(*, "resolved")= logi FALSE
[10:18:26.299]  - attr(*, "total_size")= num 2624
[10:18:26.302] Packages to be attached in all futures: [n=0] 
[10:18:26.302] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.302] future_lapply() ...
[10:18:26.303] Number of chunks: 1
[10:18:26.303] getGlobalsAndPackagesXApply() ...
[10:18:26.303]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.303]  - use_args: TRUE
[10:18:26.303] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.303] List of 2
[10:18:26.303]  $ ...          : list()
[10:18:26.303]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.303]  $ ...future.FUN:function (x)  
[10:18:26.303]  - attr(*, "where")=List of 2
[10:18:26.303]   ..$ ...          :<environment: 0x556e03b41db0> 
[10:18:26.303]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:26.303]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.303]  - attr(*, "resolved")= logi FALSE
[10:18:26.303]  - attr(*, "total_size")= num NA
[10:18:26.306] Packages to be attached in all futures: [n=0] 
[10:18:26.306] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.307] Number of futures (= number of chunks): 1
[10:18:26.307] Launching 1 futures (chunks) ...
[10:18:26.307] Chunk #1 of 1 ...
[10:18:26.307]  - seeds: <none>
[10:18:26.307]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.307] getGlobalsAndPackages() ...
[10:18:26.307] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.307] Resolving globals: FALSE
[10:18:26.307] Tweak future expression to call with '...' arguments ...
[10:18:26.308] {
[10:18:26.308]     do.call(function(...) {
[10:18:26.308]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.308]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.308]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.308]             on.exit(options(oopts), add = TRUE)
[10:18:26.308]         }
[10:18:26.308]         {
[10:18:26.308]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.308]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.308]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.308]             })
[10:18:26.308]         }
[10:18:26.308]     }, args = future.call.arguments)
[10:18:26.308] }
[10:18:26.308] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.308] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.308] 
[10:18:26.308] getGlobalsAndPackages() ... DONE
[10:18:26.309] run() for ‘Future’ ...
[10:18:26.309] - state: ‘created’
[10:18:26.309] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.309] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.309] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.309]   - Field: ‘label’
[10:18:26.309]   - Field: ‘local’
[10:18:26.310]   - Field: ‘owner’
[10:18:26.310]   - Field: ‘envir’
[10:18:26.310]   - Field: ‘packages’
[10:18:26.310]   - Field: ‘gc’
[10:18:26.310]   - Field: ‘conditions’
[10:18:26.310]   - Field: ‘expr’
[10:18:26.310]   - Field: ‘uuid’
[10:18:26.310]   - Field: ‘seed’
[10:18:26.310]   - Field: ‘version’
[10:18:26.310]   - Field: ‘result’
[10:18:26.310]   - Field: ‘asynchronous’
[10:18:26.310]   - Field: ‘calls’
[10:18:26.311]   - Field: ‘globals’
[10:18:26.311]   - Field: ‘stdout’
[10:18:26.311]   - Field: ‘earlySignal’
[10:18:26.311]   - Field: ‘lazy’
[10:18:26.311]   - Field: ‘state’
[10:18:26.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.311] - Launch lazy future ...
[10:18:26.311] Packages needed by the future expression (n = 0): <none>
[10:18:26.311] Packages needed by future strategies (n = 0): <none>
[10:18:26.312] {
[10:18:26.312]     {
[10:18:26.312]         {
[10:18:26.312]             ...future.startTime <- base::Sys.time()
[10:18:26.312]             {
[10:18:26.312]                 {
[10:18:26.312]                   {
[10:18:26.312]                     base::local({
[10:18:26.312]                       has_future <- base::requireNamespace("future", 
[10:18:26.312]                         quietly = TRUE)
[10:18:26.312]                       if (has_future) {
[10:18:26.312]                         ns <- base::getNamespace("future")
[10:18:26.312]                         version <- ns[[".package"]][["version"]]
[10:18:26.312]                         if (is.null(version)) 
[10:18:26.312]                           version <- utils::packageVersion("future")
[10:18:26.312]                       }
[10:18:26.312]                       else {
[10:18:26.312]                         version <- NULL
[10:18:26.312]                       }
[10:18:26.312]                       if (!has_future || version < "1.8.0") {
[10:18:26.312]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.312]                           "", base::R.version$version.string), 
[10:18:26.312]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:26.312]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.312]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.312]                             "release", "version")], collapse = " "), 
[10:18:26.312]                           hostname = base::Sys.info()[["nodename"]])
[10:18:26.312]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.312]                           info)
[10:18:26.312]                         info <- base::paste(info, collapse = "; ")
[10:18:26.312]                         if (!has_future) {
[10:18:26.312]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.312]                             info)
[10:18:26.312]                         }
[10:18:26.312]                         else {
[10:18:26.312]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.312]                             info, version)
[10:18:26.312]                         }
[10:18:26.312]                         base::stop(msg)
[10:18:26.312]                       }
[10:18:26.312]                     })
[10:18:26.312]                   }
[10:18:26.312]                   ...future.strategy.old <- future::plan("list")
[10:18:26.312]                   options(future.plan = NULL)
[10:18:26.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.312]                 }
[10:18:26.312]                 ...future.workdir <- getwd()
[10:18:26.312]             }
[10:18:26.312]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.312]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.312]         }
[10:18:26.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.312]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.312]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.312]             base::names(...future.oldOptions))
[10:18:26.312]     }
[10:18:26.312]     if (FALSE) {
[10:18:26.312]     }
[10:18:26.312]     else {
[10:18:26.312]         if (TRUE) {
[10:18:26.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.312]                 open = "w")
[10:18:26.312]         }
[10:18:26.312]         else {
[10:18:26.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.312]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.312]         }
[10:18:26.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.312]             base::sink(type = "output", split = FALSE)
[10:18:26.312]             base::close(...future.stdout)
[10:18:26.312]         }, add = TRUE)
[10:18:26.312]     }
[10:18:26.312]     ...future.frame <- base::sys.nframe()
[10:18:26.312]     ...future.conditions <- base::list()
[10:18:26.312]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.312]     if (FALSE) {
[10:18:26.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.312]     }
[10:18:26.312]     ...future.result <- base::tryCatch({
[10:18:26.312]         base::withCallingHandlers({
[10:18:26.312]             ...future.value <- base::withVisible(base::local({
[10:18:26.312]                 do.call(function(...) {
[10:18:26.312]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.312]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.312]                     ...future.globals.maxSize)) {
[10:18:26.312]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.312]                     on.exit(options(oopts), add = TRUE)
[10:18:26.312]                   }
[10:18:26.312]                   {
[10:18:26.312]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.312]                       FUN = function(jj) {
[10:18:26.312]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.312]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.312]                       })
[10:18:26.312]                   }
[10:18:26.312]                 }, args = future.call.arguments)
[10:18:26.312]             }))
[10:18:26.312]             future::FutureResult(value = ...future.value$value, 
[10:18:26.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.312]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.312]                     ...future.globalenv.names))
[10:18:26.312]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.312]         }, condition = base::local({
[10:18:26.312]             c <- base::c
[10:18:26.312]             inherits <- base::inherits
[10:18:26.312]             invokeRestart <- base::invokeRestart
[10:18:26.312]             length <- base::length
[10:18:26.312]             list <- base::list
[10:18:26.312]             seq.int <- base::seq.int
[10:18:26.312]             signalCondition <- base::signalCondition
[10:18:26.312]             sys.calls <- base::sys.calls
[10:18:26.312]             `[[` <- base::`[[`
[10:18:26.312]             `+` <- base::`+`
[10:18:26.312]             `<<-` <- base::`<<-`
[10:18:26.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.312]                   3L)]
[10:18:26.312]             }
[10:18:26.312]             function(cond) {
[10:18:26.312]                 is_error <- inherits(cond, "error")
[10:18:26.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.312]                   NULL)
[10:18:26.312]                 if (is_error) {
[10:18:26.312]                   sessionInformation <- function() {
[10:18:26.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.312]                       search = base::search(), system = base::Sys.info())
[10:18:26.312]                   }
[10:18:26.312]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.312]                     cond$call), session = sessionInformation(), 
[10:18:26.312]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.312]                   signalCondition(cond)
[10:18:26.312]                 }
[10:18:26.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.312]                 "immediateCondition"))) {
[10:18:26.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.312]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.312]                   if (TRUE && !signal) {
[10:18:26.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.312]                     {
[10:18:26.312]                       inherits <- base::inherits
[10:18:26.312]                       invokeRestart <- base::invokeRestart
[10:18:26.312]                       is.null <- base::is.null
[10:18:26.312]                       muffled <- FALSE
[10:18:26.312]                       if (inherits(cond, "message")) {
[10:18:26.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.312]                         if (muffled) 
[10:18:26.312]                           invokeRestart("muffleMessage")
[10:18:26.312]                       }
[10:18:26.312]                       else if (inherits(cond, "warning")) {
[10:18:26.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.312]                         if (muffled) 
[10:18:26.312]                           invokeRestart("muffleWarning")
[10:18:26.312]                       }
[10:18:26.312]                       else if (inherits(cond, "condition")) {
[10:18:26.312]                         if (!is.null(pattern)) {
[10:18:26.312]                           computeRestarts <- base::computeRestarts
[10:18:26.312]                           grepl <- base::grepl
[10:18:26.312]                           restarts <- computeRestarts(cond)
[10:18:26.312]                           for (restart in restarts) {
[10:18:26.312]                             name <- restart$name
[10:18:26.312]                             if (is.null(name)) 
[10:18:26.312]                               next
[10:18:26.312]                             if (!grepl(pattern, name)) 
[10:18:26.312]                               next
[10:18:26.312]                             invokeRestart(restart)
[10:18:26.312]                             muffled <- TRUE
[10:18:26.312]                             break
[10:18:26.312]                           }
[10:18:26.312]                         }
[10:18:26.312]                       }
[10:18:26.312]                       invisible(muffled)
[10:18:26.312]                     }
[10:18:26.312]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.312]                   }
[10:18:26.312]                 }
[10:18:26.312]                 else {
[10:18:26.312]                   if (TRUE) {
[10:18:26.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.312]                     {
[10:18:26.312]                       inherits <- base::inherits
[10:18:26.312]                       invokeRestart <- base::invokeRestart
[10:18:26.312]                       is.null <- base::is.null
[10:18:26.312]                       muffled <- FALSE
[10:18:26.312]                       if (inherits(cond, "message")) {
[10:18:26.312]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.312]                         if (muffled) 
[10:18:26.312]                           invokeRestart("muffleMessage")
[10:18:26.312]                       }
[10:18:26.312]                       else if (inherits(cond, "warning")) {
[10:18:26.312]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.312]                         if (muffled) 
[10:18:26.312]                           invokeRestart("muffleWarning")
[10:18:26.312]                       }
[10:18:26.312]                       else if (inherits(cond, "condition")) {
[10:18:26.312]                         if (!is.null(pattern)) {
[10:18:26.312]                           computeRestarts <- base::computeRestarts
[10:18:26.312]                           grepl <- base::grepl
[10:18:26.312]                           restarts <- computeRestarts(cond)
[10:18:26.312]                           for (restart in restarts) {
[10:18:26.312]                             name <- restart$name
[10:18:26.312]                             if (is.null(name)) 
[10:18:26.312]                               next
[10:18:26.312]                             if (!grepl(pattern, name)) 
[10:18:26.312]                               next
[10:18:26.312]                             invokeRestart(restart)
[10:18:26.312]                             muffled <- TRUE
[10:18:26.312]                             break
[10:18:26.312]                           }
[10:18:26.312]                         }
[10:18:26.312]                       }
[10:18:26.312]                       invisible(muffled)
[10:18:26.312]                     }
[10:18:26.312]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.312]                   }
[10:18:26.312]                 }
[10:18:26.312]             }
[10:18:26.312]         }))
[10:18:26.312]     }, error = function(ex) {
[10:18:26.312]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.312]                 ...future.rng), started = ...future.startTime, 
[10:18:26.312]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.312]             version = "1.8"), class = "FutureResult")
[10:18:26.312]     }, finally = {
[10:18:26.312]         if (!identical(...future.workdir, getwd())) 
[10:18:26.312]             setwd(...future.workdir)
[10:18:26.312]         {
[10:18:26.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.312]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.312]             }
[10:18:26.312]             base::options(...future.oldOptions)
[10:18:26.312]             if (.Platform$OS.type == "windows") {
[10:18:26.312]                 old_names <- names(...future.oldEnvVars)
[10:18:26.312]                 envs <- base::Sys.getenv()
[10:18:26.312]                 names <- names(envs)
[10:18:26.312]                 common <- intersect(names, old_names)
[10:18:26.312]                 added <- setdiff(names, old_names)
[10:18:26.312]                 removed <- setdiff(old_names, names)
[10:18:26.312]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.312]                   envs[common]]
[10:18:26.312]                 NAMES <- toupper(changed)
[10:18:26.312]                 args <- list()
[10:18:26.312]                 for (kk in seq_along(NAMES)) {
[10:18:26.312]                   name <- changed[[kk]]
[10:18:26.312]                   NAME <- NAMES[[kk]]
[10:18:26.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.312]                     next
[10:18:26.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.312]                 }
[10:18:26.312]                 NAMES <- toupper(added)
[10:18:26.312]                 for (kk in seq_along(NAMES)) {
[10:18:26.312]                   name <- added[[kk]]
[10:18:26.312]                   NAME <- NAMES[[kk]]
[10:18:26.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.312]                     next
[10:18:26.312]                   args[[name]] <- ""
[10:18:26.312]                 }
[10:18:26.312]                 NAMES <- toupper(removed)
[10:18:26.312]                 for (kk in seq_along(NAMES)) {
[10:18:26.312]                   name <- removed[[kk]]
[10:18:26.312]                   NAME <- NAMES[[kk]]
[10:18:26.312]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.312]                     next
[10:18:26.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.312]                 }
[10:18:26.312]                 if (length(args) > 0) 
[10:18:26.312]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.312]             }
[10:18:26.312]             else {
[10:18:26.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.312]             }
[10:18:26.312]             {
[10:18:26.312]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.312]                   0L) {
[10:18:26.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.312]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.312]                   base::options(opts)
[10:18:26.312]                 }
[10:18:26.312]                 {
[10:18:26.312]                   {
[10:18:26.312]                     NULL
[10:18:26.312]                     RNGkind("Mersenne-Twister")
[10:18:26.312]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:26.312]                       inherits = FALSE)
[10:18:26.312]                   }
[10:18:26.312]                   options(future.plan = NULL)
[10:18:26.312]                   if (is.na(NA_character_)) 
[10:18:26.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.312]                     .init = FALSE)
[10:18:26.312]                 }
[10:18:26.312]             }
[10:18:26.312]         }
[10:18:26.312]     })
[10:18:26.312]     if (TRUE) {
[10:18:26.312]         base::sink(type = "output", split = FALSE)
[10:18:26.312]         if (TRUE) {
[10:18:26.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.312]         }
[10:18:26.312]         else {
[10:18:26.312]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.312]         }
[10:18:26.312]         base::close(...future.stdout)
[10:18:26.312]         ...future.stdout <- NULL
[10:18:26.312]     }
[10:18:26.312]     ...future.result$conditions <- ...future.conditions
[10:18:26.312]     ...future.result$finished <- base::Sys.time()
[10:18:26.312]     ...future.result
[10:18:26.312] }
[10:18:26.313] assign_globals() ...
[10:18:26.314] List of 5
[10:18:26.314]  $ future.call.arguments    : list()
[10:18:26.314]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.314]  $ ...future.FUN            :function (x)  
[10:18:26.314]  $ ...future.elements_ii    :List of 2
[10:18:26.314]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:18:26.314]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:18:26.314]  $ ...future.seeds_ii       : NULL
[10:18:26.314]  $ ...future.globals.maxSize: num Inf
[10:18:26.314]  - attr(*, "resolved")= logi FALSE
[10:18:26.314]  - attr(*, "total_size")= num NA
[10:18:26.314]  - attr(*, "where")=List of 5
[10:18:26.314]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.314]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.314]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.314]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.314]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.314]  - attr(*, "already-done")= logi TRUE
[10:18:26.318] - copied ‘future.call.arguments’ to environment
[10:18:26.319] - copied ‘...future.FUN’ to environment
[10:18:26.319] - copied ‘...future.elements_ii’ to environment
[10:18:26.319] - copied ‘...future.seeds_ii’ to environment
[10:18:26.319] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.319] assign_globals() ... done
[10:18:26.319] plan(): Setting new future strategy stack:
[10:18:26.319] List of future strategies:
[10:18:26.319] 1. sequential:
[10:18:26.319]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.319]    - tweaked: FALSE
[10:18:26.319]    - call: NULL
[10:18:26.320] plan(): nbrOfWorkers() = 1
[10:18:26.322] plan(): Setting new future strategy stack:
[10:18:26.322] List of future strategies:
[10:18:26.322] 1. sequential:
[10:18:26.322]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.322]    - tweaked: FALSE
[10:18:26.322]    - call: plan(strategy)
[10:18:26.323] plan(): nbrOfWorkers() = 1
[10:18:26.323] SequentialFuture started (and completed)
[10:18:26.323] - Launch lazy future ... done
[10:18:26.323] run() for ‘SequentialFuture’ ... done
[10:18:26.323] Created future:
[10:18:26.323] SequentialFuture:
[10:18:26.323] Label: ‘future_apply-1’
[10:18:26.323] Expression:
[10:18:26.323] {
[10:18:26.323]     do.call(function(...) {
[10:18:26.323]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.323]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.323]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.323]             on.exit(options(oopts), add = TRUE)
[10:18:26.323]         }
[10:18:26.323]         {
[10:18:26.323]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.323]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.323]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.323]             })
[10:18:26.323]         }
[10:18:26.323]     }, args = future.call.arguments)
[10:18:26.323] }
[10:18:26.323] Lazy evaluation: FALSE
[10:18:26.323] Asynchronous evaluation: FALSE
[10:18:26.323] Local evaluation: TRUE
[10:18:26.323] Environment: R_GlobalEnv
[10:18:26.323] Capture standard output: TRUE
[10:18:26.323] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.323] Globals: 5 objects totaling 523 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 175 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.323] Packages: <none>
[10:18:26.323] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.323] Resolved: TRUE
[10:18:26.323] Value: 175 bytes of class ‘list’
[10:18:26.323] Early signaling: FALSE
[10:18:26.323] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.323] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.324] Chunk #1 of 1 ... DONE
[10:18:26.324] Launching 1 futures (chunks) ... DONE
[10:18:26.324] Resolving 1 futures (chunks) ...
[10:18:26.324] resolve() on list ...
[10:18:26.324]  recursive: 0
[10:18:26.324]  length: 1
[10:18:26.325] 
[10:18:26.325] resolved() for ‘SequentialFuture’ ...
[10:18:26.325] - state: ‘finished’
[10:18:26.325] - run: TRUE
[10:18:26.325] - result: ‘FutureResult’
[10:18:26.325] resolved() for ‘SequentialFuture’ ... done
[10:18:26.325] Future #1
[10:18:26.325] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.325] - nx: 1
[10:18:26.325] - relay: TRUE
[10:18:26.326] - stdout: TRUE
[10:18:26.326] - signal: TRUE
[10:18:26.326] - resignal: FALSE
[10:18:26.326] - force: TRUE
[10:18:26.326] - relayed: [n=1] FALSE
[10:18:26.326] - queued futures: [n=1] FALSE
[10:18:26.326]  - until=1
[10:18:26.326]  - relaying element #1
[10:18:26.326] - relayed: [n=1] TRUE
[10:18:26.326] - queued futures: [n=1] TRUE
[10:18:26.326] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.327]  length: 0 (resolved future 1)
[10:18:26.327] Relaying remaining futures
[10:18:26.327] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.327] - nx: 1
[10:18:26.327] - relay: TRUE
[10:18:26.327] - stdout: TRUE
[10:18:26.327] - signal: TRUE
[10:18:26.327] - resignal: FALSE
[10:18:26.327] - force: TRUE
[10:18:26.327] - relayed: [n=1] TRUE
[10:18:26.327] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.327] - relayed: [n=1] TRUE
[10:18:26.327] - queued futures: [n=1] TRUE
[10:18:26.328] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.328] resolve() on list ... DONE
[10:18:26.328]  - Number of value chunks collected: 1
[10:18:26.328] Resolving 1 futures (chunks) ... DONE
[10:18:26.328] Reducing values from 1 chunks ...
[10:18:26.328]  - Number of values collected after concatenation: 2
[10:18:26.328]  - Number of values expected: 2
[10:18:26.328] Reducing values from 1 chunks ... DONE
[10:18:26.328] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:18:26.329] getGlobalsAndPackagesXApply() ...
[10:18:26.329]  - future.globals: TRUE
[10:18:26.329] getGlobalsAndPackages() ...
[10:18:26.329] Searching for globals...
[10:18:26.330] - globals found: [1] ‘FUN’
[10:18:26.330] Searching for globals ... DONE
[10:18:26.330] Resolving globals: FALSE
[10:18:26.330] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:26.331] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:26.331] - globals: [1] ‘FUN’
[10:18:26.331] 
[10:18:26.331] getGlobalsAndPackages() ... DONE
[10:18:26.331]  - globals found/used: [n=1] ‘FUN’
[10:18:26.331]  - needed namespaces: [n=0] 
[10:18:26.331] Finding globals ... DONE
[10:18:26.331]  - use_args: TRUE
[10:18:26.331]  - Getting '...' globals ...
[10:18:26.332] resolve() on list ...
[10:18:26.332]  recursive: 0
[10:18:26.332]  length: 1
[10:18:26.332]  elements: ‘...’
[10:18:26.332]  length: 0 (resolved future 1)
[10:18:26.332] resolve() on list ... DONE
[10:18:26.332]    - '...' content: [n=0] 
[10:18:26.332] List of 1
[10:18:26.332]  $ ...: list()
[10:18:26.332]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.332]  - attr(*, "where")=List of 1
[10:18:26.332]   ..$ ...:<environment: 0x556e0210f1a8> 
[10:18:26.332]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.332]  - attr(*, "resolved")= logi TRUE
[10:18:26.332]  - attr(*, "total_size")= num NA
[10:18:26.335]  - Getting '...' globals ... DONE
[10:18:26.335] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.335] List of 2
[10:18:26.335]  $ ...future.FUN:function (x)  
[10:18:26.335]  $ ...          : list()
[10:18:26.335]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.335]  - attr(*, "where")=List of 2
[10:18:26.335]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.335]   ..$ ...          :<environment: 0x556e0210f1a8> 
[10:18:26.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.335]  - attr(*, "resolved")= logi FALSE
[10:18:26.335]  - attr(*, "total_size")= num 3563
[10:18:26.337] Packages to be attached in all futures: [n=0] 
[10:18:26.338] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.338] future_lapply() ...
[10:18:26.338] Number of chunks: 1
[10:18:26.338] getGlobalsAndPackagesXApply() ...
[10:18:26.338]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.339]  - use_args: TRUE
[10:18:26.339] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.339] List of 2
[10:18:26.339]  $ ...          : list()
[10:18:26.339]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.339]  $ ...future.FUN:function (x)  
[10:18:26.339]  - attr(*, "where")=List of 2
[10:18:26.339]   ..$ ...          :<environment: 0x556e0210f1a8> 
[10:18:26.339]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:26.339]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.339]  - attr(*, "resolved")= logi FALSE
[10:18:26.339]  - attr(*, "total_size")= num NA
[10:18:26.342] Packages to be attached in all futures: [n=0] 
[10:18:26.342] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.342] Number of futures (= number of chunks): 1
[10:18:26.342] Launching 1 futures (chunks) ...
[10:18:26.344] Chunk #1 of 1 ...
[10:18:26.344]  - seeds: <none>
[10:18:26.344]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.344] getGlobalsAndPackages() ...
[10:18:26.344] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.344] Resolving globals: FALSE
[10:18:26.344] Tweak future expression to call with '...' arguments ...
[10:18:26.344] {
[10:18:26.344]     do.call(function(...) {
[10:18:26.344]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.344]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.344]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.344]             on.exit(options(oopts), add = TRUE)
[10:18:26.344]         }
[10:18:26.344]         {
[10:18:26.344]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.344]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.344]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.344]             })
[10:18:26.344]         }
[10:18:26.344]     }, args = future.call.arguments)
[10:18:26.344] }
[10:18:26.345] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.345] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.345] 
[10:18:26.345] getGlobalsAndPackages() ... DONE
[10:18:26.346] run() for ‘Future’ ...
[10:18:26.346] - state: ‘created’
[10:18:26.346] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.346] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.346] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.346]   - Field: ‘label’
[10:18:26.346]   - Field: ‘local’
[10:18:26.346]   - Field: ‘owner’
[10:18:26.347]   - Field: ‘envir’
[10:18:26.347]   - Field: ‘packages’
[10:18:26.347]   - Field: ‘gc’
[10:18:26.347]   - Field: ‘conditions’
[10:18:26.347]   - Field: ‘expr’
[10:18:26.347]   - Field: ‘uuid’
[10:18:26.347]   - Field: ‘seed’
[10:18:26.347]   - Field: ‘version’
[10:18:26.347]   - Field: ‘result’
[10:18:26.347]   - Field: ‘asynchronous’
[10:18:26.347]   - Field: ‘calls’
[10:18:26.348]   - Field: ‘globals’
[10:18:26.348]   - Field: ‘stdout’
[10:18:26.348]   - Field: ‘earlySignal’
[10:18:26.348]   - Field: ‘lazy’
[10:18:26.348]   - Field: ‘state’
[10:18:26.348] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.348] - Launch lazy future ...
[10:18:26.348] Packages needed by the future expression (n = 0): <none>
[10:18:26.348] Packages needed by future strategies (n = 0): <none>
[10:18:26.349] {
[10:18:26.349]     {
[10:18:26.349]         {
[10:18:26.349]             ...future.startTime <- base::Sys.time()
[10:18:26.349]             {
[10:18:26.349]                 {
[10:18:26.349]                   {
[10:18:26.349]                     base::local({
[10:18:26.349]                       has_future <- base::requireNamespace("future", 
[10:18:26.349]                         quietly = TRUE)
[10:18:26.349]                       if (has_future) {
[10:18:26.349]                         ns <- base::getNamespace("future")
[10:18:26.349]                         version <- ns[[".package"]][["version"]]
[10:18:26.349]                         if (is.null(version)) 
[10:18:26.349]                           version <- utils::packageVersion("future")
[10:18:26.349]                       }
[10:18:26.349]                       else {
[10:18:26.349]                         version <- NULL
[10:18:26.349]                       }
[10:18:26.349]                       if (!has_future || version < "1.8.0") {
[10:18:26.349]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.349]                           "", base::R.version$version.string), 
[10:18:26.349]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:26.349]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.349]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.349]                             "release", "version")], collapse = " "), 
[10:18:26.349]                           hostname = base::Sys.info()[["nodename"]])
[10:18:26.349]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.349]                           info)
[10:18:26.349]                         info <- base::paste(info, collapse = "; ")
[10:18:26.349]                         if (!has_future) {
[10:18:26.349]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.349]                             info)
[10:18:26.349]                         }
[10:18:26.349]                         else {
[10:18:26.349]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.349]                             info, version)
[10:18:26.349]                         }
[10:18:26.349]                         base::stop(msg)
[10:18:26.349]                       }
[10:18:26.349]                     })
[10:18:26.349]                   }
[10:18:26.349]                   ...future.strategy.old <- future::plan("list")
[10:18:26.349]                   options(future.plan = NULL)
[10:18:26.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.349]                 }
[10:18:26.349]                 ...future.workdir <- getwd()
[10:18:26.349]             }
[10:18:26.349]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.349]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.349]         }
[10:18:26.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.349]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.349]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.349]             base::names(...future.oldOptions))
[10:18:26.349]     }
[10:18:26.349]     if (FALSE) {
[10:18:26.349]     }
[10:18:26.349]     else {
[10:18:26.349]         if (TRUE) {
[10:18:26.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.349]                 open = "w")
[10:18:26.349]         }
[10:18:26.349]         else {
[10:18:26.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.349]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.349]         }
[10:18:26.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.349]             base::sink(type = "output", split = FALSE)
[10:18:26.349]             base::close(...future.stdout)
[10:18:26.349]         }, add = TRUE)
[10:18:26.349]     }
[10:18:26.349]     ...future.frame <- base::sys.nframe()
[10:18:26.349]     ...future.conditions <- base::list()
[10:18:26.349]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.349]     if (FALSE) {
[10:18:26.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.349]     }
[10:18:26.349]     ...future.result <- base::tryCatch({
[10:18:26.349]         base::withCallingHandlers({
[10:18:26.349]             ...future.value <- base::withVisible(base::local({
[10:18:26.349]                 do.call(function(...) {
[10:18:26.349]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.349]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.349]                     ...future.globals.maxSize)) {
[10:18:26.349]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.349]                     on.exit(options(oopts), add = TRUE)
[10:18:26.349]                   }
[10:18:26.349]                   {
[10:18:26.349]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.349]                       FUN = function(jj) {
[10:18:26.349]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.349]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.349]                       })
[10:18:26.349]                   }
[10:18:26.349]                 }, args = future.call.arguments)
[10:18:26.349]             }))
[10:18:26.349]             future::FutureResult(value = ...future.value$value, 
[10:18:26.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.349]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.349]                     ...future.globalenv.names))
[10:18:26.349]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.349]         }, condition = base::local({
[10:18:26.349]             c <- base::c
[10:18:26.349]             inherits <- base::inherits
[10:18:26.349]             invokeRestart <- base::invokeRestart
[10:18:26.349]             length <- base::length
[10:18:26.349]             list <- base::list
[10:18:26.349]             seq.int <- base::seq.int
[10:18:26.349]             signalCondition <- base::signalCondition
[10:18:26.349]             sys.calls <- base::sys.calls
[10:18:26.349]             `[[` <- base::`[[`
[10:18:26.349]             `+` <- base::`+`
[10:18:26.349]             `<<-` <- base::`<<-`
[10:18:26.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.349]                   3L)]
[10:18:26.349]             }
[10:18:26.349]             function(cond) {
[10:18:26.349]                 is_error <- inherits(cond, "error")
[10:18:26.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.349]                   NULL)
[10:18:26.349]                 if (is_error) {
[10:18:26.349]                   sessionInformation <- function() {
[10:18:26.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.349]                       search = base::search(), system = base::Sys.info())
[10:18:26.349]                   }
[10:18:26.349]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.349]                     cond$call), session = sessionInformation(), 
[10:18:26.349]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.349]                   signalCondition(cond)
[10:18:26.349]                 }
[10:18:26.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.349]                 "immediateCondition"))) {
[10:18:26.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.349]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.349]                   if (TRUE && !signal) {
[10:18:26.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.349]                     {
[10:18:26.349]                       inherits <- base::inherits
[10:18:26.349]                       invokeRestart <- base::invokeRestart
[10:18:26.349]                       is.null <- base::is.null
[10:18:26.349]                       muffled <- FALSE
[10:18:26.349]                       if (inherits(cond, "message")) {
[10:18:26.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.349]                         if (muffled) 
[10:18:26.349]                           invokeRestart("muffleMessage")
[10:18:26.349]                       }
[10:18:26.349]                       else if (inherits(cond, "warning")) {
[10:18:26.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.349]                         if (muffled) 
[10:18:26.349]                           invokeRestart("muffleWarning")
[10:18:26.349]                       }
[10:18:26.349]                       else if (inherits(cond, "condition")) {
[10:18:26.349]                         if (!is.null(pattern)) {
[10:18:26.349]                           computeRestarts <- base::computeRestarts
[10:18:26.349]                           grepl <- base::grepl
[10:18:26.349]                           restarts <- computeRestarts(cond)
[10:18:26.349]                           for (restart in restarts) {
[10:18:26.349]                             name <- restart$name
[10:18:26.349]                             if (is.null(name)) 
[10:18:26.349]                               next
[10:18:26.349]                             if (!grepl(pattern, name)) 
[10:18:26.349]                               next
[10:18:26.349]                             invokeRestart(restart)
[10:18:26.349]                             muffled <- TRUE
[10:18:26.349]                             break
[10:18:26.349]                           }
[10:18:26.349]                         }
[10:18:26.349]                       }
[10:18:26.349]                       invisible(muffled)
[10:18:26.349]                     }
[10:18:26.349]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.349]                   }
[10:18:26.349]                 }
[10:18:26.349]                 else {
[10:18:26.349]                   if (TRUE) {
[10:18:26.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.349]                     {
[10:18:26.349]                       inherits <- base::inherits
[10:18:26.349]                       invokeRestart <- base::invokeRestart
[10:18:26.349]                       is.null <- base::is.null
[10:18:26.349]                       muffled <- FALSE
[10:18:26.349]                       if (inherits(cond, "message")) {
[10:18:26.349]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.349]                         if (muffled) 
[10:18:26.349]                           invokeRestart("muffleMessage")
[10:18:26.349]                       }
[10:18:26.349]                       else if (inherits(cond, "warning")) {
[10:18:26.349]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.349]                         if (muffled) 
[10:18:26.349]                           invokeRestart("muffleWarning")
[10:18:26.349]                       }
[10:18:26.349]                       else if (inherits(cond, "condition")) {
[10:18:26.349]                         if (!is.null(pattern)) {
[10:18:26.349]                           computeRestarts <- base::computeRestarts
[10:18:26.349]                           grepl <- base::grepl
[10:18:26.349]                           restarts <- computeRestarts(cond)
[10:18:26.349]                           for (restart in restarts) {
[10:18:26.349]                             name <- restart$name
[10:18:26.349]                             if (is.null(name)) 
[10:18:26.349]                               next
[10:18:26.349]                             if (!grepl(pattern, name)) 
[10:18:26.349]                               next
[10:18:26.349]                             invokeRestart(restart)
[10:18:26.349]                             muffled <- TRUE
[10:18:26.349]                             break
[10:18:26.349]                           }
[10:18:26.349]                         }
[10:18:26.349]                       }
[10:18:26.349]                       invisible(muffled)
[10:18:26.349]                     }
[10:18:26.349]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.349]                   }
[10:18:26.349]                 }
[10:18:26.349]             }
[10:18:26.349]         }))
[10:18:26.349]     }, error = function(ex) {
[10:18:26.349]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.349]                 ...future.rng), started = ...future.startTime, 
[10:18:26.349]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.349]             version = "1.8"), class = "FutureResult")
[10:18:26.349]     }, finally = {
[10:18:26.349]         if (!identical(...future.workdir, getwd())) 
[10:18:26.349]             setwd(...future.workdir)
[10:18:26.349]         {
[10:18:26.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.349]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.349]             }
[10:18:26.349]             base::options(...future.oldOptions)
[10:18:26.349]             if (.Platform$OS.type == "windows") {
[10:18:26.349]                 old_names <- names(...future.oldEnvVars)
[10:18:26.349]                 envs <- base::Sys.getenv()
[10:18:26.349]                 names <- names(envs)
[10:18:26.349]                 common <- intersect(names, old_names)
[10:18:26.349]                 added <- setdiff(names, old_names)
[10:18:26.349]                 removed <- setdiff(old_names, names)
[10:18:26.349]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.349]                   envs[common]]
[10:18:26.349]                 NAMES <- toupper(changed)
[10:18:26.349]                 args <- list()
[10:18:26.349]                 for (kk in seq_along(NAMES)) {
[10:18:26.349]                   name <- changed[[kk]]
[10:18:26.349]                   NAME <- NAMES[[kk]]
[10:18:26.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.349]                     next
[10:18:26.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.349]                 }
[10:18:26.349]                 NAMES <- toupper(added)
[10:18:26.349]                 for (kk in seq_along(NAMES)) {
[10:18:26.349]                   name <- added[[kk]]
[10:18:26.349]                   NAME <- NAMES[[kk]]
[10:18:26.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.349]                     next
[10:18:26.349]                   args[[name]] <- ""
[10:18:26.349]                 }
[10:18:26.349]                 NAMES <- toupper(removed)
[10:18:26.349]                 for (kk in seq_along(NAMES)) {
[10:18:26.349]                   name <- removed[[kk]]
[10:18:26.349]                   NAME <- NAMES[[kk]]
[10:18:26.349]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.349]                     next
[10:18:26.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.349]                 }
[10:18:26.349]                 if (length(args) > 0) 
[10:18:26.349]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.349]             }
[10:18:26.349]             else {
[10:18:26.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.349]             }
[10:18:26.349]             {
[10:18:26.349]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.349]                   0L) {
[10:18:26.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.349]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.349]                   base::options(opts)
[10:18:26.349]                 }
[10:18:26.349]                 {
[10:18:26.349]                   {
[10:18:26.349]                     NULL
[10:18:26.349]                     RNGkind("Mersenne-Twister")
[10:18:26.349]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:26.349]                       inherits = FALSE)
[10:18:26.349]                   }
[10:18:26.349]                   options(future.plan = NULL)
[10:18:26.349]                   if (is.na(NA_character_)) 
[10:18:26.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.349]                     .init = FALSE)
[10:18:26.349]                 }
[10:18:26.349]             }
[10:18:26.349]         }
[10:18:26.349]     })
[10:18:26.349]     if (TRUE) {
[10:18:26.349]         base::sink(type = "output", split = FALSE)
[10:18:26.349]         if (TRUE) {
[10:18:26.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.349]         }
[10:18:26.349]         else {
[10:18:26.349]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.349]         }
[10:18:26.349]         base::close(...future.stdout)
[10:18:26.349]         ...future.stdout <- NULL
[10:18:26.349]     }
[10:18:26.349]     ...future.result$conditions <- ...future.conditions
[10:18:26.349]     ...future.result$finished <- base::Sys.time()
[10:18:26.349]     ...future.result
[10:18:26.349] }
[10:18:26.350] assign_globals() ...
[10:18:26.351] List of 5
[10:18:26.351]  $ future.call.arguments    : list()
[10:18:26.351]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.351]  $ ...future.FUN            :function (x)  
[10:18:26.351]  $ ...future.elements_ii    :List of 6
[10:18:26.351]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:18:26.351]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:18:26.351]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:18:26.351]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:18:26.351]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:18:26.351]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:18:26.351]  $ ...future.seeds_ii       : NULL
[10:18:26.351]  $ ...future.globals.maxSize: num Inf
[10:18:26.351]  - attr(*, "resolved")= logi FALSE
[10:18:26.351]  - attr(*, "total_size")= num NA
[10:18:26.351]  - attr(*, "where")=List of 5
[10:18:26.351]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.351]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.351]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.351]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.351]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.351]  - attr(*, "already-done")= logi TRUE
[10:18:26.357] - copied ‘future.call.arguments’ to environment
[10:18:26.357] - copied ‘...future.FUN’ to environment
[10:18:26.357] - copied ‘...future.elements_ii’ to environment
[10:18:26.357] - copied ‘...future.seeds_ii’ to environment
[10:18:26.357] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.357] assign_globals() ... done
[10:18:26.357] plan(): Setting new future strategy stack:
[10:18:26.357] List of future strategies:
[10:18:26.357] 1. sequential:
[10:18:26.357]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.357]    - tweaked: FALSE
[10:18:26.357]    - call: NULL
[10:18:26.358] plan(): nbrOfWorkers() = 1
[10:18:26.359] plan(): Setting new future strategy stack:
[10:18:26.359] List of future strategies:
[10:18:26.359] 1. sequential:
[10:18:26.359]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.359]    - tweaked: FALSE
[10:18:26.359]    - call: plan(strategy)
[10:18:26.359] plan(): nbrOfWorkers() = 1
[10:18:26.359] SequentialFuture started (and completed)
[10:18:26.359] - Launch lazy future ... done
[10:18:26.359] run() for ‘SequentialFuture’ ... done
[10:18:26.360] Created future:
[10:18:26.360] SequentialFuture:
[10:18:26.360] Label: ‘future_apply-1’
[10:18:26.360] Expression:
[10:18:26.360] {
[10:18:26.360]     do.call(function(...) {
[10:18:26.360]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.360]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.360]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.360]             on.exit(options(oopts), add = TRUE)
[10:18:26.360]         }
[10:18:26.360]         {
[10:18:26.360]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.360]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.360]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.360]             })
[10:18:26.360]         }
[10:18:26.360]     }, args = future.call.arguments)
[10:18:26.360] }
[10:18:26.360] Lazy evaluation: FALSE
[10:18:26.360] Asynchronous evaluation: FALSE
[10:18:26.360] Local evaluation: TRUE
[10:18:26.360] Environment: R_GlobalEnv
[10:18:26.360] Capture standard output: TRUE
[10:18:26.360] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.360] Globals: 5 objects totaling 811 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 463 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.360] Packages: <none>
[10:18:26.360] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.360] Resolved: TRUE
[10:18:26.360] Value: 463 bytes of class ‘list’
[10:18:26.360] Early signaling: FALSE
[10:18:26.360] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.360] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.360] Chunk #1 of 1 ... DONE
[10:18:26.361] Launching 1 futures (chunks) ... DONE
[10:18:26.361] Resolving 1 futures (chunks) ...
[10:18:26.361] resolve() on list ...
[10:18:26.361]  recursive: 0
[10:18:26.361]  length: 1
[10:18:26.361] 
[10:18:26.361] resolved() for ‘SequentialFuture’ ...
[10:18:26.361] - state: ‘finished’
[10:18:26.361] - run: TRUE
[10:18:26.361] - result: ‘FutureResult’
[10:18:26.361] resolved() for ‘SequentialFuture’ ... done
[10:18:26.361] Future #1
[10:18:26.362] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.362] - nx: 1
[10:18:26.362] - relay: TRUE
[10:18:26.362] - stdout: TRUE
[10:18:26.362] - signal: TRUE
[10:18:26.362] - resignal: FALSE
[10:18:26.362] - force: TRUE
[10:18:26.362] - relayed: [n=1] FALSE
[10:18:26.362] - queued futures: [n=1] FALSE
[10:18:26.362]  - until=1
[10:18:26.362]  - relaying element #1
[10:18:26.363] - relayed: [n=1] TRUE
[10:18:26.363] - queued futures: [n=1] TRUE
[10:18:26.363] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.363]  length: 0 (resolved future 1)
[10:18:26.363] Relaying remaining futures
[10:18:26.363] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.363] - nx: 1
[10:18:26.363] - relay: TRUE
[10:18:26.363] - stdout: TRUE
[10:18:26.363] - signal: TRUE
[10:18:26.363] - resignal: FALSE
[10:18:26.364] - force: TRUE
[10:18:26.364] - relayed: [n=1] TRUE
[10:18:26.364] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.364] - relayed: [n=1] TRUE
[10:18:26.364] - queued futures: [n=1] TRUE
[10:18:26.364] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.364] resolve() on list ... DONE
[10:18:26.364]  - Number of value chunks collected: 1
[10:18:26.364] Resolving 1 futures (chunks) ... DONE
[10:18:26.364] Reducing values from 1 chunks ...
[10:18:26.364]  - Number of values collected after concatenation: 6
[10:18:26.364]  - Number of values expected: 6
[10:18:26.365] Reducing values from 1 chunks ... DONE
[10:18:26.365] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:18:26.365] getGlobalsAndPackagesXApply() ...
[10:18:26.365]  - future.globals: TRUE
[10:18:26.365] getGlobalsAndPackages() ...
[10:18:26.367] Searching for globals...
[10:18:26.368] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:18:26.368] Searching for globals ... DONE
[10:18:26.368] Resolving globals: FALSE
[10:18:26.369] The total size of the 1 globals is 411 bytes (411 bytes)
[10:18:26.369] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 411 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (411 bytes of class ‘function’)
[10:18:26.369] - globals: [1] ‘FUN’
[10:18:26.369] 
[10:18:26.369] getGlobalsAndPackages() ... DONE
[10:18:26.369]  - globals found/used: [n=1] ‘FUN’
[10:18:26.369]  - needed namespaces: [n=0] 
[10:18:26.369] Finding globals ... DONE
[10:18:26.370]  - use_args: TRUE
[10:18:26.370]  - Getting '...' globals ...
[10:18:26.370] resolve() on list ...
[10:18:26.370]  recursive: 0
[10:18:26.370]  length: 1
[10:18:26.370]  elements: ‘...’
[10:18:26.370]  length: 0 (resolved future 1)
[10:18:26.370] resolve() on list ... DONE
[10:18:26.370]    - '...' content: [n=0] 
[10:18:26.371] List of 1
[10:18:26.371]  $ ...: list()
[10:18:26.371]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.371]  - attr(*, "where")=List of 1
[10:18:26.371]   ..$ ...:<environment: 0x556e040add38> 
[10:18:26.371]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.371]  - attr(*, "resolved")= logi TRUE
[10:18:26.371]  - attr(*, "total_size")= num NA
[10:18:26.373]  - Getting '...' globals ... DONE
[10:18:26.373] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.373] List of 2
[10:18:26.373]  $ ...future.FUN:function (x)  
[10:18:26.373]  $ ...          : list()
[10:18:26.373]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.373]  - attr(*, "where")=List of 2
[10:18:26.373]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.373]   ..$ ...          :<environment: 0x556e040add38> 
[10:18:26.373]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.373]  - attr(*, "resolved")= logi FALSE
[10:18:26.373]  - attr(*, "total_size")= num 3672
[10:18:26.376] Packages to be attached in all futures: [n=0] 
[10:18:26.376] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.376] future_lapply() ...
[10:18:26.376] Number of chunks: 1
[10:18:26.377] getGlobalsAndPackagesXApply() ...
[10:18:26.377]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.377]  - use_args: TRUE
[10:18:26.377] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.377] List of 2
[10:18:26.377]  $ ...          : list()
[10:18:26.377]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.377]  $ ...future.FUN:function (x)  
[10:18:26.377]  - attr(*, "where")=List of 2
[10:18:26.377]   ..$ ...          :<environment: 0x556e040add38> 
[10:18:26.377]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:18:26.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.377]  - attr(*, "resolved")= logi FALSE
[10:18:26.377]  - attr(*, "total_size")= num NA
[10:18:26.380] Packages to be attached in all futures: [n=0] 
[10:18:26.380] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.380] Number of futures (= number of chunks): 1
[10:18:26.380] Launching 1 futures (chunks) ...
[10:18:26.380] Chunk #1 of 1 ...
[10:18:26.380]  - seeds: <none>
[10:18:26.380]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.380] getGlobalsAndPackages() ...
[10:18:26.381] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.381] Resolving globals: FALSE
[10:18:26.381] Tweak future expression to call with '...' arguments ...
[10:18:26.381] {
[10:18:26.381]     do.call(function(...) {
[10:18:26.381]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.381]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.381]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.381]             on.exit(options(oopts), add = TRUE)
[10:18:26.381]         }
[10:18:26.381]         {
[10:18:26.381]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.381]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.381]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.381]             })
[10:18:26.381]         }
[10:18:26.381]     }, args = future.call.arguments)
[10:18:26.381] }
[10:18:26.381] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.381] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.382] 
[10:18:26.382] getGlobalsAndPackages() ... DONE
[10:18:26.382] run() for ‘Future’ ...
[10:18:26.382] - state: ‘created’
[10:18:26.382] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.382] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.382] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.383]   - Field: ‘label’
[10:18:26.383]   - Field: ‘local’
[10:18:26.383]   - Field: ‘owner’
[10:18:26.383]   - Field: ‘envir’
[10:18:26.383]   - Field: ‘packages’
[10:18:26.383]   - Field: ‘gc’
[10:18:26.383]   - Field: ‘conditions’
[10:18:26.383]   - Field: ‘expr’
[10:18:26.383]   - Field: ‘uuid’
[10:18:26.383]   - Field: ‘seed’
[10:18:26.383]   - Field: ‘version’
[10:18:26.383]   - Field: ‘result’
[10:18:26.384]   - Field: ‘asynchronous’
[10:18:26.384]   - Field: ‘calls’
[10:18:26.384]   - Field: ‘globals’
[10:18:26.384]   - Field: ‘stdout’
[10:18:26.384]   - Field: ‘earlySignal’
[10:18:26.384]   - Field: ‘lazy’
[10:18:26.384]   - Field: ‘state’
[10:18:26.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.384] - Launch lazy future ...
[10:18:26.384] Packages needed by the future expression (n = 0): <none>
[10:18:26.385] Packages needed by future strategies (n = 0): <none>
[10:18:26.385] {
[10:18:26.385]     {
[10:18:26.385]         {
[10:18:26.385]             ...future.startTime <- base::Sys.time()
[10:18:26.385]             {
[10:18:26.385]                 {
[10:18:26.385]                   {
[10:18:26.385]                     base::local({
[10:18:26.385]                       has_future <- base::requireNamespace("future", 
[10:18:26.385]                         quietly = TRUE)
[10:18:26.385]                       if (has_future) {
[10:18:26.385]                         ns <- base::getNamespace("future")
[10:18:26.385]                         version <- ns[[".package"]][["version"]]
[10:18:26.385]                         if (is.null(version)) 
[10:18:26.385]                           version <- utils::packageVersion("future")
[10:18:26.385]                       }
[10:18:26.385]                       else {
[10:18:26.385]                         version <- NULL
[10:18:26.385]                       }
[10:18:26.385]                       if (!has_future || version < "1.8.0") {
[10:18:26.385]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.385]                           "", base::R.version$version.string), 
[10:18:26.385]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:26.385]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.385]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.385]                             "release", "version")], collapse = " "), 
[10:18:26.385]                           hostname = base::Sys.info()[["nodename"]])
[10:18:26.385]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.385]                           info)
[10:18:26.385]                         info <- base::paste(info, collapse = "; ")
[10:18:26.385]                         if (!has_future) {
[10:18:26.385]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.385]                             info)
[10:18:26.385]                         }
[10:18:26.385]                         else {
[10:18:26.385]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.385]                             info, version)
[10:18:26.385]                         }
[10:18:26.385]                         base::stop(msg)
[10:18:26.385]                       }
[10:18:26.385]                     })
[10:18:26.385]                   }
[10:18:26.385]                   ...future.strategy.old <- future::plan("list")
[10:18:26.385]                   options(future.plan = NULL)
[10:18:26.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.385]                 }
[10:18:26.385]                 ...future.workdir <- getwd()
[10:18:26.385]             }
[10:18:26.385]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.385]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.385]         }
[10:18:26.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.385]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.385]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.385]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.385]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.385]             base::names(...future.oldOptions))
[10:18:26.385]     }
[10:18:26.385]     if (FALSE) {
[10:18:26.385]     }
[10:18:26.385]     else {
[10:18:26.385]         if (TRUE) {
[10:18:26.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.385]                 open = "w")
[10:18:26.385]         }
[10:18:26.385]         else {
[10:18:26.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.385]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.385]         }
[10:18:26.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.385]             base::sink(type = "output", split = FALSE)
[10:18:26.385]             base::close(...future.stdout)
[10:18:26.385]         }, add = TRUE)
[10:18:26.385]     }
[10:18:26.385]     ...future.frame <- base::sys.nframe()
[10:18:26.385]     ...future.conditions <- base::list()
[10:18:26.385]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.385]     if (FALSE) {
[10:18:26.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.385]     }
[10:18:26.385]     ...future.result <- base::tryCatch({
[10:18:26.385]         base::withCallingHandlers({
[10:18:26.385]             ...future.value <- base::withVisible(base::local({
[10:18:26.385]                 do.call(function(...) {
[10:18:26.385]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.385]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.385]                     ...future.globals.maxSize)) {
[10:18:26.385]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.385]                     on.exit(options(oopts), add = TRUE)
[10:18:26.385]                   }
[10:18:26.385]                   {
[10:18:26.385]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.385]                       FUN = function(jj) {
[10:18:26.385]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.385]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.385]                       })
[10:18:26.385]                   }
[10:18:26.385]                 }, args = future.call.arguments)
[10:18:26.385]             }))
[10:18:26.385]             future::FutureResult(value = ...future.value$value, 
[10:18:26.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.385]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.385]                     ...future.globalenv.names))
[10:18:26.385]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.385]         }, condition = base::local({
[10:18:26.385]             c <- base::c
[10:18:26.385]             inherits <- base::inherits
[10:18:26.385]             invokeRestart <- base::invokeRestart
[10:18:26.385]             length <- base::length
[10:18:26.385]             list <- base::list
[10:18:26.385]             seq.int <- base::seq.int
[10:18:26.385]             signalCondition <- base::signalCondition
[10:18:26.385]             sys.calls <- base::sys.calls
[10:18:26.385]             `[[` <- base::`[[`
[10:18:26.385]             `+` <- base::`+`
[10:18:26.385]             `<<-` <- base::`<<-`
[10:18:26.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.385]                   3L)]
[10:18:26.385]             }
[10:18:26.385]             function(cond) {
[10:18:26.385]                 is_error <- inherits(cond, "error")
[10:18:26.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.385]                   NULL)
[10:18:26.385]                 if (is_error) {
[10:18:26.385]                   sessionInformation <- function() {
[10:18:26.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.385]                       search = base::search(), system = base::Sys.info())
[10:18:26.385]                   }
[10:18:26.385]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.385]                     cond$call), session = sessionInformation(), 
[10:18:26.385]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.385]                   signalCondition(cond)
[10:18:26.385]                 }
[10:18:26.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.385]                 "immediateCondition"))) {
[10:18:26.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.385]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.385]                   if (TRUE && !signal) {
[10:18:26.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.385]                     {
[10:18:26.385]                       inherits <- base::inherits
[10:18:26.385]                       invokeRestart <- base::invokeRestart
[10:18:26.385]                       is.null <- base::is.null
[10:18:26.385]                       muffled <- FALSE
[10:18:26.385]                       if (inherits(cond, "message")) {
[10:18:26.385]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.385]                         if (muffled) 
[10:18:26.385]                           invokeRestart("muffleMessage")
[10:18:26.385]                       }
[10:18:26.385]                       else if (inherits(cond, "warning")) {
[10:18:26.385]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.385]                         if (muffled) 
[10:18:26.385]                           invokeRestart("muffleWarning")
[10:18:26.385]                       }
[10:18:26.385]                       else if (inherits(cond, "condition")) {
[10:18:26.385]                         if (!is.null(pattern)) {
[10:18:26.385]                           computeRestarts <- base::computeRestarts
[10:18:26.385]                           grepl <- base::grepl
[10:18:26.385]                           restarts <- computeRestarts(cond)
[10:18:26.385]                           for (restart in restarts) {
[10:18:26.385]                             name <- restart$name
[10:18:26.385]                             if (is.null(name)) 
[10:18:26.385]                               next
[10:18:26.385]                             if (!grepl(pattern, name)) 
[10:18:26.385]                               next
[10:18:26.385]                             invokeRestart(restart)
[10:18:26.385]                             muffled <- TRUE
[10:18:26.385]                             break
[10:18:26.385]                           }
[10:18:26.385]                         }
[10:18:26.385]                       }
[10:18:26.385]                       invisible(muffled)
[10:18:26.385]                     }
[10:18:26.385]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.385]                   }
[10:18:26.385]                 }
[10:18:26.385]                 else {
[10:18:26.385]                   if (TRUE) {
[10:18:26.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.385]                     {
[10:18:26.385]                       inherits <- base::inherits
[10:18:26.385]                       invokeRestart <- base::invokeRestart
[10:18:26.385]                       is.null <- base::is.null
[10:18:26.385]                       muffled <- FALSE
[10:18:26.385]                       if (inherits(cond, "message")) {
[10:18:26.385]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.385]                         if (muffled) 
[10:18:26.385]                           invokeRestart("muffleMessage")
[10:18:26.385]                       }
[10:18:26.385]                       else if (inherits(cond, "warning")) {
[10:18:26.385]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.385]                         if (muffled) 
[10:18:26.385]                           invokeRestart("muffleWarning")
[10:18:26.385]                       }
[10:18:26.385]                       else if (inherits(cond, "condition")) {
[10:18:26.385]                         if (!is.null(pattern)) {
[10:18:26.385]                           computeRestarts <- base::computeRestarts
[10:18:26.385]                           grepl <- base::grepl
[10:18:26.385]                           restarts <- computeRestarts(cond)
[10:18:26.385]                           for (restart in restarts) {
[10:18:26.385]                             name <- restart$name
[10:18:26.385]                             if (is.null(name)) 
[10:18:26.385]                               next
[10:18:26.385]                             if (!grepl(pattern, name)) 
[10:18:26.385]                               next
[10:18:26.385]                             invokeRestart(restart)
[10:18:26.385]                             muffled <- TRUE
[10:18:26.385]                             break
[10:18:26.385]                           }
[10:18:26.385]                         }
[10:18:26.385]                       }
[10:18:26.385]                       invisible(muffled)
[10:18:26.385]                     }
[10:18:26.385]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.385]                   }
[10:18:26.385]                 }
[10:18:26.385]             }
[10:18:26.385]         }))
[10:18:26.385]     }, error = function(ex) {
[10:18:26.385]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.385]                 ...future.rng), started = ...future.startTime, 
[10:18:26.385]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.385]             version = "1.8"), class = "FutureResult")
[10:18:26.385]     }, finally = {
[10:18:26.385]         if (!identical(...future.workdir, getwd())) 
[10:18:26.385]             setwd(...future.workdir)
[10:18:26.385]         {
[10:18:26.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.385]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.385]             }
[10:18:26.385]             base::options(...future.oldOptions)
[10:18:26.385]             if (.Platform$OS.type == "windows") {
[10:18:26.385]                 old_names <- names(...future.oldEnvVars)
[10:18:26.385]                 envs <- base::Sys.getenv()
[10:18:26.385]                 names <- names(envs)
[10:18:26.385]                 common <- intersect(names, old_names)
[10:18:26.385]                 added <- setdiff(names, old_names)
[10:18:26.385]                 removed <- setdiff(old_names, names)
[10:18:26.385]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.385]                   envs[common]]
[10:18:26.385]                 NAMES <- toupper(changed)
[10:18:26.385]                 args <- list()
[10:18:26.385]                 for (kk in seq_along(NAMES)) {
[10:18:26.385]                   name <- changed[[kk]]
[10:18:26.385]                   NAME <- NAMES[[kk]]
[10:18:26.385]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.385]                     next
[10:18:26.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.385]                 }
[10:18:26.385]                 NAMES <- toupper(added)
[10:18:26.385]                 for (kk in seq_along(NAMES)) {
[10:18:26.385]                   name <- added[[kk]]
[10:18:26.385]                   NAME <- NAMES[[kk]]
[10:18:26.385]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.385]                     next
[10:18:26.385]                   args[[name]] <- ""
[10:18:26.385]                 }
[10:18:26.385]                 NAMES <- toupper(removed)
[10:18:26.385]                 for (kk in seq_along(NAMES)) {
[10:18:26.385]                   name <- removed[[kk]]
[10:18:26.385]                   NAME <- NAMES[[kk]]
[10:18:26.385]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.385]                     next
[10:18:26.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.385]                 }
[10:18:26.385]                 if (length(args) > 0) 
[10:18:26.385]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.385]             }
[10:18:26.385]             else {
[10:18:26.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.385]             }
[10:18:26.385]             {
[10:18:26.385]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.385]                   0L) {
[10:18:26.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.385]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.385]                   base::options(opts)
[10:18:26.385]                 }
[10:18:26.385]                 {
[10:18:26.385]                   {
[10:18:26.385]                     NULL
[10:18:26.385]                     RNGkind("Mersenne-Twister")
[10:18:26.385]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:26.385]                       inherits = FALSE)
[10:18:26.385]                   }
[10:18:26.385]                   options(future.plan = NULL)
[10:18:26.385]                   if (is.na(NA_character_)) 
[10:18:26.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.385]                     .init = FALSE)
[10:18:26.385]                 }
[10:18:26.385]             }
[10:18:26.385]         }
[10:18:26.385]     })
[10:18:26.385]     if (TRUE) {
[10:18:26.385]         base::sink(type = "output", split = FALSE)
[10:18:26.385]         if (TRUE) {
[10:18:26.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.385]         }
[10:18:26.385]         else {
[10:18:26.385]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.385]         }
[10:18:26.385]         base::close(...future.stdout)
[10:18:26.385]         ...future.stdout <- NULL
[10:18:26.385]     }
[10:18:26.385]     ...future.result$conditions <- ...future.conditions
[10:18:26.385]     ...future.result$finished <- base::Sys.time()
[10:18:26.385]     ...future.result
[10:18:26.385] }
[10:18:26.387] assign_globals() ...
[10:18:26.387] List of 5
[10:18:26.387]  $ future.call.arguments    : list()
[10:18:26.387]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.387]  $ ...future.FUN            :function (x)  
[10:18:26.387]  $ ...future.elements_ii    :List of 6
[10:18:26.387]   ..$ : int [1:4] 1 7 13 19
[10:18:26.387]   ..$ : int [1:4] 2 8 14 20
[10:18:26.387]   ..$ : int [1:4] 3 9 15 21
[10:18:26.387]   ..$ : int [1:4] 4 10 16 22
[10:18:26.387]   ..$ : int [1:4] 5 11 17 23
[10:18:26.387]   ..$ : int [1:4] 6 12 18 24
[10:18:26.387]  $ ...future.seeds_ii       : NULL
[10:18:26.387]  $ ...future.globals.maxSize: num Inf
[10:18:26.387]  - attr(*, "resolved")= logi FALSE
[10:18:26.387]  - attr(*, "total_size")= num NA
[10:18:26.387]  - attr(*, "where")=List of 5
[10:18:26.387]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.387]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.387]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.387]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.387]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.387]  - attr(*, "already-done")= logi TRUE
[10:18:26.394] - copied ‘future.call.arguments’ to environment
[10:18:26.394] - reassign environment for ‘...future.FUN’
[10:18:26.394] - copied ‘...future.FUN’ to environment
[10:18:26.394] - copied ‘...future.elements_ii’ to environment
[10:18:26.395] - copied ‘...future.seeds_ii’ to environment
[10:18:26.395] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.395] assign_globals() ... done
[10:18:26.395] plan(): Setting new future strategy stack:
[10:18:26.395] List of future strategies:
[10:18:26.395] 1. sequential:
[10:18:26.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.395]    - tweaked: FALSE
[10:18:26.395]    - call: NULL
[10:18:26.395] plan(): nbrOfWorkers() = 1
[10:18:26.396] plan(): Setting new future strategy stack:
[10:18:26.396] List of future strategies:
[10:18:26.396] 1. sequential:
[10:18:26.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.396]    - tweaked: FALSE
[10:18:26.396]    - call: plan(strategy)
[10:18:26.397] plan(): nbrOfWorkers() = 1
[10:18:26.397] SequentialFuture started (and completed)
[10:18:26.397] - Launch lazy future ... done
[10:18:26.397] run() for ‘SequentialFuture’ ... done
[10:18:26.397] Created future:
[10:18:26.397] SequentialFuture:
[10:18:26.397] Label: ‘future_apply-1’
[10:18:26.397] Expression:
[10:18:26.397] {
[10:18:26.397]     do.call(function(...) {
[10:18:26.397]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.397]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.397]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.397]             on.exit(options(oopts), add = TRUE)
[10:18:26.397]         }
[10:18:26.397]         {
[10:18:26.397]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.397]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.397]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.397]             })
[10:18:26.397]         }
[10:18:26.397]     }, args = future.call.arguments)
[10:18:26.397] }
[10:18:26.397] Lazy evaluation: FALSE
[10:18:26.397] Asynchronous evaluation: FALSE
[10:18:26.397] Local evaluation: TRUE
[10:18:26.397] Environment: R_GlobalEnv
[10:18:26.397] Capture standard output: TRUE
[10:18:26.397] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.397] Globals: 5 objects totaling 749 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 175 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.397] Packages: <none>
[10:18:26.397] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.397] Resolved: TRUE
[10:18:26.397] Value: 521 bytes of class ‘list’
[10:18:26.397] Early signaling: FALSE
[10:18:26.397] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.397] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.398] Chunk #1 of 1 ... DONE
[10:18:26.398] Launching 1 futures (chunks) ... DONE
[10:18:26.398] Resolving 1 futures (chunks) ...
[10:18:26.398] resolve() on list ...
[10:18:26.399]  recursive: 0
[10:18:26.399]  length: 1
[10:18:26.399] 
[10:18:26.399] resolved() for ‘SequentialFuture’ ...
[10:18:26.399] - state: ‘finished’
[10:18:26.399] - run: TRUE
[10:18:26.399] - result: ‘FutureResult’
[10:18:26.399] resolved() for ‘SequentialFuture’ ... done
[10:18:26.399] Future #1
[10:18:26.399] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.399] - nx: 1
[10:18:26.400] - relay: TRUE
[10:18:26.400] - stdout: TRUE
[10:18:26.400] - signal: TRUE
[10:18:26.400] - resignal: FALSE
[10:18:26.400] - force: TRUE
[10:18:26.400] - relayed: [n=1] FALSE
[10:18:26.400] - queued futures: [n=1] FALSE
[10:18:26.400]  - until=1
[10:18:26.400]  - relaying element #1
[10:18:26.400] - relayed: [n=1] TRUE
[10:18:26.400] - queued futures: [n=1] TRUE
[10:18:26.401] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.401]  length: 0 (resolved future 1)
[10:18:26.401] Relaying remaining futures
[10:18:26.401] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.401] - nx: 1
[10:18:26.401] - relay: TRUE
[10:18:26.401] - stdout: TRUE
[10:18:26.401] - signal: TRUE
[10:18:26.401] - resignal: FALSE
[10:18:26.401] - force: TRUE
[10:18:26.401] - relayed: [n=1] TRUE
[10:18:26.401] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.402] - relayed: [n=1] TRUE
[10:18:26.402] - queued futures: [n=1] TRUE
[10:18:26.402] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.402] resolve() on list ... DONE
[10:18:26.402]  - Number of value chunks collected: 1
[10:18:26.402] Resolving 1 futures (chunks) ... DONE
[10:18:26.402] Reducing values from 1 chunks ...
[10:18:26.402]  - Number of values collected after concatenation: 6
[10:18:26.402]  - Number of values expected: 6
[10:18:26.402] Reducing values from 1 chunks ... DONE
[10:18:26.402] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:18:26.403] getGlobalsAndPackagesXApply() ...
[10:18:26.403]  - future.globals: TRUE
[10:18:26.403] getGlobalsAndPackages() ...
[10:18:26.403] Searching for globals...
[10:18:26.404] - globals found: [1] ‘FUN’
[10:18:26.404] Searching for globals ... DONE
[10:18:26.404] Resolving globals: FALSE
[10:18:26.404] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:26.405] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:26.405] - globals: [1] ‘FUN’
[10:18:26.405] 
[10:18:26.405] getGlobalsAndPackages() ... DONE
[10:18:26.405]  - globals found/used: [n=1] ‘FUN’
[10:18:26.405]  - needed namespaces: [n=0] 
[10:18:26.405] Finding globals ... DONE
[10:18:26.405]  - use_args: TRUE
[10:18:26.405]  - Getting '...' globals ...
[10:18:26.406] resolve() on list ...
[10:18:26.406]  recursive: 0
[10:18:26.406]  length: 1
[10:18:26.406]  elements: ‘...’
[10:18:26.406]  length: 0 (resolved future 1)
[10:18:26.406] resolve() on list ... DONE
[10:18:26.406]    - '...' content: [n=0] 
[10:18:26.406] List of 1
[10:18:26.406]  $ ...: list()
[10:18:26.406]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.406]  - attr(*, "where")=List of 1
[10:18:26.406]   ..$ ...:<environment: 0x556e039fab40> 
[10:18:26.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.406]  - attr(*, "resolved")= logi TRUE
[10:18:26.406]  - attr(*, "total_size")= num NA
[10:18:26.409]  - Getting '...' globals ... DONE
[10:18:26.409] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.409] List of 2
[10:18:26.409]  $ ...future.FUN:function (x)  
[10:18:26.409]  $ ...          : list()
[10:18:26.409]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.409]  - attr(*, "where")=List of 2
[10:18:26.409]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.409]   ..$ ...          :<environment: 0x556e039fab40> 
[10:18:26.409]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.409]  - attr(*, "resolved")= logi FALSE
[10:18:26.409]  - attr(*, "total_size")= num 2547
[10:18:26.443] Packages to be attached in all futures: [n=0] 
[10:18:26.443] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.443] future_lapply() ...
[10:18:26.444] Number of chunks: 1
[10:18:26.444] getGlobalsAndPackagesXApply() ...
[10:18:26.444]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.444]  - use_args: TRUE
[10:18:26.444] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.444] List of 2
[10:18:26.444]  $ ...          : list()
[10:18:26.444]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.444]  $ ...future.FUN:function (x)  
[10:18:26.444]  - attr(*, "where")=List of 2
[10:18:26.444]   ..$ ...          :<environment: 0x556e039fab40> 
[10:18:26.444]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:26.444]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.444]  - attr(*, "resolved")= logi FALSE
[10:18:26.444]  - attr(*, "total_size")= num NA
[10:18:26.447] Packages to be attached in all futures: [n=0] 
[10:18:26.447] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.448] Number of futures (= number of chunks): 1
[10:18:26.448] Launching 1 futures (chunks) ...
[10:18:26.448] Chunk #1 of 1 ...
[10:18:26.448]  - seeds: <none>
[10:18:26.448]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.448] getGlobalsAndPackages() ...
[10:18:26.448] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.448] Resolving globals: FALSE
[10:18:26.449] Tweak future expression to call with '...' arguments ...
[10:18:26.449] {
[10:18:26.449]     do.call(function(...) {
[10:18:26.449]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.449]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.449]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.449]             on.exit(options(oopts), add = TRUE)
[10:18:26.449]         }
[10:18:26.449]         {
[10:18:26.449]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.449]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.449]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.449]             })
[10:18:26.449]         }
[10:18:26.449]     }, args = future.call.arguments)
[10:18:26.449] }
[10:18:26.449] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.449] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.449] 
[10:18:26.449] getGlobalsAndPackages() ... DONE
[10:18:26.450] run() for ‘Future’ ...
[10:18:26.450] - state: ‘created’
[10:18:26.450] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.450] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.450]   - Field: ‘label’
[10:18:26.451]   - Field: ‘local’
[10:18:26.451]   - Field: ‘owner’
[10:18:26.451]   - Field: ‘envir’
[10:18:26.451]   - Field: ‘packages’
[10:18:26.451]   - Field: ‘gc’
[10:18:26.451]   - Field: ‘conditions’
[10:18:26.451]   - Field: ‘expr’
[10:18:26.451]   - Field: ‘uuid’
[10:18:26.451]   - Field: ‘seed’
[10:18:26.451]   - Field: ‘version’
[10:18:26.451]   - Field: ‘result’
[10:18:26.452]   - Field: ‘asynchronous’
[10:18:26.452]   - Field: ‘calls’
[10:18:26.452]   - Field: ‘globals’
[10:18:26.452]   - Field: ‘stdout’
[10:18:26.452]   - Field: ‘earlySignal’
[10:18:26.452]   - Field: ‘lazy’
[10:18:26.452]   - Field: ‘state’
[10:18:26.452] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.452] - Launch lazy future ...
[10:18:26.452] Packages needed by the future expression (n = 0): <none>
[10:18:26.453] Packages needed by future strategies (n = 0): <none>
[10:18:26.453] {
[10:18:26.453]     {
[10:18:26.453]         {
[10:18:26.453]             ...future.startTime <- base::Sys.time()
[10:18:26.453]             {
[10:18:26.453]                 {
[10:18:26.453]                   {
[10:18:26.453]                     base::local({
[10:18:26.453]                       has_future <- base::requireNamespace("future", 
[10:18:26.453]                         quietly = TRUE)
[10:18:26.453]                       if (has_future) {
[10:18:26.453]                         ns <- base::getNamespace("future")
[10:18:26.453]                         version <- ns[[".package"]][["version"]]
[10:18:26.453]                         if (is.null(version)) 
[10:18:26.453]                           version <- utils::packageVersion("future")
[10:18:26.453]                       }
[10:18:26.453]                       else {
[10:18:26.453]                         version <- NULL
[10:18:26.453]                       }
[10:18:26.453]                       if (!has_future || version < "1.8.0") {
[10:18:26.453]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.453]                           "", base::R.version$version.string), 
[10:18:26.453]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:26.453]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.453]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.453]                             "release", "version")], collapse = " "), 
[10:18:26.453]                           hostname = base::Sys.info()[["nodename"]])
[10:18:26.453]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.453]                           info)
[10:18:26.453]                         info <- base::paste(info, collapse = "; ")
[10:18:26.453]                         if (!has_future) {
[10:18:26.453]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.453]                             info)
[10:18:26.453]                         }
[10:18:26.453]                         else {
[10:18:26.453]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.453]                             info, version)
[10:18:26.453]                         }
[10:18:26.453]                         base::stop(msg)
[10:18:26.453]                       }
[10:18:26.453]                     })
[10:18:26.453]                   }
[10:18:26.453]                   ...future.strategy.old <- future::plan("list")
[10:18:26.453]                   options(future.plan = NULL)
[10:18:26.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.453]                 }
[10:18:26.453]                 ...future.workdir <- getwd()
[10:18:26.453]             }
[10:18:26.453]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.453]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.453]         }
[10:18:26.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.453]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.453]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.453]             base::names(...future.oldOptions))
[10:18:26.453]     }
[10:18:26.453]     if (FALSE) {
[10:18:26.453]     }
[10:18:26.453]     else {
[10:18:26.453]         if (TRUE) {
[10:18:26.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.453]                 open = "w")
[10:18:26.453]         }
[10:18:26.453]         else {
[10:18:26.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.453]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.453]         }
[10:18:26.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.453]             base::sink(type = "output", split = FALSE)
[10:18:26.453]             base::close(...future.stdout)
[10:18:26.453]         }, add = TRUE)
[10:18:26.453]     }
[10:18:26.453]     ...future.frame <- base::sys.nframe()
[10:18:26.453]     ...future.conditions <- base::list()
[10:18:26.453]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.453]     if (FALSE) {
[10:18:26.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.453]     }
[10:18:26.453]     ...future.result <- base::tryCatch({
[10:18:26.453]         base::withCallingHandlers({
[10:18:26.453]             ...future.value <- base::withVisible(base::local({
[10:18:26.453]                 do.call(function(...) {
[10:18:26.453]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.453]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.453]                     ...future.globals.maxSize)) {
[10:18:26.453]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.453]                     on.exit(options(oopts), add = TRUE)
[10:18:26.453]                   }
[10:18:26.453]                   {
[10:18:26.453]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.453]                       FUN = function(jj) {
[10:18:26.453]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.453]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.453]                       })
[10:18:26.453]                   }
[10:18:26.453]                 }, args = future.call.arguments)
[10:18:26.453]             }))
[10:18:26.453]             future::FutureResult(value = ...future.value$value, 
[10:18:26.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.453]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.453]                     ...future.globalenv.names))
[10:18:26.453]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.453]         }, condition = base::local({
[10:18:26.453]             c <- base::c
[10:18:26.453]             inherits <- base::inherits
[10:18:26.453]             invokeRestart <- base::invokeRestart
[10:18:26.453]             length <- base::length
[10:18:26.453]             list <- base::list
[10:18:26.453]             seq.int <- base::seq.int
[10:18:26.453]             signalCondition <- base::signalCondition
[10:18:26.453]             sys.calls <- base::sys.calls
[10:18:26.453]             `[[` <- base::`[[`
[10:18:26.453]             `+` <- base::`+`
[10:18:26.453]             `<<-` <- base::`<<-`
[10:18:26.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.453]                   3L)]
[10:18:26.453]             }
[10:18:26.453]             function(cond) {
[10:18:26.453]                 is_error <- inherits(cond, "error")
[10:18:26.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.453]                   NULL)
[10:18:26.453]                 if (is_error) {
[10:18:26.453]                   sessionInformation <- function() {
[10:18:26.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.453]                       search = base::search(), system = base::Sys.info())
[10:18:26.453]                   }
[10:18:26.453]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.453]                     cond$call), session = sessionInformation(), 
[10:18:26.453]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.453]                   signalCondition(cond)
[10:18:26.453]                 }
[10:18:26.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.453]                 "immediateCondition"))) {
[10:18:26.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.453]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.453]                   if (TRUE && !signal) {
[10:18:26.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.453]                     {
[10:18:26.453]                       inherits <- base::inherits
[10:18:26.453]                       invokeRestart <- base::invokeRestart
[10:18:26.453]                       is.null <- base::is.null
[10:18:26.453]                       muffled <- FALSE
[10:18:26.453]                       if (inherits(cond, "message")) {
[10:18:26.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.453]                         if (muffled) 
[10:18:26.453]                           invokeRestart("muffleMessage")
[10:18:26.453]                       }
[10:18:26.453]                       else if (inherits(cond, "warning")) {
[10:18:26.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.453]                         if (muffled) 
[10:18:26.453]                           invokeRestart("muffleWarning")
[10:18:26.453]                       }
[10:18:26.453]                       else if (inherits(cond, "condition")) {
[10:18:26.453]                         if (!is.null(pattern)) {
[10:18:26.453]                           computeRestarts <- base::computeRestarts
[10:18:26.453]                           grepl <- base::grepl
[10:18:26.453]                           restarts <- computeRestarts(cond)
[10:18:26.453]                           for (restart in restarts) {
[10:18:26.453]                             name <- restart$name
[10:18:26.453]                             if (is.null(name)) 
[10:18:26.453]                               next
[10:18:26.453]                             if (!grepl(pattern, name)) 
[10:18:26.453]                               next
[10:18:26.453]                             invokeRestart(restart)
[10:18:26.453]                             muffled <- TRUE
[10:18:26.453]                             break
[10:18:26.453]                           }
[10:18:26.453]                         }
[10:18:26.453]                       }
[10:18:26.453]                       invisible(muffled)
[10:18:26.453]                     }
[10:18:26.453]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.453]                   }
[10:18:26.453]                 }
[10:18:26.453]                 else {
[10:18:26.453]                   if (TRUE) {
[10:18:26.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.453]                     {
[10:18:26.453]                       inherits <- base::inherits
[10:18:26.453]                       invokeRestart <- base::invokeRestart
[10:18:26.453]                       is.null <- base::is.null
[10:18:26.453]                       muffled <- FALSE
[10:18:26.453]                       if (inherits(cond, "message")) {
[10:18:26.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.453]                         if (muffled) 
[10:18:26.453]                           invokeRestart("muffleMessage")
[10:18:26.453]                       }
[10:18:26.453]                       else if (inherits(cond, "warning")) {
[10:18:26.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.453]                         if (muffled) 
[10:18:26.453]                           invokeRestart("muffleWarning")
[10:18:26.453]                       }
[10:18:26.453]                       else if (inherits(cond, "condition")) {
[10:18:26.453]                         if (!is.null(pattern)) {
[10:18:26.453]                           computeRestarts <- base::computeRestarts
[10:18:26.453]                           grepl <- base::grepl
[10:18:26.453]                           restarts <- computeRestarts(cond)
[10:18:26.453]                           for (restart in restarts) {
[10:18:26.453]                             name <- restart$name
[10:18:26.453]                             if (is.null(name)) 
[10:18:26.453]                               next
[10:18:26.453]                             if (!grepl(pattern, name)) 
[10:18:26.453]                               next
[10:18:26.453]                             invokeRestart(restart)
[10:18:26.453]                             muffled <- TRUE
[10:18:26.453]                             break
[10:18:26.453]                           }
[10:18:26.453]                         }
[10:18:26.453]                       }
[10:18:26.453]                       invisible(muffled)
[10:18:26.453]                     }
[10:18:26.453]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.453]                   }
[10:18:26.453]                 }
[10:18:26.453]             }
[10:18:26.453]         }))
[10:18:26.453]     }, error = function(ex) {
[10:18:26.453]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.453]                 ...future.rng), started = ...future.startTime, 
[10:18:26.453]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.453]             version = "1.8"), class = "FutureResult")
[10:18:26.453]     }, finally = {
[10:18:26.453]         if (!identical(...future.workdir, getwd())) 
[10:18:26.453]             setwd(...future.workdir)
[10:18:26.453]         {
[10:18:26.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.453]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.453]             }
[10:18:26.453]             base::options(...future.oldOptions)
[10:18:26.453]             if (.Platform$OS.type == "windows") {
[10:18:26.453]                 old_names <- names(...future.oldEnvVars)
[10:18:26.453]                 envs <- base::Sys.getenv()
[10:18:26.453]                 names <- names(envs)
[10:18:26.453]                 common <- intersect(names, old_names)
[10:18:26.453]                 added <- setdiff(names, old_names)
[10:18:26.453]                 removed <- setdiff(old_names, names)
[10:18:26.453]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.453]                   envs[common]]
[10:18:26.453]                 NAMES <- toupper(changed)
[10:18:26.453]                 args <- list()
[10:18:26.453]                 for (kk in seq_along(NAMES)) {
[10:18:26.453]                   name <- changed[[kk]]
[10:18:26.453]                   NAME <- NAMES[[kk]]
[10:18:26.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.453]                     next
[10:18:26.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.453]                 }
[10:18:26.453]                 NAMES <- toupper(added)
[10:18:26.453]                 for (kk in seq_along(NAMES)) {
[10:18:26.453]                   name <- added[[kk]]
[10:18:26.453]                   NAME <- NAMES[[kk]]
[10:18:26.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.453]                     next
[10:18:26.453]                   args[[name]] <- ""
[10:18:26.453]                 }
[10:18:26.453]                 NAMES <- toupper(removed)
[10:18:26.453]                 for (kk in seq_along(NAMES)) {
[10:18:26.453]                   name <- removed[[kk]]
[10:18:26.453]                   NAME <- NAMES[[kk]]
[10:18:26.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.453]                     next
[10:18:26.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.453]                 }
[10:18:26.453]                 if (length(args) > 0) 
[10:18:26.453]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.453]             }
[10:18:26.453]             else {
[10:18:26.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.453]             }
[10:18:26.453]             {
[10:18:26.453]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.453]                   0L) {
[10:18:26.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.453]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.453]                   base::options(opts)
[10:18:26.453]                 }
[10:18:26.453]                 {
[10:18:26.453]                   {
[10:18:26.453]                     NULL
[10:18:26.453]                     RNGkind("Mersenne-Twister")
[10:18:26.453]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:26.453]                       inherits = FALSE)
[10:18:26.453]                   }
[10:18:26.453]                   options(future.plan = NULL)
[10:18:26.453]                   if (is.na(NA_character_)) 
[10:18:26.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.453]                     .init = FALSE)
[10:18:26.453]                 }
[10:18:26.453]             }
[10:18:26.453]         }
[10:18:26.453]     })
[10:18:26.453]     if (TRUE) {
[10:18:26.453]         base::sink(type = "output", split = FALSE)
[10:18:26.453]         if (TRUE) {
[10:18:26.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.453]         }
[10:18:26.453]         else {
[10:18:26.453]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.453]         }
[10:18:26.453]         base::close(...future.stdout)
[10:18:26.453]         ...future.stdout <- NULL
[10:18:26.453]     }
[10:18:26.453]     ...future.result$conditions <- ...future.conditions
[10:18:26.453]     ...future.result$finished <- base::Sys.time()
[10:18:26.453]     ...future.result
[10:18:26.453] }
[10:18:26.455] assign_globals() ...
[10:18:26.455] List of 5
[10:18:26.455]  $ future.call.arguments    : list()
[10:18:26.455]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.455]  $ ...future.FUN            :function (x)  
[10:18:26.455]  $ ...future.elements_ii    :List of 2
[10:18:26.455]   ..$ : int 1
[10:18:26.455]   ..$ : int 2
[10:18:26.455]  $ ...future.seeds_ii       : NULL
[10:18:26.455]  $ ...future.globals.maxSize: num Inf
[10:18:26.455]  - attr(*, "resolved")= logi FALSE
[10:18:26.455]  - attr(*, "total_size")= num NA
[10:18:26.455]  - attr(*, "where")=List of 5
[10:18:26.455]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.455]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.455]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.455]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.455]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.455]  - attr(*, "already-done")= logi TRUE
[10:18:26.460] - copied ‘future.call.arguments’ to environment
[10:18:26.460] - copied ‘...future.FUN’ to environment
[10:18:26.460] - copied ‘...future.elements_ii’ to environment
[10:18:26.460] - copied ‘...future.seeds_ii’ to environment
[10:18:26.460] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.460] assign_globals() ... done
[10:18:26.460] plan(): Setting new future strategy stack:
[10:18:26.461] List of future strategies:
[10:18:26.461] 1. sequential:
[10:18:26.461]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.461]    - tweaked: FALSE
[10:18:26.461]    - call: NULL
[10:18:26.461] plan(): nbrOfWorkers() = 1
[10:18:26.462] plan(): Setting new future strategy stack:
[10:18:26.462] List of future strategies:
[10:18:26.462] 1. sequential:
[10:18:26.462]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.462]    - tweaked: FALSE
[10:18:26.462]    - call: plan(strategy)
[10:18:26.462] plan(): nbrOfWorkers() = 1
[10:18:26.462] SequentialFuture started (and completed)
[10:18:26.463] - Launch lazy future ... done
[10:18:26.463] run() for ‘SequentialFuture’ ... done
[10:18:26.463] Created future:
[10:18:26.463] SequentialFuture:
[10:18:26.463] Label: ‘future_apply-1’
[10:18:26.463] Expression:
[10:18:26.463] {
[10:18:26.463]     do.call(function(...) {
[10:18:26.463]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.463]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.463]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.463]             on.exit(options(oopts), add = TRUE)
[10:18:26.463]         }
[10:18:26.463]         {
[10:18:26.463]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.463]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.463]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.463]             })
[10:18:26.463]         }
[10:18:26.463]     }, args = future.call.arguments)
[10:18:26.463] }
[10:18:26.463] Lazy evaluation: FALSE
[10:18:26.463] Asynchronous evaluation: FALSE
[10:18:26.463] Local evaluation: TRUE
[10:18:26.463] Environment: R_GlobalEnv
[10:18:26.463] Capture standard output: TRUE
[10:18:26.463] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.463] Globals: 5 objects totaling 403 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 55 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.463] Packages: <none>
[10:18:26.463] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.463] Resolved: TRUE
[10:18:26.463] Value: 55 bytes of class ‘list’
[10:18:26.463] Early signaling: FALSE
[10:18:26.463] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.463] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.464] Chunk #1 of 1 ... DONE
[10:18:26.464] Launching 1 futures (chunks) ... DONE
[10:18:26.464] Resolving 1 futures (chunks) ...
[10:18:26.464] resolve() on list ...
[10:18:26.464]  recursive: 0
[10:18:26.464]  length: 1
[10:18:26.464] 
[10:18:26.464] resolved() for ‘SequentialFuture’ ...
[10:18:26.464] - state: ‘finished’
[10:18:26.465] - run: TRUE
[10:18:26.465] - result: ‘FutureResult’
[10:18:26.465] resolved() for ‘SequentialFuture’ ... done
[10:18:26.465] Future #1
[10:18:26.466] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.466] - nx: 1
[10:18:26.466] - relay: TRUE
[10:18:26.466] - stdout: TRUE
[10:18:26.467] - signal: TRUE
[10:18:26.467] - resignal: FALSE
[10:18:26.467] - force: TRUE
[10:18:26.467] - relayed: [n=1] FALSE
[10:18:26.467] - queued futures: [n=1] FALSE
[10:18:26.467]  - until=1
[10:18:26.467]  - relaying element #1
[10:18:26.467] - relayed: [n=1] TRUE
[10:18:26.467] - queued futures: [n=1] TRUE
[10:18:26.468] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.468]  length: 0 (resolved future 1)
[10:18:26.468] Relaying remaining futures
[10:18:26.468] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.468] - nx: 1
[10:18:26.468] - relay: TRUE
[10:18:26.468] - stdout: TRUE
[10:18:26.468] - signal: TRUE
[10:18:26.468] - resignal: FALSE
[10:18:26.468] - force: TRUE
[10:18:26.468] - relayed: [n=1] TRUE
[10:18:26.468] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.469] - relayed: [n=1] TRUE
[10:18:26.469] - queued futures: [n=1] TRUE
[10:18:26.469] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.469] resolve() on list ... DONE
[10:18:26.469]  - Number of value chunks collected: 1
[10:18:26.469] Resolving 1 futures (chunks) ... DONE
[10:18:26.469] Reducing values from 1 chunks ...
[10:18:26.469]  - Number of values collected after concatenation: 2
[10:18:26.469]  - Number of values expected: 2
[10:18:26.469] Reducing values from 1 chunks ... DONE
[10:18:26.469] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:18:26.470] getGlobalsAndPackagesXApply() ...
[10:18:26.470]  - future.globals: TRUE
[10:18:26.470] getGlobalsAndPackages() ...
[10:18:26.470] Searching for globals...
[10:18:26.471] - globals found: [1] ‘FUN’
[10:18:26.471] Searching for globals ... DONE
[10:18:26.471] Resolving globals: FALSE
[10:18:26.472] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:26.472] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:26.472] - globals: [1] ‘FUN’
[10:18:26.472] 
[10:18:26.472] getGlobalsAndPackages() ... DONE
[10:18:26.472]  - globals found/used: [n=1] ‘FUN’
[10:18:26.472]  - needed namespaces: [n=0] 
[10:18:26.472] Finding globals ... DONE
[10:18:26.473]  - use_args: TRUE
[10:18:26.473]  - Getting '...' globals ...
[10:18:26.473] resolve() on list ...
[10:18:26.473]  recursive: 0
[10:18:26.473]  length: 1
[10:18:26.473]  elements: ‘...’
[10:18:26.473]  length: 0 (resolved future 1)
[10:18:26.473] resolve() on list ... DONE
[10:18:26.473]    - '...' content: [n=0] 
[10:18:26.474] List of 1
[10:18:26.474]  $ ...: list()
[10:18:26.474]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.474]  - attr(*, "where")=List of 1
[10:18:26.474]   ..$ ...:<environment: 0x556e022b69b0> 
[10:18:26.474]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.474]  - attr(*, "resolved")= logi TRUE
[10:18:26.474]  - attr(*, "total_size")= num NA
[10:18:26.476]  - Getting '...' globals ... DONE
[10:18:26.476] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.476] List of 2
[10:18:26.476]  $ ...future.FUN:function (x)  
[10:18:26.476]  $ ...          : list()
[10:18:26.476]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.476]  - attr(*, "where")=List of 2
[10:18:26.476]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.476]   ..$ ...          :<environment: 0x556e022b69b0> 
[10:18:26.476]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.476]  - attr(*, "resolved")= logi FALSE
[10:18:26.476]  - attr(*, "total_size")= num 2274
[10:18:26.479] Packages to be attached in all futures: [n=0] 
[10:18:26.479] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.479] future_lapply() ...
[10:18:26.479] Number of chunks: 1
[10:18:26.480] getGlobalsAndPackagesXApply() ...
[10:18:26.480]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.480]  - use_args: TRUE
[10:18:26.480] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.480] List of 2
[10:18:26.480]  $ ...          : list()
[10:18:26.480]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.480]  $ ...future.FUN:function (x)  
[10:18:26.480]  - attr(*, "where")=List of 2
[10:18:26.480]   ..$ ...          :<environment: 0x556e022b69b0> 
[10:18:26.480]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:26.480]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.480]  - attr(*, "resolved")= logi FALSE
[10:18:26.480]  - attr(*, "total_size")= num NA
[10:18:26.483] Packages to be attached in all futures: [n=0] 
[10:18:26.483] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.483] Number of futures (= number of chunks): 1
[10:18:26.484] Launching 1 futures (chunks) ...
[10:18:26.484] Chunk #1 of 1 ...
[10:18:26.484]  - seeds: <none>
[10:18:26.484]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.484] getGlobalsAndPackages() ...
[10:18:26.484] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.484] Resolving globals: FALSE
[10:18:26.484] Tweak future expression to call with '...' arguments ...
[10:18:26.484] {
[10:18:26.484]     do.call(function(...) {
[10:18:26.484]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.484]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.484]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.484]             on.exit(options(oopts), add = TRUE)
[10:18:26.484]         }
[10:18:26.484]         {
[10:18:26.484]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.484]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.484]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.484]             })
[10:18:26.484]         }
[10:18:26.484]     }, args = future.call.arguments)
[10:18:26.484] }
[10:18:26.485] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.485] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.485] 
[10:18:26.485] getGlobalsAndPackages() ... DONE
[10:18:26.486] run() for ‘Future’ ...
[10:18:26.486] - state: ‘created’
[10:18:26.486] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.486] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.486]   - Field: ‘label’
[10:18:26.486]   - Field: ‘local’
[10:18:26.486]   - Field: ‘owner’
[10:18:26.487]   - Field: ‘envir’
[10:18:26.487]   - Field: ‘packages’
[10:18:26.487]   - Field: ‘gc’
[10:18:26.487]   - Field: ‘conditions’
[10:18:26.487]   - Field: ‘expr’
[10:18:26.487]   - Field: ‘uuid’
[10:18:26.487]   - Field: ‘seed’
[10:18:26.487]   - Field: ‘version’
[10:18:26.487]   - Field: ‘result’
[10:18:26.487]   - Field: ‘asynchronous’
[10:18:26.487]   - Field: ‘calls’
[10:18:26.487]   - Field: ‘globals’
[10:18:26.488]   - Field: ‘stdout’
[10:18:26.488]   - Field: ‘earlySignal’
[10:18:26.488]   - Field: ‘lazy’
[10:18:26.488]   - Field: ‘state’
[10:18:26.488] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.488] - Launch lazy future ...
[10:18:26.488] Packages needed by the future expression (n = 0): <none>
[10:18:26.488] Packages needed by future strategies (n = 0): <none>
[10:18:26.490] {
[10:18:26.490]     {
[10:18:26.490]         {
[10:18:26.490]             ...future.startTime <- base::Sys.time()
[10:18:26.490]             {
[10:18:26.490]                 {
[10:18:26.490]                   {
[10:18:26.490]                     base::local({
[10:18:26.490]                       has_future <- base::requireNamespace("future", 
[10:18:26.490]                         quietly = TRUE)
[10:18:26.490]                       if (has_future) {
[10:18:26.490]                         ns <- base::getNamespace("future")
[10:18:26.490]                         version <- ns[[".package"]][["version"]]
[10:18:26.490]                         if (is.null(version)) 
[10:18:26.490]                           version <- utils::packageVersion("future")
[10:18:26.490]                       }
[10:18:26.490]                       else {
[10:18:26.490]                         version <- NULL
[10:18:26.490]                       }
[10:18:26.490]                       if (!has_future || version < "1.8.0") {
[10:18:26.490]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.490]                           "", base::R.version$version.string), 
[10:18:26.490]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:26.490]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.490]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.490]                             "release", "version")], collapse = " "), 
[10:18:26.490]                           hostname = base::Sys.info()[["nodename"]])
[10:18:26.490]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.490]                           info)
[10:18:26.490]                         info <- base::paste(info, collapse = "; ")
[10:18:26.490]                         if (!has_future) {
[10:18:26.490]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.490]                             info)
[10:18:26.490]                         }
[10:18:26.490]                         else {
[10:18:26.490]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.490]                             info, version)
[10:18:26.490]                         }
[10:18:26.490]                         base::stop(msg)
[10:18:26.490]                       }
[10:18:26.490]                     })
[10:18:26.490]                   }
[10:18:26.490]                   ...future.strategy.old <- future::plan("list")
[10:18:26.490]                   options(future.plan = NULL)
[10:18:26.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.490]                 }
[10:18:26.490]                 ...future.workdir <- getwd()
[10:18:26.490]             }
[10:18:26.490]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.490]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.490]         }
[10:18:26.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.490]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.490]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.490]             base::names(...future.oldOptions))
[10:18:26.490]     }
[10:18:26.490]     if (FALSE) {
[10:18:26.490]     }
[10:18:26.490]     else {
[10:18:26.490]         if (TRUE) {
[10:18:26.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.490]                 open = "w")
[10:18:26.490]         }
[10:18:26.490]         else {
[10:18:26.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.490]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.490]         }
[10:18:26.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.490]             base::sink(type = "output", split = FALSE)
[10:18:26.490]             base::close(...future.stdout)
[10:18:26.490]         }, add = TRUE)
[10:18:26.490]     }
[10:18:26.490]     ...future.frame <- base::sys.nframe()
[10:18:26.490]     ...future.conditions <- base::list()
[10:18:26.490]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.490]     if (FALSE) {
[10:18:26.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.490]     }
[10:18:26.490]     ...future.result <- base::tryCatch({
[10:18:26.490]         base::withCallingHandlers({
[10:18:26.490]             ...future.value <- base::withVisible(base::local({
[10:18:26.490]                 do.call(function(...) {
[10:18:26.490]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.490]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.490]                     ...future.globals.maxSize)) {
[10:18:26.490]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.490]                     on.exit(options(oopts), add = TRUE)
[10:18:26.490]                   }
[10:18:26.490]                   {
[10:18:26.490]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.490]                       FUN = function(jj) {
[10:18:26.490]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.490]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.490]                       })
[10:18:26.490]                   }
[10:18:26.490]                 }, args = future.call.arguments)
[10:18:26.490]             }))
[10:18:26.490]             future::FutureResult(value = ...future.value$value, 
[10:18:26.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.490]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.490]                     ...future.globalenv.names))
[10:18:26.490]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.490]         }, condition = base::local({
[10:18:26.490]             c <- base::c
[10:18:26.490]             inherits <- base::inherits
[10:18:26.490]             invokeRestart <- base::invokeRestart
[10:18:26.490]             length <- base::length
[10:18:26.490]             list <- base::list
[10:18:26.490]             seq.int <- base::seq.int
[10:18:26.490]             signalCondition <- base::signalCondition
[10:18:26.490]             sys.calls <- base::sys.calls
[10:18:26.490]             `[[` <- base::`[[`
[10:18:26.490]             `+` <- base::`+`
[10:18:26.490]             `<<-` <- base::`<<-`
[10:18:26.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.490]                   3L)]
[10:18:26.490]             }
[10:18:26.490]             function(cond) {
[10:18:26.490]                 is_error <- inherits(cond, "error")
[10:18:26.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.490]                   NULL)
[10:18:26.490]                 if (is_error) {
[10:18:26.490]                   sessionInformation <- function() {
[10:18:26.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.490]                       search = base::search(), system = base::Sys.info())
[10:18:26.490]                   }
[10:18:26.490]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.490]                     cond$call), session = sessionInformation(), 
[10:18:26.490]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.490]                   signalCondition(cond)
[10:18:26.490]                 }
[10:18:26.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.490]                 "immediateCondition"))) {
[10:18:26.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.490]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.490]                   if (TRUE && !signal) {
[10:18:26.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.490]                     {
[10:18:26.490]                       inherits <- base::inherits
[10:18:26.490]                       invokeRestart <- base::invokeRestart
[10:18:26.490]                       is.null <- base::is.null
[10:18:26.490]                       muffled <- FALSE
[10:18:26.490]                       if (inherits(cond, "message")) {
[10:18:26.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.490]                         if (muffled) 
[10:18:26.490]                           invokeRestart("muffleMessage")
[10:18:26.490]                       }
[10:18:26.490]                       else if (inherits(cond, "warning")) {
[10:18:26.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.490]                         if (muffled) 
[10:18:26.490]                           invokeRestart("muffleWarning")
[10:18:26.490]                       }
[10:18:26.490]                       else if (inherits(cond, "condition")) {
[10:18:26.490]                         if (!is.null(pattern)) {
[10:18:26.490]                           computeRestarts <- base::computeRestarts
[10:18:26.490]                           grepl <- base::grepl
[10:18:26.490]                           restarts <- computeRestarts(cond)
[10:18:26.490]                           for (restart in restarts) {
[10:18:26.490]                             name <- restart$name
[10:18:26.490]                             if (is.null(name)) 
[10:18:26.490]                               next
[10:18:26.490]                             if (!grepl(pattern, name)) 
[10:18:26.490]                               next
[10:18:26.490]                             invokeRestart(restart)
[10:18:26.490]                             muffled <- TRUE
[10:18:26.490]                             break
[10:18:26.490]                           }
[10:18:26.490]                         }
[10:18:26.490]                       }
[10:18:26.490]                       invisible(muffled)
[10:18:26.490]                     }
[10:18:26.490]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.490]                   }
[10:18:26.490]                 }
[10:18:26.490]                 else {
[10:18:26.490]                   if (TRUE) {
[10:18:26.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.490]                     {
[10:18:26.490]                       inherits <- base::inherits
[10:18:26.490]                       invokeRestart <- base::invokeRestart
[10:18:26.490]                       is.null <- base::is.null
[10:18:26.490]                       muffled <- FALSE
[10:18:26.490]                       if (inherits(cond, "message")) {
[10:18:26.490]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.490]                         if (muffled) 
[10:18:26.490]                           invokeRestart("muffleMessage")
[10:18:26.490]                       }
[10:18:26.490]                       else if (inherits(cond, "warning")) {
[10:18:26.490]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.490]                         if (muffled) 
[10:18:26.490]                           invokeRestart("muffleWarning")
[10:18:26.490]                       }
[10:18:26.490]                       else if (inherits(cond, "condition")) {
[10:18:26.490]                         if (!is.null(pattern)) {
[10:18:26.490]                           computeRestarts <- base::computeRestarts
[10:18:26.490]                           grepl <- base::grepl
[10:18:26.490]                           restarts <- computeRestarts(cond)
[10:18:26.490]                           for (restart in restarts) {
[10:18:26.490]                             name <- restart$name
[10:18:26.490]                             if (is.null(name)) 
[10:18:26.490]                               next
[10:18:26.490]                             if (!grepl(pattern, name)) 
[10:18:26.490]                               next
[10:18:26.490]                             invokeRestart(restart)
[10:18:26.490]                             muffled <- TRUE
[10:18:26.490]                             break
[10:18:26.490]                           }
[10:18:26.490]                         }
[10:18:26.490]                       }
[10:18:26.490]                       invisible(muffled)
[10:18:26.490]                     }
[10:18:26.490]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.490]                   }
[10:18:26.490]                 }
[10:18:26.490]             }
[10:18:26.490]         }))
[10:18:26.490]     }, error = function(ex) {
[10:18:26.490]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.490]                 ...future.rng), started = ...future.startTime, 
[10:18:26.490]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.490]             version = "1.8"), class = "FutureResult")
[10:18:26.490]     }, finally = {
[10:18:26.490]         if (!identical(...future.workdir, getwd())) 
[10:18:26.490]             setwd(...future.workdir)
[10:18:26.490]         {
[10:18:26.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.490]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.490]             }
[10:18:26.490]             base::options(...future.oldOptions)
[10:18:26.490]             if (.Platform$OS.type == "windows") {
[10:18:26.490]                 old_names <- names(...future.oldEnvVars)
[10:18:26.490]                 envs <- base::Sys.getenv()
[10:18:26.490]                 names <- names(envs)
[10:18:26.490]                 common <- intersect(names, old_names)
[10:18:26.490]                 added <- setdiff(names, old_names)
[10:18:26.490]                 removed <- setdiff(old_names, names)
[10:18:26.490]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.490]                   envs[common]]
[10:18:26.490]                 NAMES <- toupper(changed)
[10:18:26.490]                 args <- list()
[10:18:26.490]                 for (kk in seq_along(NAMES)) {
[10:18:26.490]                   name <- changed[[kk]]
[10:18:26.490]                   NAME <- NAMES[[kk]]
[10:18:26.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.490]                     next
[10:18:26.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.490]                 }
[10:18:26.490]                 NAMES <- toupper(added)
[10:18:26.490]                 for (kk in seq_along(NAMES)) {
[10:18:26.490]                   name <- added[[kk]]
[10:18:26.490]                   NAME <- NAMES[[kk]]
[10:18:26.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.490]                     next
[10:18:26.490]                   args[[name]] <- ""
[10:18:26.490]                 }
[10:18:26.490]                 NAMES <- toupper(removed)
[10:18:26.490]                 for (kk in seq_along(NAMES)) {
[10:18:26.490]                   name <- removed[[kk]]
[10:18:26.490]                   NAME <- NAMES[[kk]]
[10:18:26.490]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.490]                     next
[10:18:26.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.490]                 }
[10:18:26.490]                 if (length(args) > 0) 
[10:18:26.490]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.490]             }
[10:18:26.490]             else {
[10:18:26.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.490]             }
[10:18:26.490]             {
[10:18:26.490]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.490]                   0L) {
[10:18:26.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.490]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.490]                   base::options(opts)
[10:18:26.490]                 }
[10:18:26.490]                 {
[10:18:26.490]                   {
[10:18:26.490]                     NULL
[10:18:26.490]                     RNGkind("Mersenne-Twister")
[10:18:26.490]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:26.490]                       inherits = FALSE)
[10:18:26.490]                   }
[10:18:26.490]                   options(future.plan = NULL)
[10:18:26.490]                   if (is.na(NA_character_)) 
[10:18:26.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.490]                     .init = FALSE)
[10:18:26.490]                 }
[10:18:26.490]             }
[10:18:26.490]         }
[10:18:26.490]     })
[10:18:26.490]     if (TRUE) {
[10:18:26.490]         base::sink(type = "output", split = FALSE)
[10:18:26.490]         if (TRUE) {
[10:18:26.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.490]         }
[10:18:26.490]         else {
[10:18:26.490]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.490]         }
[10:18:26.490]         base::close(...future.stdout)
[10:18:26.490]         ...future.stdout <- NULL
[10:18:26.490]     }
[10:18:26.490]     ...future.result$conditions <- ...future.conditions
[10:18:26.490]     ...future.result$finished <- base::Sys.time()
[10:18:26.490]     ...future.result
[10:18:26.490] }
[10:18:26.492] assign_globals() ...
[10:18:26.492] List of 5
[10:18:26.492]  $ future.call.arguments    : list()
[10:18:26.492]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.492]  $ ...future.FUN            :function (x)  
[10:18:26.492]  $ ...future.elements_ii    :List of 2
[10:18:26.492]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[10:18:26.492]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[10:18:26.492]  $ ...future.seeds_ii       : NULL
[10:18:26.492]  $ ...future.globals.maxSize: num Inf
[10:18:26.492]  - attr(*, "resolved")= logi FALSE
[10:18:26.492]  - attr(*, "total_size")= num NA
[10:18:26.492]  - attr(*, "where")=List of 5
[10:18:26.492]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.492]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.492]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.492]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.492]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.492]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.492]  - attr(*, "already-done")= logi TRUE
[10:18:26.497] - copied ‘future.call.arguments’ to environment
[10:18:26.497] - copied ‘...future.FUN’ to environment
[10:18:26.497] - copied ‘...future.elements_ii’ to environment
[10:18:26.497] - copied ‘...future.seeds_ii’ to environment
[10:18:26.497] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.498] assign_globals() ... done
[10:18:26.498] plan(): Setting new future strategy stack:
[10:18:26.498] List of future strategies:
[10:18:26.498] 1. sequential:
[10:18:26.498]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.498]    - tweaked: FALSE
[10:18:26.498]    - call: NULL
[10:18:26.498] plan(): nbrOfWorkers() = 1
[10:18:26.499] plan(): Setting new future strategy stack:
[10:18:26.499] List of future strategies:
[10:18:26.499] 1. sequential:
[10:18:26.499]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.499]    - tweaked: FALSE
[10:18:26.499]    - call: plan(strategy)
[10:18:26.500] plan(): nbrOfWorkers() = 1
[10:18:26.500] SequentialFuture started (and completed)
[10:18:26.500] - Launch lazy future ... done
[10:18:26.500] run() for ‘SequentialFuture’ ... done
[10:18:26.500] Created future:
[10:18:26.500] SequentialFuture:
[10:18:26.500] Label: ‘future_apply-1’
[10:18:26.500] Expression:
[10:18:26.500] {
[10:18:26.500]     do.call(function(...) {
[10:18:26.500]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.500]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.500]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.500]             on.exit(options(oopts), add = TRUE)
[10:18:26.500]         }
[10:18:26.500]         {
[10:18:26.500]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.500]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.500]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.500]             })
[10:18:26.500]         }
[10:18:26.500]     }, args = future.call.arguments)
[10:18:26.500] }
[10:18:26.500] Lazy evaluation: FALSE
[10:18:26.500] Asynchronous evaluation: FALSE
[10:18:26.500] Local evaluation: TRUE
[10:18:26.500] Environment: R_GlobalEnv
[10:18:26.500] Capture standard output: TRUE
[10:18:26.500] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.500] Globals: 5 objects totaling 510 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 162 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.500] Packages: <none>
[10:18:26.500] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.500] Resolved: TRUE
[10:18:26.500] Value: 162 bytes of class ‘list’
[10:18:26.500] Early signaling: FALSE
[10:18:26.500] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.500] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.501] Chunk #1 of 1 ... DONE
[10:18:26.501] Launching 1 futures (chunks) ... DONE
[10:18:26.501] Resolving 1 futures (chunks) ...
[10:18:26.501] resolve() on list ...
[10:18:26.501]  recursive: 0
[10:18:26.501]  length: 1
[10:18:26.501] 
[10:18:26.502] resolved() for ‘SequentialFuture’ ...
[10:18:26.502] - state: ‘finished’
[10:18:26.502] - run: TRUE
[10:18:26.502] - result: ‘FutureResult’
[10:18:26.502] resolved() for ‘SequentialFuture’ ... done
[10:18:26.502] Future #1
[10:18:26.502] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.502] - nx: 1
[10:18:26.502] - relay: TRUE
[10:18:26.502] - stdout: TRUE
[10:18:26.502] - signal: TRUE
[10:18:26.503] - resignal: FALSE
[10:18:26.503] - force: TRUE
[10:18:26.503] - relayed: [n=1] FALSE
[10:18:26.503] - queued futures: [n=1] FALSE
[10:18:26.503]  - until=1
[10:18:26.503]  - relaying element #1
[10:18:26.503] - relayed: [n=1] TRUE
[10:18:26.503] - queued futures: [n=1] TRUE
[10:18:26.503] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.503]  length: 0 (resolved future 1)
[10:18:26.504] Relaying remaining futures
[10:18:26.504] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.504] - nx: 1
[10:18:26.504] - relay: TRUE
[10:18:26.504] - stdout: TRUE
[10:18:26.504] - signal: TRUE
[10:18:26.504] - resignal: FALSE
[10:18:26.504] - force: TRUE
[10:18:26.504] - relayed: [n=1] TRUE
[10:18:26.504] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.504] - relayed: [n=1] TRUE
[10:18:26.504] - queued futures: [n=1] TRUE
[10:18:26.504] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.505] resolve() on list ... DONE
[10:18:26.505]  - Number of value chunks collected: 1
[10:18:26.505] Resolving 1 futures (chunks) ... DONE
[10:18:26.505] Reducing values from 1 chunks ...
[10:18:26.505]  - Number of values collected after concatenation: 2
[10:18:26.505]  - Number of values expected: 2
[10:18:26.505] Reducing values from 1 chunks ... DONE
[10:18:26.505] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:18:26.506] getGlobalsAndPackagesXApply() ...
[10:18:26.506]  - future.globals: TRUE
[10:18:26.506] getGlobalsAndPackages() ...
[10:18:26.506] Searching for globals...
[10:18:26.508] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:18:26.508] Searching for globals ... DONE
[10:18:26.508] Resolving globals: FALSE
[10:18:26.509] The total size of the 1 globals is 1.28 KiB (1311 bytes)
[10:18:26.509] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 1.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.28 KiB of class ‘function’)
[10:18:26.509] - globals: [1] ‘FUN’
[10:18:26.509] 
[10:18:26.509] getGlobalsAndPackages() ... DONE
[10:18:26.510]  - globals found/used: [n=1] ‘FUN’
[10:18:26.510]  - needed namespaces: [n=0] 
[10:18:26.510] Finding globals ... DONE
[10:18:26.510]  - use_args: TRUE
[10:18:26.510]  - Getting '...' globals ...
[10:18:26.510] resolve() on list ...
[10:18:26.510]  recursive: 0
[10:18:26.510]  length: 1
[10:18:26.510]  elements: ‘...’
[10:18:26.511]  length: 0 (resolved future 1)
[10:18:26.511] resolve() on list ... DONE
[10:18:26.511]    - '...' content: [n=0] 
[10:18:26.511] List of 1
[10:18:26.511]  $ ...: list()
[10:18:26.511]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.511]  - attr(*, "where")=List of 1
[10:18:26.511]   ..$ ...:<environment: 0x556e038e43c8> 
[10:18:26.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.511]  - attr(*, "resolved")= logi TRUE
[10:18:26.511]  - attr(*, "total_size")= num NA
[10:18:26.514]  - Getting '...' globals ... DONE
[10:18:26.515] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.515] List of 2
[10:18:26.515]  $ ...future.FUN:function (x)  
[10:18:26.515]  $ ...          : list()
[10:18:26.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.515]  - attr(*, "where")=List of 2
[10:18:26.515]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.515]   ..$ ...          :<environment: 0x556e038e43c8> 
[10:18:26.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.515]  - attr(*, "resolved")= logi FALSE
[10:18:26.515]  - attr(*, "total_size")= num 4449
[10:18:26.518] Packages to be attached in all futures: [n=0] 
[10:18:26.518] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.518] future_lapply() ...
[10:18:26.519] Number of chunks: 1
[10:18:26.519] getGlobalsAndPackagesXApply() ...
[10:18:26.519]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.520]  - use_args: TRUE
[10:18:26.520] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.520] List of 2
[10:18:26.520]  $ ...          : list()
[10:18:26.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.520]  $ ...future.FUN:function (x)  
[10:18:26.520]  - attr(*, "where")=List of 2
[10:18:26.520]   ..$ ...          :<environment: 0x556e038e43c8> 
[10:18:26.520]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:18:26.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.520]  - attr(*, "resolved")= logi FALSE
[10:18:26.520]  - attr(*, "total_size")= num NA
[10:18:26.523] Packages to be attached in all futures: [n=0] 
[10:18:26.523] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.523] Number of futures (= number of chunks): 1
[10:18:26.523] Launching 1 futures (chunks) ...
[10:18:26.523] Chunk #1 of 1 ...
[10:18:26.523]  - seeds: <none>
[10:18:26.523]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.523] getGlobalsAndPackages() ...
[10:18:26.524] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.524] Resolving globals: FALSE
[10:18:26.524] Tweak future expression to call with '...' arguments ...
[10:18:26.524] {
[10:18:26.524]     do.call(function(...) {
[10:18:26.524]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.524]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.524]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.524]             on.exit(options(oopts), add = TRUE)
[10:18:26.524]         }
[10:18:26.524]         {
[10:18:26.524]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.524]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.524]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.524]             })
[10:18:26.524]         }
[10:18:26.524]     }, args = future.call.arguments)
[10:18:26.524] }
[10:18:26.524] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.524] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.525] 
[10:18:26.525] getGlobalsAndPackages() ... DONE
[10:18:26.525] run() for ‘Future’ ...
[10:18:26.525] - state: ‘created’
[10:18:26.525] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.525] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.526] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.526]   - Field: ‘label’
[10:18:26.526]   - Field: ‘local’
[10:18:26.526]   - Field: ‘owner’
[10:18:26.526]   - Field: ‘envir’
[10:18:26.526]   - Field: ‘packages’
[10:18:26.526]   - Field: ‘gc’
[10:18:26.526]   - Field: ‘conditions’
[10:18:26.526]   - Field: ‘expr’
[10:18:26.526]   - Field: ‘uuid’
[10:18:26.526]   - Field: ‘seed’
[10:18:26.527]   - Field: ‘version’
[10:18:26.527]   - Field: ‘result’
[10:18:26.527]   - Field: ‘asynchronous’
[10:18:26.527]   - Field: ‘calls’
[10:18:26.527]   - Field: ‘globals’
[10:18:26.527]   - Field: ‘stdout’
[10:18:26.527]   - Field: ‘earlySignal’
[10:18:26.527]   - Field: ‘lazy’
[10:18:26.527]   - Field: ‘state’
[10:18:26.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.527] - Launch lazy future ...
[10:18:26.528] Packages needed by the future expression (n = 0): <none>
[10:18:26.528] Packages needed by future strategies (n = 0): <none>
[10:18:26.528] {
[10:18:26.528]     {
[10:18:26.528]         {
[10:18:26.528]             ...future.startTime <- base::Sys.time()
[10:18:26.528]             {
[10:18:26.528]                 {
[10:18:26.528]                   {
[10:18:26.528]                     base::local({
[10:18:26.528]                       has_future <- base::requireNamespace("future", 
[10:18:26.528]                         quietly = TRUE)
[10:18:26.528]                       if (has_future) {
[10:18:26.528]                         ns <- base::getNamespace("future")
[10:18:26.528]                         version <- ns[[".package"]][["version"]]
[10:18:26.528]                         if (is.null(version)) 
[10:18:26.528]                           version <- utils::packageVersion("future")
[10:18:26.528]                       }
[10:18:26.528]                       else {
[10:18:26.528]                         version <- NULL
[10:18:26.528]                       }
[10:18:26.528]                       if (!has_future || version < "1.8.0") {
[10:18:26.528]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.528]                           "", base::R.version$version.string), 
[10:18:26.528]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:26.528]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.528]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.528]                             "release", "version")], collapse = " "), 
[10:18:26.528]                           hostname = base::Sys.info()[["nodename"]])
[10:18:26.528]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.528]                           info)
[10:18:26.528]                         info <- base::paste(info, collapse = "; ")
[10:18:26.528]                         if (!has_future) {
[10:18:26.528]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.528]                             info)
[10:18:26.528]                         }
[10:18:26.528]                         else {
[10:18:26.528]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.528]                             info, version)
[10:18:26.528]                         }
[10:18:26.528]                         base::stop(msg)
[10:18:26.528]                       }
[10:18:26.528]                     })
[10:18:26.528]                   }
[10:18:26.528]                   ...future.strategy.old <- future::plan("list")
[10:18:26.528]                   options(future.plan = NULL)
[10:18:26.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.528]                 }
[10:18:26.528]                 ...future.workdir <- getwd()
[10:18:26.528]             }
[10:18:26.528]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.528]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.528]         }
[10:18:26.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.528]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.528]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.528]             base::names(...future.oldOptions))
[10:18:26.528]     }
[10:18:26.528]     if (FALSE) {
[10:18:26.528]     }
[10:18:26.528]     else {
[10:18:26.528]         if (TRUE) {
[10:18:26.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.528]                 open = "w")
[10:18:26.528]         }
[10:18:26.528]         else {
[10:18:26.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.528]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.528]         }
[10:18:26.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.528]             base::sink(type = "output", split = FALSE)
[10:18:26.528]             base::close(...future.stdout)
[10:18:26.528]         }, add = TRUE)
[10:18:26.528]     }
[10:18:26.528]     ...future.frame <- base::sys.nframe()
[10:18:26.528]     ...future.conditions <- base::list()
[10:18:26.528]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.528]     if (FALSE) {
[10:18:26.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.528]     }
[10:18:26.528]     ...future.result <- base::tryCatch({
[10:18:26.528]         base::withCallingHandlers({
[10:18:26.528]             ...future.value <- base::withVisible(base::local({
[10:18:26.528]                 do.call(function(...) {
[10:18:26.528]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.528]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.528]                     ...future.globals.maxSize)) {
[10:18:26.528]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.528]                     on.exit(options(oopts), add = TRUE)
[10:18:26.528]                   }
[10:18:26.528]                   {
[10:18:26.528]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.528]                       FUN = function(jj) {
[10:18:26.528]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.528]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.528]                       })
[10:18:26.528]                   }
[10:18:26.528]                 }, args = future.call.arguments)
[10:18:26.528]             }))
[10:18:26.528]             future::FutureResult(value = ...future.value$value, 
[10:18:26.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.528]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.528]                     ...future.globalenv.names))
[10:18:26.528]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.528]         }, condition = base::local({
[10:18:26.528]             c <- base::c
[10:18:26.528]             inherits <- base::inherits
[10:18:26.528]             invokeRestart <- base::invokeRestart
[10:18:26.528]             length <- base::length
[10:18:26.528]             list <- base::list
[10:18:26.528]             seq.int <- base::seq.int
[10:18:26.528]             signalCondition <- base::signalCondition
[10:18:26.528]             sys.calls <- base::sys.calls
[10:18:26.528]             `[[` <- base::`[[`
[10:18:26.528]             `+` <- base::`+`
[10:18:26.528]             `<<-` <- base::`<<-`
[10:18:26.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.528]                   3L)]
[10:18:26.528]             }
[10:18:26.528]             function(cond) {
[10:18:26.528]                 is_error <- inherits(cond, "error")
[10:18:26.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.528]                   NULL)
[10:18:26.528]                 if (is_error) {
[10:18:26.528]                   sessionInformation <- function() {
[10:18:26.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.528]                       search = base::search(), system = base::Sys.info())
[10:18:26.528]                   }
[10:18:26.528]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.528]                     cond$call), session = sessionInformation(), 
[10:18:26.528]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.528]                   signalCondition(cond)
[10:18:26.528]                 }
[10:18:26.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.528]                 "immediateCondition"))) {
[10:18:26.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.528]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.528]                   if (TRUE && !signal) {
[10:18:26.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.528]                     {
[10:18:26.528]                       inherits <- base::inherits
[10:18:26.528]                       invokeRestart <- base::invokeRestart
[10:18:26.528]                       is.null <- base::is.null
[10:18:26.528]                       muffled <- FALSE
[10:18:26.528]                       if (inherits(cond, "message")) {
[10:18:26.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.528]                         if (muffled) 
[10:18:26.528]                           invokeRestart("muffleMessage")
[10:18:26.528]                       }
[10:18:26.528]                       else if (inherits(cond, "warning")) {
[10:18:26.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.528]                         if (muffled) 
[10:18:26.528]                           invokeRestart("muffleWarning")
[10:18:26.528]                       }
[10:18:26.528]                       else if (inherits(cond, "condition")) {
[10:18:26.528]                         if (!is.null(pattern)) {
[10:18:26.528]                           computeRestarts <- base::computeRestarts
[10:18:26.528]                           grepl <- base::grepl
[10:18:26.528]                           restarts <- computeRestarts(cond)
[10:18:26.528]                           for (restart in restarts) {
[10:18:26.528]                             name <- restart$name
[10:18:26.528]                             if (is.null(name)) 
[10:18:26.528]                               next
[10:18:26.528]                             if (!grepl(pattern, name)) 
[10:18:26.528]                               next
[10:18:26.528]                             invokeRestart(restart)
[10:18:26.528]                             muffled <- TRUE
[10:18:26.528]                             break
[10:18:26.528]                           }
[10:18:26.528]                         }
[10:18:26.528]                       }
[10:18:26.528]                       invisible(muffled)
[10:18:26.528]                     }
[10:18:26.528]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.528]                   }
[10:18:26.528]                 }
[10:18:26.528]                 else {
[10:18:26.528]                   if (TRUE) {
[10:18:26.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.528]                     {
[10:18:26.528]                       inherits <- base::inherits
[10:18:26.528]                       invokeRestart <- base::invokeRestart
[10:18:26.528]                       is.null <- base::is.null
[10:18:26.528]                       muffled <- FALSE
[10:18:26.528]                       if (inherits(cond, "message")) {
[10:18:26.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.528]                         if (muffled) 
[10:18:26.528]                           invokeRestart("muffleMessage")
[10:18:26.528]                       }
[10:18:26.528]                       else if (inherits(cond, "warning")) {
[10:18:26.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.528]                         if (muffled) 
[10:18:26.528]                           invokeRestart("muffleWarning")
[10:18:26.528]                       }
[10:18:26.528]                       else if (inherits(cond, "condition")) {
[10:18:26.528]                         if (!is.null(pattern)) {
[10:18:26.528]                           computeRestarts <- base::computeRestarts
[10:18:26.528]                           grepl <- base::grepl
[10:18:26.528]                           restarts <- computeRestarts(cond)
[10:18:26.528]                           for (restart in restarts) {
[10:18:26.528]                             name <- restart$name
[10:18:26.528]                             if (is.null(name)) 
[10:18:26.528]                               next
[10:18:26.528]                             if (!grepl(pattern, name)) 
[10:18:26.528]                               next
[10:18:26.528]                             invokeRestart(restart)
[10:18:26.528]                             muffled <- TRUE
[10:18:26.528]                             break
[10:18:26.528]                           }
[10:18:26.528]                         }
[10:18:26.528]                       }
[10:18:26.528]                       invisible(muffled)
[10:18:26.528]                     }
[10:18:26.528]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.528]                   }
[10:18:26.528]                 }
[10:18:26.528]             }
[10:18:26.528]         }))
[10:18:26.528]     }, error = function(ex) {
[10:18:26.528]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.528]                 ...future.rng), started = ...future.startTime, 
[10:18:26.528]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.528]             version = "1.8"), class = "FutureResult")
[10:18:26.528]     }, finally = {
[10:18:26.528]         if (!identical(...future.workdir, getwd())) 
[10:18:26.528]             setwd(...future.workdir)
[10:18:26.528]         {
[10:18:26.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.528]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.528]             }
[10:18:26.528]             base::options(...future.oldOptions)
[10:18:26.528]             if (.Platform$OS.type == "windows") {
[10:18:26.528]                 old_names <- names(...future.oldEnvVars)
[10:18:26.528]                 envs <- base::Sys.getenv()
[10:18:26.528]                 names <- names(envs)
[10:18:26.528]                 common <- intersect(names, old_names)
[10:18:26.528]                 added <- setdiff(names, old_names)
[10:18:26.528]                 removed <- setdiff(old_names, names)
[10:18:26.528]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.528]                   envs[common]]
[10:18:26.528]                 NAMES <- toupper(changed)
[10:18:26.528]                 args <- list()
[10:18:26.528]                 for (kk in seq_along(NAMES)) {
[10:18:26.528]                   name <- changed[[kk]]
[10:18:26.528]                   NAME <- NAMES[[kk]]
[10:18:26.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.528]                     next
[10:18:26.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.528]                 }
[10:18:26.528]                 NAMES <- toupper(added)
[10:18:26.528]                 for (kk in seq_along(NAMES)) {
[10:18:26.528]                   name <- added[[kk]]
[10:18:26.528]                   NAME <- NAMES[[kk]]
[10:18:26.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.528]                     next
[10:18:26.528]                   args[[name]] <- ""
[10:18:26.528]                 }
[10:18:26.528]                 NAMES <- toupper(removed)
[10:18:26.528]                 for (kk in seq_along(NAMES)) {
[10:18:26.528]                   name <- removed[[kk]]
[10:18:26.528]                   NAME <- NAMES[[kk]]
[10:18:26.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.528]                     next
[10:18:26.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.528]                 }
[10:18:26.528]                 if (length(args) > 0) 
[10:18:26.528]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.528]             }
[10:18:26.528]             else {
[10:18:26.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.528]             }
[10:18:26.528]             {
[10:18:26.528]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.528]                   0L) {
[10:18:26.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.528]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.528]                   base::options(opts)
[10:18:26.528]                 }
[10:18:26.528]                 {
[10:18:26.528]                   {
[10:18:26.528]                     NULL
[10:18:26.528]                     RNGkind("Mersenne-Twister")
[10:18:26.528]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:18:26.528]                       inherits = FALSE)
[10:18:26.528]                   }
[10:18:26.528]                   options(future.plan = NULL)
[10:18:26.528]                   if (is.na(NA_character_)) 
[10:18:26.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.528]                     .init = FALSE)
[10:18:26.528]                 }
[10:18:26.528]             }
[10:18:26.528]         }
[10:18:26.528]     })
[10:18:26.528]     if (TRUE) {
[10:18:26.528]         base::sink(type = "output", split = FALSE)
[10:18:26.528]         if (TRUE) {
[10:18:26.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.528]         }
[10:18:26.528]         else {
[10:18:26.528]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.528]         }
[10:18:26.528]         base::close(...future.stdout)
[10:18:26.528]         ...future.stdout <- NULL
[10:18:26.528]     }
[10:18:26.528]     ...future.result$conditions <- ...future.conditions
[10:18:26.528]     ...future.result$finished <- base::Sys.time()
[10:18:26.528]     ...future.result
[10:18:26.528] }
[10:18:26.530] assign_globals() ...
[10:18:26.530] List of 5
[10:18:26.530]  $ future.call.arguments    : list()
[10:18:26.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.530]  $ ...future.FUN            :function (x)  
[10:18:26.530]  $ ...future.elements_ii    :List of 2
[10:18:26.530]   ..$ : int [1:2] 1 3
[10:18:26.530]   ..$ : int [1:2] 2 4
[10:18:26.530]  $ ...future.seeds_ii       : NULL
[10:18:26.530]  $ ...future.globals.maxSize: num Inf
[10:18:26.530]  - attr(*, "resolved")= logi FALSE
[10:18:26.530]  - attr(*, "total_size")= num NA
[10:18:26.530]  - attr(*, "where")=List of 5
[10:18:26.530]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.530]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.530]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.530]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.530]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.530]  - attr(*, "already-done")= logi TRUE
[10:18:26.535] - copied ‘future.call.arguments’ to environment
[10:18:26.535] - reassign environment for ‘...future.FUN’
[10:18:26.535] - copied ‘...future.FUN’ to environment
[10:18:26.535] - copied ‘...future.elements_ii’ to environment
[10:18:26.535] - copied ‘...future.seeds_ii’ to environment
[10:18:26.535] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.536] assign_globals() ... done
[10:18:26.536] plan(): Setting new future strategy stack:
[10:18:26.536] List of future strategies:
[10:18:26.536] 1. sequential:
[10:18:26.536]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.536]    - tweaked: FALSE
[10:18:26.536]    - call: NULL
[10:18:26.536] plan(): nbrOfWorkers() = 1
[10:18:26.537] plan(): Setting new future strategy stack:
[10:18:26.537] List of future strategies:
[10:18:26.537] 1. sequential:
[10:18:26.537]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.537]    - tweaked: FALSE
[10:18:26.537]    - call: plan(strategy)
[10:18:26.538] plan(): nbrOfWorkers() = 1
[10:18:26.539] SequentialFuture started (and completed)
[10:18:26.540] - Launch lazy future ... done
[10:18:26.540] run() for ‘SequentialFuture’ ... done
[10:18:26.540] Created future:
[10:18:26.540] SequentialFuture:
[10:18:26.540] Label: ‘future_apply-1’
[10:18:26.540] Expression:
[10:18:26.540] {
[10:18:26.540]     do.call(function(...) {
[10:18:26.540]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.540]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.540]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.540]             on.exit(options(oopts), add = TRUE)
[10:18:26.540]         }
[10:18:26.540]         {
[10:18:26.540]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.540]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.540]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.540]             })
[10:18:26.540]         }
[10:18:26.540]     }, args = future.call.arguments)
[10:18:26.540] }
[10:18:26.540] Lazy evaluation: FALSE
[10:18:26.540] Asynchronous evaluation: FALSE
[10:18:26.540] Local evaluation: TRUE
[10:18:26.540] Environment: R_GlobalEnv
[10:18:26.540] Capture standard output: TRUE
[10:18:26.540] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.540] Globals: 5 objects totaling 1.50 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 63 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.540] Packages: <none>
[10:18:26.540] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.540] Resolved: TRUE
[10:18:26.540] Value: 114 bytes of class ‘list’
[10:18:26.540] Early signaling: FALSE
[10:18:26.540] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.540] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.541] Chunk #1 of 1 ... DONE
[10:18:26.541] Launching 1 futures (chunks) ... DONE
[10:18:26.541] Resolving 1 futures (chunks) ...
[10:18:26.541] resolve() on list ...
[10:18:26.541]  recursive: 0
[10:18:26.542]  length: 1
[10:18:26.542] 
[10:18:26.542] resolved() for ‘SequentialFuture’ ...
[10:18:26.542] - state: ‘finished’
[10:18:26.542] - run: TRUE
[10:18:26.542] - result: ‘FutureResult’
[10:18:26.542] resolved() for ‘SequentialFuture’ ... done
[10:18:26.542] Future #1
[10:18:26.542] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.543] - nx: 1
[10:18:26.543] - relay: TRUE
[10:18:26.543] - stdout: TRUE
[10:18:26.543] - signal: TRUE
[10:18:26.543] - resignal: FALSE
[10:18:26.543] - force: TRUE
[10:18:26.543] - relayed: [n=1] FALSE
[10:18:26.543] - queued futures: [n=1] FALSE
[10:18:26.543]  - until=1
[10:18:26.543]  - relaying element #1
[10:18:26.543] - relayed: [n=1] TRUE
[10:18:26.544] - queued futures: [n=1] TRUE
[10:18:26.544] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.544]  length: 0 (resolved future 1)
[10:18:26.544] Relaying remaining futures
[10:18:26.544] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.544] - nx: 1
[10:18:26.544] - relay: TRUE
[10:18:26.544] - stdout: TRUE
[10:18:26.544] - signal: TRUE
[10:18:26.544] - resignal: FALSE
[10:18:26.544] - force: TRUE
[10:18:26.545] - relayed: [n=1] TRUE
[10:18:26.545] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.545] - relayed: [n=1] TRUE
[10:18:26.545] - queued futures: [n=1] TRUE
[10:18:26.545] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.545] resolve() on list ... DONE
[10:18:26.545]  - Number of value chunks collected: 1
[10:18:26.545] Resolving 1 futures (chunks) ... DONE
[10:18:26.545] Reducing values from 1 chunks ...
[10:18:26.545]  - Number of values collected after concatenation: 2
[10:18:26.545]  - Number of values expected: 2
[10:18:26.546] Reducing values from 1 chunks ... DONE
[10:18:26.546] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:18:26.546] getGlobalsAndPackagesXApply() ...
[10:18:26.546]  - future.globals: TRUE
[10:18:26.546] getGlobalsAndPackages() ...
[10:18:26.546] Searching for globals...
[10:18:26.549] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:18:26.549] Searching for globals ... DONE
[10:18:26.549] Resolving globals: FALSE
[10:18:26.550] The total size of the 1 globals is 3.66 KiB (3746 bytes)
[10:18:26.550] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 3.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.66 KiB of class ‘function’)
[10:18:26.551] - globals: [1] ‘FUN’
[10:18:26.551] 
[10:18:26.551] getGlobalsAndPackages() ... DONE
[10:18:26.551]  - globals found/used: [n=1] ‘FUN’
[10:18:26.551]  - needed namespaces: [n=0] 
[10:18:26.551] Finding globals ... DONE
[10:18:26.551]  - use_args: TRUE
[10:18:26.551]  - Getting '...' globals ...
[10:18:26.552] resolve() on list ...
[10:18:26.552]  recursive: 0
[10:18:26.552]  length: 1
[10:18:26.552]  elements: ‘...’
[10:18:26.552]  length: 0 (resolved future 1)
[10:18:26.552] resolve() on list ... DONE
[10:18:26.552]    - '...' content: [n=0] 
[10:18:26.552] List of 1
[10:18:26.552]  $ ...: list()
[10:18:26.552]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.552]  - attr(*, "where")=List of 1
[10:18:26.552]   ..$ ...:<environment: 0x556e01530a18> 
[10:18:26.552]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.552]  - attr(*, "resolved")= logi TRUE
[10:18:26.552]  - attr(*, "total_size")= num NA
[10:18:26.555]  - Getting '...' globals ... DONE
[10:18:26.555] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.555] List of 2
[10:18:26.555]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:18:26.555]  $ ...          : list()
[10:18:26.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.555]  - attr(*, "where")=List of 2
[10:18:26.555]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.555]   ..$ ...          :<environment: 0x556e01530a18> 
[10:18:26.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.555]  - attr(*, "resolved")= logi FALSE
[10:18:26.555]  - attr(*, "total_size")= num 9424
[10:18:26.558] Packages to be attached in all futures: [n=0] 
[10:18:26.558] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.558] future_lapply() ...
[10:18:26.560] Generating random seeds ...
[10:18:26.560] Generating random seed streams for 2 elements ...
[10:18:26.560] Generating random seed streams for 2 elements ... DONE
[10:18:26.561] Generating random seeds ... DONE
[10:18:26.561] Will set RNG state on exit: 10407, 910572183, 481958584, 1068500591, -1507272550, -1889286337, 1507591261
[10:18:26.561] Number of chunks: 1
[10:18:26.561] getGlobalsAndPackagesXApply() ...
[10:18:26.561]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.561]  - use_args: TRUE
[10:18:26.561] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.561] List of 2
[10:18:26.561]  $ ...          : list()
[10:18:26.561]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.561]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:18:26.561]  - attr(*, "where")=List of 2
[10:18:26.561]   ..$ ...          :<environment: 0x556e01530a18> 
[10:18:26.561]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:26.561]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.561]  - attr(*, "resolved")= logi FALSE
[10:18:26.561]  - attr(*, "total_size")= num NA
[10:18:26.567] Packages to be attached in all futures: [n=0] 
[10:18:26.567] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.568] Number of futures (= number of chunks): 1
[10:18:26.568] Launching 1 futures (chunks) ...
[10:18:26.568] Chunk #1 of 1 ...
[10:18:26.568]  - seeds: [2] <seeds>
[10:18:26.568]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.568] getGlobalsAndPackages() ...
[10:18:26.568] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.569] Resolving globals: FALSE
[10:18:26.569] Tweak future expression to call with '...' arguments ...
[10:18:26.569] {
[10:18:26.569]     do.call(function(...) {
[10:18:26.569]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.569]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.569]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.569]             on.exit(options(oopts), add = TRUE)
[10:18:26.569]         }
[10:18:26.569]         {
[10:18:26.569]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.569]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.569]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:26.569]                   envir = globalenv(), inherits = FALSE)
[10:18:26.569]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.569]             })
[10:18:26.569]         }
[10:18:26.569]     }, args = future.call.arguments)
[10:18:26.569] }
[10:18:26.569] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.569] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.570] 
[10:18:26.570] getGlobalsAndPackages() ... DONE
[10:18:26.570] run() for ‘Future’ ...
[10:18:26.570] - state: ‘created’
[10:18:26.570] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:18:26.570] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:18:26.571]   - Field: ‘label’
[10:18:26.571]   - Field: ‘local’
[10:18:26.571]   - Field: ‘owner’
[10:18:26.571]   - Field: ‘envir’
[10:18:26.571]   - Field: ‘packages’
[10:18:26.571]   - Field: ‘gc’
[10:18:26.571]   - Field: ‘conditions’
[10:18:26.571]   - Field: ‘expr’
[10:18:26.571]   - Field: ‘uuid’
[10:18:26.572]   - Field: ‘seed’
[10:18:26.572]   - Field: ‘version’
[10:18:26.572]   - Field: ‘result’
[10:18:26.572]   - Field: ‘asynchronous’
[10:18:26.572]   - Field: ‘calls’
[10:18:26.572]   - Field: ‘globals’
[10:18:26.572]   - Field: ‘stdout’
[10:18:26.572]   - Field: ‘earlySignal’
[10:18:26.572]   - Field: ‘lazy’
[10:18:26.572]   - Field: ‘state’
[10:18:26.572] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:18:26.573] - Launch lazy future ...
[10:18:26.573] Packages needed by the future expression (n = 0): <none>
[10:18:26.573] Packages needed by future strategies (n = 0): <none>
[10:18:26.573] {
[10:18:26.573]     {
[10:18:26.573]         {
[10:18:26.573]             ...future.startTime <- base::Sys.time()
[10:18:26.573]             {
[10:18:26.573]                 {
[10:18:26.573]                   {
[10:18:26.573]                     base::local({
[10:18:26.573]                       has_future <- base::requireNamespace("future", 
[10:18:26.573]                         quietly = TRUE)
[10:18:26.573]                       if (has_future) {
[10:18:26.573]                         ns <- base::getNamespace("future")
[10:18:26.573]                         version <- ns[[".package"]][["version"]]
[10:18:26.573]                         if (is.null(version)) 
[10:18:26.573]                           version <- utils::packageVersion("future")
[10:18:26.573]                       }
[10:18:26.573]                       else {
[10:18:26.573]                         version <- NULL
[10:18:26.573]                       }
[10:18:26.573]                       if (!has_future || version < "1.8.0") {
[10:18:26.573]                         info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.573]                           "", base::R.version$version.string), 
[10:18:26.573]                           platform = base::sprintf("%s (%s-bit)", 
[10:18:26.573]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.573]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.573]                             "release", "version")], collapse = " "), 
[10:18:26.573]                           hostname = base::Sys.info()[["nodename"]])
[10:18:26.573]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.573]                           info)
[10:18:26.573]                         info <- base::paste(info, collapse = "; ")
[10:18:26.573]                         if (!has_future) {
[10:18:26.573]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.573]                             info)
[10:18:26.573]                         }
[10:18:26.573]                         else {
[10:18:26.573]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.573]                             info, version)
[10:18:26.573]                         }
[10:18:26.573]                         base::stop(msg)
[10:18:26.573]                       }
[10:18:26.573]                     })
[10:18:26.573]                   }
[10:18:26.573]                   ...future.strategy.old <- future::plan("list")
[10:18:26.573]                   options(future.plan = NULL)
[10:18:26.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.573]                 }
[10:18:26.573]                 ...future.workdir <- getwd()
[10:18:26.573]             }
[10:18:26.573]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.573]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.573]         }
[10:18:26.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.573]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.573]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.573]             base::names(...future.oldOptions))
[10:18:26.573]     }
[10:18:26.573]     if (FALSE) {
[10:18:26.573]     }
[10:18:26.573]     else {
[10:18:26.573]         if (TRUE) {
[10:18:26.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.573]                 open = "w")
[10:18:26.573]         }
[10:18:26.573]         else {
[10:18:26.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.573]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.573]         }
[10:18:26.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.573]             base::sink(type = "output", split = FALSE)
[10:18:26.573]             base::close(...future.stdout)
[10:18:26.573]         }, add = TRUE)
[10:18:26.573]     }
[10:18:26.573]     ...future.frame <- base::sys.nframe()
[10:18:26.573]     ...future.conditions <- base::list()
[10:18:26.573]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.573]     if (FALSE) {
[10:18:26.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.573]     }
[10:18:26.573]     ...future.result <- base::tryCatch({
[10:18:26.573]         base::withCallingHandlers({
[10:18:26.573]             ...future.value <- base::withVisible(base::local({
[10:18:26.573]                 do.call(function(...) {
[10:18:26.573]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.573]                   if (!identical(...future.globals.maxSize.org, 
[10:18:26.573]                     ...future.globals.maxSize)) {
[10:18:26.573]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.573]                     on.exit(options(oopts), add = TRUE)
[10:18:26.573]                   }
[10:18:26.573]                   {
[10:18:26.573]                     lapply(seq_along(...future.elements_ii), 
[10:18:26.573]                       FUN = function(jj) {
[10:18:26.573]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.573]                         assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:26.573]                           envir = globalenv(), inherits = FALSE)
[10:18:26.573]                         ...future.FUN(...future.X_jj, ...)
[10:18:26.573]                       })
[10:18:26.573]                   }
[10:18:26.573]                 }, args = future.call.arguments)
[10:18:26.573]             }))
[10:18:26.573]             future::FutureResult(value = ...future.value$value, 
[10:18:26.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.573]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.573]                     ...future.globalenv.names))
[10:18:26.573]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.573]         }, condition = base::local({
[10:18:26.573]             c <- base::c
[10:18:26.573]             inherits <- base::inherits
[10:18:26.573]             invokeRestart <- base::invokeRestart
[10:18:26.573]             length <- base::length
[10:18:26.573]             list <- base::list
[10:18:26.573]             seq.int <- base::seq.int
[10:18:26.573]             signalCondition <- base::signalCondition
[10:18:26.573]             sys.calls <- base::sys.calls
[10:18:26.573]             `[[` <- base::`[[`
[10:18:26.573]             `+` <- base::`+`
[10:18:26.573]             `<<-` <- base::`<<-`
[10:18:26.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.573]                   3L)]
[10:18:26.573]             }
[10:18:26.573]             function(cond) {
[10:18:26.573]                 is_error <- inherits(cond, "error")
[10:18:26.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.573]                   NULL)
[10:18:26.573]                 if (is_error) {
[10:18:26.573]                   sessionInformation <- function() {
[10:18:26.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.573]                       search = base::search(), system = base::Sys.info())
[10:18:26.573]                   }
[10:18:26.573]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.573]                     cond$call), session = sessionInformation(), 
[10:18:26.573]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.573]                   signalCondition(cond)
[10:18:26.573]                 }
[10:18:26.573]                 else if (!ignore && FALSE && inherits(cond, NULL)) {
[10:18:26.573]                   signal <- TRUE && inherits(cond, character(0))
[10:18:26.573]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.573]                   if (TRUE && !signal) {
[10:18:26.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.573]                     {
[10:18:26.573]                       inherits <- base::inherits
[10:18:26.573]                       invokeRestart <- base::invokeRestart
[10:18:26.573]                       is.null <- base::is.null
[10:18:26.573]                       muffled <- FALSE
[10:18:26.573]                       if (inherits(cond, "message")) {
[10:18:26.573]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.573]                         if (muffled) 
[10:18:26.573]                           invokeRestart("muffleMessage")
[10:18:26.573]                       }
[10:18:26.573]                       else if (inherits(cond, "warning")) {
[10:18:26.573]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.573]                         if (muffled) 
[10:18:26.573]                           invokeRestart("muffleWarning")
[10:18:26.573]                       }
[10:18:26.573]                       else if (inherits(cond, "condition")) {
[10:18:26.573]                         if (!is.null(pattern)) {
[10:18:26.573]                           computeRestarts <- base::computeRestarts
[10:18:26.573]                           grepl <- base::grepl
[10:18:26.573]                           restarts <- computeRestarts(cond)
[10:18:26.573]                           for (restart in restarts) {
[10:18:26.573]                             name <- restart$name
[10:18:26.573]                             if (is.null(name)) 
[10:18:26.573]                               next
[10:18:26.573]                             if (!grepl(pattern, name)) 
[10:18:26.573]                               next
[10:18:26.573]                             invokeRestart(restart)
[10:18:26.573]                             muffled <- TRUE
[10:18:26.573]                             break
[10:18:26.573]                           }
[10:18:26.573]                         }
[10:18:26.573]                       }
[10:18:26.573]                       invisible(muffled)
[10:18:26.573]                     }
[10:18:26.573]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.573]                   }
[10:18:26.573]                 }
[10:18:26.573]                 else {
[10:18:26.573]                   if (FALSE) {
[10:18:26.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.573]                     {
[10:18:26.573]                       inherits <- base::inherits
[10:18:26.573]                       invokeRestart <- base::invokeRestart
[10:18:26.573]                       is.null <- base::is.null
[10:18:26.573]                       muffled <- FALSE
[10:18:26.573]                       if (inherits(cond, "message")) {
[10:18:26.573]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.573]                         if (muffled) 
[10:18:26.573]                           invokeRestart("muffleMessage")
[10:18:26.573]                       }
[10:18:26.573]                       else if (inherits(cond, "warning")) {
[10:18:26.573]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.573]                         if (muffled) 
[10:18:26.573]                           invokeRestart("muffleWarning")
[10:18:26.573]                       }
[10:18:26.573]                       else if (inherits(cond, "condition")) {
[10:18:26.573]                         if (!is.null(pattern)) {
[10:18:26.573]                           computeRestarts <- base::computeRestarts
[10:18:26.573]                           grepl <- base::grepl
[10:18:26.573]                           restarts <- computeRestarts(cond)
[10:18:26.573]                           for (restart in restarts) {
[10:18:26.573]                             name <- restart$name
[10:18:26.573]                             if (is.null(name)) 
[10:18:26.573]                               next
[10:18:26.573]                             if (!grepl(pattern, name)) 
[10:18:26.573]                               next
[10:18:26.573]                             invokeRestart(restart)
[10:18:26.573]                             muffled <- TRUE
[10:18:26.573]                             break
[10:18:26.573]                           }
[10:18:26.573]                         }
[10:18:26.573]                       }
[10:18:26.573]                       invisible(muffled)
[10:18:26.573]                     }
[10:18:26.573]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.573]                   }
[10:18:26.573]                 }
[10:18:26.573]             }
[10:18:26.573]         }))
[10:18:26.573]     }, error = function(ex) {
[10:18:26.573]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.573]                 ...future.rng), started = ...future.startTime, 
[10:18:26.573]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.573]             version = "1.8"), class = "FutureResult")
[10:18:26.573]     }, finally = {
[10:18:26.573]         if (!identical(...future.workdir, getwd())) 
[10:18:26.573]             setwd(...future.workdir)
[10:18:26.573]         {
[10:18:26.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.573]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.573]             }
[10:18:26.573]             base::options(...future.oldOptions)
[10:18:26.573]             if (.Platform$OS.type == "windows") {
[10:18:26.573]                 old_names <- names(...future.oldEnvVars)
[10:18:26.573]                 envs <- base::Sys.getenv()
[10:18:26.573]                 names <- names(envs)
[10:18:26.573]                 common <- intersect(names, old_names)
[10:18:26.573]                 added <- setdiff(names, old_names)
[10:18:26.573]                 removed <- setdiff(old_names, names)
[10:18:26.573]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.573]                   envs[common]]
[10:18:26.573]                 NAMES <- toupper(changed)
[10:18:26.573]                 args <- list()
[10:18:26.573]                 for (kk in seq_along(NAMES)) {
[10:18:26.573]                   name <- changed[[kk]]
[10:18:26.573]                   NAME <- NAMES[[kk]]
[10:18:26.573]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.573]                     next
[10:18:26.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.573]                 }
[10:18:26.573]                 NAMES <- toupper(added)
[10:18:26.573]                 for (kk in seq_along(NAMES)) {
[10:18:26.573]                   name <- added[[kk]]
[10:18:26.573]                   NAME <- NAMES[[kk]]
[10:18:26.573]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.573]                     next
[10:18:26.573]                   args[[name]] <- ""
[10:18:26.573]                 }
[10:18:26.573]                 NAMES <- toupper(removed)
[10:18:26.573]                 for (kk in seq_along(NAMES)) {
[10:18:26.573]                   name <- removed[[kk]]
[10:18:26.573]                   NAME <- NAMES[[kk]]
[10:18:26.573]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.573]                     next
[10:18:26.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.573]                 }
[10:18:26.573]                 if (length(args) > 0) 
[10:18:26.573]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.573]             }
[10:18:26.573]             else {
[10:18:26.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.573]             }
[10:18:26.573]             {
[10:18:26.573]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.573]                   0L) {
[10:18:26.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.573]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.573]                   base::options(opts)
[10:18:26.573]                 }
[10:18:26.573]                 {
[10:18:26.573]                   {
[10:18:26.573]                     base::assign(".Random.seed", c(10407L, 910572183L, 
[10:18:26.573]                     481958584L, 1068500591L, -1507272550L, -1889286337L, 
[10:18:26.573]                     1507591261L), envir = base::globalenv(), 
[10:18:26.573]                       inherits = FALSE)
[10:18:26.573]                     NULL
[10:18:26.573]                   }
[10:18:26.573]                   options(future.plan = NULL)
[10:18:26.573]                   if (is.na(NA_character_)) 
[10:18:26.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.573]                     .init = FALSE)
[10:18:26.573]                 }
[10:18:26.573]             }
[10:18:26.573]         }
[10:18:26.573]     })
[10:18:26.573]     if (TRUE) {
[10:18:26.573]         base::sink(type = "output", split = FALSE)
[10:18:26.573]         if (TRUE) {
[10:18:26.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.573]         }
[10:18:26.573]         else {
[10:18:26.573]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.573]         }
[10:18:26.573]         base::close(...future.stdout)
[10:18:26.573]         ...future.stdout <- NULL
[10:18:26.573]     }
[10:18:26.573]     ...future.result$conditions <- ...future.conditions
[10:18:26.573]     ...future.result$finished <- base::Sys.time()
[10:18:26.573]     ...future.result
[10:18:26.573] }
[10:18:26.575] assign_globals() ...
[10:18:26.575] List of 5
[10:18:26.575]  $ future.call.arguments    : list()
[10:18:26.575]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.575]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:18:26.575]  $ ...future.elements_ii    :List of 2
[10:18:26.575]   ..$ : int [1:2] 1 3
[10:18:26.575]   ..$ : int [1:2] 2 4
[10:18:26.575]  $ ...future.seeds_ii       :List of 2
[10:18:26.575]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:18:26.575]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:18:26.575]  $ ...future.globals.maxSize: num Inf
[10:18:26.575]  - attr(*, "resolved")= logi FALSE
[10:18:26.575]  - attr(*, "total_size")= num NA
[10:18:26.575]  - attr(*, "where")=List of 5
[10:18:26.575]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.575]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.575]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.575]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.575]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.575]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.575]  - attr(*, "already-done")= logi TRUE
[10:18:26.581] - copied ‘future.call.arguments’ to environment
[10:18:26.581] - copied ‘...future.FUN’ to environment
[10:18:26.581] - copied ‘...future.elements_ii’ to environment
[10:18:26.581] - copied ‘...future.seeds_ii’ to environment
[10:18:26.581] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.581] assign_globals() ... done
[10:18:26.582] plan(): Setting new future strategy stack:
[10:18:26.582] List of future strategies:
[10:18:26.582] 1. sequential:
[10:18:26.582]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.582]    - tweaked: FALSE
[10:18:26.582]    - call: NULL
[10:18:26.582] plan(): nbrOfWorkers() = 1
[10:18:26.583] plan(): Setting new future strategy stack:
[10:18:26.583] List of future strategies:
[10:18:26.583] 1. sequential:
[10:18:26.583]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.583]    - tweaked: FALSE
[10:18:26.583]    - call: plan(strategy)
[10:18:26.584] plan(): nbrOfWorkers() = 1
[10:18:26.584] SequentialFuture started (and completed)
[10:18:26.584] - Launch lazy future ... done
[10:18:26.584] run() for ‘SequentialFuture’ ... done
[10:18:26.584] Created future:
[10:18:26.584] SequentialFuture:
[10:18:26.584] Label: ‘future_apply-1’
[10:18:26.584] Expression:
[10:18:26.584] {
[10:18:26.584]     do.call(function(...) {
[10:18:26.584]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.584]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.584]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.584]             on.exit(options(oopts), add = TRUE)
[10:18:26.584]         }
[10:18:26.584]         {
[10:18:26.584]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.584]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.584]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:26.584]                   envir = globalenv(), inherits = FALSE)
[10:18:26.584]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.584]             })
[10:18:26.584]         }
[10:18:26.584]     }, args = future.call.arguments)
[10:18:26.584] }
[10:18:26.584] Lazy evaluation: FALSE
[10:18:26.584] Asynchronous evaluation: FALSE
[10:18:26.584] Local evaluation: TRUE
[10:18:26.584] Environment: R_GlobalEnv
[10:18:26.584] Capture standard output: TRUE
[10:18:26.584] Capture condition classes: <none>
[10:18:26.584] Globals: 5 objects totaling 3.95 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 63 bytes, list ‘...future.seeds_ii’ of 103 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.584] Packages: <none>
[10:18:26.584] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:18:26.584] Resolved: TRUE
[10:18:26.584] Value: 63 bytes of class ‘list’
[10:18:26.584] Early signaling: FALSE
[10:18:26.584] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.584] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:18:26.585] Chunk #1 of 1 ... DONE
[10:18:26.585] Launching 1 futures (chunks) ... DONE
[10:18:26.585] Resolving 1 futures (chunks) ...
[10:18:26.585] resolve() on list ...
[10:18:26.585]  recursive: 0
[10:18:26.586]  length: 1
[10:18:26.586] 
[10:18:26.586] resolved() for ‘SequentialFuture’ ...
[10:18:26.586] - state: ‘finished’
[10:18:26.586] - run: TRUE
[10:18:26.586] - result: ‘FutureResult’
[10:18:26.586] resolved() for ‘SequentialFuture’ ... done
[10:18:26.586] Future #1
[10:18:26.586] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:18:26.586] - nx: 1
[10:18:26.587] - relay: TRUE
[10:18:26.587] - stdout: TRUE
[10:18:26.587] - signal: TRUE
[10:18:26.587] - resignal: FALSE
[10:18:26.587] - force: TRUE
[10:18:26.587] - relayed: [n=1] FALSE
[10:18:26.587] - queued futures: [n=1] FALSE
[10:18:26.587]  - until=1
[10:18:26.587]  - relaying element #1
[10:18:26.587] - relayed: [n=1] TRUE
[10:18:26.588] - queued futures: [n=1] TRUE
[10:18:26.588] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:18:26.588]  length: 0 (resolved future 1)
[10:18:26.588] Relaying remaining futures
[10:18:26.588] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.588] - nx: 1
[10:18:26.588] - relay: TRUE
[10:18:26.588] - stdout: TRUE
[10:18:26.588] - signal: TRUE
[10:18:26.588] - resignal: FALSE
[10:18:26.588] - force: TRUE
[10:18:26.588] - relayed: [n=1] TRUE
[10:18:26.589] - queued futures: [n=1] TRUE
 - flush all
[10:18:26.589] - relayed: [n=1] TRUE
[10:18:26.589] - queued futures: [n=1] TRUE
[10:18:26.589] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.589] resolve() on list ... DONE
[10:18:26.591]  - Number of value chunks collected: 1
[10:18:26.591] Resolving 1 futures (chunks) ... DONE
[10:18:26.591] Reducing values from 1 chunks ...
[10:18:26.591]  - Number of values collected after concatenation: 2
[10:18:26.591]  - Number of values expected: 2
[10:18:26.591] Reducing values from 1 chunks ... DONE
[10:18:26.591] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:18:26.592] plan(): Setting new future strategy stack:
[10:18:26.592] List of future strategies:
[10:18:26.592] 1. sequential:
[10:18:26.592]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.592]    - tweaked: FALSE
[10:18:26.592]    - call: plan(sequential)
[10:18:26.592] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:18:26.593] plan(): Setting new future strategy stack:
[10:18:26.593] List of future strategies:
[10:18:26.593] 1. multicore:
[10:18:26.593]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:26.593]    - tweaked: FALSE
[10:18:26.593]    - call: plan(strategy)
[10:18:26.595] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[10:18:26.595] getGlobalsAndPackagesXApply() ...
[10:18:26.595]  - future.globals: TRUE
[10:18:26.596] getGlobalsAndPackages() ...
[10:18:26.596] Searching for globals...
[10:18:26.631] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:18:26.631] Searching for globals ... DONE
[10:18:26.631] Resolving globals: FALSE
[10:18:26.633] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:18:26.633] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:18:26.633] - globals: [1] ‘FUN’
[10:18:26.634] 
[10:18:26.634] getGlobalsAndPackages() ... DONE
[10:18:26.634]  - globals found/used: [n=1] ‘FUN’
[10:18:26.634]  - needed namespaces: [n=0] 
[10:18:26.634] Finding globals ... DONE
[10:18:26.634]  - use_args: TRUE
[10:18:26.634]  - Getting '...' globals ...
[10:18:26.634] resolve() on list ...
[10:18:26.634]  recursive: 0
[10:18:26.635]  length: 1
[10:18:26.635]  elements: ‘...’
[10:18:26.635]  length: 0 (resolved future 1)
[10:18:26.635] resolve() on list ... DONE
[10:18:26.635]    - '...' content: [n=0] 
[10:18:26.635] List of 1
[10:18:26.635]  $ ...: list()
[10:18:26.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.635]  - attr(*, "where")=List of 1
[10:18:26.635]   ..$ ...:<environment: 0x556e025813a8> 
[10:18:26.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.635]  - attr(*, "resolved")= logi TRUE
[10:18:26.635]  - attr(*, "total_size")= num NA
[10:18:26.638]  - Getting '...' globals ... DONE
[10:18:26.638] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.638] List of 2
[10:18:26.638]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.638]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.638]  $ ...          : list()
[10:18:26.638]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.638]  - attr(*, "where")=List of 2
[10:18:26.638]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.638]   ..$ ...          :<environment: 0x556e025813a8> 
[10:18:26.638]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.638]  - attr(*, "resolved")= logi FALSE
[10:18:26.638]  - attr(*, "total_size")= num 65963
[10:18:26.641] Packages to be attached in all futures: [n=0] 
[10:18:26.641] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.642] future_lapply() ...
[10:18:26.677] Number of chunks: 2
[10:18:26.677] getGlobalsAndPackagesXApply() ...
[10:18:26.677]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.677]  - use_args: TRUE
[10:18:26.677] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.677] List of 2
[10:18:26.677]  $ ...          : list()
[10:18:26.677]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.677]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.677]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.677]  - attr(*, "where")=List of 2
[10:18:26.677]   ..$ ...          :<environment: 0x556e025813a8> 
[10:18:26.677]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:26.677]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.677]  - attr(*, "resolved")= logi FALSE
[10:18:26.677]  - attr(*, "total_size")= num NA
[10:18:26.681] Packages to be attached in all futures: [n=0] 
[10:18:26.681] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.681] Number of futures (= number of chunks): 2
[10:18:26.681] Launching 2 futures (chunks) ...
[10:18:26.681] Chunk #1 of 2 ...
[10:18:26.681]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:26.681]  - seeds: <none>
[10:18:26.682]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.682] getGlobalsAndPackages() ...
[10:18:26.682] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.682] Resolving globals: FALSE
[10:18:26.682] Tweak future expression to call with '...' arguments ...
[10:18:26.682] {
[10:18:26.682]     do.call(function(...) {
[10:18:26.682]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.682]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.682]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.682]             on.exit(options(oopts), add = TRUE)
[10:18:26.682]         }
[10:18:26.682]         {
[10:18:26.682]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.682]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.682]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.682]             })
[10:18:26.682]         }
[10:18:26.682]     }, args = future.call.arguments)
[10:18:26.682] }
[10:18:26.682] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.683] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.683] 
[10:18:26.683] getGlobalsAndPackages() ... DONE
[10:18:26.683] run() for ‘Future’ ...
[10:18:26.683] - state: ‘created’
[10:18:26.683] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:26.685] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:26.686] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:26.686]   - Field: ‘label’
[10:18:26.686]   - Field: ‘local’
[10:18:26.686]   - Field: ‘owner’
[10:18:26.686]   - Field: ‘envir’
[10:18:26.686]   - Field: ‘workers’
[10:18:26.686]   - Field: ‘packages’
[10:18:26.686]   - Field: ‘gc’
[10:18:26.686]   - Field: ‘job’
[10:18:26.687]   - Field: ‘conditions’
[10:18:26.687]   - Field: ‘expr’
[10:18:26.687]   - Field: ‘uuid’
[10:18:26.687]   - Field: ‘seed’
[10:18:26.687]   - Field: ‘version’
[10:18:26.687]   - Field: ‘result’
[10:18:26.687]   - Field: ‘asynchronous’
[10:18:26.687]   - Field: ‘calls’
[10:18:26.687]   - Field: ‘globals’
[10:18:26.687]   - Field: ‘stdout’
[10:18:26.687]   - Field: ‘earlySignal’
[10:18:26.687]   - Field: ‘lazy’
[10:18:26.688]   - Field: ‘state’
[10:18:26.688] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:26.688] - Launch lazy future ...
[10:18:26.689] Packages needed by the future expression (n = 0): <none>
[10:18:26.689] Packages needed by future strategies (n = 0): <none>
[10:18:26.689] {
[10:18:26.689]     {
[10:18:26.689]         {
[10:18:26.689]             ...future.startTime <- base::Sys.time()
[10:18:26.689]             {
[10:18:26.689]                 {
[10:18:26.689]                   {
[10:18:26.689]                     {
[10:18:26.689]                       base::local({
[10:18:26.689]                         has_future <- base::requireNamespace("future", 
[10:18:26.689]                           quietly = TRUE)
[10:18:26.689]                         if (has_future) {
[10:18:26.689]                           ns <- base::getNamespace("future")
[10:18:26.689]                           version <- ns[[".package"]][["version"]]
[10:18:26.689]                           if (is.null(version)) 
[10:18:26.689]                             version <- utils::packageVersion("future")
[10:18:26.689]                         }
[10:18:26.689]                         else {
[10:18:26.689]                           version <- NULL
[10:18:26.689]                         }
[10:18:26.689]                         if (!has_future || version < "1.8.0") {
[10:18:26.689]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.689]                             "", base::R.version$version.string), 
[10:18:26.689]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:26.689]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.689]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.689]                               "release", "version")], collapse = " "), 
[10:18:26.689]                             hostname = base::Sys.info()[["nodename"]])
[10:18:26.689]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.689]                             info)
[10:18:26.689]                           info <- base::paste(info, collapse = "; ")
[10:18:26.689]                           if (!has_future) {
[10:18:26.689]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.689]                               info)
[10:18:26.689]                           }
[10:18:26.689]                           else {
[10:18:26.689]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.689]                               info, version)
[10:18:26.689]                           }
[10:18:26.689]                           base::stop(msg)
[10:18:26.689]                         }
[10:18:26.689]                       })
[10:18:26.689]                     }
[10:18:26.689]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:26.689]                     base::options(mc.cores = 1L)
[10:18:26.689]                   }
[10:18:26.689]                   ...future.strategy.old <- future::plan("list")
[10:18:26.689]                   options(future.plan = NULL)
[10:18:26.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.689]                 }
[10:18:26.689]                 ...future.workdir <- getwd()
[10:18:26.689]             }
[10:18:26.689]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.689]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.689]         }
[10:18:26.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.689]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.689]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.689]             base::names(...future.oldOptions))
[10:18:26.689]     }
[10:18:26.689]     if (FALSE) {
[10:18:26.689]     }
[10:18:26.689]     else {
[10:18:26.689]         if (TRUE) {
[10:18:26.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.689]                 open = "w")
[10:18:26.689]         }
[10:18:26.689]         else {
[10:18:26.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.689]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.689]         }
[10:18:26.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.689]             base::sink(type = "output", split = FALSE)
[10:18:26.689]             base::close(...future.stdout)
[10:18:26.689]         }, add = TRUE)
[10:18:26.689]     }
[10:18:26.689]     ...future.frame <- base::sys.nframe()
[10:18:26.689]     ...future.conditions <- base::list()
[10:18:26.689]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.689]     if (FALSE) {
[10:18:26.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.689]     }
[10:18:26.689]     ...future.result <- base::tryCatch({
[10:18:26.689]         base::withCallingHandlers({
[10:18:26.689]             ...future.value <- base::withVisible(base::local({
[10:18:26.689]                 withCallingHandlers({
[10:18:26.689]                   {
[10:18:26.689]                     do.call(function(...) {
[10:18:26.689]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.689]                       if (!identical(...future.globals.maxSize.org, 
[10:18:26.689]                         ...future.globals.maxSize)) {
[10:18:26.689]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.689]                         on.exit(options(oopts), add = TRUE)
[10:18:26.689]                       }
[10:18:26.689]                       {
[10:18:26.689]                         lapply(seq_along(...future.elements_ii), 
[10:18:26.689]                           FUN = function(jj) {
[10:18:26.689]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.689]                             ...future.FUN(...future.X_jj, ...)
[10:18:26.689]                           })
[10:18:26.689]                       }
[10:18:26.689]                     }, args = future.call.arguments)
[10:18:26.689]                   }
[10:18:26.689]                 }, immediateCondition = function(cond) {
[10:18:26.689]                   save_rds <- function (object, pathname, ...) 
[10:18:26.689]                   {
[10:18:26.689]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:26.689]                     if (file_test("-f", pathname_tmp)) {
[10:18:26.689]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.689]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:26.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.689]                         fi_tmp[["mtime"]])
[10:18:26.689]                     }
[10:18:26.689]                     tryCatch({
[10:18:26.689]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:26.689]                     }, error = function(ex) {
[10:18:26.689]                       msg <- conditionMessage(ex)
[10:18:26.689]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.689]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:26.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.689]                         fi_tmp[["mtime"]], msg)
[10:18:26.689]                       ex$message <- msg
[10:18:26.689]                       stop(ex)
[10:18:26.689]                     })
[10:18:26.689]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:26.689]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:26.689]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:26.689]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.689]                       fi <- file.info(pathname)
[10:18:26.689]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:26.689]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.689]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:26.689]                         fi[["size"]], fi[["mtime"]])
[10:18:26.689]                       stop(msg)
[10:18:26.689]                     }
[10:18:26.689]                     invisible(pathname)
[10:18:26.689]                   }
[10:18:26.689]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:26.689]                     rootPath = tempdir()) 
[10:18:26.689]                   {
[10:18:26.689]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:26.689]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:26.689]                       tmpdir = path, fileext = ".rds")
[10:18:26.689]                     save_rds(obj, file)
[10:18:26.689]                   }
[10:18:26.689]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:26.689]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.689]                   {
[10:18:26.689]                     inherits <- base::inherits
[10:18:26.689]                     invokeRestart <- base::invokeRestart
[10:18:26.689]                     is.null <- base::is.null
[10:18:26.689]                     muffled <- FALSE
[10:18:26.689]                     if (inherits(cond, "message")) {
[10:18:26.689]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:26.689]                       if (muffled) 
[10:18:26.689]                         invokeRestart("muffleMessage")
[10:18:26.689]                     }
[10:18:26.689]                     else if (inherits(cond, "warning")) {
[10:18:26.689]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:26.689]                       if (muffled) 
[10:18:26.689]                         invokeRestart("muffleWarning")
[10:18:26.689]                     }
[10:18:26.689]                     else if (inherits(cond, "condition")) {
[10:18:26.689]                       if (!is.null(pattern)) {
[10:18:26.689]                         computeRestarts <- base::computeRestarts
[10:18:26.689]                         grepl <- base::grepl
[10:18:26.689]                         restarts <- computeRestarts(cond)
[10:18:26.689]                         for (restart in restarts) {
[10:18:26.689]                           name <- restart$name
[10:18:26.689]                           if (is.null(name)) 
[10:18:26.689]                             next
[10:18:26.689]                           if (!grepl(pattern, name)) 
[10:18:26.689]                             next
[10:18:26.689]                           invokeRestart(restart)
[10:18:26.689]                           muffled <- TRUE
[10:18:26.689]                           break
[10:18:26.689]                         }
[10:18:26.689]                       }
[10:18:26.689]                     }
[10:18:26.689]                     invisible(muffled)
[10:18:26.689]                   }
[10:18:26.689]                   muffleCondition(cond)
[10:18:26.689]                 })
[10:18:26.689]             }))
[10:18:26.689]             future::FutureResult(value = ...future.value$value, 
[10:18:26.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.689]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.689]                     ...future.globalenv.names))
[10:18:26.689]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.689]         }, condition = base::local({
[10:18:26.689]             c <- base::c
[10:18:26.689]             inherits <- base::inherits
[10:18:26.689]             invokeRestart <- base::invokeRestart
[10:18:26.689]             length <- base::length
[10:18:26.689]             list <- base::list
[10:18:26.689]             seq.int <- base::seq.int
[10:18:26.689]             signalCondition <- base::signalCondition
[10:18:26.689]             sys.calls <- base::sys.calls
[10:18:26.689]             `[[` <- base::`[[`
[10:18:26.689]             `+` <- base::`+`
[10:18:26.689]             `<<-` <- base::`<<-`
[10:18:26.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.689]                   3L)]
[10:18:26.689]             }
[10:18:26.689]             function(cond) {
[10:18:26.689]                 is_error <- inherits(cond, "error")
[10:18:26.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.689]                   NULL)
[10:18:26.689]                 if (is_error) {
[10:18:26.689]                   sessionInformation <- function() {
[10:18:26.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.689]                       search = base::search(), system = base::Sys.info())
[10:18:26.689]                   }
[10:18:26.689]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.689]                     cond$call), session = sessionInformation(), 
[10:18:26.689]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.689]                   signalCondition(cond)
[10:18:26.689]                 }
[10:18:26.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.689]                 "immediateCondition"))) {
[10:18:26.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.689]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.689]                   if (TRUE && !signal) {
[10:18:26.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.689]                     {
[10:18:26.689]                       inherits <- base::inherits
[10:18:26.689]                       invokeRestart <- base::invokeRestart
[10:18:26.689]                       is.null <- base::is.null
[10:18:26.689]                       muffled <- FALSE
[10:18:26.689]                       if (inherits(cond, "message")) {
[10:18:26.689]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.689]                         if (muffled) 
[10:18:26.689]                           invokeRestart("muffleMessage")
[10:18:26.689]                       }
[10:18:26.689]                       else if (inherits(cond, "warning")) {
[10:18:26.689]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.689]                         if (muffled) 
[10:18:26.689]                           invokeRestart("muffleWarning")
[10:18:26.689]                       }
[10:18:26.689]                       else if (inherits(cond, "condition")) {
[10:18:26.689]                         if (!is.null(pattern)) {
[10:18:26.689]                           computeRestarts <- base::computeRestarts
[10:18:26.689]                           grepl <- base::grepl
[10:18:26.689]                           restarts <- computeRestarts(cond)
[10:18:26.689]                           for (restart in restarts) {
[10:18:26.689]                             name <- restart$name
[10:18:26.689]                             if (is.null(name)) 
[10:18:26.689]                               next
[10:18:26.689]                             if (!grepl(pattern, name)) 
[10:18:26.689]                               next
[10:18:26.689]                             invokeRestart(restart)
[10:18:26.689]                             muffled <- TRUE
[10:18:26.689]                             break
[10:18:26.689]                           }
[10:18:26.689]                         }
[10:18:26.689]                       }
[10:18:26.689]                       invisible(muffled)
[10:18:26.689]                     }
[10:18:26.689]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.689]                   }
[10:18:26.689]                 }
[10:18:26.689]                 else {
[10:18:26.689]                   if (TRUE) {
[10:18:26.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.689]                     {
[10:18:26.689]                       inherits <- base::inherits
[10:18:26.689]                       invokeRestart <- base::invokeRestart
[10:18:26.689]                       is.null <- base::is.null
[10:18:26.689]                       muffled <- FALSE
[10:18:26.689]                       if (inherits(cond, "message")) {
[10:18:26.689]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.689]                         if (muffled) 
[10:18:26.689]                           invokeRestart("muffleMessage")
[10:18:26.689]                       }
[10:18:26.689]                       else if (inherits(cond, "warning")) {
[10:18:26.689]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.689]                         if (muffled) 
[10:18:26.689]                           invokeRestart("muffleWarning")
[10:18:26.689]                       }
[10:18:26.689]                       else if (inherits(cond, "condition")) {
[10:18:26.689]                         if (!is.null(pattern)) {
[10:18:26.689]                           computeRestarts <- base::computeRestarts
[10:18:26.689]                           grepl <- base::grepl
[10:18:26.689]                           restarts <- computeRestarts(cond)
[10:18:26.689]                           for (restart in restarts) {
[10:18:26.689]                             name <- restart$name
[10:18:26.689]                             if (is.null(name)) 
[10:18:26.689]                               next
[10:18:26.689]                             if (!grepl(pattern, name)) 
[10:18:26.689]                               next
[10:18:26.689]                             invokeRestart(restart)
[10:18:26.689]                             muffled <- TRUE
[10:18:26.689]                             break
[10:18:26.689]                           }
[10:18:26.689]                         }
[10:18:26.689]                       }
[10:18:26.689]                       invisible(muffled)
[10:18:26.689]                     }
[10:18:26.689]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.689]                   }
[10:18:26.689]                 }
[10:18:26.689]             }
[10:18:26.689]         }))
[10:18:26.689]     }, error = function(ex) {
[10:18:26.689]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.689]                 ...future.rng), started = ...future.startTime, 
[10:18:26.689]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.689]             version = "1.8"), class = "FutureResult")
[10:18:26.689]     }, finally = {
[10:18:26.689]         if (!identical(...future.workdir, getwd())) 
[10:18:26.689]             setwd(...future.workdir)
[10:18:26.689]         {
[10:18:26.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.689]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.689]             }
[10:18:26.689]             base::options(...future.oldOptions)
[10:18:26.689]             if (.Platform$OS.type == "windows") {
[10:18:26.689]                 old_names <- names(...future.oldEnvVars)
[10:18:26.689]                 envs <- base::Sys.getenv()
[10:18:26.689]                 names <- names(envs)
[10:18:26.689]                 common <- intersect(names, old_names)
[10:18:26.689]                 added <- setdiff(names, old_names)
[10:18:26.689]                 removed <- setdiff(old_names, names)
[10:18:26.689]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.689]                   envs[common]]
[10:18:26.689]                 NAMES <- toupper(changed)
[10:18:26.689]                 args <- list()
[10:18:26.689]                 for (kk in seq_along(NAMES)) {
[10:18:26.689]                   name <- changed[[kk]]
[10:18:26.689]                   NAME <- NAMES[[kk]]
[10:18:26.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.689]                     next
[10:18:26.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.689]                 }
[10:18:26.689]                 NAMES <- toupper(added)
[10:18:26.689]                 for (kk in seq_along(NAMES)) {
[10:18:26.689]                   name <- added[[kk]]
[10:18:26.689]                   NAME <- NAMES[[kk]]
[10:18:26.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.689]                     next
[10:18:26.689]                   args[[name]] <- ""
[10:18:26.689]                 }
[10:18:26.689]                 NAMES <- toupper(removed)
[10:18:26.689]                 for (kk in seq_along(NAMES)) {
[10:18:26.689]                   name <- removed[[kk]]
[10:18:26.689]                   NAME <- NAMES[[kk]]
[10:18:26.689]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.689]                     next
[10:18:26.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.689]                 }
[10:18:26.689]                 if (length(args) > 0) 
[10:18:26.689]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.689]             }
[10:18:26.689]             else {
[10:18:26.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.689]             }
[10:18:26.689]             {
[10:18:26.689]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.689]                   0L) {
[10:18:26.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.689]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.689]                   base::options(opts)
[10:18:26.689]                 }
[10:18:26.689]                 {
[10:18:26.689]                   {
[10:18:26.689]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:26.689]                     NULL
[10:18:26.689]                   }
[10:18:26.689]                   options(future.plan = NULL)
[10:18:26.689]                   if (is.na(NA_character_)) 
[10:18:26.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.689]                     .init = FALSE)
[10:18:26.689]                 }
[10:18:26.689]             }
[10:18:26.689]         }
[10:18:26.689]     })
[10:18:26.689]     if (TRUE) {
[10:18:26.689]         base::sink(type = "output", split = FALSE)
[10:18:26.689]         if (TRUE) {
[10:18:26.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.689]         }
[10:18:26.689]         else {
[10:18:26.689]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.689]         }
[10:18:26.689]         base::close(...future.stdout)
[10:18:26.689]         ...future.stdout <- NULL
[10:18:26.689]     }
[10:18:26.689]     ...future.result$conditions <- ...future.conditions
[10:18:26.689]     ...future.result$finished <- base::Sys.time()
[10:18:26.689]     ...future.result
[10:18:26.689] }
[10:18:26.692] assign_globals() ...
[10:18:26.692] List of 5
[10:18:26.692]  $ future.call.arguments    : list()
[10:18:26.692]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.692]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.692]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.692]  $ ...future.elements_ii    :List of 1
[10:18:26.692]   ..$ : num [1:4] 1 3 1 7
[10:18:26.692]  $ ...future.seeds_ii       : NULL
[10:18:26.692]  $ ...future.globals.maxSize: num Inf
[10:18:26.692]  - attr(*, "resolved")= logi FALSE
[10:18:26.692]  - attr(*, "total_size")= num NA
[10:18:26.692]  - attr(*, "where")=List of 5
[10:18:26.692]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.692]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.692]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.692]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.692]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.692]  - attr(*, "already-done")= logi TRUE
[10:18:26.699] - copied ‘future.call.arguments’ to environment
[10:18:26.699] - copied ‘...future.FUN’ to environment
[10:18:26.699] - copied ‘...future.elements_ii’ to environment
[10:18:26.699] - copied ‘...future.seeds_ii’ to environment
[10:18:26.699] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.699] assign_globals() ... done
[10:18:26.699] requestCore(): workers = 2
[10:18:26.703] MulticoreFuture started
[10:18:26.703] - Launch lazy future ... done
[10:18:26.703] plan(): Setting new future strategy stack:
[10:18:26.703] run() for ‘MulticoreFuture’ ... done
[10:18:26.704] Created future:
[10:18:26.704] List of future strategies:
[10:18:26.704] 1. sequential:
[10:18:26.704]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.704]    - tweaked: FALSE
[10:18:26.704]    - call: NULL
[10:18:26.705] plan(): nbrOfWorkers() = 1
[10:18:26.708] plan(): Setting new future strategy stack:
[10:18:26.708] List of future strategies:
[10:18:26.708] 1. multicore:
[10:18:26.708]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:26.708]    - tweaked: FALSE
[10:18:26.708]    - call: plan(strategy)
[10:18:26.711] plan(): nbrOfWorkers() = 2
[10:18:26.704] MulticoreFuture:
[10:18:26.704] Label: ‘future_apply-1’
[10:18:26.704] Expression:
[10:18:26.704] {
[10:18:26.704]     do.call(function(...) {
[10:18:26.704]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.704]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.704]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.704]             on.exit(options(oopts), add = TRUE)
[10:18:26.704]         }
[10:18:26.704]         {
[10:18:26.704]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.704]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.704]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.704]             })
[10:18:26.704]         }
[10:18:26.704]     }, args = future.call.arguments)
[10:18:26.704] }
[10:18:26.704] Lazy evaluation: FALSE
[10:18:26.704] Asynchronous evaluation: TRUE
[10:18:26.704] Local evaluation: TRUE
[10:18:26.704] Environment: R_GlobalEnv
[10:18:26.704] Capture standard output: TRUE
[10:18:26.704] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.704] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.704] Packages: <none>
[10:18:26.704] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.704] Resolved: TRUE
[10:18:26.704] Value: <not collected>
[10:18:26.704] Conditions captured: <none>
[10:18:26.704] Early signaling: FALSE
[10:18:26.704] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.704] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:26.713] Chunk #1 of 2 ... DONE
[10:18:26.713] Chunk #2 of 2 ...
[10:18:26.713]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:26.713]  - seeds: <none>
[10:18:26.713]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.714] getGlobalsAndPackages() ...
[10:18:26.714] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.714] Resolving globals: FALSE
[10:18:26.714] Tweak future expression to call with '...' arguments ...
[10:18:26.714] {
[10:18:26.714]     do.call(function(...) {
[10:18:26.714]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.714]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.714]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.714]             on.exit(options(oopts), add = TRUE)
[10:18:26.714]         }
[10:18:26.714]         {
[10:18:26.714]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.714]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.714]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.714]             })
[10:18:26.714]         }
[10:18:26.714]     }, args = future.call.arguments)
[10:18:26.714] }
[10:18:26.715] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.716] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.716] 
[10:18:26.716] getGlobalsAndPackages() ... DONE
[10:18:26.717] run() for ‘Future’ ...
[10:18:26.717] - state: ‘created’
[10:18:26.717] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:26.721] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:26.721] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:26.721]   - Field: ‘label’
[10:18:26.722]   - Field: ‘local’
[10:18:26.722]   - Field: ‘owner’
[10:18:26.722]   - Field: ‘envir’
[10:18:26.722]   - Field: ‘workers’
[10:18:26.722]   - Field: ‘packages’
[10:18:26.722]   - Field: ‘gc’
[10:18:26.723]   - Field: ‘job’
[10:18:26.723]   - Field: ‘conditions’
[10:18:26.723]   - Field: ‘expr’
[10:18:26.723]   - Field: ‘uuid’
[10:18:26.723]   - Field: ‘seed’
[10:18:26.723]   - Field: ‘version’
[10:18:26.723]   - Field: ‘result’
[10:18:26.724]   - Field: ‘asynchronous’
[10:18:26.724]   - Field: ‘calls’
[10:18:26.724]   - Field: ‘globals’
[10:18:26.724]   - Field: ‘stdout’
[10:18:26.724]   - Field: ‘earlySignal’
[10:18:26.724]   - Field: ‘lazy’
[10:18:26.724]   - Field: ‘state’
[10:18:26.725] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:26.725] - Launch lazy future ...
[10:18:26.725] Packages needed by the future expression (n = 0): <none>
[10:18:26.725] Packages needed by future strategies (n = 0): <none>
[10:18:26.726] {
[10:18:26.726]     {
[10:18:26.726]         {
[10:18:26.726]             ...future.startTime <- base::Sys.time()
[10:18:26.726]             {
[10:18:26.726]                 {
[10:18:26.726]                   {
[10:18:26.726]                     {
[10:18:26.726]                       base::local({
[10:18:26.726]                         has_future <- base::requireNamespace("future", 
[10:18:26.726]                           quietly = TRUE)
[10:18:26.726]                         if (has_future) {
[10:18:26.726]                           ns <- base::getNamespace("future")
[10:18:26.726]                           version <- ns[[".package"]][["version"]]
[10:18:26.726]                           if (is.null(version)) 
[10:18:26.726]                             version <- utils::packageVersion("future")
[10:18:26.726]                         }
[10:18:26.726]                         else {
[10:18:26.726]                           version <- NULL
[10:18:26.726]                         }
[10:18:26.726]                         if (!has_future || version < "1.8.0") {
[10:18:26.726]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.726]                             "", base::R.version$version.string), 
[10:18:26.726]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:26.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.726]                               "release", "version")], collapse = " "), 
[10:18:26.726]                             hostname = base::Sys.info()[["nodename"]])
[10:18:26.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.726]                             info)
[10:18:26.726]                           info <- base::paste(info, collapse = "; ")
[10:18:26.726]                           if (!has_future) {
[10:18:26.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.726]                               info)
[10:18:26.726]                           }
[10:18:26.726]                           else {
[10:18:26.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.726]                               info, version)
[10:18:26.726]                           }
[10:18:26.726]                           base::stop(msg)
[10:18:26.726]                         }
[10:18:26.726]                       })
[10:18:26.726]                     }
[10:18:26.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:26.726]                     base::options(mc.cores = 1L)
[10:18:26.726]                   }
[10:18:26.726]                   ...future.strategy.old <- future::plan("list")
[10:18:26.726]                   options(future.plan = NULL)
[10:18:26.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.726]                 }
[10:18:26.726]                 ...future.workdir <- getwd()
[10:18:26.726]             }
[10:18:26.726]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.726]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.726]         }
[10:18:26.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.726]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.726]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.726]             base::names(...future.oldOptions))
[10:18:26.726]     }
[10:18:26.726]     if (FALSE) {
[10:18:26.726]     }
[10:18:26.726]     else {
[10:18:26.726]         if (TRUE) {
[10:18:26.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.726]                 open = "w")
[10:18:26.726]         }
[10:18:26.726]         else {
[10:18:26.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.726]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.726]         }
[10:18:26.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.726]             base::sink(type = "output", split = FALSE)
[10:18:26.726]             base::close(...future.stdout)
[10:18:26.726]         }, add = TRUE)
[10:18:26.726]     }
[10:18:26.726]     ...future.frame <- base::sys.nframe()
[10:18:26.726]     ...future.conditions <- base::list()
[10:18:26.726]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.726]     if (FALSE) {
[10:18:26.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.726]     }
[10:18:26.726]     ...future.result <- base::tryCatch({
[10:18:26.726]         base::withCallingHandlers({
[10:18:26.726]             ...future.value <- base::withVisible(base::local({
[10:18:26.726]                 withCallingHandlers({
[10:18:26.726]                   {
[10:18:26.726]                     do.call(function(...) {
[10:18:26.726]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.726]                       if (!identical(...future.globals.maxSize.org, 
[10:18:26.726]                         ...future.globals.maxSize)) {
[10:18:26.726]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.726]                         on.exit(options(oopts), add = TRUE)
[10:18:26.726]                       }
[10:18:26.726]                       {
[10:18:26.726]                         lapply(seq_along(...future.elements_ii), 
[10:18:26.726]                           FUN = function(jj) {
[10:18:26.726]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.726]                             ...future.FUN(...future.X_jj, ...)
[10:18:26.726]                           })
[10:18:26.726]                       }
[10:18:26.726]                     }, args = future.call.arguments)
[10:18:26.726]                   }
[10:18:26.726]                 }, immediateCondition = function(cond) {
[10:18:26.726]                   save_rds <- function (object, pathname, ...) 
[10:18:26.726]                   {
[10:18:26.726]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:26.726]                     if (file_test("-f", pathname_tmp)) {
[10:18:26.726]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.726]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:26.726]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.726]                         fi_tmp[["mtime"]])
[10:18:26.726]                     }
[10:18:26.726]                     tryCatch({
[10:18:26.726]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:26.726]                     }, error = function(ex) {
[10:18:26.726]                       msg <- conditionMessage(ex)
[10:18:26.726]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.726]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:26.726]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.726]                         fi_tmp[["mtime"]], msg)
[10:18:26.726]                       ex$message <- msg
[10:18:26.726]                       stop(ex)
[10:18:26.726]                     })
[10:18:26.726]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:26.726]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:26.726]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:26.726]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.726]                       fi <- file.info(pathname)
[10:18:26.726]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:26.726]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.726]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:26.726]                         fi[["size"]], fi[["mtime"]])
[10:18:26.726]                       stop(msg)
[10:18:26.726]                     }
[10:18:26.726]                     invisible(pathname)
[10:18:26.726]                   }
[10:18:26.726]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:26.726]                     rootPath = tempdir()) 
[10:18:26.726]                   {
[10:18:26.726]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:26.726]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:26.726]                       tmpdir = path, fileext = ".rds")
[10:18:26.726]                     save_rds(obj, file)
[10:18:26.726]                   }
[10:18:26.726]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:26.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.726]                   {
[10:18:26.726]                     inherits <- base::inherits
[10:18:26.726]                     invokeRestart <- base::invokeRestart
[10:18:26.726]                     is.null <- base::is.null
[10:18:26.726]                     muffled <- FALSE
[10:18:26.726]                     if (inherits(cond, "message")) {
[10:18:26.726]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:26.726]                       if (muffled) 
[10:18:26.726]                         invokeRestart("muffleMessage")
[10:18:26.726]                     }
[10:18:26.726]                     else if (inherits(cond, "warning")) {
[10:18:26.726]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:26.726]                       if (muffled) 
[10:18:26.726]                         invokeRestart("muffleWarning")
[10:18:26.726]                     }
[10:18:26.726]                     else if (inherits(cond, "condition")) {
[10:18:26.726]                       if (!is.null(pattern)) {
[10:18:26.726]                         computeRestarts <- base::computeRestarts
[10:18:26.726]                         grepl <- base::grepl
[10:18:26.726]                         restarts <- computeRestarts(cond)
[10:18:26.726]                         for (restart in restarts) {
[10:18:26.726]                           name <- restart$name
[10:18:26.726]                           if (is.null(name)) 
[10:18:26.726]                             next
[10:18:26.726]                           if (!grepl(pattern, name)) 
[10:18:26.726]                             next
[10:18:26.726]                           invokeRestart(restart)
[10:18:26.726]                           muffled <- TRUE
[10:18:26.726]                           break
[10:18:26.726]                         }
[10:18:26.726]                       }
[10:18:26.726]                     }
[10:18:26.726]                     invisible(muffled)
[10:18:26.726]                   }
[10:18:26.726]                   muffleCondition(cond)
[10:18:26.726]                 })
[10:18:26.726]             }))
[10:18:26.726]             future::FutureResult(value = ...future.value$value, 
[10:18:26.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.726]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.726]                     ...future.globalenv.names))
[10:18:26.726]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.726]         }, condition = base::local({
[10:18:26.726]             c <- base::c
[10:18:26.726]             inherits <- base::inherits
[10:18:26.726]             invokeRestart <- base::invokeRestart
[10:18:26.726]             length <- base::length
[10:18:26.726]             list <- base::list
[10:18:26.726]             seq.int <- base::seq.int
[10:18:26.726]             signalCondition <- base::signalCondition
[10:18:26.726]             sys.calls <- base::sys.calls
[10:18:26.726]             `[[` <- base::`[[`
[10:18:26.726]             `+` <- base::`+`
[10:18:26.726]             `<<-` <- base::`<<-`
[10:18:26.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.726]                   3L)]
[10:18:26.726]             }
[10:18:26.726]             function(cond) {
[10:18:26.726]                 is_error <- inherits(cond, "error")
[10:18:26.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.726]                   NULL)
[10:18:26.726]                 if (is_error) {
[10:18:26.726]                   sessionInformation <- function() {
[10:18:26.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.726]                       search = base::search(), system = base::Sys.info())
[10:18:26.726]                   }
[10:18:26.726]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.726]                     cond$call), session = sessionInformation(), 
[10:18:26.726]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.726]                   signalCondition(cond)
[10:18:26.726]                 }
[10:18:26.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.726]                 "immediateCondition"))) {
[10:18:26.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.726]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.726]                   if (TRUE && !signal) {
[10:18:26.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.726]                     {
[10:18:26.726]                       inherits <- base::inherits
[10:18:26.726]                       invokeRestart <- base::invokeRestart
[10:18:26.726]                       is.null <- base::is.null
[10:18:26.726]                       muffled <- FALSE
[10:18:26.726]                       if (inherits(cond, "message")) {
[10:18:26.726]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.726]                         if (muffled) 
[10:18:26.726]                           invokeRestart("muffleMessage")
[10:18:26.726]                       }
[10:18:26.726]                       else if (inherits(cond, "warning")) {
[10:18:26.726]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.726]                         if (muffled) 
[10:18:26.726]                           invokeRestart("muffleWarning")
[10:18:26.726]                       }
[10:18:26.726]                       else if (inherits(cond, "condition")) {
[10:18:26.726]                         if (!is.null(pattern)) {
[10:18:26.726]                           computeRestarts <- base::computeRestarts
[10:18:26.726]                           grepl <- base::grepl
[10:18:26.726]                           restarts <- computeRestarts(cond)
[10:18:26.726]                           for (restart in restarts) {
[10:18:26.726]                             name <- restart$name
[10:18:26.726]                             if (is.null(name)) 
[10:18:26.726]                               next
[10:18:26.726]                             if (!grepl(pattern, name)) 
[10:18:26.726]                               next
[10:18:26.726]                             invokeRestart(restart)
[10:18:26.726]                             muffled <- TRUE
[10:18:26.726]                             break
[10:18:26.726]                           }
[10:18:26.726]                         }
[10:18:26.726]                       }
[10:18:26.726]                       invisible(muffled)
[10:18:26.726]                     }
[10:18:26.726]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.726]                   }
[10:18:26.726]                 }
[10:18:26.726]                 else {
[10:18:26.726]                   if (TRUE) {
[10:18:26.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.726]                     {
[10:18:26.726]                       inherits <- base::inherits
[10:18:26.726]                       invokeRestart <- base::invokeRestart
[10:18:26.726]                       is.null <- base::is.null
[10:18:26.726]                       muffled <- FALSE
[10:18:26.726]                       if (inherits(cond, "message")) {
[10:18:26.726]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.726]                         if (muffled) 
[10:18:26.726]                           invokeRestart("muffleMessage")
[10:18:26.726]                       }
[10:18:26.726]                       else if (inherits(cond, "warning")) {
[10:18:26.726]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.726]                         if (muffled) 
[10:18:26.726]                           invokeRestart("muffleWarning")
[10:18:26.726]                       }
[10:18:26.726]                       else if (inherits(cond, "condition")) {
[10:18:26.726]                         if (!is.null(pattern)) {
[10:18:26.726]                           computeRestarts <- base::computeRestarts
[10:18:26.726]                           grepl <- base::grepl
[10:18:26.726]                           restarts <- computeRestarts(cond)
[10:18:26.726]                           for (restart in restarts) {
[10:18:26.726]                             name <- restart$name
[10:18:26.726]                             if (is.null(name)) 
[10:18:26.726]                               next
[10:18:26.726]                             if (!grepl(pattern, name)) 
[10:18:26.726]                               next
[10:18:26.726]                             invokeRestart(restart)
[10:18:26.726]                             muffled <- TRUE
[10:18:26.726]                             break
[10:18:26.726]                           }
[10:18:26.726]                         }
[10:18:26.726]                       }
[10:18:26.726]                       invisible(muffled)
[10:18:26.726]                     }
[10:18:26.726]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.726]                   }
[10:18:26.726]                 }
[10:18:26.726]             }
[10:18:26.726]         }))
[10:18:26.726]     }, error = function(ex) {
[10:18:26.726]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.726]                 ...future.rng), started = ...future.startTime, 
[10:18:26.726]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.726]             version = "1.8"), class = "FutureResult")
[10:18:26.726]     }, finally = {
[10:18:26.726]         if (!identical(...future.workdir, getwd())) 
[10:18:26.726]             setwd(...future.workdir)
[10:18:26.726]         {
[10:18:26.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.726]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.726]             }
[10:18:26.726]             base::options(...future.oldOptions)
[10:18:26.726]             if (.Platform$OS.type == "windows") {
[10:18:26.726]                 old_names <- names(...future.oldEnvVars)
[10:18:26.726]                 envs <- base::Sys.getenv()
[10:18:26.726]                 names <- names(envs)
[10:18:26.726]                 common <- intersect(names, old_names)
[10:18:26.726]                 added <- setdiff(names, old_names)
[10:18:26.726]                 removed <- setdiff(old_names, names)
[10:18:26.726]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.726]                   envs[common]]
[10:18:26.726]                 NAMES <- toupper(changed)
[10:18:26.726]                 args <- list()
[10:18:26.726]                 for (kk in seq_along(NAMES)) {
[10:18:26.726]                   name <- changed[[kk]]
[10:18:26.726]                   NAME <- NAMES[[kk]]
[10:18:26.726]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.726]                     next
[10:18:26.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.726]                 }
[10:18:26.726]                 NAMES <- toupper(added)
[10:18:26.726]                 for (kk in seq_along(NAMES)) {
[10:18:26.726]                   name <- added[[kk]]
[10:18:26.726]                   NAME <- NAMES[[kk]]
[10:18:26.726]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.726]                     next
[10:18:26.726]                   args[[name]] <- ""
[10:18:26.726]                 }
[10:18:26.726]                 NAMES <- toupper(removed)
[10:18:26.726]                 for (kk in seq_along(NAMES)) {
[10:18:26.726]                   name <- removed[[kk]]
[10:18:26.726]                   NAME <- NAMES[[kk]]
[10:18:26.726]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.726]                     next
[10:18:26.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.726]                 }
[10:18:26.726]                 if (length(args) > 0) 
[10:18:26.726]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.726]             }
[10:18:26.726]             else {
[10:18:26.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.726]             }
[10:18:26.726]             {
[10:18:26.726]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.726]                   0L) {
[10:18:26.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.726]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.726]                   base::options(opts)
[10:18:26.726]                 }
[10:18:26.726]                 {
[10:18:26.726]                   {
[10:18:26.726]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:26.726]                     NULL
[10:18:26.726]                   }
[10:18:26.726]                   options(future.plan = NULL)
[10:18:26.726]                   if (is.na(NA_character_)) 
[10:18:26.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.726]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.726]                     .init = FALSE)
[10:18:26.726]                 }
[10:18:26.726]             }
[10:18:26.726]         }
[10:18:26.726]     })
[10:18:26.726]     if (TRUE) {
[10:18:26.726]         base::sink(type = "output", split = FALSE)
[10:18:26.726]         if (TRUE) {
[10:18:26.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.726]         }
[10:18:26.726]         else {
[10:18:26.726]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.726]         }
[10:18:26.726]         base::close(...future.stdout)
[10:18:26.726]         ...future.stdout <- NULL
[10:18:26.726]     }
[10:18:26.726]     ...future.result$conditions <- ...future.conditions
[10:18:26.726]     ...future.result$finished <- base::Sys.time()
[10:18:26.726]     ...future.result
[10:18:26.726] }
[10:18:26.729] assign_globals() ...
[10:18:26.729] List of 5
[10:18:26.729]  $ future.call.arguments    : list()
[10:18:26.729]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.729]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.729]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.729]  $ ...future.elements_ii    :List of 1
[10:18:26.729]   ..$ : num [1:4] 2 4 6 8
[10:18:26.729]  $ ...future.seeds_ii       : NULL
[10:18:26.729]  $ ...future.globals.maxSize: num Inf
[10:18:26.729]  - attr(*, "resolved")= logi FALSE
[10:18:26.729]  - attr(*, "total_size")= num NA
[10:18:26.729]  - attr(*, "where")=List of 5
[10:18:26.729]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.729]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.729]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.729]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.729]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.729]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.729]  - attr(*, "already-done")= logi TRUE
[10:18:26.737] - copied ‘future.call.arguments’ to environment
[10:18:26.737] - copied ‘...future.FUN’ to environment
[10:18:26.737] - copied ‘...future.elements_ii’ to environment
[10:18:26.737] - copied ‘...future.seeds_ii’ to environment
[10:18:26.737] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.737] assign_globals() ... done
[10:18:26.738] requestCore(): workers = 2
[10:18:26.743] MulticoreFuture started
[10:18:26.744] - Launch lazy future ... done
[10:18:26.744] run() for ‘MulticoreFuture’ ... done
[10:18:26.745] plan(): Setting new future strategy stack:
[10:18:26.744] Created future:
[10:18:26.745] List of future strategies:
[10:18:26.745] 1. sequential:
[10:18:26.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.745]    - tweaked: FALSE
[10:18:26.745]    - call: NULL
[10:18:26.750] plan(): nbrOfWorkers() = 1
[10:18:26.754] plan(): Setting new future strategy stack:
[10:18:26.754] List of future strategies:
[10:18:26.754] 1. multicore:
[10:18:26.754]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:26.754]    - tweaked: FALSE
[10:18:26.754]    - call: plan(strategy)
[10:18:26.758] plan(): nbrOfWorkers() = 2
[10:18:26.749] MulticoreFuture:
[10:18:26.749] Label: ‘future_apply-2’
[10:18:26.749] Expression:
[10:18:26.749] {
[10:18:26.749]     do.call(function(...) {
[10:18:26.749]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.749]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.749]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.749]             on.exit(options(oopts), add = TRUE)
[10:18:26.749]         }
[10:18:26.749]         {
[10:18:26.749]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.749]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.749]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.749]             })
[10:18:26.749]         }
[10:18:26.749]     }, args = future.call.arguments)
[10:18:26.749] }
[10:18:26.749] Lazy evaluation: FALSE
[10:18:26.749] Asynchronous evaluation: TRUE
[10:18:26.749] Local evaluation: TRUE
[10:18:26.749] Environment: R_GlobalEnv
[10:18:26.749] Capture standard output: TRUE
[10:18:26.749] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.749] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.749] Packages: <none>
[10:18:26.749] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.749] Resolved: TRUE
[10:18:26.749] Value: <not collected>
[10:18:26.749] Conditions captured: <none>
[10:18:26.749] Early signaling: FALSE
[10:18:26.749] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.749] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:26.759] Chunk #2 of 2 ... DONE
[10:18:26.759] Launching 2 futures (chunks) ... DONE
[10:18:26.760] Resolving 2 futures (chunks) ...
[10:18:26.760] resolve() on list ...
[10:18:26.760]  recursive: 0
[10:18:26.760]  length: 2
[10:18:26.761] 
[10:18:26.761] Future #1
[10:18:26.762] result() for MulticoreFuture ...
[10:18:26.763] result() for MulticoreFuture ...
[10:18:26.763] result() for MulticoreFuture ... done
[10:18:26.763] result() for MulticoreFuture ... done
[10:18:26.764] result() for MulticoreFuture ...
[10:18:26.764] result() for MulticoreFuture ... done
[10:18:26.764] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:26.764] - nx: 2
[10:18:26.764] - relay: TRUE
[10:18:26.764] - stdout: TRUE
[10:18:26.765] - signal: TRUE
[10:18:26.765] - resignal: FALSE
[10:18:26.765] - force: TRUE
[10:18:26.765] - relayed: [n=2] FALSE, FALSE
[10:18:26.765] - queued futures: [n=2] FALSE, FALSE
[10:18:26.765]  - until=1
[10:18:26.765]  - relaying element #1
[10:18:26.766] result() for MulticoreFuture ...
[10:18:26.766] result() for MulticoreFuture ... done
[10:18:26.766] result() for MulticoreFuture ...
[10:18:26.766] result() for MulticoreFuture ... done
[10:18:26.766] result() for MulticoreFuture ...
[10:18:26.766] result() for MulticoreFuture ... done
[10:18:26.767] result() for MulticoreFuture ...
[10:18:26.767] result() for MulticoreFuture ... done
[10:18:26.767] - relayed: [n=2] TRUE, FALSE
[10:18:26.767] - queued futures: [n=2] TRUE, FALSE
[10:18:26.767] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:26.767]  length: 1 (resolved future 1)
[10:18:26.768] Future #2
[10:18:26.768] result() for MulticoreFuture ...
[10:18:26.768] result() for MulticoreFuture ...
[10:18:26.769] result() for MulticoreFuture ... done
[10:18:26.769] result() for MulticoreFuture ... done
[10:18:26.769] result() for MulticoreFuture ...
[10:18:26.769] result() for MulticoreFuture ... done
[10:18:26.769] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:26.769] - nx: 2
[10:18:26.769] - relay: TRUE
[10:18:26.769] - stdout: TRUE
[10:18:26.770] - signal: TRUE
[10:18:26.770] - resignal: FALSE
[10:18:26.770] - force: TRUE
[10:18:26.770] - relayed: [n=2] TRUE, FALSE
[10:18:26.770] - queued futures: [n=2] TRUE, FALSE
[10:18:26.770]  - until=2
[10:18:26.770]  - relaying element #2
[10:18:26.770] result() for MulticoreFuture ...
[10:18:26.770] result() for MulticoreFuture ... done
[10:18:26.771] result() for MulticoreFuture ...
[10:18:26.771] result() for MulticoreFuture ... done
[10:18:26.771] result() for MulticoreFuture ...
[10:18:26.771] result() for MulticoreFuture ... done
[10:18:26.771] result() for MulticoreFuture ...
[10:18:26.771] result() for MulticoreFuture ... done
[10:18:26.771] - relayed: [n=2] TRUE, TRUE
[10:18:26.771] - queued futures: [n=2] TRUE, TRUE
[10:18:26.772] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:26.772]  length: 0 (resolved future 2)
[10:18:26.772] Relaying remaining futures
[10:18:26.772] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.772] - nx: 2
[10:18:26.772] - relay: TRUE
[10:18:26.772] - stdout: TRUE
[10:18:26.772] - signal: TRUE
[10:18:26.772] - resignal: FALSE
[10:18:26.772] - force: TRUE
[10:18:26.773] - relayed: [n=2] TRUE, TRUE
[10:18:26.773] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:26.773] - relayed: [n=2] TRUE, TRUE
[10:18:26.773] - queued futures: [n=2] TRUE, TRUE
[10:18:26.773] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.773] resolve() on list ... DONE
[10:18:26.773] result() for MulticoreFuture ...
[10:18:26.773] result() for MulticoreFuture ... done
[10:18:26.773] result() for MulticoreFuture ...
[10:18:26.774] result() for MulticoreFuture ... done
[10:18:26.774] result() for MulticoreFuture ...
[10:18:26.774] result() for MulticoreFuture ... done
[10:18:26.774] result() for MulticoreFuture ...
[10:18:26.774] result() for MulticoreFuture ... done
[10:18:26.774]  - Number of value chunks collected: 2
[10:18:26.774] Resolving 2 futures (chunks) ... DONE
[10:18:26.774] Reducing values from 2 chunks ...
[10:18:26.774]  - Number of values collected after concatenation: 2
[10:18:26.774]  - Number of values expected: 2
[10:18:26.775] Reducing values from 2 chunks ... DONE
[10:18:26.775] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:18:26.775] getGlobalsAndPackagesXApply() ...
[10:18:26.775]  - future.globals: TRUE
[10:18:26.775] getGlobalsAndPackages() ...
[10:18:26.776] Searching for globals...
[10:18:26.813] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:18:26.813] Searching for globals ... DONE
[10:18:26.813] Resolving globals: FALSE
[10:18:26.815] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:18:26.815] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:18:26.816] - globals: [1] ‘FUN’
[10:18:26.816] 
[10:18:26.816] getGlobalsAndPackages() ... DONE
[10:18:26.816]  - globals found/used: [n=1] ‘FUN’
[10:18:26.816]  - needed namespaces: [n=0] 
[10:18:26.816] Finding globals ... DONE
[10:18:26.816]  - use_args: TRUE
[10:18:26.816]  - Getting '...' globals ...
[10:18:26.817] resolve() on list ...
[10:18:26.817]  recursive: 0
[10:18:26.817]  length: 1
[10:18:26.817]  elements: ‘...’
[10:18:26.817]  length: 0 (resolved future 1)
[10:18:26.817] resolve() on list ... DONE
[10:18:26.817]    - '...' content: [n=0] 
[10:18:26.817] List of 1
[10:18:26.817]  $ ...: list()
[10:18:26.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.817]  - attr(*, "where")=List of 1
[10:18:26.817]   ..$ ...:<environment: 0x556e036417f0> 
[10:18:26.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.817]  - attr(*, "resolved")= logi TRUE
[10:18:26.817]  - attr(*, "total_size")= num NA
[10:18:26.820]  - Getting '...' globals ... DONE
[10:18:26.820] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.820] List of 2
[10:18:26.820]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.820]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.820]  $ ...          : list()
[10:18:26.820]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.820]  - attr(*, "where")=List of 2
[10:18:26.820]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.820]   ..$ ...          :<environment: 0x556e036417f0> 
[10:18:26.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.820]  - attr(*, "resolved")= logi FALSE
[10:18:26.820]  - attr(*, "total_size")= num 65967
[10:18:26.825] Packages to be attached in all futures: [n=0] 
[10:18:26.825] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.827] future_lapply() ...
[10:18:26.861] Number of chunks: 2
[10:18:26.861] getGlobalsAndPackagesXApply() ...
[10:18:26.861]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.861]  - use_args: TRUE
[10:18:26.861] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.862] List of 2
[10:18:26.862]  $ ...          : list()
[10:18:26.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.862]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.862]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.862]  - attr(*, "where")=List of 2
[10:18:26.862]   ..$ ...          :<environment: 0x556e036417f0> 
[10:18:26.862]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:26.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.862]  - attr(*, "resolved")= logi FALSE
[10:18:26.862]  - attr(*, "total_size")= num NA
[10:18:26.865] Packages to be attached in all futures: [n=0] 
[10:18:26.865] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.865] Number of futures (= number of chunks): 2
[10:18:26.865] Launching 2 futures (chunks) ...
[10:18:26.866] Chunk #1 of 2 ...
[10:18:26.866]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:26.866]  - seeds: <none>
[10:18:26.866]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.866] getGlobalsAndPackages() ...
[10:18:26.866] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.866] Resolving globals: FALSE
[10:18:26.866] Tweak future expression to call with '...' arguments ...
[10:18:26.866] {
[10:18:26.866]     do.call(function(...) {
[10:18:26.866]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.866]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.866]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.866]             on.exit(options(oopts), add = TRUE)
[10:18:26.866]         }
[10:18:26.866]         {
[10:18:26.866]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.866]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.866]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.866]             })
[10:18:26.866]         }
[10:18:26.866]     }, args = future.call.arguments)
[10:18:26.866] }
[10:18:26.867] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.867] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.867] 
[10:18:26.867] getGlobalsAndPackages() ... DONE
[10:18:26.868] run() for ‘Future’ ...
[10:18:26.868] - state: ‘created’
[10:18:26.868] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:26.870] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:26.870] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:26.870]   - Field: ‘label’
[10:18:26.870]   - Field: ‘local’
[10:18:26.870]   - Field: ‘owner’
[10:18:26.870]   - Field: ‘envir’
[10:18:26.870]   - Field: ‘workers’
[10:18:26.870]   - Field: ‘packages’
[10:18:26.870]   - Field: ‘gc’
[10:18:26.870]   - Field: ‘job’
[10:18:26.870]   - Field: ‘conditions’
[10:18:26.871]   - Field: ‘expr’
[10:18:26.871]   - Field: ‘uuid’
[10:18:26.871]   - Field: ‘seed’
[10:18:26.871]   - Field: ‘version’
[10:18:26.871]   - Field: ‘result’
[10:18:26.871]   - Field: ‘asynchronous’
[10:18:26.871]   - Field: ‘calls’
[10:18:26.871]   - Field: ‘globals’
[10:18:26.871]   - Field: ‘stdout’
[10:18:26.871]   - Field: ‘earlySignal’
[10:18:26.871]   - Field: ‘lazy’
[10:18:26.871]   - Field: ‘state’
[10:18:26.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:26.872] - Launch lazy future ...
[10:18:26.872] Packages needed by the future expression (n = 0): <none>
[10:18:26.872] Packages needed by future strategies (n = 0): <none>
[10:18:26.873] {
[10:18:26.873]     {
[10:18:26.873]         {
[10:18:26.873]             ...future.startTime <- base::Sys.time()
[10:18:26.873]             {
[10:18:26.873]                 {
[10:18:26.873]                   {
[10:18:26.873]                     {
[10:18:26.873]                       base::local({
[10:18:26.873]                         has_future <- base::requireNamespace("future", 
[10:18:26.873]                           quietly = TRUE)
[10:18:26.873]                         if (has_future) {
[10:18:26.873]                           ns <- base::getNamespace("future")
[10:18:26.873]                           version <- ns[[".package"]][["version"]]
[10:18:26.873]                           if (is.null(version)) 
[10:18:26.873]                             version <- utils::packageVersion("future")
[10:18:26.873]                         }
[10:18:26.873]                         else {
[10:18:26.873]                           version <- NULL
[10:18:26.873]                         }
[10:18:26.873]                         if (!has_future || version < "1.8.0") {
[10:18:26.873]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.873]                             "", base::R.version$version.string), 
[10:18:26.873]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:26.873]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.873]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.873]                               "release", "version")], collapse = " "), 
[10:18:26.873]                             hostname = base::Sys.info()[["nodename"]])
[10:18:26.873]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.873]                             info)
[10:18:26.873]                           info <- base::paste(info, collapse = "; ")
[10:18:26.873]                           if (!has_future) {
[10:18:26.873]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.873]                               info)
[10:18:26.873]                           }
[10:18:26.873]                           else {
[10:18:26.873]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.873]                               info, version)
[10:18:26.873]                           }
[10:18:26.873]                           base::stop(msg)
[10:18:26.873]                         }
[10:18:26.873]                       })
[10:18:26.873]                     }
[10:18:26.873]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:26.873]                     base::options(mc.cores = 1L)
[10:18:26.873]                   }
[10:18:26.873]                   ...future.strategy.old <- future::plan("list")
[10:18:26.873]                   options(future.plan = NULL)
[10:18:26.873]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.873]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.873]                 }
[10:18:26.873]                 ...future.workdir <- getwd()
[10:18:26.873]             }
[10:18:26.873]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.873]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.873]         }
[10:18:26.873]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.873]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.873]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.873]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.873]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.873]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.873]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.873]             base::names(...future.oldOptions))
[10:18:26.873]     }
[10:18:26.873]     if (FALSE) {
[10:18:26.873]     }
[10:18:26.873]     else {
[10:18:26.873]         if (TRUE) {
[10:18:26.873]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.873]                 open = "w")
[10:18:26.873]         }
[10:18:26.873]         else {
[10:18:26.873]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.873]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.873]         }
[10:18:26.873]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.873]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.873]             base::sink(type = "output", split = FALSE)
[10:18:26.873]             base::close(...future.stdout)
[10:18:26.873]         }, add = TRUE)
[10:18:26.873]     }
[10:18:26.873]     ...future.frame <- base::sys.nframe()
[10:18:26.873]     ...future.conditions <- base::list()
[10:18:26.873]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.873]     if (FALSE) {
[10:18:26.873]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.873]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.873]     }
[10:18:26.873]     ...future.result <- base::tryCatch({
[10:18:26.873]         base::withCallingHandlers({
[10:18:26.873]             ...future.value <- base::withVisible(base::local({
[10:18:26.873]                 withCallingHandlers({
[10:18:26.873]                   {
[10:18:26.873]                     do.call(function(...) {
[10:18:26.873]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.873]                       if (!identical(...future.globals.maxSize.org, 
[10:18:26.873]                         ...future.globals.maxSize)) {
[10:18:26.873]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.873]                         on.exit(options(oopts), add = TRUE)
[10:18:26.873]                       }
[10:18:26.873]                       {
[10:18:26.873]                         lapply(seq_along(...future.elements_ii), 
[10:18:26.873]                           FUN = function(jj) {
[10:18:26.873]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.873]                             ...future.FUN(...future.X_jj, ...)
[10:18:26.873]                           })
[10:18:26.873]                       }
[10:18:26.873]                     }, args = future.call.arguments)
[10:18:26.873]                   }
[10:18:26.873]                 }, immediateCondition = function(cond) {
[10:18:26.873]                   save_rds <- function (object, pathname, ...) 
[10:18:26.873]                   {
[10:18:26.873]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:26.873]                     if (file_test("-f", pathname_tmp)) {
[10:18:26.873]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.873]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:26.873]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.873]                         fi_tmp[["mtime"]])
[10:18:26.873]                     }
[10:18:26.873]                     tryCatch({
[10:18:26.873]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:26.873]                     }, error = function(ex) {
[10:18:26.873]                       msg <- conditionMessage(ex)
[10:18:26.873]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.873]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:26.873]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.873]                         fi_tmp[["mtime"]], msg)
[10:18:26.873]                       ex$message <- msg
[10:18:26.873]                       stop(ex)
[10:18:26.873]                     })
[10:18:26.873]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:26.873]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:26.873]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:26.873]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.873]                       fi <- file.info(pathname)
[10:18:26.873]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:26.873]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.873]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:26.873]                         fi[["size"]], fi[["mtime"]])
[10:18:26.873]                       stop(msg)
[10:18:26.873]                     }
[10:18:26.873]                     invisible(pathname)
[10:18:26.873]                   }
[10:18:26.873]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:26.873]                     rootPath = tempdir()) 
[10:18:26.873]                   {
[10:18:26.873]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:26.873]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:26.873]                       tmpdir = path, fileext = ".rds")
[10:18:26.873]                     save_rds(obj, file)
[10:18:26.873]                   }
[10:18:26.873]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:26.873]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.873]                   {
[10:18:26.873]                     inherits <- base::inherits
[10:18:26.873]                     invokeRestart <- base::invokeRestart
[10:18:26.873]                     is.null <- base::is.null
[10:18:26.873]                     muffled <- FALSE
[10:18:26.873]                     if (inherits(cond, "message")) {
[10:18:26.873]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:26.873]                       if (muffled) 
[10:18:26.873]                         invokeRestart("muffleMessage")
[10:18:26.873]                     }
[10:18:26.873]                     else if (inherits(cond, "warning")) {
[10:18:26.873]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:26.873]                       if (muffled) 
[10:18:26.873]                         invokeRestart("muffleWarning")
[10:18:26.873]                     }
[10:18:26.873]                     else if (inherits(cond, "condition")) {
[10:18:26.873]                       if (!is.null(pattern)) {
[10:18:26.873]                         computeRestarts <- base::computeRestarts
[10:18:26.873]                         grepl <- base::grepl
[10:18:26.873]                         restarts <- computeRestarts(cond)
[10:18:26.873]                         for (restart in restarts) {
[10:18:26.873]                           name <- restart$name
[10:18:26.873]                           if (is.null(name)) 
[10:18:26.873]                             next
[10:18:26.873]                           if (!grepl(pattern, name)) 
[10:18:26.873]                             next
[10:18:26.873]                           invokeRestart(restart)
[10:18:26.873]                           muffled <- TRUE
[10:18:26.873]                           break
[10:18:26.873]                         }
[10:18:26.873]                       }
[10:18:26.873]                     }
[10:18:26.873]                     invisible(muffled)
[10:18:26.873]                   }
[10:18:26.873]                   muffleCondition(cond)
[10:18:26.873]                 })
[10:18:26.873]             }))
[10:18:26.873]             future::FutureResult(value = ...future.value$value, 
[10:18:26.873]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.873]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.873]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.873]                     ...future.globalenv.names))
[10:18:26.873]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.873]         }, condition = base::local({
[10:18:26.873]             c <- base::c
[10:18:26.873]             inherits <- base::inherits
[10:18:26.873]             invokeRestart <- base::invokeRestart
[10:18:26.873]             length <- base::length
[10:18:26.873]             list <- base::list
[10:18:26.873]             seq.int <- base::seq.int
[10:18:26.873]             signalCondition <- base::signalCondition
[10:18:26.873]             sys.calls <- base::sys.calls
[10:18:26.873]             `[[` <- base::`[[`
[10:18:26.873]             `+` <- base::`+`
[10:18:26.873]             `<<-` <- base::`<<-`
[10:18:26.873]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.873]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.873]                   3L)]
[10:18:26.873]             }
[10:18:26.873]             function(cond) {
[10:18:26.873]                 is_error <- inherits(cond, "error")
[10:18:26.873]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.873]                   NULL)
[10:18:26.873]                 if (is_error) {
[10:18:26.873]                   sessionInformation <- function() {
[10:18:26.873]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.873]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.873]                       search = base::search(), system = base::Sys.info())
[10:18:26.873]                   }
[10:18:26.873]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.873]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.873]                     cond$call), session = sessionInformation(), 
[10:18:26.873]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.873]                   signalCondition(cond)
[10:18:26.873]                 }
[10:18:26.873]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.873]                 "immediateCondition"))) {
[10:18:26.873]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.873]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.873]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.873]                   if (TRUE && !signal) {
[10:18:26.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.873]                     {
[10:18:26.873]                       inherits <- base::inherits
[10:18:26.873]                       invokeRestart <- base::invokeRestart
[10:18:26.873]                       is.null <- base::is.null
[10:18:26.873]                       muffled <- FALSE
[10:18:26.873]                       if (inherits(cond, "message")) {
[10:18:26.873]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.873]                         if (muffled) 
[10:18:26.873]                           invokeRestart("muffleMessage")
[10:18:26.873]                       }
[10:18:26.873]                       else if (inherits(cond, "warning")) {
[10:18:26.873]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.873]                         if (muffled) 
[10:18:26.873]                           invokeRestart("muffleWarning")
[10:18:26.873]                       }
[10:18:26.873]                       else if (inherits(cond, "condition")) {
[10:18:26.873]                         if (!is.null(pattern)) {
[10:18:26.873]                           computeRestarts <- base::computeRestarts
[10:18:26.873]                           grepl <- base::grepl
[10:18:26.873]                           restarts <- computeRestarts(cond)
[10:18:26.873]                           for (restart in restarts) {
[10:18:26.873]                             name <- restart$name
[10:18:26.873]                             if (is.null(name)) 
[10:18:26.873]                               next
[10:18:26.873]                             if (!grepl(pattern, name)) 
[10:18:26.873]                               next
[10:18:26.873]                             invokeRestart(restart)
[10:18:26.873]                             muffled <- TRUE
[10:18:26.873]                             break
[10:18:26.873]                           }
[10:18:26.873]                         }
[10:18:26.873]                       }
[10:18:26.873]                       invisible(muffled)
[10:18:26.873]                     }
[10:18:26.873]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.873]                   }
[10:18:26.873]                 }
[10:18:26.873]                 else {
[10:18:26.873]                   if (TRUE) {
[10:18:26.873]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.873]                     {
[10:18:26.873]                       inherits <- base::inherits
[10:18:26.873]                       invokeRestart <- base::invokeRestart
[10:18:26.873]                       is.null <- base::is.null
[10:18:26.873]                       muffled <- FALSE
[10:18:26.873]                       if (inherits(cond, "message")) {
[10:18:26.873]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.873]                         if (muffled) 
[10:18:26.873]                           invokeRestart("muffleMessage")
[10:18:26.873]                       }
[10:18:26.873]                       else if (inherits(cond, "warning")) {
[10:18:26.873]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.873]                         if (muffled) 
[10:18:26.873]                           invokeRestart("muffleWarning")
[10:18:26.873]                       }
[10:18:26.873]                       else if (inherits(cond, "condition")) {
[10:18:26.873]                         if (!is.null(pattern)) {
[10:18:26.873]                           computeRestarts <- base::computeRestarts
[10:18:26.873]                           grepl <- base::grepl
[10:18:26.873]                           restarts <- computeRestarts(cond)
[10:18:26.873]                           for (restart in restarts) {
[10:18:26.873]                             name <- restart$name
[10:18:26.873]                             if (is.null(name)) 
[10:18:26.873]                               next
[10:18:26.873]                             if (!grepl(pattern, name)) 
[10:18:26.873]                               next
[10:18:26.873]                             invokeRestart(restart)
[10:18:26.873]                             muffled <- TRUE
[10:18:26.873]                             break
[10:18:26.873]                           }
[10:18:26.873]                         }
[10:18:26.873]                       }
[10:18:26.873]                       invisible(muffled)
[10:18:26.873]                     }
[10:18:26.873]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.873]                   }
[10:18:26.873]                 }
[10:18:26.873]             }
[10:18:26.873]         }))
[10:18:26.873]     }, error = function(ex) {
[10:18:26.873]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.873]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.873]                 ...future.rng), started = ...future.startTime, 
[10:18:26.873]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.873]             version = "1.8"), class = "FutureResult")
[10:18:26.873]     }, finally = {
[10:18:26.873]         if (!identical(...future.workdir, getwd())) 
[10:18:26.873]             setwd(...future.workdir)
[10:18:26.873]         {
[10:18:26.873]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.873]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.873]             }
[10:18:26.873]             base::options(...future.oldOptions)
[10:18:26.873]             if (.Platform$OS.type == "windows") {
[10:18:26.873]                 old_names <- names(...future.oldEnvVars)
[10:18:26.873]                 envs <- base::Sys.getenv()
[10:18:26.873]                 names <- names(envs)
[10:18:26.873]                 common <- intersect(names, old_names)
[10:18:26.873]                 added <- setdiff(names, old_names)
[10:18:26.873]                 removed <- setdiff(old_names, names)
[10:18:26.873]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.873]                   envs[common]]
[10:18:26.873]                 NAMES <- toupper(changed)
[10:18:26.873]                 args <- list()
[10:18:26.873]                 for (kk in seq_along(NAMES)) {
[10:18:26.873]                   name <- changed[[kk]]
[10:18:26.873]                   NAME <- NAMES[[kk]]
[10:18:26.873]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.873]                     next
[10:18:26.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.873]                 }
[10:18:26.873]                 NAMES <- toupper(added)
[10:18:26.873]                 for (kk in seq_along(NAMES)) {
[10:18:26.873]                   name <- added[[kk]]
[10:18:26.873]                   NAME <- NAMES[[kk]]
[10:18:26.873]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.873]                     next
[10:18:26.873]                   args[[name]] <- ""
[10:18:26.873]                 }
[10:18:26.873]                 NAMES <- toupper(removed)
[10:18:26.873]                 for (kk in seq_along(NAMES)) {
[10:18:26.873]                   name <- removed[[kk]]
[10:18:26.873]                   NAME <- NAMES[[kk]]
[10:18:26.873]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.873]                     next
[10:18:26.873]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.873]                 }
[10:18:26.873]                 if (length(args) > 0) 
[10:18:26.873]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.873]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.873]             }
[10:18:26.873]             else {
[10:18:26.873]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.873]             }
[10:18:26.873]             {
[10:18:26.873]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.873]                   0L) {
[10:18:26.873]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.873]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.873]                   base::options(opts)
[10:18:26.873]                 }
[10:18:26.873]                 {
[10:18:26.873]                   {
[10:18:26.873]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:26.873]                     NULL
[10:18:26.873]                   }
[10:18:26.873]                   options(future.plan = NULL)
[10:18:26.873]                   if (is.na(NA_character_)) 
[10:18:26.873]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.873]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.873]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.873]                     .init = FALSE)
[10:18:26.873]                 }
[10:18:26.873]             }
[10:18:26.873]         }
[10:18:26.873]     })
[10:18:26.873]     if (TRUE) {
[10:18:26.873]         base::sink(type = "output", split = FALSE)
[10:18:26.873]         if (TRUE) {
[10:18:26.873]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.873]         }
[10:18:26.873]         else {
[10:18:26.873]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.873]         }
[10:18:26.873]         base::close(...future.stdout)
[10:18:26.873]         ...future.stdout <- NULL
[10:18:26.873]     }
[10:18:26.873]     ...future.result$conditions <- ...future.conditions
[10:18:26.873]     ...future.result$finished <- base::Sys.time()
[10:18:26.873]     ...future.result
[10:18:26.873] }
[10:18:26.875] assign_globals() ...
[10:18:26.875] List of 5
[10:18:26.875]  $ future.call.arguments    : list()
[10:18:26.875]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.875]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.875]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.875]  $ ...future.elements_ii    :List of 1
[10:18:26.875]   ..$ : num [1:4] 1 3 1 7
[10:18:26.875]  $ ...future.seeds_ii       : NULL
[10:18:26.875]  $ ...future.globals.maxSize: num Inf
[10:18:26.875]  - attr(*, "resolved")= logi FALSE
[10:18:26.875]  - attr(*, "total_size")= num NA
[10:18:26.875]  - attr(*, "where")=List of 5
[10:18:26.875]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.875]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.875]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.875]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.875]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.875]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.875]  - attr(*, "already-done")= logi TRUE
[10:18:26.880] - copied ‘future.call.arguments’ to environment
[10:18:26.880] - copied ‘...future.FUN’ to environment
[10:18:26.880] - copied ‘...future.elements_ii’ to environment
[10:18:26.880] - copied ‘...future.seeds_ii’ to environment
[10:18:26.880] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.880] assign_globals() ... done
[10:18:26.880] requestCore(): workers = 2
[10:18:26.883] MulticoreFuture started
[10:18:26.883] - Launch lazy future ... done
[10:18:26.883] run() for ‘MulticoreFuture’ ... done
[10:18:26.884] Created future:
[10:18:26.884] plan(): Setting new future strategy stack:
[10:18:26.884] List of future strategies:
[10:18:26.884] 1. sequential:
[10:18:26.884]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.884]    - tweaked: FALSE
[10:18:26.884]    - call: NULL
[10:18:26.885] plan(): nbrOfWorkers() = 1
[10:18:26.891] plan(): Setting new future strategy stack:
[10:18:26.892] List of future strategies:
[10:18:26.892] 1. multicore:
[10:18:26.892]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:26.892]    - tweaked: FALSE
[10:18:26.892]    - call: plan(strategy)
[10:18:26.884] MulticoreFuture:
[10:18:26.884] Label: ‘future_apply-1’
[10:18:26.884] Expression:
[10:18:26.884] {
[10:18:26.884]     do.call(function(...) {
[10:18:26.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.884]             on.exit(options(oopts), add = TRUE)
[10:18:26.884]         }
[10:18:26.884]         {
[10:18:26.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.884]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.884]             })
[10:18:26.884]         }
[10:18:26.884]     }, args = future.call.arguments)
[10:18:26.884] }
[10:18:26.884] Lazy evaluation: FALSE
[10:18:26.884] Asynchronous evaluation: TRUE
[10:18:26.884] Local evaluation: TRUE
[10:18:26.884] Environment: R_GlobalEnv
[10:18:26.884] Capture standard output: TRUE
[10:18:26.884] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.884] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.884] Packages: <none>
[10:18:26.884] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.884] Resolved: FALSE
[10:18:26.884] Value: <not collected>
[10:18:26.884] Conditions captured: <none>
[10:18:26.884] Early signaling: FALSE
[10:18:26.884] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.884] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:26.897] plan(): nbrOfWorkers() = 2
[10:18:26.897] Chunk #1 of 2 ... DONE
[10:18:26.900] Chunk #2 of 2 ...
[10:18:26.900]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:26.900]  - seeds: <none>
[10:18:26.901]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.901] getGlobalsAndPackages() ...
[10:18:26.901] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.902] Resolving globals: FALSE
[10:18:26.902] Tweak future expression to call with '...' arguments ...
[10:18:26.902] {
[10:18:26.902]     do.call(function(...) {
[10:18:26.902]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.902]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.902]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.902]             on.exit(options(oopts), add = TRUE)
[10:18:26.902]         }
[10:18:26.902]         {
[10:18:26.902]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.902]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.902]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.902]             })
[10:18:26.902]         }
[10:18:26.902]     }, args = future.call.arguments)
[10:18:26.902] }
[10:18:26.903] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.904] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.904] 
[10:18:26.904] getGlobalsAndPackages() ... DONE
[10:18:26.905] run() for ‘Future’ ...
[10:18:26.905] - state: ‘created’
[10:18:26.905] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:26.908] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:26.908] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:26.908]   - Field: ‘label’
[10:18:26.909]   - Field: ‘local’
[10:18:26.909]   - Field: ‘owner’
[10:18:26.909]   - Field: ‘envir’
[10:18:26.909]   - Field: ‘workers’
[10:18:26.909]   - Field: ‘packages’
[10:18:26.909]   - Field: ‘gc’
[10:18:26.910]   - Field: ‘job’
[10:18:26.910]   - Field: ‘conditions’
[10:18:26.910]   - Field: ‘expr’
[10:18:26.910]   - Field: ‘uuid’
[10:18:26.910]   - Field: ‘seed’
[10:18:26.910]   - Field: ‘version’
[10:18:26.910]   - Field: ‘result’
[10:18:26.911]   - Field: ‘asynchronous’
[10:18:26.911]   - Field: ‘calls’
[10:18:26.911]   - Field: ‘globals’
[10:18:26.911]   - Field: ‘stdout’
[10:18:26.911]   - Field: ‘earlySignal’
[10:18:26.911]   - Field: ‘lazy’
[10:18:26.911]   - Field: ‘state’
[10:18:26.912] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:26.912] - Launch lazy future ...
[10:18:26.912] Packages needed by the future expression (n = 0): <none>
[10:18:26.912] Packages needed by future strategies (n = 0): <none>
[10:18:26.913] {
[10:18:26.913]     {
[10:18:26.913]         {
[10:18:26.913]             ...future.startTime <- base::Sys.time()
[10:18:26.913]             {
[10:18:26.913]                 {
[10:18:26.913]                   {
[10:18:26.913]                     {
[10:18:26.913]                       base::local({
[10:18:26.913]                         has_future <- base::requireNamespace("future", 
[10:18:26.913]                           quietly = TRUE)
[10:18:26.913]                         if (has_future) {
[10:18:26.913]                           ns <- base::getNamespace("future")
[10:18:26.913]                           version <- ns[[".package"]][["version"]]
[10:18:26.913]                           if (is.null(version)) 
[10:18:26.913]                             version <- utils::packageVersion("future")
[10:18:26.913]                         }
[10:18:26.913]                         else {
[10:18:26.913]                           version <- NULL
[10:18:26.913]                         }
[10:18:26.913]                         if (!has_future || version < "1.8.0") {
[10:18:26.913]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.913]                             "", base::R.version$version.string), 
[10:18:26.913]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:26.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:26.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.913]                               "release", "version")], collapse = " "), 
[10:18:26.913]                             hostname = base::Sys.info()[["nodename"]])
[10:18:26.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.913]                             info)
[10:18:26.913]                           info <- base::paste(info, collapse = "; ")
[10:18:26.913]                           if (!has_future) {
[10:18:26.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.913]                               info)
[10:18:26.913]                           }
[10:18:26.913]                           else {
[10:18:26.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.913]                               info, version)
[10:18:26.913]                           }
[10:18:26.913]                           base::stop(msg)
[10:18:26.913]                         }
[10:18:26.913]                       })
[10:18:26.913]                     }
[10:18:26.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:26.913]                     base::options(mc.cores = 1L)
[10:18:26.913]                   }
[10:18:26.913]                   ...future.strategy.old <- future::plan("list")
[10:18:26.913]                   options(future.plan = NULL)
[10:18:26.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.913]                 }
[10:18:26.913]                 ...future.workdir <- getwd()
[10:18:26.913]             }
[10:18:26.913]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.913]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.913]         }
[10:18:26.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.913]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.913]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.913]             base::names(...future.oldOptions))
[10:18:26.913]     }
[10:18:26.913]     if (FALSE) {
[10:18:26.913]     }
[10:18:26.913]     else {
[10:18:26.913]         if (TRUE) {
[10:18:26.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.913]                 open = "w")
[10:18:26.913]         }
[10:18:26.913]         else {
[10:18:26.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.913]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.913]         }
[10:18:26.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.913]             base::sink(type = "output", split = FALSE)
[10:18:26.913]             base::close(...future.stdout)
[10:18:26.913]         }, add = TRUE)
[10:18:26.913]     }
[10:18:26.913]     ...future.frame <- base::sys.nframe()
[10:18:26.913]     ...future.conditions <- base::list()
[10:18:26.913]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.913]     if (FALSE) {
[10:18:26.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.913]     }
[10:18:26.913]     ...future.result <- base::tryCatch({
[10:18:26.913]         base::withCallingHandlers({
[10:18:26.913]             ...future.value <- base::withVisible(base::local({
[10:18:26.913]                 withCallingHandlers({
[10:18:26.913]                   {
[10:18:26.913]                     do.call(function(...) {
[10:18:26.913]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.913]                       if (!identical(...future.globals.maxSize.org, 
[10:18:26.913]                         ...future.globals.maxSize)) {
[10:18:26.913]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.913]                         on.exit(options(oopts), add = TRUE)
[10:18:26.913]                       }
[10:18:26.913]                       {
[10:18:26.913]                         lapply(seq_along(...future.elements_ii), 
[10:18:26.913]                           FUN = function(jj) {
[10:18:26.913]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.913]                             ...future.FUN(...future.X_jj, ...)
[10:18:26.913]                           })
[10:18:26.913]                       }
[10:18:26.913]                     }, args = future.call.arguments)
[10:18:26.913]                   }
[10:18:26.913]                 }, immediateCondition = function(cond) {
[10:18:26.913]                   save_rds <- function (object, pathname, ...) 
[10:18:26.913]                   {
[10:18:26.913]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:26.913]                     if (file_test("-f", pathname_tmp)) {
[10:18:26.913]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.913]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:26.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.913]                         fi_tmp[["mtime"]])
[10:18:26.913]                     }
[10:18:26.913]                     tryCatch({
[10:18:26.913]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:26.913]                     }, error = function(ex) {
[10:18:26.913]                       msg <- conditionMessage(ex)
[10:18:26.913]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.913]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:26.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.913]                         fi_tmp[["mtime"]], msg)
[10:18:26.913]                       ex$message <- msg
[10:18:26.913]                       stop(ex)
[10:18:26.913]                     })
[10:18:26.913]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:26.913]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:26.913]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:26.913]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.913]                       fi <- file.info(pathname)
[10:18:26.913]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:26.913]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.913]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:26.913]                         fi[["size"]], fi[["mtime"]])
[10:18:26.913]                       stop(msg)
[10:18:26.913]                     }
[10:18:26.913]                     invisible(pathname)
[10:18:26.913]                   }
[10:18:26.913]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:26.913]                     rootPath = tempdir()) 
[10:18:26.913]                   {
[10:18:26.913]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:26.913]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:26.913]                       tmpdir = path, fileext = ".rds")
[10:18:26.913]                     save_rds(obj, file)
[10:18:26.913]                   }
[10:18:26.913]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:26.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.913]                   {
[10:18:26.913]                     inherits <- base::inherits
[10:18:26.913]                     invokeRestart <- base::invokeRestart
[10:18:26.913]                     is.null <- base::is.null
[10:18:26.913]                     muffled <- FALSE
[10:18:26.913]                     if (inherits(cond, "message")) {
[10:18:26.913]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:26.913]                       if (muffled) 
[10:18:26.913]                         invokeRestart("muffleMessage")
[10:18:26.913]                     }
[10:18:26.913]                     else if (inherits(cond, "warning")) {
[10:18:26.913]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:26.913]                       if (muffled) 
[10:18:26.913]                         invokeRestart("muffleWarning")
[10:18:26.913]                     }
[10:18:26.913]                     else if (inherits(cond, "condition")) {
[10:18:26.913]                       if (!is.null(pattern)) {
[10:18:26.913]                         computeRestarts <- base::computeRestarts
[10:18:26.913]                         grepl <- base::grepl
[10:18:26.913]                         restarts <- computeRestarts(cond)
[10:18:26.913]                         for (restart in restarts) {
[10:18:26.913]                           name <- restart$name
[10:18:26.913]                           if (is.null(name)) 
[10:18:26.913]                             next
[10:18:26.913]                           if (!grepl(pattern, name)) 
[10:18:26.913]                             next
[10:18:26.913]                           invokeRestart(restart)
[10:18:26.913]                           muffled <- TRUE
[10:18:26.913]                           break
[10:18:26.913]                         }
[10:18:26.913]                       }
[10:18:26.913]                     }
[10:18:26.913]                     invisible(muffled)
[10:18:26.913]                   }
[10:18:26.913]                   muffleCondition(cond)
[10:18:26.913]                 })
[10:18:26.913]             }))
[10:18:26.913]             future::FutureResult(value = ...future.value$value, 
[10:18:26.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.913]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.913]                     ...future.globalenv.names))
[10:18:26.913]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.913]         }, condition = base::local({
[10:18:26.913]             c <- base::c
[10:18:26.913]             inherits <- base::inherits
[10:18:26.913]             invokeRestart <- base::invokeRestart
[10:18:26.913]             length <- base::length
[10:18:26.913]             list <- base::list
[10:18:26.913]             seq.int <- base::seq.int
[10:18:26.913]             signalCondition <- base::signalCondition
[10:18:26.913]             sys.calls <- base::sys.calls
[10:18:26.913]             `[[` <- base::`[[`
[10:18:26.913]             `+` <- base::`+`
[10:18:26.913]             `<<-` <- base::`<<-`
[10:18:26.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.913]                   3L)]
[10:18:26.913]             }
[10:18:26.913]             function(cond) {
[10:18:26.913]                 is_error <- inherits(cond, "error")
[10:18:26.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.913]                   NULL)
[10:18:26.913]                 if (is_error) {
[10:18:26.913]                   sessionInformation <- function() {
[10:18:26.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.913]                       search = base::search(), system = base::Sys.info())
[10:18:26.913]                   }
[10:18:26.913]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.913]                     cond$call), session = sessionInformation(), 
[10:18:26.913]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.913]                   signalCondition(cond)
[10:18:26.913]                 }
[10:18:26.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.913]                 "immediateCondition"))) {
[10:18:26.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.913]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.913]                   if (TRUE && !signal) {
[10:18:26.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.913]                     {
[10:18:26.913]                       inherits <- base::inherits
[10:18:26.913]                       invokeRestart <- base::invokeRestart
[10:18:26.913]                       is.null <- base::is.null
[10:18:26.913]                       muffled <- FALSE
[10:18:26.913]                       if (inherits(cond, "message")) {
[10:18:26.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.913]                         if (muffled) 
[10:18:26.913]                           invokeRestart("muffleMessage")
[10:18:26.913]                       }
[10:18:26.913]                       else if (inherits(cond, "warning")) {
[10:18:26.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.913]                         if (muffled) 
[10:18:26.913]                           invokeRestart("muffleWarning")
[10:18:26.913]                       }
[10:18:26.913]                       else if (inherits(cond, "condition")) {
[10:18:26.913]                         if (!is.null(pattern)) {
[10:18:26.913]                           computeRestarts <- base::computeRestarts
[10:18:26.913]                           grepl <- base::grepl
[10:18:26.913]                           restarts <- computeRestarts(cond)
[10:18:26.913]                           for (restart in restarts) {
[10:18:26.913]                             name <- restart$name
[10:18:26.913]                             if (is.null(name)) 
[10:18:26.913]                               next
[10:18:26.913]                             if (!grepl(pattern, name)) 
[10:18:26.913]                               next
[10:18:26.913]                             invokeRestart(restart)
[10:18:26.913]                             muffled <- TRUE
[10:18:26.913]                             break
[10:18:26.913]                           }
[10:18:26.913]                         }
[10:18:26.913]                       }
[10:18:26.913]                       invisible(muffled)
[10:18:26.913]                     }
[10:18:26.913]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.913]                   }
[10:18:26.913]                 }
[10:18:26.913]                 else {
[10:18:26.913]                   if (TRUE) {
[10:18:26.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.913]                     {
[10:18:26.913]                       inherits <- base::inherits
[10:18:26.913]                       invokeRestart <- base::invokeRestart
[10:18:26.913]                       is.null <- base::is.null
[10:18:26.913]                       muffled <- FALSE
[10:18:26.913]                       if (inherits(cond, "message")) {
[10:18:26.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.913]                         if (muffled) 
[10:18:26.913]                           invokeRestart("muffleMessage")
[10:18:26.913]                       }
[10:18:26.913]                       else if (inherits(cond, "warning")) {
[10:18:26.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.913]                         if (muffled) 
[10:18:26.913]                           invokeRestart("muffleWarning")
[10:18:26.913]                       }
[10:18:26.913]                       else if (inherits(cond, "condition")) {
[10:18:26.913]                         if (!is.null(pattern)) {
[10:18:26.913]                           computeRestarts <- base::computeRestarts
[10:18:26.913]                           grepl <- base::grepl
[10:18:26.913]                           restarts <- computeRestarts(cond)
[10:18:26.913]                           for (restart in restarts) {
[10:18:26.913]                             name <- restart$name
[10:18:26.913]                             if (is.null(name)) 
[10:18:26.913]                               next
[10:18:26.913]                             if (!grepl(pattern, name)) 
[10:18:26.913]                               next
[10:18:26.913]                             invokeRestart(restart)
[10:18:26.913]                             muffled <- TRUE
[10:18:26.913]                             break
[10:18:26.913]                           }
[10:18:26.913]                         }
[10:18:26.913]                       }
[10:18:26.913]                       invisible(muffled)
[10:18:26.913]                     }
[10:18:26.913]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.913]                   }
[10:18:26.913]                 }
[10:18:26.913]             }
[10:18:26.913]         }))
[10:18:26.913]     }, error = function(ex) {
[10:18:26.913]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.913]                 ...future.rng), started = ...future.startTime, 
[10:18:26.913]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.913]             version = "1.8"), class = "FutureResult")
[10:18:26.913]     }, finally = {
[10:18:26.913]         if (!identical(...future.workdir, getwd())) 
[10:18:26.913]             setwd(...future.workdir)
[10:18:26.913]         {
[10:18:26.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.913]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.913]             }
[10:18:26.913]             base::options(...future.oldOptions)
[10:18:26.913]             if (.Platform$OS.type == "windows") {
[10:18:26.913]                 old_names <- names(...future.oldEnvVars)
[10:18:26.913]                 envs <- base::Sys.getenv()
[10:18:26.913]                 names <- names(envs)
[10:18:26.913]                 common <- intersect(names, old_names)
[10:18:26.913]                 added <- setdiff(names, old_names)
[10:18:26.913]                 removed <- setdiff(old_names, names)
[10:18:26.913]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.913]                   envs[common]]
[10:18:26.913]                 NAMES <- toupper(changed)
[10:18:26.913]                 args <- list()
[10:18:26.913]                 for (kk in seq_along(NAMES)) {
[10:18:26.913]                   name <- changed[[kk]]
[10:18:26.913]                   NAME <- NAMES[[kk]]
[10:18:26.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.913]                     next
[10:18:26.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.913]                 }
[10:18:26.913]                 NAMES <- toupper(added)
[10:18:26.913]                 for (kk in seq_along(NAMES)) {
[10:18:26.913]                   name <- added[[kk]]
[10:18:26.913]                   NAME <- NAMES[[kk]]
[10:18:26.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.913]                     next
[10:18:26.913]                   args[[name]] <- ""
[10:18:26.913]                 }
[10:18:26.913]                 NAMES <- toupper(removed)
[10:18:26.913]                 for (kk in seq_along(NAMES)) {
[10:18:26.913]                   name <- removed[[kk]]
[10:18:26.913]                   NAME <- NAMES[[kk]]
[10:18:26.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.913]                     next
[10:18:26.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.913]                 }
[10:18:26.913]                 if (length(args) > 0) 
[10:18:26.913]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.913]             }
[10:18:26.913]             else {
[10:18:26.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.913]             }
[10:18:26.913]             {
[10:18:26.913]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.913]                   0L) {
[10:18:26.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.913]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.913]                   base::options(opts)
[10:18:26.913]                 }
[10:18:26.913]                 {
[10:18:26.913]                   {
[10:18:26.913]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:26.913]                     NULL
[10:18:26.913]                   }
[10:18:26.913]                   options(future.plan = NULL)
[10:18:26.913]                   if (is.na(NA_character_)) 
[10:18:26.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.913]                     .init = FALSE)
[10:18:26.913]                 }
[10:18:26.913]             }
[10:18:26.913]         }
[10:18:26.913]     })
[10:18:26.913]     if (TRUE) {
[10:18:26.913]         base::sink(type = "output", split = FALSE)
[10:18:26.913]         if (TRUE) {
[10:18:26.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.913]         }
[10:18:26.913]         else {
[10:18:26.913]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.913]         }
[10:18:26.913]         base::close(...future.stdout)
[10:18:26.913]         ...future.stdout <- NULL
[10:18:26.913]     }
[10:18:26.913]     ...future.result$conditions <- ...future.conditions
[10:18:26.913]     ...future.result$finished <- base::Sys.time()
[10:18:26.913]     ...future.result
[10:18:26.913] }
[10:18:26.916] assign_globals() ...
[10:18:26.916] List of 5
[10:18:26.916]  $ future.call.arguments    : list()
[10:18:26.916]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.916]  $ ...future.FUN            :function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:26.916]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:26.916]  $ ...future.elements_ii    :List of 1
[10:18:26.916]   ..$ : num [1:4] 2 4 6 8
[10:18:26.916]  $ ...future.seeds_ii       : NULL
[10:18:26.916]  $ ...future.globals.maxSize: num Inf
[10:18:26.916]  - attr(*, "resolved")= logi FALSE
[10:18:26.916]  - attr(*, "total_size")= num NA
[10:18:26.916]  - attr(*, "where")=List of 5
[10:18:26.916]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.916]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.916]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.916]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.916]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.916]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.916]  - attr(*, "already-done")= logi TRUE
[10:18:26.922] - copied ‘future.call.arguments’ to environment
[10:18:26.922] - copied ‘...future.FUN’ to environment
[10:18:26.923] - copied ‘...future.elements_ii’ to environment
[10:18:26.923] - copied ‘...future.seeds_ii’ to environment
[10:18:26.923] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.923] assign_globals() ... done
[10:18:26.923] requestCore(): workers = 2
[10:18:26.926] MulticoreFuture started
[10:18:26.926] - Launch lazy future ... done
[10:18:26.926] run() for ‘MulticoreFuture’ ... done
[10:18:26.927] plan(): Setting new future strategy stack:
[10:18:26.927] Created future:
[10:18:26.927] List of future strategies:
[10:18:26.927] 1. sequential:
[10:18:26.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.927]    - tweaked: FALSE
[10:18:26.927]    - call: NULL
[10:18:26.928] plan(): nbrOfWorkers() = 1
[10:18:26.930] plan(): Setting new future strategy stack:
[10:18:26.930] List of future strategies:
[10:18:26.930] 1. multicore:
[10:18:26.930]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:26.930]    - tweaked: FALSE
[10:18:26.930]    - call: plan(strategy)
[10:18:26.934] plan(): nbrOfWorkers() = 2
[10:18:26.927] MulticoreFuture:
[10:18:26.927] Label: ‘future_apply-2’
[10:18:26.927] Expression:
[10:18:26.927] {
[10:18:26.927]     do.call(function(...) {
[10:18:26.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.927]             on.exit(options(oopts), add = TRUE)
[10:18:26.927]         }
[10:18:26.927]         {
[10:18:26.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.927]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.927]             })
[10:18:26.927]         }
[10:18:26.927]     }, args = future.call.arguments)
[10:18:26.927] }
[10:18:26.927] Lazy evaluation: FALSE
[10:18:26.927] Asynchronous evaluation: TRUE
[10:18:26.927] Local evaluation: TRUE
[10:18:26.927] Environment: R_GlobalEnv
[10:18:26.927] Capture standard output: TRUE
[10:18:26.927] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.927] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.927] Packages: <none>
[10:18:26.927] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.927] Resolved: TRUE
[10:18:26.927] Value: <not collected>
[10:18:26.927] Conditions captured: <none>
[10:18:26.927] Early signaling: FALSE
[10:18:26.927] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.927] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:26.935] Chunk #2 of 2 ... DONE
[10:18:26.935] Launching 2 futures (chunks) ... DONE
[10:18:26.935] Resolving 2 futures (chunks) ...
[10:18:26.935] resolve() on list ...
[10:18:26.935]  recursive: 0
[10:18:26.935]  length: 2
[10:18:26.936] 
[10:18:26.936] Future #1
[10:18:26.936] result() for MulticoreFuture ...
[10:18:26.937] result() for MulticoreFuture ...
[10:18:26.937] result() for MulticoreFuture ... done
[10:18:26.937] result() for MulticoreFuture ... done
[10:18:26.937] result() for MulticoreFuture ...
[10:18:26.938] result() for MulticoreFuture ... done
[10:18:26.938] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:26.938] - nx: 2
[10:18:26.938] - relay: TRUE
[10:18:26.938] - stdout: TRUE
[10:18:26.938] - signal: TRUE
[10:18:26.938] - resignal: FALSE
[10:18:26.938] - force: TRUE
[10:18:26.939] - relayed: [n=2] FALSE, FALSE
[10:18:26.939] - queued futures: [n=2] FALSE, FALSE
[10:18:26.939]  - until=1
[10:18:26.939]  - relaying element #1
[10:18:26.939] result() for MulticoreFuture ...
[10:18:26.939] result() for MulticoreFuture ... done
[10:18:26.939] result() for MulticoreFuture ...
[10:18:26.940] result() for MulticoreFuture ... done
[10:18:26.940] result() for MulticoreFuture ...
[10:18:26.940] result() for MulticoreFuture ... done
[10:18:26.940] result() for MulticoreFuture ...
[10:18:26.940] result() for MulticoreFuture ... done
[10:18:26.940] - relayed: [n=2] TRUE, FALSE
[10:18:26.940] - queued futures: [n=2] TRUE, FALSE
[10:18:26.941] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:26.941]  length: 1 (resolved future 1)
[10:18:26.941] Future #2
[10:18:26.941] result() for MulticoreFuture ...
[10:18:26.942] result() for MulticoreFuture ...
[10:18:26.942] result() for MulticoreFuture ... done
[10:18:26.942] result() for MulticoreFuture ... done
[10:18:26.942] result() for MulticoreFuture ...
[10:18:26.942] result() for MulticoreFuture ... done
[10:18:26.943] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:26.943] - nx: 2
[10:18:26.943] - relay: TRUE
[10:18:26.943] - stdout: TRUE
[10:18:26.943] - signal: TRUE
[10:18:26.943] - resignal: FALSE
[10:18:26.943] - force: TRUE
[10:18:26.943] - relayed: [n=2] TRUE, FALSE
[10:18:26.943] - queued futures: [n=2] TRUE, FALSE
[10:18:26.944]  - until=2
[10:18:26.944]  - relaying element #2
[10:18:26.944] result() for MulticoreFuture ...
[10:18:26.946] result() for MulticoreFuture ... done
[10:18:26.947] result() for MulticoreFuture ...
[10:18:26.947] result() for MulticoreFuture ... done
[10:18:26.947] result() for MulticoreFuture ...
[10:18:26.947] result() for MulticoreFuture ... done
[10:18:26.947] result() for MulticoreFuture ...
[10:18:26.948] result() for MulticoreFuture ... done
[10:18:26.948] - relayed: [n=2] TRUE, TRUE
[10:18:26.948] - queued futures: [n=2] TRUE, TRUE
[10:18:26.948] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:26.948]  length: 0 (resolved future 2)
[10:18:26.949] Relaying remaining futures
[10:18:26.949] signalConditionsASAP(NULL, pos=0) ...
[10:18:26.949] - nx: 2
[10:18:26.949] - relay: TRUE
[10:18:26.949] - stdout: TRUE
[10:18:26.949] - signal: TRUE
[10:18:26.949] - resignal: FALSE
[10:18:26.950] - force: TRUE
[10:18:26.950] - relayed: [n=2] TRUE, TRUE
[10:18:26.950] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:26.950] - relayed: [n=2] TRUE, TRUE
[10:18:26.950] - queued futures: [n=2] TRUE, TRUE
[10:18:26.950] signalConditionsASAP(NULL, pos=0) ... done
[10:18:26.950] resolve() on list ... DONE
[10:18:26.950] result() for MulticoreFuture ...
[10:18:26.950] result() for MulticoreFuture ... done
[10:18:26.951] result() for MulticoreFuture ...
[10:18:26.951] result() for MulticoreFuture ... done
[10:18:26.951] result() for MulticoreFuture ...
[10:18:26.951] result() for MulticoreFuture ... done
[10:18:26.951] result() for MulticoreFuture ...
[10:18:26.951] result() for MulticoreFuture ... done
[10:18:26.951]  - Number of value chunks collected: 2
[10:18:26.951] Resolving 2 futures (chunks) ... DONE
[10:18:26.952] Reducing values from 2 chunks ...
[10:18:26.952]  - Number of values collected after concatenation: 2
[10:18:26.952]  - Number of values expected: 2
[10:18:26.952] Reducing values from 2 chunks ... DONE
[10:18:26.952] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:18:26.953] getGlobalsAndPackagesXApply() ...
[10:18:26.953]  - future.globals: TRUE
[10:18:26.953] getGlobalsAndPackages() ...
[10:18:26.953] Searching for globals...
[10:18:26.955] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:26.955] Searching for globals ... DONE
[10:18:26.955] Resolving globals: FALSE
[10:18:26.956] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:26.956] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:26.956] - globals: [1] ‘FUN’
[10:18:26.956] - packages: [1] ‘stats’
[10:18:26.956] getGlobalsAndPackages() ... DONE
[10:18:26.956]  - globals found/used: [n=1] ‘FUN’
[10:18:26.957]  - needed namespaces: [n=1] ‘stats’
[10:18:26.957] Finding globals ... DONE
[10:18:26.957]  - use_args: TRUE
[10:18:26.957]  - Getting '...' globals ...
[10:18:26.957] resolve() on list ...
[10:18:26.957]  recursive: 0
[10:18:26.958]  length: 1
[10:18:26.958]  elements: ‘...’
[10:18:26.958]  length: 0 (resolved future 1)
[10:18:26.958] resolve() on list ... DONE
[10:18:26.958]    - '...' content: [n=0] 
[10:18:26.958] List of 1
[10:18:26.958]  $ ...: list()
[10:18:26.958]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.958]  - attr(*, "where")=List of 1
[10:18:26.958]   ..$ ...:<environment: 0x556e016506c0> 
[10:18:26.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.958]  - attr(*, "resolved")= logi TRUE
[10:18:26.958]  - attr(*, "total_size")= num NA
[10:18:26.961]  - Getting '...' globals ... DONE
[10:18:26.961] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:26.961] List of 2
[10:18:26.961]  $ ...future.FUN:function (x, ...)  
[10:18:26.961]  $ ...          : list()
[10:18:26.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.961]  - attr(*, "where")=List of 2
[10:18:26.961]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:26.961]   ..$ ...          :<environment: 0x556e016506c0> 
[10:18:26.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.961]  - attr(*, "resolved")= logi FALSE
[10:18:26.961]  - attr(*, "total_size")= num 2586
[10:18:26.964] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:26.964] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.966] future_lapply() ...
[10:18:26.968] Number of chunks: 2
[10:18:26.968] getGlobalsAndPackagesXApply() ...
[10:18:26.968]  - future.globals: <name-value list> with names ‘list()’
[10:18:26.968]  - use_args: TRUE
[10:18:26.968] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:26.968] List of 2
[10:18:26.968]  $ ...          : list()
[10:18:26.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.968]  $ ...future.FUN:function (x, ...)  
[10:18:26.968]  - attr(*, "where")=List of 2
[10:18:26.968]   ..$ ...          :<environment: 0x556e016506c0> 
[10:18:26.968]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:18:26.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.968]  - attr(*, "resolved")= logi FALSE
[10:18:26.968]  - attr(*, "total_size")= num NA
[10:18:26.973] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:26.973] getGlobalsAndPackagesXApply() ... DONE
[10:18:26.973] Number of futures (= number of chunks): 2
[10:18:26.973] Launching 2 futures (chunks) ...
[10:18:26.973] Chunk #1 of 2 ...
[10:18:26.974]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:26.974]  - seeds: <none>
[10:18:26.974]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.974] getGlobalsAndPackages() ...
[10:18:26.974] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.974] Resolving globals: FALSE
[10:18:26.974] Tweak future expression to call with '...' arguments ...
[10:18:26.975] {
[10:18:26.975]     do.call(function(...) {
[10:18:26.975]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.975]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.975]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.975]             on.exit(options(oopts), add = TRUE)
[10:18:26.975]         }
[10:18:26.975]         {
[10:18:26.975]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.975]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.975]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.975]             })
[10:18:26.975]         }
[10:18:26.975]     }, args = future.call.arguments)
[10:18:26.975] }
[10:18:26.975] Tweak future expression to call with '...' arguments ... DONE
[10:18:26.975] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:26.975] - packages: [1] ‘stats’
[10:18:26.975] getGlobalsAndPackages() ... DONE
[10:18:26.976] run() for ‘Future’ ...
[10:18:26.976] - state: ‘created’
[10:18:26.976] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:26.978] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:26.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:26.978]   - Field: ‘label’
[10:18:26.978]   - Field: ‘local’
[10:18:26.978]   - Field: ‘owner’
[10:18:26.978]   - Field: ‘envir’
[10:18:26.978]   - Field: ‘workers’
[10:18:26.978]   - Field: ‘packages’
[10:18:26.978]   - Field: ‘gc’
[10:18:26.979]   - Field: ‘job’
[10:18:26.979]   - Field: ‘conditions’
[10:18:26.979]   - Field: ‘expr’
[10:18:26.979]   - Field: ‘uuid’
[10:18:26.979]   - Field: ‘seed’
[10:18:26.979]   - Field: ‘version’
[10:18:26.979]   - Field: ‘result’
[10:18:26.979]   - Field: ‘asynchronous’
[10:18:26.979]   - Field: ‘calls’
[10:18:26.979]   - Field: ‘globals’
[10:18:26.979]   - Field: ‘stdout’
[10:18:26.980]   - Field: ‘earlySignal’
[10:18:26.980]   - Field: ‘lazy’
[10:18:26.980]   - Field: ‘state’
[10:18:26.980] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:26.980] - Launch lazy future ...
[10:18:26.980] Packages needed by the future expression (n = 1): ‘stats’
[10:18:26.980] Packages needed by future strategies (n = 0): <none>
[10:18:26.981] {
[10:18:26.981]     {
[10:18:26.981]         {
[10:18:26.981]             ...future.startTime <- base::Sys.time()
[10:18:26.981]             {
[10:18:26.981]                 {
[10:18:26.981]                   {
[10:18:26.981]                     {
[10:18:26.981]                       {
[10:18:26.981]                         base::local({
[10:18:26.981]                           has_future <- base::requireNamespace("future", 
[10:18:26.981]                             quietly = TRUE)
[10:18:26.981]                           if (has_future) {
[10:18:26.981]                             ns <- base::getNamespace("future")
[10:18:26.981]                             version <- ns[[".package"]][["version"]]
[10:18:26.981]                             if (is.null(version)) 
[10:18:26.981]                               version <- utils::packageVersion("future")
[10:18:26.981]                           }
[10:18:26.981]                           else {
[10:18:26.981]                             version <- NULL
[10:18:26.981]                           }
[10:18:26.981]                           if (!has_future || version < "1.8.0") {
[10:18:26.981]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:26.981]                               "", base::R.version$version.string), 
[10:18:26.981]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:26.981]                                 base::R.version$platform, 8 * 
[10:18:26.981]                                   base::.Machine$sizeof.pointer), 
[10:18:26.981]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:26.981]                                 "release", "version")], collapse = " "), 
[10:18:26.981]                               hostname = base::Sys.info()[["nodename"]])
[10:18:26.981]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:26.981]                               info)
[10:18:26.981]                             info <- base::paste(info, collapse = "; ")
[10:18:26.981]                             if (!has_future) {
[10:18:26.981]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:26.981]                                 info)
[10:18:26.981]                             }
[10:18:26.981]                             else {
[10:18:26.981]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:26.981]                                 info, version)
[10:18:26.981]                             }
[10:18:26.981]                             base::stop(msg)
[10:18:26.981]                           }
[10:18:26.981]                         })
[10:18:26.981]                       }
[10:18:26.981]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:26.981]                       base::options(mc.cores = 1L)
[10:18:26.981]                     }
[10:18:26.981]                     base::local({
[10:18:26.981]                       for (pkg in "stats") {
[10:18:26.981]                         base::loadNamespace(pkg)
[10:18:26.981]                         base::library(pkg, character.only = TRUE)
[10:18:26.981]                       }
[10:18:26.981]                     })
[10:18:26.981]                   }
[10:18:26.981]                   ...future.strategy.old <- future::plan("list")
[10:18:26.981]                   options(future.plan = NULL)
[10:18:26.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:26.981]                 }
[10:18:26.981]                 ...future.workdir <- getwd()
[10:18:26.981]             }
[10:18:26.981]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:26.981]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:26.981]         }
[10:18:26.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:26.981]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:26.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:26.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:26.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:26.981]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:26.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:26.981]             base::names(...future.oldOptions))
[10:18:26.981]     }
[10:18:26.981]     if (FALSE) {
[10:18:26.981]     }
[10:18:26.981]     else {
[10:18:26.981]         if (TRUE) {
[10:18:26.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:26.981]                 open = "w")
[10:18:26.981]         }
[10:18:26.981]         else {
[10:18:26.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:26.981]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:26.981]         }
[10:18:26.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:26.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:26.981]             base::sink(type = "output", split = FALSE)
[10:18:26.981]             base::close(...future.stdout)
[10:18:26.981]         }, add = TRUE)
[10:18:26.981]     }
[10:18:26.981]     ...future.frame <- base::sys.nframe()
[10:18:26.981]     ...future.conditions <- base::list()
[10:18:26.981]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:26.981]     if (FALSE) {
[10:18:26.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:26.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:26.981]     }
[10:18:26.981]     ...future.result <- base::tryCatch({
[10:18:26.981]         base::withCallingHandlers({
[10:18:26.981]             ...future.value <- base::withVisible(base::local({
[10:18:26.981]                 withCallingHandlers({
[10:18:26.981]                   {
[10:18:26.981]                     do.call(function(...) {
[10:18:26.981]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.981]                       if (!identical(...future.globals.maxSize.org, 
[10:18:26.981]                         ...future.globals.maxSize)) {
[10:18:26.981]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.981]                         on.exit(options(oopts), add = TRUE)
[10:18:26.981]                       }
[10:18:26.981]                       {
[10:18:26.981]                         lapply(seq_along(...future.elements_ii), 
[10:18:26.981]                           FUN = function(jj) {
[10:18:26.981]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.981]                             ...future.FUN(...future.X_jj, ...)
[10:18:26.981]                           })
[10:18:26.981]                       }
[10:18:26.981]                     }, args = future.call.arguments)
[10:18:26.981]                   }
[10:18:26.981]                 }, immediateCondition = function(cond) {
[10:18:26.981]                   save_rds <- function (object, pathname, ...) 
[10:18:26.981]                   {
[10:18:26.981]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:26.981]                     if (file_test("-f", pathname_tmp)) {
[10:18:26.981]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.981]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:26.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.981]                         fi_tmp[["mtime"]])
[10:18:26.981]                     }
[10:18:26.981]                     tryCatch({
[10:18:26.981]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:26.981]                     }, error = function(ex) {
[10:18:26.981]                       msg <- conditionMessage(ex)
[10:18:26.981]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.981]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:26.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.981]                         fi_tmp[["mtime"]], msg)
[10:18:26.981]                       ex$message <- msg
[10:18:26.981]                       stop(ex)
[10:18:26.981]                     })
[10:18:26.981]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:26.981]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:26.981]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:26.981]                       fi_tmp <- file.info(pathname_tmp)
[10:18:26.981]                       fi <- file.info(pathname)
[10:18:26.981]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:26.981]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:26.981]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:26.981]                         fi[["size"]], fi[["mtime"]])
[10:18:26.981]                       stop(msg)
[10:18:26.981]                     }
[10:18:26.981]                     invisible(pathname)
[10:18:26.981]                   }
[10:18:26.981]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:26.981]                     rootPath = tempdir()) 
[10:18:26.981]                   {
[10:18:26.981]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:26.981]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:26.981]                       tmpdir = path, fileext = ".rds")
[10:18:26.981]                     save_rds(obj, file)
[10:18:26.981]                   }
[10:18:26.981]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:26.981]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.981]                   {
[10:18:26.981]                     inherits <- base::inherits
[10:18:26.981]                     invokeRestart <- base::invokeRestart
[10:18:26.981]                     is.null <- base::is.null
[10:18:26.981]                     muffled <- FALSE
[10:18:26.981]                     if (inherits(cond, "message")) {
[10:18:26.981]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:26.981]                       if (muffled) 
[10:18:26.981]                         invokeRestart("muffleMessage")
[10:18:26.981]                     }
[10:18:26.981]                     else if (inherits(cond, "warning")) {
[10:18:26.981]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:26.981]                       if (muffled) 
[10:18:26.981]                         invokeRestart("muffleWarning")
[10:18:26.981]                     }
[10:18:26.981]                     else if (inherits(cond, "condition")) {
[10:18:26.981]                       if (!is.null(pattern)) {
[10:18:26.981]                         computeRestarts <- base::computeRestarts
[10:18:26.981]                         grepl <- base::grepl
[10:18:26.981]                         restarts <- computeRestarts(cond)
[10:18:26.981]                         for (restart in restarts) {
[10:18:26.981]                           name <- restart$name
[10:18:26.981]                           if (is.null(name)) 
[10:18:26.981]                             next
[10:18:26.981]                           if (!grepl(pattern, name)) 
[10:18:26.981]                             next
[10:18:26.981]                           invokeRestart(restart)
[10:18:26.981]                           muffled <- TRUE
[10:18:26.981]                           break
[10:18:26.981]                         }
[10:18:26.981]                       }
[10:18:26.981]                     }
[10:18:26.981]                     invisible(muffled)
[10:18:26.981]                   }
[10:18:26.981]                   muffleCondition(cond)
[10:18:26.981]                 })
[10:18:26.981]             }))
[10:18:26.981]             future::FutureResult(value = ...future.value$value, 
[10:18:26.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.981]                   ...future.rng), globalenv = if (FALSE) 
[10:18:26.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:26.981]                     ...future.globalenv.names))
[10:18:26.981]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:26.981]         }, condition = base::local({
[10:18:26.981]             c <- base::c
[10:18:26.981]             inherits <- base::inherits
[10:18:26.981]             invokeRestart <- base::invokeRestart
[10:18:26.981]             length <- base::length
[10:18:26.981]             list <- base::list
[10:18:26.981]             seq.int <- base::seq.int
[10:18:26.981]             signalCondition <- base::signalCondition
[10:18:26.981]             sys.calls <- base::sys.calls
[10:18:26.981]             `[[` <- base::`[[`
[10:18:26.981]             `+` <- base::`+`
[10:18:26.981]             `<<-` <- base::`<<-`
[10:18:26.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:26.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:26.981]                   3L)]
[10:18:26.981]             }
[10:18:26.981]             function(cond) {
[10:18:26.981]                 is_error <- inherits(cond, "error")
[10:18:26.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:26.981]                   NULL)
[10:18:26.981]                 if (is_error) {
[10:18:26.981]                   sessionInformation <- function() {
[10:18:26.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:26.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:26.981]                       search = base::search(), system = base::Sys.info())
[10:18:26.981]                   }
[10:18:26.981]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:26.981]                     cond$call), session = sessionInformation(), 
[10:18:26.981]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:26.981]                   signalCondition(cond)
[10:18:26.981]                 }
[10:18:26.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:26.981]                 "immediateCondition"))) {
[10:18:26.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:26.981]                   ...future.conditions[[length(...future.conditions) + 
[10:18:26.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:26.981]                   if (TRUE && !signal) {
[10:18:26.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.981]                     {
[10:18:26.981]                       inherits <- base::inherits
[10:18:26.981]                       invokeRestart <- base::invokeRestart
[10:18:26.981]                       is.null <- base::is.null
[10:18:26.981]                       muffled <- FALSE
[10:18:26.981]                       if (inherits(cond, "message")) {
[10:18:26.981]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.981]                         if (muffled) 
[10:18:26.981]                           invokeRestart("muffleMessage")
[10:18:26.981]                       }
[10:18:26.981]                       else if (inherits(cond, "warning")) {
[10:18:26.981]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.981]                         if (muffled) 
[10:18:26.981]                           invokeRestart("muffleWarning")
[10:18:26.981]                       }
[10:18:26.981]                       else if (inherits(cond, "condition")) {
[10:18:26.981]                         if (!is.null(pattern)) {
[10:18:26.981]                           computeRestarts <- base::computeRestarts
[10:18:26.981]                           grepl <- base::grepl
[10:18:26.981]                           restarts <- computeRestarts(cond)
[10:18:26.981]                           for (restart in restarts) {
[10:18:26.981]                             name <- restart$name
[10:18:26.981]                             if (is.null(name)) 
[10:18:26.981]                               next
[10:18:26.981]                             if (!grepl(pattern, name)) 
[10:18:26.981]                               next
[10:18:26.981]                             invokeRestart(restart)
[10:18:26.981]                             muffled <- TRUE
[10:18:26.981]                             break
[10:18:26.981]                           }
[10:18:26.981]                         }
[10:18:26.981]                       }
[10:18:26.981]                       invisible(muffled)
[10:18:26.981]                     }
[10:18:26.981]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.981]                   }
[10:18:26.981]                 }
[10:18:26.981]                 else {
[10:18:26.981]                   if (TRUE) {
[10:18:26.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:26.981]                     {
[10:18:26.981]                       inherits <- base::inherits
[10:18:26.981]                       invokeRestart <- base::invokeRestart
[10:18:26.981]                       is.null <- base::is.null
[10:18:26.981]                       muffled <- FALSE
[10:18:26.981]                       if (inherits(cond, "message")) {
[10:18:26.981]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:26.981]                         if (muffled) 
[10:18:26.981]                           invokeRestart("muffleMessage")
[10:18:26.981]                       }
[10:18:26.981]                       else if (inherits(cond, "warning")) {
[10:18:26.981]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:26.981]                         if (muffled) 
[10:18:26.981]                           invokeRestart("muffleWarning")
[10:18:26.981]                       }
[10:18:26.981]                       else if (inherits(cond, "condition")) {
[10:18:26.981]                         if (!is.null(pattern)) {
[10:18:26.981]                           computeRestarts <- base::computeRestarts
[10:18:26.981]                           grepl <- base::grepl
[10:18:26.981]                           restarts <- computeRestarts(cond)
[10:18:26.981]                           for (restart in restarts) {
[10:18:26.981]                             name <- restart$name
[10:18:26.981]                             if (is.null(name)) 
[10:18:26.981]                               next
[10:18:26.981]                             if (!grepl(pattern, name)) 
[10:18:26.981]                               next
[10:18:26.981]                             invokeRestart(restart)
[10:18:26.981]                             muffled <- TRUE
[10:18:26.981]                             break
[10:18:26.981]                           }
[10:18:26.981]                         }
[10:18:26.981]                       }
[10:18:26.981]                       invisible(muffled)
[10:18:26.981]                     }
[10:18:26.981]                     muffleCondition(cond, pattern = "^muffle")
[10:18:26.981]                   }
[10:18:26.981]                 }
[10:18:26.981]             }
[10:18:26.981]         }))
[10:18:26.981]     }, error = function(ex) {
[10:18:26.981]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:26.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:26.981]                 ...future.rng), started = ...future.startTime, 
[10:18:26.981]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:26.981]             version = "1.8"), class = "FutureResult")
[10:18:26.981]     }, finally = {
[10:18:26.981]         if (!identical(...future.workdir, getwd())) 
[10:18:26.981]             setwd(...future.workdir)
[10:18:26.981]         {
[10:18:26.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:26.981]                 ...future.oldOptions$nwarnings <- NULL
[10:18:26.981]             }
[10:18:26.981]             base::options(...future.oldOptions)
[10:18:26.981]             if (.Platform$OS.type == "windows") {
[10:18:26.981]                 old_names <- names(...future.oldEnvVars)
[10:18:26.981]                 envs <- base::Sys.getenv()
[10:18:26.981]                 names <- names(envs)
[10:18:26.981]                 common <- intersect(names, old_names)
[10:18:26.981]                 added <- setdiff(names, old_names)
[10:18:26.981]                 removed <- setdiff(old_names, names)
[10:18:26.981]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:26.981]                   envs[common]]
[10:18:26.981]                 NAMES <- toupper(changed)
[10:18:26.981]                 args <- list()
[10:18:26.981]                 for (kk in seq_along(NAMES)) {
[10:18:26.981]                   name <- changed[[kk]]
[10:18:26.981]                   NAME <- NAMES[[kk]]
[10:18:26.981]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.981]                     next
[10:18:26.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.981]                 }
[10:18:26.981]                 NAMES <- toupper(added)
[10:18:26.981]                 for (kk in seq_along(NAMES)) {
[10:18:26.981]                   name <- added[[kk]]
[10:18:26.981]                   NAME <- NAMES[[kk]]
[10:18:26.981]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.981]                     next
[10:18:26.981]                   args[[name]] <- ""
[10:18:26.981]                 }
[10:18:26.981]                 NAMES <- toupper(removed)
[10:18:26.981]                 for (kk in seq_along(NAMES)) {
[10:18:26.981]                   name <- removed[[kk]]
[10:18:26.981]                   NAME <- NAMES[[kk]]
[10:18:26.981]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:26.981]                     next
[10:18:26.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:26.981]                 }
[10:18:26.981]                 if (length(args) > 0) 
[10:18:26.981]                   base::do.call(base::Sys.setenv, args = args)
[10:18:26.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:26.981]             }
[10:18:26.981]             else {
[10:18:26.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:26.981]             }
[10:18:26.981]             {
[10:18:26.981]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:26.981]                   0L) {
[10:18:26.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:26.981]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:26.981]                   base::options(opts)
[10:18:26.981]                 }
[10:18:26.981]                 {
[10:18:26.981]                   {
[10:18:26.981]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:26.981]                     NULL
[10:18:26.981]                   }
[10:18:26.981]                   options(future.plan = NULL)
[10:18:26.981]                   if (is.na(NA_character_)) 
[10:18:26.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:26.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:26.981]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:26.981]                     .init = FALSE)
[10:18:26.981]                 }
[10:18:26.981]             }
[10:18:26.981]         }
[10:18:26.981]     })
[10:18:26.981]     if (TRUE) {
[10:18:26.981]         base::sink(type = "output", split = FALSE)
[10:18:26.981]         if (TRUE) {
[10:18:26.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:26.981]         }
[10:18:26.981]         else {
[10:18:26.981]             ...future.result["stdout"] <- base::list(NULL)
[10:18:26.981]         }
[10:18:26.981]         base::close(...future.stdout)
[10:18:26.981]         ...future.stdout <- NULL
[10:18:26.981]     }
[10:18:26.981]     ...future.result$conditions <- ...future.conditions
[10:18:26.981]     ...future.result$finished <- base::Sys.time()
[10:18:26.981]     ...future.result
[10:18:26.981] }
[10:18:26.983] assign_globals() ...
[10:18:26.983] List of 5
[10:18:26.983]  $ future.call.arguments    : list()
[10:18:26.983]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:26.983]  $ ...future.FUN            :function (x, ...)  
[10:18:26.983]  $ ...future.elements_ii    :List of 1
[10:18:26.983]   ..$ : num [1:4] 1 3 1 7
[10:18:26.983]  $ ...future.seeds_ii       : NULL
[10:18:26.983]  $ ...future.globals.maxSize: num Inf
[10:18:26.983]  - attr(*, "resolved")= logi FALSE
[10:18:26.983]  - attr(*, "total_size")= num NA
[10:18:26.983]  - attr(*, "where")=List of 5
[10:18:26.983]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:26.983]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:26.983]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:26.983]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:26.983]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:26.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:26.983]  - attr(*, "already-done")= logi TRUE
[10:18:26.988] - copied ‘future.call.arguments’ to environment
[10:18:26.988] - copied ‘...future.FUN’ to environment
[10:18:26.988] - copied ‘...future.elements_ii’ to environment
[10:18:26.988] - copied ‘...future.seeds_ii’ to environment
[10:18:26.988] - copied ‘...future.globals.maxSize’ to environment
[10:18:26.989] assign_globals() ... done
[10:18:26.989] requestCore(): workers = 2
[10:18:26.991] MulticoreFuture started
[10:18:26.992] - Launch lazy future ... done
[10:18:26.992] run() for ‘MulticoreFuture’ ... done
[10:18:26.992] Created future:
[10:18:26.993] plan(): Setting new future strategy stack:
[10:18:26.993] List of future strategies:
[10:18:26.993] 1. sequential:
[10:18:26.993]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:26.993]    - tweaked: FALSE
[10:18:26.993]    - call: NULL
[10:18:26.994] plan(): nbrOfWorkers() = 1
[10:18:26.996] plan(): Setting new future strategy stack:
[10:18:26.996] List of future strategies:
[10:18:26.996] 1. multicore:
[10:18:26.996]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:26.996]    - tweaked: FALSE
[10:18:26.996]    - call: plan(strategy)
[10:18:27.000] plan(): nbrOfWorkers() = 2
[10:18:26.992] MulticoreFuture:
[10:18:26.992] Label: ‘future_apply-1’
[10:18:26.992] Expression:
[10:18:26.992] {
[10:18:26.992]     do.call(function(...) {
[10:18:26.992]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:26.992]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:26.992]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:26.992]             on.exit(options(oopts), add = TRUE)
[10:18:26.992]         }
[10:18:26.992]         {
[10:18:26.992]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:26.992]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:26.992]                 ...future.FUN(...future.X_jj, ...)
[10:18:26.992]             })
[10:18:26.992]         }
[10:18:26.992]     }, args = future.call.arguments)
[10:18:26.992] }
[10:18:26.992] Lazy evaluation: FALSE
[10:18:26.992] Asynchronous evaluation: TRUE
[10:18:26.992] Local evaluation: TRUE
[10:18:26.992] Environment: R_GlobalEnv
[10:18:26.992] Capture standard output: TRUE
[10:18:26.992] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:26.992] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:26.992] Packages: 1 packages (‘stats’)
[10:18:26.992] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:26.992] Resolved: TRUE
[10:18:26.992] Value: <not collected>
[10:18:26.992] Conditions captured: <none>
[10:18:26.992] Early signaling: FALSE
[10:18:26.992] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:26.992] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.001] Chunk #1 of 2 ... DONE
[10:18:27.001] Chunk #2 of 2 ...
[10:18:27.001]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.001]  - seeds: <none>
[10:18:27.001]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.002] getGlobalsAndPackages() ...
[10:18:27.002] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.002] Resolving globals: FALSE
[10:18:27.002] Tweak future expression to call with '...' arguments ...
[10:18:27.002] {
[10:18:27.002]     do.call(function(...) {
[10:18:27.002]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.002]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.002]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.002]             on.exit(options(oopts), add = TRUE)
[10:18:27.002]         }
[10:18:27.002]         {
[10:18:27.002]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.002]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.002]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.002]             })
[10:18:27.002]         }
[10:18:27.002]     }, args = future.call.arguments)
[10:18:27.002] }
[10:18:27.003] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.003] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.004] - packages: [1] ‘stats’
[10:18:27.004] getGlobalsAndPackages() ... DONE
[10:18:27.004] run() for ‘Future’ ...
[10:18:27.004] - state: ‘created’
[10:18:27.005] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.008] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.008] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.008]   - Field: ‘label’
[10:18:27.008]   - Field: ‘local’
[10:18:27.008]   - Field: ‘owner’
[10:18:27.008]   - Field: ‘envir’
[10:18:27.008]   - Field: ‘workers’
[10:18:27.009]   - Field: ‘packages’
[10:18:27.009]   - Field: ‘gc’
[10:18:27.009]   - Field: ‘job’
[10:18:27.009]   - Field: ‘conditions’
[10:18:27.009]   - Field: ‘expr’
[10:18:27.009]   - Field: ‘uuid’
[10:18:27.009]   - Field: ‘seed’
[10:18:27.010]   - Field: ‘version’
[10:18:27.010]   - Field: ‘result’
[10:18:27.010]   - Field: ‘asynchronous’
[10:18:27.010]   - Field: ‘calls’
[10:18:27.010]   - Field: ‘globals’
[10:18:27.020]   - Field: ‘stdout’
[10:18:27.020]   - Field: ‘earlySignal’
[10:18:27.021]   - Field: ‘lazy’
[10:18:27.021]   - Field: ‘state’
[10:18:27.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.021] - Launch lazy future ...
[10:18:27.021] Packages needed by the future expression (n = 1): ‘stats’
[10:18:27.022] Packages needed by future strategies (n = 0): <none>
[10:18:27.022] {
[10:18:27.022]     {
[10:18:27.022]         {
[10:18:27.022]             ...future.startTime <- base::Sys.time()
[10:18:27.022]             {
[10:18:27.022]                 {
[10:18:27.022]                   {
[10:18:27.022]                     {
[10:18:27.022]                       {
[10:18:27.022]                         base::local({
[10:18:27.022]                           has_future <- base::requireNamespace("future", 
[10:18:27.022]                             quietly = TRUE)
[10:18:27.022]                           if (has_future) {
[10:18:27.022]                             ns <- base::getNamespace("future")
[10:18:27.022]                             version <- ns[[".package"]][["version"]]
[10:18:27.022]                             if (is.null(version)) 
[10:18:27.022]                               version <- utils::packageVersion("future")
[10:18:27.022]                           }
[10:18:27.022]                           else {
[10:18:27.022]                             version <- NULL
[10:18:27.022]                           }
[10:18:27.022]                           if (!has_future || version < "1.8.0") {
[10:18:27.022]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.022]                               "", base::R.version$version.string), 
[10:18:27.022]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:27.022]                                 base::R.version$platform, 8 * 
[10:18:27.022]                                   base::.Machine$sizeof.pointer), 
[10:18:27.022]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.022]                                 "release", "version")], collapse = " "), 
[10:18:27.022]                               hostname = base::Sys.info()[["nodename"]])
[10:18:27.022]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.022]                               info)
[10:18:27.022]                             info <- base::paste(info, collapse = "; ")
[10:18:27.022]                             if (!has_future) {
[10:18:27.022]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.022]                                 info)
[10:18:27.022]                             }
[10:18:27.022]                             else {
[10:18:27.022]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.022]                                 info, version)
[10:18:27.022]                             }
[10:18:27.022]                             base::stop(msg)
[10:18:27.022]                           }
[10:18:27.022]                         })
[10:18:27.022]                       }
[10:18:27.022]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.022]                       base::options(mc.cores = 1L)
[10:18:27.022]                     }
[10:18:27.022]                     base::local({
[10:18:27.022]                       for (pkg in "stats") {
[10:18:27.022]                         base::loadNamespace(pkg)
[10:18:27.022]                         base::library(pkg, character.only = TRUE)
[10:18:27.022]                       }
[10:18:27.022]                     })
[10:18:27.022]                   }
[10:18:27.022]                   ...future.strategy.old <- future::plan("list")
[10:18:27.022]                   options(future.plan = NULL)
[10:18:27.022]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.022]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.022]                 }
[10:18:27.022]                 ...future.workdir <- getwd()
[10:18:27.022]             }
[10:18:27.022]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.022]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.022]         }
[10:18:27.022]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.022]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.022]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.022]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.022]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.022]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.022]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.022]             base::names(...future.oldOptions))
[10:18:27.022]     }
[10:18:27.022]     if (FALSE) {
[10:18:27.022]     }
[10:18:27.022]     else {
[10:18:27.022]         if (TRUE) {
[10:18:27.022]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.022]                 open = "w")
[10:18:27.022]         }
[10:18:27.022]         else {
[10:18:27.022]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.022]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.022]         }
[10:18:27.022]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.022]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.022]             base::sink(type = "output", split = FALSE)
[10:18:27.022]             base::close(...future.stdout)
[10:18:27.022]         }, add = TRUE)
[10:18:27.022]     }
[10:18:27.022]     ...future.frame <- base::sys.nframe()
[10:18:27.022]     ...future.conditions <- base::list()
[10:18:27.022]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.022]     if (FALSE) {
[10:18:27.022]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.022]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.022]     }
[10:18:27.022]     ...future.result <- base::tryCatch({
[10:18:27.022]         base::withCallingHandlers({
[10:18:27.022]             ...future.value <- base::withVisible(base::local({
[10:18:27.022]                 withCallingHandlers({
[10:18:27.022]                   {
[10:18:27.022]                     do.call(function(...) {
[10:18:27.022]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.022]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.022]                         ...future.globals.maxSize)) {
[10:18:27.022]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.022]                         on.exit(options(oopts), add = TRUE)
[10:18:27.022]                       }
[10:18:27.022]                       {
[10:18:27.022]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.022]                           FUN = function(jj) {
[10:18:27.022]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.022]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.022]                           })
[10:18:27.022]                       }
[10:18:27.022]                     }, args = future.call.arguments)
[10:18:27.022]                   }
[10:18:27.022]                 }, immediateCondition = function(cond) {
[10:18:27.022]                   save_rds <- function (object, pathname, ...) 
[10:18:27.022]                   {
[10:18:27.022]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.022]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.022]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.022]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.022]                         fi_tmp[["mtime"]])
[10:18:27.022]                     }
[10:18:27.022]                     tryCatch({
[10:18:27.022]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.022]                     }, error = function(ex) {
[10:18:27.022]                       msg <- conditionMessage(ex)
[10:18:27.022]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.022]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.022]                         fi_tmp[["mtime"]], msg)
[10:18:27.022]                       ex$message <- msg
[10:18:27.022]                       stop(ex)
[10:18:27.022]                     })
[10:18:27.022]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.022]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.022]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.022]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.022]                       fi <- file.info(pathname)
[10:18:27.022]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.022]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.022]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.022]                         fi[["size"]], fi[["mtime"]])
[10:18:27.022]                       stop(msg)
[10:18:27.022]                     }
[10:18:27.022]                     invisible(pathname)
[10:18:27.022]                   }
[10:18:27.022]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.022]                     rootPath = tempdir()) 
[10:18:27.022]                   {
[10:18:27.022]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.022]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.022]                       tmpdir = path, fileext = ".rds")
[10:18:27.022]                     save_rds(obj, file)
[10:18:27.022]                   }
[10:18:27.022]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.022]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.022]                   {
[10:18:27.022]                     inherits <- base::inherits
[10:18:27.022]                     invokeRestart <- base::invokeRestart
[10:18:27.022]                     is.null <- base::is.null
[10:18:27.022]                     muffled <- FALSE
[10:18:27.022]                     if (inherits(cond, "message")) {
[10:18:27.022]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.022]                       if (muffled) 
[10:18:27.022]                         invokeRestart("muffleMessage")
[10:18:27.022]                     }
[10:18:27.022]                     else if (inherits(cond, "warning")) {
[10:18:27.022]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.022]                       if (muffled) 
[10:18:27.022]                         invokeRestart("muffleWarning")
[10:18:27.022]                     }
[10:18:27.022]                     else if (inherits(cond, "condition")) {
[10:18:27.022]                       if (!is.null(pattern)) {
[10:18:27.022]                         computeRestarts <- base::computeRestarts
[10:18:27.022]                         grepl <- base::grepl
[10:18:27.022]                         restarts <- computeRestarts(cond)
[10:18:27.022]                         for (restart in restarts) {
[10:18:27.022]                           name <- restart$name
[10:18:27.022]                           if (is.null(name)) 
[10:18:27.022]                             next
[10:18:27.022]                           if (!grepl(pattern, name)) 
[10:18:27.022]                             next
[10:18:27.022]                           invokeRestart(restart)
[10:18:27.022]                           muffled <- TRUE
[10:18:27.022]                           break
[10:18:27.022]                         }
[10:18:27.022]                       }
[10:18:27.022]                     }
[10:18:27.022]                     invisible(muffled)
[10:18:27.022]                   }
[10:18:27.022]                   muffleCondition(cond)
[10:18:27.022]                 })
[10:18:27.022]             }))
[10:18:27.022]             future::FutureResult(value = ...future.value$value, 
[10:18:27.022]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.022]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.022]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.022]                     ...future.globalenv.names))
[10:18:27.022]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.022]         }, condition = base::local({
[10:18:27.022]             c <- base::c
[10:18:27.022]             inherits <- base::inherits
[10:18:27.022]             invokeRestart <- base::invokeRestart
[10:18:27.022]             length <- base::length
[10:18:27.022]             list <- base::list
[10:18:27.022]             seq.int <- base::seq.int
[10:18:27.022]             signalCondition <- base::signalCondition
[10:18:27.022]             sys.calls <- base::sys.calls
[10:18:27.022]             `[[` <- base::`[[`
[10:18:27.022]             `+` <- base::`+`
[10:18:27.022]             `<<-` <- base::`<<-`
[10:18:27.022]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.022]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.022]                   3L)]
[10:18:27.022]             }
[10:18:27.022]             function(cond) {
[10:18:27.022]                 is_error <- inherits(cond, "error")
[10:18:27.022]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.022]                   NULL)
[10:18:27.022]                 if (is_error) {
[10:18:27.022]                   sessionInformation <- function() {
[10:18:27.022]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.022]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.022]                       search = base::search(), system = base::Sys.info())
[10:18:27.022]                   }
[10:18:27.022]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.022]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.022]                     cond$call), session = sessionInformation(), 
[10:18:27.022]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.022]                   signalCondition(cond)
[10:18:27.022]                 }
[10:18:27.022]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.022]                 "immediateCondition"))) {
[10:18:27.022]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.022]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.022]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.022]                   if (TRUE && !signal) {
[10:18:27.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.022]                     {
[10:18:27.022]                       inherits <- base::inherits
[10:18:27.022]                       invokeRestart <- base::invokeRestart
[10:18:27.022]                       is.null <- base::is.null
[10:18:27.022]                       muffled <- FALSE
[10:18:27.022]                       if (inherits(cond, "message")) {
[10:18:27.022]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.022]                         if (muffled) 
[10:18:27.022]                           invokeRestart("muffleMessage")
[10:18:27.022]                       }
[10:18:27.022]                       else if (inherits(cond, "warning")) {
[10:18:27.022]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.022]                         if (muffled) 
[10:18:27.022]                           invokeRestart("muffleWarning")
[10:18:27.022]                       }
[10:18:27.022]                       else if (inherits(cond, "condition")) {
[10:18:27.022]                         if (!is.null(pattern)) {
[10:18:27.022]                           computeRestarts <- base::computeRestarts
[10:18:27.022]                           grepl <- base::grepl
[10:18:27.022]                           restarts <- computeRestarts(cond)
[10:18:27.022]                           for (restart in restarts) {
[10:18:27.022]                             name <- restart$name
[10:18:27.022]                             if (is.null(name)) 
[10:18:27.022]                               next
[10:18:27.022]                             if (!grepl(pattern, name)) 
[10:18:27.022]                               next
[10:18:27.022]                             invokeRestart(restart)
[10:18:27.022]                             muffled <- TRUE
[10:18:27.022]                             break
[10:18:27.022]                           }
[10:18:27.022]                         }
[10:18:27.022]                       }
[10:18:27.022]                       invisible(muffled)
[10:18:27.022]                     }
[10:18:27.022]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.022]                   }
[10:18:27.022]                 }
[10:18:27.022]                 else {
[10:18:27.022]                   if (TRUE) {
[10:18:27.022]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.022]                     {
[10:18:27.022]                       inherits <- base::inherits
[10:18:27.022]                       invokeRestart <- base::invokeRestart
[10:18:27.022]                       is.null <- base::is.null
[10:18:27.022]                       muffled <- FALSE
[10:18:27.022]                       if (inherits(cond, "message")) {
[10:18:27.022]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.022]                         if (muffled) 
[10:18:27.022]                           invokeRestart("muffleMessage")
[10:18:27.022]                       }
[10:18:27.022]                       else if (inherits(cond, "warning")) {
[10:18:27.022]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.022]                         if (muffled) 
[10:18:27.022]                           invokeRestart("muffleWarning")
[10:18:27.022]                       }
[10:18:27.022]                       else if (inherits(cond, "condition")) {
[10:18:27.022]                         if (!is.null(pattern)) {
[10:18:27.022]                           computeRestarts <- base::computeRestarts
[10:18:27.022]                           grepl <- base::grepl
[10:18:27.022]                           restarts <- computeRestarts(cond)
[10:18:27.022]                           for (restart in restarts) {
[10:18:27.022]                             name <- restart$name
[10:18:27.022]                             if (is.null(name)) 
[10:18:27.022]                               next
[10:18:27.022]                             if (!grepl(pattern, name)) 
[10:18:27.022]                               next
[10:18:27.022]                             invokeRestart(restart)
[10:18:27.022]                             muffled <- TRUE
[10:18:27.022]                             break
[10:18:27.022]                           }
[10:18:27.022]                         }
[10:18:27.022]                       }
[10:18:27.022]                       invisible(muffled)
[10:18:27.022]                     }
[10:18:27.022]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.022]                   }
[10:18:27.022]                 }
[10:18:27.022]             }
[10:18:27.022]         }))
[10:18:27.022]     }, error = function(ex) {
[10:18:27.022]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.022]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.022]                 ...future.rng), started = ...future.startTime, 
[10:18:27.022]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.022]             version = "1.8"), class = "FutureResult")
[10:18:27.022]     }, finally = {
[10:18:27.022]         if (!identical(...future.workdir, getwd())) 
[10:18:27.022]             setwd(...future.workdir)
[10:18:27.022]         {
[10:18:27.022]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.022]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.022]             }
[10:18:27.022]             base::options(...future.oldOptions)
[10:18:27.022]             if (.Platform$OS.type == "windows") {
[10:18:27.022]                 old_names <- names(...future.oldEnvVars)
[10:18:27.022]                 envs <- base::Sys.getenv()
[10:18:27.022]                 names <- names(envs)
[10:18:27.022]                 common <- intersect(names, old_names)
[10:18:27.022]                 added <- setdiff(names, old_names)
[10:18:27.022]                 removed <- setdiff(old_names, names)
[10:18:27.022]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.022]                   envs[common]]
[10:18:27.022]                 NAMES <- toupper(changed)
[10:18:27.022]                 args <- list()
[10:18:27.022]                 for (kk in seq_along(NAMES)) {
[10:18:27.022]                   name <- changed[[kk]]
[10:18:27.022]                   NAME <- NAMES[[kk]]
[10:18:27.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.022]                     next
[10:18:27.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.022]                 }
[10:18:27.022]                 NAMES <- toupper(added)
[10:18:27.022]                 for (kk in seq_along(NAMES)) {
[10:18:27.022]                   name <- added[[kk]]
[10:18:27.022]                   NAME <- NAMES[[kk]]
[10:18:27.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.022]                     next
[10:18:27.022]                   args[[name]] <- ""
[10:18:27.022]                 }
[10:18:27.022]                 NAMES <- toupper(removed)
[10:18:27.022]                 for (kk in seq_along(NAMES)) {
[10:18:27.022]                   name <- removed[[kk]]
[10:18:27.022]                   NAME <- NAMES[[kk]]
[10:18:27.022]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.022]                     next
[10:18:27.022]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.022]                 }
[10:18:27.022]                 if (length(args) > 0) 
[10:18:27.022]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.022]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.022]             }
[10:18:27.022]             else {
[10:18:27.022]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.022]             }
[10:18:27.022]             {
[10:18:27.022]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.022]                   0L) {
[10:18:27.022]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.022]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.022]                   base::options(opts)
[10:18:27.022]                 }
[10:18:27.022]                 {
[10:18:27.022]                   {
[10:18:27.022]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.022]                     NULL
[10:18:27.022]                   }
[10:18:27.022]                   options(future.plan = NULL)
[10:18:27.022]                   if (is.na(NA_character_)) 
[10:18:27.022]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.022]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.022]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.022]                     .init = FALSE)
[10:18:27.022]                 }
[10:18:27.022]             }
[10:18:27.022]         }
[10:18:27.022]     })
[10:18:27.022]     if (TRUE) {
[10:18:27.022]         base::sink(type = "output", split = FALSE)
[10:18:27.022]         if (TRUE) {
[10:18:27.022]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.022]         }
[10:18:27.022]         else {
[10:18:27.022]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.022]         }
[10:18:27.022]         base::close(...future.stdout)
[10:18:27.022]         ...future.stdout <- NULL
[10:18:27.022]     }
[10:18:27.022]     ...future.result$conditions <- ...future.conditions
[10:18:27.022]     ...future.result$finished <- base::Sys.time()
[10:18:27.022]     ...future.result
[10:18:27.022] }
[10:18:27.025] assign_globals() ...
[10:18:27.026] List of 5
[10:18:27.026]  $ future.call.arguments    : list()
[10:18:27.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.026]  $ ...future.FUN            :function (x, ...)  
[10:18:27.026]  $ ...future.elements_ii    :List of 1
[10:18:27.026]   ..$ : num [1:4] 2 4 6 8
[10:18:27.026]  $ ...future.seeds_ii       : NULL
[10:18:27.026]  $ ...future.globals.maxSize: num Inf
[10:18:27.026]  - attr(*, "resolved")= logi FALSE
[10:18:27.026]  - attr(*, "total_size")= num NA
[10:18:27.026]  - attr(*, "where")=List of 5
[10:18:27.026]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.026]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.026]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.026]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.026]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.026]  - attr(*, "already-done")= logi TRUE
[10:18:27.034] - copied ‘future.call.arguments’ to environment
[10:18:27.034] - copied ‘...future.FUN’ to environment
[10:18:27.035] - copied ‘...future.elements_ii’ to environment
[10:18:27.035] - copied ‘...future.seeds_ii’ to environment
[10:18:27.035] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.035] assign_globals() ... done
[10:18:27.035] requestCore(): workers = 2
[10:18:27.038] MulticoreFuture started
[10:18:27.038] - Launch lazy future ... done
[10:18:27.038] run() for ‘MulticoreFuture’ ... done
[10:18:27.039] Created future:
[10:18:27.039] plan(): Setting new future strategy stack:
[10:18:27.039] List of future strategies:
[10:18:27.039] 1. sequential:
[10:18:27.039]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.039]    - tweaked: FALSE
[10:18:27.039]    - call: NULL
[10:18:27.040] plan(): nbrOfWorkers() = 1
[10:18:27.043] plan(): Setting new future strategy stack:
[10:18:27.043] List of future strategies:
[10:18:27.043] 1. multicore:
[10:18:27.043]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.043]    - tweaked: FALSE
[10:18:27.043]    - call: plan(strategy)
[10:18:27.047] plan(): nbrOfWorkers() = 2
[10:18:27.039] MulticoreFuture:
[10:18:27.039] Label: ‘future_apply-2’
[10:18:27.039] Expression:
[10:18:27.039] {
[10:18:27.039]     do.call(function(...) {
[10:18:27.039]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.039]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.039]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.039]             on.exit(options(oopts), add = TRUE)
[10:18:27.039]         }
[10:18:27.039]         {
[10:18:27.039]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.039]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.039]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.039]             })
[10:18:27.039]         }
[10:18:27.039]     }, args = future.call.arguments)
[10:18:27.039] }
[10:18:27.039] Lazy evaluation: FALSE
[10:18:27.039] Asynchronous evaluation: TRUE
[10:18:27.039] Local evaluation: TRUE
[10:18:27.039] Environment: R_GlobalEnv
[10:18:27.039] Capture standard output: TRUE
[10:18:27.039] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.039] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.039] Packages: 1 packages (‘stats’)
[10:18:27.039] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.039] Resolved: TRUE
[10:18:27.039] Value: <not collected>
[10:18:27.039] Conditions captured: <none>
[10:18:27.039] Early signaling: FALSE
[10:18:27.039] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.039] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.048] Chunk #2 of 2 ... DONE
[10:18:27.048] Launching 2 futures (chunks) ... DONE
[10:18:27.048] Resolving 2 futures (chunks) ...
[10:18:27.048] resolve() on list ...
[10:18:27.048]  recursive: 0
[10:18:27.049]  length: 2
[10:18:27.049] 
[10:18:27.049] Future #1
[10:18:27.049] result() for MulticoreFuture ...
[10:18:27.050] result() for MulticoreFuture ...
[10:18:27.051] result() for MulticoreFuture ... done
[10:18:27.051] result() for MulticoreFuture ... done
[10:18:27.051] result() for MulticoreFuture ...
[10:18:27.051] result() for MulticoreFuture ... done
[10:18:27.051] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:27.051] - nx: 2
[10:18:27.051] - relay: TRUE
[10:18:27.052] - stdout: TRUE
[10:18:27.052] - signal: TRUE
[10:18:27.052] - resignal: FALSE
[10:18:27.052] - force: TRUE
[10:18:27.052] - relayed: [n=2] FALSE, FALSE
[10:18:27.052] - queued futures: [n=2] FALSE, FALSE
[10:18:27.052]  - until=1
[10:18:27.053]  - relaying element #1
[10:18:27.053] result() for MulticoreFuture ...
[10:18:27.053] result() for MulticoreFuture ... done
[10:18:27.053] result() for MulticoreFuture ...
[10:18:27.053] result() for MulticoreFuture ... done
[10:18:27.053] result() for MulticoreFuture ...
[10:18:27.053] result() for MulticoreFuture ... done
[10:18:27.054] result() for MulticoreFuture ...
[10:18:27.054] result() for MulticoreFuture ... done
[10:18:27.054] - relayed: [n=2] TRUE, FALSE
[10:18:27.054] - queued futures: [n=2] TRUE, FALSE
[10:18:27.054] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:27.054]  length: 1 (resolved future 1)
[10:18:27.055] Future #2
[10:18:27.055] result() for MulticoreFuture ...
[10:18:27.056] result() for MulticoreFuture ...
[10:18:27.056] result() for MulticoreFuture ... done
[10:18:27.056] result() for MulticoreFuture ... done
[10:18:27.056] result() for MulticoreFuture ...
[10:18:27.056] result() for MulticoreFuture ... done
[10:18:27.056] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:27.057] - nx: 2
[10:18:27.057] - relay: TRUE
[10:18:27.057] - stdout: TRUE
[10:18:27.057] - signal: TRUE
[10:18:27.057] - resignal: FALSE
[10:18:27.057] - force: TRUE
[10:18:27.057] - relayed: [n=2] TRUE, FALSE
[10:18:27.057] - queued futures: [n=2] TRUE, FALSE
[10:18:27.058]  - until=2
[10:18:27.058]  - relaying element #2
[10:18:27.058] result() for MulticoreFuture ...
[10:18:27.058] result() for MulticoreFuture ... done
[10:18:27.058] result() for MulticoreFuture ...
[10:18:27.058] result() for MulticoreFuture ... done
[10:18:27.058] result() for MulticoreFuture ...
[10:18:27.058] result() for MulticoreFuture ... done
[10:18:27.059] result() for MulticoreFuture ...
[10:18:27.059] result() for MulticoreFuture ... done
[10:18:27.059] - relayed: [n=2] TRUE, TRUE
[10:18:27.059] - queued futures: [n=2] TRUE, TRUE
[10:18:27.059] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:27.059]  length: 0 (resolved future 2)
[10:18:27.059] Relaying remaining futures
[10:18:27.059] signalConditionsASAP(NULL, pos=0) ...
[10:18:27.059] - nx: 2
[10:18:27.060] - relay: TRUE
[10:18:27.060] - stdout: TRUE
[10:18:27.060] - signal: TRUE
[10:18:27.060] - resignal: FALSE
[10:18:27.060] - force: TRUE
[10:18:27.060] - relayed: [n=2] TRUE, TRUE
[10:18:27.060] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:27.060] - relayed: [n=2] TRUE, TRUE
[10:18:27.060] - queued futures: [n=2] TRUE, TRUE
[10:18:27.061] signalConditionsASAP(NULL, pos=0) ... done
[10:18:27.061] resolve() on list ... DONE
[10:18:27.061] result() for MulticoreFuture ...
[10:18:27.061] result() for MulticoreFuture ... done
[10:18:27.061] result() for MulticoreFuture ...
[10:18:27.061] result() for MulticoreFuture ... done
[10:18:27.061] result() for MulticoreFuture ...
[10:18:27.061] result() for MulticoreFuture ... done
[10:18:27.061] result() for MulticoreFuture ...
[10:18:27.062] result() for MulticoreFuture ... done
[10:18:27.062]  - Number of value chunks collected: 2
[10:18:27.062] Resolving 2 futures (chunks) ... DONE
[10:18:27.062] Reducing values from 2 chunks ...
[10:18:27.062]  - Number of values collected after concatenation: 2
[10:18:27.062]  - Number of values expected: 2
[10:18:27.062] Reducing values from 2 chunks ... DONE
[10:18:27.062] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:18:27.063] getGlobalsAndPackagesXApply() ...
[10:18:27.063]  - future.globals: TRUE
[10:18:27.063] getGlobalsAndPackages() ...
[10:18:27.063] Searching for globals...
[10:18:27.065] - globals found: [1] ‘FUN’
[10:18:27.065] Searching for globals ... DONE
[10:18:27.065] Resolving globals: FALSE
[10:18:27.066] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:27.069] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:27.069] - globals: [1] ‘FUN’
[10:18:27.069] 
[10:18:27.069] getGlobalsAndPackages() ... DONE
[10:18:27.069]  - globals found/used: [n=1] ‘FUN’
[10:18:27.070]  - needed namespaces: [n=0] 
[10:18:27.070] Finding globals ... DONE
[10:18:27.070]  - use_args: TRUE
[10:18:27.070]  - Getting '...' globals ...
[10:18:27.071] resolve() on list ...
[10:18:27.071]  recursive: 0
[10:18:27.071]  length: 1
[10:18:27.071]  elements: ‘...’
[10:18:27.071]  length: 0 (resolved future 1)
[10:18:27.071] resolve() on list ... DONE
[10:18:27.072]    - '...' content: [n=0] 
[10:18:27.072] List of 1
[10:18:27.072]  $ ...: list()
[10:18:27.072]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.072]  - attr(*, "where")=List of 1
[10:18:27.072]   ..$ ...:<environment: 0x556e03c4ae68> 
[10:18:27.072]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.072]  - attr(*, "resolved")= logi TRUE
[10:18:27.072]  - attr(*, "total_size")= num NA
[10:18:27.075]  - Getting '...' globals ... DONE
[10:18:27.075] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:27.075] List of 2
[10:18:27.075]  $ ...future.FUN:function (x)  
[10:18:27.075]  $ ...          : list()
[10:18:27.075]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.075]  - attr(*, "where")=List of 2
[10:18:27.075]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:27.075]   ..$ ...          :<environment: 0x556e03c4ae68> 
[10:18:27.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.075]  - attr(*, "resolved")= logi FALSE
[10:18:27.075]  - attr(*, "total_size")= num 2624
[10:18:27.079] Packages to be attached in all futures: [n=0] 
[10:18:27.079] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.080] future_lapply() ...
[10:18:27.083] Number of chunks: 2
[10:18:27.083] getGlobalsAndPackagesXApply() ...
[10:18:27.083]  - future.globals: <name-value list> with names ‘list()’
[10:18:27.083]  - use_args: TRUE
[10:18:27.083] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:27.083] List of 2
[10:18:27.083]  $ ...          : list()
[10:18:27.083]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.083]  $ ...future.FUN:function (x)  
[10:18:27.083]  - attr(*, "where")=List of 2
[10:18:27.083]   ..$ ...          :<environment: 0x556e03c4ae68> 
[10:18:27.083]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:27.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.083]  - attr(*, "resolved")= logi FALSE
[10:18:27.083]  - attr(*, "total_size")= num NA
[10:18:27.087] Packages to be attached in all futures: [n=0] 
[10:18:27.087] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.087] Number of futures (= number of chunks): 2
[10:18:27.087] Launching 2 futures (chunks) ...
[10:18:27.087] Chunk #1 of 2 ...
[10:18:27.088]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.088]  - seeds: <none>
[10:18:27.088]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.088] getGlobalsAndPackages() ...
[10:18:27.088] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.088] Resolving globals: FALSE
[10:18:27.088] Tweak future expression to call with '...' arguments ...
[10:18:27.088] {
[10:18:27.088]     do.call(function(...) {
[10:18:27.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.088]             on.exit(options(oopts), add = TRUE)
[10:18:27.088]         }
[10:18:27.088]         {
[10:18:27.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.088]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.088]             })
[10:18:27.088]         }
[10:18:27.088]     }, args = future.call.arguments)
[10:18:27.088] }
[10:18:27.089] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.089] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.089] 
[10:18:27.089] getGlobalsAndPackages() ... DONE
[10:18:27.090] run() for ‘Future’ ...
[10:18:27.090] - state: ‘created’
[10:18:27.090] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.092] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.092]   - Field: ‘label’
[10:18:27.092]   - Field: ‘local’
[10:18:27.092]   - Field: ‘owner’
[10:18:27.092]   - Field: ‘envir’
[10:18:27.092]   - Field: ‘workers’
[10:18:27.092]   - Field: ‘packages’
[10:18:27.092]   - Field: ‘gc’
[10:18:27.092]   - Field: ‘job’
[10:18:27.093]   - Field: ‘conditions’
[10:18:27.093]   - Field: ‘expr’
[10:18:27.093]   - Field: ‘uuid’
[10:18:27.093]   - Field: ‘seed’
[10:18:27.093]   - Field: ‘version’
[10:18:27.093]   - Field: ‘result’
[10:18:27.093]   - Field: ‘asynchronous’
[10:18:27.093]   - Field: ‘calls’
[10:18:27.093]   - Field: ‘globals’
[10:18:27.093]   - Field: ‘stdout’
[10:18:27.093]   - Field: ‘earlySignal’
[10:18:27.093]   - Field: ‘lazy’
[10:18:27.094]   - Field: ‘state’
[10:18:27.094] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.094] - Launch lazy future ...
[10:18:27.094] Packages needed by the future expression (n = 0): <none>
[10:18:27.094] Packages needed by future strategies (n = 0): <none>
[10:18:27.095] {
[10:18:27.095]     {
[10:18:27.095]         {
[10:18:27.095]             ...future.startTime <- base::Sys.time()
[10:18:27.095]             {
[10:18:27.095]                 {
[10:18:27.095]                   {
[10:18:27.095]                     {
[10:18:27.095]                       base::local({
[10:18:27.095]                         has_future <- base::requireNamespace("future", 
[10:18:27.095]                           quietly = TRUE)
[10:18:27.095]                         if (has_future) {
[10:18:27.095]                           ns <- base::getNamespace("future")
[10:18:27.095]                           version <- ns[[".package"]][["version"]]
[10:18:27.095]                           if (is.null(version)) 
[10:18:27.095]                             version <- utils::packageVersion("future")
[10:18:27.095]                         }
[10:18:27.095]                         else {
[10:18:27.095]                           version <- NULL
[10:18:27.095]                         }
[10:18:27.095]                         if (!has_future || version < "1.8.0") {
[10:18:27.095]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.095]                             "", base::R.version$version.string), 
[10:18:27.095]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.095]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.095]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.095]                               "release", "version")], collapse = " "), 
[10:18:27.095]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.095]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.095]                             info)
[10:18:27.095]                           info <- base::paste(info, collapse = "; ")
[10:18:27.095]                           if (!has_future) {
[10:18:27.095]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.095]                               info)
[10:18:27.095]                           }
[10:18:27.095]                           else {
[10:18:27.095]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.095]                               info, version)
[10:18:27.095]                           }
[10:18:27.095]                           base::stop(msg)
[10:18:27.095]                         }
[10:18:27.095]                       })
[10:18:27.095]                     }
[10:18:27.095]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.095]                     base::options(mc.cores = 1L)
[10:18:27.095]                   }
[10:18:27.095]                   ...future.strategy.old <- future::plan("list")
[10:18:27.095]                   options(future.plan = NULL)
[10:18:27.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.095]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.095]                 }
[10:18:27.095]                 ...future.workdir <- getwd()
[10:18:27.095]             }
[10:18:27.095]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.095]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.095]         }
[10:18:27.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.095]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.095]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.095]             base::names(...future.oldOptions))
[10:18:27.095]     }
[10:18:27.095]     if (FALSE) {
[10:18:27.095]     }
[10:18:27.095]     else {
[10:18:27.095]         if (TRUE) {
[10:18:27.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.095]                 open = "w")
[10:18:27.095]         }
[10:18:27.095]         else {
[10:18:27.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.095]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.095]         }
[10:18:27.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.095]             base::sink(type = "output", split = FALSE)
[10:18:27.095]             base::close(...future.stdout)
[10:18:27.095]         }, add = TRUE)
[10:18:27.095]     }
[10:18:27.095]     ...future.frame <- base::sys.nframe()
[10:18:27.095]     ...future.conditions <- base::list()
[10:18:27.095]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.095]     if (FALSE) {
[10:18:27.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.095]     }
[10:18:27.095]     ...future.result <- base::tryCatch({
[10:18:27.095]         base::withCallingHandlers({
[10:18:27.095]             ...future.value <- base::withVisible(base::local({
[10:18:27.095]                 withCallingHandlers({
[10:18:27.095]                   {
[10:18:27.095]                     do.call(function(...) {
[10:18:27.095]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.095]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.095]                         ...future.globals.maxSize)) {
[10:18:27.095]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.095]                         on.exit(options(oopts), add = TRUE)
[10:18:27.095]                       }
[10:18:27.095]                       {
[10:18:27.095]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.095]                           FUN = function(jj) {
[10:18:27.095]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.095]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.095]                           })
[10:18:27.095]                       }
[10:18:27.095]                     }, args = future.call.arguments)
[10:18:27.095]                   }
[10:18:27.095]                 }, immediateCondition = function(cond) {
[10:18:27.095]                   save_rds <- function (object, pathname, ...) 
[10:18:27.095]                   {
[10:18:27.095]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.095]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.095]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.095]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.095]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.095]                         fi_tmp[["mtime"]])
[10:18:27.095]                     }
[10:18:27.095]                     tryCatch({
[10:18:27.095]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.095]                     }, error = function(ex) {
[10:18:27.095]                       msg <- conditionMessage(ex)
[10:18:27.095]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.095]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.095]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.095]                         fi_tmp[["mtime"]], msg)
[10:18:27.095]                       ex$message <- msg
[10:18:27.095]                       stop(ex)
[10:18:27.095]                     })
[10:18:27.095]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.095]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.095]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.095]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.095]                       fi <- file.info(pathname)
[10:18:27.095]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.095]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.095]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.095]                         fi[["size"]], fi[["mtime"]])
[10:18:27.095]                       stop(msg)
[10:18:27.095]                     }
[10:18:27.095]                     invisible(pathname)
[10:18:27.095]                   }
[10:18:27.095]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.095]                     rootPath = tempdir()) 
[10:18:27.095]                   {
[10:18:27.095]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.095]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.095]                       tmpdir = path, fileext = ".rds")
[10:18:27.095]                     save_rds(obj, file)
[10:18:27.095]                   }
[10:18:27.095]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.095]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.095]                   {
[10:18:27.095]                     inherits <- base::inherits
[10:18:27.095]                     invokeRestart <- base::invokeRestart
[10:18:27.095]                     is.null <- base::is.null
[10:18:27.095]                     muffled <- FALSE
[10:18:27.095]                     if (inherits(cond, "message")) {
[10:18:27.095]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.095]                       if (muffled) 
[10:18:27.095]                         invokeRestart("muffleMessage")
[10:18:27.095]                     }
[10:18:27.095]                     else if (inherits(cond, "warning")) {
[10:18:27.095]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.095]                       if (muffled) 
[10:18:27.095]                         invokeRestart("muffleWarning")
[10:18:27.095]                     }
[10:18:27.095]                     else if (inherits(cond, "condition")) {
[10:18:27.095]                       if (!is.null(pattern)) {
[10:18:27.095]                         computeRestarts <- base::computeRestarts
[10:18:27.095]                         grepl <- base::grepl
[10:18:27.095]                         restarts <- computeRestarts(cond)
[10:18:27.095]                         for (restart in restarts) {
[10:18:27.095]                           name <- restart$name
[10:18:27.095]                           if (is.null(name)) 
[10:18:27.095]                             next
[10:18:27.095]                           if (!grepl(pattern, name)) 
[10:18:27.095]                             next
[10:18:27.095]                           invokeRestart(restart)
[10:18:27.095]                           muffled <- TRUE
[10:18:27.095]                           break
[10:18:27.095]                         }
[10:18:27.095]                       }
[10:18:27.095]                     }
[10:18:27.095]                     invisible(muffled)
[10:18:27.095]                   }
[10:18:27.095]                   muffleCondition(cond)
[10:18:27.095]                 })
[10:18:27.095]             }))
[10:18:27.095]             future::FutureResult(value = ...future.value$value, 
[10:18:27.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.095]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.095]                     ...future.globalenv.names))
[10:18:27.095]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.095]         }, condition = base::local({
[10:18:27.095]             c <- base::c
[10:18:27.095]             inherits <- base::inherits
[10:18:27.095]             invokeRestart <- base::invokeRestart
[10:18:27.095]             length <- base::length
[10:18:27.095]             list <- base::list
[10:18:27.095]             seq.int <- base::seq.int
[10:18:27.095]             signalCondition <- base::signalCondition
[10:18:27.095]             sys.calls <- base::sys.calls
[10:18:27.095]             `[[` <- base::`[[`
[10:18:27.095]             `+` <- base::`+`
[10:18:27.095]             `<<-` <- base::`<<-`
[10:18:27.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.095]                   3L)]
[10:18:27.095]             }
[10:18:27.095]             function(cond) {
[10:18:27.095]                 is_error <- inherits(cond, "error")
[10:18:27.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.095]                   NULL)
[10:18:27.095]                 if (is_error) {
[10:18:27.095]                   sessionInformation <- function() {
[10:18:27.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.095]                       search = base::search(), system = base::Sys.info())
[10:18:27.095]                   }
[10:18:27.095]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.095]                     cond$call), session = sessionInformation(), 
[10:18:27.095]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.095]                   signalCondition(cond)
[10:18:27.095]                 }
[10:18:27.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.095]                 "immediateCondition"))) {
[10:18:27.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.095]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.095]                   if (TRUE && !signal) {
[10:18:27.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.095]                     {
[10:18:27.095]                       inherits <- base::inherits
[10:18:27.095]                       invokeRestart <- base::invokeRestart
[10:18:27.095]                       is.null <- base::is.null
[10:18:27.095]                       muffled <- FALSE
[10:18:27.095]                       if (inherits(cond, "message")) {
[10:18:27.095]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.095]                         if (muffled) 
[10:18:27.095]                           invokeRestart("muffleMessage")
[10:18:27.095]                       }
[10:18:27.095]                       else if (inherits(cond, "warning")) {
[10:18:27.095]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.095]                         if (muffled) 
[10:18:27.095]                           invokeRestart("muffleWarning")
[10:18:27.095]                       }
[10:18:27.095]                       else if (inherits(cond, "condition")) {
[10:18:27.095]                         if (!is.null(pattern)) {
[10:18:27.095]                           computeRestarts <- base::computeRestarts
[10:18:27.095]                           grepl <- base::grepl
[10:18:27.095]                           restarts <- computeRestarts(cond)
[10:18:27.095]                           for (restart in restarts) {
[10:18:27.095]                             name <- restart$name
[10:18:27.095]                             if (is.null(name)) 
[10:18:27.095]                               next
[10:18:27.095]                             if (!grepl(pattern, name)) 
[10:18:27.095]                               next
[10:18:27.095]                             invokeRestart(restart)
[10:18:27.095]                             muffled <- TRUE
[10:18:27.095]                             break
[10:18:27.095]                           }
[10:18:27.095]                         }
[10:18:27.095]                       }
[10:18:27.095]                       invisible(muffled)
[10:18:27.095]                     }
[10:18:27.095]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.095]                   }
[10:18:27.095]                 }
[10:18:27.095]                 else {
[10:18:27.095]                   if (TRUE) {
[10:18:27.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.095]                     {
[10:18:27.095]                       inherits <- base::inherits
[10:18:27.095]                       invokeRestart <- base::invokeRestart
[10:18:27.095]                       is.null <- base::is.null
[10:18:27.095]                       muffled <- FALSE
[10:18:27.095]                       if (inherits(cond, "message")) {
[10:18:27.095]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.095]                         if (muffled) 
[10:18:27.095]                           invokeRestart("muffleMessage")
[10:18:27.095]                       }
[10:18:27.095]                       else if (inherits(cond, "warning")) {
[10:18:27.095]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.095]                         if (muffled) 
[10:18:27.095]                           invokeRestart("muffleWarning")
[10:18:27.095]                       }
[10:18:27.095]                       else if (inherits(cond, "condition")) {
[10:18:27.095]                         if (!is.null(pattern)) {
[10:18:27.095]                           computeRestarts <- base::computeRestarts
[10:18:27.095]                           grepl <- base::grepl
[10:18:27.095]                           restarts <- computeRestarts(cond)
[10:18:27.095]                           for (restart in restarts) {
[10:18:27.095]                             name <- restart$name
[10:18:27.095]                             if (is.null(name)) 
[10:18:27.095]                               next
[10:18:27.095]                             if (!grepl(pattern, name)) 
[10:18:27.095]                               next
[10:18:27.095]                             invokeRestart(restart)
[10:18:27.095]                             muffled <- TRUE
[10:18:27.095]                             break
[10:18:27.095]                           }
[10:18:27.095]                         }
[10:18:27.095]                       }
[10:18:27.095]                       invisible(muffled)
[10:18:27.095]                     }
[10:18:27.095]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.095]                   }
[10:18:27.095]                 }
[10:18:27.095]             }
[10:18:27.095]         }))
[10:18:27.095]     }, error = function(ex) {
[10:18:27.095]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.095]                 ...future.rng), started = ...future.startTime, 
[10:18:27.095]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.095]             version = "1.8"), class = "FutureResult")
[10:18:27.095]     }, finally = {
[10:18:27.095]         if (!identical(...future.workdir, getwd())) 
[10:18:27.095]             setwd(...future.workdir)
[10:18:27.095]         {
[10:18:27.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.095]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.095]             }
[10:18:27.095]             base::options(...future.oldOptions)
[10:18:27.095]             if (.Platform$OS.type == "windows") {
[10:18:27.095]                 old_names <- names(...future.oldEnvVars)
[10:18:27.095]                 envs <- base::Sys.getenv()
[10:18:27.095]                 names <- names(envs)
[10:18:27.095]                 common <- intersect(names, old_names)
[10:18:27.095]                 added <- setdiff(names, old_names)
[10:18:27.095]                 removed <- setdiff(old_names, names)
[10:18:27.095]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.095]                   envs[common]]
[10:18:27.095]                 NAMES <- toupper(changed)
[10:18:27.095]                 args <- list()
[10:18:27.095]                 for (kk in seq_along(NAMES)) {
[10:18:27.095]                   name <- changed[[kk]]
[10:18:27.095]                   NAME <- NAMES[[kk]]
[10:18:27.095]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.095]                     next
[10:18:27.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.095]                 }
[10:18:27.095]                 NAMES <- toupper(added)
[10:18:27.095]                 for (kk in seq_along(NAMES)) {
[10:18:27.095]                   name <- added[[kk]]
[10:18:27.095]                   NAME <- NAMES[[kk]]
[10:18:27.095]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.095]                     next
[10:18:27.095]                   args[[name]] <- ""
[10:18:27.095]                 }
[10:18:27.095]                 NAMES <- toupper(removed)
[10:18:27.095]                 for (kk in seq_along(NAMES)) {
[10:18:27.095]                   name <- removed[[kk]]
[10:18:27.095]                   NAME <- NAMES[[kk]]
[10:18:27.095]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.095]                     next
[10:18:27.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.095]                 }
[10:18:27.095]                 if (length(args) > 0) 
[10:18:27.095]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.095]             }
[10:18:27.095]             else {
[10:18:27.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.095]             }
[10:18:27.095]             {
[10:18:27.095]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.095]                   0L) {
[10:18:27.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.095]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.095]                   base::options(opts)
[10:18:27.095]                 }
[10:18:27.095]                 {
[10:18:27.095]                   {
[10:18:27.095]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.095]                     NULL
[10:18:27.095]                   }
[10:18:27.095]                   options(future.plan = NULL)
[10:18:27.095]                   if (is.na(NA_character_)) 
[10:18:27.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.095]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.095]                     .init = FALSE)
[10:18:27.095]                 }
[10:18:27.095]             }
[10:18:27.095]         }
[10:18:27.095]     })
[10:18:27.095]     if (TRUE) {
[10:18:27.095]         base::sink(type = "output", split = FALSE)
[10:18:27.095]         if (TRUE) {
[10:18:27.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.095]         }
[10:18:27.095]         else {
[10:18:27.095]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.095]         }
[10:18:27.095]         base::close(...future.stdout)
[10:18:27.095]         ...future.stdout <- NULL
[10:18:27.095]     }
[10:18:27.095]     ...future.result$conditions <- ...future.conditions
[10:18:27.095]     ...future.result$finished <- base::Sys.time()
[10:18:27.095]     ...future.result
[10:18:27.095] }
[10:18:27.097] assign_globals() ...
[10:18:27.097] List of 5
[10:18:27.097]  $ future.call.arguments    : list()
[10:18:27.097]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.097]  $ ...future.FUN            :function (x)  
[10:18:27.097]  $ ...future.elements_ii    :List of 1
[10:18:27.097]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:18:27.097]  $ ...future.seeds_ii       : NULL
[10:18:27.097]  $ ...future.globals.maxSize: num Inf
[10:18:27.097]  - attr(*, "resolved")= logi FALSE
[10:18:27.097]  - attr(*, "total_size")= num NA
[10:18:27.097]  - attr(*, "where")=List of 5
[10:18:27.097]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.097]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.097]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.097]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.097]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.097]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.097]  - attr(*, "already-done")= logi TRUE
[10:18:27.104] - copied ‘future.call.arguments’ to environment
[10:18:27.105] - copied ‘...future.FUN’ to environment
[10:18:27.105] - copied ‘...future.elements_ii’ to environment
[10:18:27.105] - copied ‘...future.seeds_ii’ to environment
[10:18:27.105] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.105] assign_globals() ... done
[10:18:27.105] requestCore(): workers = 2
[10:18:27.108] MulticoreFuture started
[10:18:27.108] - Launch lazy future ... done
[10:18:27.108] run() for ‘MulticoreFuture’ ... done
[10:18:27.109] Created future:
[10:18:27.109] plan(): Setting new future strategy stack:
[10:18:27.109] List of future strategies:
[10:18:27.109] 1. sequential:
[10:18:27.109]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.109]    - tweaked: FALSE
[10:18:27.109]    - call: NULL
[10:18:27.110] plan(): nbrOfWorkers() = 1
[10:18:27.112] plan(): Setting new future strategy stack:
[10:18:27.112] List of future strategies:
[10:18:27.112] 1. multicore:
[10:18:27.112]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.112]    - tweaked: FALSE
[10:18:27.112]    - call: plan(strategy)
[10:18:27.116] plan(): nbrOfWorkers() = 2
[10:18:27.109] MulticoreFuture:
[10:18:27.109] Label: ‘future_apply-1’
[10:18:27.109] Expression:
[10:18:27.109] {
[10:18:27.109]     do.call(function(...) {
[10:18:27.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.109]             on.exit(options(oopts), add = TRUE)
[10:18:27.109]         }
[10:18:27.109]         {
[10:18:27.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.109]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.109]             })
[10:18:27.109]         }
[10:18:27.109]     }, args = future.call.arguments)
[10:18:27.109] }
[10:18:27.109] Lazy evaluation: FALSE
[10:18:27.109] Asynchronous evaluation: TRUE
[10:18:27.109] Local evaluation: TRUE
[10:18:27.109] Environment: R_GlobalEnv
[10:18:27.109] Capture standard output: TRUE
[10:18:27.109] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.109] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.109] Packages: <none>
[10:18:27.109] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.109] Resolved: TRUE
[10:18:27.109] Value: <not collected>
[10:18:27.109] Conditions captured: <none>
[10:18:27.109] Early signaling: FALSE
[10:18:27.109] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.109] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.117] Chunk #1 of 2 ... DONE
[10:18:27.117] Chunk #2 of 2 ...
[10:18:27.117]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.117]  - seeds: <none>
[10:18:27.117]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.118] getGlobalsAndPackages() ...
[10:18:27.118] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.118] Resolving globals: FALSE
[10:18:27.118] Tweak future expression to call with '...' arguments ...
[10:18:27.118] {
[10:18:27.118]     do.call(function(...) {
[10:18:27.118]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.118]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.118]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.118]             on.exit(options(oopts), add = TRUE)
[10:18:27.118]         }
[10:18:27.118]         {
[10:18:27.118]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.118]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.118]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.118]             })
[10:18:27.118]         }
[10:18:27.118]     }, args = future.call.arguments)
[10:18:27.118] }
[10:18:27.119] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.119] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.119] 
[10:18:27.120] getGlobalsAndPackages() ... DONE
[10:18:27.120] run() for ‘Future’ ...
[10:18:27.120] - state: ‘created’
[10:18:27.121] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.123] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.124] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.124]   - Field: ‘label’
[10:18:27.124]   - Field: ‘local’
[10:18:27.124]   - Field: ‘owner’
[10:18:27.124]   - Field: ‘envir’
[10:18:27.124]   - Field: ‘workers’
[10:18:27.124]   - Field: ‘packages’
[10:18:27.125]   - Field: ‘gc’
[10:18:27.125]   - Field: ‘job’
[10:18:27.125]   - Field: ‘conditions’
[10:18:27.125]   - Field: ‘expr’
[10:18:27.125]   - Field: ‘uuid’
[10:18:27.125]   - Field: ‘seed’
[10:18:27.125]   - Field: ‘version’
[10:18:27.126]   - Field: ‘result’
[10:18:27.126]   - Field: ‘asynchronous’
[10:18:27.126]   - Field: ‘calls’
[10:18:27.126]   - Field: ‘globals’
[10:18:27.126]   - Field: ‘stdout’
[10:18:27.126]   - Field: ‘earlySignal’
[10:18:27.126]   - Field: ‘lazy’
[10:18:27.126]   - Field: ‘state’
[10:18:27.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.127] - Launch lazy future ...
[10:18:27.127] Packages needed by the future expression (n = 0): <none>
[10:18:27.127] Packages needed by future strategies (n = 0): <none>
[10:18:27.128] {
[10:18:27.128]     {
[10:18:27.128]         {
[10:18:27.128]             ...future.startTime <- base::Sys.time()
[10:18:27.128]             {
[10:18:27.128]                 {
[10:18:27.128]                   {
[10:18:27.128]                     {
[10:18:27.128]                       base::local({
[10:18:27.128]                         has_future <- base::requireNamespace("future", 
[10:18:27.128]                           quietly = TRUE)
[10:18:27.128]                         if (has_future) {
[10:18:27.128]                           ns <- base::getNamespace("future")
[10:18:27.128]                           version <- ns[[".package"]][["version"]]
[10:18:27.128]                           if (is.null(version)) 
[10:18:27.128]                             version <- utils::packageVersion("future")
[10:18:27.128]                         }
[10:18:27.128]                         else {
[10:18:27.128]                           version <- NULL
[10:18:27.128]                         }
[10:18:27.128]                         if (!has_future || version < "1.8.0") {
[10:18:27.128]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.128]                             "", base::R.version$version.string), 
[10:18:27.128]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.128]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.128]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.128]                               "release", "version")], collapse = " "), 
[10:18:27.128]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.128]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.128]                             info)
[10:18:27.128]                           info <- base::paste(info, collapse = "; ")
[10:18:27.128]                           if (!has_future) {
[10:18:27.128]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.128]                               info)
[10:18:27.128]                           }
[10:18:27.128]                           else {
[10:18:27.128]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.128]                               info, version)
[10:18:27.128]                           }
[10:18:27.128]                           base::stop(msg)
[10:18:27.128]                         }
[10:18:27.128]                       })
[10:18:27.128]                     }
[10:18:27.128]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.128]                     base::options(mc.cores = 1L)
[10:18:27.128]                   }
[10:18:27.128]                   ...future.strategy.old <- future::plan("list")
[10:18:27.128]                   options(future.plan = NULL)
[10:18:27.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.128]                 }
[10:18:27.128]                 ...future.workdir <- getwd()
[10:18:27.128]             }
[10:18:27.128]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.128]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.128]         }
[10:18:27.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.128]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.128]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.128]             base::names(...future.oldOptions))
[10:18:27.128]     }
[10:18:27.128]     if (FALSE) {
[10:18:27.128]     }
[10:18:27.128]     else {
[10:18:27.128]         if (TRUE) {
[10:18:27.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.128]                 open = "w")
[10:18:27.128]         }
[10:18:27.128]         else {
[10:18:27.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.128]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.128]         }
[10:18:27.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.128]             base::sink(type = "output", split = FALSE)
[10:18:27.128]             base::close(...future.stdout)
[10:18:27.128]         }, add = TRUE)
[10:18:27.128]     }
[10:18:27.128]     ...future.frame <- base::sys.nframe()
[10:18:27.128]     ...future.conditions <- base::list()
[10:18:27.128]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.128]     if (FALSE) {
[10:18:27.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.128]     }
[10:18:27.128]     ...future.result <- base::tryCatch({
[10:18:27.128]         base::withCallingHandlers({
[10:18:27.128]             ...future.value <- base::withVisible(base::local({
[10:18:27.128]                 withCallingHandlers({
[10:18:27.128]                   {
[10:18:27.128]                     do.call(function(...) {
[10:18:27.128]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.128]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.128]                         ...future.globals.maxSize)) {
[10:18:27.128]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.128]                         on.exit(options(oopts), add = TRUE)
[10:18:27.128]                       }
[10:18:27.128]                       {
[10:18:27.128]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.128]                           FUN = function(jj) {
[10:18:27.128]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.128]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.128]                           })
[10:18:27.128]                       }
[10:18:27.128]                     }, args = future.call.arguments)
[10:18:27.128]                   }
[10:18:27.128]                 }, immediateCondition = function(cond) {
[10:18:27.128]                   save_rds <- function (object, pathname, ...) 
[10:18:27.128]                   {
[10:18:27.128]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.128]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.128]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.128]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.128]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.128]                         fi_tmp[["mtime"]])
[10:18:27.128]                     }
[10:18:27.128]                     tryCatch({
[10:18:27.128]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.128]                     }, error = function(ex) {
[10:18:27.128]                       msg <- conditionMessage(ex)
[10:18:27.128]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.128]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.128]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.128]                         fi_tmp[["mtime"]], msg)
[10:18:27.128]                       ex$message <- msg
[10:18:27.128]                       stop(ex)
[10:18:27.128]                     })
[10:18:27.128]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.128]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.128]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.128]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.128]                       fi <- file.info(pathname)
[10:18:27.128]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.128]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.128]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.128]                         fi[["size"]], fi[["mtime"]])
[10:18:27.128]                       stop(msg)
[10:18:27.128]                     }
[10:18:27.128]                     invisible(pathname)
[10:18:27.128]                   }
[10:18:27.128]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.128]                     rootPath = tempdir()) 
[10:18:27.128]                   {
[10:18:27.128]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.128]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.128]                       tmpdir = path, fileext = ".rds")
[10:18:27.128]                     save_rds(obj, file)
[10:18:27.128]                   }
[10:18:27.128]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.128]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.128]                   {
[10:18:27.128]                     inherits <- base::inherits
[10:18:27.128]                     invokeRestart <- base::invokeRestart
[10:18:27.128]                     is.null <- base::is.null
[10:18:27.128]                     muffled <- FALSE
[10:18:27.128]                     if (inherits(cond, "message")) {
[10:18:27.128]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.128]                       if (muffled) 
[10:18:27.128]                         invokeRestart("muffleMessage")
[10:18:27.128]                     }
[10:18:27.128]                     else if (inherits(cond, "warning")) {
[10:18:27.128]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.128]                       if (muffled) 
[10:18:27.128]                         invokeRestart("muffleWarning")
[10:18:27.128]                     }
[10:18:27.128]                     else if (inherits(cond, "condition")) {
[10:18:27.128]                       if (!is.null(pattern)) {
[10:18:27.128]                         computeRestarts <- base::computeRestarts
[10:18:27.128]                         grepl <- base::grepl
[10:18:27.128]                         restarts <- computeRestarts(cond)
[10:18:27.128]                         for (restart in restarts) {
[10:18:27.128]                           name <- restart$name
[10:18:27.128]                           if (is.null(name)) 
[10:18:27.128]                             next
[10:18:27.128]                           if (!grepl(pattern, name)) 
[10:18:27.128]                             next
[10:18:27.128]                           invokeRestart(restart)
[10:18:27.128]                           muffled <- TRUE
[10:18:27.128]                           break
[10:18:27.128]                         }
[10:18:27.128]                       }
[10:18:27.128]                     }
[10:18:27.128]                     invisible(muffled)
[10:18:27.128]                   }
[10:18:27.128]                   muffleCondition(cond)
[10:18:27.128]                 })
[10:18:27.128]             }))
[10:18:27.128]             future::FutureResult(value = ...future.value$value, 
[10:18:27.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.128]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.128]                     ...future.globalenv.names))
[10:18:27.128]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.128]         }, condition = base::local({
[10:18:27.128]             c <- base::c
[10:18:27.128]             inherits <- base::inherits
[10:18:27.128]             invokeRestart <- base::invokeRestart
[10:18:27.128]             length <- base::length
[10:18:27.128]             list <- base::list
[10:18:27.128]             seq.int <- base::seq.int
[10:18:27.128]             signalCondition <- base::signalCondition
[10:18:27.128]             sys.calls <- base::sys.calls
[10:18:27.128]             `[[` <- base::`[[`
[10:18:27.128]             `+` <- base::`+`
[10:18:27.128]             `<<-` <- base::`<<-`
[10:18:27.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.128]                   3L)]
[10:18:27.128]             }
[10:18:27.128]             function(cond) {
[10:18:27.128]                 is_error <- inherits(cond, "error")
[10:18:27.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.128]                   NULL)
[10:18:27.128]                 if (is_error) {
[10:18:27.128]                   sessionInformation <- function() {
[10:18:27.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.128]                       search = base::search(), system = base::Sys.info())
[10:18:27.128]                   }
[10:18:27.128]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.128]                     cond$call), session = sessionInformation(), 
[10:18:27.128]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.128]                   signalCondition(cond)
[10:18:27.128]                 }
[10:18:27.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.128]                 "immediateCondition"))) {
[10:18:27.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.128]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.128]                   if (TRUE && !signal) {
[10:18:27.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.128]                     {
[10:18:27.128]                       inherits <- base::inherits
[10:18:27.128]                       invokeRestart <- base::invokeRestart
[10:18:27.128]                       is.null <- base::is.null
[10:18:27.128]                       muffled <- FALSE
[10:18:27.128]                       if (inherits(cond, "message")) {
[10:18:27.128]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.128]                         if (muffled) 
[10:18:27.128]                           invokeRestart("muffleMessage")
[10:18:27.128]                       }
[10:18:27.128]                       else if (inherits(cond, "warning")) {
[10:18:27.128]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.128]                         if (muffled) 
[10:18:27.128]                           invokeRestart("muffleWarning")
[10:18:27.128]                       }
[10:18:27.128]                       else if (inherits(cond, "condition")) {
[10:18:27.128]                         if (!is.null(pattern)) {
[10:18:27.128]                           computeRestarts <- base::computeRestarts
[10:18:27.128]                           grepl <- base::grepl
[10:18:27.128]                           restarts <- computeRestarts(cond)
[10:18:27.128]                           for (restart in restarts) {
[10:18:27.128]                             name <- restart$name
[10:18:27.128]                             if (is.null(name)) 
[10:18:27.128]                               next
[10:18:27.128]                             if (!grepl(pattern, name)) 
[10:18:27.128]                               next
[10:18:27.128]                             invokeRestart(restart)
[10:18:27.128]                             muffled <- TRUE
[10:18:27.128]                             break
[10:18:27.128]                           }
[10:18:27.128]                         }
[10:18:27.128]                       }
[10:18:27.128]                       invisible(muffled)
[10:18:27.128]                     }
[10:18:27.128]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.128]                   }
[10:18:27.128]                 }
[10:18:27.128]                 else {
[10:18:27.128]                   if (TRUE) {
[10:18:27.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.128]                     {
[10:18:27.128]                       inherits <- base::inherits
[10:18:27.128]                       invokeRestart <- base::invokeRestart
[10:18:27.128]                       is.null <- base::is.null
[10:18:27.128]                       muffled <- FALSE
[10:18:27.128]                       if (inherits(cond, "message")) {
[10:18:27.128]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.128]                         if (muffled) 
[10:18:27.128]                           invokeRestart("muffleMessage")
[10:18:27.128]                       }
[10:18:27.128]                       else if (inherits(cond, "warning")) {
[10:18:27.128]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.128]                         if (muffled) 
[10:18:27.128]                           invokeRestart("muffleWarning")
[10:18:27.128]                       }
[10:18:27.128]                       else if (inherits(cond, "condition")) {
[10:18:27.128]                         if (!is.null(pattern)) {
[10:18:27.128]                           computeRestarts <- base::computeRestarts
[10:18:27.128]                           grepl <- base::grepl
[10:18:27.128]                           restarts <- computeRestarts(cond)
[10:18:27.128]                           for (restart in restarts) {
[10:18:27.128]                             name <- restart$name
[10:18:27.128]                             if (is.null(name)) 
[10:18:27.128]                               next
[10:18:27.128]                             if (!grepl(pattern, name)) 
[10:18:27.128]                               next
[10:18:27.128]                             invokeRestart(restart)
[10:18:27.128]                             muffled <- TRUE
[10:18:27.128]                             break
[10:18:27.128]                           }
[10:18:27.128]                         }
[10:18:27.128]                       }
[10:18:27.128]                       invisible(muffled)
[10:18:27.128]                     }
[10:18:27.128]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.128]                   }
[10:18:27.128]                 }
[10:18:27.128]             }
[10:18:27.128]         }))
[10:18:27.128]     }, error = function(ex) {
[10:18:27.128]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.128]                 ...future.rng), started = ...future.startTime, 
[10:18:27.128]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.128]             version = "1.8"), class = "FutureResult")
[10:18:27.128]     }, finally = {
[10:18:27.128]         if (!identical(...future.workdir, getwd())) 
[10:18:27.128]             setwd(...future.workdir)
[10:18:27.128]         {
[10:18:27.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.128]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.128]             }
[10:18:27.128]             base::options(...future.oldOptions)
[10:18:27.128]             if (.Platform$OS.type == "windows") {
[10:18:27.128]                 old_names <- names(...future.oldEnvVars)
[10:18:27.128]                 envs <- base::Sys.getenv()
[10:18:27.128]                 names <- names(envs)
[10:18:27.128]                 common <- intersect(names, old_names)
[10:18:27.128]                 added <- setdiff(names, old_names)
[10:18:27.128]                 removed <- setdiff(old_names, names)
[10:18:27.128]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.128]                   envs[common]]
[10:18:27.128]                 NAMES <- toupper(changed)
[10:18:27.128]                 args <- list()
[10:18:27.128]                 for (kk in seq_along(NAMES)) {
[10:18:27.128]                   name <- changed[[kk]]
[10:18:27.128]                   NAME <- NAMES[[kk]]
[10:18:27.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.128]                     next
[10:18:27.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.128]                 }
[10:18:27.128]                 NAMES <- toupper(added)
[10:18:27.128]                 for (kk in seq_along(NAMES)) {
[10:18:27.128]                   name <- added[[kk]]
[10:18:27.128]                   NAME <- NAMES[[kk]]
[10:18:27.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.128]                     next
[10:18:27.128]                   args[[name]] <- ""
[10:18:27.128]                 }
[10:18:27.128]                 NAMES <- toupper(removed)
[10:18:27.128]                 for (kk in seq_along(NAMES)) {
[10:18:27.128]                   name <- removed[[kk]]
[10:18:27.128]                   NAME <- NAMES[[kk]]
[10:18:27.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.128]                     next
[10:18:27.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.128]                 }
[10:18:27.128]                 if (length(args) > 0) 
[10:18:27.128]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.128]             }
[10:18:27.128]             else {
[10:18:27.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.128]             }
[10:18:27.128]             {
[10:18:27.128]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.128]                   0L) {
[10:18:27.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.128]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.128]                   base::options(opts)
[10:18:27.128]                 }
[10:18:27.128]                 {
[10:18:27.128]                   {
[10:18:27.128]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.128]                     NULL
[10:18:27.128]                   }
[10:18:27.128]                   options(future.plan = NULL)
[10:18:27.128]                   if (is.na(NA_character_)) 
[10:18:27.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.128]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.128]                     .init = FALSE)
[10:18:27.128]                 }
[10:18:27.128]             }
[10:18:27.128]         }
[10:18:27.128]     })
[10:18:27.128]     if (TRUE) {
[10:18:27.128]         base::sink(type = "output", split = FALSE)
[10:18:27.128]         if (TRUE) {
[10:18:27.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.128]         }
[10:18:27.128]         else {
[10:18:27.128]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.128]         }
[10:18:27.128]         base::close(...future.stdout)
[10:18:27.128]         ...future.stdout <- NULL
[10:18:27.128]     }
[10:18:27.128]     ...future.result$conditions <- ...future.conditions
[10:18:27.128]     ...future.result$finished <- base::Sys.time()
[10:18:27.128]     ...future.result
[10:18:27.128] }
[10:18:27.132] assign_globals() ...
[10:18:27.132] List of 5
[10:18:27.132]  $ future.call.arguments    : list()
[10:18:27.132]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.132]  $ ...future.FUN            :function (x)  
[10:18:27.132]  $ ...future.elements_ii    :List of 1
[10:18:27.132]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:18:27.132]  $ ...future.seeds_ii       : NULL
[10:18:27.132]  $ ...future.globals.maxSize: num Inf
[10:18:27.132]  - attr(*, "resolved")= logi FALSE
[10:18:27.132]  - attr(*, "total_size")= num NA
[10:18:27.132]  - attr(*, "where")=List of 5
[10:18:27.132]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.132]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.132]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.132]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.132]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.132]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.132]  - attr(*, "already-done")= logi TRUE
[10:18:27.139] - copied ‘future.call.arguments’ to environment
[10:18:27.139] - copied ‘...future.FUN’ to environment
[10:18:27.140] - copied ‘...future.elements_ii’ to environment
[10:18:27.140] - copied ‘...future.seeds_ii’ to environment
[10:18:27.140] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.140] assign_globals() ... done
[10:18:27.140] requestCore(): workers = 2
[10:18:27.143] MulticoreFuture started
[10:18:27.143] - Launch lazy future ... done
[10:18:27.143] run() for ‘MulticoreFuture’ ... done
[10:18:27.143] Created future:
[10:18:27.144] plan(): Setting new future strategy stack:
[10:18:27.144] List of future strategies:
[10:18:27.144] 1. sequential:
[10:18:27.144]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.144]    - tweaked: FALSE
[10:18:27.144]    - call: NULL
[10:18:27.145] plan(): nbrOfWorkers() = 1
[10:18:27.151] plan(): Setting new future strategy stack:
[10:18:27.151] List of future strategies:
[10:18:27.151] 1. multicore:
[10:18:27.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.151]    - tweaked: FALSE
[10:18:27.151]    - call: plan(strategy)
[10:18:27.156] plan(): nbrOfWorkers() = 2
[10:18:27.144] MulticoreFuture:
[10:18:27.144] Label: ‘future_apply-2’
[10:18:27.144] Expression:
[10:18:27.144] {
[10:18:27.144]     do.call(function(...) {
[10:18:27.144]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.144]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.144]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.144]             on.exit(options(oopts), add = TRUE)
[10:18:27.144]         }
[10:18:27.144]         {
[10:18:27.144]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.144]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.144]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.144]             })
[10:18:27.144]         }
[10:18:27.144]     }, args = future.call.arguments)
[10:18:27.144] }
[10:18:27.144] Lazy evaluation: FALSE
[10:18:27.144] Asynchronous evaluation: TRUE
[10:18:27.144] Local evaluation: TRUE
[10:18:27.144] Environment: R_GlobalEnv
[10:18:27.144] Capture standard output: TRUE
[10:18:27.144] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.144] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.144] Packages: <none>
[10:18:27.144] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.144] Resolved: TRUE
[10:18:27.144] Value: <not collected>
[10:18:27.144] Conditions captured: <none>
[10:18:27.144] Early signaling: FALSE
[10:18:27.144] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.144] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.158] Chunk #2 of 2 ... DONE
[10:18:27.158] Launching 2 futures (chunks) ... DONE
[10:18:27.158] Resolving 2 futures (chunks) ...
[10:18:27.159] resolve() on list ...
[10:18:27.159]  recursive: 0
[10:18:27.159]  length: 2
[10:18:27.159] 
[10:18:27.160] Future #1
[10:18:27.160] result() for MulticoreFuture ...
[10:18:27.162] result() for MulticoreFuture ...
[10:18:27.162] result() for MulticoreFuture ... done
[10:18:27.162] result() for MulticoreFuture ... done
[10:18:27.162] result() for MulticoreFuture ...
[10:18:27.163] result() for MulticoreFuture ... done
[10:18:27.163] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:27.163] - nx: 2
[10:18:27.164] - relay: TRUE
[10:18:27.164] - stdout: TRUE
[10:18:27.164] - signal: TRUE
[10:18:27.164] - resignal: FALSE
[10:18:27.165] - force: TRUE
[10:18:27.165] - relayed: [n=2] FALSE, FALSE
[10:18:27.165] - queued futures: [n=2] FALSE, FALSE
[10:18:27.165]  - until=1
[10:18:27.166]  - relaying element #1
[10:18:27.166] result() for MulticoreFuture ...
[10:18:27.166] result() for MulticoreFuture ... done
[10:18:27.166] result() for MulticoreFuture ...
[10:18:27.166] result() for MulticoreFuture ... done
[10:18:27.166] result() for MulticoreFuture ...
[10:18:27.167] result() for MulticoreFuture ... done
[10:18:27.167] result() for MulticoreFuture ...
[10:18:27.167] result() for MulticoreFuture ... done
[10:18:27.167] - relayed: [n=2] TRUE, FALSE
[10:18:27.167] - queued futures: [n=2] TRUE, FALSE
[10:18:27.167] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:27.167]  length: 1 (resolved future 1)
[10:18:27.168] Future #2
[10:18:27.168] result() for MulticoreFuture ...
[10:18:27.169] result() for MulticoreFuture ...
[10:18:27.169] result() for MulticoreFuture ... done
[10:18:27.169] result() for MulticoreFuture ... done
[10:18:27.169] result() for MulticoreFuture ...
[10:18:27.169] result() for MulticoreFuture ... done
[10:18:27.169] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:27.170] - nx: 2
[10:18:27.170] - relay: TRUE
[10:18:27.170] - stdout: TRUE
[10:18:27.170] - signal: TRUE
[10:18:27.170] - resignal: FALSE
[10:18:27.170] - force: TRUE
[10:18:27.170] - relayed: [n=2] TRUE, FALSE
[10:18:27.170] - queued futures: [n=2] TRUE, FALSE
[10:18:27.170]  - until=2
[10:18:27.171]  - relaying element #2
[10:18:27.171] result() for MulticoreFuture ...
[10:18:27.171] result() for MulticoreFuture ... done
[10:18:27.171] result() for MulticoreFuture ...
[10:18:27.171] result() for MulticoreFuture ... done
[10:18:27.171] result() for MulticoreFuture ...
[10:18:27.171] result() for MulticoreFuture ... done
[10:18:27.171] result() for MulticoreFuture ...
[10:18:27.172] result() for MulticoreFuture ... done
[10:18:27.172] - relayed: [n=2] TRUE, TRUE
[10:18:27.172] - queued futures: [n=2] TRUE, TRUE
[10:18:27.172] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:27.172]  length: 0 (resolved future 2)
[10:18:27.172] Relaying remaining futures
[10:18:27.172] signalConditionsASAP(NULL, pos=0) ...
[10:18:27.172] - nx: 2
[10:18:27.172] - relay: TRUE
[10:18:27.172] - stdout: TRUE
[10:18:27.173] - signal: TRUE
[10:18:27.173] - resignal: FALSE
[10:18:27.173] - force: TRUE
[10:18:27.173] - relayed: [n=2] TRUE, TRUE
[10:18:27.173] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:27.173] - relayed: [n=2] TRUE, TRUE
[10:18:27.173] - queued futures: [n=2] TRUE, TRUE
[10:18:27.173] signalConditionsASAP(NULL, pos=0) ... done
[10:18:27.173] resolve() on list ... DONE
[10:18:27.174] result() for MulticoreFuture ...
[10:18:27.174] result() for MulticoreFuture ... done
[10:18:27.174] result() for MulticoreFuture ...
[10:18:27.174] result() for MulticoreFuture ... done
[10:18:27.174] result() for MulticoreFuture ...
[10:18:27.174] result() for MulticoreFuture ... done
[10:18:27.174] result() for MulticoreFuture ...
[10:18:27.174] result() for MulticoreFuture ... done
[10:18:27.174]  - Number of value chunks collected: 2
[10:18:27.175] Resolving 2 futures (chunks) ... DONE
[10:18:27.175] Reducing values from 2 chunks ...
[10:18:27.175]  - Number of values collected after concatenation: 2
[10:18:27.175]  - Number of values expected: 2
[10:18:27.175] Reducing values from 2 chunks ... DONE
[10:18:27.175] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:18:27.175] getGlobalsAndPackagesXApply() ...
[10:18:27.176]  - future.globals: TRUE
[10:18:27.176] getGlobalsAndPackages() ...
[10:18:27.176] Searching for globals...
[10:18:27.177] - globals found: [1] ‘FUN’
[10:18:27.177] Searching for globals ... DONE
[10:18:27.177] Resolving globals: FALSE
[10:18:27.178] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:27.178] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:27.178] - globals: [1] ‘FUN’
[10:18:27.179] 
[10:18:27.179] getGlobalsAndPackages() ... DONE
[10:18:27.179]  - globals found/used: [n=1] ‘FUN’
[10:18:27.179]  - needed namespaces: [n=0] 
[10:18:27.179] Finding globals ... DONE
[10:18:27.179]  - use_args: TRUE
[10:18:27.179]  - Getting '...' globals ...
[10:18:27.180] resolve() on list ...
[10:18:27.180]  recursive: 0
[10:18:27.180]  length: 1
[10:18:27.180]  elements: ‘...’
[10:18:27.180]  length: 0 (resolved future 1)
[10:18:27.180] resolve() on list ... DONE
[10:18:27.180]    - '...' content: [n=0] 
[10:18:27.180] List of 1
[10:18:27.180]  $ ...: list()
[10:18:27.180]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.180]  - attr(*, "where")=List of 1
[10:18:27.180]   ..$ ...:<environment: 0x556e030c2a40> 
[10:18:27.180]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.180]  - attr(*, "resolved")= logi TRUE
[10:18:27.180]  - attr(*, "total_size")= num NA
[10:18:27.183]  - Getting '...' globals ... DONE
[10:18:27.183] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:27.183] List of 2
[10:18:27.183]  $ ...future.FUN:function (x)  
[10:18:27.183]  $ ...          : list()
[10:18:27.183]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.183]  - attr(*, "where")=List of 2
[10:18:27.183]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:27.183]   ..$ ...          :<environment: 0x556e030c2a40> 
[10:18:27.183]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.183]  - attr(*, "resolved")= logi FALSE
[10:18:27.183]  - attr(*, "total_size")= num 3563
[10:18:27.186] Packages to be attached in all futures: [n=0] 
[10:18:27.186] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.190] future_lapply() ...
[10:18:27.192] Number of chunks: 2
[10:18:27.192] getGlobalsAndPackagesXApply() ...
[10:18:27.193]  - future.globals: <name-value list> with names ‘list()’
[10:18:27.193]  - use_args: TRUE
[10:18:27.193] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:27.193] List of 2
[10:18:27.193]  $ ...          : list()
[10:18:27.193]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.193]  $ ...future.FUN:function (x)  
[10:18:27.193]  - attr(*, "where")=List of 2
[10:18:27.193]   ..$ ...          :<environment: 0x556e030c2a40> 
[10:18:27.193]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:27.193]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.193]  - attr(*, "resolved")= logi FALSE
[10:18:27.193]  - attr(*, "total_size")= num NA
[10:18:27.197] Packages to be attached in all futures: [n=0] 
[10:18:27.197] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.197] Number of futures (= number of chunks): 2
[10:18:27.197] Launching 2 futures (chunks) ...
[10:18:27.197] Chunk #1 of 2 ...
[10:18:27.197]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.197]  - seeds: <none>
[10:18:27.197]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.198] getGlobalsAndPackages() ...
[10:18:27.198] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.198] Resolving globals: FALSE
[10:18:27.198] Tweak future expression to call with '...' arguments ...
[10:18:27.198] {
[10:18:27.198]     do.call(function(...) {
[10:18:27.198]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.198]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.198]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.198]             on.exit(options(oopts), add = TRUE)
[10:18:27.198]         }
[10:18:27.198]         {
[10:18:27.198]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.198]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.198]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.198]             })
[10:18:27.198]         }
[10:18:27.198]     }, args = future.call.arguments)
[10:18:27.198] }
[10:18:27.198] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.199] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.199] 
[10:18:27.199] getGlobalsAndPackages() ... DONE
[10:18:27.199] run() for ‘Future’ ...
[10:18:27.199] - state: ‘created’
[10:18:27.199] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.201] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.201] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.201]   - Field: ‘label’
[10:18:27.201]   - Field: ‘local’
[10:18:27.201]   - Field: ‘owner’
[10:18:27.202]   - Field: ‘envir’
[10:18:27.202]   - Field: ‘workers’
[10:18:27.202]   - Field: ‘packages’
[10:18:27.202]   - Field: ‘gc’
[10:18:27.202]   - Field: ‘job’
[10:18:27.202]   - Field: ‘conditions’
[10:18:27.202]   - Field: ‘expr’
[10:18:27.202]   - Field: ‘uuid’
[10:18:27.202]   - Field: ‘seed’
[10:18:27.202]   - Field: ‘version’
[10:18:27.202]   - Field: ‘result’
[10:18:27.203]   - Field: ‘asynchronous’
[10:18:27.203]   - Field: ‘calls’
[10:18:27.203]   - Field: ‘globals’
[10:18:27.203]   - Field: ‘stdout’
[10:18:27.203]   - Field: ‘earlySignal’
[10:18:27.203]   - Field: ‘lazy’
[10:18:27.203]   - Field: ‘state’
[10:18:27.203] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.203] - Launch lazy future ...
[10:18:27.204] Packages needed by the future expression (n = 0): <none>
[10:18:27.204] Packages needed by future strategies (n = 0): <none>
[10:18:27.204] {
[10:18:27.204]     {
[10:18:27.204]         {
[10:18:27.204]             ...future.startTime <- base::Sys.time()
[10:18:27.204]             {
[10:18:27.204]                 {
[10:18:27.204]                   {
[10:18:27.204]                     {
[10:18:27.204]                       base::local({
[10:18:27.204]                         has_future <- base::requireNamespace("future", 
[10:18:27.204]                           quietly = TRUE)
[10:18:27.204]                         if (has_future) {
[10:18:27.204]                           ns <- base::getNamespace("future")
[10:18:27.204]                           version <- ns[[".package"]][["version"]]
[10:18:27.204]                           if (is.null(version)) 
[10:18:27.204]                             version <- utils::packageVersion("future")
[10:18:27.204]                         }
[10:18:27.204]                         else {
[10:18:27.204]                           version <- NULL
[10:18:27.204]                         }
[10:18:27.204]                         if (!has_future || version < "1.8.0") {
[10:18:27.204]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.204]                             "", base::R.version$version.string), 
[10:18:27.204]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.204]                               "release", "version")], collapse = " "), 
[10:18:27.204]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.204]                             info)
[10:18:27.204]                           info <- base::paste(info, collapse = "; ")
[10:18:27.204]                           if (!has_future) {
[10:18:27.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.204]                               info)
[10:18:27.204]                           }
[10:18:27.204]                           else {
[10:18:27.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.204]                               info, version)
[10:18:27.204]                           }
[10:18:27.204]                           base::stop(msg)
[10:18:27.204]                         }
[10:18:27.204]                       })
[10:18:27.204]                     }
[10:18:27.204]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.204]                     base::options(mc.cores = 1L)
[10:18:27.204]                   }
[10:18:27.204]                   ...future.strategy.old <- future::plan("list")
[10:18:27.204]                   options(future.plan = NULL)
[10:18:27.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.204]                 }
[10:18:27.204]                 ...future.workdir <- getwd()
[10:18:27.204]             }
[10:18:27.204]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.204]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.204]         }
[10:18:27.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.204]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.204]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.204]             base::names(...future.oldOptions))
[10:18:27.204]     }
[10:18:27.204]     if (FALSE) {
[10:18:27.204]     }
[10:18:27.204]     else {
[10:18:27.204]         if (TRUE) {
[10:18:27.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.204]                 open = "w")
[10:18:27.204]         }
[10:18:27.204]         else {
[10:18:27.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.204]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.204]         }
[10:18:27.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.204]             base::sink(type = "output", split = FALSE)
[10:18:27.204]             base::close(...future.stdout)
[10:18:27.204]         }, add = TRUE)
[10:18:27.204]     }
[10:18:27.204]     ...future.frame <- base::sys.nframe()
[10:18:27.204]     ...future.conditions <- base::list()
[10:18:27.204]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.204]     if (FALSE) {
[10:18:27.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.204]     }
[10:18:27.204]     ...future.result <- base::tryCatch({
[10:18:27.204]         base::withCallingHandlers({
[10:18:27.204]             ...future.value <- base::withVisible(base::local({
[10:18:27.204]                 withCallingHandlers({
[10:18:27.204]                   {
[10:18:27.204]                     do.call(function(...) {
[10:18:27.204]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.204]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.204]                         ...future.globals.maxSize)) {
[10:18:27.204]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.204]                         on.exit(options(oopts), add = TRUE)
[10:18:27.204]                       }
[10:18:27.204]                       {
[10:18:27.204]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.204]                           FUN = function(jj) {
[10:18:27.204]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.204]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.204]                           })
[10:18:27.204]                       }
[10:18:27.204]                     }, args = future.call.arguments)
[10:18:27.204]                   }
[10:18:27.204]                 }, immediateCondition = function(cond) {
[10:18:27.204]                   save_rds <- function (object, pathname, ...) 
[10:18:27.204]                   {
[10:18:27.204]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.204]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.204]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.204]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.204]                         fi_tmp[["mtime"]])
[10:18:27.204]                     }
[10:18:27.204]                     tryCatch({
[10:18:27.204]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.204]                     }, error = function(ex) {
[10:18:27.204]                       msg <- conditionMessage(ex)
[10:18:27.204]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.204]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.204]                         fi_tmp[["mtime"]], msg)
[10:18:27.204]                       ex$message <- msg
[10:18:27.204]                       stop(ex)
[10:18:27.204]                     })
[10:18:27.204]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.204]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.204]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.204]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.204]                       fi <- file.info(pathname)
[10:18:27.204]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.204]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.204]                         fi[["size"]], fi[["mtime"]])
[10:18:27.204]                       stop(msg)
[10:18:27.204]                     }
[10:18:27.204]                     invisible(pathname)
[10:18:27.204]                   }
[10:18:27.204]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.204]                     rootPath = tempdir()) 
[10:18:27.204]                   {
[10:18:27.204]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.204]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.204]                       tmpdir = path, fileext = ".rds")
[10:18:27.204]                     save_rds(obj, file)
[10:18:27.204]                   }
[10:18:27.204]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.204]                   {
[10:18:27.204]                     inherits <- base::inherits
[10:18:27.204]                     invokeRestart <- base::invokeRestart
[10:18:27.204]                     is.null <- base::is.null
[10:18:27.204]                     muffled <- FALSE
[10:18:27.204]                     if (inherits(cond, "message")) {
[10:18:27.204]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.204]                       if (muffled) 
[10:18:27.204]                         invokeRestart("muffleMessage")
[10:18:27.204]                     }
[10:18:27.204]                     else if (inherits(cond, "warning")) {
[10:18:27.204]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.204]                       if (muffled) 
[10:18:27.204]                         invokeRestart("muffleWarning")
[10:18:27.204]                     }
[10:18:27.204]                     else if (inherits(cond, "condition")) {
[10:18:27.204]                       if (!is.null(pattern)) {
[10:18:27.204]                         computeRestarts <- base::computeRestarts
[10:18:27.204]                         grepl <- base::grepl
[10:18:27.204]                         restarts <- computeRestarts(cond)
[10:18:27.204]                         for (restart in restarts) {
[10:18:27.204]                           name <- restart$name
[10:18:27.204]                           if (is.null(name)) 
[10:18:27.204]                             next
[10:18:27.204]                           if (!grepl(pattern, name)) 
[10:18:27.204]                             next
[10:18:27.204]                           invokeRestart(restart)
[10:18:27.204]                           muffled <- TRUE
[10:18:27.204]                           break
[10:18:27.204]                         }
[10:18:27.204]                       }
[10:18:27.204]                     }
[10:18:27.204]                     invisible(muffled)
[10:18:27.204]                   }
[10:18:27.204]                   muffleCondition(cond)
[10:18:27.204]                 })
[10:18:27.204]             }))
[10:18:27.204]             future::FutureResult(value = ...future.value$value, 
[10:18:27.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.204]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.204]                     ...future.globalenv.names))
[10:18:27.204]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.204]         }, condition = base::local({
[10:18:27.204]             c <- base::c
[10:18:27.204]             inherits <- base::inherits
[10:18:27.204]             invokeRestart <- base::invokeRestart
[10:18:27.204]             length <- base::length
[10:18:27.204]             list <- base::list
[10:18:27.204]             seq.int <- base::seq.int
[10:18:27.204]             signalCondition <- base::signalCondition
[10:18:27.204]             sys.calls <- base::sys.calls
[10:18:27.204]             `[[` <- base::`[[`
[10:18:27.204]             `+` <- base::`+`
[10:18:27.204]             `<<-` <- base::`<<-`
[10:18:27.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.204]                   3L)]
[10:18:27.204]             }
[10:18:27.204]             function(cond) {
[10:18:27.204]                 is_error <- inherits(cond, "error")
[10:18:27.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.204]                   NULL)
[10:18:27.204]                 if (is_error) {
[10:18:27.204]                   sessionInformation <- function() {
[10:18:27.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.204]                       search = base::search(), system = base::Sys.info())
[10:18:27.204]                   }
[10:18:27.204]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.204]                     cond$call), session = sessionInformation(), 
[10:18:27.204]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.204]                   signalCondition(cond)
[10:18:27.204]                 }
[10:18:27.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.204]                 "immediateCondition"))) {
[10:18:27.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.204]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.204]                   if (TRUE && !signal) {
[10:18:27.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.204]                     {
[10:18:27.204]                       inherits <- base::inherits
[10:18:27.204]                       invokeRestart <- base::invokeRestart
[10:18:27.204]                       is.null <- base::is.null
[10:18:27.204]                       muffled <- FALSE
[10:18:27.204]                       if (inherits(cond, "message")) {
[10:18:27.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.204]                         if (muffled) 
[10:18:27.204]                           invokeRestart("muffleMessage")
[10:18:27.204]                       }
[10:18:27.204]                       else if (inherits(cond, "warning")) {
[10:18:27.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.204]                         if (muffled) 
[10:18:27.204]                           invokeRestart("muffleWarning")
[10:18:27.204]                       }
[10:18:27.204]                       else if (inherits(cond, "condition")) {
[10:18:27.204]                         if (!is.null(pattern)) {
[10:18:27.204]                           computeRestarts <- base::computeRestarts
[10:18:27.204]                           grepl <- base::grepl
[10:18:27.204]                           restarts <- computeRestarts(cond)
[10:18:27.204]                           for (restart in restarts) {
[10:18:27.204]                             name <- restart$name
[10:18:27.204]                             if (is.null(name)) 
[10:18:27.204]                               next
[10:18:27.204]                             if (!grepl(pattern, name)) 
[10:18:27.204]                               next
[10:18:27.204]                             invokeRestart(restart)
[10:18:27.204]                             muffled <- TRUE
[10:18:27.204]                             break
[10:18:27.204]                           }
[10:18:27.204]                         }
[10:18:27.204]                       }
[10:18:27.204]                       invisible(muffled)
[10:18:27.204]                     }
[10:18:27.204]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.204]                   }
[10:18:27.204]                 }
[10:18:27.204]                 else {
[10:18:27.204]                   if (TRUE) {
[10:18:27.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.204]                     {
[10:18:27.204]                       inherits <- base::inherits
[10:18:27.204]                       invokeRestart <- base::invokeRestart
[10:18:27.204]                       is.null <- base::is.null
[10:18:27.204]                       muffled <- FALSE
[10:18:27.204]                       if (inherits(cond, "message")) {
[10:18:27.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.204]                         if (muffled) 
[10:18:27.204]                           invokeRestart("muffleMessage")
[10:18:27.204]                       }
[10:18:27.204]                       else if (inherits(cond, "warning")) {
[10:18:27.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.204]                         if (muffled) 
[10:18:27.204]                           invokeRestart("muffleWarning")
[10:18:27.204]                       }
[10:18:27.204]                       else if (inherits(cond, "condition")) {
[10:18:27.204]                         if (!is.null(pattern)) {
[10:18:27.204]                           computeRestarts <- base::computeRestarts
[10:18:27.204]                           grepl <- base::grepl
[10:18:27.204]                           restarts <- computeRestarts(cond)
[10:18:27.204]                           for (restart in restarts) {
[10:18:27.204]                             name <- restart$name
[10:18:27.204]                             if (is.null(name)) 
[10:18:27.204]                               next
[10:18:27.204]                             if (!grepl(pattern, name)) 
[10:18:27.204]                               next
[10:18:27.204]                             invokeRestart(restart)
[10:18:27.204]                             muffled <- TRUE
[10:18:27.204]                             break
[10:18:27.204]                           }
[10:18:27.204]                         }
[10:18:27.204]                       }
[10:18:27.204]                       invisible(muffled)
[10:18:27.204]                     }
[10:18:27.204]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.204]                   }
[10:18:27.204]                 }
[10:18:27.204]             }
[10:18:27.204]         }))
[10:18:27.204]     }, error = function(ex) {
[10:18:27.204]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.204]                 ...future.rng), started = ...future.startTime, 
[10:18:27.204]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.204]             version = "1.8"), class = "FutureResult")
[10:18:27.204]     }, finally = {
[10:18:27.204]         if (!identical(...future.workdir, getwd())) 
[10:18:27.204]             setwd(...future.workdir)
[10:18:27.204]         {
[10:18:27.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.204]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.204]             }
[10:18:27.204]             base::options(...future.oldOptions)
[10:18:27.204]             if (.Platform$OS.type == "windows") {
[10:18:27.204]                 old_names <- names(...future.oldEnvVars)
[10:18:27.204]                 envs <- base::Sys.getenv()
[10:18:27.204]                 names <- names(envs)
[10:18:27.204]                 common <- intersect(names, old_names)
[10:18:27.204]                 added <- setdiff(names, old_names)
[10:18:27.204]                 removed <- setdiff(old_names, names)
[10:18:27.204]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.204]                   envs[common]]
[10:18:27.204]                 NAMES <- toupper(changed)
[10:18:27.204]                 args <- list()
[10:18:27.204]                 for (kk in seq_along(NAMES)) {
[10:18:27.204]                   name <- changed[[kk]]
[10:18:27.204]                   NAME <- NAMES[[kk]]
[10:18:27.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.204]                     next
[10:18:27.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.204]                 }
[10:18:27.204]                 NAMES <- toupper(added)
[10:18:27.204]                 for (kk in seq_along(NAMES)) {
[10:18:27.204]                   name <- added[[kk]]
[10:18:27.204]                   NAME <- NAMES[[kk]]
[10:18:27.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.204]                     next
[10:18:27.204]                   args[[name]] <- ""
[10:18:27.204]                 }
[10:18:27.204]                 NAMES <- toupper(removed)
[10:18:27.204]                 for (kk in seq_along(NAMES)) {
[10:18:27.204]                   name <- removed[[kk]]
[10:18:27.204]                   NAME <- NAMES[[kk]]
[10:18:27.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.204]                     next
[10:18:27.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.204]                 }
[10:18:27.204]                 if (length(args) > 0) 
[10:18:27.204]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.204]             }
[10:18:27.204]             else {
[10:18:27.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.204]             }
[10:18:27.204]             {
[10:18:27.204]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.204]                   0L) {
[10:18:27.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.204]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.204]                   base::options(opts)
[10:18:27.204]                 }
[10:18:27.204]                 {
[10:18:27.204]                   {
[10:18:27.204]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.204]                     NULL
[10:18:27.204]                   }
[10:18:27.204]                   options(future.plan = NULL)
[10:18:27.204]                   if (is.na(NA_character_)) 
[10:18:27.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.204]                     .init = FALSE)
[10:18:27.204]                 }
[10:18:27.204]             }
[10:18:27.204]         }
[10:18:27.204]     })
[10:18:27.204]     if (TRUE) {
[10:18:27.204]         base::sink(type = "output", split = FALSE)
[10:18:27.204]         if (TRUE) {
[10:18:27.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.204]         }
[10:18:27.204]         else {
[10:18:27.204]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.204]         }
[10:18:27.204]         base::close(...future.stdout)
[10:18:27.204]         ...future.stdout <- NULL
[10:18:27.204]     }
[10:18:27.204]     ...future.result$conditions <- ...future.conditions
[10:18:27.204]     ...future.result$finished <- base::Sys.time()
[10:18:27.204]     ...future.result
[10:18:27.204] }
[10:18:27.207] assign_globals() ...
[10:18:27.207] List of 5
[10:18:27.207]  $ future.call.arguments    : list()
[10:18:27.207]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.207]  $ ...future.FUN            :function (x)  
[10:18:27.207]  $ ...future.elements_ii    :List of 3
[10:18:27.207]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:18:27.207]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:18:27.207]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:18:27.207]  $ ...future.seeds_ii       : NULL
[10:18:27.207]  $ ...future.globals.maxSize: num Inf
[10:18:27.207]  - attr(*, "resolved")= logi FALSE
[10:18:27.207]  - attr(*, "total_size")= num NA
[10:18:27.207]  - attr(*, "where")=List of 5
[10:18:27.207]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.207]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.207]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.207]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.207]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.207]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.207]  - attr(*, "already-done")= logi TRUE
[10:18:27.212] - copied ‘future.call.arguments’ to environment
[10:18:27.212] - copied ‘...future.FUN’ to environment
[10:18:27.212] - copied ‘...future.elements_ii’ to environment
[10:18:27.212] - copied ‘...future.seeds_ii’ to environment
[10:18:27.212] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.212] assign_globals() ... done
[10:18:27.213] requestCore(): workers = 2
[10:18:27.215] MulticoreFuture started
[10:18:27.216] - Launch lazy future ... done
[10:18:27.216] run() for ‘MulticoreFuture’ ... done
[10:18:27.216] plan(): Setting new future strategy stack:
[10:18:27.216] Created future:
[10:18:27.216] List of future strategies:
[10:18:27.216] 1. sequential:
[10:18:27.216]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.216]    - tweaked: FALSE
[10:18:27.216]    - call: NULL
[10:18:27.217] plan(): nbrOfWorkers() = 1
[10:18:27.219] plan(): Setting new future strategy stack:
[10:18:27.220] List of future strategies:
[10:18:27.220] 1. multicore:
[10:18:27.220]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.220]    - tweaked: FALSE
[10:18:27.220]    - call: plan(strategy)
[10:18:27.228] plan(): nbrOfWorkers() = 2
[10:18:27.216] MulticoreFuture:
[10:18:27.216] Label: ‘future_apply-1’
[10:18:27.216] Expression:
[10:18:27.216] {
[10:18:27.216]     do.call(function(...) {
[10:18:27.216]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.216]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.216]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.216]             on.exit(options(oopts), add = TRUE)
[10:18:27.216]         }
[10:18:27.216]         {
[10:18:27.216]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.216]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.216]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.216]             })
[10:18:27.216]         }
[10:18:27.216]     }, args = future.call.arguments)
[10:18:27.216] }
[10:18:27.216] Lazy evaluation: FALSE
[10:18:27.216] Asynchronous evaluation: TRUE
[10:18:27.216] Local evaluation: TRUE
[10:18:27.216] Environment: R_GlobalEnv
[10:18:27.216] Capture standard output: TRUE
[10:18:27.216] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.216] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.216] Packages: <none>
[10:18:27.216] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.216] Resolved: FALSE
[10:18:27.216] Value: <not collected>
[10:18:27.216] Conditions captured: <none>
[10:18:27.216] Early signaling: FALSE
[10:18:27.216] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.216] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.229] Chunk #1 of 2 ... DONE
[10:18:27.229] Chunk #2 of 2 ...
[10:18:27.230]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.230]  - seeds: <none>
[10:18:27.232]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.233] getGlobalsAndPackages() ...
[10:18:27.233] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.233] Resolving globals: FALSE
[10:18:27.234] Tweak future expression to call with '...' arguments ...
[10:18:27.234] {
[10:18:27.234]     do.call(function(...) {
[10:18:27.234]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.234]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.234]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.234]             on.exit(options(oopts), add = TRUE)
[10:18:27.234]         }
[10:18:27.234]         {
[10:18:27.234]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.234]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.234]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.234]             })
[10:18:27.234]         }
[10:18:27.234]     }, args = future.call.arguments)
[10:18:27.234] }
[10:18:27.235] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.236] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.236] 
[10:18:27.236] getGlobalsAndPackages() ... DONE
[10:18:27.237] run() for ‘Future’ ...
[10:18:27.238] - state: ‘created’
[10:18:27.238] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.243] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.243] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.244]   - Field: ‘label’
[10:18:27.244]   - Field: ‘local’
[10:18:27.244]   - Field: ‘owner’
[10:18:27.244]   - Field: ‘envir’
[10:18:27.244]   - Field: ‘workers’
[10:18:27.245]   - Field: ‘packages’
[10:18:27.245]   - Field: ‘gc’
[10:18:27.245]   - Field: ‘job’
[10:18:27.245]   - Field: ‘conditions’
[10:18:27.245]   - Field: ‘expr’
[10:18:27.245]   - Field: ‘uuid’
[10:18:27.246]   - Field: ‘seed’
[10:18:27.246]   - Field: ‘version’
[10:18:27.246]   - Field: ‘result’
[10:18:27.246]   - Field: ‘asynchronous’
[10:18:27.246]   - Field: ‘calls’
[10:18:27.247]   - Field: ‘globals’
[10:18:27.247]   - Field: ‘stdout’
[10:18:27.247]   - Field: ‘earlySignal’
[10:18:27.247]   - Field: ‘lazy’
[10:18:27.247]   - Field: ‘state’
[10:18:27.247] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.247] - Launch lazy future ...
[10:18:27.248] Packages needed by the future expression (n = 0): <none>
[10:18:27.248] Packages needed by future strategies (n = 0): <none>
[10:18:27.249] {
[10:18:27.249]     {
[10:18:27.249]         {
[10:18:27.249]             ...future.startTime <- base::Sys.time()
[10:18:27.249]             {
[10:18:27.249]                 {
[10:18:27.249]                   {
[10:18:27.249]                     {
[10:18:27.249]                       base::local({
[10:18:27.249]                         has_future <- base::requireNamespace("future", 
[10:18:27.249]                           quietly = TRUE)
[10:18:27.249]                         if (has_future) {
[10:18:27.249]                           ns <- base::getNamespace("future")
[10:18:27.249]                           version <- ns[[".package"]][["version"]]
[10:18:27.249]                           if (is.null(version)) 
[10:18:27.249]                             version <- utils::packageVersion("future")
[10:18:27.249]                         }
[10:18:27.249]                         else {
[10:18:27.249]                           version <- NULL
[10:18:27.249]                         }
[10:18:27.249]                         if (!has_future || version < "1.8.0") {
[10:18:27.249]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.249]                             "", base::R.version$version.string), 
[10:18:27.249]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.249]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.249]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.249]                               "release", "version")], collapse = " "), 
[10:18:27.249]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.249]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.249]                             info)
[10:18:27.249]                           info <- base::paste(info, collapse = "; ")
[10:18:27.249]                           if (!has_future) {
[10:18:27.249]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.249]                               info)
[10:18:27.249]                           }
[10:18:27.249]                           else {
[10:18:27.249]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.249]                               info, version)
[10:18:27.249]                           }
[10:18:27.249]                           base::stop(msg)
[10:18:27.249]                         }
[10:18:27.249]                       })
[10:18:27.249]                     }
[10:18:27.249]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.249]                     base::options(mc.cores = 1L)
[10:18:27.249]                   }
[10:18:27.249]                   ...future.strategy.old <- future::plan("list")
[10:18:27.249]                   options(future.plan = NULL)
[10:18:27.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.249]                 }
[10:18:27.249]                 ...future.workdir <- getwd()
[10:18:27.249]             }
[10:18:27.249]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.249]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.249]         }
[10:18:27.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.249]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.249]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.249]             base::names(...future.oldOptions))
[10:18:27.249]     }
[10:18:27.249]     if (FALSE) {
[10:18:27.249]     }
[10:18:27.249]     else {
[10:18:27.249]         if (TRUE) {
[10:18:27.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.249]                 open = "w")
[10:18:27.249]         }
[10:18:27.249]         else {
[10:18:27.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.249]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.249]         }
[10:18:27.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.249]             base::sink(type = "output", split = FALSE)
[10:18:27.249]             base::close(...future.stdout)
[10:18:27.249]         }, add = TRUE)
[10:18:27.249]     }
[10:18:27.249]     ...future.frame <- base::sys.nframe()
[10:18:27.249]     ...future.conditions <- base::list()
[10:18:27.249]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.249]     if (FALSE) {
[10:18:27.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.249]     }
[10:18:27.249]     ...future.result <- base::tryCatch({
[10:18:27.249]         base::withCallingHandlers({
[10:18:27.249]             ...future.value <- base::withVisible(base::local({
[10:18:27.249]                 withCallingHandlers({
[10:18:27.249]                   {
[10:18:27.249]                     do.call(function(...) {
[10:18:27.249]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.249]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.249]                         ...future.globals.maxSize)) {
[10:18:27.249]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.249]                         on.exit(options(oopts), add = TRUE)
[10:18:27.249]                       }
[10:18:27.249]                       {
[10:18:27.249]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.249]                           FUN = function(jj) {
[10:18:27.249]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.249]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.249]                           })
[10:18:27.249]                       }
[10:18:27.249]                     }, args = future.call.arguments)
[10:18:27.249]                   }
[10:18:27.249]                 }, immediateCondition = function(cond) {
[10:18:27.249]                   save_rds <- function (object, pathname, ...) 
[10:18:27.249]                   {
[10:18:27.249]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.249]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.249]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.249]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.249]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.249]                         fi_tmp[["mtime"]])
[10:18:27.249]                     }
[10:18:27.249]                     tryCatch({
[10:18:27.249]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.249]                     }, error = function(ex) {
[10:18:27.249]                       msg <- conditionMessage(ex)
[10:18:27.249]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.249]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.249]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.249]                         fi_tmp[["mtime"]], msg)
[10:18:27.249]                       ex$message <- msg
[10:18:27.249]                       stop(ex)
[10:18:27.249]                     })
[10:18:27.249]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.249]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.249]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.249]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.249]                       fi <- file.info(pathname)
[10:18:27.249]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.249]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.249]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.249]                         fi[["size"]], fi[["mtime"]])
[10:18:27.249]                       stop(msg)
[10:18:27.249]                     }
[10:18:27.249]                     invisible(pathname)
[10:18:27.249]                   }
[10:18:27.249]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.249]                     rootPath = tempdir()) 
[10:18:27.249]                   {
[10:18:27.249]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.249]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.249]                       tmpdir = path, fileext = ".rds")
[10:18:27.249]                     save_rds(obj, file)
[10:18:27.249]                   }
[10:18:27.249]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.249]                   {
[10:18:27.249]                     inherits <- base::inherits
[10:18:27.249]                     invokeRestart <- base::invokeRestart
[10:18:27.249]                     is.null <- base::is.null
[10:18:27.249]                     muffled <- FALSE
[10:18:27.249]                     if (inherits(cond, "message")) {
[10:18:27.249]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.249]                       if (muffled) 
[10:18:27.249]                         invokeRestart("muffleMessage")
[10:18:27.249]                     }
[10:18:27.249]                     else if (inherits(cond, "warning")) {
[10:18:27.249]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.249]                       if (muffled) 
[10:18:27.249]                         invokeRestart("muffleWarning")
[10:18:27.249]                     }
[10:18:27.249]                     else if (inherits(cond, "condition")) {
[10:18:27.249]                       if (!is.null(pattern)) {
[10:18:27.249]                         computeRestarts <- base::computeRestarts
[10:18:27.249]                         grepl <- base::grepl
[10:18:27.249]                         restarts <- computeRestarts(cond)
[10:18:27.249]                         for (restart in restarts) {
[10:18:27.249]                           name <- restart$name
[10:18:27.249]                           if (is.null(name)) 
[10:18:27.249]                             next
[10:18:27.249]                           if (!grepl(pattern, name)) 
[10:18:27.249]                             next
[10:18:27.249]                           invokeRestart(restart)
[10:18:27.249]                           muffled <- TRUE
[10:18:27.249]                           break
[10:18:27.249]                         }
[10:18:27.249]                       }
[10:18:27.249]                     }
[10:18:27.249]                     invisible(muffled)
[10:18:27.249]                   }
[10:18:27.249]                   muffleCondition(cond)
[10:18:27.249]                 })
[10:18:27.249]             }))
[10:18:27.249]             future::FutureResult(value = ...future.value$value, 
[10:18:27.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.249]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.249]                     ...future.globalenv.names))
[10:18:27.249]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.249]         }, condition = base::local({
[10:18:27.249]             c <- base::c
[10:18:27.249]             inherits <- base::inherits
[10:18:27.249]             invokeRestart <- base::invokeRestart
[10:18:27.249]             length <- base::length
[10:18:27.249]             list <- base::list
[10:18:27.249]             seq.int <- base::seq.int
[10:18:27.249]             signalCondition <- base::signalCondition
[10:18:27.249]             sys.calls <- base::sys.calls
[10:18:27.249]             `[[` <- base::`[[`
[10:18:27.249]             `+` <- base::`+`
[10:18:27.249]             `<<-` <- base::`<<-`
[10:18:27.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.249]                   3L)]
[10:18:27.249]             }
[10:18:27.249]             function(cond) {
[10:18:27.249]                 is_error <- inherits(cond, "error")
[10:18:27.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.249]                   NULL)
[10:18:27.249]                 if (is_error) {
[10:18:27.249]                   sessionInformation <- function() {
[10:18:27.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.249]                       search = base::search(), system = base::Sys.info())
[10:18:27.249]                   }
[10:18:27.249]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.249]                     cond$call), session = sessionInformation(), 
[10:18:27.249]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.249]                   signalCondition(cond)
[10:18:27.249]                 }
[10:18:27.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.249]                 "immediateCondition"))) {
[10:18:27.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.249]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.249]                   if (TRUE && !signal) {
[10:18:27.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.249]                     {
[10:18:27.249]                       inherits <- base::inherits
[10:18:27.249]                       invokeRestart <- base::invokeRestart
[10:18:27.249]                       is.null <- base::is.null
[10:18:27.249]                       muffled <- FALSE
[10:18:27.249]                       if (inherits(cond, "message")) {
[10:18:27.249]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.249]                         if (muffled) 
[10:18:27.249]                           invokeRestart("muffleMessage")
[10:18:27.249]                       }
[10:18:27.249]                       else if (inherits(cond, "warning")) {
[10:18:27.249]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.249]                         if (muffled) 
[10:18:27.249]                           invokeRestart("muffleWarning")
[10:18:27.249]                       }
[10:18:27.249]                       else if (inherits(cond, "condition")) {
[10:18:27.249]                         if (!is.null(pattern)) {
[10:18:27.249]                           computeRestarts <- base::computeRestarts
[10:18:27.249]                           grepl <- base::grepl
[10:18:27.249]                           restarts <- computeRestarts(cond)
[10:18:27.249]                           for (restart in restarts) {
[10:18:27.249]                             name <- restart$name
[10:18:27.249]                             if (is.null(name)) 
[10:18:27.249]                               next
[10:18:27.249]                             if (!grepl(pattern, name)) 
[10:18:27.249]                               next
[10:18:27.249]                             invokeRestart(restart)
[10:18:27.249]                             muffled <- TRUE
[10:18:27.249]                             break
[10:18:27.249]                           }
[10:18:27.249]                         }
[10:18:27.249]                       }
[10:18:27.249]                       invisible(muffled)
[10:18:27.249]                     }
[10:18:27.249]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.249]                   }
[10:18:27.249]                 }
[10:18:27.249]                 else {
[10:18:27.249]                   if (TRUE) {
[10:18:27.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.249]                     {
[10:18:27.249]                       inherits <- base::inherits
[10:18:27.249]                       invokeRestart <- base::invokeRestart
[10:18:27.249]                       is.null <- base::is.null
[10:18:27.249]                       muffled <- FALSE
[10:18:27.249]                       if (inherits(cond, "message")) {
[10:18:27.249]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.249]                         if (muffled) 
[10:18:27.249]                           invokeRestart("muffleMessage")
[10:18:27.249]                       }
[10:18:27.249]                       else if (inherits(cond, "warning")) {
[10:18:27.249]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.249]                         if (muffled) 
[10:18:27.249]                           invokeRestart("muffleWarning")
[10:18:27.249]                       }
[10:18:27.249]                       else if (inherits(cond, "condition")) {
[10:18:27.249]                         if (!is.null(pattern)) {
[10:18:27.249]                           computeRestarts <- base::computeRestarts
[10:18:27.249]                           grepl <- base::grepl
[10:18:27.249]                           restarts <- computeRestarts(cond)
[10:18:27.249]                           for (restart in restarts) {
[10:18:27.249]                             name <- restart$name
[10:18:27.249]                             if (is.null(name)) 
[10:18:27.249]                               next
[10:18:27.249]                             if (!grepl(pattern, name)) 
[10:18:27.249]                               next
[10:18:27.249]                             invokeRestart(restart)
[10:18:27.249]                             muffled <- TRUE
[10:18:27.249]                             break
[10:18:27.249]                           }
[10:18:27.249]                         }
[10:18:27.249]                       }
[10:18:27.249]                       invisible(muffled)
[10:18:27.249]                     }
[10:18:27.249]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.249]                   }
[10:18:27.249]                 }
[10:18:27.249]             }
[10:18:27.249]         }))
[10:18:27.249]     }, error = function(ex) {
[10:18:27.249]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.249]                 ...future.rng), started = ...future.startTime, 
[10:18:27.249]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.249]             version = "1.8"), class = "FutureResult")
[10:18:27.249]     }, finally = {
[10:18:27.249]         if (!identical(...future.workdir, getwd())) 
[10:18:27.249]             setwd(...future.workdir)
[10:18:27.249]         {
[10:18:27.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.249]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.249]             }
[10:18:27.249]             base::options(...future.oldOptions)
[10:18:27.249]             if (.Platform$OS.type == "windows") {
[10:18:27.249]                 old_names <- names(...future.oldEnvVars)
[10:18:27.249]                 envs <- base::Sys.getenv()
[10:18:27.249]                 names <- names(envs)
[10:18:27.249]                 common <- intersect(names, old_names)
[10:18:27.249]                 added <- setdiff(names, old_names)
[10:18:27.249]                 removed <- setdiff(old_names, names)
[10:18:27.249]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.249]                   envs[common]]
[10:18:27.249]                 NAMES <- toupper(changed)
[10:18:27.249]                 args <- list()
[10:18:27.249]                 for (kk in seq_along(NAMES)) {
[10:18:27.249]                   name <- changed[[kk]]
[10:18:27.249]                   NAME <- NAMES[[kk]]
[10:18:27.249]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.249]                     next
[10:18:27.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.249]                 }
[10:18:27.249]                 NAMES <- toupper(added)
[10:18:27.249]                 for (kk in seq_along(NAMES)) {
[10:18:27.249]                   name <- added[[kk]]
[10:18:27.249]                   NAME <- NAMES[[kk]]
[10:18:27.249]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.249]                     next
[10:18:27.249]                   args[[name]] <- ""
[10:18:27.249]                 }
[10:18:27.249]                 NAMES <- toupper(removed)
[10:18:27.249]                 for (kk in seq_along(NAMES)) {
[10:18:27.249]                   name <- removed[[kk]]
[10:18:27.249]                   NAME <- NAMES[[kk]]
[10:18:27.249]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.249]                     next
[10:18:27.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.249]                 }
[10:18:27.249]                 if (length(args) > 0) 
[10:18:27.249]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.249]             }
[10:18:27.249]             else {
[10:18:27.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.249]             }
[10:18:27.249]             {
[10:18:27.249]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.249]                   0L) {
[10:18:27.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.249]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.249]                   base::options(opts)
[10:18:27.249]                 }
[10:18:27.249]                 {
[10:18:27.249]                   {
[10:18:27.249]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.249]                     NULL
[10:18:27.249]                   }
[10:18:27.249]                   options(future.plan = NULL)
[10:18:27.249]                   if (is.na(NA_character_)) 
[10:18:27.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.249]                     .init = FALSE)
[10:18:27.249]                 }
[10:18:27.249]             }
[10:18:27.249]         }
[10:18:27.249]     })
[10:18:27.249]     if (TRUE) {
[10:18:27.249]         base::sink(type = "output", split = FALSE)
[10:18:27.249]         if (TRUE) {
[10:18:27.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.249]         }
[10:18:27.249]         else {
[10:18:27.249]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.249]         }
[10:18:27.249]         base::close(...future.stdout)
[10:18:27.249]         ...future.stdout <- NULL
[10:18:27.249]     }
[10:18:27.249]     ...future.result$conditions <- ...future.conditions
[10:18:27.249]     ...future.result$finished <- base::Sys.time()
[10:18:27.249]     ...future.result
[10:18:27.249] }
[10:18:27.251] assign_globals() ...
[10:18:27.251] List of 5
[10:18:27.251]  $ future.call.arguments    : list()
[10:18:27.251]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.251]  $ ...future.FUN            :function (x)  
[10:18:27.251]  $ ...future.elements_ii    :List of 3
[10:18:27.251]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:18:27.251]   ..$ : num [1:8] 3 3 3 3 3 3 3 3
[10:18:27.251]   ..$ : num [1:8] 4 3 2 1 2 3 4 5
[10:18:27.251]  $ ...future.seeds_ii       : NULL
[10:18:27.251]  $ ...future.globals.maxSize: num Inf
[10:18:27.251]  - attr(*, "resolved")= logi FALSE
[10:18:27.251]  - attr(*, "total_size")= num NA
[10:18:27.251]  - attr(*, "where")=List of 5
[10:18:27.251]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.251]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.251]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.251]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.251]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.251]  - attr(*, "already-done")= logi TRUE
[10:18:27.259] - copied ‘future.call.arguments’ to environment
[10:18:27.259] - copied ‘...future.FUN’ to environment
[10:18:27.259] - copied ‘...future.elements_ii’ to environment
[10:18:27.259] - copied ‘...future.seeds_ii’ to environment
[10:18:27.259] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.259] assign_globals() ... done
[10:18:27.259] requestCore(): workers = 2
[10:18:27.262] MulticoreFuture started
[10:18:27.262] - Launch lazy future ... done
[10:18:27.262] run() for ‘MulticoreFuture’ ... done
[10:18:27.263] Created future:
[10:18:27.263] plan(): Setting new future strategy stack:
[10:18:27.263] List of future strategies:
[10:18:27.263] 1. sequential:
[10:18:27.263]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.263]    - tweaked: FALSE
[10:18:27.263]    - call: NULL
[10:18:27.264] plan(): nbrOfWorkers() = 1
[10:18:27.266] plan(): Setting new future strategy stack:
[10:18:27.266] List of future strategies:
[10:18:27.266] 1. multicore:
[10:18:27.266]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.266]    - tweaked: FALSE
[10:18:27.266]    - call: plan(strategy)
[10:18:27.270] plan(): nbrOfWorkers() = 2
[10:18:27.263] MulticoreFuture:
[10:18:27.263] Label: ‘future_apply-2’
[10:18:27.263] Expression:
[10:18:27.263] {
[10:18:27.263]     do.call(function(...) {
[10:18:27.263]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.263]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.263]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.263]             on.exit(options(oopts), add = TRUE)
[10:18:27.263]         }
[10:18:27.263]         {
[10:18:27.263]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.263]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.263]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.263]             })
[10:18:27.263]         }
[10:18:27.263]     }, args = future.call.arguments)
[10:18:27.263] }
[10:18:27.263] Lazy evaluation: FALSE
[10:18:27.263] Asynchronous evaluation: TRUE
[10:18:27.263] Local evaluation: TRUE
[10:18:27.263] Environment: R_GlobalEnv
[10:18:27.263] Capture standard output: TRUE
[10:18:27.263] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.263] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.263] Packages: <none>
[10:18:27.263] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.263] Resolved: TRUE
[10:18:27.263] Value: <not collected>
[10:18:27.263] Conditions captured: <none>
[10:18:27.263] Early signaling: FALSE
[10:18:27.263] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.263] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.271] Chunk #2 of 2 ... DONE
[10:18:27.271] Launching 2 futures (chunks) ... DONE
[10:18:27.271] Resolving 2 futures (chunks) ...
[10:18:27.271] resolve() on list ...
[10:18:27.271]  recursive: 0
[10:18:27.272]  length: 2
[10:18:27.272] 
[10:18:27.272] Future #1
[10:18:27.272] result() for MulticoreFuture ...
[10:18:27.273] result() for MulticoreFuture ...
[10:18:27.273] result() for MulticoreFuture ... done
[10:18:27.273] result() for MulticoreFuture ... done
[10:18:27.273] result() for MulticoreFuture ...
[10:18:27.274] result() for MulticoreFuture ... done
[10:18:27.274] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:27.274] - nx: 2
[10:18:27.274] - relay: TRUE
[10:18:27.274] - stdout: TRUE
[10:18:27.274] - signal: TRUE
[10:18:27.274] - resignal: FALSE
[10:18:27.275] - force: TRUE
[10:18:27.275] - relayed: [n=2] FALSE, FALSE
[10:18:27.275] - queued futures: [n=2] FALSE, FALSE
[10:18:27.275]  - until=1
[10:18:27.275]  - relaying element #1
[10:18:27.275] result() for MulticoreFuture ...
[10:18:27.275] result() for MulticoreFuture ... done
[10:18:27.276] result() for MulticoreFuture ...
[10:18:27.276] result() for MulticoreFuture ... done
[10:18:27.276] result() for MulticoreFuture ...
[10:18:27.276] result() for MulticoreFuture ... done
[10:18:27.276] result() for MulticoreFuture ...
[10:18:27.276] result() for MulticoreFuture ... done
[10:18:27.276] - relayed: [n=2] TRUE, FALSE
[10:18:27.276] - queued futures: [n=2] TRUE, FALSE
[10:18:27.277] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:27.277]  length: 1 (resolved future 1)
[10:18:27.277] Future #2
[10:18:27.277] result() for MulticoreFuture ...
[10:18:27.278] result() for MulticoreFuture ...
[10:18:27.278] result() for MulticoreFuture ... done
[10:18:27.278] result() for MulticoreFuture ... done
[10:18:27.278] result() for MulticoreFuture ...
[10:18:27.279] result() for MulticoreFuture ... done
[10:18:27.279] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:27.279] - nx: 2
[10:18:27.279] - relay: TRUE
[10:18:27.279] - stdout: TRUE
[10:18:27.279] - signal: TRUE
[10:18:27.279] - resignal: FALSE
[10:18:27.279] - force: TRUE
[10:18:27.279] - relayed: [n=2] TRUE, FALSE
[10:18:27.280] - queued futures: [n=2] TRUE, FALSE
[10:18:27.280]  - until=2
[10:18:27.280]  - relaying element #2
[10:18:27.280] result() for MulticoreFuture ...
[10:18:27.280] result() for MulticoreFuture ... done
[10:18:27.280] result() for MulticoreFuture ...
[10:18:27.283] result() for MulticoreFuture ... done
[10:18:27.283] result() for MulticoreFuture ...
[10:18:27.283] result() for MulticoreFuture ... done
[10:18:27.283] result() for MulticoreFuture ...
[10:18:27.284] result() for MulticoreFuture ... done
[10:18:27.284] - relayed: [n=2] TRUE, TRUE
[10:18:27.284] - queued futures: [n=2] TRUE, TRUE
[10:18:27.284] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:27.284]  length: 0 (resolved future 2)
[10:18:27.285] Relaying remaining futures
[10:18:27.285] signalConditionsASAP(NULL, pos=0) ...
[10:18:27.285] - nx: 2
[10:18:27.285] - relay: TRUE
[10:18:27.285] - stdout: TRUE
[10:18:27.285] - signal: TRUE
[10:18:27.285] - resignal: FALSE
[10:18:27.286] - force: TRUE
[10:18:27.286] - relayed: [n=2] TRUE, TRUE
[10:18:27.286] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:27.286] - relayed: [n=2] TRUE, TRUE
[10:18:27.286] - queued futures: [n=2] TRUE, TRUE
[10:18:27.287] signalConditionsASAP(NULL, pos=0) ... done
[10:18:27.287] resolve() on list ... DONE
[10:18:27.287] result() for MulticoreFuture ...
[10:18:27.287] result() for MulticoreFuture ... done
[10:18:27.287] result() for MulticoreFuture ...
[10:18:27.287] result() for MulticoreFuture ... done
[10:18:27.288] result() for MulticoreFuture ...
[10:18:27.288] result() for MulticoreFuture ... done
[10:18:27.288] result() for MulticoreFuture ...
[10:18:27.288] result() for MulticoreFuture ... done
[10:18:27.288]  - Number of value chunks collected: 2
[10:18:27.288] Resolving 2 futures (chunks) ... DONE
[10:18:27.288] Reducing values from 2 chunks ...
[10:18:27.288]  - Number of values collected after concatenation: 6
[10:18:27.288]  - Number of values expected: 6
[10:18:27.288] Reducing values from 2 chunks ... DONE
[10:18:27.289] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:18:27.289] getGlobalsAndPackagesXApply() ...
[10:18:27.289]  - future.globals: TRUE
[10:18:27.289] getGlobalsAndPackages() ...
[10:18:27.289] Searching for globals...
[10:18:27.291] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:18:27.291] Searching for globals ... DONE
[10:18:27.291] Resolving globals: FALSE
[10:18:27.292] The total size of the 1 globals is 411 bytes (411 bytes)
[10:18:27.292] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 411 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (411 bytes of class ‘function’)
[10:18:27.292] - globals: [1] ‘FUN’
[10:18:27.293] 
[10:18:27.293] getGlobalsAndPackages() ... DONE
[10:18:27.293]  - globals found/used: [n=1] ‘FUN’
[10:18:27.293]  - needed namespaces: [n=0] 
[10:18:27.293] Finding globals ... DONE
[10:18:27.293]  - use_args: TRUE
[10:18:27.293]  - Getting '...' globals ...
[10:18:27.294] resolve() on list ...
[10:18:27.294]  recursive: 0
[10:18:27.294]  length: 1
[10:18:27.294]  elements: ‘...’
[10:18:27.294]  length: 0 (resolved future 1)
[10:18:27.294] resolve() on list ... DONE
[10:18:27.294]    - '...' content: [n=0] 
[10:18:27.294] List of 1
[10:18:27.294]  $ ...: list()
[10:18:27.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.294]  - attr(*, "where")=List of 1
[10:18:27.294]   ..$ ...:<environment: 0x556e02c81aa0> 
[10:18:27.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.294]  - attr(*, "resolved")= logi TRUE
[10:18:27.294]  - attr(*, "total_size")= num NA
[10:18:27.297]  - Getting '...' globals ... DONE
[10:18:27.297] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:27.298] List of 2
[10:18:27.298]  $ ...future.FUN:function (x)  
[10:18:27.298]  $ ...          : list()
[10:18:27.298]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.298]  - attr(*, "where")=List of 2
[10:18:27.298]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:27.298]   ..$ ...          :<environment: 0x556e02c81aa0> 
[10:18:27.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.298]  - attr(*, "resolved")= logi FALSE
[10:18:27.298]  - attr(*, "total_size")= num 3672
[10:18:27.300] Packages to be attached in all futures: [n=0] 
[10:18:27.301] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.302] future_lapply() ...
[10:18:27.304] Number of chunks: 2
[10:18:27.304] getGlobalsAndPackagesXApply() ...
[10:18:27.304]  - future.globals: <name-value list> with names ‘list()’
[10:18:27.305]  - use_args: TRUE
[10:18:27.305] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:27.305] List of 2
[10:18:27.305]  $ ...          : list()
[10:18:27.305]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.305]  $ ...future.FUN:function (x)  
[10:18:27.305]  - attr(*, "where")=List of 2
[10:18:27.305]   ..$ ...          :<environment: 0x556e02c81aa0> 
[10:18:27.305]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:18:27.305]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.305]  - attr(*, "resolved")= logi FALSE
[10:18:27.305]  - attr(*, "total_size")= num NA
[10:18:27.308] Packages to be attached in all futures: [n=0] 
[10:18:27.308] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.308] Number of futures (= number of chunks): 2
[10:18:27.308] Launching 2 futures (chunks) ...
[10:18:27.308] Chunk #1 of 2 ...
[10:18:27.310]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.310]  - seeds: <none>
[10:18:27.310]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.310] getGlobalsAndPackages() ...
[10:18:27.310] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.310] Resolving globals: FALSE
[10:18:27.311] Tweak future expression to call with '...' arguments ...
[10:18:27.311] {
[10:18:27.311]     do.call(function(...) {
[10:18:27.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.311]             on.exit(options(oopts), add = TRUE)
[10:18:27.311]         }
[10:18:27.311]         {
[10:18:27.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.311]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.311]             })
[10:18:27.311]         }
[10:18:27.311]     }, args = future.call.arguments)
[10:18:27.311] }
[10:18:27.311] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.311] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.312] 
[10:18:27.312] getGlobalsAndPackages() ... DONE
[10:18:27.312] run() for ‘Future’ ...
[10:18:27.312] - state: ‘created’
[10:18:27.312] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.314] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.314] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.314]   - Field: ‘label’
[10:18:27.314]   - Field: ‘local’
[10:18:27.314]   - Field: ‘owner’
[10:18:27.315]   - Field: ‘envir’
[10:18:27.315]   - Field: ‘workers’
[10:18:27.315]   - Field: ‘packages’
[10:18:27.315]   - Field: ‘gc’
[10:18:27.315]   - Field: ‘job’
[10:18:27.315]   - Field: ‘conditions’
[10:18:27.315]   - Field: ‘expr’
[10:18:27.315]   - Field: ‘uuid’
[10:18:27.315]   - Field: ‘seed’
[10:18:27.315]   - Field: ‘version’
[10:18:27.315]   - Field: ‘result’
[10:18:27.315]   - Field: ‘asynchronous’
[10:18:27.316]   - Field: ‘calls’
[10:18:27.316]   - Field: ‘globals’
[10:18:27.316]   - Field: ‘stdout’
[10:18:27.316]   - Field: ‘earlySignal’
[10:18:27.316]   - Field: ‘lazy’
[10:18:27.316]   - Field: ‘state’
[10:18:27.316] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.316] - Launch lazy future ...
[10:18:27.316] Packages needed by the future expression (n = 0): <none>
[10:18:27.317] Packages needed by future strategies (n = 0): <none>
[10:18:27.317] {
[10:18:27.317]     {
[10:18:27.317]         {
[10:18:27.317]             ...future.startTime <- base::Sys.time()
[10:18:27.317]             {
[10:18:27.317]                 {
[10:18:27.317]                   {
[10:18:27.317]                     {
[10:18:27.317]                       base::local({
[10:18:27.317]                         has_future <- base::requireNamespace("future", 
[10:18:27.317]                           quietly = TRUE)
[10:18:27.317]                         if (has_future) {
[10:18:27.317]                           ns <- base::getNamespace("future")
[10:18:27.317]                           version <- ns[[".package"]][["version"]]
[10:18:27.317]                           if (is.null(version)) 
[10:18:27.317]                             version <- utils::packageVersion("future")
[10:18:27.317]                         }
[10:18:27.317]                         else {
[10:18:27.317]                           version <- NULL
[10:18:27.317]                         }
[10:18:27.317]                         if (!has_future || version < "1.8.0") {
[10:18:27.317]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.317]                             "", base::R.version$version.string), 
[10:18:27.317]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.317]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.317]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.317]                               "release", "version")], collapse = " "), 
[10:18:27.317]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.317]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.317]                             info)
[10:18:27.317]                           info <- base::paste(info, collapse = "; ")
[10:18:27.317]                           if (!has_future) {
[10:18:27.317]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.317]                               info)
[10:18:27.317]                           }
[10:18:27.317]                           else {
[10:18:27.317]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.317]                               info, version)
[10:18:27.317]                           }
[10:18:27.317]                           base::stop(msg)
[10:18:27.317]                         }
[10:18:27.317]                       })
[10:18:27.317]                     }
[10:18:27.317]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.317]                     base::options(mc.cores = 1L)
[10:18:27.317]                   }
[10:18:27.317]                   ...future.strategy.old <- future::plan("list")
[10:18:27.317]                   options(future.plan = NULL)
[10:18:27.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.317]                 }
[10:18:27.317]                 ...future.workdir <- getwd()
[10:18:27.317]             }
[10:18:27.317]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.317]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.317]         }
[10:18:27.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.317]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.317]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.317]             base::names(...future.oldOptions))
[10:18:27.317]     }
[10:18:27.317]     if (FALSE) {
[10:18:27.317]     }
[10:18:27.317]     else {
[10:18:27.317]         if (TRUE) {
[10:18:27.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.317]                 open = "w")
[10:18:27.317]         }
[10:18:27.317]         else {
[10:18:27.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.317]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.317]         }
[10:18:27.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.317]             base::sink(type = "output", split = FALSE)
[10:18:27.317]             base::close(...future.stdout)
[10:18:27.317]         }, add = TRUE)
[10:18:27.317]     }
[10:18:27.317]     ...future.frame <- base::sys.nframe()
[10:18:27.317]     ...future.conditions <- base::list()
[10:18:27.317]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.317]     if (FALSE) {
[10:18:27.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.317]     }
[10:18:27.317]     ...future.result <- base::tryCatch({
[10:18:27.317]         base::withCallingHandlers({
[10:18:27.317]             ...future.value <- base::withVisible(base::local({
[10:18:27.317]                 withCallingHandlers({
[10:18:27.317]                   {
[10:18:27.317]                     do.call(function(...) {
[10:18:27.317]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.317]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.317]                         ...future.globals.maxSize)) {
[10:18:27.317]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.317]                         on.exit(options(oopts), add = TRUE)
[10:18:27.317]                       }
[10:18:27.317]                       {
[10:18:27.317]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.317]                           FUN = function(jj) {
[10:18:27.317]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.317]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.317]                           })
[10:18:27.317]                       }
[10:18:27.317]                     }, args = future.call.arguments)
[10:18:27.317]                   }
[10:18:27.317]                 }, immediateCondition = function(cond) {
[10:18:27.317]                   save_rds <- function (object, pathname, ...) 
[10:18:27.317]                   {
[10:18:27.317]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.317]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.317]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.317]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.317]                         fi_tmp[["mtime"]])
[10:18:27.317]                     }
[10:18:27.317]                     tryCatch({
[10:18:27.317]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.317]                     }, error = function(ex) {
[10:18:27.317]                       msg <- conditionMessage(ex)
[10:18:27.317]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.317]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.317]                         fi_tmp[["mtime"]], msg)
[10:18:27.317]                       ex$message <- msg
[10:18:27.317]                       stop(ex)
[10:18:27.317]                     })
[10:18:27.317]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.317]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.317]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.317]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.317]                       fi <- file.info(pathname)
[10:18:27.317]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.317]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.317]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.317]                         fi[["size"]], fi[["mtime"]])
[10:18:27.317]                       stop(msg)
[10:18:27.317]                     }
[10:18:27.317]                     invisible(pathname)
[10:18:27.317]                   }
[10:18:27.317]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.317]                     rootPath = tempdir()) 
[10:18:27.317]                   {
[10:18:27.317]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.317]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.317]                       tmpdir = path, fileext = ".rds")
[10:18:27.317]                     save_rds(obj, file)
[10:18:27.317]                   }
[10:18:27.317]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.317]                   {
[10:18:27.317]                     inherits <- base::inherits
[10:18:27.317]                     invokeRestart <- base::invokeRestart
[10:18:27.317]                     is.null <- base::is.null
[10:18:27.317]                     muffled <- FALSE
[10:18:27.317]                     if (inherits(cond, "message")) {
[10:18:27.317]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.317]                       if (muffled) 
[10:18:27.317]                         invokeRestart("muffleMessage")
[10:18:27.317]                     }
[10:18:27.317]                     else if (inherits(cond, "warning")) {
[10:18:27.317]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.317]                       if (muffled) 
[10:18:27.317]                         invokeRestart("muffleWarning")
[10:18:27.317]                     }
[10:18:27.317]                     else if (inherits(cond, "condition")) {
[10:18:27.317]                       if (!is.null(pattern)) {
[10:18:27.317]                         computeRestarts <- base::computeRestarts
[10:18:27.317]                         grepl <- base::grepl
[10:18:27.317]                         restarts <- computeRestarts(cond)
[10:18:27.317]                         for (restart in restarts) {
[10:18:27.317]                           name <- restart$name
[10:18:27.317]                           if (is.null(name)) 
[10:18:27.317]                             next
[10:18:27.317]                           if (!grepl(pattern, name)) 
[10:18:27.317]                             next
[10:18:27.317]                           invokeRestart(restart)
[10:18:27.317]                           muffled <- TRUE
[10:18:27.317]                           break
[10:18:27.317]                         }
[10:18:27.317]                       }
[10:18:27.317]                     }
[10:18:27.317]                     invisible(muffled)
[10:18:27.317]                   }
[10:18:27.317]                   muffleCondition(cond)
[10:18:27.317]                 })
[10:18:27.317]             }))
[10:18:27.317]             future::FutureResult(value = ...future.value$value, 
[10:18:27.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.317]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.317]                     ...future.globalenv.names))
[10:18:27.317]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.317]         }, condition = base::local({
[10:18:27.317]             c <- base::c
[10:18:27.317]             inherits <- base::inherits
[10:18:27.317]             invokeRestart <- base::invokeRestart
[10:18:27.317]             length <- base::length
[10:18:27.317]             list <- base::list
[10:18:27.317]             seq.int <- base::seq.int
[10:18:27.317]             signalCondition <- base::signalCondition
[10:18:27.317]             sys.calls <- base::sys.calls
[10:18:27.317]             `[[` <- base::`[[`
[10:18:27.317]             `+` <- base::`+`
[10:18:27.317]             `<<-` <- base::`<<-`
[10:18:27.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.317]                   3L)]
[10:18:27.317]             }
[10:18:27.317]             function(cond) {
[10:18:27.317]                 is_error <- inherits(cond, "error")
[10:18:27.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.317]                   NULL)
[10:18:27.317]                 if (is_error) {
[10:18:27.317]                   sessionInformation <- function() {
[10:18:27.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.317]                       search = base::search(), system = base::Sys.info())
[10:18:27.317]                   }
[10:18:27.317]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.317]                     cond$call), session = sessionInformation(), 
[10:18:27.317]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.317]                   signalCondition(cond)
[10:18:27.317]                 }
[10:18:27.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.317]                 "immediateCondition"))) {
[10:18:27.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.317]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.317]                   if (TRUE && !signal) {
[10:18:27.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.317]                     {
[10:18:27.317]                       inherits <- base::inherits
[10:18:27.317]                       invokeRestart <- base::invokeRestart
[10:18:27.317]                       is.null <- base::is.null
[10:18:27.317]                       muffled <- FALSE
[10:18:27.317]                       if (inherits(cond, "message")) {
[10:18:27.317]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.317]                         if (muffled) 
[10:18:27.317]                           invokeRestart("muffleMessage")
[10:18:27.317]                       }
[10:18:27.317]                       else if (inherits(cond, "warning")) {
[10:18:27.317]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.317]                         if (muffled) 
[10:18:27.317]                           invokeRestart("muffleWarning")
[10:18:27.317]                       }
[10:18:27.317]                       else if (inherits(cond, "condition")) {
[10:18:27.317]                         if (!is.null(pattern)) {
[10:18:27.317]                           computeRestarts <- base::computeRestarts
[10:18:27.317]                           grepl <- base::grepl
[10:18:27.317]                           restarts <- computeRestarts(cond)
[10:18:27.317]                           for (restart in restarts) {
[10:18:27.317]                             name <- restart$name
[10:18:27.317]                             if (is.null(name)) 
[10:18:27.317]                               next
[10:18:27.317]                             if (!grepl(pattern, name)) 
[10:18:27.317]                               next
[10:18:27.317]                             invokeRestart(restart)
[10:18:27.317]                             muffled <- TRUE
[10:18:27.317]                             break
[10:18:27.317]                           }
[10:18:27.317]                         }
[10:18:27.317]                       }
[10:18:27.317]                       invisible(muffled)
[10:18:27.317]                     }
[10:18:27.317]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.317]                   }
[10:18:27.317]                 }
[10:18:27.317]                 else {
[10:18:27.317]                   if (TRUE) {
[10:18:27.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.317]                     {
[10:18:27.317]                       inherits <- base::inherits
[10:18:27.317]                       invokeRestart <- base::invokeRestart
[10:18:27.317]                       is.null <- base::is.null
[10:18:27.317]                       muffled <- FALSE
[10:18:27.317]                       if (inherits(cond, "message")) {
[10:18:27.317]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.317]                         if (muffled) 
[10:18:27.317]                           invokeRestart("muffleMessage")
[10:18:27.317]                       }
[10:18:27.317]                       else if (inherits(cond, "warning")) {
[10:18:27.317]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.317]                         if (muffled) 
[10:18:27.317]                           invokeRestart("muffleWarning")
[10:18:27.317]                       }
[10:18:27.317]                       else if (inherits(cond, "condition")) {
[10:18:27.317]                         if (!is.null(pattern)) {
[10:18:27.317]                           computeRestarts <- base::computeRestarts
[10:18:27.317]                           grepl <- base::grepl
[10:18:27.317]                           restarts <- computeRestarts(cond)
[10:18:27.317]                           for (restart in restarts) {
[10:18:27.317]                             name <- restart$name
[10:18:27.317]                             if (is.null(name)) 
[10:18:27.317]                               next
[10:18:27.317]                             if (!grepl(pattern, name)) 
[10:18:27.317]                               next
[10:18:27.317]                             invokeRestart(restart)
[10:18:27.317]                             muffled <- TRUE
[10:18:27.317]                             break
[10:18:27.317]                           }
[10:18:27.317]                         }
[10:18:27.317]                       }
[10:18:27.317]                       invisible(muffled)
[10:18:27.317]                     }
[10:18:27.317]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.317]                   }
[10:18:27.317]                 }
[10:18:27.317]             }
[10:18:27.317]         }))
[10:18:27.317]     }, error = function(ex) {
[10:18:27.317]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.317]                 ...future.rng), started = ...future.startTime, 
[10:18:27.317]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.317]             version = "1.8"), class = "FutureResult")
[10:18:27.317]     }, finally = {
[10:18:27.317]         if (!identical(...future.workdir, getwd())) 
[10:18:27.317]             setwd(...future.workdir)
[10:18:27.317]         {
[10:18:27.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.317]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.317]             }
[10:18:27.317]             base::options(...future.oldOptions)
[10:18:27.317]             if (.Platform$OS.type == "windows") {
[10:18:27.317]                 old_names <- names(...future.oldEnvVars)
[10:18:27.317]                 envs <- base::Sys.getenv()
[10:18:27.317]                 names <- names(envs)
[10:18:27.317]                 common <- intersect(names, old_names)
[10:18:27.317]                 added <- setdiff(names, old_names)
[10:18:27.317]                 removed <- setdiff(old_names, names)
[10:18:27.317]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.317]                   envs[common]]
[10:18:27.317]                 NAMES <- toupper(changed)
[10:18:27.317]                 args <- list()
[10:18:27.317]                 for (kk in seq_along(NAMES)) {
[10:18:27.317]                   name <- changed[[kk]]
[10:18:27.317]                   NAME <- NAMES[[kk]]
[10:18:27.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.317]                     next
[10:18:27.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.317]                 }
[10:18:27.317]                 NAMES <- toupper(added)
[10:18:27.317]                 for (kk in seq_along(NAMES)) {
[10:18:27.317]                   name <- added[[kk]]
[10:18:27.317]                   NAME <- NAMES[[kk]]
[10:18:27.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.317]                     next
[10:18:27.317]                   args[[name]] <- ""
[10:18:27.317]                 }
[10:18:27.317]                 NAMES <- toupper(removed)
[10:18:27.317]                 for (kk in seq_along(NAMES)) {
[10:18:27.317]                   name <- removed[[kk]]
[10:18:27.317]                   NAME <- NAMES[[kk]]
[10:18:27.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.317]                     next
[10:18:27.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.317]                 }
[10:18:27.317]                 if (length(args) > 0) 
[10:18:27.317]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.317]             }
[10:18:27.317]             else {
[10:18:27.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.317]             }
[10:18:27.317]             {
[10:18:27.317]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.317]                   0L) {
[10:18:27.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.317]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.317]                   base::options(opts)
[10:18:27.317]                 }
[10:18:27.317]                 {
[10:18:27.317]                   {
[10:18:27.317]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.317]                     NULL
[10:18:27.317]                   }
[10:18:27.317]                   options(future.plan = NULL)
[10:18:27.317]                   if (is.na(NA_character_)) 
[10:18:27.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.317]                     .init = FALSE)
[10:18:27.317]                 }
[10:18:27.317]             }
[10:18:27.317]         }
[10:18:27.317]     })
[10:18:27.317]     if (TRUE) {
[10:18:27.317]         base::sink(type = "output", split = FALSE)
[10:18:27.317]         if (TRUE) {
[10:18:27.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.317]         }
[10:18:27.317]         else {
[10:18:27.317]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.317]         }
[10:18:27.317]         base::close(...future.stdout)
[10:18:27.317]         ...future.stdout <- NULL
[10:18:27.317]     }
[10:18:27.317]     ...future.result$conditions <- ...future.conditions
[10:18:27.317]     ...future.result$finished <- base::Sys.time()
[10:18:27.317]     ...future.result
[10:18:27.317] }
[10:18:27.319] assign_globals() ...
[10:18:27.320] List of 5
[10:18:27.320]  $ future.call.arguments    : list()
[10:18:27.320]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.320]  $ ...future.FUN            :function (x)  
[10:18:27.320]  $ ...future.elements_ii    :List of 3
[10:18:27.320]   ..$ : int [1:4] 1 7 13 19
[10:18:27.320]   ..$ : int [1:4] 2 8 14 20
[10:18:27.320]   ..$ : int [1:4] 3 9 15 21
[10:18:27.320]  $ ...future.seeds_ii       : NULL
[10:18:27.320]  $ ...future.globals.maxSize: num Inf
[10:18:27.320]  - attr(*, "resolved")= logi FALSE
[10:18:27.320]  - attr(*, "total_size")= num NA
[10:18:27.320]  - attr(*, "where")=List of 5
[10:18:27.320]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.320]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.320]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.320]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.320]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.320]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.320]  - attr(*, "already-done")= logi TRUE
[10:18:27.325] - copied ‘future.call.arguments’ to environment
[10:18:27.325] - reassign environment for ‘...future.FUN’
[10:18:27.325] - copied ‘...future.FUN’ to environment
[10:18:27.325] - copied ‘...future.elements_ii’ to environment
[10:18:27.325] - copied ‘...future.seeds_ii’ to environment
[10:18:27.325] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.325] assign_globals() ... done
[10:18:27.326] requestCore(): workers = 2
[10:18:27.328] MulticoreFuture started
[10:18:27.328] - Launch lazy future ... done
[10:18:27.328] run() for ‘MulticoreFuture’ ... done
[10:18:27.329] Created future:
[10:18:27.329] plan(): Setting new future strategy stack:
[10:18:27.329] List of future strategies:
[10:18:27.329] 1. sequential:
[10:18:27.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.329]    - tweaked: FALSE
[10:18:27.329]    - call: NULL
[10:18:27.330] plan(): nbrOfWorkers() = 1
[10:18:27.332] plan(): Setting new future strategy stack:
[10:18:27.332] List of future strategies:
[10:18:27.332] 1. multicore:
[10:18:27.332]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.332]    - tweaked: FALSE
[10:18:27.332]    - call: plan(strategy)
[10:18:27.336] plan(): nbrOfWorkers() = 2
[10:18:27.329] MulticoreFuture:
[10:18:27.329] Label: ‘future_apply-1’
[10:18:27.329] Expression:
[10:18:27.329] {
[10:18:27.329]     do.call(function(...) {
[10:18:27.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.329]             on.exit(options(oopts), add = TRUE)
[10:18:27.329]         }
[10:18:27.329]         {
[10:18:27.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.329]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.329]             })
[10:18:27.329]         }
[10:18:27.329]     }, args = future.call.arguments)
[10:18:27.329] }
[10:18:27.329] Lazy evaluation: FALSE
[10:18:27.329] Asynchronous evaluation: TRUE
[10:18:27.329] Local evaluation: TRUE
[10:18:27.329] Environment: R_GlobalEnv
[10:18:27.329] Capture standard output: TRUE
[10:18:27.329] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.329] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.329] Packages: <none>
[10:18:27.329] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.329] Resolved: TRUE
[10:18:27.329] Value: <not collected>
[10:18:27.329] Conditions captured: <none>
[10:18:27.329] Early signaling: FALSE
[10:18:27.329] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.329] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.338] Chunk #1 of 2 ... DONE
[10:18:27.338] Chunk #2 of 2 ...
[10:18:27.338]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.338]  - seeds: <none>
[10:18:27.338]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.338] getGlobalsAndPackages() ...
[10:18:27.339] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.339] Resolving globals: FALSE
[10:18:27.339] Tweak future expression to call with '...' arguments ...
[10:18:27.339] {
[10:18:27.339]     do.call(function(...) {
[10:18:27.339]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.339]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.339]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.339]             on.exit(options(oopts), add = TRUE)
[10:18:27.339]         }
[10:18:27.339]         {
[10:18:27.339]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.339]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.339]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.339]             })
[10:18:27.339]         }
[10:18:27.339]     }, args = future.call.arguments)
[10:18:27.339] }
[10:18:27.339] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.340] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.340] 
[10:18:27.340] getGlobalsAndPackages() ... DONE
[10:18:27.341] run() for ‘Future’ ...
[10:18:27.341] - state: ‘created’
[10:18:27.341] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.344] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.344] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.344]   - Field: ‘label’
[10:18:27.344]   - Field: ‘local’
[10:18:27.344]   - Field: ‘owner’
[10:18:27.345]   - Field: ‘envir’
[10:18:27.345]   - Field: ‘workers’
[10:18:27.345]   - Field: ‘packages’
[10:18:27.345]   - Field: ‘gc’
[10:18:27.345]   - Field: ‘job’
[10:18:27.345]   - Field: ‘conditions’
[10:18:27.345]   - Field: ‘expr’
[10:18:27.345]   - Field: ‘uuid’
[10:18:27.346]   - Field: ‘seed’
[10:18:27.346]   - Field: ‘version’
[10:18:27.346]   - Field: ‘result’
[10:18:27.346]   - Field: ‘asynchronous’
[10:18:27.346]   - Field: ‘calls’
[10:18:27.346]   - Field: ‘globals’
[10:18:27.346]   - Field: ‘stdout’
[10:18:27.347]   - Field: ‘earlySignal’
[10:18:27.347]   - Field: ‘lazy’
[10:18:27.347]   - Field: ‘state’
[10:18:27.347] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.350] - Launch lazy future ...
[10:18:27.351] Packages needed by the future expression (n = 0): <none>
[10:18:27.352] Packages needed by future strategies (n = 0): <none>
[10:18:27.353] {
[10:18:27.353]     {
[10:18:27.353]         {
[10:18:27.353]             ...future.startTime <- base::Sys.time()
[10:18:27.353]             {
[10:18:27.353]                 {
[10:18:27.353]                   {
[10:18:27.353]                     {
[10:18:27.353]                       base::local({
[10:18:27.353]                         has_future <- base::requireNamespace("future", 
[10:18:27.353]                           quietly = TRUE)
[10:18:27.353]                         if (has_future) {
[10:18:27.353]                           ns <- base::getNamespace("future")
[10:18:27.353]                           version <- ns[[".package"]][["version"]]
[10:18:27.353]                           if (is.null(version)) 
[10:18:27.353]                             version <- utils::packageVersion("future")
[10:18:27.353]                         }
[10:18:27.353]                         else {
[10:18:27.353]                           version <- NULL
[10:18:27.353]                         }
[10:18:27.353]                         if (!has_future || version < "1.8.0") {
[10:18:27.353]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.353]                             "", base::R.version$version.string), 
[10:18:27.353]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.353]                               "release", "version")], collapse = " "), 
[10:18:27.353]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.353]                             info)
[10:18:27.353]                           info <- base::paste(info, collapse = "; ")
[10:18:27.353]                           if (!has_future) {
[10:18:27.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.353]                               info)
[10:18:27.353]                           }
[10:18:27.353]                           else {
[10:18:27.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.353]                               info, version)
[10:18:27.353]                           }
[10:18:27.353]                           base::stop(msg)
[10:18:27.353]                         }
[10:18:27.353]                       })
[10:18:27.353]                     }
[10:18:27.353]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.353]                     base::options(mc.cores = 1L)
[10:18:27.353]                   }
[10:18:27.353]                   ...future.strategy.old <- future::plan("list")
[10:18:27.353]                   options(future.plan = NULL)
[10:18:27.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.353]                 }
[10:18:27.353]                 ...future.workdir <- getwd()
[10:18:27.353]             }
[10:18:27.353]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.353]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.353]         }
[10:18:27.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.353]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.353]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.353]             base::names(...future.oldOptions))
[10:18:27.353]     }
[10:18:27.353]     if (FALSE) {
[10:18:27.353]     }
[10:18:27.353]     else {
[10:18:27.353]         if (TRUE) {
[10:18:27.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.353]                 open = "w")
[10:18:27.353]         }
[10:18:27.353]         else {
[10:18:27.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.353]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.353]         }
[10:18:27.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.353]             base::sink(type = "output", split = FALSE)
[10:18:27.353]             base::close(...future.stdout)
[10:18:27.353]         }, add = TRUE)
[10:18:27.353]     }
[10:18:27.353]     ...future.frame <- base::sys.nframe()
[10:18:27.353]     ...future.conditions <- base::list()
[10:18:27.353]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.353]     if (FALSE) {
[10:18:27.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.353]     }
[10:18:27.353]     ...future.result <- base::tryCatch({
[10:18:27.353]         base::withCallingHandlers({
[10:18:27.353]             ...future.value <- base::withVisible(base::local({
[10:18:27.353]                 withCallingHandlers({
[10:18:27.353]                   {
[10:18:27.353]                     do.call(function(...) {
[10:18:27.353]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.353]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.353]                         ...future.globals.maxSize)) {
[10:18:27.353]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.353]                         on.exit(options(oopts), add = TRUE)
[10:18:27.353]                       }
[10:18:27.353]                       {
[10:18:27.353]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.353]                           FUN = function(jj) {
[10:18:27.353]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.353]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.353]                           })
[10:18:27.353]                       }
[10:18:27.353]                     }, args = future.call.arguments)
[10:18:27.353]                   }
[10:18:27.353]                 }, immediateCondition = function(cond) {
[10:18:27.353]                   save_rds <- function (object, pathname, ...) 
[10:18:27.353]                   {
[10:18:27.353]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.353]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.353]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.353]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.353]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.353]                         fi_tmp[["mtime"]])
[10:18:27.353]                     }
[10:18:27.353]                     tryCatch({
[10:18:27.353]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.353]                     }, error = function(ex) {
[10:18:27.353]                       msg <- conditionMessage(ex)
[10:18:27.353]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.353]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.353]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.353]                         fi_tmp[["mtime"]], msg)
[10:18:27.353]                       ex$message <- msg
[10:18:27.353]                       stop(ex)
[10:18:27.353]                     })
[10:18:27.353]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.353]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.353]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.353]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.353]                       fi <- file.info(pathname)
[10:18:27.353]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.353]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.353]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.353]                         fi[["size"]], fi[["mtime"]])
[10:18:27.353]                       stop(msg)
[10:18:27.353]                     }
[10:18:27.353]                     invisible(pathname)
[10:18:27.353]                   }
[10:18:27.353]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.353]                     rootPath = tempdir()) 
[10:18:27.353]                   {
[10:18:27.353]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.353]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.353]                       tmpdir = path, fileext = ".rds")
[10:18:27.353]                     save_rds(obj, file)
[10:18:27.353]                   }
[10:18:27.353]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.353]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.353]                   {
[10:18:27.353]                     inherits <- base::inherits
[10:18:27.353]                     invokeRestart <- base::invokeRestart
[10:18:27.353]                     is.null <- base::is.null
[10:18:27.353]                     muffled <- FALSE
[10:18:27.353]                     if (inherits(cond, "message")) {
[10:18:27.353]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.353]                       if (muffled) 
[10:18:27.353]                         invokeRestart("muffleMessage")
[10:18:27.353]                     }
[10:18:27.353]                     else if (inherits(cond, "warning")) {
[10:18:27.353]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.353]                       if (muffled) 
[10:18:27.353]                         invokeRestart("muffleWarning")
[10:18:27.353]                     }
[10:18:27.353]                     else if (inherits(cond, "condition")) {
[10:18:27.353]                       if (!is.null(pattern)) {
[10:18:27.353]                         computeRestarts <- base::computeRestarts
[10:18:27.353]                         grepl <- base::grepl
[10:18:27.353]                         restarts <- computeRestarts(cond)
[10:18:27.353]                         for (restart in restarts) {
[10:18:27.353]                           name <- restart$name
[10:18:27.353]                           if (is.null(name)) 
[10:18:27.353]                             next
[10:18:27.353]                           if (!grepl(pattern, name)) 
[10:18:27.353]                             next
[10:18:27.353]                           invokeRestart(restart)
[10:18:27.353]                           muffled <- TRUE
[10:18:27.353]                           break
[10:18:27.353]                         }
[10:18:27.353]                       }
[10:18:27.353]                     }
[10:18:27.353]                     invisible(muffled)
[10:18:27.353]                   }
[10:18:27.353]                   muffleCondition(cond)
[10:18:27.353]                 })
[10:18:27.353]             }))
[10:18:27.353]             future::FutureResult(value = ...future.value$value, 
[10:18:27.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.353]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.353]                     ...future.globalenv.names))
[10:18:27.353]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.353]         }, condition = base::local({
[10:18:27.353]             c <- base::c
[10:18:27.353]             inherits <- base::inherits
[10:18:27.353]             invokeRestart <- base::invokeRestart
[10:18:27.353]             length <- base::length
[10:18:27.353]             list <- base::list
[10:18:27.353]             seq.int <- base::seq.int
[10:18:27.353]             signalCondition <- base::signalCondition
[10:18:27.353]             sys.calls <- base::sys.calls
[10:18:27.353]             `[[` <- base::`[[`
[10:18:27.353]             `+` <- base::`+`
[10:18:27.353]             `<<-` <- base::`<<-`
[10:18:27.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.353]                   3L)]
[10:18:27.353]             }
[10:18:27.353]             function(cond) {
[10:18:27.353]                 is_error <- inherits(cond, "error")
[10:18:27.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.353]                   NULL)
[10:18:27.353]                 if (is_error) {
[10:18:27.353]                   sessionInformation <- function() {
[10:18:27.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.353]                       search = base::search(), system = base::Sys.info())
[10:18:27.353]                   }
[10:18:27.353]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.353]                     cond$call), session = sessionInformation(), 
[10:18:27.353]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.353]                   signalCondition(cond)
[10:18:27.353]                 }
[10:18:27.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.353]                 "immediateCondition"))) {
[10:18:27.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.353]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.353]                   if (TRUE && !signal) {
[10:18:27.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.353]                     {
[10:18:27.353]                       inherits <- base::inherits
[10:18:27.353]                       invokeRestart <- base::invokeRestart
[10:18:27.353]                       is.null <- base::is.null
[10:18:27.353]                       muffled <- FALSE
[10:18:27.353]                       if (inherits(cond, "message")) {
[10:18:27.353]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.353]                         if (muffled) 
[10:18:27.353]                           invokeRestart("muffleMessage")
[10:18:27.353]                       }
[10:18:27.353]                       else if (inherits(cond, "warning")) {
[10:18:27.353]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.353]                         if (muffled) 
[10:18:27.353]                           invokeRestart("muffleWarning")
[10:18:27.353]                       }
[10:18:27.353]                       else if (inherits(cond, "condition")) {
[10:18:27.353]                         if (!is.null(pattern)) {
[10:18:27.353]                           computeRestarts <- base::computeRestarts
[10:18:27.353]                           grepl <- base::grepl
[10:18:27.353]                           restarts <- computeRestarts(cond)
[10:18:27.353]                           for (restart in restarts) {
[10:18:27.353]                             name <- restart$name
[10:18:27.353]                             if (is.null(name)) 
[10:18:27.353]                               next
[10:18:27.353]                             if (!grepl(pattern, name)) 
[10:18:27.353]                               next
[10:18:27.353]                             invokeRestart(restart)
[10:18:27.353]                             muffled <- TRUE
[10:18:27.353]                             break
[10:18:27.353]                           }
[10:18:27.353]                         }
[10:18:27.353]                       }
[10:18:27.353]                       invisible(muffled)
[10:18:27.353]                     }
[10:18:27.353]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.353]                   }
[10:18:27.353]                 }
[10:18:27.353]                 else {
[10:18:27.353]                   if (TRUE) {
[10:18:27.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.353]                     {
[10:18:27.353]                       inherits <- base::inherits
[10:18:27.353]                       invokeRestart <- base::invokeRestart
[10:18:27.353]                       is.null <- base::is.null
[10:18:27.353]                       muffled <- FALSE
[10:18:27.353]                       if (inherits(cond, "message")) {
[10:18:27.353]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.353]                         if (muffled) 
[10:18:27.353]                           invokeRestart("muffleMessage")
[10:18:27.353]                       }
[10:18:27.353]                       else if (inherits(cond, "warning")) {
[10:18:27.353]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.353]                         if (muffled) 
[10:18:27.353]                           invokeRestart("muffleWarning")
[10:18:27.353]                       }
[10:18:27.353]                       else if (inherits(cond, "condition")) {
[10:18:27.353]                         if (!is.null(pattern)) {
[10:18:27.353]                           computeRestarts <- base::computeRestarts
[10:18:27.353]                           grepl <- base::grepl
[10:18:27.353]                           restarts <- computeRestarts(cond)
[10:18:27.353]                           for (restart in restarts) {
[10:18:27.353]                             name <- restart$name
[10:18:27.353]                             if (is.null(name)) 
[10:18:27.353]                               next
[10:18:27.353]                             if (!grepl(pattern, name)) 
[10:18:27.353]                               next
[10:18:27.353]                             invokeRestart(restart)
[10:18:27.353]                             muffled <- TRUE
[10:18:27.353]                             break
[10:18:27.353]                           }
[10:18:27.353]                         }
[10:18:27.353]                       }
[10:18:27.353]                       invisible(muffled)
[10:18:27.353]                     }
[10:18:27.353]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.353]                   }
[10:18:27.353]                 }
[10:18:27.353]             }
[10:18:27.353]         }))
[10:18:27.353]     }, error = function(ex) {
[10:18:27.353]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.353]                 ...future.rng), started = ...future.startTime, 
[10:18:27.353]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.353]             version = "1.8"), class = "FutureResult")
[10:18:27.353]     }, finally = {
[10:18:27.353]         if (!identical(...future.workdir, getwd())) 
[10:18:27.353]             setwd(...future.workdir)
[10:18:27.353]         {
[10:18:27.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.353]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.353]             }
[10:18:27.353]             base::options(...future.oldOptions)
[10:18:27.353]             if (.Platform$OS.type == "windows") {
[10:18:27.353]                 old_names <- names(...future.oldEnvVars)
[10:18:27.353]                 envs <- base::Sys.getenv()
[10:18:27.353]                 names <- names(envs)
[10:18:27.353]                 common <- intersect(names, old_names)
[10:18:27.353]                 added <- setdiff(names, old_names)
[10:18:27.353]                 removed <- setdiff(old_names, names)
[10:18:27.353]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.353]                   envs[common]]
[10:18:27.353]                 NAMES <- toupper(changed)
[10:18:27.353]                 args <- list()
[10:18:27.353]                 for (kk in seq_along(NAMES)) {
[10:18:27.353]                   name <- changed[[kk]]
[10:18:27.353]                   NAME <- NAMES[[kk]]
[10:18:27.353]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.353]                     next
[10:18:27.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.353]                 }
[10:18:27.353]                 NAMES <- toupper(added)
[10:18:27.353]                 for (kk in seq_along(NAMES)) {
[10:18:27.353]                   name <- added[[kk]]
[10:18:27.353]                   NAME <- NAMES[[kk]]
[10:18:27.353]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.353]                     next
[10:18:27.353]                   args[[name]] <- ""
[10:18:27.353]                 }
[10:18:27.353]                 NAMES <- toupper(removed)
[10:18:27.353]                 for (kk in seq_along(NAMES)) {
[10:18:27.353]                   name <- removed[[kk]]
[10:18:27.353]                   NAME <- NAMES[[kk]]
[10:18:27.353]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.353]                     next
[10:18:27.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.353]                 }
[10:18:27.353]                 if (length(args) > 0) 
[10:18:27.353]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.353]             }
[10:18:27.353]             else {
[10:18:27.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.353]             }
[10:18:27.353]             {
[10:18:27.353]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.353]                   0L) {
[10:18:27.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.353]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.353]                   base::options(opts)
[10:18:27.353]                 }
[10:18:27.353]                 {
[10:18:27.353]                   {
[10:18:27.353]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.353]                     NULL
[10:18:27.353]                   }
[10:18:27.353]                   options(future.plan = NULL)
[10:18:27.353]                   if (is.na(NA_character_)) 
[10:18:27.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.353]                     .init = FALSE)
[10:18:27.353]                 }
[10:18:27.353]             }
[10:18:27.353]         }
[10:18:27.353]     })
[10:18:27.353]     if (TRUE) {
[10:18:27.353]         base::sink(type = "output", split = FALSE)
[10:18:27.353]         if (TRUE) {
[10:18:27.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.353]         }
[10:18:27.353]         else {
[10:18:27.353]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.353]         }
[10:18:27.353]         base::close(...future.stdout)
[10:18:27.353]         ...future.stdout <- NULL
[10:18:27.353]     }
[10:18:27.353]     ...future.result$conditions <- ...future.conditions
[10:18:27.353]     ...future.result$finished <- base::Sys.time()
[10:18:27.353]     ...future.result
[10:18:27.353] }
[10:18:27.357] assign_globals() ...
[10:18:27.357] List of 5
[10:18:27.357]  $ future.call.arguments    : list()
[10:18:27.357]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.357]  $ ...future.FUN            :function (x)  
[10:18:27.357]  $ ...future.elements_ii    :List of 3
[10:18:27.357]   ..$ : int [1:4] 4 10 16 22
[10:18:27.357]   ..$ : int [1:4] 5 11 17 23
[10:18:27.357]   ..$ : int [1:4] 6 12 18 24
[10:18:27.357]  $ ...future.seeds_ii       : NULL
[10:18:27.357]  $ ...future.globals.maxSize: num Inf
[10:18:27.357]  - attr(*, "resolved")= logi FALSE
[10:18:27.357]  - attr(*, "total_size")= num NA
[10:18:27.357]  - attr(*, "where")=List of 5
[10:18:27.357]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.357]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.357]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.357]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.357]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.357]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.357]  - attr(*, "already-done")= logi TRUE
[10:18:27.367] - copied ‘future.call.arguments’ to environment
[10:18:27.367] - reassign environment for ‘...future.FUN’
[10:18:27.367] - copied ‘...future.FUN’ to environment
[10:18:27.367] - copied ‘...future.elements_ii’ to environment
[10:18:27.367] - copied ‘...future.seeds_ii’ to environment
[10:18:27.367] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.368] assign_globals() ... done
[10:18:27.368] requestCore(): workers = 2
[10:18:27.370] MulticoreFuture started
[10:18:27.371] - Launch lazy future ... done
[10:18:27.371] run() for ‘MulticoreFuture’ ... done
[10:18:27.371] Created future:
[10:18:27.371] plan(): Setting new future strategy stack:
[10:18:27.372] List of future strategies:
[10:18:27.372] 1. sequential:
[10:18:27.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.372]    - tweaked: FALSE
[10:18:27.372]    - call: NULL
[10:18:27.372] plan(): nbrOfWorkers() = 1
[10:18:27.375] plan(): Setting new future strategy stack:
[10:18:27.375] List of future strategies:
[10:18:27.375] 1. multicore:
[10:18:27.375]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.375]    - tweaked: FALSE
[10:18:27.375]    - call: plan(strategy)
[10:18:27.378] plan(): nbrOfWorkers() = 2
[10:18:27.371] MulticoreFuture:
[10:18:27.371] Label: ‘future_apply-2’
[10:18:27.371] Expression:
[10:18:27.371] {
[10:18:27.371]     do.call(function(...) {
[10:18:27.371]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.371]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.371]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.371]             on.exit(options(oopts), add = TRUE)
[10:18:27.371]         }
[10:18:27.371]         {
[10:18:27.371]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.371]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.371]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.371]             })
[10:18:27.371]         }
[10:18:27.371]     }, args = future.call.arguments)
[10:18:27.371] }
[10:18:27.371] Lazy evaluation: FALSE
[10:18:27.371] Asynchronous evaluation: TRUE
[10:18:27.371] Local evaluation: TRUE
[10:18:27.371] Environment: R_GlobalEnv
[10:18:27.371] Capture standard output: TRUE
[10:18:27.371] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.371] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.371] Packages: <none>
[10:18:27.371] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.371] Resolved: TRUE
[10:18:27.371] Value: <not collected>
[10:18:27.371] Conditions captured: <none>
[10:18:27.371] Early signaling: FALSE
[10:18:27.371] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.371] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.379] Chunk #2 of 2 ... DONE
[10:18:27.379] Launching 2 futures (chunks) ... DONE
[10:18:27.379] Resolving 2 futures (chunks) ...
[10:18:27.380] resolve() on list ...
[10:18:27.380]  recursive: 0
[10:18:27.380]  length: 2
[10:18:27.380] 
[10:18:27.380] Future #1
[10:18:27.381] result() for MulticoreFuture ...
[10:18:27.381] result() for MulticoreFuture ...
[10:18:27.382] result() for MulticoreFuture ... done
[10:18:27.382] result() for MulticoreFuture ... done
[10:18:27.382] result() for MulticoreFuture ...
[10:18:27.382] result() for MulticoreFuture ... done
[10:18:27.382] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:27.382] - nx: 2
[10:18:27.382] - relay: TRUE
[10:18:27.383] - stdout: TRUE
[10:18:27.383] - signal: TRUE
[10:18:27.383] - resignal: FALSE
[10:18:27.383] - force: TRUE
[10:18:27.383] - relayed: [n=2] FALSE, FALSE
[10:18:27.383] - queued futures: [n=2] FALSE, FALSE
[10:18:27.383]  - until=1
[10:18:27.384]  - relaying element #1
[10:18:27.384] result() for MulticoreFuture ...
[10:18:27.384] result() for MulticoreFuture ... done
[10:18:27.384] result() for MulticoreFuture ...
[10:18:27.384] result() for MulticoreFuture ... done
[10:18:27.384] result() for MulticoreFuture ...
[10:18:27.385] result() for MulticoreFuture ... done
[10:18:27.385] result() for MulticoreFuture ...
[10:18:27.385] result() for MulticoreFuture ... done
[10:18:27.385] - relayed: [n=2] TRUE, FALSE
[10:18:27.385] - queued futures: [n=2] TRUE, FALSE
[10:18:27.385] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:27.385]  length: 1 (resolved future 1)
[10:18:27.386] Future #2
[10:18:27.386] result() for MulticoreFuture ...
[10:18:27.387] result() for MulticoreFuture ...
[10:18:27.387] result() for MulticoreFuture ... done
[10:18:27.387] result() for MulticoreFuture ... done
[10:18:27.387] result() for MulticoreFuture ...
[10:18:27.387] result() for MulticoreFuture ... done
[10:18:27.387] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:27.388] - nx: 2
[10:18:27.388] - relay: TRUE
[10:18:27.388] - stdout: TRUE
[10:18:27.388] - signal: TRUE
[10:18:27.388] - resignal: FALSE
[10:18:27.388] - force: TRUE
[10:18:27.388] - relayed: [n=2] TRUE, FALSE
[10:18:27.388] - queued futures: [n=2] TRUE, FALSE
[10:18:27.389]  - until=2
[10:18:27.389]  - relaying element #2
[10:18:27.389] result() for MulticoreFuture ...
[10:18:27.389] result() for MulticoreFuture ... done
[10:18:27.389] result() for MulticoreFuture ...
[10:18:27.389] result() for MulticoreFuture ... done
[10:18:27.389] result() for MulticoreFuture ...
[10:18:27.389] result() for MulticoreFuture ... done
[10:18:27.390] result() for MulticoreFuture ...
[10:18:27.390] result() for MulticoreFuture ... done
[10:18:27.390] - relayed: [n=2] TRUE, TRUE
[10:18:27.390] - queued futures: [n=2] TRUE, TRUE
[10:18:27.390] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:27.390]  length: 0 (resolved future 2)
[10:18:27.390] Relaying remaining futures
[10:18:27.390] signalConditionsASAP(NULL, pos=0) ...
[10:18:27.390] - nx: 2
[10:18:27.390] - relay: TRUE
[10:18:27.391] - stdout: TRUE
[10:18:27.391] - signal: TRUE
[10:18:27.391] - resignal: FALSE
[10:18:27.391] - force: TRUE
[10:18:27.391] - relayed: [n=2] TRUE, TRUE
[10:18:27.391] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:27.391] - relayed: [n=2] TRUE, TRUE
[10:18:27.391] - queued futures: [n=2] TRUE, TRUE
[10:18:27.391] signalConditionsASAP(NULL, pos=0) ... done
[10:18:27.392] resolve() on list ... DONE
[10:18:27.392] result() for MulticoreFuture ...
[10:18:27.392] result() for MulticoreFuture ... done
[10:18:27.392] result() for MulticoreFuture ...
[10:18:27.392] result() for MulticoreFuture ... done
[10:18:27.392] result() for MulticoreFuture ...
[10:18:27.392] result() for MulticoreFuture ... done
[10:18:27.392] result() for MulticoreFuture ...
[10:18:27.392] result() for MulticoreFuture ... done
[10:18:27.393]  - Number of value chunks collected: 2
[10:18:27.393] Resolving 2 futures (chunks) ... DONE
[10:18:27.393] Reducing values from 2 chunks ...
[10:18:27.393]  - Number of values collected after concatenation: 6
[10:18:27.393]  - Number of values expected: 6
[10:18:27.393] Reducing values from 2 chunks ... DONE
[10:18:27.393] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:18:27.394] getGlobalsAndPackagesXApply() ...
[10:18:27.394]  - future.globals: TRUE
[10:18:27.394] getGlobalsAndPackages() ...
[10:18:27.394] Searching for globals...
[10:18:27.398] - globals found: [1] ‘FUN’
[10:18:27.398] Searching for globals ... DONE
[10:18:27.399] Resolving globals: FALSE
[10:18:27.399] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:27.400] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:27.400] - globals: [1] ‘FUN’
[10:18:27.400] 
[10:18:27.400] getGlobalsAndPackages() ... DONE
[10:18:27.400]  - globals found/used: [n=1] ‘FUN’
[10:18:27.401]  - needed namespaces: [n=0] 
[10:18:27.401] Finding globals ... DONE
[10:18:27.401]  - use_args: TRUE
[10:18:27.401]  - Getting '...' globals ...
[10:18:27.402] resolve() on list ...
[10:18:27.402]  recursive: 0
[10:18:27.402]  length: 1
[10:18:27.402]  elements: ‘...’
[10:18:27.402]  length: 0 (resolved future 1)
[10:18:27.402] resolve() on list ... DONE
[10:18:27.402]    - '...' content: [n=0] 
[10:18:27.403] List of 1
[10:18:27.403]  $ ...: list()
[10:18:27.403]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.403]  - attr(*, "where")=List of 1
[10:18:27.403]   ..$ ...:<environment: 0x556e03c88238> 
[10:18:27.403]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.403]  - attr(*, "resolved")= logi TRUE
[10:18:27.403]  - attr(*, "total_size")= num NA
[10:18:27.405]  - Getting '...' globals ... DONE
[10:18:27.406] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:27.406] List of 2
[10:18:27.406]  $ ...future.FUN:function (x)  
[10:18:27.406]  $ ...          : list()
[10:18:27.406]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.406]  - attr(*, "where")=List of 2
[10:18:27.406]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:27.406]   ..$ ...          :<environment: 0x556e03c88238> 
[10:18:27.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.406]  - attr(*, "resolved")= logi FALSE
[10:18:27.406]  - attr(*, "total_size")= num 2547
[10:18:27.409] Packages to be attached in all futures: [n=0] 
[10:18:27.409] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.411] future_lapply() ...
[10:18:27.413] Number of chunks: 2
[10:18:27.413] getGlobalsAndPackagesXApply() ...
[10:18:27.413]  - future.globals: <name-value list> with names ‘list()’
[10:18:27.413]  - use_args: TRUE
[10:18:27.413] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:27.413] List of 2
[10:18:27.413]  $ ...          : list()
[10:18:27.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.413]  $ ...future.FUN:function (x)  
[10:18:27.413]  - attr(*, "where")=List of 2
[10:18:27.413]   ..$ ...          :<environment: 0x556e03c88238> 
[10:18:27.413]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:27.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.413]  - attr(*, "resolved")= logi FALSE
[10:18:27.413]  - attr(*, "total_size")= num NA
[10:18:27.417] Packages to be attached in all futures: [n=0] 
[10:18:27.417] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.417] Number of futures (= number of chunks): 2
[10:18:27.417] Launching 2 futures (chunks) ...
[10:18:27.417] Chunk #1 of 2 ...
[10:18:27.418]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.418]  - seeds: <none>
[10:18:27.418]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.418] getGlobalsAndPackages() ...
[10:18:27.418] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.418] Resolving globals: FALSE
[10:18:27.418] Tweak future expression to call with '...' arguments ...
[10:18:27.418] {
[10:18:27.418]     do.call(function(...) {
[10:18:27.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.418]             on.exit(options(oopts), add = TRUE)
[10:18:27.418]         }
[10:18:27.418]         {
[10:18:27.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.418]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.418]             })
[10:18:27.418]         }
[10:18:27.418]     }, args = future.call.arguments)
[10:18:27.418] }
[10:18:27.419] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.419] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.419] 
[10:18:27.419] getGlobalsAndPackages() ... DONE
[10:18:27.420] run() for ‘Future’ ...
[10:18:27.420] - state: ‘created’
[10:18:27.420] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.421] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.422]   - Field: ‘label’
[10:18:27.422]   - Field: ‘local’
[10:18:27.422]   - Field: ‘owner’
[10:18:27.422]   - Field: ‘envir’
[10:18:27.422]   - Field: ‘workers’
[10:18:27.422]   - Field: ‘packages’
[10:18:27.422]   - Field: ‘gc’
[10:18:27.422]   - Field: ‘job’
[10:18:27.422]   - Field: ‘conditions’
[10:18:27.423]   - Field: ‘expr’
[10:18:27.423]   - Field: ‘uuid’
[10:18:27.423]   - Field: ‘seed’
[10:18:27.423]   - Field: ‘version’
[10:18:27.423]   - Field: ‘result’
[10:18:27.423]   - Field: ‘asynchronous’
[10:18:27.425]   - Field: ‘calls’
[10:18:27.425]   - Field: ‘globals’
[10:18:27.425]   - Field: ‘stdout’
[10:18:27.425]   - Field: ‘earlySignal’
[10:18:27.425]   - Field: ‘lazy’
[10:18:27.425]   - Field: ‘state’
[10:18:27.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.426] - Launch lazy future ...
[10:18:27.426] Packages needed by the future expression (n = 0): <none>
[10:18:27.426] Packages needed by future strategies (n = 0): <none>
[10:18:27.427] {
[10:18:27.427]     {
[10:18:27.427]         {
[10:18:27.427]             ...future.startTime <- base::Sys.time()
[10:18:27.427]             {
[10:18:27.427]                 {
[10:18:27.427]                   {
[10:18:27.427]                     {
[10:18:27.427]                       base::local({
[10:18:27.427]                         has_future <- base::requireNamespace("future", 
[10:18:27.427]                           quietly = TRUE)
[10:18:27.427]                         if (has_future) {
[10:18:27.427]                           ns <- base::getNamespace("future")
[10:18:27.427]                           version <- ns[[".package"]][["version"]]
[10:18:27.427]                           if (is.null(version)) 
[10:18:27.427]                             version <- utils::packageVersion("future")
[10:18:27.427]                         }
[10:18:27.427]                         else {
[10:18:27.427]                           version <- NULL
[10:18:27.427]                         }
[10:18:27.427]                         if (!has_future || version < "1.8.0") {
[10:18:27.427]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.427]                             "", base::R.version$version.string), 
[10:18:27.427]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.427]                               "release", "version")], collapse = " "), 
[10:18:27.427]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.427]                             info)
[10:18:27.427]                           info <- base::paste(info, collapse = "; ")
[10:18:27.427]                           if (!has_future) {
[10:18:27.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.427]                               info)
[10:18:27.427]                           }
[10:18:27.427]                           else {
[10:18:27.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.427]                               info, version)
[10:18:27.427]                           }
[10:18:27.427]                           base::stop(msg)
[10:18:27.427]                         }
[10:18:27.427]                       })
[10:18:27.427]                     }
[10:18:27.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.427]                     base::options(mc.cores = 1L)
[10:18:27.427]                   }
[10:18:27.427]                   ...future.strategy.old <- future::plan("list")
[10:18:27.427]                   options(future.plan = NULL)
[10:18:27.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.427]                 }
[10:18:27.427]                 ...future.workdir <- getwd()
[10:18:27.427]             }
[10:18:27.427]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.427]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.427]         }
[10:18:27.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.427]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.427]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.427]             base::names(...future.oldOptions))
[10:18:27.427]     }
[10:18:27.427]     if (FALSE) {
[10:18:27.427]     }
[10:18:27.427]     else {
[10:18:27.427]         if (TRUE) {
[10:18:27.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.427]                 open = "w")
[10:18:27.427]         }
[10:18:27.427]         else {
[10:18:27.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.427]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.427]         }
[10:18:27.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.427]             base::sink(type = "output", split = FALSE)
[10:18:27.427]             base::close(...future.stdout)
[10:18:27.427]         }, add = TRUE)
[10:18:27.427]     }
[10:18:27.427]     ...future.frame <- base::sys.nframe()
[10:18:27.427]     ...future.conditions <- base::list()
[10:18:27.427]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.427]     if (FALSE) {
[10:18:27.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.427]     }
[10:18:27.427]     ...future.result <- base::tryCatch({
[10:18:27.427]         base::withCallingHandlers({
[10:18:27.427]             ...future.value <- base::withVisible(base::local({
[10:18:27.427]                 withCallingHandlers({
[10:18:27.427]                   {
[10:18:27.427]                     do.call(function(...) {
[10:18:27.427]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.427]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.427]                         ...future.globals.maxSize)) {
[10:18:27.427]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.427]                         on.exit(options(oopts), add = TRUE)
[10:18:27.427]                       }
[10:18:27.427]                       {
[10:18:27.427]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.427]                           FUN = function(jj) {
[10:18:27.427]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.427]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.427]                           })
[10:18:27.427]                       }
[10:18:27.427]                     }, args = future.call.arguments)
[10:18:27.427]                   }
[10:18:27.427]                 }, immediateCondition = function(cond) {
[10:18:27.427]                   save_rds <- function (object, pathname, ...) 
[10:18:27.427]                   {
[10:18:27.427]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.427]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.427]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.427]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.427]                         fi_tmp[["mtime"]])
[10:18:27.427]                     }
[10:18:27.427]                     tryCatch({
[10:18:27.427]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.427]                     }, error = function(ex) {
[10:18:27.427]                       msg <- conditionMessage(ex)
[10:18:27.427]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.427]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.427]                         fi_tmp[["mtime"]], msg)
[10:18:27.427]                       ex$message <- msg
[10:18:27.427]                       stop(ex)
[10:18:27.427]                     })
[10:18:27.427]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.427]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.427]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.427]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.427]                       fi <- file.info(pathname)
[10:18:27.427]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.427]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.427]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.427]                         fi[["size"]], fi[["mtime"]])
[10:18:27.427]                       stop(msg)
[10:18:27.427]                     }
[10:18:27.427]                     invisible(pathname)
[10:18:27.427]                   }
[10:18:27.427]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.427]                     rootPath = tempdir()) 
[10:18:27.427]                   {
[10:18:27.427]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.427]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.427]                       tmpdir = path, fileext = ".rds")
[10:18:27.427]                     save_rds(obj, file)
[10:18:27.427]                   }
[10:18:27.427]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.427]                   {
[10:18:27.427]                     inherits <- base::inherits
[10:18:27.427]                     invokeRestart <- base::invokeRestart
[10:18:27.427]                     is.null <- base::is.null
[10:18:27.427]                     muffled <- FALSE
[10:18:27.427]                     if (inherits(cond, "message")) {
[10:18:27.427]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.427]                       if (muffled) 
[10:18:27.427]                         invokeRestart("muffleMessage")
[10:18:27.427]                     }
[10:18:27.427]                     else if (inherits(cond, "warning")) {
[10:18:27.427]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.427]                       if (muffled) 
[10:18:27.427]                         invokeRestart("muffleWarning")
[10:18:27.427]                     }
[10:18:27.427]                     else if (inherits(cond, "condition")) {
[10:18:27.427]                       if (!is.null(pattern)) {
[10:18:27.427]                         computeRestarts <- base::computeRestarts
[10:18:27.427]                         grepl <- base::grepl
[10:18:27.427]                         restarts <- computeRestarts(cond)
[10:18:27.427]                         for (restart in restarts) {
[10:18:27.427]                           name <- restart$name
[10:18:27.427]                           if (is.null(name)) 
[10:18:27.427]                             next
[10:18:27.427]                           if (!grepl(pattern, name)) 
[10:18:27.427]                             next
[10:18:27.427]                           invokeRestart(restart)
[10:18:27.427]                           muffled <- TRUE
[10:18:27.427]                           break
[10:18:27.427]                         }
[10:18:27.427]                       }
[10:18:27.427]                     }
[10:18:27.427]                     invisible(muffled)
[10:18:27.427]                   }
[10:18:27.427]                   muffleCondition(cond)
[10:18:27.427]                 })
[10:18:27.427]             }))
[10:18:27.427]             future::FutureResult(value = ...future.value$value, 
[10:18:27.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.427]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.427]                     ...future.globalenv.names))
[10:18:27.427]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.427]         }, condition = base::local({
[10:18:27.427]             c <- base::c
[10:18:27.427]             inherits <- base::inherits
[10:18:27.427]             invokeRestart <- base::invokeRestart
[10:18:27.427]             length <- base::length
[10:18:27.427]             list <- base::list
[10:18:27.427]             seq.int <- base::seq.int
[10:18:27.427]             signalCondition <- base::signalCondition
[10:18:27.427]             sys.calls <- base::sys.calls
[10:18:27.427]             `[[` <- base::`[[`
[10:18:27.427]             `+` <- base::`+`
[10:18:27.427]             `<<-` <- base::`<<-`
[10:18:27.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.427]                   3L)]
[10:18:27.427]             }
[10:18:27.427]             function(cond) {
[10:18:27.427]                 is_error <- inherits(cond, "error")
[10:18:27.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.427]                   NULL)
[10:18:27.427]                 if (is_error) {
[10:18:27.427]                   sessionInformation <- function() {
[10:18:27.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.427]                       search = base::search(), system = base::Sys.info())
[10:18:27.427]                   }
[10:18:27.427]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.427]                     cond$call), session = sessionInformation(), 
[10:18:27.427]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.427]                   signalCondition(cond)
[10:18:27.427]                 }
[10:18:27.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.427]                 "immediateCondition"))) {
[10:18:27.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.427]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.427]                   if (TRUE && !signal) {
[10:18:27.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.427]                     {
[10:18:27.427]                       inherits <- base::inherits
[10:18:27.427]                       invokeRestart <- base::invokeRestart
[10:18:27.427]                       is.null <- base::is.null
[10:18:27.427]                       muffled <- FALSE
[10:18:27.427]                       if (inherits(cond, "message")) {
[10:18:27.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.427]                         if (muffled) 
[10:18:27.427]                           invokeRestart("muffleMessage")
[10:18:27.427]                       }
[10:18:27.427]                       else if (inherits(cond, "warning")) {
[10:18:27.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.427]                         if (muffled) 
[10:18:27.427]                           invokeRestart("muffleWarning")
[10:18:27.427]                       }
[10:18:27.427]                       else if (inherits(cond, "condition")) {
[10:18:27.427]                         if (!is.null(pattern)) {
[10:18:27.427]                           computeRestarts <- base::computeRestarts
[10:18:27.427]                           grepl <- base::grepl
[10:18:27.427]                           restarts <- computeRestarts(cond)
[10:18:27.427]                           for (restart in restarts) {
[10:18:27.427]                             name <- restart$name
[10:18:27.427]                             if (is.null(name)) 
[10:18:27.427]                               next
[10:18:27.427]                             if (!grepl(pattern, name)) 
[10:18:27.427]                               next
[10:18:27.427]                             invokeRestart(restart)
[10:18:27.427]                             muffled <- TRUE
[10:18:27.427]                             break
[10:18:27.427]                           }
[10:18:27.427]                         }
[10:18:27.427]                       }
[10:18:27.427]                       invisible(muffled)
[10:18:27.427]                     }
[10:18:27.427]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.427]                   }
[10:18:27.427]                 }
[10:18:27.427]                 else {
[10:18:27.427]                   if (TRUE) {
[10:18:27.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.427]                     {
[10:18:27.427]                       inherits <- base::inherits
[10:18:27.427]                       invokeRestart <- base::invokeRestart
[10:18:27.427]                       is.null <- base::is.null
[10:18:27.427]                       muffled <- FALSE
[10:18:27.427]                       if (inherits(cond, "message")) {
[10:18:27.427]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.427]                         if (muffled) 
[10:18:27.427]                           invokeRestart("muffleMessage")
[10:18:27.427]                       }
[10:18:27.427]                       else if (inherits(cond, "warning")) {
[10:18:27.427]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.427]                         if (muffled) 
[10:18:27.427]                           invokeRestart("muffleWarning")
[10:18:27.427]                       }
[10:18:27.427]                       else if (inherits(cond, "condition")) {
[10:18:27.427]                         if (!is.null(pattern)) {
[10:18:27.427]                           computeRestarts <- base::computeRestarts
[10:18:27.427]                           grepl <- base::grepl
[10:18:27.427]                           restarts <- computeRestarts(cond)
[10:18:27.427]                           for (restart in restarts) {
[10:18:27.427]                             name <- restart$name
[10:18:27.427]                             if (is.null(name)) 
[10:18:27.427]                               next
[10:18:27.427]                             if (!grepl(pattern, name)) 
[10:18:27.427]                               next
[10:18:27.427]                             invokeRestart(restart)
[10:18:27.427]                             muffled <- TRUE
[10:18:27.427]                             break
[10:18:27.427]                           }
[10:18:27.427]                         }
[10:18:27.427]                       }
[10:18:27.427]                       invisible(muffled)
[10:18:27.427]                     }
[10:18:27.427]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.427]                   }
[10:18:27.427]                 }
[10:18:27.427]             }
[10:18:27.427]         }))
[10:18:27.427]     }, error = function(ex) {
[10:18:27.427]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.427]                 ...future.rng), started = ...future.startTime, 
[10:18:27.427]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.427]             version = "1.8"), class = "FutureResult")
[10:18:27.427]     }, finally = {
[10:18:27.427]         if (!identical(...future.workdir, getwd())) 
[10:18:27.427]             setwd(...future.workdir)
[10:18:27.427]         {
[10:18:27.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.427]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.427]             }
[10:18:27.427]             base::options(...future.oldOptions)
[10:18:27.427]             if (.Platform$OS.type == "windows") {
[10:18:27.427]                 old_names <- names(...future.oldEnvVars)
[10:18:27.427]                 envs <- base::Sys.getenv()
[10:18:27.427]                 names <- names(envs)
[10:18:27.427]                 common <- intersect(names, old_names)
[10:18:27.427]                 added <- setdiff(names, old_names)
[10:18:27.427]                 removed <- setdiff(old_names, names)
[10:18:27.427]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.427]                   envs[common]]
[10:18:27.427]                 NAMES <- toupper(changed)
[10:18:27.427]                 args <- list()
[10:18:27.427]                 for (kk in seq_along(NAMES)) {
[10:18:27.427]                   name <- changed[[kk]]
[10:18:27.427]                   NAME <- NAMES[[kk]]
[10:18:27.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.427]                     next
[10:18:27.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.427]                 }
[10:18:27.427]                 NAMES <- toupper(added)
[10:18:27.427]                 for (kk in seq_along(NAMES)) {
[10:18:27.427]                   name <- added[[kk]]
[10:18:27.427]                   NAME <- NAMES[[kk]]
[10:18:27.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.427]                     next
[10:18:27.427]                   args[[name]] <- ""
[10:18:27.427]                 }
[10:18:27.427]                 NAMES <- toupper(removed)
[10:18:27.427]                 for (kk in seq_along(NAMES)) {
[10:18:27.427]                   name <- removed[[kk]]
[10:18:27.427]                   NAME <- NAMES[[kk]]
[10:18:27.427]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.427]                     next
[10:18:27.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.427]                 }
[10:18:27.427]                 if (length(args) > 0) 
[10:18:27.427]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.427]             }
[10:18:27.427]             else {
[10:18:27.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.427]             }
[10:18:27.427]             {
[10:18:27.427]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.427]                   0L) {
[10:18:27.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.427]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.427]                   base::options(opts)
[10:18:27.427]                 }
[10:18:27.427]                 {
[10:18:27.427]                   {
[10:18:27.427]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.427]                     NULL
[10:18:27.427]                   }
[10:18:27.427]                   options(future.plan = NULL)
[10:18:27.427]                   if (is.na(NA_character_)) 
[10:18:27.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.427]                     .init = FALSE)
[10:18:27.427]                 }
[10:18:27.427]             }
[10:18:27.427]         }
[10:18:27.427]     })
[10:18:27.427]     if (TRUE) {
[10:18:27.427]         base::sink(type = "output", split = FALSE)
[10:18:27.427]         if (TRUE) {
[10:18:27.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.427]         }
[10:18:27.427]         else {
[10:18:27.427]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.427]         }
[10:18:27.427]         base::close(...future.stdout)
[10:18:27.427]         ...future.stdout <- NULL
[10:18:27.427]     }
[10:18:27.427]     ...future.result$conditions <- ...future.conditions
[10:18:27.427]     ...future.result$finished <- base::Sys.time()
[10:18:27.427]     ...future.result
[10:18:27.427] }
[10:18:27.429] assign_globals() ...
[10:18:27.429] List of 5
[10:18:27.429]  $ future.call.arguments    : list()
[10:18:27.429]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.429]  $ ...future.FUN            :function (x)  
[10:18:27.429]  $ ...future.elements_ii    :List of 1
[10:18:27.429]   ..$ : int 1
[10:18:27.429]  $ ...future.seeds_ii       : NULL
[10:18:27.429]  $ ...future.globals.maxSize: num Inf
[10:18:27.429]  - attr(*, "resolved")= logi FALSE
[10:18:27.429]  - attr(*, "total_size")= num NA
[10:18:27.429]  - attr(*, "where")=List of 5
[10:18:27.429]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.429]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.429]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.429]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.429]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.429]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.429]  - attr(*, "already-done")= logi TRUE
[10:18:27.434] - copied ‘future.call.arguments’ to environment
[10:18:27.434] - copied ‘...future.FUN’ to environment
[10:18:27.434] - copied ‘...future.elements_ii’ to environment
[10:18:27.434] - copied ‘...future.seeds_ii’ to environment
[10:18:27.434] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.435] assign_globals() ... done
[10:18:27.435] requestCore(): workers = 2
[10:18:27.437] MulticoreFuture started
[10:18:27.437] - Launch lazy future ... done
[10:18:27.438] run() for ‘MulticoreFuture’ ... done
[10:18:27.438] Created future:
[10:18:27.438] plan(): Setting new future strategy stack:
[10:18:27.438] List of future strategies:
[10:18:27.438] 1. sequential:
[10:18:27.438]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.438]    - tweaked: FALSE
[10:18:27.438]    - call: NULL
[10:18:27.439] plan(): nbrOfWorkers() = 1
[10:18:27.441] plan(): Setting new future strategy stack:
[10:18:27.441] List of future strategies:
[10:18:27.441] 1. multicore:
[10:18:27.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.441]    - tweaked: FALSE
[10:18:27.441]    - call: plan(strategy)
[10:18:27.445] plan(): nbrOfWorkers() = 2
[10:18:27.438] MulticoreFuture:
[10:18:27.438] Label: ‘future_apply-1’
[10:18:27.438] Expression:
[10:18:27.438] {
[10:18:27.438]     do.call(function(...) {
[10:18:27.438]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.438]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.438]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.438]             on.exit(options(oopts), add = TRUE)
[10:18:27.438]         }
[10:18:27.438]         {
[10:18:27.438]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.438]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.438]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.438]             })
[10:18:27.438]         }
[10:18:27.438]     }, args = future.call.arguments)
[10:18:27.438] }
[10:18:27.438] Lazy evaluation: FALSE
[10:18:27.438] Asynchronous evaluation: TRUE
[10:18:27.438] Local evaluation: TRUE
[10:18:27.438] Environment: R_GlobalEnv
[10:18:27.438] Capture standard output: TRUE
[10:18:27.438] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.438] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.438] Packages: <none>
[10:18:27.438] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.438] Resolved: TRUE
[10:18:27.438] Value: <not collected>
[10:18:27.438] Conditions captured: <none>
[10:18:27.438] Early signaling: FALSE
[10:18:27.438] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.438] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.446] Chunk #1 of 2 ... DONE
[10:18:27.446] Chunk #2 of 2 ...
[10:18:27.446]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.446]  - seeds: <none>
[10:18:27.447]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.447] getGlobalsAndPackages() ...
[10:18:27.447] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.447] Resolving globals: FALSE
[10:18:27.447] Tweak future expression to call with '...' arguments ...
[10:18:27.447] {
[10:18:27.447]     do.call(function(...) {
[10:18:27.447]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.447]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.447]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.447]             on.exit(options(oopts), add = TRUE)
[10:18:27.447]         }
[10:18:27.447]         {
[10:18:27.447]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.447]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.447]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.447]             })
[10:18:27.447]         }
[10:18:27.447]     }, args = future.call.arguments)
[10:18:27.447] }
[10:18:27.448] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.448] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.449] 
[10:18:27.449] getGlobalsAndPackages() ... DONE
[10:18:27.449] run() for ‘Future’ ...
[10:18:27.449] - state: ‘created’
[10:18:27.450] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.452] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.453]   - Field: ‘label’
[10:18:27.453]   - Field: ‘local’
[10:18:27.453]   - Field: ‘owner’
[10:18:27.453]   - Field: ‘envir’
[10:18:27.453]   - Field: ‘workers’
[10:18:27.453]   - Field: ‘packages’
[10:18:27.454]   - Field: ‘gc’
[10:18:27.454]   - Field: ‘job’
[10:18:27.454]   - Field: ‘conditions’
[10:18:27.454]   - Field: ‘expr’
[10:18:27.454]   - Field: ‘uuid’
[10:18:27.454]   - Field: ‘seed’
[10:18:27.454]   - Field: ‘version’
[10:18:27.455]   - Field: ‘result’
[10:18:27.455]   - Field: ‘asynchronous’
[10:18:27.455]   - Field: ‘calls’
[10:18:27.455]   - Field: ‘globals’
[10:18:27.455]   - Field: ‘stdout’
[10:18:27.455]   - Field: ‘earlySignal’
[10:18:27.456]   - Field: ‘lazy’
[10:18:27.456]   - Field: ‘state’
[10:18:27.456] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.456] - Launch lazy future ...
[10:18:27.457] Packages needed by the future expression (n = 0): <none>
[10:18:27.457] Packages needed by future strategies (n = 0): <none>
[10:18:27.457] {
[10:18:27.457]     {
[10:18:27.457]         {
[10:18:27.457]             ...future.startTime <- base::Sys.time()
[10:18:27.457]             {
[10:18:27.457]                 {
[10:18:27.457]                   {
[10:18:27.457]                     {
[10:18:27.457]                       base::local({
[10:18:27.457]                         has_future <- base::requireNamespace("future", 
[10:18:27.457]                           quietly = TRUE)
[10:18:27.457]                         if (has_future) {
[10:18:27.457]                           ns <- base::getNamespace("future")
[10:18:27.457]                           version <- ns[[".package"]][["version"]]
[10:18:27.457]                           if (is.null(version)) 
[10:18:27.457]                             version <- utils::packageVersion("future")
[10:18:27.457]                         }
[10:18:27.457]                         else {
[10:18:27.457]                           version <- NULL
[10:18:27.457]                         }
[10:18:27.457]                         if (!has_future || version < "1.8.0") {
[10:18:27.457]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.457]                             "", base::R.version$version.string), 
[10:18:27.457]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.457]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.457]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.457]                               "release", "version")], collapse = " "), 
[10:18:27.457]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.457]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.457]                             info)
[10:18:27.457]                           info <- base::paste(info, collapse = "; ")
[10:18:27.457]                           if (!has_future) {
[10:18:27.457]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.457]                               info)
[10:18:27.457]                           }
[10:18:27.457]                           else {
[10:18:27.457]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.457]                               info, version)
[10:18:27.457]                           }
[10:18:27.457]                           base::stop(msg)
[10:18:27.457]                         }
[10:18:27.457]                       })
[10:18:27.457]                     }
[10:18:27.457]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.457]                     base::options(mc.cores = 1L)
[10:18:27.457]                   }
[10:18:27.457]                   ...future.strategy.old <- future::plan("list")
[10:18:27.457]                   options(future.plan = NULL)
[10:18:27.457]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.457]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.457]                 }
[10:18:27.457]                 ...future.workdir <- getwd()
[10:18:27.457]             }
[10:18:27.457]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.457]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.457]         }
[10:18:27.457]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.457]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.457]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.457]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.457]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.457]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.457]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.457]             base::names(...future.oldOptions))
[10:18:27.457]     }
[10:18:27.457]     if (FALSE) {
[10:18:27.457]     }
[10:18:27.457]     else {
[10:18:27.457]         if (TRUE) {
[10:18:27.457]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.457]                 open = "w")
[10:18:27.457]         }
[10:18:27.457]         else {
[10:18:27.457]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.457]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.457]         }
[10:18:27.457]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.457]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.457]             base::sink(type = "output", split = FALSE)
[10:18:27.457]             base::close(...future.stdout)
[10:18:27.457]         }, add = TRUE)
[10:18:27.457]     }
[10:18:27.457]     ...future.frame <- base::sys.nframe()
[10:18:27.457]     ...future.conditions <- base::list()
[10:18:27.457]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.457]     if (FALSE) {
[10:18:27.457]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.457]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.457]     }
[10:18:27.457]     ...future.result <- base::tryCatch({
[10:18:27.457]         base::withCallingHandlers({
[10:18:27.457]             ...future.value <- base::withVisible(base::local({
[10:18:27.457]                 withCallingHandlers({
[10:18:27.457]                   {
[10:18:27.457]                     do.call(function(...) {
[10:18:27.457]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.457]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.457]                         ...future.globals.maxSize)) {
[10:18:27.457]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.457]                         on.exit(options(oopts), add = TRUE)
[10:18:27.457]                       }
[10:18:27.457]                       {
[10:18:27.457]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.457]                           FUN = function(jj) {
[10:18:27.457]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.457]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.457]                           })
[10:18:27.457]                       }
[10:18:27.457]                     }, args = future.call.arguments)
[10:18:27.457]                   }
[10:18:27.457]                 }, immediateCondition = function(cond) {
[10:18:27.457]                   save_rds <- function (object, pathname, ...) 
[10:18:27.457]                   {
[10:18:27.457]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.457]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.457]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.457]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.457]                         fi_tmp[["mtime"]])
[10:18:27.457]                     }
[10:18:27.457]                     tryCatch({
[10:18:27.457]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.457]                     }, error = function(ex) {
[10:18:27.457]                       msg <- conditionMessage(ex)
[10:18:27.457]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.457]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.457]                         fi_tmp[["mtime"]], msg)
[10:18:27.457]                       ex$message <- msg
[10:18:27.457]                       stop(ex)
[10:18:27.457]                     })
[10:18:27.457]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.457]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.457]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.457]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.457]                       fi <- file.info(pathname)
[10:18:27.457]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.457]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.457]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.457]                         fi[["size"]], fi[["mtime"]])
[10:18:27.457]                       stop(msg)
[10:18:27.457]                     }
[10:18:27.457]                     invisible(pathname)
[10:18:27.457]                   }
[10:18:27.457]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.457]                     rootPath = tempdir()) 
[10:18:27.457]                   {
[10:18:27.457]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.457]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.457]                       tmpdir = path, fileext = ".rds")
[10:18:27.457]                     save_rds(obj, file)
[10:18:27.457]                   }
[10:18:27.457]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.457]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.457]                   {
[10:18:27.457]                     inherits <- base::inherits
[10:18:27.457]                     invokeRestart <- base::invokeRestart
[10:18:27.457]                     is.null <- base::is.null
[10:18:27.457]                     muffled <- FALSE
[10:18:27.457]                     if (inherits(cond, "message")) {
[10:18:27.457]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.457]                       if (muffled) 
[10:18:27.457]                         invokeRestart("muffleMessage")
[10:18:27.457]                     }
[10:18:27.457]                     else if (inherits(cond, "warning")) {
[10:18:27.457]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.457]                       if (muffled) 
[10:18:27.457]                         invokeRestart("muffleWarning")
[10:18:27.457]                     }
[10:18:27.457]                     else if (inherits(cond, "condition")) {
[10:18:27.457]                       if (!is.null(pattern)) {
[10:18:27.457]                         computeRestarts <- base::computeRestarts
[10:18:27.457]                         grepl <- base::grepl
[10:18:27.457]                         restarts <- computeRestarts(cond)
[10:18:27.457]                         for (restart in restarts) {
[10:18:27.457]                           name <- restart$name
[10:18:27.457]                           if (is.null(name)) 
[10:18:27.457]                             next
[10:18:27.457]                           if (!grepl(pattern, name)) 
[10:18:27.457]                             next
[10:18:27.457]                           invokeRestart(restart)
[10:18:27.457]                           muffled <- TRUE
[10:18:27.457]                           break
[10:18:27.457]                         }
[10:18:27.457]                       }
[10:18:27.457]                     }
[10:18:27.457]                     invisible(muffled)
[10:18:27.457]                   }
[10:18:27.457]                   muffleCondition(cond)
[10:18:27.457]                 })
[10:18:27.457]             }))
[10:18:27.457]             future::FutureResult(value = ...future.value$value, 
[10:18:27.457]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.457]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.457]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.457]                     ...future.globalenv.names))
[10:18:27.457]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.457]         }, condition = base::local({
[10:18:27.457]             c <- base::c
[10:18:27.457]             inherits <- base::inherits
[10:18:27.457]             invokeRestart <- base::invokeRestart
[10:18:27.457]             length <- base::length
[10:18:27.457]             list <- base::list
[10:18:27.457]             seq.int <- base::seq.int
[10:18:27.457]             signalCondition <- base::signalCondition
[10:18:27.457]             sys.calls <- base::sys.calls
[10:18:27.457]             `[[` <- base::`[[`
[10:18:27.457]             `+` <- base::`+`
[10:18:27.457]             `<<-` <- base::`<<-`
[10:18:27.457]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.457]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.457]                   3L)]
[10:18:27.457]             }
[10:18:27.457]             function(cond) {
[10:18:27.457]                 is_error <- inherits(cond, "error")
[10:18:27.457]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.457]                   NULL)
[10:18:27.457]                 if (is_error) {
[10:18:27.457]                   sessionInformation <- function() {
[10:18:27.457]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.457]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.457]                       search = base::search(), system = base::Sys.info())
[10:18:27.457]                   }
[10:18:27.457]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.457]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.457]                     cond$call), session = sessionInformation(), 
[10:18:27.457]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.457]                   signalCondition(cond)
[10:18:27.457]                 }
[10:18:27.457]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.457]                 "immediateCondition"))) {
[10:18:27.457]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.457]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.457]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.457]                   if (TRUE && !signal) {
[10:18:27.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.457]                     {
[10:18:27.457]                       inherits <- base::inherits
[10:18:27.457]                       invokeRestart <- base::invokeRestart
[10:18:27.457]                       is.null <- base::is.null
[10:18:27.457]                       muffled <- FALSE
[10:18:27.457]                       if (inherits(cond, "message")) {
[10:18:27.457]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.457]                         if (muffled) 
[10:18:27.457]                           invokeRestart("muffleMessage")
[10:18:27.457]                       }
[10:18:27.457]                       else if (inherits(cond, "warning")) {
[10:18:27.457]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.457]                         if (muffled) 
[10:18:27.457]                           invokeRestart("muffleWarning")
[10:18:27.457]                       }
[10:18:27.457]                       else if (inherits(cond, "condition")) {
[10:18:27.457]                         if (!is.null(pattern)) {
[10:18:27.457]                           computeRestarts <- base::computeRestarts
[10:18:27.457]                           grepl <- base::grepl
[10:18:27.457]                           restarts <- computeRestarts(cond)
[10:18:27.457]                           for (restart in restarts) {
[10:18:27.457]                             name <- restart$name
[10:18:27.457]                             if (is.null(name)) 
[10:18:27.457]                               next
[10:18:27.457]                             if (!grepl(pattern, name)) 
[10:18:27.457]                               next
[10:18:27.457]                             invokeRestart(restart)
[10:18:27.457]                             muffled <- TRUE
[10:18:27.457]                             break
[10:18:27.457]                           }
[10:18:27.457]                         }
[10:18:27.457]                       }
[10:18:27.457]                       invisible(muffled)
[10:18:27.457]                     }
[10:18:27.457]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.457]                   }
[10:18:27.457]                 }
[10:18:27.457]                 else {
[10:18:27.457]                   if (TRUE) {
[10:18:27.457]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.457]                     {
[10:18:27.457]                       inherits <- base::inherits
[10:18:27.457]                       invokeRestart <- base::invokeRestart
[10:18:27.457]                       is.null <- base::is.null
[10:18:27.457]                       muffled <- FALSE
[10:18:27.457]                       if (inherits(cond, "message")) {
[10:18:27.457]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.457]                         if (muffled) 
[10:18:27.457]                           invokeRestart("muffleMessage")
[10:18:27.457]                       }
[10:18:27.457]                       else if (inherits(cond, "warning")) {
[10:18:27.457]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.457]                         if (muffled) 
[10:18:27.457]                           invokeRestart("muffleWarning")
[10:18:27.457]                       }
[10:18:27.457]                       else if (inherits(cond, "condition")) {
[10:18:27.457]                         if (!is.null(pattern)) {
[10:18:27.457]                           computeRestarts <- base::computeRestarts
[10:18:27.457]                           grepl <- base::grepl
[10:18:27.457]                           restarts <- computeRestarts(cond)
[10:18:27.457]                           for (restart in restarts) {
[10:18:27.457]                             name <- restart$name
[10:18:27.457]                             if (is.null(name)) 
[10:18:27.457]                               next
[10:18:27.457]                             if (!grepl(pattern, name)) 
[10:18:27.457]                               next
[10:18:27.457]                             invokeRestart(restart)
[10:18:27.457]                             muffled <- TRUE
[10:18:27.457]                             break
[10:18:27.457]                           }
[10:18:27.457]                         }
[10:18:27.457]                       }
[10:18:27.457]                       invisible(muffled)
[10:18:27.457]                     }
[10:18:27.457]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.457]                   }
[10:18:27.457]                 }
[10:18:27.457]             }
[10:18:27.457]         }))
[10:18:27.457]     }, error = function(ex) {
[10:18:27.457]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.457]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.457]                 ...future.rng), started = ...future.startTime, 
[10:18:27.457]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.457]             version = "1.8"), class = "FutureResult")
[10:18:27.457]     }, finally = {
[10:18:27.457]         if (!identical(...future.workdir, getwd())) 
[10:18:27.457]             setwd(...future.workdir)
[10:18:27.457]         {
[10:18:27.457]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.457]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.457]             }
[10:18:27.457]             base::options(...future.oldOptions)
[10:18:27.457]             if (.Platform$OS.type == "windows") {
[10:18:27.457]                 old_names <- names(...future.oldEnvVars)
[10:18:27.457]                 envs <- base::Sys.getenv()
[10:18:27.457]                 names <- names(envs)
[10:18:27.457]                 common <- intersect(names, old_names)
[10:18:27.457]                 added <- setdiff(names, old_names)
[10:18:27.457]                 removed <- setdiff(old_names, names)
[10:18:27.457]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.457]                   envs[common]]
[10:18:27.457]                 NAMES <- toupper(changed)
[10:18:27.457]                 args <- list()
[10:18:27.457]                 for (kk in seq_along(NAMES)) {
[10:18:27.457]                   name <- changed[[kk]]
[10:18:27.457]                   NAME <- NAMES[[kk]]
[10:18:27.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.457]                     next
[10:18:27.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.457]                 }
[10:18:27.457]                 NAMES <- toupper(added)
[10:18:27.457]                 for (kk in seq_along(NAMES)) {
[10:18:27.457]                   name <- added[[kk]]
[10:18:27.457]                   NAME <- NAMES[[kk]]
[10:18:27.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.457]                     next
[10:18:27.457]                   args[[name]] <- ""
[10:18:27.457]                 }
[10:18:27.457]                 NAMES <- toupper(removed)
[10:18:27.457]                 for (kk in seq_along(NAMES)) {
[10:18:27.457]                   name <- removed[[kk]]
[10:18:27.457]                   NAME <- NAMES[[kk]]
[10:18:27.457]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.457]                     next
[10:18:27.457]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.457]                 }
[10:18:27.457]                 if (length(args) > 0) 
[10:18:27.457]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.457]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.457]             }
[10:18:27.457]             else {
[10:18:27.457]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.457]             }
[10:18:27.457]             {
[10:18:27.457]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.457]                   0L) {
[10:18:27.457]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.457]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.457]                   base::options(opts)
[10:18:27.457]                 }
[10:18:27.457]                 {
[10:18:27.457]                   {
[10:18:27.457]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.457]                     NULL
[10:18:27.457]                   }
[10:18:27.457]                   options(future.plan = NULL)
[10:18:27.457]                   if (is.na(NA_character_)) 
[10:18:27.457]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.457]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.457]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.457]                     .init = FALSE)
[10:18:27.457]                 }
[10:18:27.457]             }
[10:18:27.457]         }
[10:18:27.457]     })
[10:18:27.457]     if (TRUE) {
[10:18:27.457]         base::sink(type = "output", split = FALSE)
[10:18:27.457]         if (TRUE) {
[10:18:27.457]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.457]         }
[10:18:27.457]         else {
[10:18:27.457]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.457]         }
[10:18:27.457]         base::close(...future.stdout)
[10:18:27.457]         ...future.stdout <- NULL
[10:18:27.457]     }
[10:18:27.457]     ...future.result$conditions <- ...future.conditions
[10:18:27.457]     ...future.result$finished <- base::Sys.time()
[10:18:27.457]     ...future.result
[10:18:27.457] }
[10:18:27.461] assign_globals() ...
[10:18:27.461] List of 5
[10:18:27.461]  $ future.call.arguments    : list()
[10:18:27.461]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.461]  $ ...future.FUN            :function (x)  
[10:18:27.461]  $ ...future.elements_ii    :List of 1
[10:18:27.461]   ..$ : int 2
[10:18:27.461]  $ ...future.seeds_ii       : NULL
[10:18:27.461]  $ ...future.globals.maxSize: num Inf
[10:18:27.461]  - attr(*, "resolved")= logi FALSE
[10:18:27.461]  - attr(*, "total_size")= num NA
[10:18:27.461]  - attr(*, "where")=List of 5
[10:18:27.461]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.461]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.461]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.461]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.461]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.461]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.461]  - attr(*, "already-done")= logi TRUE
[10:18:27.473] - copied ‘future.call.arguments’ to environment
[10:18:27.474] - copied ‘...future.FUN’ to environment
[10:18:27.474] - copied ‘...future.elements_ii’ to environment
[10:18:27.474] - copied ‘...future.seeds_ii’ to environment
[10:18:27.475] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.475] assign_globals() ... done
[10:18:27.475] requestCore(): workers = 2
[10:18:27.478] MulticoreFuture started
[10:18:27.479] - Launch lazy future ... done
[10:18:27.479] plan(): Setting new future strategy stack:
[10:18:27.479] run() for ‘MulticoreFuture’ ... done
[10:18:27.480] Created future:
[10:18:27.480] List of future strategies:
[10:18:27.480] 1. sequential:
[10:18:27.480]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.480]    - tweaked: FALSE
[10:18:27.480]    - call: NULL
[10:18:27.482] plan(): nbrOfWorkers() = 1
[10:18:27.484] plan(): Setting new future strategy stack:
[10:18:27.484] List of future strategies:
[10:18:27.484] 1. multicore:
[10:18:27.484]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.484]    - tweaked: FALSE
[10:18:27.484]    - call: plan(strategy)
[10:18:27.488] plan(): nbrOfWorkers() = 2
[10:18:27.480] MulticoreFuture:
[10:18:27.480] Label: ‘future_apply-2’
[10:18:27.480] Expression:
[10:18:27.480] {
[10:18:27.480]     do.call(function(...) {
[10:18:27.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.480]             on.exit(options(oopts), add = TRUE)
[10:18:27.480]         }
[10:18:27.480]         {
[10:18:27.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.480]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.480]             })
[10:18:27.480]         }
[10:18:27.480]     }, args = future.call.arguments)
[10:18:27.480] }
[10:18:27.480] Lazy evaluation: FALSE
[10:18:27.480] Asynchronous evaluation: TRUE
[10:18:27.480] Local evaluation: TRUE
[10:18:27.480] Environment: R_GlobalEnv
[10:18:27.480] Capture standard output: TRUE
[10:18:27.480] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.480] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.480] Packages: <none>
[10:18:27.480] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.480] Resolved: TRUE
[10:18:27.480] Value: <not collected>
[10:18:27.480] Conditions captured: <none>
[10:18:27.480] Early signaling: FALSE
[10:18:27.480] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.480] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.489] Chunk #2 of 2 ... DONE
[10:18:27.489] Launching 2 futures (chunks) ... DONE
[10:18:27.490] Resolving 2 futures (chunks) ...
[10:18:27.490] resolve() on list ...
[10:18:27.490]  recursive: 0
[10:18:27.490]  length: 2
[10:18:27.490] 
[10:18:27.491] Future #1
[10:18:27.491] result() for MulticoreFuture ...
[10:18:27.492] result() for MulticoreFuture ...
[10:18:27.492] result() for MulticoreFuture ... done
[10:18:27.492] result() for MulticoreFuture ... done
[10:18:27.493] result() for MulticoreFuture ...
[10:18:27.493] result() for MulticoreFuture ... done
[10:18:27.493] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:27.493] - nx: 2
[10:18:27.493] - relay: TRUE
[10:18:27.494] - stdout: TRUE
[10:18:27.494] - signal: TRUE
[10:18:27.494] - resignal: FALSE
[10:18:27.494] - force: TRUE
[10:18:27.494] - relayed: [n=2] FALSE, FALSE
[10:18:27.494] - queued futures: [n=2] FALSE, FALSE
[10:18:27.495]  - until=1
[10:18:27.495]  - relaying element #1
[10:18:27.495] result() for MulticoreFuture ...
[10:18:27.495] result() for MulticoreFuture ... done
[10:18:27.495] result() for MulticoreFuture ...
[10:18:27.495] result() for MulticoreFuture ... done
[10:18:27.496] result() for MulticoreFuture ...
[10:18:27.496] result() for MulticoreFuture ... done
[10:18:27.496] result() for MulticoreFuture ...
[10:18:27.496] result() for MulticoreFuture ... done
[10:18:27.496] - relayed: [n=2] TRUE, FALSE
[10:18:27.496] - queued futures: [n=2] TRUE, FALSE
[10:18:27.496] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:27.497]  length: 1 (resolved future 1)
[10:18:27.497] Future #2
[10:18:27.497] result() for MulticoreFuture ...
[10:18:27.498] result() for MulticoreFuture ...
[10:18:27.498] result() for MulticoreFuture ... done
[10:18:27.498] result() for MulticoreFuture ... done
[10:18:27.498] result() for MulticoreFuture ...
[10:18:27.498] result() for MulticoreFuture ... done
[10:18:27.498] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:27.499] - nx: 2
[10:18:27.499] - relay: TRUE
[10:18:27.499] - stdout: TRUE
[10:18:27.499] - signal: TRUE
[10:18:27.499] - resignal: FALSE
[10:18:27.499] - force: TRUE
[10:18:27.499] - relayed: [n=2] TRUE, FALSE
[10:18:27.499] - queued futures: [n=2] TRUE, FALSE
[10:18:27.500]  - until=2
[10:18:27.500]  - relaying element #2
[10:18:27.500] result() for MulticoreFuture ...
[10:18:27.500] result() for MulticoreFuture ... done
[10:18:27.500] result() for MulticoreFuture ...
[10:18:27.500] result() for MulticoreFuture ... done
[10:18:27.500] result() for MulticoreFuture ...
[10:18:27.500] result() for MulticoreFuture ... done
[10:18:27.500] result() for MulticoreFuture ...
[10:18:27.501] result() for MulticoreFuture ... done
[10:18:27.501] - relayed: [n=2] TRUE, TRUE
[10:18:27.501] - queued futures: [n=2] TRUE, TRUE
[10:18:27.501] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:27.501]  length: 0 (resolved future 2)
[10:18:27.501] Relaying remaining futures
[10:18:27.501] signalConditionsASAP(NULL, pos=0) ...
[10:18:27.501] - nx: 2
[10:18:27.501] - relay: TRUE
[10:18:27.502] - stdout: TRUE
[10:18:27.502] - signal: TRUE
[10:18:27.502] - resignal: FALSE
[10:18:27.502] - force: TRUE
[10:18:27.502] - relayed: [n=2] TRUE, TRUE
[10:18:27.502] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:27.502] - relayed: [n=2] TRUE, TRUE
[10:18:27.502] - queued futures: [n=2] TRUE, TRUE
[10:18:27.502] signalConditionsASAP(NULL, pos=0) ... done
[10:18:27.502] resolve() on list ... DONE
[10:18:27.503] result() for MulticoreFuture ...
[10:18:27.503] result() for MulticoreFuture ... done
[10:18:27.503] result() for MulticoreFuture ...
[10:18:27.503] result() for MulticoreFuture ... done
[10:18:27.503] result() for MulticoreFuture ...
[10:18:27.503] result() for MulticoreFuture ... done
[10:18:27.503] result() for MulticoreFuture ...
[10:18:27.503] result() for MulticoreFuture ... done
[10:18:27.504]  - Number of value chunks collected: 2
[10:18:27.504] Resolving 2 futures (chunks) ... DONE
[10:18:27.504] Reducing values from 2 chunks ...
[10:18:27.504]  - Number of values collected after concatenation: 2
[10:18:27.504]  - Number of values expected: 2
[10:18:27.504] Reducing values from 2 chunks ... DONE
[10:18:27.504] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:18:27.505] getGlobalsAndPackagesXApply() ...
[10:18:27.505]  - future.globals: TRUE
[10:18:27.505] getGlobalsAndPackages() ...
[10:18:27.505] Searching for globals...
[10:18:27.506] - globals found: [1] ‘FUN’
[10:18:27.507] Searching for globals ... DONE
[10:18:27.507] Resolving globals: FALSE
[10:18:27.507] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:27.508] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:27.508] - globals: [1] ‘FUN’
[10:18:27.508] 
[10:18:27.508] getGlobalsAndPackages() ... DONE
[10:18:27.508]  - globals found/used: [n=1] ‘FUN’
[10:18:27.508]  - needed namespaces: [n=0] 
[10:18:27.508] Finding globals ... DONE
[10:18:27.508]  - use_args: TRUE
[10:18:27.508]  - Getting '...' globals ...
[10:18:27.509] resolve() on list ...
[10:18:27.509]  recursive: 0
[10:18:27.509]  length: 1
[10:18:27.509]  elements: ‘...’
[10:18:27.509]  length: 0 (resolved future 1)
[10:18:27.509] resolve() on list ... DONE
[10:18:27.510]    - '...' content: [n=0] 
[10:18:27.510] List of 1
[10:18:27.510]  $ ...: list()
[10:18:27.510]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.510]  - attr(*, "where")=List of 1
[10:18:27.510]   ..$ ...:<environment: 0x556e036f7480> 
[10:18:27.510]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.510]  - attr(*, "resolved")= logi TRUE
[10:18:27.510]  - attr(*, "total_size")= num NA
[10:18:27.513]  - Getting '...' globals ... DONE
[10:18:27.515] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:27.515] List of 2
[10:18:27.515]  $ ...future.FUN:function (x)  
[10:18:27.515]  $ ...          : list()
[10:18:27.515]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.515]  - attr(*, "where")=List of 2
[10:18:27.515]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:27.515]   ..$ ...          :<environment: 0x556e036f7480> 
[10:18:27.515]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.515]  - attr(*, "resolved")= logi FALSE
[10:18:27.515]  - attr(*, "total_size")= num 2274
[10:18:27.520] Packages to be attached in all futures: [n=0] 
[10:18:27.520] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.522] future_lapply() ...
[10:18:27.524] Number of chunks: 2
[10:18:27.524] getGlobalsAndPackagesXApply() ...
[10:18:27.524]  - future.globals: <name-value list> with names ‘list()’
[10:18:27.524]  - use_args: TRUE
[10:18:27.524] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:27.524] List of 2
[10:18:27.524]  $ ...          : list()
[10:18:27.524]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.524]  $ ...future.FUN:function (x)  
[10:18:27.524]  - attr(*, "where")=List of 2
[10:18:27.524]   ..$ ...          :<environment: 0x556e036f7480> 
[10:18:27.524]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:27.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.524]  - attr(*, "resolved")= logi FALSE
[10:18:27.524]  - attr(*, "total_size")= num NA
[10:18:27.528] Packages to be attached in all futures: [n=0] 
[10:18:27.528] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.528] Number of futures (= number of chunks): 2
[10:18:27.529] Launching 2 futures (chunks) ...
[10:18:27.529] Chunk #1 of 2 ...
[10:18:27.529]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.529]  - seeds: <none>
[10:18:27.529]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.529] getGlobalsAndPackages() ...
[10:18:27.529] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.529] Resolving globals: FALSE
[10:18:27.529] Tweak future expression to call with '...' arguments ...
[10:18:27.530] {
[10:18:27.530]     do.call(function(...) {
[10:18:27.530]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.530]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.530]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.530]             on.exit(options(oopts), add = TRUE)
[10:18:27.530]         }
[10:18:27.530]         {
[10:18:27.530]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.530]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.530]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.530]             })
[10:18:27.530]         }
[10:18:27.530]     }, args = future.call.arguments)
[10:18:27.530] }
[10:18:27.530] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.530] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.530] 
[10:18:27.530] getGlobalsAndPackages() ... DONE
[10:18:27.531] run() for ‘Future’ ...
[10:18:27.531] - state: ‘created’
[10:18:27.531] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.533] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.533] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.533]   - Field: ‘label’
[10:18:27.533]   - Field: ‘local’
[10:18:27.533]   - Field: ‘owner’
[10:18:27.533]   - Field: ‘envir’
[10:18:27.533]   - Field: ‘workers’
[10:18:27.534]   - Field: ‘packages’
[10:18:27.534]   - Field: ‘gc’
[10:18:27.534]   - Field: ‘job’
[10:18:27.534]   - Field: ‘conditions’
[10:18:27.534]   - Field: ‘expr’
[10:18:27.534]   - Field: ‘uuid’
[10:18:27.534]   - Field: ‘seed’
[10:18:27.534]   - Field: ‘version’
[10:18:27.534]   - Field: ‘result’
[10:18:27.534]   - Field: ‘asynchronous’
[10:18:27.534]   - Field: ‘calls’
[10:18:27.535]   - Field: ‘globals’
[10:18:27.535]   - Field: ‘stdout’
[10:18:27.535]   - Field: ‘earlySignal’
[10:18:27.535]   - Field: ‘lazy’
[10:18:27.535]   - Field: ‘state’
[10:18:27.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.535] - Launch lazy future ...
[10:18:27.535] Packages needed by the future expression (n = 0): <none>
[10:18:27.536] Packages needed by future strategies (n = 0): <none>
[10:18:27.536] {
[10:18:27.536]     {
[10:18:27.536]         {
[10:18:27.536]             ...future.startTime <- base::Sys.time()
[10:18:27.536]             {
[10:18:27.536]                 {
[10:18:27.536]                   {
[10:18:27.536]                     {
[10:18:27.536]                       base::local({
[10:18:27.536]                         has_future <- base::requireNamespace("future", 
[10:18:27.536]                           quietly = TRUE)
[10:18:27.536]                         if (has_future) {
[10:18:27.536]                           ns <- base::getNamespace("future")
[10:18:27.536]                           version <- ns[[".package"]][["version"]]
[10:18:27.536]                           if (is.null(version)) 
[10:18:27.536]                             version <- utils::packageVersion("future")
[10:18:27.536]                         }
[10:18:27.536]                         else {
[10:18:27.536]                           version <- NULL
[10:18:27.536]                         }
[10:18:27.536]                         if (!has_future || version < "1.8.0") {
[10:18:27.536]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.536]                             "", base::R.version$version.string), 
[10:18:27.536]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.536]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.536]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.536]                               "release", "version")], collapse = " "), 
[10:18:27.536]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.536]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.536]                             info)
[10:18:27.536]                           info <- base::paste(info, collapse = "; ")
[10:18:27.536]                           if (!has_future) {
[10:18:27.536]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.536]                               info)
[10:18:27.536]                           }
[10:18:27.536]                           else {
[10:18:27.536]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.536]                               info, version)
[10:18:27.536]                           }
[10:18:27.536]                           base::stop(msg)
[10:18:27.536]                         }
[10:18:27.536]                       })
[10:18:27.536]                     }
[10:18:27.536]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.536]                     base::options(mc.cores = 1L)
[10:18:27.536]                   }
[10:18:27.536]                   ...future.strategy.old <- future::plan("list")
[10:18:27.536]                   options(future.plan = NULL)
[10:18:27.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.536]                 }
[10:18:27.536]                 ...future.workdir <- getwd()
[10:18:27.536]             }
[10:18:27.536]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.536]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.536]         }
[10:18:27.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.536]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.536]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.536]             base::names(...future.oldOptions))
[10:18:27.536]     }
[10:18:27.536]     if (FALSE) {
[10:18:27.536]     }
[10:18:27.536]     else {
[10:18:27.536]         if (TRUE) {
[10:18:27.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.536]                 open = "w")
[10:18:27.536]         }
[10:18:27.536]         else {
[10:18:27.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.536]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.536]         }
[10:18:27.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.536]             base::sink(type = "output", split = FALSE)
[10:18:27.536]             base::close(...future.stdout)
[10:18:27.536]         }, add = TRUE)
[10:18:27.536]     }
[10:18:27.536]     ...future.frame <- base::sys.nframe()
[10:18:27.536]     ...future.conditions <- base::list()
[10:18:27.536]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.536]     if (FALSE) {
[10:18:27.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.536]     }
[10:18:27.536]     ...future.result <- base::tryCatch({
[10:18:27.536]         base::withCallingHandlers({
[10:18:27.536]             ...future.value <- base::withVisible(base::local({
[10:18:27.536]                 withCallingHandlers({
[10:18:27.536]                   {
[10:18:27.536]                     do.call(function(...) {
[10:18:27.536]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.536]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.536]                         ...future.globals.maxSize)) {
[10:18:27.536]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.536]                         on.exit(options(oopts), add = TRUE)
[10:18:27.536]                       }
[10:18:27.536]                       {
[10:18:27.536]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.536]                           FUN = function(jj) {
[10:18:27.536]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.536]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.536]                           })
[10:18:27.536]                       }
[10:18:27.536]                     }, args = future.call.arguments)
[10:18:27.536]                   }
[10:18:27.536]                 }, immediateCondition = function(cond) {
[10:18:27.536]                   save_rds <- function (object, pathname, ...) 
[10:18:27.536]                   {
[10:18:27.536]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.536]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.536]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.536]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.536]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.536]                         fi_tmp[["mtime"]])
[10:18:27.536]                     }
[10:18:27.536]                     tryCatch({
[10:18:27.536]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.536]                     }, error = function(ex) {
[10:18:27.536]                       msg <- conditionMessage(ex)
[10:18:27.536]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.536]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.536]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.536]                         fi_tmp[["mtime"]], msg)
[10:18:27.536]                       ex$message <- msg
[10:18:27.536]                       stop(ex)
[10:18:27.536]                     })
[10:18:27.536]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.536]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.536]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.536]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.536]                       fi <- file.info(pathname)
[10:18:27.536]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.536]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.536]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.536]                         fi[["size"]], fi[["mtime"]])
[10:18:27.536]                       stop(msg)
[10:18:27.536]                     }
[10:18:27.536]                     invisible(pathname)
[10:18:27.536]                   }
[10:18:27.536]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.536]                     rootPath = tempdir()) 
[10:18:27.536]                   {
[10:18:27.536]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.536]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.536]                       tmpdir = path, fileext = ".rds")
[10:18:27.536]                     save_rds(obj, file)
[10:18:27.536]                   }
[10:18:27.536]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.536]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.536]                   {
[10:18:27.536]                     inherits <- base::inherits
[10:18:27.536]                     invokeRestart <- base::invokeRestart
[10:18:27.536]                     is.null <- base::is.null
[10:18:27.536]                     muffled <- FALSE
[10:18:27.536]                     if (inherits(cond, "message")) {
[10:18:27.536]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.536]                       if (muffled) 
[10:18:27.536]                         invokeRestart("muffleMessage")
[10:18:27.536]                     }
[10:18:27.536]                     else if (inherits(cond, "warning")) {
[10:18:27.536]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.536]                       if (muffled) 
[10:18:27.536]                         invokeRestart("muffleWarning")
[10:18:27.536]                     }
[10:18:27.536]                     else if (inherits(cond, "condition")) {
[10:18:27.536]                       if (!is.null(pattern)) {
[10:18:27.536]                         computeRestarts <- base::computeRestarts
[10:18:27.536]                         grepl <- base::grepl
[10:18:27.536]                         restarts <- computeRestarts(cond)
[10:18:27.536]                         for (restart in restarts) {
[10:18:27.536]                           name <- restart$name
[10:18:27.536]                           if (is.null(name)) 
[10:18:27.536]                             next
[10:18:27.536]                           if (!grepl(pattern, name)) 
[10:18:27.536]                             next
[10:18:27.536]                           invokeRestart(restart)
[10:18:27.536]                           muffled <- TRUE
[10:18:27.536]                           break
[10:18:27.536]                         }
[10:18:27.536]                       }
[10:18:27.536]                     }
[10:18:27.536]                     invisible(muffled)
[10:18:27.536]                   }
[10:18:27.536]                   muffleCondition(cond)
[10:18:27.536]                 })
[10:18:27.536]             }))
[10:18:27.536]             future::FutureResult(value = ...future.value$value, 
[10:18:27.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.536]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.536]                     ...future.globalenv.names))
[10:18:27.536]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.536]         }, condition = base::local({
[10:18:27.536]             c <- base::c
[10:18:27.536]             inherits <- base::inherits
[10:18:27.536]             invokeRestart <- base::invokeRestart
[10:18:27.536]             length <- base::length
[10:18:27.536]             list <- base::list
[10:18:27.536]             seq.int <- base::seq.int
[10:18:27.536]             signalCondition <- base::signalCondition
[10:18:27.536]             sys.calls <- base::sys.calls
[10:18:27.536]             `[[` <- base::`[[`
[10:18:27.536]             `+` <- base::`+`
[10:18:27.536]             `<<-` <- base::`<<-`
[10:18:27.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.536]                   3L)]
[10:18:27.536]             }
[10:18:27.536]             function(cond) {
[10:18:27.536]                 is_error <- inherits(cond, "error")
[10:18:27.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.536]                   NULL)
[10:18:27.536]                 if (is_error) {
[10:18:27.536]                   sessionInformation <- function() {
[10:18:27.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.536]                       search = base::search(), system = base::Sys.info())
[10:18:27.536]                   }
[10:18:27.536]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.536]                     cond$call), session = sessionInformation(), 
[10:18:27.536]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.536]                   signalCondition(cond)
[10:18:27.536]                 }
[10:18:27.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.536]                 "immediateCondition"))) {
[10:18:27.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.536]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.536]                   if (TRUE && !signal) {
[10:18:27.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.536]                     {
[10:18:27.536]                       inherits <- base::inherits
[10:18:27.536]                       invokeRestart <- base::invokeRestart
[10:18:27.536]                       is.null <- base::is.null
[10:18:27.536]                       muffled <- FALSE
[10:18:27.536]                       if (inherits(cond, "message")) {
[10:18:27.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.536]                         if (muffled) 
[10:18:27.536]                           invokeRestart("muffleMessage")
[10:18:27.536]                       }
[10:18:27.536]                       else if (inherits(cond, "warning")) {
[10:18:27.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.536]                         if (muffled) 
[10:18:27.536]                           invokeRestart("muffleWarning")
[10:18:27.536]                       }
[10:18:27.536]                       else if (inherits(cond, "condition")) {
[10:18:27.536]                         if (!is.null(pattern)) {
[10:18:27.536]                           computeRestarts <- base::computeRestarts
[10:18:27.536]                           grepl <- base::grepl
[10:18:27.536]                           restarts <- computeRestarts(cond)
[10:18:27.536]                           for (restart in restarts) {
[10:18:27.536]                             name <- restart$name
[10:18:27.536]                             if (is.null(name)) 
[10:18:27.536]                               next
[10:18:27.536]                             if (!grepl(pattern, name)) 
[10:18:27.536]                               next
[10:18:27.536]                             invokeRestart(restart)
[10:18:27.536]                             muffled <- TRUE
[10:18:27.536]                             break
[10:18:27.536]                           }
[10:18:27.536]                         }
[10:18:27.536]                       }
[10:18:27.536]                       invisible(muffled)
[10:18:27.536]                     }
[10:18:27.536]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.536]                   }
[10:18:27.536]                 }
[10:18:27.536]                 else {
[10:18:27.536]                   if (TRUE) {
[10:18:27.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.536]                     {
[10:18:27.536]                       inherits <- base::inherits
[10:18:27.536]                       invokeRestart <- base::invokeRestart
[10:18:27.536]                       is.null <- base::is.null
[10:18:27.536]                       muffled <- FALSE
[10:18:27.536]                       if (inherits(cond, "message")) {
[10:18:27.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.536]                         if (muffled) 
[10:18:27.536]                           invokeRestart("muffleMessage")
[10:18:27.536]                       }
[10:18:27.536]                       else if (inherits(cond, "warning")) {
[10:18:27.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.536]                         if (muffled) 
[10:18:27.536]                           invokeRestart("muffleWarning")
[10:18:27.536]                       }
[10:18:27.536]                       else if (inherits(cond, "condition")) {
[10:18:27.536]                         if (!is.null(pattern)) {
[10:18:27.536]                           computeRestarts <- base::computeRestarts
[10:18:27.536]                           grepl <- base::grepl
[10:18:27.536]                           restarts <- computeRestarts(cond)
[10:18:27.536]                           for (restart in restarts) {
[10:18:27.536]                             name <- restart$name
[10:18:27.536]                             if (is.null(name)) 
[10:18:27.536]                               next
[10:18:27.536]                             if (!grepl(pattern, name)) 
[10:18:27.536]                               next
[10:18:27.536]                             invokeRestart(restart)
[10:18:27.536]                             muffled <- TRUE
[10:18:27.536]                             break
[10:18:27.536]                           }
[10:18:27.536]                         }
[10:18:27.536]                       }
[10:18:27.536]                       invisible(muffled)
[10:18:27.536]                     }
[10:18:27.536]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.536]                   }
[10:18:27.536]                 }
[10:18:27.536]             }
[10:18:27.536]         }))
[10:18:27.536]     }, error = function(ex) {
[10:18:27.536]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.536]                 ...future.rng), started = ...future.startTime, 
[10:18:27.536]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.536]             version = "1.8"), class = "FutureResult")
[10:18:27.536]     }, finally = {
[10:18:27.536]         if (!identical(...future.workdir, getwd())) 
[10:18:27.536]             setwd(...future.workdir)
[10:18:27.536]         {
[10:18:27.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.536]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.536]             }
[10:18:27.536]             base::options(...future.oldOptions)
[10:18:27.536]             if (.Platform$OS.type == "windows") {
[10:18:27.536]                 old_names <- names(...future.oldEnvVars)
[10:18:27.536]                 envs <- base::Sys.getenv()
[10:18:27.536]                 names <- names(envs)
[10:18:27.536]                 common <- intersect(names, old_names)
[10:18:27.536]                 added <- setdiff(names, old_names)
[10:18:27.536]                 removed <- setdiff(old_names, names)
[10:18:27.536]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.536]                   envs[common]]
[10:18:27.536]                 NAMES <- toupper(changed)
[10:18:27.536]                 args <- list()
[10:18:27.536]                 for (kk in seq_along(NAMES)) {
[10:18:27.536]                   name <- changed[[kk]]
[10:18:27.536]                   NAME <- NAMES[[kk]]
[10:18:27.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.536]                     next
[10:18:27.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.536]                 }
[10:18:27.536]                 NAMES <- toupper(added)
[10:18:27.536]                 for (kk in seq_along(NAMES)) {
[10:18:27.536]                   name <- added[[kk]]
[10:18:27.536]                   NAME <- NAMES[[kk]]
[10:18:27.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.536]                     next
[10:18:27.536]                   args[[name]] <- ""
[10:18:27.536]                 }
[10:18:27.536]                 NAMES <- toupper(removed)
[10:18:27.536]                 for (kk in seq_along(NAMES)) {
[10:18:27.536]                   name <- removed[[kk]]
[10:18:27.536]                   NAME <- NAMES[[kk]]
[10:18:27.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.536]                     next
[10:18:27.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.536]                 }
[10:18:27.536]                 if (length(args) > 0) 
[10:18:27.536]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.536]             }
[10:18:27.536]             else {
[10:18:27.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.536]             }
[10:18:27.536]             {
[10:18:27.536]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.536]                   0L) {
[10:18:27.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.536]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.536]                   base::options(opts)
[10:18:27.536]                 }
[10:18:27.536]                 {
[10:18:27.536]                   {
[10:18:27.536]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.536]                     NULL
[10:18:27.536]                   }
[10:18:27.536]                   options(future.plan = NULL)
[10:18:27.536]                   if (is.na(NA_character_)) 
[10:18:27.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.536]                     .init = FALSE)
[10:18:27.536]                 }
[10:18:27.536]             }
[10:18:27.536]         }
[10:18:27.536]     })
[10:18:27.536]     if (TRUE) {
[10:18:27.536]         base::sink(type = "output", split = FALSE)
[10:18:27.536]         if (TRUE) {
[10:18:27.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.536]         }
[10:18:27.536]         else {
[10:18:27.536]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.536]         }
[10:18:27.536]         base::close(...future.stdout)
[10:18:27.536]         ...future.stdout <- NULL
[10:18:27.536]     }
[10:18:27.536]     ...future.result$conditions <- ...future.conditions
[10:18:27.536]     ...future.result$finished <- base::Sys.time()
[10:18:27.536]     ...future.result
[10:18:27.536] }
[10:18:27.539] assign_globals() ...
[10:18:27.539] List of 5
[10:18:27.539]  $ future.call.arguments    : list()
[10:18:27.539]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.539]  $ ...future.FUN            :function (x)  
[10:18:27.539]  $ ...future.elements_ii    :List of 1
[10:18:27.539]   ..$ : int [1:2, 1:3] 1 3 5 7 9 11
[10:18:27.539]  $ ...future.seeds_ii       : NULL
[10:18:27.539]  $ ...future.globals.maxSize: num Inf
[10:18:27.539]  - attr(*, "resolved")= logi FALSE
[10:18:27.539]  - attr(*, "total_size")= num NA
[10:18:27.539]  - attr(*, "where")=List of 5
[10:18:27.539]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.539]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.539]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.539]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.539]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.539]  - attr(*, "already-done")= logi TRUE
[10:18:27.547] - copied ‘future.call.arguments’ to environment
[10:18:27.547] - copied ‘...future.FUN’ to environment
[10:18:27.547] - copied ‘...future.elements_ii’ to environment
[10:18:27.547] - copied ‘...future.seeds_ii’ to environment
[10:18:27.547] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.547] assign_globals() ... done
[10:18:27.547] requestCore(): workers = 2
[10:18:27.550] MulticoreFuture started
[10:18:27.551] - Launch lazy future ... done
[10:18:27.551] run() for ‘MulticoreFuture’ ... done
[10:18:27.551] plan(): Setting new future strategy stack:
[10:18:27.551] Created future:
[10:18:27.551] List of future strategies:
[10:18:27.551] 1. sequential:
[10:18:27.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.551]    - tweaked: FALSE
[10:18:27.551]    - call: NULL
[10:18:27.553] plan(): nbrOfWorkers() = 1
[10:18:27.555] plan(): Setting new future strategy stack:
[10:18:27.555] List of future strategies:
[10:18:27.555] 1. multicore:
[10:18:27.555]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.555]    - tweaked: FALSE
[10:18:27.555]    - call: plan(strategy)
[10:18:27.559] plan(): nbrOfWorkers() = 2
[10:18:27.552] MulticoreFuture:
[10:18:27.552] Label: ‘future_apply-1’
[10:18:27.552] Expression:
[10:18:27.552] {
[10:18:27.552]     do.call(function(...) {
[10:18:27.552]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.552]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.552]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.552]             on.exit(options(oopts), add = TRUE)
[10:18:27.552]         }
[10:18:27.552]         {
[10:18:27.552]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.552]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.552]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.552]             })
[10:18:27.552]         }
[10:18:27.552]     }, args = future.call.arguments)
[10:18:27.552] }
[10:18:27.552] Lazy evaluation: FALSE
[10:18:27.552] Asynchronous evaluation: TRUE
[10:18:27.552] Local evaluation: TRUE
[10:18:27.552] Environment: R_GlobalEnv
[10:18:27.552] Capture standard output: TRUE
[10:18:27.552] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.552] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.552] Packages: <none>
[10:18:27.552] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.552] Resolved: TRUE
[10:18:27.552] Value: <not collected>
[10:18:27.552] Conditions captured: <none>
[10:18:27.552] Early signaling: FALSE
[10:18:27.552] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.552] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.560] Chunk #1 of 2 ... DONE
[10:18:27.560] Chunk #2 of 2 ...
[10:18:27.561]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.561]  - seeds: <none>
[10:18:27.561]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.561] getGlobalsAndPackages() ...
[10:18:27.561] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.562] Resolving globals: FALSE
[10:18:27.562] Tweak future expression to call with '...' arguments ...
[10:18:27.562] {
[10:18:27.562]     do.call(function(...) {
[10:18:27.562]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.562]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.562]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.562]             on.exit(options(oopts), add = TRUE)
[10:18:27.562]         }
[10:18:27.562]         {
[10:18:27.562]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.562]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.562]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.562]             })
[10:18:27.562]         }
[10:18:27.562]     }, args = future.call.arguments)
[10:18:27.562] }
[10:18:27.562] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.563] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.563] 
[10:18:27.563] getGlobalsAndPackages() ... DONE
[10:18:27.564] run() for ‘Future’ ...
[10:18:27.564] - state: ‘created’
[10:18:27.564] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.567] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.567] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.568]   - Field: ‘label’
[10:18:27.568]   - Field: ‘local’
[10:18:27.568]   - Field: ‘owner’
[10:18:27.568]   - Field: ‘envir’
[10:18:27.568]   - Field: ‘workers’
[10:18:27.568]   - Field: ‘packages’
[10:18:27.568]   - Field: ‘gc’
[10:18:27.569]   - Field: ‘job’
[10:18:27.569]   - Field: ‘conditions’
[10:18:27.569]   - Field: ‘expr’
[10:18:27.569]   - Field: ‘uuid’
[10:18:27.569]   - Field: ‘seed’
[10:18:27.569]   - Field: ‘version’
[10:18:27.569]   - Field: ‘result’
[10:18:27.570]   - Field: ‘asynchronous’
[10:18:27.570]   - Field: ‘calls’
[10:18:27.570]   - Field: ‘globals’
[10:18:27.570]   - Field: ‘stdout’
[10:18:27.570]   - Field: ‘earlySignal’
[10:18:27.570]   - Field: ‘lazy’
[10:18:27.571]   - Field: ‘state’
[10:18:27.571] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.571] - Launch lazy future ...
[10:18:27.571] Packages needed by the future expression (n = 0): <none>
[10:18:27.572] Packages needed by future strategies (n = 0): <none>
[10:18:27.572] {
[10:18:27.572]     {
[10:18:27.572]         {
[10:18:27.572]             ...future.startTime <- base::Sys.time()
[10:18:27.572]             {
[10:18:27.572]                 {
[10:18:27.572]                   {
[10:18:27.572]                     {
[10:18:27.572]                       base::local({
[10:18:27.572]                         has_future <- base::requireNamespace("future", 
[10:18:27.572]                           quietly = TRUE)
[10:18:27.572]                         if (has_future) {
[10:18:27.572]                           ns <- base::getNamespace("future")
[10:18:27.572]                           version <- ns[[".package"]][["version"]]
[10:18:27.572]                           if (is.null(version)) 
[10:18:27.572]                             version <- utils::packageVersion("future")
[10:18:27.572]                         }
[10:18:27.572]                         else {
[10:18:27.572]                           version <- NULL
[10:18:27.572]                         }
[10:18:27.572]                         if (!has_future || version < "1.8.0") {
[10:18:27.572]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.572]                             "", base::R.version$version.string), 
[10:18:27.572]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.572]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.572]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.572]                               "release", "version")], collapse = " "), 
[10:18:27.572]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.572]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.572]                             info)
[10:18:27.572]                           info <- base::paste(info, collapse = "; ")
[10:18:27.572]                           if (!has_future) {
[10:18:27.572]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.572]                               info)
[10:18:27.572]                           }
[10:18:27.572]                           else {
[10:18:27.572]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.572]                               info, version)
[10:18:27.572]                           }
[10:18:27.572]                           base::stop(msg)
[10:18:27.572]                         }
[10:18:27.572]                       })
[10:18:27.572]                     }
[10:18:27.572]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.572]                     base::options(mc.cores = 1L)
[10:18:27.572]                   }
[10:18:27.572]                   ...future.strategy.old <- future::plan("list")
[10:18:27.572]                   options(future.plan = NULL)
[10:18:27.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.572]                 }
[10:18:27.572]                 ...future.workdir <- getwd()
[10:18:27.572]             }
[10:18:27.572]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.572]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.572]         }
[10:18:27.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.572]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.572]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.572]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.572]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.572]             base::names(...future.oldOptions))
[10:18:27.572]     }
[10:18:27.572]     if (FALSE) {
[10:18:27.572]     }
[10:18:27.572]     else {
[10:18:27.572]         if (TRUE) {
[10:18:27.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.572]                 open = "w")
[10:18:27.572]         }
[10:18:27.572]         else {
[10:18:27.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.572]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.572]         }
[10:18:27.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.572]             base::sink(type = "output", split = FALSE)
[10:18:27.572]             base::close(...future.stdout)
[10:18:27.572]         }, add = TRUE)
[10:18:27.572]     }
[10:18:27.572]     ...future.frame <- base::sys.nframe()
[10:18:27.572]     ...future.conditions <- base::list()
[10:18:27.572]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.572]     if (FALSE) {
[10:18:27.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.572]     }
[10:18:27.572]     ...future.result <- base::tryCatch({
[10:18:27.572]         base::withCallingHandlers({
[10:18:27.572]             ...future.value <- base::withVisible(base::local({
[10:18:27.572]                 withCallingHandlers({
[10:18:27.572]                   {
[10:18:27.572]                     do.call(function(...) {
[10:18:27.572]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.572]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.572]                         ...future.globals.maxSize)) {
[10:18:27.572]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.572]                         on.exit(options(oopts), add = TRUE)
[10:18:27.572]                       }
[10:18:27.572]                       {
[10:18:27.572]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.572]                           FUN = function(jj) {
[10:18:27.572]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.572]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.572]                           })
[10:18:27.572]                       }
[10:18:27.572]                     }, args = future.call.arguments)
[10:18:27.572]                   }
[10:18:27.572]                 }, immediateCondition = function(cond) {
[10:18:27.572]                   save_rds <- function (object, pathname, ...) 
[10:18:27.572]                   {
[10:18:27.572]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.572]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.572]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.572]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.572]                         fi_tmp[["mtime"]])
[10:18:27.572]                     }
[10:18:27.572]                     tryCatch({
[10:18:27.572]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.572]                     }, error = function(ex) {
[10:18:27.572]                       msg <- conditionMessage(ex)
[10:18:27.572]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.572]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.572]                         fi_tmp[["mtime"]], msg)
[10:18:27.572]                       ex$message <- msg
[10:18:27.572]                       stop(ex)
[10:18:27.572]                     })
[10:18:27.572]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.572]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.572]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.572]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.572]                       fi <- file.info(pathname)
[10:18:27.572]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.572]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.572]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.572]                         fi[["size"]], fi[["mtime"]])
[10:18:27.572]                       stop(msg)
[10:18:27.572]                     }
[10:18:27.572]                     invisible(pathname)
[10:18:27.572]                   }
[10:18:27.572]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.572]                     rootPath = tempdir()) 
[10:18:27.572]                   {
[10:18:27.572]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.572]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.572]                       tmpdir = path, fileext = ".rds")
[10:18:27.572]                     save_rds(obj, file)
[10:18:27.572]                   }
[10:18:27.572]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.572]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.572]                   {
[10:18:27.572]                     inherits <- base::inherits
[10:18:27.572]                     invokeRestart <- base::invokeRestart
[10:18:27.572]                     is.null <- base::is.null
[10:18:27.572]                     muffled <- FALSE
[10:18:27.572]                     if (inherits(cond, "message")) {
[10:18:27.572]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.572]                       if (muffled) 
[10:18:27.572]                         invokeRestart("muffleMessage")
[10:18:27.572]                     }
[10:18:27.572]                     else if (inherits(cond, "warning")) {
[10:18:27.572]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.572]                       if (muffled) 
[10:18:27.572]                         invokeRestart("muffleWarning")
[10:18:27.572]                     }
[10:18:27.572]                     else if (inherits(cond, "condition")) {
[10:18:27.572]                       if (!is.null(pattern)) {
[10:18:27.572]                         computeRestarts <- base::computeRestarts
[10:18:27.572]                         grepl <- base::grepl
[10:18:27.572]                         restarts <- computeRestarts(cond)
[10:18:27.572]                         for (restart in restarts) {
[10:18:27.572]                           name <- restart$name
[10:18:27.572]                           if (is.null(name)) 
[10:18:27.572]                             next
[10:18:27.572]                           if (!grepl(pattern, name)) 
[10:18:27.572]                             next
[10:18:27.572]                           invokeRestart(restart)
[10:18:27.572]                           muffled <- TRUE
[10:18:27.572]                           break
[10:18:27.572]                         }
[10:18:27.572]                       }
[10:18:27.572]                     }
[10:18:27.572]                     invisible(muffled)
[10:18:27.572]                   }
[10:18:27.572]                   muffleCondition(cond)
[10:18:27.572]                 })
[10:18:27.572]             }))
[10:18:27.572]             future::FutureResult(value = ...future.value$value, 
[10:18:27.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.572]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.572]                     ...future.globalenv.names))
[10:18:27.572]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.572]         }, condition = base::local({
[10:18:27.572]             c <- base::c
[10:18:27.572]             inherits <- base::inherits
[10:18:27.572]             invokeRestart <- base::invokeRestart
[10:18:27.572]             length <- base::length
[10:18:27.572]             list <- base::list
[10:18:27.572]             seq.int <- base::seq.int
[10:18:27.572]             signalCondition <- base::signalCondition
[10:18:27.572]             sys.calls <- base::sys.calls
[10:18:27.572]             `[[` <- base::`[[`
[10:18:27.572]             `+` <- base::`+`
[10:18:27.572]             `<<-` <- base::`<<-`
[10:18:27.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.572]                   3L)]
[10:18:27.572]             }
[10:18:27.572]             function(cond) {
[10:18:27.572]                 is_error <- inherits(cond, "error")
[10:18:27.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.572]                   NULL)
[10:18:27.572]                 if (is_error) {
[10:18:27.572]                   sessionInformation <- function() {
[10:18:27.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.572]                       search = base::search(), system = base::Sys.info())
[10:18:27.572]                   }
[10:18:27.572]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.572]                     cond$call), session = sessionInformation(), 
[10:18:27.572]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.572]                   signalCondition(cond)
[10:18:27.572]                 }
[10:18:27.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.572]                 "immediateCondition"))) {
[10:18:27.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.572]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.572]                   if (TRUE && !signal) {
[10:18:27.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.572]                     {
[10:18:27.572]                       inherits <- base::inherits
[10:18:27.572]                       invokeRestart <- base::invokeRestart
[10:18:27.572]                       is.null <- base::is.null
[10:18:27.572]                       muffled <- FALSE
[10:18:27.572]                       if (inherits(cond, "message")) {
[10:18:27.572]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.572]                         if (muffled) 
[10:18:27.572]                           invokeRestart("muffleMessage")
[10:18:27.572]                       }
[10:18:27.572]                       else if (inherits(cond, "warning")) {
[10:18:27.572]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.572]                         if (muffled) 
[10:18:27.572]                           invokeRestart("muffleWarning")
[10:18:27.572]                       }
[10:18:27.572]                       else if (inherits(cond, "condition")) {
[10:18:27.572]                         if (!is.null(pattern)) {
[10:18:27.572]                           computeRestarts <- base::computeRestarts
[10:18:27.572]                           grepl <- base::grepl
[10:18:27.572]                           restarts <- computeRestarts(cond)
[10:18:27.572]                           for (restart in restarts) {
[10:18:27.572]                             name <- restart$name
[10:18:27.572]                             if (is.null(name)) 
[10:18:27.572]                               next
[10:18:27.572]                             if (!grepl(pattern, name)) 
[10:18:27.572]                               next
[10:18:27.572]                             invokeRestart(restart)
[10:18:27.572]                             muffled <- TRUE
[10:18:27.572]                             break
[10:18:27.572]                           }
[10:18:27.572]                         }
[10:18:27.572]                       }
[10:18:27.572]                       invisible(muffled)
[10:18:27.572]                     }
[10:18:27.572]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.572]                   }
[10:18:27.572]                 }
[10:18:27.572]                 else {
[10:18:27.572]                   if (TRUE) {
[10:18:27.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.572]                     {
[10:18:27.572]                       inherits <- base::inherits
[10:18:27.572]                       invokeRestart <- base::invokeRestart
[10:18:27.572]                       is.null <- base::is.null
[10:18:27.572]                       muffled <- FALSE
[10:18:27.572]                       if (inherits(cond, "message")) {
[10:18:27.572]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.572]                         if (muffled) 
[10:18:27.572]                           invokeRestart("muffleMessage")
[10:18:27.572]                       }
[10:18:27.572]                       else if (inherits(cond, "warning")) {
[10:18:27.572]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.572]                         if (muffled) 
[10:18:27.572]                           invokeRestart("muffleWarning")
[10:18:27.572]                       }
[10:18:27.572]                       else if (inherits(cond, "condition")) {
[10:18:27.572]                         if (!is.null(pattern)) {
[10:18:27.572]                           computeRestarts <- base::computeRestarts
[10:18:27.572]                           grepl <- base::grepl
[10:18:27.572]                           restarts <- computeRestarts(cond)
[10:18:27.572]                           for (restart in restarts) {
[10:18:27.572]                             name <- restart$name
[10:18:27.572]                             if (is.null(name)) 
[10:18:27.572]                               next
[10:18:27.572]                             if (!grepl(pattern, name)) 
[10:18:27.572]                               next
[10:18:27.572]                             invokeRestart(restart)
[10:18:27.572]                             muffled <- TRUE
[10:18:27.572]                             break
[10:18:27.572]                           }
[10:18:27.572]                         }
[10:18:27.572]                       }
[10:18:27.572]                       invisible(muffled)
[10:18:27.572]                     }
[10:18:27.572]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.572]                   }
[10:18:27.572]                 }
[10:18:27.572]             }
[10:18:27.572]         }))
[10:18:27.572]     }, error = function(ex) {
[10:18:27.572]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.572]                 ...future.rng), started = ...future.startTime, 
[10:18:27.572]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.572]             version = "1.8"), class = "FutureResult")
[10:18:27.572]     }, finally = {
[10:18:27.572]         if (!identical(...future.workdir, getwd())) 
[10:18:27.572]             setwd(...future.workdir)
[10:18:27.572]         {
[10:18:27.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.572]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.572]             }
[10:18:27.572]             base::options(...future.oldOptions)
[10:18:27.572]             if (.Platform$OS.type == "windows") {
[10:18:27.572]                 old_names <- names(...future.oldEnvVars)
[10:18:27.572]                 envs <- base::Sys.getenv()
[10:18:27.572]                 names <- names(envs)
[10:18:27.572]                 common <- intersect(names, old_names)
[10:18:27.572]                 added <- setdiff(names, old_names)
[10:18:27.572]                 removed <- setdiff(old_names, names)
[10:18:27.572]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.572]                   envs[common]]
[10:18:27.572]                 NAMES <- toupper(changed)
[10:18:27.572]                 args <- list()
[10:18:27.572]                 for (kk in seq_along(NAMES)) {
[10:18:27.572]                   name <- changed[[kk]]
[10:18:27.572]                   NAME <- NAMES[[kk]]
[10:18:27.572]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.572]                     next
[10:18:27.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.572]                 }
[10:18:27.572]                 NAMES <- toupper(added)
[10:18:27.572]                 for (kk in seq_along(NAMES)) {
[10:18:27.572]                   name <- added[[kk]]
[10:18:27.572]                   NAME <- NAMES[[kk]]
[10:18:27.572]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.572]                     next
[10:18:27.572]                   args[[name]] <- ""
[10:18:27.572]                 }
[10:18:27.572]                 NAMES <- toupper(removed)
[10:18:27.572]                 for (kk in seq_along(NAMES)) {
[10:18:27.572]                   name <- removed[[kk]]
[10:18:27.572]                   NAME <- NAMES[[kk]]
[10:18:27.572]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.572]                     next
[10:18:27.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.572]                 }
[10:18:27.572]                 if (length(args) > 0) 
[10:18:27.572]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.572]             }
[10:18:27.572]             else {
[10:18:27.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.572]             }
[10:18:27.572]             {
[10:18:27.572]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.572]                   0L) {
[10:18:27.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.572]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.572]                   base::options(opts)
[10:18:27.572]                 }
[10:18:27.572]                 {
[10:18:27.572]                   {
[10:18:27.572]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.572]                     NULL
[10:18:27.572]                   }
[10:18:27.572]                   options(future.plan = NULL)
[10:18:27.572]                   if (is.na(NA_character_)) 
[10:18:27.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.572]                     .init = FALSE)
[10:18:27.572]                 }
[10:18:27.572]             }
[10:18:27.572]         }
[10:18:27.572]     })
[10:18:27.572]     if (TRUE) {
[10:18:27.572]         base::sink(type = "output", split = FALSE)
[10:18:27.572]         if (TRUE) {
[10:18:27.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.572]         }
[10:18:27.572]         else {
[10:18:27.572]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.572]         }
[10:18:27.572]         base::close(...future.stdout)
[10:18:27.572]         ...future.stdout <- NULL
[10:18:27.572]     }
[10:18:27.572]     ...future.result$conditions <- ...future.conditions
[10:18:27.572]     ...future.result$finished <- base::Sys.time()
[10:18:27.572]     ...future.result
[10:18:27.572] }
[10:18:27.576] assign_globals() ...
[10:18:27.576] List of 5
[10:18:27.576]  $ future.call.arguments    : list()
[10:18:27.576]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.576]  $ ...future.FUN            :function (x)  
[10:18:27.576]  $ ...future.elements_ii    :List of 1
[10:18:27.576]   ..$ : int [1:2, 1:3] 2 4 6 8 10 12
[10:18:27.576]  $ ...future.seeds_ii       : NULL
[10:18:27.576]  $ ...future.globals.maxSize: num Inf
[10:18:27.576]  - attr(*, "resolved")= logi FALSE
[10:18:27.576]  - attr(*, "total_size")= num NA
[10:18:27.576]  - attr(*, "where")=List of 5
[10:18:27.576]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.576]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.576]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.576]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.576]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.576]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.576]  - attr(*, "already-done")= logi TRUE
[10:18:27.584] - copied ‘future.call.arguments’ to environment
[10:18:27.584] - copied ‘...future.FUN’ to environment
[10:18:27.584] - copied ‘...future.elements_ii’ to environment
[10:18:27.584] - copied ‘...future.seeds_ii’ to environment
[10:18:27.584] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.584] assign_globals() ... done
[10:18:27.585] requestCore(): workers = 2
[10:18:27.587] MulticoreFuture started
[10:18:27.587] - Launch lazy future ... done
[10:18:27.588] run() for ‘MulticoreFuture’ ... done
[10:18:27.588] Created future:
[10:18:27.588] plan(): Setting new future strategy stack:
[10:18:27.588] List of future strategies:
[10:18:27.588] 1. sequential:
[10:18:27.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.588]    - tweaked: FALSE
[10:18:27.588]    - call: NULL
[10:18:27.589] plan(): nbrOfWorkers() = 1
[10:18:27.591] plan(): Setting new future strategy stack:
[10:18:27.592] List of future strategies:
[10:18:27.592] 1. multicore:
[10:18:27.592]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.592]    - tweaked: FALSE
[10:18:27.592]    - call: plan(strategy)
[10:18:27.599] plan(): nbrOfWorkers() = 2
[10:18:27.588] MulticoreFuture:
[10:18:27.588] Label: ‘future_apply-2’
[10:18:27.588] Expression:
[10:18:27.588] {
[10:18:27.588]     do.call(function(...) {
[10:18:27.588]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.588]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.588]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.588]             on.exit(options(oopts), add = TRUE)
[10:18:27.588]         }
[10:18:27.588]         {
[10:18:27.588]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.588]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.588]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.588]             })
[10:18:27.588]         }
[10:18:27.588]     }, args = future.call.arguments)
[10:18:27.588] }
[10:18:27.588] Lazy evaluation: FALSE
[10:18:27.588] Asynchronous evaluation: TRUE
[10:18:27.588] Local evaluation: TRUE
[10:18:27.588] Environment: R_GlobalEnv
[10:18:27.588] Capture standard output: TRUE
[10:18:27.588] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.588] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.588] Packages: <none>
[10:18:27.588] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.588] Resolved: TRUE
[10:18:27.588] Value: <not collected>
[10:18:27.588] Conditions captured: <none>
[10:18:27.588] Early signaling: FALSE
[10:18:27.588] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.588] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.601] Chunk #2 of 2 ... DONE
[10:18:27.601] Launching 2 futures (chunks) ... DONE
[10:18:27.601] Resolving 2 futures (chunks) ...
[10:18:27.601] resolve() on list ...
[10:18:27.602]  recursive: 0
[10:18:27.602]  length: 2
[10:18:27.602] 
[10:18:27.602] Future #1
[10:18:27.603] result() for MulticoreFuture ...
[10:18:27.604] result() for MulticoreFuture ...
[10:18:27.606] result() for MulticoreFuture ... done
[10:18:27.607] result() for MulticoreFuture ... done
[10:18:27.607] result() for MulticoreFuture ...
[10:18:27.607] result() for MulticoreFuture ... done
[10:18:27.608] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:27.608] - nx: 2
[10:18:27.609] - relay: TRUE
[10:18:27.609] - stdout: TRUE
[10:18:27.609] - signal: TRUE
[10:18:27.609] - resignal: FALSE
[10:18:27.610] - force: TRUE
[10:18:27.610] - relayed: [n=2] FALSE, FALSE
[10:18:27.610] - queued futures: [n=2] FALSE, FALSE
[10:18:27.611]  - until=1
[10:18:27.611]  - relaying element #1
[10:18:27.611] result() for MulticoreFuture ...
[10:18:27.611] result() for MulticoreFuture ... done
[10:18:27.612] result() for MulticoreFuture ...
[10:18:27.612] result() for MulticoreFuture ... done
[10:18:27.613] result() for MulticoreFuture ...
[10:18:27.613] result() for MulticoreFuture ... done
[10:18:27.613] result() for MulticoreFuture ...
[10:18:27.613] result() for MulticoreFuture ... done
[10:18:27.614] - relayed: [n=2] TRUE, FALSE
[10:18:27.614] - queued futures: [n=2] TRUE, FALSE
[10:18:27.614] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:27.614]  length: 1 (resolved future 1)
[10:18:27.615] Future #2
[10:18:27.615] result() for MulticoreFuture ...
[10:18:27.616] result() for MulticoreFuture ...
[10:18:27.616] result() for MulticoreFuture ... done
[10:18:27.616] result() for MulticoreFuture ... done
[10:18:27.616] result() for MulticoreFuture ...
[10:18:27.616] result() for MulticoreFuture ... done
[10:18:27.616] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:27.617] - nx: 2
[10:18:27.617] - relay: TRUE
[10:18:27.617] - stdout: TRUE
[10:18:27.617] - signal: TRUE
[10:18:27.617] - resignal: FALSE
[10:18:27.617] - force: TRUE
[10:18:27.617] - relayed: [n=2] TRUE, FALSE
[10:18:27.618] - queued futures: [n=2] TRUE, FALSE
[10:18:27.618]  - until=2
[10:18:27.618]  - relaying element #2
[10:18:27.618] result() for MulticoreFuture ...
[10:18:27.618] result() for MulticoreFuture ... done
[10:18:27.618] result() for MulticoreFuture ...
[10:18:27.618] result() for MulticoreFuture ... done
[10:18:27.618] result() for MulticoreFuture ...
[10:18:27.619] result() for MulticoreFuture ... done
[10:18:27.619] result() for MulticoreFuture ...
[10:18:27.619] result() for MulticoreFuture ... done
[10:18:27.619] - relayed: [n=2] TRUE, TRUE
[10:18:27.619] - queued futures: [n=2] TRUE, TRUE
[10:18:27.619] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:27.619]  length: 0 (resolved future 2)
[10:18:27.619] Relaying remaining futures
[10:18:27.619] signalConditionsASAP(NULL, pos=0) ...
[10:18:27.620] - nx: 2
[10:18:27.620] - relay: TRUE
[10:18:27.620] - stdout: TRUE
[10:18:27.620] - signal: TRUE
[10:18:27.620] - resignal: FALSE
[10:18:27.620] - force: TRUE
[10:18:27.620] - relayed: [n=2] TRUE, TRUE
[10:18:27.620] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:27.620] - relayed: [n=2] TRUE, TRUE
[10:18:27.620] - queued futures: [n=2] TRUE, TRUE
[10:18:27.621] signalConditionsASAP(NULL, pos=0) ... done
[10:18:27.621] resolve() on list ... DONE
[10:18:27.621] result() for MulticoreFuture ...
[10:18:27.621] result() for MulticoreFuture ... done
[10:18:27.621] result() for MulticoreFuture ...
[10:18:27.621] result() for MulticoreFuture ... done
[10:18:27.621] result() for MulticoreFuture ...
[10:18:27.621] result() for MulticoreFuture ... done
[10:18:27.621] result() for MulticoreFuture ...
[10:18:27.622] result() for MulticoreFuture ... done
[10:18:27.622]  - Number of value chunks collected: 2
[10:18:27.622] Resolving 2 futures (chunks) ... DONE
[10:18:27.622] Reducing values from 2 chunks ...
[10:18:27.622]  - Number of values collected after concatenation: 2
[10:18:27.622]  - Number of values expected: 2
[10:18:27.622] Reducing values from 2 chunks ... DONE
[10:18:27.622] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:18:27.623] getGlobalsAndPackagesXApply() ...
[10:18:27.623]  - future.globals: TRUE
[10:18:27.623] getGlobalsAndPackages() ...
[10:18:27.623] Searching for globals...
[10:18:27.626] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:18:27.626] Searching for globals ... DONE
[10:18:27.626] Resolving globals: FALSE
[10:18:27.627] The total size of the 1 globals is 1.28 KiB (1311 bytes)
[10:18:27.627] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 1.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.28 KiB of class ‘function’)
[10:18:27.627] - globals: [1] ‘FUN’
[10:18:27.628] 
[10:18:27.628] getGlobalsAndPackages() ... DONE
[10:18:27.628]  - globals found/used: [n=1] ‘FUN’
[10:18:27.628]  - needed namespaces: [n=0] 
[10:18:27.628] Finding globals ... DONE
[10:18:27.628]  - use_args: TRUE
[10:18:27.628]  - Getting '...' globals ...
[10:18:27.629] resolve() on list ...
[10:18:27.629]  recursive: 0
[10:18:27.629]  length: 1
[10:18:27.629]  elements: ‘...’
[10:18:27.629]  length: 0 (resolved future 1)
[10:18:27.629] resolve() on list ... DONE
[10:18:27.629]    - '...' content: [n=0] 
[10:18:27.629] List of 1
[10:18:27.629]  $ ...: list()
[10:18:27.629]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.629]  - attr(*, "where")=List of 1
[10:18:27.629]   ..$ ...:<environment: 0x556e02fbc1c8> 
[10:18:27.629]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.629]  - attr(*, "resolved")= logi TRUE
[10:18:27.629]  - attr(*, "total_size")= num NA
[10:18:27.632]  - Getting '...' globals ... DONE
[10:18:27.632] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:27.632] List of 2
[10:18:27.632]  $ ...future.FUN:function (x)  
[10:18:27.632]  $ ...          : list()
[10:18:27.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.632]  - attr(*, "where")=List of 2
[10:18:27.632]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:27.632]   ..$ ...          :<environment: 0x556e02fbc1c8> 
[10:18:27.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.632]  - attr(*, "resolved")= logi FALSE
[10:18:27.632]  - attr(*, "total_size")= num 4449
[10:18:27.637] Packages to be attached in all futures: [n=0] 
[10:18:27.637] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.639] future_lapply() ...
[10:18:27.642] Number of chunks: 2
[10:18:27.643] getGlobalsAndPackagesXApply() ...
[10:18:27.643]  - future.globals: <name-value list> with names ‘list()’
[10:18:27.643]  - use_args: TRUE
[10:18:27.643] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:27.643] List of 2
[10:18:27.643]  $ ...          : list()
[10:18:27.643]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.643]  $ ...future.FUN:function (x)  
[10:18:27.643]  - attr(*, "where")=List of 2
[10:18:27.643]   ..$ ...          :<environment: 0x556e02fbc1c8> 
[10:18:27.643]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:18:27.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.643]  - attr(*, "resolved")= logi FALSE
[10:18:27.643]  - attr(*, "total_size")= num NA
[10:18:27.646] Packages to be attached in all futures: [n=0] 
[10:18:27.646] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.646] Number of futures (= number of chunks): 2
[10:18:27.646] Launching 2 futures (chunks) ...
[10:18:27.646] Chunk #1 of 2 ...
[10:18:27.647]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.647]  - seeds: <none>
[10:18:27.647]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.647] getGlobalsAndPackages() ...
[10:18:27.647] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.647] Resolving globals: FALSE
[10:18:27.647] Tweak future expression to call with '...' arguments ...
[10:18:27.647] {
[10:18:27.647]     do.call(function(...) {
[10:18:27.647]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.647]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.647]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.647]             on.exit(options(oopts), add = TRUE)
[10:18:27.647]         }
[10:18:27.647]         {
[10:18:27.647]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.647]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.647]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.647]             })
[10:18:27.647]         }
[10:18:27.647]     }, args = future.call.arguments)
[10:18:27.647] }
[10:18:27.648] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.648] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.648] 
[10:18:27.648] getGlobalsAndPackages() ... DONE
[10:18:27.648] run() for ‘Future’ ...
[10:18:27.649] - state: ‘created’
[10:18:27.649] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.650] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.650] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.651]   - Field: ‘label’
[10:18:27.651]   - Field: ‘local’
[10:18:27.651]   - Field: ‘owner’
[10:18:27.651]   - Field: ‘envir’
[10:18:27.651]   - Field: ‘workers’
[10:18:27.651]   - Field: ‘packages’
[10:18:27.651]   - Field: ‘gc’
[10:18:27.651]   - Field: ‘job’
[10:18:27.651]   - Field: ‘conditions’
[10:18:27.651]   - Field: ‘expr’
[10:18:27.651]   - Field: ‘uuid’
[10:18:27.652]   - Field: ‘seed’
[10:18:27.652]   - Field: ‘version’
[10:18:27.652]   - Field: ‘result’
[10:18:27.652]   - Field: ‘asynchronous’
[10:18:27.652]   - Field: ‘calls’
[10:18:27.652]   - Field: ‘globals’
[10:18:27.652]   - Field: ‘stdout’
[10:18:27.652]   - Field: ‘earlySignal’
[10:18:27.652]   - Field: ‘lazy’
[10:18:27.652]   - Field: ‘state’
[10:18:27.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.653] - Launch lazy future ...
[10:18:27.653] Packages needed by the future expression (n = 0): <none>
[10:18:27.653] Packages needed by future strategies (n = 0): <none>
[10:18:27.653] {
[10:18:27.653]     {
[10:18:27.653]         {
[10:18:27.653]             ...future.startTime <- base::Sys.time()
[10:18:27.653]             {
[10:18:27.653]                 {
[10:18:27.653]                   {
[10:18:27.653]                     {
[10:18:27.653]                       base::local({
[10:18:27.653]                         has_future <- base::requireNamespace("future", 
[10:18:27.653]                           quietly = TRUE)
[10:18:27.653]                         if (has_future) {
[10:18:27.653]                           ns <- base::getNamespace("future")
[10:18:27.653]                           version <- ns[[".package"]][["version"]]
[10:18:27.653]                           if (is.null(version)) 
[10:18:27.653]                             version <- utils::packageVersion("future")
[10:18:27.653]                         }
[10:18:27.653]                         else {
[10:18:27.653]                           version <- NULL
[10:18:27.653]                         }
[10:18:27.653]                         if (!has_future || version < "1.8.0") {
[10:18:27.653]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.653]                             "", base::R.version$version.string), 
[10:18:27.653]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.653]                               "release", "version")], collapse = " "), 
[10:18:27.653]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.653]                             info)
[10:18:27.653]                           info <- base::paste(info, collapse = "; ")
[10:18:27.653]                           if (!has_future) {
[10:18:27.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.653]                               info)
[10:18:27.653]                           }
[10:18:27.653]                           else {
[10:18:27.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.653]                               info, version)
[10:18:27.653]                           }
[10:18:27.653]                           base::stop(msg)
[10:18:27.653]                         }
[10:18:27.653]                       })
[10:18:27.653]                     }
[10:18:27.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.653]                     base::options(mc.cores = 1L)
[10:18:27.653]                   }
[10:18:27.653]                   ...future.strategy.old <- future::plan("list")
[10:18:27.653]                   options(future.plan = NULL)
[10:18:27.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.653]                 }
[10:18:27.653]                 ...future.workdir <- getwd()
[10:18:27.653]             }
[10:18:27.653]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.653]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.653]         }
[10:18:27.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.653]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.653]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.653]             base::names(...future.oldOptions))
[10:18:27.653]     }
[10:18:27.653]     if (FALSE) {
[10:18:27.653]     }
[10:18:27.653]     else {
[10:18:27.653]         if (TRUE) {
[10:18:27.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.653]                 open = "w")
[10:18:27.653]         }
[10:18:27.653]         else {
[10:18:27.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.653]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.653]         }
[10:18:27.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.653]             base::sink(type = "output", split = FALSE)
[10:18:27.653]             base::close(...future.stdout)
[10:18:27.653]         }, add = TRUE)
[10:18:27.653]     }
[10:18:27.653]     ...future.frame <- base::sys.nframe()
[10:18:27.653]     ...future.conditions <- base::list()
[10:18:27.653]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.653]     if (FALSE) {
[10:18:27.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.653]     }
[10:18:27.653]     ...future.result <- base::tryCatch({
[10:18:27.653]         base::withCallingHandlers({
[10:18:27.653]             ...future.value <- base::withVisible(base::local({
[10:18:27.653]                 withCallingHandlers({
[10:18:27.653]                   {
[10:18:27.653]                     do.call(function(...) {
[10:18:27.653]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.653]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.653]                         ...future.globals.maxSize)) {
[10:18:27.653]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.653]                         on.exit(options(oopts), add = TRUE)
[10:18:27.653]                       }
[10:18:27.653]                       {
[10:18:27.653]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.653]                           FUN = function(jj) {
[10:18:27.653]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.653]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.653]                           })
[10:18:27.653]                       }
[10:18:27.653]                     }, args = future.call.arguments)
[10:18:27.653]                   }
[10:18:27.653]                 }, immediateCondition = function(cond) {
[10:18:27.653]                   save_rds <- function (object, pathname, ...) 
[10:18:27.653]                   {
[10:18:27.653]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.653]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.653]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.653]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.653]                         fi_tmp[["mtime"]])
[10:18:27.653]                     }
[10:18:27.653]                     tryCatch({
[10:18:27.653]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.653]                     }, error = function(ex) {
[10:18:27.653]                       msg <- conditionMessage(ex)
[10:18:27.653]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.653]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.653]                         fi_tmp[["mtime"]], msg)
[10:18:27.653]                       ex$message <- msg
[10:18:27.653]                       stop(ex)
[10:18:27.653]                     })
[10:18:27.653]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.653]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.653]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.653]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.653]                       fi <- file.info(pathname)
[10:18:27.653]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.653]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.653]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.653]                         fi[["size"]], fi[["mtime"]])
[10:18:27.653]                       stop(msg)
[10:18:27.653]                     }
[10:18:27.653]                     invisible(pathname)
[10:18:27.653]                   }
[10:18:27.653]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.653]                     rootPath = tempdir()) 
[10:18:27.653]                   {
[10:18:27.653]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.653]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.653]                       tmpdir = path, fileext = ".rds")
[10:18:27.653]                     save_rds(obj, file)
[10:18:27.653]                   }
[10:18:27.653]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.653]                   {
[10:18:27.653]                     inherits <- base::inherits
[10:18:27.653]                     invokeRestart <- base::invokeRestart
[10:18:27.653]                     is.null <- base::is.null
[10:18:27.653]                     muffled <- FALSE
[10:18:27.653]                     if (inherits(cond, "message")) {
[10:18:27.653]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.653]                       if (muffled) 
[10:18:27.653]                         invokeRestart("muffleMessage")
[10:18:27.653]                     }
[10:18:27.653]                     else if (inherits(cond, "warning")) {
[10:18:27.653]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.653]                       if (muffled) 
[10:18:27.653]                         invokeRestart("muffleWarning")
[10:18:27.653]                     }
[10:18:27.653]                     else if (inherits(cond, "condition")) {
[10:18:27.653]                       if (!is.null(pattern)) {
[10:18:27.653]                         computeRestarts <- base::computeRestarts
[10:18:27.653]                         grepl <- base::grepl
[10:18:27.653]                         restarts <- computeRestarts(cond)
[10:18:27.653]                         for (restart in restarts) {
[10:18:27.653]                           name <- restart$name
[10:18:27.653]                           if (is.null(name)) 
[10:18:27.653]                             next
[10:18:27.653]                           if (!grepl(pattern, name)) 
[10:18:27.653]                             next
[10:18:27.653]                           invokeRestart(restart)
[10:18:27.653]                           muffled <- TRUE
[10:18:27.653]                           break
[10:18:27.653]                         }
[10:18:27.653]                       }
[10:18:27.653]                     }
[10:18:27.653]                     invisible(muffled)
[10:18:27.653]                   }
[10:18:27.653]                   muffleCondition(cond)
[10:18:27.653]                 })
[10:18:27.653]             }))
[10:18:27.653]             future::FutureResult(value = ...future.value$value, 
[10:18:27.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.653]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.653]                     ...future.globalenv.names))
[10:18:27.653]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.653]         }, condition = base::local({
[10:18:27.653]             c <- base::c
[10:18:27.653]             inherits <- base::inherits
[10:18:27.653]             invokeRestart <- base::invokeRestart
[10:18:27.653]             length <- base::length
[10:18:27.653]             list <- base::list
[10:18:27.653]             seq.int <- base::seq.int
[10:18:27.653]             signalCondition <- base::signalCondition
[10:18:27.653]             sys.calls <- base::sys.calls
[10:18:27.653]             `[[` <- base::`[[`
[10:18:27.653]             `+` <- base::`+`
[10:18:27.653]             `<<-` <- base::`<<-`
[10:18:27.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.653]                   3L)]
[10:18:27.653]             }
[10:18:27.653]             function(cond) {
[10:18:27.653]                 is_error <- inherits(cond, "error")
[10:18:27.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.653]                   NULL)
[10:18:27.653]                 if (is_error) {
[10:18:27.653]                   sessionInformation <- function() {
[10:18:27.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.653]                       search = base::search(), system = base::Sys.info())
[10:18:27.653]                   }
[10:18:27.653]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.653]                     cond$call), session = sessionInformation(), 
[10:18:27.653]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.653]                   signalCondition(cond)
[10:18:27.653]                 }
[10:18:27.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.653]                 "immediateCondition"))) {
[10:18:27.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.653]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.653]                   if (TRUE && !signal) {
[10:18:27.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.653]                     {
[10:18:27.653]                       inherits <- base::inherits
[10:18:27.653]                       invokeRestart <- base::invokeRestart
[10:18:27.653]                       is.null <- base::is.null
[10:18:27.653]                       muffled <- FALSE
[10:18:27.653]                       if (inherits(cond, "message")) {
[10:18:27.653]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.653]                         if (muffled) 
[10:18:27.653]                           invokeRestart("muffleMessage")
[10:18:27.653]                       }
[10:18:27.653]                       else if (inherits(cond, "warning")) {
[10:18:27.653]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.653]                         if (muffled) 
[10:18:27.653]                           invokeRestart("muffleWarning")
[10:18:27.653]                       }
[10:18:27.653]                       else if (inherits(cond, "condition")) {
[10:18:27.653]                         if (!is.null(pattern)) {
[10:18:27.653]                           computeRestarts <- base::computeRestarts
[10:18:27.653]                           grepl <- base::grepl
[10:18:27.653]                           restarts <- computeRestarts(cond)
[10:18:27.653]                           for (restart in restarts) {
[10:18:27.653]                             name <- restart$name
[10:18:27.653]                             if (is.null(name)) 
[10:18:27.653]                               next
[10:18:27.653]                             if (!grepl(pattern, name)) 
[10:18:27.653]                               next
[10:18:27.653]                             invokeRestart(restart)
[10:18:27.653]                             muffled <- TRUE
[10:18:27.653]                             break
[10:18:27.653]                           }
[10:18:27.653]                         }
[10:18:27.653]                       }
[10:18:27.653]                       invisible(muffled)
[10:18:27.653]                     }
[10:18:27.653]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.653]                   }
[10:18:27.653]                 }
[10:18:27.653]                 else {
[10:18:27.653]                   if (TRUE) {
[10:18:27.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.653]                     {
[10:18:27.653]                       inherits <- base::inherits
[10:18:27.653]                       invokeRestart <- base::invokeRestart
[10:18:27.653]                       is.null <- base::is.null
[10:18:27.653]                       muffled <- FALSE
[10:18:27.653]                       if (inherits(cond, "message")) {
[10:18:27.653]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.653]                         if (muffled) 
[10:18:27.653]                           invokeRestart("muffleMessage")
[10:18:27.653]                       }
[10:18:27.653]                       else if (inherits(cond, "warning")) {
[10:18:27.653]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.653]                         if (muffled) 
[10:18:27.653]                           invokeRestart("muffleWarning")
[10:18:27.653]                       }
[10:18:27.653]                       else if (inherits(cond, "condition")) {
[10:18:27.653]                         if (!is.null(pattern)) {
[10:18:27.653]                           computeRestarts <- base::computeRestarts
[10:18:27.653]                           grepl <- base::grepl
[10:18:27.653]                           restarts <- computeRestarts(cond)
[10:18:27.653]                           for (restart in restarts) {
[10:18:27.653]                             name <- restart$name
[10:18:27.653]                             if (is.null(name)) 
[10:18:27.653]                               next
[10:18:27.653]                             if (!grepl(pattern, name)) 
[10:18:27.653]                               next
[10:18:27.653]                             invokeRestart(restart)
[10:18:27.653]                             muffled <- TRUE
[10:18:27.653]                             break
[10:18:27.653]                           }
[10:18:27.653]                         }
[10:18:27.653]                       }
[10:18:27.653]                       invisible(muffled)
[10:18:27.653]                     }
[10:18:27.653]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.653]                   }
[10:18:27.653]                 }
[10:18:27.653]             }
[10:18:27.653]         }))
[10:18:27.653]     }, error = function(ex) {
[10:18:27.653]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.653]                 ...future.rng), started = ...future.startTime, 
[10:18:27.653]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.653]             version = "1.8"), class = "FutureResult")
[10:18:27.653]     }, finally = {
[10:18:27.653]         if (!identical(...future.workdir, getwd())) 
[10:18:27.653]             setwd(...future.workdir)
[10:18:27.653]         {
[10:18:27.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.653]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.653]             }
[10:18:27.653]             base::options(...future.oldOptions)
[10:18:27.653]             if (.Platform$OS.type == "windows") {
[10:18:27.653]                 old_names <- names(...future.oldEnvVars)
[10:18:27.653]                 envs <- base::Sys.getenv()
[10:18:27.653]                 names <- names(envs)
[10:18:27.653]                 common <- intersect(names, old_names)
[10:18:27.653]                 added <- setdiff(names, old_names)
[10:18:27.653]                 removed <- setdiff(old_names, names)
[10:18:27.653]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.653]                   envs[common]]
[10:18:27.653]                 NAMES <- toupper(changed)
[10:18:27.653]                 args <- list()
[10:18:27.653]                 for (kk in seq_along(NAMES)) {
[10:18:27.653]                   name <- changed[[kk]]
[10:18:27.653]                   NAME <- NAMES[[kk]]
[10:18:27.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.653]                     next
[10:18:27.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.653]                 }
[10:18:27.653]                 NAMES <- toupper(added)
[10:18:27.653]                 for (kk in seq_along(NAMES)) {
[10:18:27.653]                   name <- added[[kk]]
[10:18:27.653]                   NAME <- NAMES[[kk]]
[10:18:27.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.653]                     next
[10:18:27.653]                   args[[name]] <- ""
[10:18:27.653]                 }
[10:18:27.653]                 NAMES <- toupper(removed)
[10:18:27.653]                 for (kk in seq_along(NAMES)) {
[10:18:27.653]                   name <- removed[[kk]]
[10:18:27.653]                   NAME <- NAMES[[kk]]
[10:18:27.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.653]                     next
[10:18:27.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.653]                 }
[10:18:27.653]                 if (length(args) > 0) 
[10:18:27.653]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.653]             }
[10:18:27.653]             else {
[10:18:27.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.653]             }
[10:18:27.653]             {
[10:18:27.653]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.653]                   0L) {
[10:18:27.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.653]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.653]                   base::options(opts)
[10:18:27.653]                 }
[10:18:27.653]                 {
[10:18:27.653]                   {
[10:18:27.653]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.653]                     NULL
[10:18:27.653]                   }
[10:18:27.653]                   options(future.plan = NULL)
[10:18:27.653]                   if (is.na(NA_character_)) 
[10:18:27.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.653]                     .init = FALSE)
[10:18:27.653]                 }
[10:18:27.653]             }
[10:18:27.653]         }
[10:18:27.653]     })
[10:18:27.653]     if (TRUE) {
[10:18:27.653]         base::sink(type = "output", split = FALSE)
[10:18:27.653]         if (TRUE) {
[10:18:27.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.653]         }
[10:18:27.653]         else {
[10:18:27.653]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.653]         }
[10:18:27.653]         base::close(...future.stdout)
[10:18:27.653]         ...future.stdout <- NULL
[10:18:27.653]     }
[10:18:27.653]     ...future.result$conditions <- ...future.conditions
[10:18:27.653]     ...future.result$finished <- base::Sys.time()
[10:18:27.653]     ...future.result
[10:18:27.653] }
[10:18:27.656] assign_globals() ...
[10:18:27.656] List of 5
[10:18:27.656]  $ future.call.arguments    : list()
[10:18:27.656]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.656]  $ ...future.FUN            :function (x)  
[10:18:27.656]  $ ...future.elements_ii    :List of 1
[10:18:27.656]   ..$ : int [1:2] 1 3
[10:18:27.656]  $ ...future.seeds_ii       : NULL
[10:18:27.656]  $ ...future.globals.maxSize: num Inf
[10:18:27.656]  - attr(*, "resolved")= logi FALSE
[10:18:27.656]  - attr(*, "total_size")= num NA
[10:18:27.656]  - attr(*, "where")=List of 5
[10:18:27.656]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.656]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.656]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.656]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.656]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.656]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.656]  - attr(*, "already-done")= logi TRUE
[10:18:27.663] - copied ‘future.call.arguments’ to environment
[10:18:27.663] - reassign environment for ‘...future.FUN’
[10:18:27.663] - copied ‘...future.FUN’ to environment
[10:18:27.663] - copied ‘...future.elements_ii’ to environment
[10:18:27.663] - copied ‘...future.seeds_ii’ to environment
[10:18:27.663] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.663] assign_globals() ... done
[10:18:27.663] requestCore(): workers = 2
[10:18:27.666] MulticoreFuture started
[10:18:27.666] - Launch lazy future ... done
[10:18:27.667] run() for ‘MulticoreFuture’ ... done
[10:18:27.667] plan(): Setting new future strategy stack:
[10:18:27.667] Created future:
[10:18:27.667] List of future strategies:
[10:18:27.667] 1. sequential:
[10:18:27.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.667]    - tweaked: FALSE
[10:18:27.667]    - call: NULL
[10:18:27.669] plan(): nbrOfWorkers() = 1
[10:18:27.671] plan(): Setting new future strategy stack:
[10:18:27.671] List of future strategies:
[10:18:27.671] 1. multicore:
[10:18:27.671]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.671]    - tweaked: FALSE
[10:18:27.671]    - call: plan(strategy)
[10:18:27.675] plan(): nbrOfWorkers() = 2
[10:18:27.667] MulticoreFuture:
[10:18:27.667] Label: ‘future_apply-1’
[10:18:27.667] Expression:
[10:18:27.667] {
[10:18:27.667]     do.call(function(...) {
[10:18:27.667]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.667]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.667]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.667]             on.exit(options(oopts), add = TRUE)
[10:18:27.667]         }
[10:18:27.667]         {
[10:18:27.667]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.667]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.667]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.667]             })
[10:18:27.667]         }
[10:18:27.667]     }, args = future.call.arguments)
[10:18:27.667] }
[10:18:27.667] Lazy evaluation: FALSE
[10:18:27.667] Asynchronous evaluation: TRUE
[10:18:27.667] Local evaluation: TRUE
[10:18:27.667] Environment: R_GlobalEnv
[10:18:27.667] Capture standard output: TRUE
[10:18:27.667] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.667] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.667] Packages: <none>
[10:18:27.667] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.667] Resolved: TRUE
[10:18:27.667] Value: <not collected>
[10:18:27.667] Conditions captured: <none>
[10:18:27.667] Early signaling: FALSE
[10:18:27.667] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.667] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.676] Chunk #1 of 2 ... DONE
[10:18:27.676] Chunk #2 of 2 ...
[10:18:27.676]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.676]  - seeds: <none>
[10:18:27.676]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.677] getGlobalsAndPackages() ...
[10:18:27.677] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.677] Resolving globals: FALSE
[10:18:27.677] Tweak future expression to call with '...' arguments ...
[10:18:27.677] {
[10:18:27.677]     do.call(function(...) {
[10:18:27.677]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.677]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.677]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.677]             on.exit(options(oopts), add = TRUE)
[10:18:27.677]         }
[10:18:27.677]         {
[10:18:27.677]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.677]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.677]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.677]             })
[10:18:27.677]         }
[10:18:27.677]     }, args = future.call.arguments)
[10:18:27.677] }
[10:18:27.678] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.678] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.679] 
[10:18:27.679] getGlobalsAndPackages() ... DONE
[10:18:27.679] run() for ‘Future’ ...
[10:18:27.679] - state: ‘created’
[10:18:27.680] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.682] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.683]   - Field: ‘label’
[10:18:27.683]   - Field: ‘local’
[10:18:27.683]   - Field: ‘owner’
[10:18:27.683]   - Field: ‘envir’
[10:18:27.683]   - Field: ‘workers’
[10:18:27.683]   - Field: ‘packages’
[10:18:27.683]   - Field: ‘gc’
[10:18:27.684]   - Field: ‘job’
[10:18:27.684]   - Field: ‘conditions’
[10:18:27.684]   - Field: ‘expr’
[10:18:27.684]   - Field: ‘uuid’
[10:18:27.684]   - Field: ‘seed’
[10:18:27.684]   - Field: ‘version’
[10:18:27.685]   - Field: ‘result’
[10:18:27.685]   - Field: ‘asynchronous’
[10:18:27.685]   - Field: ‘calls’
[10:18:27.685]   - Field: ‘globals’
[10:18:27.685]   - Field: ‘stdout’
[10:18:27.685]   - Field: ‘earlySignal’
[10:18:27.685]   - Field: ‘lazy’
[10:18:27.685]   - Field: ‘state’
[10:18:27.686] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.686] - Launch lazy future ...
[10:18:27.686] Packages needed by the future expression (n = 0): <none>
[10:18:27.686] Packages needed by future strategies (n = 0): <none>
[10:18:27.687] {
[10:18:27.687]     {
[10:18:27.687]         {
[10:18:27.687]             ...future.startTime <- base::Sys.time()
[10:18:27.687]             {
[10:18:27.687]                 {
[10:18:27.687]                   {
[10:18:27.687]                     {
[10:18:27.687]                       base::local({
[10:18:27.687]                         has_future <- base::requireNamespace("future", 
[10:18:27.687]                           quietly = TRUE)
[10:18:27.687]                         if (has_future) {
[10:18:27.687]                           ns <- base::getNamespace("future")
[10:18:27.687]                           version <- ns[[".package"]][["version"]]
[10:18:27.687]                           if (is.null(version)) 
[10:18:27.687]                             version <- utils::packageVersion("future")
[10:18:27.687]                         }
[10:18:27.687]                         else {
[10:18:27.687]                           version <- NULL
[10:18:27.687]                         }
[10:18:27.687]                         if (!has_future || version < "1.8.0") {
[10:18:27.687]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.687]                             "", base::R.version$version.string), 
[10:18:27.687]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.687]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.687]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.687]                               "release", "version")], collapse = " "), 
[10:18:27.687]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.687]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.687]                             info)
[10:18:27.687]                           info <- base::paste(info, collapse = "; ")
[10:18:27.687]                           if (!has_future) {
[10:18:27.687]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.687]                               info)
[10:18:27.687]                           }
[10:18:27.687]                           else {
[10:18:27.687]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.687]                               info, version)
[10:18:27.687]                           }
[10:18:27.687]                           base::stop(msg)
[10:18:27.687]                         }
[10:18:27.687]                       })
[10:18:27.687]                     }
[10:18:27.687]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.687]                     base::options(mc.cores = 1L)
[10:18:27.687]                   }
[10:18:27.687]                   ...future.strategy.old <- future::plan("list")
[10:18:27.687]                   options(future.plan = NULL)
[10:18:27.687]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.687]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.687]                 }
[10:18:27.687]                 ...future.workdir <- getwd()
[10:18:27.687]             }
[10:18:27.687]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.687]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.687]         }
[10:18:27.687]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.687]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.687]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.687]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.687]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.687]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.687]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.687]             base::names(...future.oldOptions))
[10:18:27.687]     }
[10:18:27.687]     if (FALSE) {
[10:18:27.687]     }
[10:18:27.687]     else {
[10:18:27.687]         if (TRUE) {
[10:18:27.687]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.687]                 open = "w")
[10:18:27.687]         }
[10:18:27.687]         else {
[10:18:27.687]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.687]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.687]         }
[10:18:27.687]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.687]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.687]             base::sink(type = "output", split = FALSE)
[10:18:27.687]             base::close(...future.stdout)
[10:18:27.687]         }, add = TRUE)
[10:18:27.687]     }
[10:18:27.687]     ...future.frame <- base::sys.nframe()
[10:18:27.687]     ...future.conditions <- base::list()
[10:18:27.687]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.687]     if (FALSE) {
[10:18:27.687]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.687]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.687]     }
[10:18:27.687]     ...future.result <- base::tryCatch({
[10:18:27.687]         base::withCallingHandlers({
[10:18:27.687]             ...future.value <- base::withVisible(base::local({
[10:18:27.687]                 withCallingHandlers({
[10:18:27.687]                   {
[10:18:27.687]                     do.call(function(...) {
[10:18:27.687]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.687]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.687]                         ...future.globals.maxSize)) {
[10:18:27.687]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.687]                         on.exit(options(oopts), add = TRUE)
[10:18:27.687]                       }
[10:18:27.687]                       {
[10:18:27.687]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.687]                           FUN = function(jj) {
[10:18:27.687]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.687]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.687]                           })
[10:18:27.687]                       }
[10:18:27.687]                     }, args = future.call.arguments)
[10:18:27.687]                   }
[10:18:27.687]                 }, immediateCondition = function(cond) {
[10:18:27.687]                   save_rds <- function (object, pathname, ...) 
[10:18:27.687]                   {
[10:18:27.687]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.687]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.687]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.687]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.687]                         fi_tmp[["mtime"]])
[10:18:27.687]                     }
[10:18:27.687]                     tryCatch({
[10:18:27.687]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.687]                     }, error = function(ex) {
[10:18:27.687]                       msg <- conditionMessage(ex)
[10:18:27.687]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.687]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.687]                         fi_tmp[["mtime"]], msg)
[10:18:27.687]                       ex$message <- msg
[10:18:27.687]                       stop(ex)
[10:18:27.687]                     })
[10:18:27.687]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.687]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.687]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.687]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.687]                       fi <- file.info(pathname)
[10:18:27.687]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.687]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.687]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.687]                         fi[["size"]], fi[["mtime"]])
[10:18:27.687]                       stop(msg)
[10:18:27.687]                     }
[10:18:27.687]                     invisible(pathname)
[10:18:27.687]                   }
[10:18:27.687]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.687]                     rootPath = tempdir()) 
[10:18:27.687]                   {
[10:18:27.687]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.687]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.687]                       tmpdir = path, fileext = ".rds")
[10:18:27.687]                     save_rds(obj, file)
[10:18:27.687]                   }
[10:18:27.687]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.687]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.687]                   {
[10:18:27.687]                     inherits <- base::inherits
[10:18:27.687]                     invokeRestart <- base::invokeRestart
[10:18:27.687]                     is.null <- base::is.null
[10:18:27.687]                     muffled <- FALSE
[10:18:27.687]                     if (inherits(cond, "message")) {
[10:18:27.687]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.687]                       if (muffled) 
[10:18:27.687]                         invokeRestart("muffleMessage")
[10:18:27.687]                     }
[10:18:27.687]                     else if (inherits(cond, "warning")) {
[10:18:27.687]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.687]                       if (muffled) 
[10:18:27.687]                         invokeRestart("muffleWarning")
[10:18:27.687]                     }
[10:18:27.687]                     else if (inherits(cond, "condition")) {
[10:18:27.687]                       if (!is.null(pattern)) {
[10:18:27.687]                         computeRestarts <- base::computeRestarts
[10:18:27.687]                         grepl <- base::grepl
[10:18:27.687]                         restarts <- computeRestarts(cond)
[10:18:27.687]                         for (restart in restarts) {
[10:18:27.687]                           name <- restart$name
[10:18:27.687]                           if (is.null(name)) 
[10:18:27.687]                             next
[10:18:27.687]                           if (!grepl(pattern, name)) 
[10:18:27.687]                             next
[10:18:27.687]                           invokeRestart(restart)
[10:18:27.687]                           muffled <- TRUE
[10:18:27.687]                           break
[10:18:27.687]                         }
[10:18:27.687]                       }
[10:18:27.687]                     }
[10:18:27.687]                     invisible(muffled)
[10:18:27.687]                   }
[10:18:27.687]                   muffleCondition(cond)
[10:18:27.687]                 })
[10:18:27.687]             }))
[10:18:27.687]             future::FutureResult(value = ...future.value$value, 
[10:18:27.687]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.687]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.687]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.687]                     ...future.globalenv.names))
[10:18:27.687]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.687]         }, condition = base::local({
[10:18:27.687]             c <- base::c
[10:18:27.687]             inherits <- base::inherits
[10:18:27.687]             invokeRestart <- base::invokeRestart
[10:18:27.687]             length <- base::length
[10:18:27.687]             list <- base::list
[10:18:27.687]             seq.int <- base::seq.int
[10:18:27.687]             signalCondition <- base::signalCondition
[10:18:27.687]             sys.calls <- base::sys.calls
[10:18:27.687]             `[[` <- base::`[[`
[10:18:27.687]             `+` <- base::`+`
[10:18:27.687]             `<<-` <- base::`<<-`
[10:18:27.687]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.687]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.687]                   3L)]
[10:18:27.687]             }
[10:18:27.687]             function(cond) {
[10:18:27.687]                 is_error <- inherits(cond, "error")
[10:18:27.687]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.687]                   NULL)
[10:18:27.687]                 if (is_error) {
[10:18:27.687]                   sessionInformation <- function() {
[10:18:27.687]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.687]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.687]                       search = base::search(), system = base::Sys.info())
[10:18:27.687]                   }
[10:18:27.687]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.687]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.687]                     cond$call), session = sessionInformation(), 
[10:18:27.687]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.687]                   signalCondition(cond)
[10:18:27.687]                 }
[10:18:27.687]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:27.687]                 "immediateCondition"))) {
[10:18:27.687]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.687]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.687]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.687]                   if (TRUE && !signal) {
[10:18:27.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.687]                     {
[10:18:27.687]                       inherits <- base::inherits
[10:18:27.687]                       invokeRestart <- base::invokeRestart
[10:18:27.687]                       is.null <- base::is.null
[10:18:27.687]                       muffled <- FALSE
[10:18:27.687]                       if (inherits(cond, "message")) {
[10:18:27.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.687]                         if (muffled) 
[10:18:27.687]                           invokeRestart("muffleMessage")
[10:18:27.687]                       }
[10:18:27.687]                       else if (inherits(cond, "warning")) {
[10:18:27.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.687]                         if (muffled) 
[10:18:27.687]                           invokeRestart("muffleWarning")
[10:18:27.687]                       }
[10:18:27.687]                       else if (inherits(cond, "condition")) {
[10:18:27.687]                         if (!is.null(pattern)) {
[10:18:27.687]                           computeRestarts <- base::computeRestarts
[10:18:27.687]                           grepl <- base::grepl
[10:18:27.687]                           restarts <- computeRestarts(cond)
[10:18:27.687]                           for (restart in restarts) {
[10:18:27.687]                             name <- restart$name
[10:18:27.687]                             if (is.null(name)) 
[10:18:27.687]                               next
[10:18:27.687]                             if (!grepl(pattern, name)) 
[10:18:27.687]                               next
[10:18:27.687]                             invokeRestart(restart)
[10:18:27.687]                             muffled <- TRUE
[10:18:27.687]                             break
[10:18:27.687]                           }
[10:18:27.687]                         }
[10:18:27.687]                       }
[10:18:27.687]                       invisible(muffled)
[10:18:27.687]                     }
[10:18:27.687]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.687]                   }
[10:18:27.687]                 }
[10:18:27.687]                 else {
[10:18:27.687]                   if (TRUE) {
[10:18:27.687]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.687]                     {
[10:18:27.687]                       inherits <- base::inherits
[10:18:27.687]                       invokeRestart <- base::invokeRestart
[10:18:27.687]                       is.null <- base::is.null
[10:18:27.687]                       muffled <- FALSE
[10:18:27.687]                       if (inherits(cond, "message")) {
[10:18:27.687]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.687]                         if (muffled) 
[10:18:27.687]                           invokeRestart("muffleMessage")
[10:18:27.687]                       }
[10:18:27.687]                       else if (inherits(cond, "warning")) {
[10:18:27.687]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.687]                         if (muffled) 
[10:18:27.687]                           invokeRestart("muffleWarning")
[10:18:27.687]                       }
[10:18:27.687]                       else if (inherits(cond, "condition")) {
[10:18:27.687]                         if (!is.null(pattern)) {
[10:18:27.687]                           computeRestarts <- base::computeRestarts
[10:18:27.687]                           grepl <- base::grepl
[10:18:27.687]                           restarts <- computeRestarts(cond)
[10:18:27.687]                           for (restart in restarts) {
[10:18:27.687]                             name <- restart$name
[10:18:27.687]                             if (is.null(name)) 
[10:18:27.687]                               next
[10:18:27.687]                             if (!grepl(pattern, name)) 
[10:18:27.687]                               next
[10:18:27.687]                             invokeRestart(restart)
[10:18:27.687]                             muffled <- TRUE
[10:18:27.687]                             break
[10:18:27.687]                           }
[10:18:27.687]                         }
[10:18:27.687]                       }
[10:18:27.687]                       invisible(muffled)
[10:18:27.687]                     }
[10:18:27.687]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.687]                   }
[10:18:27.687]                 }
[10:18:27.687]             }
[10:18:27.687]         }))
[10:18:27.687]     }, error = function(ex) {
[10:18:27.687]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.687]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.687]                 ...future.rng), started = ...future.startTime, 
[10:18:27.687]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.687]             version = "1.8"), class = "FutureResult")
[10:18:27.687]     }, finally = {
[10:18:27.687]         if (!identical(...future.workdir, getwd())) 
[10:18:27.687]             setwd(...future.workdir)
[10:18:27.687]         {
[10:18:27.687]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.687]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.687]             }
[10:18:27.687]             base::options(...future.oldOptions)
[10:18:27.687]             if (.Platform$OS.type == "windows") {
[10:18:27.687]                 old_names <- names(...future.oldEnvVars)
[10:18:27.687]                 envs <- base::Sys.getenv()
[10:18:27.687]                 names <- names(envs)
[10:18:27.687]                 common <- intersect(names, old_names)
[10:18:27.687]                 added <- setdiff(names, old_names)
[10:18:27.687]                 removed <- setdiff(old_names, names)
[10:18:27.687]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.687]                   envs[common]]
[10:18:27.687]                 NAMES <- toupper(changed)
[10:18:27.687]                 args <- list()
[10:18:27.687]                 for (kk in seq_along(NAMES)) {
[10:18:27.687]                   name <- changed[[kk]]
[10:18:27.687]                   NAME <- NAMES[[kk]]
[10:18:27.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.687]                     next
[10:18:27.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.687]                 }
[10:18:27.687]                 NAMES <- toupper(added)
[10:18:27.687]                 for (kk in seq_along(NAMES)) {
[10:18:27.687]                   name <- added[[kk]]
[10:18:27.687]                   NAME <- NAMES[[kk]]
[10:18:27.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.687]                     next
[10:18:27.687]                   args[[name]] <- ""
[10:18:27.687]                 }
[10:18:27.687]                 NAMES <- toupper(removed)
[10:18:27.687]                 for (kk in seq_along(NAMES)) {
[10:18:27.687]                   name <- removed[[kk]]
[10:18:27.687]                   NAME <- NAMES[[kk]]
[10:18:27.687]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.687]                     next
[10:18:27.687]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.687]                 }
[10:18:27.687]                 if (length(args) > 0) 
[10:18:27.687]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.687]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.687]             }
[10:18:27.687]             else {
[10:18:27.687]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.687]             }
[10:18:27.687]             {
[10:18:27.687]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.687]                   0L) {
[10:18:27.687]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.687]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.687]                   base::options(opts)
[10:18:27.687]                 }
[10:18:27.687]                 {
[10:18:27.687]                   {
[10:18:27.687]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.687]                     NULL
[10:18:27.687]                   }
[10:18:27.687]                   options(future.plan = NULL)
[10:18:27.687]                   if (is.na(NA_character_)) 
[10:18:27.687]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.687]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.687]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.687]                     .init = FALSE)
[10:18:27.687]                 }
[10:18:27.687]             }
[10:18:27.687]         }
[10:18:27.687]     })
[10:18:27.687]     if (TRUE) {
[10:18:27.687]         base::sink(type = "output", split = FALSE)
[10:18:27.687]         if (TRUE) {
[10:18:27.687]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.687]         }
[10:18:27.687]         else {
[10:18:27.687]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.687]         }
[10:18:27.687]         base::close(...future.stdout)
[10:18:27.687]         ...future.stdout <- NULL
[10:18:27.687]     }
[10:18:27.687]     ...future.result$conditions <- ...future.conditions
[10:18:27.687]     ...future.result$finished <- base::Sys.time()
[10:18:27.687]     ...future.result
[10:18:27.687] }
[10:18:27.691] assign_globals() ...
[10:18:27.691] List of 5
[10:18:27.691]  $ future.call.arguments    : list()
[10:18:27.691]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.691]  $ ...future.FUN            :function (x)  
[10:18:27.691]  $ ...future.elements_ii    :List of 1
[10:18:27.691]   ..$ : int [1:2] 2 4
[10:18:27.691]  $ ...future.seeds_ii       : NULL
[10:18:27.691]  $ ...future.globals.maxSize: num Inf
[10:18:27.691]  - attr(*, "resolved")= logi FALSE
[10:18:27.691]  - attr(*, "total_size")= num NA
[10:18:27.691]  - attr(*, "where")=List of 5
[10:18:27.691]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.691]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.691]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.691]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.691]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.691]  - attr(*, "already-done")= logi TRUE
[10:18:27.698] - copied ‘future.call.arguments’ to environment
[10:18:27.698] - reassign environment for ‘...future.FUN’
[10:18:27.699] - copied ‘...future.FUN’ to environment
[10:18:27.699] - copied ‘...future.elements_ii’ to environment
[10:18:27.699] - copied ‘...future.seeds_ii’ to environment
[10:18:27.699] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.699] assign_globals() ... done
[10:18:27.699] requestCore(): workers = 2
[10:18:27.702] MulticoreFuture started
[10:18:27.702] - Launch lazy future ... done
[10:18:27.702] run() for ‘MulticoreFuture’ ... done
[10:18:27.703] Created future:
[10:18:27.703] plan(): Setting new future strategy stack:
[10:18:27.703] List of future strategies:
[10:18:27.703] 1. sequential:
[10:18:27.703]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.703]    - tweaked: FALSE
[10:18:27.703]    - call: NULL
[10:18:27.704] plan(): nbrOfWorkers() = 1
[10:18:27.706] plan(): Setting new future strategy stack:
[10:18:27.706] List of future strategies:
[10:18:27.706] 1. multicore:
[10:18:27.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.706]    - tweaked: FALSE
[10:18:27.706]    - call: plan(strategy)
[10:18:27.703] MulticoreFuture:
[10:18:27.703] Label: ‘future_apply-2’
[10:18:27.703] Expression:
[10:18:27.703] {
[10:18:27.703]     do.call(function(...) {
[10:18:27.703]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.703]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.703]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.703]             on.exit(options(oopts), add = TRUE)
[10:18:27.703]         }
[10:18:27.703]         {
[10:18:27.703]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.703]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.703]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.703]             })
[10:18:27.703]         }
[10:18:27.703]     }, args = future.call.arguments)
[10:18:27.703] }
[10:18:27.703] Lazy evaluation: FALSE
[10:18:27.703] Asynchronous evaluation: TRUE
[10:18:27.703] Local evaluation: TRUE
[10:18:27.703] Environment: R_GlobalEnv
[10:18:27.703] Capture standard output: TRUE
[10:18:27.703] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:27.703] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.703] Packages: <none>
[10:18:27.703] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:27.703] Resolved: FALSE
[10:18:27.703] Value: <not collected>
[10:18:27.703] Conditions captured: <none>
[10:18:27.703] Early signaling: FALSE
[10:18:27.703] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.703] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.715] plan(): nbrOfWorkers() = 2
[10:18:27.715] Chunk #2 of 2 ... DONE
[10:18:27.715] Launching 2 futures (chunks) ... DONE
[10:18:27.716] Resolving 2 futures (chunks) ...
[10:18:27.716] resolve() on list ...
[10:18:27.716]  recursive: 0
[10:18:27.716]  length: 2
[10:18:27.719] 
[10:18:27.719] Future #1
[10:18:27.720] result() for MulticoreFuture ...
[10:18:27.721] result() for MulticoreFuture ...
[10:18:27.721] result() for MulticoreFuture ... done
[10:18:27.721] result() for MulticoreFuture ... done
[10:18:27.722] result() for MulticoreFuture ...
[10:18:27.722] result() for MulticoreFuture ... done
[10:18:27.722] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:27.723] - nx: 2
[10:18:27.723] - relay: TRUE
[10:18:27.723] - stdout: TRUE
[10:18:27.723] - signal: TRUE
[10:18:27.724] - resignal: FALSE
[10:18:27.724] - force: TRUE
[10:18:27.724] - relayed: [n=2] FALSE, FALSE
[10:18:27.725] - queued futures: [n=2] FALSE, FALSE
[10:18:27.725]  - until=1
[10:18:27.725]  - relaying element #1
[10:18:27.725] result() for MulticoreFuture ...
[10:18:27.726] result() for MulticoreFuture ... done
[10:18:27.726] result() for MulticoreFuture ...
[10:18:27.726] result() for MulticoreFuture ... done
[10:18:27.727] result() for MulticoreFuture ...
[10:18:27.727] result() for MulticoreFuture ... done
[10:18:27.727] result() for MulticoreFuture ...
[10:18:27.727] result() for MulticoreFuture ... done
[10:18:27.727] - relayed: [n=2] TRUE, FALSE
[10:18:27.727] - queued futures: [n=2] TRUE, FALSE
[10:18:27.728] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:27.728]  length: 1 (resolved future 1)
[10:18:27.728] Future #2
[10:18:27.728] result() for MulticoreFuture ...
[10:18:27.729] result() for MulticoreFuture ...
[10:18:27.729] result() for MulticoreFuture ... done
[10:18:27.729] result() for MulticoreFuture ... done
[10:18:27.729] result() for MulticoreFuture ...
[10:18:27.729] result() for MulticoreFuture ... done
[10:18:27.730] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:27.730] - nx: 2
[10:18:27.730] - relay: TRUE
[10:18:27.730] - stdout: TRUE
[10:18:27.730] - signal: TRUE
[10:18:27.730] - resignal: FALSE
[10:18:27.730] - force: TRUE
[10:18:27.730] - relayed: [n=2] TRUE, FALSE
[10:18:27.731] - queued futures: [n=2] TRUE, FALSE
[10:18:27.731]  - until=2
[10:18:27.731]  - relaying element #2
[10:18:27.731] result() for MulticoreFuture ...
[10:18:27.731] result() for MulticoreFuture ... done
[10:18:27.731] result() for MulticoreFuture ...
[10:18:27.731] result() for MulticoreFuture ... done
[10:18:27.731] result() for MulticoreFuture ...
[10:18:27.732] result() for MulticoreFuture ... done
[10:18:27.732] result() for MulticoreFuture ...
[10:18:27.732] result() for MulticoreFuture ... done
[10:18:27.732] - relayed: [n=2] TRUE, TRUE
[10:18:27.732] - queued futures: [n=2] TRUE, TRUE
[10:18:27.732] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:27.732]  length: 0 (resolved future 2)
[10:18:27.732] Relaying remaining futures
[10:18:27.732] signalConditionsASAP(NULL, pos=0) ...
[10:18:27.733] - nx: 2
[10:18:27.733] - relay: TRUE
[10:18:27.733] - stdout: TRUE
[10:18:27.733] - signal: TRUE
[10:18:27.733] - resignal: FALSE
[10:18:27.733] - force: TRUE
[10:18:27.733] - relayed: [n=2] TRUE, TRUE
[10:18:27.733] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:27.733] - relayed: [n=2] TRUE, TRUE
[10:18:27.733] - queued futures: [n=2] TRUE, TRUE
[10:18:27.734] signalConditionsASAP(NULL, pos=0) ... done
[10:18:27.734] resolve() on list ... DONE
[10:18:27.734] result() for MulticoreFuture ...
[10:18:27.734] result() for MulticoreFuture ... done
[10:18:27.734] result() for MulticoreFuture ...
[10:18:27.734] result() for MulticoreFuture ... done
[10:18:27.734] result() for MulticoreFuture ...
[10:18:27.734] result() for MulticoreFuture ... done
[10:18:27.734] result() for MulticoreFuture ...
[10:18:27.734] result() for MulticoreFuture ... done
[10:18:27.735]  - Number of value chunks collected: 2
[10:18:27.735] Resolving 2 futures (chunks) ... DONE
[10:18:27.735] Reducing values from 2 chunks ...
[10:18:27.735]  - Number of values collected after concatenation: 2
[10:18:27.735]  - Number of values expected: 2
[10:18:27.735] Reducing values from 2 chunks ... DONE
[10:18:27.735] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:18:27.736] getGlobalsAndPackagesXApply() ...
[10:18:27.736]  - future.globals: TRUE
[10:18:27.736] getGlobalsAndPackages() ...
[10:18:27.736] Searching for globals...
[10:18:27.739] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:18:27.740] Searching for globals ... DONE
[10:18:27.740] Resolving globals: FALSE
[10:18:27.740] The total size of the 1 globals is 3.66 KiB (3746 bytes)
[10:18:27.741] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 3.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.66 KiB of class ‘function’)
[10:18:27.741] - globals: [1] ‘FUN’
[10:18:27.741] 
[10:18:27.741] getGlobalsAndPackages() ... DONE
[10:18:27.741]  - globals found/used: [n=1] ‘FUN’
[10:18:27.741]  - needed namespaces: [n=0] 
[10:18:27.741] Finding globals ... DONE
[10:18:27.742]  - use_args: TRUE
[10:18:27.742]  - Getting '...' globals ...
[10:18:27.742] resolve() on list ...
[10:18:27.742]  recursive: 0
[10:18:27.742]  length: 1
[10:18:27.742]  elements: ‘...’
[10:18:27.742]  length: 0 (resolved future 1)
[10:18:27.743] resolve() on list ... DONE
[10:18:27.743]    - '...' content: [n=0] 
[10:18:27.743] List of 1
[10:18:27.743]  $ ...: list()
[10:18:27.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.743]  - attr(*, "where")=List of 1
[10:18:27.743]   ..$ ...:<environment: 0x556e0304c0d0> 
[10:18:27.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.743]  - attr(*, "resolved")= logi TRUE
[10:18:27.743]  - attr(*, "total_size")= num NA
[10:18:27.745]  - Getting '...' globals ... DONE
[10:18:27.748] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:27.748] List of 2
[10:18:27.748]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:18:27.748]  $ ...          : list()
[10:18:27.748]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.748]  - attr(*, "where")=List of 2
[10:18:27.748]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:27.748]   ..$ ...          :<environment: 0x556e0304c0d0> 
[10:18:27.748]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.748]  - attr(*, "resolved")= logi FALSE
[10:18:27.748]  - attr(*, "total_size")= num 9424
[10:18:27.751] Packages to be attached in all futures: [n=0] 
[10:18:27.751] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.753] future_lapply() ...
[10:18:27.755] Generating random seeds ...
[10:18:27.755] Generating random seed streams for 2 elements ...
[10:18:27.755] Generating random seed streams for 2 elements ... DONE
[10:18:27.755] Generating random seeds ... DONE
[10:18:27.755] Will set RNG state on exit: 10407, 1068500591, -1603704740, -1826006590, 1507591261, -1648200315, -1881364239
[10:18:27.757] Number of chunks: 2
[10:18:27.757] getGlobalsAndPackagesXApply() ...
[10:18:27.757]  - future.globals: <name-value list> with names ‘list()’
[10:18:27.757]  - use_args: TRUE
[10:18:27.757] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:27.758] List of 2
[10:18:27.758]  $ ...          : list()
[10:18:27.758]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.758]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:18:27.758]  - attr(*, "where")=List of 2
[10:18:27.758]   ..$ ...          :<environment: 0x556e0304c0d0> 
[10:18:27.758]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:27.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.758]  - attr(*, "resolved")= logi FALSE
[10:18:27.758]  - attr(*, "total_size")= num NA
[10:18:27.761] Packages to be attached in all futures: [n=0] 
[10:18:27.761] getGlobalsAndPackagesXApply() ... DONE
[10:18:27.761] Number of futures (= number of chunks): 2
[10:18:27.761] Launching 2 futures (chunks) ...
[10:18:27.761] Chunk #1 of 2 ...
[10:18:27.762]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.762]  - seeds: [1] <seeds>
[10:18:27.762]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.762] getGlobalsAndPackages() ...
[10:18:27.762] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.762] Resolving globals: FALSE
[10:18:27.762] Tweak future expression to call with '...' arguments ...
[10:18:27.762] {
[10:18:27.762]     do.call(function(...) {
[10:18:27.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.762]             on.exit(options(oopts), add = TRUE)
[10:18:27.762]         }
[10:18:27.762]         {
[10:18:27.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.762]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:27.762]                   envir = globalenv(), inherits = FALSE)
[10:18:27.762]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.762]             })
[10:18:27.762]         }
[10:18:27.762]     }, args = future.call.arguments)
[10:18:27.762] }
[10:18:27.763] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.763] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.763] 
[10:18:27.763] getGlobalsAndPackages() ... DONE
[10:18:27.764] run() for ‘Future’ ...
[10:18:27.764] - state: ‘created’
[10:18:27.764] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.765] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.766] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.766]   - Field: ‘label’
[10:18:27.766]   - Field: ‘local’
[10:18:27.766]   - Field: ‘owner’
[10:18:27.766]   - Field: ‘envir’
[10:18:27.766]   - Field: ‘workers’
[10:18:27.766]   - Field: ‘packages’
[10:18:27.766]   - Field: ‘gc’
[10:18:27.766]   - Field: ‘job’
[10:18:27.766]   - Field: ‘conditions’
[10:18:27.766]   - Field: ‘expr’
[10:18:27.767]   - Field: ‘uuid’
[10:18:27.767]   - Field: ‘seed’
[10:18:27.767]   - Field: ‘version’
[10:18:27.767]   - Field: ‘result’
[10:18:27.767]   - Field: ‘asynchronous’
[10:18:27.767]   - Field: ‘calls’
[10:18:27.767]   - Field: ‘globals’
[10:18:27.767]   - Field: ‘stdout’
[10:18:27.767]   - Field: ‘earlySignal’
[10:18:27.767]   - Field: ‘lazy’
[10:18:27.767]   - Field: ‘state’
[10:18:27.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.768] - Launch lazy future ...
[10:18:27.768] Packages needed by the future expression (n = 0): <none>
[10:18:27.768] Packages needed by future strategies (n = 0): <none>
[10:18:27.768] {
[10:18:27.768]     {
[10:18:27.768]         {
[10:18:27.768]             ...future.startTime <- base::Sys.time()
[10:18:27.768]             {
[10:18:27.768]                 {
[10:18:27.768]                   {
[10:18:27.768]                     {
[10:18:27.768]                       base::local({
[10:18:27.768]                         has_future <- base::requireNamespace("future", 
[10:18:27.768]                           quietly = TRUE)
[10:18:27.768]                         if (has_future) {
[10:18:27.768]                           ns <- base::getNamespace("future")
[10:18:27.768]                           version <- ns[[".package"]][["version"]]
[10:18:27.768]                           if (is.null(version)) 
[10:18:27.768]                             version <- utils::packageVersion("future")
[10:18:27.768]                         }
[10:18:27.768]                         else {
[10:18:27.768]                           version <- NULL
[10:18:27.768]                         }
[10:18:27.768]                         if (!has_future || version < "1.8.0") {
[10:18:27.768]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.768]                             "", base::R.version$version.string), 
[10:18:27.768]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.768]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.768]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.768]                               "release", "version")], collapse = " "), 
[10:18:27.768]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.768]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.768]                             info)
[10:18:27.768]                           info <- base::paste(info, collapse = "; ")
[10:18:27.768]                           if (!has_future) {
[10:18:27.768]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.768]                               info)
[10:18:27.768]                           }
[10:18:27.768]                           else {
[10:18:27.768]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.768]                               info, version)
[10:18:27.768]                           }
[10:18:27.768]                           base::stop(msg)
[10:18:27.768]                         }
[10:18:27.768]                       })
[10:18:27.768]                     }
[10:18:27.768]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.768]                     base::options(mc.cores = 1L)
[10:18:27.768]                   }
[10:18:27.768]                   ...future.strategy.old <- future::plan("list")
[10:18:27.768]                   options(future.plan = NULL)
[10:18:27.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.768]                 }
[10:18:27.768]                 ...future.workdir <- getwd()
[10:18:27.768]             }
[10:18:27.768]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.768]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.768]         }
[10:18:27.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.768]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.768]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.768]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.768]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.768]             base::names(...future.oldOptions))
[10:18:27.768]     }
[10:18:27.768]     if (FALSE) {
[10:18:27.768]     }
[10:18:27.768]     else {
[10:18:27.768]         if (TRUE) {
[10:18:27.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.768]                 open = "w")
[10:18:27.768]         }
[10:18:27.768]         else {
[10:18:27.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.768]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.768]         }
[10:18:27.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.768]             base::sink(type = "output", split = FALSE)
[10:18:27.768]             base::close(...future.stdout)
[10:18:27.768]         }, add = TRUE)
[10:18:27.768]     }
[10:18:27.768]     ...future.frame <- base::sys.nframe()
[10:18:27.768]     ...future.conditions <- base::list()
[10:18:27.768]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.768]     if (FALSE) {
[10:18:27.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.768]     }
[10:18:27.768]     ...future.result <- base::tryCatch({
[10:18:27.768]         base::withCallingHandlers({
[10:18:27.768]             ...future.value <- base::withVisible(base::local({
[10:18:27.768]                 withCallingHandlers({
[10:18:27.768]                   {
[10:18:27.768]                     do.call(function(...) {
[10:18:27.768]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.768]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.768]                         ...future.globals.maxSize)) {
[10:18:27.768]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.768]                         on.exit(options(oopts), add = TRUE)
[10:18:27.768]                       }
[10:18:27.768]                       {
[10:18:27.768]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.768]                           FUN = function(jj) {
[10:18:27.768]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.768]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:27.768]                               envir = globalenv(), inherits = FALSE)
[10:18:27.768]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.768]                           })
[10:18:27.768]                       }
[10:18:27.768]                     }, args = future.call.arguments)
[10:18:27.768]                   }
[10:18:27.768]                 }, immediateCondition = function(cond) {
[10:18:27.768]                   save_rds <- function (object, pathname, ...) 
[10:18:27.768]                   {
[10:18:27.768]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.768]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.768]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.768]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.768]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.768]                         fi_tmp[["mtime"]])
[10:18:27.768]                     }
[10:18:27.768]                     tryCatch({
[10:18:27.768]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.768]                     }, error = function(ex) {
[10:18:27.768]                       msg <- conditionMessage(ex)
[10:18:27.768]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.768]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.768]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.768]                         fi_tmp[["mtime"]], msg)
[10:18:27.768]                       ex$message <- msg
[10:18:27.768]                       stop(ex)
[10:18:27.768]                     })
[10:18:27.768]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.768]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.768]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.768]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.768]                       fi <- file.info(pathname)
[10:18:27.768]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.768]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.768]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.768]                         fi[["size"]], fi[["mtime"]])
[10:18:27.768]                       stop(msg)
[10:18:27.768]                     }
[10:18:27.768]                     invisible(pathname)
[10:18:27.768]                   }
[10:18:27.768]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.768]                     rootPath = tempdir()) 
[10:18:27.768]                   {
[10:18:27.768]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.768]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.768]                       tmpdir = path, fileext = ".rds")
[10:18:27.768]                     save_rds(obj, file)
[10:18:27.768]                   }
[10:18:27.768]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.768]                   {
[10:18:27.768]                     inherits <- base::inherits
[10:18:27.768]                     invokeRestart <- base::invokeRestart
[10:18:27.768]                     is.null <- base::is.null
[10:18:27.768]                     muffled <- FALSE
[10:18:27.768]                     if (inherits(cond, "message")) {
[10:18:27.768]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.768]                       if (muffled) 
[10:18:27.768]                         invokeRestart("muffleMessage")
[10:18:27.768]                     }
[10:18:27.768]                     else if (inherits(cond, "warning")) {
[10:18:27.768]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.768]                       if (muffled) 
[10:18:27.768]                         invokeRestart("muffleWarning")
[10:18:27.768]                     }
[10:18:27.768]                     else if (inherits(cond, "condition")) {
[10:18:27.768]                       if (!is.null(pattern)) {
[10:18:27.768]                         computeRestarts <- base::computeRestarts
[10:18:27.768]                         grepl <- base::grepl
[10:18:27.768]                         restarts <- computeRestarts(cond)
[10:18:27.768]                         for (restart in restarts) {
[10:18:27.768]                           name <- restart$name
[10:18:27.768]                           if (is.null(name)) 
[10:18:27.768]                             next
[10:18:27.768]                           if (!grepl(pattern, name)) 
[10:18:27.768]                             next
[10:18:27.768]                           invokeRestart(restart)
[10:18:27.768]                           muffled <- TRUE
[10:18:27.768]                           break
[10:18:27.768]                         }
[10:18:27.768]                       }
[10:18:27.768]                     }
[10:18:27.768]                     invisible(muffled)
[10:18:27.768]                   }
[10:18:27.768]                   muffleCondition(cond)
[10:18:27.768]                 })
[10:18:27.768]             }))
[10:18:27.768]             future::FutureResult(value = ...future.value$value, 
[10:18:27.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.768]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.768]                     ...future.globalenv.names))
[10:18:27.768]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.768]         }, condition = base::local({
[10:18:27.768]             c <- base::c
[10:18:27.768]             inherits <- base::inherits
[10:18:27.768]             invokeRestart <- base::invokeRestart
[10:18:27.768]             length <- base::length
[10:18:27.768]             list <- base::list
[10:18:27.768]             seq.int <- base::seq.int
[10:18:27.768]             signalCondition <- base::signalCondition
[10:18:27.768]             sys.calls <- base::sys.calls
[10:18:27.768]             `[[` <- base::`[[`
[10:18:27.768]             `+` <- base::`+`
[10:18:27.768]             `<<-` <- base::`<<-`
[10:18:27.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.768]                   3L)]
[10:18:27.768]             }
[10:18:27.768]             function(cond) {
[10:18:27.768]                 is_error <- inherits(cond, "error")
[10:18:27.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.768]                   NULL)
[10:18:27.768]                 if (is_error) {
[10:18:27.768]                   sessionInformation <- function() {
[10:18:27.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.768]                       search = base::search(), system = base::Sys.info())
[10:18:27.768]                   }
[10:18:27.768]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.768]                     cond$call), session = sessionInformation(), 
[10:18:27.768]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.768]                   signalCondition(cond)
[10:18:27.768]                 }
[10:18:27.768]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:18:27.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.768]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.768]                   if (TRUE && !signal) {
[10:18:27.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.768]                     {
[10:18:27.768]                       inherits <- base::inherits
[10:18:27.768]                       invokeRestart <- base::invokeRestart
[10:18:27.768]                       is.null <- base::is.null
[10:18:27.768]                       muffled <- FALSE
[10:18:27.768]                       if (inherits(cond, "message")) {
[10:18:27.768]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.768]                         if (muffled) 
[10:18:27.768]                           invokeRestart("muffleMessage")
[10:18:27.768]                       }
[10:18:27.768]                       else if (inherits(cond, "warning")) {
[10:18:27.768]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.768]                         if (muffled) 
[10:18:27.768]                           invokeRestart("muffleWarning")
[10:18:27.768]                       }
[10:18:27.768]                       else if (inherits(cond, "condition")) {
[10:18:27.768]                         if (!is.null(pattern)) {
[10:18:27.768]                           computeRestarts <- base::computeRestarts
[10:18:27.768]                           grepl <- base::grepl
[10:18:27.768]                           restarts <- computeRestarts(cond)
[10:18:27.768]                           for (restart in restarts) {
[10:18:27.768]                             name <- restart$name
[10:18:27.768]                             if (is.null(name)) 
[10:18:27.768]                               next
[10:18:27.768]                             if (!grepl(pattern, name)) 
[10:18:27.768]                               next
[10:18:27.768]                             invokeRestart(restart)
[10:18:27.768]                             muffled <- TRUE
[10:18:27.768]                             break
[10:18:27.768]                           }
[10:18:27.768]                         }
[10:18:27.768]                       }
[10:18:27.768]                       invisible(muffled)
[10:18:27.768]                     }
[10:18:27.768]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.768]                   }
[10:18:27.768]                 }
[10:18:27.768]                 else {
[10:18:27.768]                   if (TRUE) {
[10:18:27.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.768]                     {
[10:18:27.768]                       inherits <- base::inherits
[10:18:27.768]                       invokeRestart <- base::invokeRestart
[10:18:27.768]                       is.null <- base::is.null
[10:18:27.768]                       muffled <- FALSE
[10:18:27.768]                       if (inherits(cond, "message")) {
[10:18:27.768]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.768]                         if (muffled) 
[10:18:27.768]                           invokeRestart("muffleMessage")
[10:18:27.768]                       }
[10:18:27.768]                       else if (inherits(cond, "warning")) {
[10:18:27.768]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.768]                         if (muffled) 
[10:18:27.768]                           invokeRestart("muffleWarning")
[10:18:27.768]                       }
[10:18:27.768]                       else if (inherits(cond, "condition")) {
[10:18:27.768]                         if (!is.null(pattern)) {
[10:18:27.768]                           computeRestarts <- base::computeRestarts
[10:18:27.768]                           grepl <- base::grepl
[10:18:27.768]                           restarts <- computeRestarts(cond)
[10:18:27.768]                           for (restart in restarts) {
[10:18:27.768]                             name <- restart$name
[10:18:27.768]                             if (is.null(name)) 
[10:18:27.768]                               next
[10:18:27.768]                             if (!grepl(pattern, name)) 
[10:18:27.768]                               next
[10:18:27.768]                             invokeRestart(restart)
[10:18:27.768]                             muffled <- TRUE
[10:18:27.768]                             break
[10:18:27.768]                           }
[10:18:27.768]                         }
[10:18:27.768]                       }
[10:18:27.768]                       invisible(muffled)
[10:18:27.768]                     }
[10:18:27.768]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.768]                   }
[10:18:27.768]                 }
[10:18:27.768]             }
[10:18:27.768]         }))
[10:18:27.768]     }, error = function(ex) {
[10:18:27.768]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.768]                 ...future.rng), started = ...future.startTime, 
[10:18:27.768]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.768]             version = "1.8"), class = "FutureResult")
[10:18:27.768]     }, finally = {
[10:18:27.768]         if (!identical(...future.workdir, getwd())) 
[10:18:27.768]             setwd(...future.workdir)
[10:18:27.768]         {
[10:18:27.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.768]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.768]             }
[10:18:27.768]             base::options(...future.oldOptions)
[10:18:27.768]             if (.Platform$OS.type == "windows") {
[10:18:27.768]                 old_names <- names(...future.oldEnvVars)
[10:18:27.768]                 envs <- base::Sys.getenv()
[10:18:27.768]                 names <- names(envs)
[10:18:27.768]                 common <- intersect(names, old_names)
[10:18:27.768]                 added <- setdiff(names, old_names)
[10:18:27.768]                 removed <- setdiff(old_names, names)
[10:18:27.768]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.768]                   envs[common]]
[10:18:27.768]                 NAMES <- toupper(changed)
[10:18:27.768]                 args <- list()
[10:18:27.768]                 for (kk in seq_along(NAMES)) {
[10:18:27.768]                   name <- changed[[kk]]
[10:18:27.768]                   NAME <- NAMES[[kk]]
[10:18:27.768]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.768]                     next
[10:18:27.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.768]                 }
[10:18:27.768]                 NAMES <- toupper(added)
[10:18:27.768]                 for (kk in seq_along(NAMES)) {
[10:18:27.768]                   name <- added[[kk]]
[10:18:27.768]                   NAME <- NAMES[[kk]]
[10:18:27.768]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.768]                     next
[10:18:27.768]                   args[[name]] <- ""
[10:18:27.768]                 }
[10:18:27.768]                 NAMES <- toupper(removed)
[10:18:27.768]                 for (kk in seq_along(NAMES)) {
[10:18:27.768]                   name <- removed[[kk]]
[10:18:27.768]                   NAME <- NAMES[[kk]]
[10:18:27.768]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.768]                     next
[10:18:27.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.768]                 }
[10:18:27.768]                 if (length(args) > 0) 
[10:18:27.768]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.768]             }
[10:18:27.768]             else {
[10:18:27.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.768]             }
[10:18:27.768]             {
[10:18:27.768]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.768]                   0L) {
[10:18:27.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.768]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.768]                   base::options(opts)
[10:18:27.768]                 }
[10:18:27.768]                 {
[10:18:27.768]                   {
[10:18:27.768]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.768]                     NULL
[10:18:27.768]                   }
[10:18:27.768]                   options(future.plan = NULL)
[10:18:27.768]                   if (is.na(NA_character_)) 
[10:18:27.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.768]                     .init = FALSE)
[10:18:27.768]                 }
[10:18:27.768]             }
[10:18:27.768]         }
[10:18:27.768]     })
[10:18:27.768]     if (TRUE) {
[10:18:27.768]         base::sink(type = "output", split = FALSE)
[10:18:27.768]         if (TRUE) {
[10:18:27.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.768]         }
[10:18:27.768]         else {
[10:18:27.768]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.768]         }
[10:18:27.768]         base::close(...future.stdout)
[10:18:27.768]         ...future.stdout <- NULL
[10:18:27.768]     }
[10:18:27.768]     ...future.result$conditions <- ...future.conditions
[10:18:27.768]     ...future.result$finished <- base::Sys.time()
[10:18:27.768]     ...future.result
[10:18:27.768] }
[10:18:27.773] assign_globals() ...
[10:18:27.773] List of 5
[10:18:27.773]  $ future.call.arguments    : list()
[10:18:27.773]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.773]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:18:27.773]  $ ...future.elements_ii    :List of 1
[10:18:27.773]   ..$ : int [1:2] 1 3
[10:18:27.773]  $ ...future.seeds_ii       :List of 1
[10:18:27.773]   ..$ : int [1:7] 10407 1242173061 -1150840343 -834448425 701050094 -1369558043 -650964284
[10:18:27.773]  $ ...future.globals.maxSize: num Inf
[10:18:27.773]  - attr(*, "resolved")= logi FALSE
[10:18:27.773]  - attr(*, "total_size")= num NA
[10:18:27.773]  - attr(*, "where")=List of 5
[10:18:27.773]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.773]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.773]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.773]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.773]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.773]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.773]  - attr(*, "already-done")= logi TRUE
[10:18:27.778] - copied ‘future.call.arguments’ to environment
[10:18:27.778] - copied ‘...future.FUN’ to environment
[10:18:27.778] - copied ‘...future.elements_ii’ to environment
[10:18:27.779] - copied ‘...future.seeds_ii’ to environment
[10:18:27.779] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.779] assign_globals() ... done
[10:18:27.779] requestCore(): workers = 2
[10:18:27.781] MulticoreFuture started
[10:18:27.782] - Launch lazy future ... done
[10:18:27.782] run() for ‘MulticoreFuture’ ... done
[10:18:27.782] Created future:
[10:18:27.782] plan(): Setting new future strategy stack:
[10:18:27.783] List of future strategies:
[10:18:27.783] 1. sequential:
[10:18:27.783]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.783]    - tweaked: FALSE
[10:18:27.783]    - call: NULL
[10:18:27.783] plan(): nbrOfWorkers() = 1
[10:18:27.786] plan(): Setting new future strategy stack:
[10:18:27.786] List of future strategies:
[10:18:27.786] 1. multicore:
[10:18:27.786]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.786]    - tweaked: FALSE
[10:18:27.786]    - call: plan(strategy)
[10:18:27.789] plan(): nbrOfWorkers() = 2
[10:18:27.782] MulticoreFuture:
[10:18:27.782] Label: ‘future_apply-1’
[10:18:27.782] Expression:
[10:18:27.782] {
[10:18:27.782]     do.call(function(...) {
[10:18:27.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.782]             on.exit(options(oopts), add = TRUE)
[10:18:27.782]         }
[10:18:27.782]         {
[10:18:27.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.782]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:27.782]                   envir = globalenv(), inherits = FALSE)
[10:18:27.782]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.782]             })
[10:18:27.782]         }
[10:18:27.782]     }, args = future.call.arguments)
[10:18:27.782] }
[10:18:27.782] Lazy evaluation: FALSE
[10:18:27.782] Asynchronous evaluation: TRUE
[10:18:27.782] Local evaluation: TRUE
[10:18:27.782] Environment: R_GlobalEnv
[10:18:27.782] Capture standard output: TRUE
[10:18:27.782] Capture condition classes: <none>
[10:18:27.782] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.782] Packages: <none>
[10:18:27.782] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:18:27.782] Resolved: TRUE
[10:18:27.782] Value: <not collected>
[10:18:27.782] Conditions captured: <none>
[10:18:27.782] Early signaling: FALSE
[10:18:27.782] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.782] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.790] Chunk #1 of 2 ... DONE
[10:18:27.790] Chunk #2 of 2 ...
[10:18:27.791]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:27.791]  - seeds: [1] <seeds>
[10:18:27.791]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.791] getGlobalsAndPackages() ...
[10:18:27.791] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.791] Resolving globals: FALSE
[10:18:27.792] Tweak future expression to call with '...' arguments ...
[10:18:27.792] {
[10:18:27.792]     do.call(function(...) {
[10:18:27.792]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.792]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.792]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.792]             on.exit(options(oopts), add = TRUE)
[10:18:27.792]         }
[10:18:27.792]         {
[10:18:27.792]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.792]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.792]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:27.792]                   envir = globalenv(), inherits = FALSE)
[10:18:27.792]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.792]             })
[10:18:27.792]         }
[10:18:27.792]     }, args = future.call.arguments)
[10:18:27.792] }
[10:18:27.792] Tweak future expression to call with '...' arguments ... DONE
[10:18:27.793] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:27.793] 
[10:18:27.793] getGlobalsAndPackages() ... DONE
[10:18:27.794] run() for ‘Future’ ...
[10:18:27.794] - state: ‘created’
[10:18:27.794] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:18:27.797] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:18:27.797]   - Field: ‘label’
[10:18:27.797]   - Field: ‘local’
[10:18:27.797]   - Field: ‘owner’
[10:18:27.798]   - Field: ‘envir’
[10:18:27.798]   - Field: ‘workers’
[10:18:27.798]   - Field: ‘packages’
[10:18:27.798]   - Field: ‘gc’
[10:18:27.798]   - Field: ‘job’
[10:18:27.798]   - Field: ‘conditions’
[10:18:27.798]   - Field: ‘expr’
[10:18:27.799]   - Field: ‘uuid’
[10:18:27.799]   - Field: ‘seed’
[10:18:27.799]   - Field: ‘version’
[10:18:27.799]   - Field: ‘result’
[10:18:27.799]   - Field: ‘asynchronous’
[10:18:27.799]   - Field: ‘calls’
[10:18:27.799]   - Field: ‘globals’
[10:18:27.800]   - Field: ‘stdout’
[10:18:27.800]   - Field: ‘earlySignal’
[10:18:27.800]   - Field: ‘lazy’
[10:18:27.800]   - Field: ‘state’
[10:18:27.800] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:18:27.800] - Launch lazy future ...
[10:18:27.801] Packages needed by the future expression (n = 0): <none>
[10:18:27.801] Packages needed by future strategies (n = 0): <none>
[10:18:27.802] {
[10:18:27.802]     {
[10:18:27.802]         {
[10:18:27.802]             ...future.startTime <- base::Sys.time()
[10:18:27.802]             {
[10:18:27.802]                 {
[10:18:27.802]                   {
[10:18:27.802]                     {
[10:18:27.802]                       base::local({
[10:18:27.802]                         has_future <- base::requireNamespace("future", 
[10:18:27.802]                           quietly = TRUE)
[10:18:27.802]                         if (has_future) {
[10:18:27.802]                           ns <- base::getNamespace("future")
[10:18:27.802]                           version <- ns[[".package"]][["version"]]
[10:18:27.802]                           if (is.null(version)) 
[10:18:27.802]                             version <- utils::packageVersion("future")
[10:18:27.802]                         }
[10:18:27.802]                         else {
[10:18:27.802]                           version <- NULL
[10:18:27.802]                         }
[10:18:27.802]                         if (!has_future || version < "1.8.0") {
[10:18:27.802]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:27.802]                             "", base::R.version$version.string), 
[10:18:27.802]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:27.802]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:27.802]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:27.802]                               "release", "version")], collapse = " "), 
[10:18:27.802]                             hostname = base::Sys.info()[["nodename"]])
[10:18:27.802]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:27.802]                             info)
[10:18:27.802]                           info <- base::paste(info, collapse = "; ")
[10:18:27.802]                           if (!has_future) {
[10:18:27.802]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:27.802]                               info)
[10:18:27.802]                           }
[10:18:27.802]                           else {
[10:18:27.802]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:27.802]                               info, version)
[10:18:27.802]                           }
[10:18:27.802]                           base::stop(msg)
[10:18:27.802]                         }
[10:18:27.802]                       })
[10:18:27.802]                     }
[10:18:27.802]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:27.802]                     base::options(mc.cores = 1L)
[10:18:27.802]                   }
[10:18:27.802]                   ...future.strategy.old <- future::plan("list")
[10:18:27.802]                   options(future.plan = NULL)
[10:18:27.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:27.802]                 }
[10:18:27.802]                 ...future.workdir <- getwd()
[10:18:27.802]             }
[10:18:27.802]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:27.802]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:27.802]         }
[10:18:27.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:27.802]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:27.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:27.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:27.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:27.802]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:27.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:27.802]             base::names(...future.oldOptions))
[10:18:27.802]     }
[10:18:27.802]     if (FALSE) {
[10:18:27.802]     }
[10:18:27.802]     else {
[10:18:27.802]         if (TRUE) {
[10:18:27.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:27.802]                 open = "w")
[10:18:27.802]         }
[10:18:27.802]         else {
[10:18:27.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:27.802]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:27.802]         }
[10:18:27.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:27.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:27.802]             base::sink(type = "output", split = FALSE)
[10:18:27.802]             base::close(...future.stdout)
[10:18:27.802]         }, add = TRUE)
[10:18:27.802]     }
[10:18:27.802]     ...future.frame <- base::sys.nframe()
[10:18:27.802]     ...future.conditions <- base::list()
[10:18:27.802]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:27.802]     if (FALSE) {
[10:18:27.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:27.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:27.802]     }
[10:18:27.802]     ...future.result <- base::tryCatch({
[10:18:27.802]         base::withCallingHandlers({
[10:18:27.802]             ...future.value <- base::withVisible(base::local({
[10:18:27.802]                 withCallingHandlers({
[10:18:27.802]                   {
[10:18:27.802]                     do.call(function(...) {
[10:18:27.802]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.802]                       if (!identical(...future.globals.maxSize.org, 
[10:18:27.802]                         ...future.globals.maxSize)) {
[10:18:27.802]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.802]                         on.exit(options(oopts), add = TRUE)
[10:18:27.802]                       }
[10:18:27.802]                       {
[10:18:27.802]                         lapply(seq_along(...future.elements_ii), 
[10:18:27.802]                           FUN = function(jj) {
[10:18:27.802]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.802]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:27.802]                               envir = globalenv(), inherits = FALSE)
[10:18:27.802]                             ...future.FUN(...future.X_jj, ...)
[10:18:27.802]                           })
[10:18:27.802]                       }
[10:18:27.802]                     }, args = future.call.arguments)
[10:18:27.802]                   }
[10:18:27.802]                 }, immediateCondition = function(cond) {
[10:18:27.802]                   save_rds <- function (object, pathname, ...) 
[10:18:27.802]                   {
[10:18:27.802]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:18:27.802]                     if (file_test("-f", pathname_tmp)) {
[10:18:27.802]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.802]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:18:27.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.802]                         fi_tmp[["mtime"]])
[10:18:27.802]                     }
[10:18:27.802]                     tryCatch({
[10:18:27.802]                       saveRDS(object, file = pathname_tmp, ...)
[10:18:27.802]                     }, error = function(ex) {
[10:18:27.802]                       msg <- conditionMessage(ex)
[10:18:27.802]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.802]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:18:27.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.802]                         fi_tmp[["mtime"]], msg)
[10:18:27.802]                       ex$message <- msg
[10:18:27.802]                       stop(ex)
[10:18:27.802]                     })
[10:18:27.802]                     stopifnot(file_test("-f", pathname_tmp))
[10:18:27.802]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:18:27.802]                     if (!res || file_test("-f", pathname_tmp)) {
[10:18:27.802]                       fi_tmp <- file.info(pathname_tmp)
[10:18:27.802]                       fi <- file.info(pathname)
[10:18:27.802]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:18:27.802]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:18:27.802]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:18:27.802]                         fi[["size"]], fi[["mtime"]])
[10:18:27.802]                       stop(msg)
[10:18:27.802]                     }
[10:18:27.802]                     invisible(pathname)
[10:18:27.802]                   }
[10:18:27.802]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:18:27.802]                     rootPath = tempdir()) 
[10:18:27.802]                   {
[10:18:27.802]                     obj <- list(time = Sys.time(), condition = cond)
[10:18:27.802]                     file <- tempfile(pattern = class(cond)[1], 
[10:18:27.802]                       tmpdir = path, fileext = ".rds")
[10:18:27.802]                     save_rds(obj, file)
[10:18:27.802]                   }
[10:18:27.802]                   saveImmediateCondition(cond, path = "/tmp/RtmpQh7YIP/.future/immediateConditions")
[10:18:27.802]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.802]                   {
[10:18:27.802]                     inherits <- base::inherits
[10:18:27.802]                     invokeRestart <- base::invokeRestart
[10:18:27.802]                     is.null <- base::is.null
[10:18:27.802]                     muffled <- FALSE
[10:18:27.802]                     if (inherits(cond, "message")) {
[10:18:27.802]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:27.802]                       if (muffled) 
[10:18:27.802]                         invokeRestart("muffleMessage")
[10:18:27.802]                     }
[10:18:27.802]                     else if (inherits(cond, "warning")) {
[10:18:27.802]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:27.802]                       if (muffled) 
[10:18:27.802]                         invokeRestart("muffleWarning")
[10:18:27.802]                     }
[10:18:27.802]                     else if (inherits(cond, "condition")) {
[10:18:27.802]                       if (!is.null(pattern)) {
[10:18:27.802]                         computeRestarts <- base::computeRestarts
[10:18:27.802]                         grepl <- base::grepl
[10:18:27.802]                         restarts <- computeRestarts(cond)
[10:18:27.802]                         for (restart in restarts) {
[10:18:27.802]                           name <- restart$name
[10:18:27.802]                           if (is.null(name)) 
[10:18:27.802]                             next
[10:18:27.802]                           if (!grepl(pattern, name)) 
[10:18:27.802]                             next
[10:18:27.802]                           invokeRestart(restart)
[10:18:27.802]                           muffled <- TRUE
[10:18:27.802]                           break
[10:18:27.802]                         }
[10:18:27.802]                       }
[10:18:27.802]                     }
[10:18:27.802]                     invisible(muffled)
[10:18:27.802]                   }
[10:18:27.802]                   muffleCondition(cond)
[10:18:27.802]                 })
[10:18:27.802]             }))
[10:18:27.802]             future::FutureResult(value = ...future.value$value, 
[10:18:27.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.802]                   ...future.rng), globalenv = if (FALSE) 
[10:18:27.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:27.802]                     ...future.globalenv.names))
[10:18:27.802]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:27.802]         }, condition = base::local({
[10:18:27.802]             c <- base::c
[10:18:27.802]             inherits <- base::inherits
[10:18:27.802]             invokeRestart <- base::invokeRestart
[10:18:27.802]             length <- base::length
[10:18:27.802]             list <- base::list
[10:18:27.802]             seq.int <- base::seq.int
[10:18:27.802]             signalCondition <- base::signalCondition
[10:18:27.802]             sys.calls <- base::sys.calls
[10:18:27.802]             `[[` <- base::`[[`
[10:18:27.802]             `+` <- base::`+`
[10:18:27.802]             `<<-` <- base::`<<-`
[10:18:27.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:27.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:27.802]                   3L)]
[10:18:27.802]             }
[10:18:27.802]             function(cond) {
[10:18:27.802]                 is_error <- inherits(cond, "error")
[10:18:27.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:27.802]                   NULL)
[10:18:27.802]                 if (is_error) {
[10:18:27.802]                   sessionInformation <- function() {
[10:18:27.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:27.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:27.802]                       search = base::search(), system = base::Sys.info())
[10:18:27.802]                   }
[10:18:27.802]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:27.802]                     cond$call), session = sessionInformation(), 
[10:18:27.802]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:27.802]                   signalCondition(cond)
[10:18:27.802]                 }
[10:18:27.802]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:18:27.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:27.802]                   ...future.conditions[[length(...future.conditions) + 
[10:18:27.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:27.802]                   if (TRUE && !signal) {
[10:18:27.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.802]                     {
[10:18:27.802]                       inherits <- base::inherits
[10:18:27.802]                       invokeRestart <- base::invokeRestart
[10:18:27.802]                       is.null <- base::is.null
[10:18:27.802]                       muffled <- FALSE
[10:18:27.802]                       if (inherits(cond, "message")) {
[10:18:27.802]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.802]                         if (muffled) 
[10:18:27.802]                           invokeRestart("muffleMessage")
[10:18:27.802]                       }
[10:18:27.802]                       else if (inherits(cond, "warning")) {
[10:18:27.802]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.802]                         if (muffled) 
[10:18:27.802]                           invokeRestart("muffleWarning")
[10:18:27.802]                       }
[10:18:27.802]                       else if (inherits(cond, "condition")) {
[10:18:27.802]                         if (!is.null(pattern)) {
[10:18:27.802]                           computeRestarts <- base::computeRestarts
[10:18:27.802]                           grepl <- base::grepl
[10:18:27.802]                           restarts <- computeRestarts(cond)
[10:18:27.802]                           for (restart in restarts) {
[10:18:27.802]                             name <- restart$name
[10:18:27.802]                             if (is.null(name)) 
[10:18:27.802]                               next
[10:18:27.802]                             if (!grepl(pattern, name)) 
[10:18:27.802]                               next
[10:18:27.802]                             invokeRestart(restart)
[10:18:27.802]                             muffled <- TRUE
[10:18:27.802]                             break
[10:18:27.802]                           }
[10:18:27.802]                         }
[10:18:27.802]                       }
[10:18:27.802]                       invisible(muffled)
[10:18:27.802]                     }
[10:18:27.802]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.802]                   }
[10:18:27.802]                 }
[10:18:27.802]                 else {
[10:18:27.802]                   if (TRUE) {
[10:18:27.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:27.802]                     {
[10:18:27.802]                       inherits <- base::inherits
[10:18:27.802]                       invokeRestart <- base::invokeRestart
[10:18:27.802]                       is.null <- base::is.null
[10:18:27.802]                       muffled <- FALSE
[10:18:27.802]                       if (inherits(cond, "message")) {
[10:18:27.802]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:27.802]                         if (muffled) 
[10:18:27.802]                           invokeRestart("muffleMessage")
[10:18:27.802]                       }
[10:18:27.802]                       else if (inherits(cond, "warning")) {
[10:18:27.802]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:27.802]                         if (muffled) 
[10:18:27.802]                           invokeRestart("muffleWarning")
[10:18:27.802]                       }
[10:18:27.802]                       else if (inherits(cond, "condition")) {
[10:18:27.802]                         if (!is.null(pattern)) {
[10:18:27.802]                           computeRestarts <- base::computeRestarts
[10:18:27.802]                           grepl <- base::grepl
[10:18:27.802]                           restarts <- computeRestarts(cond)
[10:18:27.802]                           for (restart in restarts) {
[10:18:27.802]                             name <- restart$name
[10:18:27.802]                             if (is.null(name)) 
[10:18:27.802]                               next
[10:18:27.802]                             if (!grepl(pattern, name)) 
[10:18:27.802]                               next
[10:18:27.802]                             invokeRestart(restart)
[10:18:27.802]                             muffled <- TRUE
[10:18:27.802]                             break
[10:18:27.802]                           }
[10:18:27.802]                         }
[10:18:27.802]                       }
[10:18:27.802]                       invisible(muffled)
[10:18:27.802]                     }
[10:18:27.802]                     muffleCondition(cond, pattern = "^muffle")
[10:18:27.802]                   }
[10:18:27.802]                 }
[10:18:27.802]             }
[10:18:27.802]         }))
[10:18:27.802]     }, error = function(ex) {
[10:18:27.802]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:27.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:27.802]                 ...future.rng), started = ...future.startTime, 
[10:18:27.802]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:27.802]             version = "1.8"), class = "FutureResult")
[10:18:27.802]     }, finally = {
[10:18:27.802]         if (!identical(...future.workdir, getwd())) 
[10:18:27.802]             setwd(...future.workdir)
[10:18:27.802]         {
[10:18:27.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:27.802]                 ...future.oldOptions$nwarnings <- NULL
[10:18:27.802]             }
[10:18:27.802]             base::options(...future.oldOptions)
[10:18:27.802]             if (.Platform$OS.type == "windows") {
[10:18:27.802]                 old_names <- names(...future.oldEnvVars)
[10:18:27.802]                 envs <- base::Sys.getenv()
[10:18:27.802]                 names <- names(envs)
[10:18:27.802]                 common <- intersect(names, old_names)
[10:18:27.802]                 added <- setdiff(names, old_names)
[10:18:27.802]                 removed <- setdiff(old_names, names)
[10:18:27.802]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:27.802]                   envs[common]]
[10:18:27.802]                 NAMES <- toupper(changed)
[10:18:27.802]                 args <- list()
[10:18:27.802]                 for (kk in seq_along(NAMES)) {
[10:18:27.802]                   name <- changed[[kk]]
[10:18:27.802]                   NAME <- NAMES[[kk]]
[10:18:27.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.802]                     next
[10:18:27.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.802]                 }
[10:18:27.802]                 NAMES <- toupper(added)
[10:18:27.802]                 for (kk in seq_along(NAMES)) {
[10:18:27.802]                   name <- added[[kk]]
[10:18:27.802]                   NAME <- NAMES[[kk]]
[10:18:27.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.802]                     next
[10:18:27.802]                   args[[name]] <- ""
[10:18:27.802]                 }
[10:18:27.802]                 NAMES <- toupper(removed)
[10:18:27.802]                 for (kk in seq_along(NAMES)) {
[10:18:27.802]                   name <- removed[[kk]]
[10:18:27.802]                   NAME <- NAMES[[kk]]
[10:18:27.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:27.802]                     next
[10:18:27.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:27.802]                 }
[10:18:27.802]                 if (length(args) > 0) 
[10:18:27.802]                   base::do.call(base::Sys.setenv, args = args)
[10:18:27.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:27.802]             }
[10:18:27.802]             else {
[10:18:27.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:27.802]             }
[10:18:27.802]             {
[10:18:27.802]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:27.802]                   0L) {
[10:18:27.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:27.802]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:27.802]                   base::options(opts)
[10:18:27.802]                 }
[10:18:27.802]                 {
[10:18:27.802]                   {
[10:18:27.802]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:27.802]                     NULL
[10:18:27.802]                   }
[10:18:27.802]                   options(future.plan = NULL)
[10:18:27.802]                   if (is.na(NA_character_)) 
[10:18:27.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:27.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:27.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:27.802]                     .init = FALSE)
[10:18:27.802]                 }
[10:18:27.802]             }
[10:18:27.802]         }
[10:18:27.802]     })
[10:18:27.802]     if (TRUE) {
[10:18:27.802]         base::sink(type = "output", split = FALSE)
[10:18:27.802]         if (TRUE) {
[10:18:27.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:27.802]         }
[10:18:27.802]         else {
[10:18:27.802]             ...future.result["stdout"] <- base::list(NULL)
[10:18:27.802]         }
[10:18:27.802]         base::close(...future.stdout)
[10:18:27.802]         ...future.stdout <- NULL
[10:18:27.802]     }
[10:18:27.802]     ...future.result$conditions <- ...future.conditions
[10:18:27.802]     ...future.result$finished <- base::Sys.time()
[10:18:27.802]     ...future.result
[10:18:27.802] }
[10:18:27.806] assign_globals() ...
[10:18:27.806] List of 5
[10:18:27.806]  $ future.call.arguments    : list()
[10:18:27.806]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:27.806]  $ ...future.FUN            :function (x, size, replace = FALSE, prob = NULL)  
[10:18:27.806]  $ ...future.elements_ii    :List of 1
[10:18:27.806]   ..$ : int [1:2] 2 4
[10:18:27.806]  $ ...future.seeds_ii       :List of 1
[10:18:27.806]   ..$ : int [1:7] 10407 859061261 1088872332 -1371790091 -942478768 -889560561 1393381402
[10:18:27.806]  $ ...future.globals.maxSize: num Inf
[10:18:27.806]  - attr(*, "resolved")= logi FALSE
[10:18:27.806]  - attr(*, "total_size")= num NA
[10:18:27.806]  - attr(*, "where")=List of 5
[10:18:27.806]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:18:27.806]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:18:27.806]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:18:27.806]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:18:27.806]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:18:27.806]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:27.806]  - attr(*, "already-done")= logi TRUE
[10:18:27.818] - copied ‘future.call.arguments’ to environment
[10:18:27.818] - copied ‘...future.FUN’ to environment
[10:18:27.819] - copied ‘...future.elements_ii’ to environment
[10:18:27.819] - copied ‘...future.seeds_ii’ to environment
[10:18:27.819] - copied ‘...future.globals.maxSize’ to environment
[10:18:27.819] assign_globals() ... done
[10:18:27.819] requestCore(): workers = 2
[10:18:27.822] MulticoreFuture started
[10:18:27.823] - Launch lazy future ... done
[10:18:27.823] run() for ‘MulticoreFuture’ ... done
[10:18:27.824] plan(): Setting new future strategy stack:
[10:18:27.824] Created future:
[10:18:27.824] List of future strategies:
[10:18:27.824] 1. sequential:
[10:18:27.824]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.824]    - tweaked: FALSE
[10:18:27.824]    - call: NULL
[10:18:27.825] plan(): nbrOfWorkers() = 1
[10:18:27.827] plan(): Setting new future strategy stack:
[10:18:27.828] List of future strategies:
[10:18:27.828] 1. multicore:
[10:18:27.828]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:18:27.828]    - tweaked: FALSE
[10:18:27.828]    - call: plan(strategy)
[10:18:27.831] plan(): nbrOfWorkers() = 2
[10:18:27.824] MulticoreFuture:
[10:18:27.824] Label: ‘future_apply-2’
[10:18:27.824] Expression:
[10:18:27.824] {
[10:18:27.824]     do.call(function(...) {
[10:18:27.824]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:27.824]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:27.824]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:27.824]             on.exit(options(oopts), add = TRUE)
[10:18:27.824]         }
[10:18:27.824]         {
[10:18:27.824]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:27.824]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:27.824]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:27.824]                   envir = globalenv(), inherits = FALSE)
[10:18:27.824]                 ...future.FUN(...future.X_jj, ...)
[10:18:27.824]             })
[10:18:27.824]         }
[10:18:27.824]     }, args = future.call.arguments)
[10:18:27.824] }
[10:18:27.824] Lazy evaluation: FALSE
[10:18:27.824] Asynchronous evaluation: TRUE
[10:18:27.824] Local evaluation: TRUE
[10:18:27.824] Environment: R_GlobalEnv
[10:18:27.824] Capture standard output: TRUE
[10:18:27.824] Capture condition classes: <none>
[10:18:27.824] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:27.824] Packages: <none>
[10:18:27.824] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:18:27.824] Resolved: TRUE
[10:18:27.824] Value: <not collected>
[10:18:27.824] Conditions captured: <none>
[10:18:27.824] Early signaling: FALSE
[10:18:27.824] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:27.824] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:27.833] Chunk #2 of 2 ... DONE
[10:18:27.833] Launching 2 futures (chunks) ... DONE
[10:18:27.833] Resolving 2 futures (chunks) ...
[10:18:27.833] resolve() on list ...
[10:18:27.833]  recursive: 0
[10:18:27.833]  length: 2
[10:18:27.834] 
[10:18:27.834] Future #1
[10:18:27.834] result() for MulticoreFuture ...
[10:18:27.835] result() for MulticoreFuture ...
[10:18:27.835] result() for MulticoreFuture ... done
[10:18:27.836] result() for MulticoreFuture ... done
[10:18:27.836] result() for MulticoreFuture ...
[10:18:27.836] result() for MulticoreFuture ... done
[10:18:27.836] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:18:27.836] - nx: 2
[10:18:27.836] - relay: TRUE
[10:18:27.837] - stdout: TRUE
[10:18:27.837] - signal: TRUE
[10:18:27.837] - resignal: FALSE
[10:18:27.837] - force: TRUE
[10:18:27.837] - relayed: [n=2] FALSE, FALSE
[10:18:27.837] - queued futures: [n=2] FALSE, FALSE
[10:18:27.837]  - until=1
[10:18:27.838]  - relaying element #1
[10:18:27.838] result() for MulticoreFuture ...
[10:18:27.838] result() for MulticoreFuture ... done
[10:18:27.838] result() for MulticoreFuture ...
[10:18:27.838] result() for MulticoreFuture ... done
[10:18:27.838] result() for MulticoreFuture ...
[10:18:27.838] result() for MulticoreFuture ... done
[10:18:27.839] result() for MulticoreFuture ...
[10:18:27.839] result() for MulticoreFuture ... done
[10:18:27.839] - relayed: [n=2] TRUE, FALSE
[10:18:27.839] - queued futures: [n=2] TRUE, FALSE
[10:18:27.839] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:18:27.839]  length: 1 (resolved future 1)
[10:18:27.840] Future #2
[10:18:27.840] result() for MulticoreFuture ...
[10:18:27.841] result() for MulticoreFuture ...
[10:18:27.841] result() for MulticoreFuture ... done
[10:18:27.841] result() for MulticoreFuture ... done
[10:18:27.841] result() for MulticoreFuture ...
[10:18:27.841] result() for MulticoreFuture ... done
[10:18:27.841] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:18:27.842] - nx: 2
[10:18:27.842] - relay: TRUE
[10:18:27.842] - stdout: TRUE
[10:18:27.842] - signal: TRUE
[10:18:27.842] - resignal: FALSE
[10:18:27.842] - force: TRUE
[10:18:27.842] - relayed: [n=2] TRUE, FALSE
[10:18:27.842] - queued futures: [n=2] TRUE, FALSE
[10:18:27.843]  - until=2
[10:18:27.843]  - relaying element #2
[10:18:27.843] result() for MulticoreFuture ...
[10:18:27.843] result() for MulticoreFuture ... done
[10:18:27.843] result() for MulticoreFuture ...
[10:18:27.843] result() for MulticoreFuture ... done
[10:18:27.843] result() for MulticoreFuture ...
[10:18:27.843] result() for MulticoreFuture ... done
[10:18:27.843] result() for MulticoreFuture ...
[10:18:27.844] result() for MulticoreFuture ... done
[10:18:27.844] - relayed: [n=2] TRUE, TRUE
[10:18:27.844] - queued futures: [n=2] TRUE, TRUE
[10:18:27.844] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:18:27.844]  length: 0 (resolved future 2)
[10:18:27.844] Relaying remaining futures
[10:18:27.844] signalConditionsASAP(NULL, pos=0) ...
[10:18:27.844] - nx: 2
[10:18:27.844] - relay: TRUE
[10:18:27.845] - stdout: TRUE
[10:18:27.845] - signal: TRUE
[10:18:27.845] - resignal: FALSE
[10:18:27.845] - force: TRUE
[10:18:27.845] - relayed: [n=2] TRUE, TRUE
[10:18:27.845] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:27.845] - relayed: [n=2] TRUE, TRUE
[10:18:27.845] - queued futures: [n=2] TRUE, TRUE
[10:18:27.845] signalConditionsASAP(NULL, pos=0) ... done
[10:18:27.845] resolve() on list ... DONE
[10:18:27.846] result() for MulticoreFuture ...
[10:18:27.846] result() for MulticoreFuture ... done
[10:18:27.846] result() for MulticoreFuture ...
[10:18:27.846] result() for MulticoreFuture ... done
[10:18:27.846] result() for MulticoreFuture ...
[10:18:27.846] result() for MulticoreFuture ... done
[10:18:27.847] result() for MulticoreFuture ...
[10:18:27.847] result() for MulticoreFuture ... done
[10:18:27.847]  - Number of value chunks collected: 2
[10:18:27.847] Resolving 2 futures (chunks) ... DONE
[10:18:27.847] Reducing values from 2 chunks ...
[10:18:27.847]  - Number of values collected after concatenation: 2
[10:18:27.847]  - Number of values expected: 2
[10:18:27.847] Reducing values from 2 chunks ... DONE
[10:18:27.848] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:18:27.848] plan(): Setting new future strategy stack:
[10:18:27.848] List of future strategies:
[10:18:27.848] 1. sequential:
[10:18:27.848]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:27.848]    - tweaked: FALSE
[10:18:27.848]    - call: plan(sequential)
[10:18:27.849] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:18:27.849] plan(): Setting new future strategy stack:
[10:18:27.849] List of future strategies:
[10:18:27.849] 1. multisession:
[10:18:27.849]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:27.849]    - tweaked: FALSE
[10:18:27.849]    - call: plan(strategy)
[10:18:27.850] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:18:27.850] multisession:
[10:18:27.850] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:18:27.850] - tweaked: FALSE
[10:18:27.850] - call: plan(strategy)
[10:18:27.854] getGlobalsAndPackages() ...
[10:18:27.855] Not searching for globals
[10:18:27.855] - globals: [0] <none>
[10:18:27.855] getGlobalsAndPackages() ... DONE
[10:18:28.348] Packages needed by the future expression (n = 0): <none>
[10:18:28.348] Packages needed by future strategies (n = 0): <none>
[10:18:28.348] {
[10:18:28.348]     {
[10:18:28.348]         {
[10:18:28.348]             ...future.startTime <- base::Sys.time()
[10:18:28.348]             {
[10:18:28.348]                 {
[10:18:28.348]                   {
[10:18:28.348]                     {
[10:18:28.348]                       base::local({
[10:18:28.348]                         has_future <- base::requireNamespace("future", 
[10:18:28.348]                           quietly = TRUE)
[10:18:28.348]                         if (has_future) {
[10:18:28.348]                           ns <- base::getNamespace("future")
[10:18:28.348]                           version <- ns[[".package"]][["version"]]
[10:18:28.348]                           if (is.null(version)) 
[10:18:28.348]                             version <- utils::packageVersion("future")
[10:18:28.348]                         }
[10:18:28.348]                         else {
[10:18:28.348]                           version <- NULL
[10:18:28.348]                         }
[10:18:28.348]                         if (!has_future || version < "1.8.0") {
[10:18:28.348]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:28.348]                             "", base::R.version$version.string), 
[10:18:28.348]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:28.348]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:28.348]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:28.348]                               "release", "version")], collapse = " "), 
[10:18:28.348]                             hostname = base::Sys.info()[["nodename"]])
[10:18:28.348]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:28.348]                             info)
[10:18:28.348]                           info <- base::paste(info, collapse = "; ")
[10:18:28.348]                           if (!has_future) {
[10:18:28.348]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:28.348]                               info)
[10:18:28.348]                           }
[10:18:28.348]                           else {
[10:18:28.348]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:28.348]                               info, version)
[10:18:28.348]                           }
[10:18:28.348]                           base::stop(msg)
[10:18:28.348]                         }
[10:18:28.348]                       })
[10:18:28.348]                     }
[10:18:28.348]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:28.348]                     base::options(mc.cores = 1L)
[10:18:28.348]                   }
[10:18:28.348]                   ...future.strategy.old <- future::plan("list")
[10:18:28.348]                   options(future.plan = NULL)
[10:18:28.348]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:28.348]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:28.348]                 }
[10:18:28.348]                 ...future.workdir <- getwd()
[10:18:28.348]             }
[10:18:28.348]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:28.348]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:28.348]         }
[10:18:28.348]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:28.348]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:18:28.348]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:28.348]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:28.348]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:28.348]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:28.348]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:28.348]             base::names(...future.oldOptions))
[10:18:28.348]     }
[10:18:28.348]     if (FALSE) {
[10:18:28.348]     }
[10:18:28.348]     else {
[10:18:28.348]         if (TRUE) {
[10:18:28.348]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:28.348]                 open = "w")
[10:18:28.348]         }
[10:18:28.348]         else {
[10:18:28.348]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:28.348]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:28.348]         }
[10:18:28.348]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:28.348]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:28.348]             base::sink(type = "output", split = FALSE)
[10:18:28.348]             base::close(...future.stdout)
[10:18:28.348]         }, add = TRUE)
[10:18:28.348]     }
[10:18:28.348]     ...future.frame <- base::sys.nframe()
[10:18:28.348]     ...future.conditions <- base::list()
[10:18:28.348]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:28.348]     if (FALSE) {
[10:18:28.348]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:28.348]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:28.348]     }
[10:18:28.348]     ...future.result <- base::tryCatch({
[10:18:28.348]         base::withCallingHandlers({
[10:18:28.348]             ...future.value <- base::withVisible(base::local({
[10:18:28.348]                 ...future.makeSendCondition <- base::local({
[10:18:28.348]                   sendCondition <- NULL
[10:18:28.348]                   function(frame = 1L) {
[10:18:28.348]                     if (is.function(sendCondition)) 
[10:18:28.348]                       return(sendCondition)
[10:18:28.348]                     ns <- getNamespace("parallel")
[10:18:28.348]                     if (exists("sendData", mode = "function", 
[10:18:28.348]                       envir = ns)) {
[10:18:28.348]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:28.348]                         envir = ns)
[10:18:28.348]                       envir <- sys.frame(frame)
[10:18:28.348]                       master <- NULL
[10:18:28.348]                       while (!identical(envir, .GlobalEnv) && 
[10:18:28.348]                         !identical(envir, emptyenv())) {
[10:18:28.348]                         if (exists("master", mode = "list", envir = envir, 
[10:18:28.348]                           inherits = FALSE)) {
[10:18:28.348]                           master <- get("master", mode = "list", 
[10:18:28.348]                             envir = envir, inherits = FALSE)
[10:18:28.348]                           if (inherits(master, c("SOCKnode", 
[10:18:28.348]                             "SOCK0node"))) {
[10:18:28.348]                             sendCondition <<- function(cond) {
[10:18:28.348]                               data <- list(type = "VALUE", value = cond, 
[10:18:28.348]                                 success = TRUE)
[10:18:28.348]                               parallel_sendData(master, data)
[10:18:28.348]                             }
[10:18:28.348]                             return(sendCondition)
[10:18:28.348]                           }
[10:18:28.348]                         }
[10:18:28.348]                         frame <- frame + 1L
[10:18:28.348]                         envir <- sys.frame(frame)
[10:18:28.348]                       }
[10:18:28.348]                     }
[10:18:28.348]                     sendCondition <<- function(cond) NULL
[10:18:28.348]                   }
[10:18:28.348]                 })
[10:18:28.348]                 withCallingHandlers({
[10:18:28.348]                   NA
[10:18:28.348]                 }, immediateCondition = function(cond) {
[10:18:28.348]                   sendCondition <- ...future.makeSendCondition()
[10:18:28.348]                   sendCondition(cond)
[10:18:28.348]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.348]                   {
[10:18:28.348]                     inherits <- base::inherits
[10:18:28.348]                     invokeRestart <- base::invokeRestart
[10:18:28.348]                     is.null <- base::is.null
[10:18:28.348]                     muffled <- FALSE
[10:18:28.348]                     if (inherits(cond, "message")) {
[10:18:28.348]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:28.348]                       if (muffled) 
[10:18:28.348]                         invokeRestart("muffleMessage")
[10:18:28.348]                     }
[10:18:28.348]                     else if (inherits(cond, "warning")) {
[10:18:28.348]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:28.348]                       if (muffled) 
[10:18:28.348]                         invokeRestart("muffleWarning")
[10:18:28.348]                     }
[10:18:28.348]                     else if (inherits(cond, "condition")) {
[10:18:28.348]                       if (!is.null(pattern)) {
[10:18:28.348]                         computeRestarts <- base::computeRestarts
[10:18:28.348]                         grepl <- base::grepl
[10:18:28.348]                         restarts <- computeRestarts(cond)
[10:18:28.348]                         for (restart in restarts) {
[10:18:28.348]                           name <- restart$name
[10:18:28.348]                           if (is.null(name)) 
[10:18:28.348]                             next
[10:18:28.348]                           if (!grepl(pattern, name)) 
[10:18:28.348]                             next
[10:18:28.348]                           invokeRestart(restart)
[10:18:28.348]                           muffled <- TRUE
[10:18:28.348]                           break
[10:18:28.348]                         }
[10:18:28.348]                       }
[10:18:28.348]                     }
[10:18:28.348]                     invisible(muffled)
[10:18:28.348]                   }
[10:18:28.348]                   muffleCondition(cond)
[10:18:28.348]                 })
[10:18:28.348]             }))
[10:18:28.348]             future::FutureResult(value = ...future.value$value, 
[10:18:28.348]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:28.348]                   ...future.rng), globalenv = if (FALSE) 
[10:18:28.348]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:28.348]                     ...future.globalenv.names))
[10:18:28.348]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:28.348]         }, condition = base::local({
[10:18:28.348]             c <- base::c
[10:18:28.348]             inherits <- base::inherits
[10:18:28.348]             invokeRestart <- base::invokeRestart
[10:18:28.348]             length <- base::length
[10:18:28.348]             list <- base::list
[10:18:28.348]             seq.int <- base::seq.int
[10:18:28.348]             signalCondition <- base::signalCondition
[10:18:28.348]             sys.calls <- base::sys.calls
[10:18:28.348]             `[[` <- base::`[[`
[10:18:28.348]             `+` <- base::`+`
[10:18:28.348]             `<<-` <- base::`<<-`
[10:18:28.348]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:28.348]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:28.348]                   3L)]
[10:18:28.348]             }
[10:18:28.348]             function(cond) {
[10:18:28.348]                 is_error <- inherits(cond, "error")
[10:18:28.348]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:28.348]                   NULL)
[10:18:28.348]                 if (is_error) {
[10:18:28.348]                   sessionInformation <- function() {
[10:18:28.348]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:28.348]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:28.348]                       search = base::search(), system = base::Sys.info())
[10:18:28.348]                   }
[10:18:28.348]                   ...future.conditions[[length(...future.conditions) + 
[10:18:28.348]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:28.348]                     cond$call), session = sessionInformation(), 
[10:18:28.348]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:28.348]                   signalCondition(cond)
[10:18:28.348]                 }
[10:18:28.348]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:28.348]                 "immediateCondition"))) {
[10:18:28.348]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:28.348]                   ...future.conditions[[length(...future.conditions) + 
[10:18:28.348]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:28.348]                   if (TRUE && !signal) {
[10:18:28.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.348]                     {
[10:18:28.348]                       inherits <- base::inherits
[10:18:28.348]                       invokeRestart <- base::invokeRestart
[10:18:28.348]                       is.null <- base::is.null
[10:18:28.348]                       muffled <- FALSE
[10:18:28.348]                       if (inherits(cond, "message")) {
[10:18:28.348]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:28.348]                         if (muffled) 
[10:18:28.348]                           invokeRestart("muffleMessage")
[10:18:28.348]                       }
[10:18:28.348]                       else if (inherits(cond, "warning")) {
[10:18:28.348]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:28.348]                         if (muffled) 
[10:18:28.348]                           invokeRestart("muffleWarning")
[10:18:28.348]                       }
[10:18:28.348]                       else if (inherits(cond, "condition")) {
[10:18:28.348]                         if (!is.null(pattern)) {
[10:18:28.348]                           computeRestarts <- base::computeRestarts
[10:18:28.348]                           grepl <- base::grepl
[10:18:28.348]                           restarts <- computeRestarts(cond)
[10:18:28.348]                           for (restart in restarts) {
[10:18:28.348]                             name <- restart$name
[10:18:28.348]                             if (is.null(name)) 
[10:18:28.348]                               next
[10:18:28.348]                             if (!grepl(pattern, name)) 
[10:18:28.348]                               next
[10:18:28.348]                             invokeRestart(restart)
[10:18:28.348]                             muffled <- TRUE
[10:18:28.348]                             break
[10:18:28.348]                           }
[10:18:28.348]                         }
[10:18:28.348]                       }
[10:18:28.348]                       invisible(muffled)
[10:18:28.348]                     }
[10:18:28.348]                     muffleCondition(cond, pattern = "^muffle")
[10:18:28.348]                   }
[10:18:28.348]                 }
[10:18:28.348]                 else {
[10:18:28.348]                   if (TRUE) {
[10:18:28.348]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.348]                     {
[10:18:28.348]                       inherits <- base::inherits
[10:18:28.348]                       invokeRestart <- base::invokeRestart
[10:18:28.348]                       is.null <- base::is.null
[10:18:28.348]                       muffled <- FALSE
[10:18:28.348]                       if (inherits(cond, "message")) {
[10:18:28.348]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:28.348]                         if (muffled) 
[10:18:28.348]                           invokeRestart("muffleMessage")
[10:18:28.348]                       }
[10:18:28.348]                       else if (inherits(cond, "warning")) {
[10:18:28.348]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:28.348]                         if (muffled) 
[10:18:28.348]                           invokeRestart("muffleWarning")
[10:18:28.348]                       }
[10:18:28.348]                       else if (inherits(cond, "condition")) {
[10:18:28.348]                         if (!is.null(pattern)) {
[10:18:28.348]                           computeRestarts <- base::computeRestarts
[10:18:28.348]                           grepl <- base::grepl
[10:18:28.348]                           restarts <- computeRestarts(cond)
[10:18:28.348]                           for (restart in restarts) {
[10:18:28.348]                             name <- restart$name
[10:18:28.348]                             if (is.null(name)) 
[10:18:28.348]                               next
[10:18:28.348]                             if (!grepl(pattern, name)) 
[10:18:28.348]                               next
[10:18:28.348]                             invokeRestart(restart)
[10:18:28.348]                             muffled <- TRUE
[10:18:28.348]                             break
[10:18:28.348]                           }
[10:18:28.348]                         }
[10:18:28.348]                       }
[10:18:28.348]                       invisible(muffled)
[10:18:28.348]                     }
[10:18:28.348]                     muffleCondition(cond, pattern = "^muffle")
[10:18:28.348]                   }
[10:18:28.348]                 }
[10:18:28.348]             }
[10:18:28.348]         }))
[10:18:28.348]     }, error = function(ex) {
[10:18:28.348]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:28.348]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:28.348]                 ...future.rng), started = ...future.startTime, 
[10:18:28.348]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:28.348]             version = "1.8"), class = "FutureResult")
[10:18:28.348]     }, finally = {
[10:18:28.348]         if (!identical(...future.workdir, getwd())) 
[10:18:28.348]             setwd(...future.workdir)
[10:18:28.348]         {
[10:18:28.348]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:28.348]                 ...future.oldOptions$nwarnings <- NULL
[10:18:28.348]             }
[10:18:28.348]             base::options(...future.oldOptions)
[10:18:28.348]             if (.Platform$OS.type == "windows") {
[10:18:28.348]                 old_names <- names(...future.oldEnvVars)
[10:18:28.348]                 envs <- base::Sys.getenv()
[10:18:28.348]                 names <- names(envs)
[10:18:28.348]                 common <- intersect(names, old_names)
[10:18:28.348]                 added <- setdiff(names, old_names)
[10:18:28.348]                 removed <- setdiff(old_names, names)
[10:18:28.348]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:28.348]                   envs[common]]
[10:18:28.348]                 NAMES <- toupper(changed)
[10:18:28.348]                 args <- list()
[10:18:28.348]                 for (kk in seq_along(NAMES)) {
[10:18:28.348]                   name <- changed[[kk]]
[10:18:28.348]                   NAME <- NAMES[[kk]]
[10:18:28.348]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.348]                     next
[10:18:28.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:28.348]                 }
[10:18:28.348]                 NAMES <- toupper(added)
[10:18:28.348]                 for (kk in seq_along(NAMES)) {
[10:18:28.348]                   name <- added[[kk]]
[10:18:28.348]                   NAME <- NAMES[[kk]]
[10:18:28.348]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.348]                     next
[10:18:28.348]                   args[[name]] <- ""
[10:18:28.348]                 }
[10:18:28.348]                 NAMES <- toupper(removed)
[10:18:28.348]                 for (kk in seq_along(NAMES)) {
[10:18:28.348]                   name <- removed[[kk]]
[10:18:28.348]                   NAME <- NAMES[[kk]]
[10:18:28.348]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.348]                     next
[10:18:28.348]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:28.348]                 }
[10:18:28.348]                 if (length(args) > 0) 
[10:18:28.348]                   base::do.call(base::Sys.setenv, args = args)
[10:18:28.348]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:28.348]             }
[10:18:28.348]             else {
[10:18:28.348]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:28.348]             }
[10:18:28.348]             {
[10:18:28.348]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:28.348]                   0L) {
[10:18:28.348]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:28.348]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:28.348]                   base::options(opts)
[10:18:28.348]                 }
[10:18:28.348]                 {
[10:18:28.348]                   {
[10:18:28.348]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:28.348]                     NULL
[10:18:28.348]                   }
[10:18:28.348]                   options(future.plan = NULL)
[10:18:28.348]                   if (is.na(NA_character_)) 
[10:18:28.348]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:28.348]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:28.348]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:28.348]                     .init = FALSE)
[10:18:28.348]                 }
[10:18:28.348]             }
[10:18:28.348]         }
[10:18:28.348]     })
[10:18:28.348]     if (TRUE) {
[10:18:28.348]         base::sink(type = "output", split = FALSE)
[10:18:28.348]         if (TRUE) {
[10:18:28.348]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:28.348]         }
[10:18:28.348]         else {
[10:18:28.348]             ...future.result["stdout"] <- base::list(NULL)
[10:18:28.348]         }
[10:18:28.348]         base::close(...future.stdout)
[10:18:28.348]         ...future.stdout <- NULL
[10:18:28.348]     }
[10:18:28.348]     ...future.result$conditions <- ...future.conditions
[10:18:28.348]     ...future.result$finished <- base::Sys.time()
[10:18:28.348]     ...future.result
[10:18:28.348] }
[10:18:28.403] MultisessionFuture started
[10:18:28.404] result() for ClusterFuture ...
[10:18:28.404] receiveMessageFromWorker() for ClusterFuture ...
[10:18:28.404] - Validating connection of MultisessionFuture
[10:18:28.436] - received message: FutureResult
[10:18:28.437] - Received FutureResult
[10:18:28.437] - Erased future from FutureRegistry
[10:18:28.437] result() for ClusterFuture ...
[10:18:28.437] - result already collected: FutureResult
[10:18:28.437] result() for ClusterFuture ... done
[10:18:28.437] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:28.437] result() for ClusterFuture ... done
[10:18:28.437] result() for ClusterFuture ...
[10:18:28.437] - result already collected: FutureResult
[10:18:28.438] result() for ClusterFuture ... done
[10:18:28.438] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:18:28.439] plan(): nbrOfWorkers() = 2
- From example(apply) ...
[10:18:28.440] getGlobalsAndPackagesXApply() ...
[10:18:28.440]  - future.globals: TRUE
[10:18:28.440] getGlobalsAndPackages() ...
[10:18:28.440] Searching for globals...
[10:18:28.478] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:18:28.478] Searching for globals ... DONE
[10:18:28.478] Resolving globals: FALSE
[10:18:28.481] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:18:28.481] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:18:28.481] - globals: [1] ‘FUN’
[10:18:28.481] 
[10:18:28.482] getGlobalsAndPackages() ... DONE
[10:18:28.482]  - globals found/used: [n=1] ‘FUN’
[10:18:28.482]  - needed namespaces: [n=0] 
[10:18:28.482] Finding globals ... DONE
[10:18:28.482]  - use_args: TRUE
[10:18:28.482]  - Getting '...' globals ...
[10:18:28.483] resolve() on list ...
[10:18:28.483]  recursive: 0
[10:18:28.483]  length: 1
[10:18:28.483]  elements: ‘...’
[10:18:28.483]  length: 0 (resolved future 1)
[10:18:28.483] resolve() on list ... DONE
[10:18:28.483]    - '...' content: [n=0] 
[10:18:28.483] List of 1
[10:18:28.483]  $ ...: list()
[10:18:28.483]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:28.483]  - attr(*, "where")=List of 1
[10:18:28.483]   ..$ ...:<environment: 0x556e039b8360> 
[10:18:28.483]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:28.483]  - attr(*, "resolved")= logi TRUE
[10:18:28.483]  - attr(*, "total_size")= num NA
[10:18:28.487]  - Getting '...' globals ... DONE
[10:18:28.487] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:28.487] List of 2
[10:18:28.487]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:28.487]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:28.487]  $ ...          : list()
[10:18:28.487]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:28.487]  - attr(*, "where")=List of 2
[10:18:28.487]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:28.487]   ..$ ...          :<environment: 0x556e039b8360> 
[10:18:28.487]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:28.487]  - attr(*, "resolved")= logi FALSE
[10:18:28.487]  - attr(*, "total_size")= num 65963
[10:18:28.490] Packages to be attached in all futures: [n=0] 
[10:18:28.491] getGlobalsAndPackagesXApply() ... DONE
[10:18:28.492] future_lapply() ...
[10:18:28.528] Number of chunks: 2
[10:18:28.528] getGlobalsAndPackagesXApply() ...
[10:18:28.528]  - future.globals: <name-value list> with names ‘list()’
[10:18:28.529]  - use_args: TRUE
[10:18:28.529] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:28.529] List of 2
[10:18:28.529]  $ ...          : list()
[10:18:28.529]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:28.529]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:28.529]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:28.529]  - attr(*, "where")=List of 2
[10:18:28.529]   ..$ ...          :<environment: 0x556e039b8360> 
[10:18:28.529]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:28.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:28.529]  - attr(*, "resolved")= logi FALSE
[10:18:28.529]  - attr(*, "total_size")= num NA
[10:18:28.533] Packages to be attached in all futures: [n=0] 
[10:18:28.533] getGlobalsAndPackagesXApply() ... DONE
[10:18:28.533] Number of futures (= number of chunks): 2
[10:18:28.533] Launching 2 futures (chunks) ...
[10:18:28.533] Chunk #1 of 2 ...
[10:18:28.533]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:28.533]  - seeds: <none>
[10:18:28.533]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.533] getGlobalsAndPackages() ...
[10:18:28.534] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.534] Resolving globals: FALSE
[10:18:28.534] Tweak future expression to call with '...' arguments ...
[10:18:28.534] {
[10:18:28.534]     do.call(function(...) {
[10:18:28.534]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.534]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:28.534]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.534]             on.exit(options(oopts), add = TRUE)
[10:18:28.534]         }
[10:18:28.534]         {
[10:18:28.534]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:28.534]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.534]                 ...future.FUN(...future.X_jj, ...)
[10:18:28.534]             })
[10:18:28.534]         }
[10:18:28.534]     }, args = future.call.arguments)
[10:18:28.534] }
[10:18:28.534] Tweak future expression to call with '...' arguments ... DONE
[10:18:28.535] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.535] 
[10:18:28.535] getGlobalsAndPackages() ... DONE
[10:18:28.535] run() for ‘Future’ ...
[10:18:28.535] - state: ‘created’
[10:18:28.535] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:28.549] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:28.549] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:28.550]   - Field: ‘node’
[10:18:28.550]   - Field: ‘label’
[10:18:28.550]   - Field: ‘local’
[10:18:28.550]   - Field: ‘owner’
[10:18:28.550]   - Field: ‘envir’
[10:18:28.550]   - Field: ‘workers’
[10:18:28.550]   - Field: ‘packages’
[10:18:28.550]   - Field: ‘gc’
[10:18:28.550]   - Field: ‘conditions’
[10:18:28.550]   - Field: ‘persistent’
[10:18:28.550]   - Field: ‘expr’
[10:18:28.551]   - Field: ‘uuid’
[10:18:28.551]   - Field: ‘seed’
[10:18:28.551]   - Field: ‘version’
[10:18:28.551]   - Field: ‘result’
[10:18:28.551]   - Field: ‘asynchronous’
[10:18:28.551]   - Field: ‘calls’
[10:18:28.551]   - Field: ‘globals’
[10:18:28.551]   - Field: ‘stdout’
[10:18:28.551]   - Field: ‘earlySignal’
[10:18:28.551]   - Field: ‘lazy’
[10:18:28.551]   - Field: ‘state’
[10:18:28.551] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:28.552] - Launch lazy future ...
[10:18:28.552] Packages needed by the future expression (n = 0): <none>
[10:18:28.552] Packages needed by future strategies (n = 0): <none>
[10:18:28.552] {
[10:18:28.552]     {
[10:18:28.552]         {
[10:18:28.552]             ...future.startTime <- base::Sys.time()
[10:18:28.552]             {
[10:18:28.552]                 {
[10:18:28.552]                   {
[10:18:28.552]                     {
[10:18:28.552]                       base::local({
[10:18:28.552]                         has_future <- base::requireNamespace("future", 
[10:18:28.552]                           quietly = TRUE)
[10:18:28.552]                         if (has_future) {
[10:18:28.552]                           ns <- base::getNamespace("future")
[10:18:28.552]                           version <- ns[[".package"]][["version"]]
[10:18:28.552]                           if (is.null(version)) 
[10:18:28.552]                             version <- utils::packageVersion("future")
[10:18:28.552]                         }
[10:18:28.552]                         else {
[10:18:28.552]                           version <- NULL
[10:18:28.552]                         }
[10:18:28.552]                         if (!has_future || version < "1.8.0") {
[10:18:28.552]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:28.552]                             "", base::R.version$version.string), 
[10:18:28.552]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:28.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:28.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:28.552]                               "release", "version")], collapse = " "), 
[10:18:28.552]                             hostname = base::Sys.info()[["nodename"]])
[10:18:28.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:28.552]                             info)
[10:18:28.552]                           info <- base::paste(info, collapse = "; ")
[10:18:28.552]                           if (!has_future) {
[10:18:28.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:28.552]                               info)
[10:18:28.552]                           }
[10:18:28.552]                           else {
[10:18:28.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:28.552]                               info, version)
[10:18:28.552]                           }
[10:18:28.552]                           base::stop(msg)
[10:18:28.552]                         }
[10:18:28.552]                       })
[10:18:28.552]                     }
[10:18:28.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:28.552]                     base::options(mc.cores = 1L)
[10:18:28.552]                   }
[10:18:28.552]                   ...future.strategy.old <- future::plan("list")
[10:18:28.552]                   options(future.plan = NULL)
[10:18:28.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:28.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:28.552]                 }
[10:18:28.552]                 ...future.workdir <- getwd()
[10:18:28.552]             }
[10:18:28.552]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:28.552]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:28.552]         }
[10:18:28.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:28.552]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:28.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:28.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:28.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:28.552]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:28.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:28.552]             base::names(...future.oldOptions))
[10:18:28.552]     }
[10:18:28.552]     if (FALSE) {
[10:18:28.552]     }
[10:18:28.552]     else {
[10:18:28.552]         if (TRUE) {
[10:18:28.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:28.552]                 open = "w")
[10:18:28.552]         }
[10:18:28.552]         else {
[10:18:28.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:28.552]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:28.552]         }
[10:18:28.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:28.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:28.552]             base::sink(type = "output", split = FALSE)
[10:18:28.552]             base::close(...future.stdout)
[10:18:28.552]         }, add = TRUE)
[10:18:28.552]     }
[10:18:28.552]     ...future.frame <- base::sys.nframe()
[10:18:28.552]     ...future.conditions <- base::list()
[10:18:28.552]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:28.552]     if (FALSE) {
[10:18:28.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:28.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:28.552]     }
[10:18:28.552]     ...future.result <- base::tryCatch({
[10:18:28.552]         base::withCallingHandlers({
[10:18:28.552]             ...future.value <- base::withVisible(base::local({
[10:18:28.552]                 ...future.makeSendCondition <- base::local({
[10:18:28.552]                   sendCondition <- NULL
[10:18:28.552]                   function(frame = 1L) {
[10:18:28.552]                     if (is.function(sendCondition)) 
[10:18:28.552]                       return(sendCondition)
[10:18:28.552]                     ns <- getNamespace("parallel")
[10:18:28.552]                     if (exists("sendData", mode = "function", 
[10:18:28.552]                       envir = ns)) {
[10:18:28.552]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:28.552]                         envir = ns)
[10:18:28.552]                       envir <- sys.frame(frame)
[10:18:28.552]                       master <- NULL
[10:18:28.552]                       while (!identical(envir, .GlobalEnv) && 
[10:18:28.552]                         !identical(envir, emptyenv())) {
[10:18:28.552]                         if (exists("master", mode = "list", envir = envir, 
[10:18:28.552]                           inherits = FALSE)) {
[10:18:28.552]                           master <- get("master", mode = "list", 
[10:18:28.552]                             envir = envir, inherits = FALSE)
[10:18:28.552]                           if (inherits(master, c("SOCKnode", 
[10:18:28.552]                             "SOCK0node"))) {
[10:18:28.552]                             sendCondition <<- function(cond) {
[10:18:28.552]                               data <- list(type = "VALUE", value = cond, 
[10:18:28.552]                                 success = TRUE)
[10:18:28.552]                               parallel_sendData(master, data)
[10:18:28.552]                             }
[10:18:28.552]                             return(sendCondition)
[10:18:28.552]                           }
[10:18:28.552]                         }
[10:18:28.552]                         frame <- frame + 1L
[10:18:28.552]                         envir <- sys.frame(frame)
[10:18:28.552]                       }
[10:18:28.552]                     }
[10:18:28.552]                     sendCondition <<- function(cond) NULL
[10:18:28.552]                   }
[10:18:28.552]                 })
[10:18:28.552]                 withCallingHandlers({
[10:18:28.552]                   {
[10:18:28.552]                     do.call(function(...) {
[10:18:28.552]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.552]                       if (!identical(...future.globals.maxSize.org, 
[10:18:28.552]                         ...future.globals.maxSize)) {
[10:18:28.552]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.552]                         on.exit(options(oopts), add = TRUE)
[10:18:28.552]                       }
[10:18:28.552]                       {
[10:18:28.552]                         lapply(seq_along(...future.elements_ii), 
[10:18:28.552]                           FUN = function(jj) {
[10:18:28.552]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.552]                             ...future.FUN(...future.X_jj, ...)
[10:18:28.552]                           })
[10:18:28.552]                       }
[10:18:28.552]                     }, args = future.call.arguments)
[10:18:28.552]                   }
[10:18:28.552]                 }, immediateCondition = function(cond) {
[10:18:28.552]                   sendCondition <- ...future.makeSendCondition()
[10:18:28.552]                   sendCondition(cond)
[10:18:28.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.552]                   {
[10:18:28.552]                     inherits <- base::inherits
[10:18:28.552]                     invokeRestart <- base::invokeRestart
[10:18:28.552]                     is.null <- base::is.null
[10:18:28.552]                     muffled <- FALSE
[10:18:28.552]                     if (inherits(cond, "message")) {
[10:18:28.552]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:28.552]                       if (muffled) 
[10:18:28.552]                         invokeRestart("muffleMessage")
[10:18:28.552]                     }
[10:18:28.552]                     else if (inherits(cond, "warning")) {
[10:18:28.552]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:28.552]                       if (muffled) 
[10:18:28.552]                         invokeRestart("muffleWarning")
[10:18:28.552]                     }
[10:18:28.552]                     else if (inherits(cond, "condition")) {
[10:18:28.552]                       if (!is.null(pattern)) {
[10:18:28.552]                         computeRestarts <- base::computeRestarts
[10:18:28.552]                         grepl <- base::grepl
[10:18:28.552]                         restarts <- computeRestarts(cond)
[10:18:28.552]                         for (restart in restarts) {
[10:18:28.552]                           name <- restart$name
[10:18:28.552]                           if (is.null(name)) 
[10:18:28.552]                             next
[10:18:28.552]                           if (!grepl(pattern, name)) 
[10:18:28.552]                             next
[10:18:28.552]                           invokeRestart(restart)
[10:18:28.552]                           muffled <- TRUE
[10:18:28.552]                           break
[10:18:28.552]                         }
[10:18:28.552]                       }
[10:18:28.552]                     }
[10:18:28.552]                     invisible(muffled)
[10:18:28.552]                   }
[10:18:28.552]                   muffleCondition(cond)
[10:18:28.552]                 })
[10:18:28.552]             }))
[10:18:28.552]             future::FutureResult(value = ...future.value$value, 
[10:18:28.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:28.552]                   ...future.rng), globalenv = if (FALSE) 
[10:18:28.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:28.552]                     ...future.globalenv.names))
[10:18:28.552]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:28.552]         }, condition = base::local({
[10:18:28.552]             c <- base::c
[10:18:28.552]             inherits <- base::inherits
[10:18:28.552]             invokeRestart <- base::invokeRestart
[10:18:28.552]             length <- base::length
[10:18:28.552]             list <- base::list
[10:18:28.552]             seq.int <- base::seq.int
[10:18:28.552]             signalCondition <- base::signalCondition
[10:18:28.552]             sys.calls <- base::sys.calls
[10:18:28.552]             `[[` <- base::`[[`
[10:18:28.552]             `+` <- base::`+`
[10:18:28.552]             `<<-` <- base::`<<-`
[10:18:28.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:28.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:28.552]                   3L)]
[10:18:28.552]             }
[10:18:28.552]             function(cond) {
[10:18:28.552]                 is_error <- inherits(cond, "error")
[10:18:28.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:28.552]                   NULL)
[10:18:28.552]                 if (is_error) {
[10:18:28.552]                   sessionInformation <- function() {
[10:18:28.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:28.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:28.552]                       search = base::search(), system = base::Sys.info())
[10:18:28.552]                   }
[10:18:28.552]                   ...future.conditions[[length(...future.conditions) + 
[10:18:28.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:28.552]                     cond$call), session = sessionInformation(), 
[10:18:28.552]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:28.552]                   signalCondition(cond)
[10:18:28.552]                 }
[10:18:28.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:28.552]                 "immediateCondition"))) {
[10:18:28.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:28.552]                   ...future.conditions[[length(...future.conditions) + 
[10:18:28.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:28.552]                   if (TRUE && !signal) {
[10:18:28.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.552]                     {
[10:18:28.552]                       inherits <- base::inherits
[10:18:28.552]                       invokeRestart <- base::invokeRestart
[10:18:28.552]                       is.null <- base::is.null
[10:18:28.552]                       muffled <- FALSE
[10:18:28.552]                       if (inherits(cond, "message")) {
[10:18:28.552]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:28.552]                         if (muffled) 
[10:18:28.552]                           invokeRestart("muffleMessage")
[10:18:28.552]                       }
[10:18:28.552]                       else if (inherits(cond, "warning")) {
[10:18:28.552]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:28.552]                         if (muffled) 
[10:18:28.552]                           invokeRestart("muffleWarning")
[10:18:28.552]                       }
[10:18:28.552]                       else if (inherits(cond, "condition")) {
[10:18:28.552]                         if (!is.null(pattern)) {
[10:18:28.552]                           computeRestarts <- base::computeRestarts
[10:18:28.552]                           grepl <- base::grepl
[10:18:28.552]                           restarts <- computeRestarts(cond)
[10:18:28.552]                           for (restart in restarts) {
[10:18:28.552]                             name <- restart$name
[10:18:28.552]                             if (is.null(name)) 
[10:18:28.552]                               next
[10:18:28.552]                             if (!grepl(pattern, name)) 
[10:18:28.552]                               next
[10:18:28.552]                             invokeRestart(restart)
[10:18:28.552]                             muffled <- TRUE
[10:18:28.552]                             break
[10:18:28.552]                           }
[10:18:28.552]                         }
[10:18:28.552]                       }
[10:18:28.552]                       invisible(muffled)
[10:18:28.552]                     }
[10:18:28.552]                     muffleCondition(cond, pattern = "^muffle")
[10:18:28.552]                   }
[10:18:28.552]                 }
[10:18:28.552]                 else {
[10:18:28.552]                   if (TRUE) {
[10:18:28.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.552]                     {
[10:18:28.552]                       inherits <- base::inherits
[10:18:28.552]                       invokeRestart <- base::invokeRestart
[10:18:28.552]                       is.null <- base::is.null
[10:18:28.552]                       muffled <- FALSE
[10:18:28.552]                       if (inherits(cond, "message")) {
[10:18:28.552]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:28.552]                         if (muffled) 
[10:18:28.552]                           invokeRestart("muffleMessage")
[10:18:28.552]                       }
[10:18:28.552]                       else if (inherits(cond, "warning")) {
[10:18:28.552]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:28.552]                         if (muffled) 
[10:18:28.552]                           invokeRestart("muffleWarning")
[10:18:28.552]                       }
[10:18:28.552]                       else if (inherits(cond, "condition")) {
[10:18:28.552]                         if (!is.null(pattern)) {
[10:18:28.552]                           computeRestarts <- base::computeRestarts
[10:18:28.552]                           grepl <- base::grepl
[10:18:28.552]                           restarts <- computeRestarts(cond)
[10:18:28.552]                           for (restart in restarts) {
[10:18:28.552]                             name <- restart$name
[10:18:28.552]                             if (is.null(name)) 
[10:18:28.552]                               next
[10:18:28.552]                             if (!grepl(pattern, name)) 
[10:18:28.552]                               next
[10:18:28.552]                             invokeRestart(restart)
[10:18:28.552]                             muffled <- TRUE
[10:18:28.552]                             break
[10:18:28.552]                           }
[10:18:28.552]                         }
[10:18:28.552]                       }
[10:18:28.552]                       invisible(muffled)
[10:18:28.552]                     }
[10:18:28.552]                     muffleCondition(cond, pattern = "^muffle")
[10:18:28.552]                   }
[10:18:28.552]                 }
[10:18:28.552]             }
[10:18:28.552]         }))
[10:18:28.552]     }, error = function(ex) {
[10:18:28.552]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:28.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:28.552]                 ...future.rng), started = ...future.startTime, 
[10:18:28.552]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:28.552]             version = "1.8"), class = "FutureResult")
[10:18:28.552]     }, finally = {
[10:18:28.552]         if (!identical(...future.workdir, getwd())) 
[10:18:28.552]             setwd(...future.workdir)
[10:18:28.552]         {
[10:18:28.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:28.552]                 ...future.oldOptions$nwarnings <- NULL
[10:18:28.552]             }
[10:18:28.552]             base::options(...future.oldOptions)
[10:18:28.552]             if (.Platform$OS.type == "windows") {
[10:18:28.552]                 old_names <- names(...future.oldEnvVars)
[10:18:28.552]                 envs <- base::Sys.getenv()
[10:18:28.552]                 names <- names(envs)
[10:18:28.552]                 common <- intersect(names, old_names)
[10:18:28.552]                 added <- setdiff(names, old_names)
[10:18:28.552]                 removed <- setdiff(old_names, names)
[10:18:28.552]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:28.552]                   envs[common]]
[10:18:28.552]                 NAMES <- toupper(changed)
[10:18:28.552]                 args <- list()
[10:18:28.552]                 for (kk in seq_along(NAMES)) {
[10:18:28.552]                   name <- changed[[kk]]
[10:18:28.552]                   NAME <- NAMES[[kk]]
[10:18:28.552]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.552]                     next
[10:18:28.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:28.552]                 }
[10:18:28.552]                 NAMES <- toupper(added)
[10:18:28.552]                 for (kk in seq_along(NAMES)) {
[10:18:28.552]                   name <- added[[kk]]
[10:18:28.552]                   NAME <- NAMES[[kk]]
[10:18:28.552]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.552]                     next
[10:18:28.552]                   args[[name]] <- ""
[10:18:28.552]                 }
[10:18:28.552]                 NAMES <- toupper(removed)
[10:18:28.552]                 for (kk in seq_along(NAMES)) {
[10:18:28.552]                   name <- removed[[kk]]
[10:18:28.552]                   NAME <- NAMES[[kk]]
[10:18:28.552]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.552]                     next
[10:18:28.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:28.552]                 }
[10:18:28.552]                 if (length(args) > 0) 
[10:18:28.552]                   base::do.call(base::Sys.setenv, args = args)
[10:18:28.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:28.552]             }
[10:18:28.552]             else {
[10:18:28.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:28.552]             }
[10:18:28.552]             {
[10:18:28.552]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:28.552]                   0L) {
[10:18:28.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:28.552]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:28.552]                   base::options(opts)
[10:18:28.552]                 }
[10:18:28.552]                 {
[10:18:28.552]                   {
[10:18:28.552]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:28.552]                     NULL
[10:18:28.552]                   }
[10:18:28.552]                   options(future.plan = NULL)
[10:18:28.552]                   if (is.na(NA_character_)) 
[10:18:28.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:28.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:28.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:28.552]                     .init = FALSE)
[10:18:28.552]                 }
[10:18:28.552]             }
[10:18:28.552]         }
[10:18:28.552]     })
[10:18:28.552]     if (TRUE) {
[10:18:28.552]         base::sink(type = "output", split = FALSE)
[10:18:28.552]         if (TRUE) {
[10:18:28.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:28.552]         }
[10:18:28.552]         else {
[10:18:28.552]             ...future.result["stdout"] <- base::list(NULL)
[10:18:28.552]         }
[10:18:28.552]         base::close(...future.stdout)
[10:18:28.552]         ...future.stdout <- NULL
[10:18:28.552]     }
[10:18:28.552]     ...future.result$conditions <- ...future.conditions
[10:18:28.552]     ...future.result$finished <- base::Sys.time()
[10:18:28.552]     ...future.result
[10:18:28.552] }
[10:18:28.556] Exporting 5 global objects (31.96 KiB) to cluster node #1 ...
[10:18:28.556] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:28.556] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:28.557] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ...
[10:18:28.598] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ... DONE
[10:18:28.598] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[10:18:28.598] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[10:18:28.599] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:28.599] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:28.599] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:28.600] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:28.600] Exporting 5 global objects (31.96 KiB) to cluster node #1 ... DONE
[10:18:28.600] MultisessionFuture started
[10:18:28.600] - Launch lazy future ... done
[10:18:28.600] run() for ‘MultisessionFuture’ ... done
[10:18:28.601] Created future:
[10:18:28.601] MultisessionFuture:
[10:18:28.601] Label: ‘future_apply-1’
[10:18:28.601] Expression:
[10:18:28.601] {
[10:18:28.601]     do.call(function(...) {
[10:18:28.601]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.601]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:28.601]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.601]             on.exit(options(oopts), add = TRUE)
[10:18:28.601]         }
[10:18:28.601]         {
[10:18:28.601]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:28.601]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.601]                 ...future.FUN(...future.X_jj, ...)
[10:18:28.601]             })
[10:18:28.601]         }
[10:18:28.601]     }, args = future.call.arguments)
[10:18:28.601] }
[10:18:28.601] Lazy evaluation: FALSE
[10:18:28.601] Asynchronous evaluation: TRUE
[10:18:28.601] Local evaluation: TRUE
[10:18:28.601] Environment: R_GlobalEnv
[10:18:28.601] Capture standard output: TRUE
[10:18:28.601] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:28.601] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:28.601] Packages: <none>
[10:18:28.601] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:28.601] Resolved: FALSE
[10:18:28.601] Value: <not collected>
[10:18:28.601] Conditions captured: <none>
[10:18:28.601] Early signaling: FALSE
[10:18:28.601] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:28.601] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:28.613] Chunk #1 of 2 ... DONE
[10:18:28.613] Chunk #2 of 2 ...
[10:18:28.613]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:28.613]  - seeds: <none>
[10:18:28.613]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.613] getGlobalsAndPackages() ...
[10:18:28.613] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.614] Resolving globals: FALSE
[10:18:28.614] Tweak future expression to call with '...' arguments ...
[10:18:28.614] {
[10:18:28.614]     do.call(function(...) {
[10:18:28.614]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.614]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:28.614]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.614]             on.exit(options(oopts), add = TRUE)
[10:18:28.614]         }
[10:18:28.614]         {
[10:18:28.614]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:28.614]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.614]                 ...future.FUN(...future.X_jj, ...)
[10:18:28.614]             })
[10:18:28.614]         }
[10:18:28.614]     }, args = future.call.arguments)
[10:18:28.614] }
[10:18:28.614] Tweak future expression to call with '...' arguments ... DONE
[10:18:28.614] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.615] 
[10:18:28.615] getGlobalsAndPackages() ... DONE
[10:18:28.615] run() for ‘Future’ ...
[10:18:28.615] - state: ‘created’
[10:18:28.615] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:28.629] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:28.629] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:28.630]   - Field: ‘node’
[10:18:28.630]   - Field: ‘label’
[10:18:28.630]   - Field: ‘local’
[10:18:28.630]   - Field: ‘owner’
[10:18:28.630]   - Field: ‘envir’
[10:18:28.630]   - Field: ‘workers’
[10:18:28.630]   - Field: ‘packages’
[10:18:28.630]   - Field: ‘gc’
[10:18:28.630]   - Field: ‘conditions’
[10:18:28.630]   - Field: ‘persistent’
[10:18:28.630]   - Field: ‘expr’
[10:18:28.631]   - Field: ‘uuid’
[10:18:28.631]   - Field: ‘seed’
[10:18:28.631]   - Field: ‘version’
[10:18:28.631]   - Field: ‘result’
[10:18:28.631]   - Field: ‘asynchronous’
[10:18:28.631]   - Field: ‘calls’
[10:18:28.631]   - Field: ‘globals’
[10:18:28.631]   - Field: ‘stdout’
[10:18:28.631]   - Field: ‘earlySignal’
[10:18:28.631]   - Field: ‘lazy’
[10:18:28.631]   - Field: ‘state’
[10:18:28.631] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:28.632] - Launch lazy future ...
[10:18:28.632] Packages needed by the future expression (n = 0): <none>
[10:18:28.632] Packages needed by future strategies (n = 0): <none>
[10:18:28.632] {
[10:18:28.632]     {
[10:18:28.632]         {
[10:18:28.632]             ...future.startTime <- base::Sys.time()
[10:18:28.632]             {
[10:18:28.632]                 {
[10:18:28.632]                   {
[10:18:28.632]                     {
[10:18:28.632]                       base::local({
[10:18:28.632]                         has_future <- base::requireNamespace("future", 
[10:18:28.632]                           quietly = TRUE)
[10:18:28.632]                         if (has_future) {
[10:18:28.632]                           ns <- base::getNamespace("future")
[10:18:28.632]                           version <- ns[[".package"]][["version"]]
[10:18:28.632]                           if (is.null(version)) 
[10:18:28.632]                             version <- utils::packageVersion("future")
[10:18:28.632]                         }
[10:18:28.632]                         else {
[10:18:28.632]                           version <- NULL
[10:18:28.632]                         }
[10:18:28.632]                         if (!has_future || version < "1.8.0") {
[10:18:28.632]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:28.632]                             "", base::R.version$version.string), 
[10:18:28.632]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:28.632]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:28.632]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:28.632]                               "release", "version")], collapse = " "), 
[10:18:28.632]                             hostname = base::Sys.info()[["nodename"]])
[10:18:28.632]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:28.632]                             info)
[10:18:28.632]                           info <- base::paste(info, collapse = "; ")
[10:18:28.632]                           if (!has_future) {
[10:18:28.632]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:28.632]                               info)
[10:18:28.632]                           }
[10:18:28.632]                           else {
[10:18:28.632]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:28.632]                               info, version)
[10:18:28.632]                           }
[10:18:28.632]                           base::stop(msg)
[10:18:28.632]                         }
[10:18:28.632]                       })
[10:18:28.632]                     }
[10:18:28.632]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:28.632]                     base::options(mc.cores = 1L)
[10:18:28.632]                   }
[10:18:28.632]                   ...future.strategy.old <- future::plan("list")
[10:18:28.632]                   options(future.plan = NULL)
[10:18:28.632]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:28.632]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:28.632]                 }
[10:18:28.632]                 ...future.workdir <- getwd()
[10:18:28.632]             }
[10:18:28.632]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:28.632]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:28.632]         }
[10:18:28.632]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:28.632]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:28.632]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:28.632]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:28.632]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:28.632]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:28.632]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:28.632]             base::names(...future.oldOptions))
[10:18:28.632]     }
[10:18:28.632]     if (FALSE) {
[10:18:28.632]     }
[10:18:28.632]     else {
[10:18:28.632]         if (TRUE) {
[10:18:28.632]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:28.632]                 open = "w")
[10:18:28.632]         }
[10:18:28.632]         else {
[10:18:28.632]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:28.632]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:28.632]         }
[10:18:28.632]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:28.632]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:28.632]             base::sink(type = "output", split = FALSE)
[10:18:28.632]             base::close(...future.stdout)
[10:18:28.632]         }, add = TRUE)
[10:18:28.632]     }
[10:18:28.632]     ...future.frame <- base::sys.nframe()
[10:18:28.632]     ...future.conditions <- base::list()
[10:18:28.632]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:28.632]     if (FALSE) {
[10:18:28.632]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:28.632]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:28.632]     }
[10:18:28.632]     ...future.result <- base::tryCatch({
[10:18:28.632]         base::withCallingHandlers({
[10:18:28.632]             ...future.value <- base::withVisible(base::local({
[10:18:28.632]                 ...future.makeSendCondition <- base::local({
[10:18:28.632]                   sendCondition <- NULL
[10:18:28.632]                   function(frame = 1L) {
[10:18:28.632]                     if (is.function(sendCondition)) 
[10:18:28.632]                       return(sendCondition)
[10:18:28.632]                     ns <- getNamespace("parallel")
[10:18:28.632]                     if (exists("sendData", mode = "function", 
[10:18:28.632]                       envir = ns)) {
[10:18:28.632]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:28.632]                         envir = ns)
[10:18:28.632]                       envir <- sys.frame(frame)
[10:18:28.632]                       master <- NULL
[10:18:28.632]                       while (!identical(envir, .GlobalEnv) && 
[10:18:28.632]                         !identical(envir, emptyenv())) {
[10:18:28.632]                         if (exists("master", mode = "list", envir = envir, 
[10:18:28.632]                           inherits = FALSE)) {
[10:18:28.632]                           master <- get("master", mode = "list", 
[10:18:28.632]                             envir = envir, inherits = FALSE)
[10:18:28.632]                           if (inherits(master, c("SOCKnode", 
[10:18:28.632]                             "SOCK0node"))) {
[10:18:28.632]                             sendCondition <<- function(cond) {
[10:18:28.632]                               data <- list(type = "VALUE", value = cond, 
[10:18:28.632]                                 success = TRUE)
[10:18:28.632]                               parallel_sendData(master, data)
[10:18:28.632]                             }
[10:18:28.632]                             return(sendCondition)
[10:18:28.632]                           }
[10:18:28.632]                         }
[10:18:28.632]                         frame <- frame + 1L
[10:18:28.632]                         envir <- sys.frame(frame)
[10:18:28.632]                       }
[10:18:28.632]                     }
[10:18:28.632]                     sendCondition <<- function(cond) NULL
[10:18:28.632]                   }
[10:18:28.632]                 })
[10:18:28.632]                 withCallingHandlers({
[10:18:28.632]                   {
[10:18:28.632]                     do.call(function(...) {
[10:18:28.632]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.632]                       if (!identical(...future.globals.maxSize.org, 
[10:18:28.632]                         ...future.globals.maxSize)) {
[10:18:28.632]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.632]                         on.exit(options(oopts), add = TRUE)
[10:18:28.632]                       }
[10:18:28.632]                       {
[10:18:28.632]                         lapply(seq_along(...future.elements_ii), 
[10:18:28.632]                           FUN = function(jj) {
[10:18:28.632]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.632]                             ...future.FUN(...future.X_jj, ...)
[10:18:28.632]                           })
[10:18:28.632]                       }
[10:18:28.632]                     }, args = future.call.arguments)
[10:18:28.632]                   }
[10:18:28.632]                 }, immediateCondition = function(cond) {
[10:18:28.632]                   sendCondition <- ...future.makeSendCondition()
[10:18:28.632]                   sendCondition(cond)
[10:18:28.632]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.632]                   {
[10:18:28.632]                     inherits <- base::inherits
[10:18:28.632]                     invokeRestart <- base::invokeRestart
[10:18:28.632]                     is.null <- base::is.null
[10:18:28.632]                     muffled <- FALSE
[10:18:28.632]                     if (inherits(cond, "message")) {
[10:18:28.632]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:28.632]                       if (muffled) 
[10:18:28.632]                         invokeRestart("muffleMessage")
[10:18:28.632]                     }
[10:18:28.632]                     else if (inherits(cond, "warning")) {
[10:18:28.632]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:28.632]                       if (muffled) 
[10:18:28.632]                         invokeRestart("muffleWarning")
[10:18:28.632]                     }
[10:18:28.632]                     else if (inherits(cond, "condition")) {
[10:18:28.632]                       if (!is.null(pattern)) {
[10:18:28.632]                         computeRestarts <- base::computeRestarts
[10:18:28.632]                         grepl <- base::grepl
[10:18:28.632]                         restarts <- computeRestarts(cond)
[10:18:28.632]                         for (restart in restarts) {
[10:18:28.632]                           name <- restart$name
[10:18:28.632]                           if (is.null(name)) 
[10:18:28.632]                             next
[10:18:28.632]                           if (!grepl(pattern, name)) 
[10:18:28.632]                             next
[10:18:28.632]                           invokeRestart(restart)
[10:18:28.632]                           muffled <- TRUE
[10:18:28.632]                           break
[10:18:28.632]                         }
[10:18:28.632]                       }
[10:18:28.632]                     }
[10:18:28.632]                     invisible(muffled)
[10:18:28.632]                   }
[10:18:28.632]                   muffleCondition(cond)
[10:18:28.632]                 })
[10:18:28.632]             }))
[10:18:28.632]             future::FutureResult(value = ...future.value$value, 
[10:18:28.632]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:28.632]                   ...future.rng), globalenv = if (FALSE) 
[10:18:28.632]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:28.632]                     ...future.globalenv.names))
[10:18:28.632]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:28.632]         }, condition = base::local({
[10:18:28.632]             c <- base::c
[10:18:28.632]             inherits <- base::inherits
[10:18:28.632]             invokeRestart <- base::invokeRestart
[10:18:28.632]             length <- base::length
[10:18:28.632]             list <- base::list
[10:18:28.632]             seq.int <- base::seq.int
[10:18:28.632]             signalCondition <- base::signalCondition
[10:18:28.632]             sys.calls <- base::sys.calls
[10:18:28.632]             `[[` <- base::`[[`
[10:18:28.632]             `+` <- base::`+`
[10:18:28.632]             `<<-` <- base::`<<-`
[10:18:28.632]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:28.632]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:28.632]                   3L)]
[10:18:28.632]             }
[10:18:28.632]             function(cond) {
[10:18:28.632]                 is_error <- inherits(cond, "error")
[10:18:28.632]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:28.632]                   NULL)
[10:18:28.632]                 if (is_error) {
[10:18:28.632]                   sessionInformation <- function() {
[10:18:28.632]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:28.632]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:28.632]                       search = base::search(), system = base::Sys.info())
[10:18:28.632]                   }
[10:18:28.632]                   ...future.conditions[[length(...future.conditions) + 
[10:18:28.632]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:28.632]                     cond$call), session = sessionInformation(), 
[10:18:28.632]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:28.632]                   signalCondition(cond)
[10:18:28.632]                 }
[10:18:28.632]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:28.632]                 "immediateCondition"))) {
[10:18:28.632]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:28.632]                   ...future.conditions[[length(...future.conditions) + 
[10:18:28.632]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:28.632]                   if (TRUE && !signal) {
[10:18:28.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.632]                     {
[10:18:28.632]                       inherits <- base::inherits
[10:18:28.632]                       invokeRestart <- base::invokeRestart
[10:18:28.632]                       is.null <- base::is.null
[10:18:28.632]                       muffled <- FALSE
[10:18:28.632]                       if (inherits(cond, "message")) {
[10:18:28.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:28.632]                         if (muffled) 
[10:18:28.632]                           invokeRestart("muffleMessage")
[10:18:28.632]                       }
[10:18:28.632]                       else if (inherits(cond, "warning")) {
[10:18:28.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:28.632]                         if (muffled) 
[10:18:28.632]                           invokeRestart("muffleWarning")
[10:18:28.632]                       }
[10:18:28.632]                       else if (inherits(cond, "condition")) {
[10:18:28.632]                         if (!is.null(pattern)) {
[10:18:28.632]                           computeRestarts <- base::computeRestarts
[10:18:28.632]                           grepl <- base::grepl
[10:18:28.632]                           restarts <- computeRestarts(cond)
[10:18:28.632]                           for (restart in restarts) {
[10:18:28.632]                             name <- restart$name
[10:18:28.632]                             if (is.null(name)) 
[10:18:28.632]                               next
[10:18:28.632]                             if (!grepl(pattern, name)) 
[10:18:28.632]                               next
[10:18:28.632]                             invokeRestart(restart)
[10:18:28.632]                             muffled <- TRUE
[10:18:28.632]                             break
[10:18:28.632]                           }
[10:18:28.632]                         }
[10:18:28.632]                       }
[10:18:28.632]                       invisible(muffled)
[10:18:28.632]                     }
[10:18:28.632]                     muffleCondition(cond, pattern = "^muffle")
[10:18:28.632]                   }
[10:18:28.632]                 }
[10:18:28.632]                 else {
[10:18:28.632]                   if (TRUE) {
[10:18:28.632]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.632]                     {
[10:18:28.632]                       inherits <- base::inherits
[10:18:28.632]                       invokeRestart <- base::invokeRestart
[10:18:28.632]                       is.null <- base::is.null
[10:18:28.632]                       muffled <- FALSE
[10:18:28.632]                       if (inherits(cond, "message")) {
[10:18:28.632]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:28.632]                         if (muffled) 
[10:18:28.632]                           invokeRestart("muffleMessage")
[10:18:28.632]                       }
[10:18:28.632]                       else if (inherits(cond, "warning")) {
[10:18:28.632]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:28.632]                         if (muffled) 
[10:18:28.632]                           invokeRestart("muffleWarning")
[10:18:28.632]                       }
[10:18:28.632]                       else if (inherits(cond, "condition")) {
[10:18:28.632]                         if (!is.null(pattern)) {
[10:18:28.632]                           computeRestarts <- base::computeRestarts
[10:18:28.632]                           grepl <- base::grepl
[10:18:28.632]                           restarts <- computeRestarts(cond)
[10:18:28.632]                           for (restart in restarts) {
[10:18:28.632]                             name <- restart$name
[10:18:28.632]                             if (is.null(name)) 
[10:18:28.632]                               next
[10:18:28.632]                             if (!grepl(pattern, name)) 
[10:18:28.632]                               next
[10:18:28.632]                             invokeRestart(restart)
[10:18:28.632]                             muffled <- TRUE
[10:18:28.632]                             break
[10:18:28.632]                           }
[10:18:28.632]                         }
[10:18:28.632]                       }
[10:18:28.632]                       invisible(muffled)
[10:18:28.632]                     }
[10:18:28.632]                     muffleCondition(cond, pattern = "^muffle")
[10:18:28.632]                   }
[10:18:28.632]                 }
[10:18:28.632]             }
[10:18:28.632]         }))
[10:18:28.632]     }, error = function(ex) {
[10:18:28.632]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:28.632]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:28.632]                 ...future.rng), started = ...future.startTime, 
[10:18:28.632]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:28.632]             version = "1.8"), class = "FutureResult")
[10:18:28.632]     }, finally = {
[10:18:28.632]         if (!identical(...future.workdir, getwd())) 
[10:18:28.632]             setwd(...future.workdir)
[10:18:28.632]         {
[10:18:28.632]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:28.632]                 ...future.oldOptions$nwarnings <- NULL
[10:18:28.632]             }
[10:18:28.632]             base::options(...future.oldOptions)
[10:18:28.632]             if (.Platform$OS.type == "windows") {
[10:18:28.632]                 old_names <- names(...future.oldEnvVars)
[10:18:28.632]                 envs <- base::Sys.getenv()
[10:18:28.632]                 names <- names(envs)
[10:18:28.632]                 common <- intersect(names, old_names)
[10:18:28.632]                 added <- setdiff(names, old_names)
[10:18:28.632]                 removed <- setdiff(old_names, names)
[10:18:28.632]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:28.632]                   envs[common]]
[10:18:28.632]                 NAMES <- toupper(changed)
[10:18:28.632]                 args <- list()
[10:18:28.632]                 for (kk in seq_along(NAMES)) {
[10:18:28.632]                   name <- changed[[kk]]
[10:18:28.632]                   NAME <- NAMES[[kk]]
[10:18:28.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.632]                     next
[10:18:28.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:28.632]                 }
[10:18:28.632]                 NAMES <- toupper(added)
[10:18:28.632]                 for (kk in seq_along(NAMES)) {
[10:18:28.632]                   name <- added[[kk]]
[10:18:28.632]                   NAME <- NAMES[[kk]]
[10:18:28.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.632]                     next
[10:18:28.632]                   args[[name]] <- ""
[10:18:28.632]                 }
[10:18:28.632]                 NAMES <- toupper(removed)
[10:18:28.632]                 for (kk in seq_along(NAMES)) {
[10:18:28.632]                   name <- removed[[kk]]
[10:18:28.632]                   NAME <- NAMES[[kk]]
[10:18:28.632]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.632]                     next
[10:18:28.632]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:28.632]                 }
[10:18:28.632]                 if (length(args) > 0) 
[10:18:28.632]                   base::do.call(base::Sys.setenv, args = args)
[10:18:28.632]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:28.632]             }
[10:18:28.632]             else {
[10:18:28.632]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:28.632]             }
[10:18:28.632]             {
[10:18:28.632]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:28.632]                   0L) {
[10:18:28.632]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:28.632]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:28.632]                   base::options(opts)
[10:18:28.632]                 }
[10:18:28.632]                 {
[10:18:28.632]                   {
[10:18:28.632]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:28.632]                     NULL
[10:18:28.632]                   }
[10:18:28.632]                   options(future.plan = NULL)
[10:18:28.632]                   if (is.na(NA_character_)) 
[10:18:28.632]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:28.632]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:28.632]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:28.632]                     .init = FALSE)
[10:18:28.632]                 }
[10:18:28.632]             }
[10:18:28.632]         }
[10:18:28.632]     })
[10:18:28.632]     if (TRUE) {
[10:18:28.632]         base::sink(type = "output", split = FALSE)
[10:18:28.632]         if (TRUE) {
[10:18:28.632]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:28.632]         }
[10:18:28.632]         else {
[10:18:28.632]             ...future.result["stdout"] <- base::list(NULL)
[10:18:28.632]         }
[10:18:28.632]         base::close(...future.stdout)
[10:18:28.632]         ...future.stdout <- NULL
[10:18:28.632]     }
[10:18:28.632]     ...future.result$conditions <- ...future.conditions
[10:18:28.632]     ...future.result$finished <- base::Sys.time()
[10:18:28.632]     ...future.result
[10:18:28.632] }
[10:18:28.685] Exporting 5 global objects (31.96 KiB) to cluster node #2 ...
[10:18:28.685] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:28.686] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:28.686] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ...
[10:18:28.728] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ... DONE
[10:18:28.728] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[10:18:28.728] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[10:18:28.728] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:28.729] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:28.729] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:28.729] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:28.729] Exporting 5 global objects (31.96 KiB) to cluster node #2 ... DONE
[10:18:28.730] MultisessionFuture started
[10:18:28.730] - Launch lazy future ... done
[10:18:28.730] run() for ‘MultisessionFuture’ ... done
[10:18:28.730] Created future:
[10:18:28.730] MultisessionFuture:
[10:18:28.730] Label: ‘future_apply-2’
[10:18:28.730] Expression:
[10:18:28.730] {
[10:18:28.730]     do.call(function(...) {
[10:18:28.730]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.730]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:28.730]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.730]             on.exit(options(oopts), add = TRUE)
[10:18:28.730]         }
[10:18:28.730]         {
[10:18:28.730]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:28.730]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.730]                 ...future.FUN(...future.X_jj, ...)
[10:18:28.730]             })
[10:18:28.730]         }
[10:18:28.730]     }, args = future.call.arguments)
[10:18:28.730] }
[10:18:28.730] Lazy evaluation: FALSE
[10:18:28.730] Asynchronous evaluation: TRUE
[10:18:28.730] Local evaluation: TRUE
[10:18:28.730] Environment: R_GlobalEnv
[10:18:28.730] Capture standard output: TRUE
[10:18:28.730] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:28.730] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:28.730] Packages: <none>
[10:18:28.730] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:28.730] Resolved: FALSE
[10:18:28.730] Value: <not collected>
[10:18:28.730] Conditions captured: <none>
[10:18:28.730] Early signaling: FALSE
[10:18:28.730] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:28.730] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:28.742] Chunk #2 of 2 ... DONE
[10:18:28.742] Launching 2 futures (chunks) ... DONE
[10:18:28.742] Resolving 2 futures (chunks) ...
[10:18:28.742] resolve() on list ...
[10:18:28.742]  recursive: 0
[10:18:28.742]  length: 2
[10:18:28.743] 
[10:18:28.743] receiveMessageFromWorker() for ClusterFuture ...
[10:18:28.743] - Validating connection of MultisessionFuture
[10:18:28.743] - received message: FutureResult
[10:18:28.743] - Received FutureResult
[10:18:28.744] - Erased future from FutureRegistry
[10:18:28.744] result() for ClusterFuture ...
[10:18:28.744] - result already collected: FutureResult
[10:18:28.744] result() for ClusterFuture ... done
[10:18:28.744] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:28.744] Future #1
[10:18:28.744] result() for ClusterFuture ...
[10:18:28.744] - result already collected: FutureResult
[10:18:28.744] result() for ClusterFuture ... done
[10:18:28.744] result() for ClusterFuture ...
[10:18:28.744] - result already collected: FutureResult
[10:18:28.744] result() for ClusterFuture ... done
[10:18:28.745] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:28.745] - nx: 2
[10:18:28.745] - relay: TRUE
[10:18:28.745] - stdout: TRUE
[10:18:28.745] - signal: TRUE
[10:18:28.745] - resignal: FALSE
[10:18:28.745] - force: TRUE
[10:18:28.745] - relayed: [n=2] FALSE, FALSE
[10:18:28.745] - queued futures: [n=2] FALSE, FALSE
[10:18:28.745]  - until=1
[10:18:28.745]  - relaying element #1
[10:18:28.745] result() for ClusterFuture ...
[10:18:28.746] - result already collected: FutureResult
[10:18:28.746] result() for ClusterFuture ... done
[10:18:28.746] result() for ClusterFuture ...
[10:18:28.746] - result already collected: FutureResult
[10:18:28.746] result() for ClusterFuture ... done
[10:18:28.746] result() for ClusterFuture ...
[10:18:28.746] - result already collected: FutureResult
[10:18:28.746] result() for ClusterFuture ... done
[10:18:28.746] result() for ClusterFuture ...
[10:18:28.746] - result already collected: FutureResult
[10:18:28.746] result() for ClusterFuture ... done
[10:18:28.746] - relayed: [n=2] TRUE, FALSE
[10:18:28.747] - queued futures: [n=2] TRUE, FALSE
[10:18:28.747] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:28.747]  length: 1 (resolved future 1)
[10:18:28.809] receiveMessageFromWorker() for ClusterFuture ...
[10:18:28.810] - Validating connection of MultisessionFuture
[10:18:28.810] - received message: FutureResult
[10:18:28.810] - Received FutureResult
[10:18:28.810] - Erased future from FutureRegistry
[10:18:28.810] result() for ClusterFuture ...
[10:18:28.810] - result already collected: FutureResult
[10:18:28.810] result() for ClusterFuture ... done
[10:18:28.810] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:28.811] Future #2
[10:18:28.811] result() for ClusterFuture ...
[10:18:28.811] - result already collected: FutureResult
[10:18:28.811] result() for ClusterFuture ... done
[10:18:28.811] result() for ClusterFuture ...
[10:18:28.811] - result already collected: FutureResult
[10:18:28.811] result() for ClusterFuture ... done
[10:18:28.811] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:28.811] - nx: 2
[10:18:28.811] - relay: TRUE
[10:18:28.811] - stdout: TRUE
[10:18:28.812] - signal: TRUE
[10:18:28.812] - resignal: FALSE
[10:18:28.812] - force: TRUE
[10:18:28.812] - relayed: [n=2] TRUE, FALSE
[10:18:28.812] - queued futures: [n=2] TRUE, FALSE
[10:18:28.812]  - until=2
[10:18:28.812]  - relaying element #2
[10:18:28.812] result() for ClusterFuture ...
[10:18:28.812] - result already collected: FutureResult
[10:18:28.812] result() for ClusterFuture ... done
[10:18:28.812] result() for ClusterFuture ...
[10:18:28.812] - result already collected: FutureResult
[10:18:28.813] result() for ClusterFuture ... done
[10:18:28.813] result() for ClusterFuture ...
[10:18:28.813] - result already collected: FutureResult
[10:18:28.813] result() for ClusterFuture ... done
[10:18:28.813] result() for ClusterFuture ...
[10:18:28.813] - result already collected: FutureResult
[10:18:28.813] result() for ClusterFuture ... done
[10:18:28.813] - relayed: [n=2] TRUE, TRUE
[10:18:28.813] - queued futures: [n=2] TRUE, TRUE
[10:18:28.813] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:28.813]  length: 0 (resolved future 2)
[10:18:28.814] Relaying remaining futures
[10:18:28.814] signalConditionsASAP(NULL, pos=0) ...
[10:18:28.814] - nx: 2
[10:18:28.814] - relay: TRUE
[10:18:28.814] - stdout: TRUE
[10:18:28.814] - signal: TRUE
[10:18:28.814] - resignal: FALSE
[10:18:28.814] - force: TRUE
[10:18:28.814] - relayed: [n=2] TRUE, TRUE
[10:18:28.814] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:28.814] - relayed: [n=2] TRUE, TRUE
[10:18:28.815] - queued futures: [n=2] TRUE, TRUE
[10:18:28.815] signalConditionsASAP(NULL, pos=0) ... done
[10:18:28.815] resolve() on list ... DONE
[10:18:28.815] result() for ClusterFuture ...
[10:18:28.815] - result already collected: FutureResult
[10:18:28.815] result() for ClusterFuture ... done
[10:18:28.815] result() for ClusterFuture ...
[10:18:28.815] - result already collected: FutureResult
[10:18:28.815] result() for ClusterFuture ... done
[10:18:28.815] result() for ClusterFuture ...
[10:18:28.815] - result already collected: FutureResult
[10:18:28.815] result() for ClusterFuture ... done
[10:18:28.816] result() for ClusterFuture ...
[10:18:28.816] - result already collected: FutureResult
[10:18:28.816] result() for ClusterFuture ... done
[10:18:28.816]  - Number of value chunks collected: 2
[10:18:28.816] Resolving 2 futures (chunks) ... DONE
[10:18:28.816] Reducing values from 2 chunks ...
[10:18:28.816]  - Number of values collected after concatenation: 2
[10:18:28.816]  - Number of values expected: 2
[10:18:28.816] Reducing values from 2 chunks ... DONE
[10:18:28.816] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:18:28.817] getGlobalsAndPackagesXApply() ...
[10:18:28.817]  - future.globals: TRUE
[10:18:28.817] getGlobalsAndPackages() ...
[10:18:28.817] Searching for globals...
[10:18:28.852] - globals found: [59] ‘FUN’, ‘if’, ‘==’, ‘c’, ‘list.names’, ‘{’, ‘<-’, ‘[’, ‘as.list’, ‘substitute’, ‘-’, ‘&&’, ‘length’, ‘is.list’, ‘!’, ‘is.null’, ‘names’, ‘return’, ‘seq_along’, ‘vapply’, ‘switch’, ‘+’, ‘is.symbol’, ‘as.character’, ‘deparse’, ‘[<-’, ‘missing’, ‘match’, ‘match.arg’, ‘!=’, ‘warning’, ‘list’, ‘[[’, ‘paste’, ‘stop’, ‘integer’, ‘for’, ‘is.factor’, ‘anyNA’, ‘options’, ‘on.exit’, ‘factor’, ‘(’, ‘||’, ‘levels’, ‘as.integer’, ‘which’, ‘is.na’, ‘is.na<-’, ‘>’, ‘prod’, ‘$’, ‘.Machine’, ‘*’, ‘names<-’, ‘array’, ‘tabulate’, ‘class’, ‘class<-’
[10:18:28.852] Searching for globals ... DONE
[10:18:28.852] Resolving globals: FALSE
[10:18:28.854] The total size of the 1 globals is 31.30 KiB (32048 bytes)
[10:18:28.854] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 31.30 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (31.30 KiB of class ‘function’)
[10:18:28.855] - globals: [1] ‘FUN’
[10:18:28.855] 
[10:18:28.855] getGlobalsAndPackages() ... DONE
[10:18:28.855]  - globals found/used: [n=1] ‘FUN’
[10:18:28.855]  - needed namespaces: [n=0] 
[10:18:28.855] Finding globals ... DONE
[10:18:28.855]  - use_args: TRUE
[10:18:28.855]  - Getting '...' globals ...
[10:18:28.856] resolve() on list ...
[10:18:28.856]  recursive: 0
[10:18:28.856]  length: 1
[10:18:28.856]  elements: ‘...’
[10:18:28.856]  length: 0 (resolved future 1)
[10:18:28.856] resolve() on list ... DONE
[10:18:28.856]    - '...' content: [n=0] 
[10:18:28.856] List of 1
[10:18:28.856]  $ ...: list()
[10:18:28.856]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:28.856]  - attr(*, "where")=List of 1
[10:18:28.856]   ..$ ...:<environment: 0x556e05d23278> 
[10:18:28.856]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:28.856]  - attr(*, "resolved")= logi TRUE
[10:18:28.856]  - attr(*, "total_size")= num NA
[10:18:28.859]  - Getting '...' globals ... DONE
[10:18:28.859] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:28.859] List of 2
[10:18:28.859]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:28.859]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:28.859]  $ ...          : list()
[10:18:28.859]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:28.859]  - attr(*, "where")=List of 2
[10:18:28.859]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:28.859]   ..$ ...          :<environment: 0x556e05d23278> 
[10:18:28.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:28.859]  - attr(*, "resolved")= logi FALSE
[10:18:28.859]  - attr(*, "total_size")= num 65967
[10:18:28.862] Packages to be attached in all futures: [n=0] 
[10:18:28.862] getGlobalsAndPackagesXApply() ... DONE
[10:18:28.864] future_lapply() ...
[10:18:28.898] Number of chunks: 2
[10:18:28.898] getGlobalsAndPackagesXApply() ...
[10:18:28.898]  - future.globals: <name-value list> with names ‘list()’
[10:18:28.898]  - use_args: TRUE
[10:18:28.898] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:28.899] List of 2
[10:18:28.899]  $ ...          : list()
[10:18:28.899]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:28.899]  $ ...future.FUN:function (..., exclude = if (useNA == "no") c(NA, NaN), useNA = c("no", 
[10:18:28.899]     "ifany", "always"), dnn = list.names(...), deparse.level = 1)  
[10:18:28.899]  - attr(*, "where")=List of 2
[10:18:28.899]   ..$ ...          :<environment: 0x556e05d23278> 
[10:18:28.899]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:28.899]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:28.899]  - attr(*, "resolved")= logi FALSE
[10:18:28.899]  - attr(*, "total_size")= num NA
[10:18:28.902] Packages to be attached in all futures: [n=0] 
[10:18:28.902] getGlobalsAndPackagesXApply() ... DONE
[10:18:28.903] Number of futures (= number of chunks): 2
[10:18:28.903] Launching 2 futures (chunks) ...
[10:18:28.903] Chunk #1 of 2 ...
[10:18:28.903]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:28.903]  - seeds: <none>
[10:18:28.903]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.903] getGlobalsAndPackages() ...
[10:18:28.903] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.903] Resolving globals: FALSE
[10:18:28.903] Tweak future expression to call with '...' arguments ...
[10:18:28.904] {
[10:18:28.904]     do.call(function(...) {
[10:18:28.904]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.904]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:28.904]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.904]             on.exit(options(oopts), add = TRUE)
[10:18:28.904]         }
[10:18:28.904]         {
[10:18:28.904]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:28.904]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.904]                 ...future.FUN(...future.X_jj, ...)
[10:18:28.904]             })
[10:18:28.904]         }
[10:18:28.904]     }, args = future.call.arguments)
[10:18:28.904] }
[10:18:28.904] Tweak future expression to call with '...' arguments ... DONE
[10:18:28.904] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.904] 
[10:18:28.904] getGlobalsAndPackages() ... DONE
[10:18:28.905] run() for ‘Future’ ...
[10:18:28.905] - state: ‘created’
[10:18:28.905] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:28.920] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:28.920] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:28.920]   - Field: ‘node’
[10:18:28.920]   - Field: ‘label’
[10:18:28.920]   - Field: ‘local’
[10:18:28.920]   - Field: ‘owner’
[10:18:28.920]   - Field: ‘envir’
[10:18:28.920]   - Field: ‘workers’
[10:18:28.920]   - Field: ‘packages’
[10:18:28.921]   - Field: ‘gc’
[10:18:28.921]   - Field: ‘conditions’
[10:18:28.921]   - Field: ‘persistent’
[10:18:28.921]   - Field: ‘expr’
[10:18:28.921]   - Field: ‘uuid’
[10:18:28.921]   - Field: ‘seed’
[10:18:28.921]   - Field: ‘version’
[10:18:28.921]   - Field: ‘result’
[10:18:28.921]   - Field: ‘asynchronous’
[10:18:28.921]   - Field: ‘calls’
[10:18:28.921]   - Field: ‘globals’
[10:18:28.921]   - Field: ‘stdout’
[10:18:28.922]   - Field: ‘earlySignal’
[10:18:28.922]   - Field: ‘lazy’
[10:18:28.922]   - Field: ‘state’
[10:18:28.922] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:28.922] - Launch lazy future ...
[10:18:28.922] Packages needed by the future expression (n = 0): <none>
[10:18:28.922] Packages needed by future strategies (n = 0): <none>
[10:18:28.923] {
[10:18:28.923]     {
[10:18:28.923]         {
[10:18:28.923]             ...future.startTime <- base::Sys.time()
[10:18:28.923]             {
[10:18:28.923]                 {
[10:18:28.923]                   {
[10:18:28.923]                     {
[10:18:28.923]                       base::local({
[10:18:28.923]                         has_future <- base::requireNamespace("future", 
[10:18:28.923]                           quietly = TRUE)
[10:18:28.923]                         if (has_future) {
[10:18:28.923]                           ns <- base::getNamespace("future")
[10:18:28.923]                           version <- ns[[".package"]][["version"]]
[10:18:28.923]                           if (is.null(version)) 
[10:18:28.923]                             version <- utils::packageVersion("future")
[10:18:28.923]                         }
[10:18:28.923]                         else {
[10:18:28.923]                           version <- NULL
[10:18:28.923]                         }
[10:18:28.923]                         if (!has_future || version < "1.8.0") {
[10:18:28.923]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:28.923]                             "", base::R.version$version.string), 
[10:18:28.923]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:28.923]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:28.923]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:28.923]                               "release", "version")], collapse = " "), 
[10:18:28.923]                             hostname = base::Sys.info()[["nodename"]])
[10:18:28.923]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:28.923]                             info)
[10:18:28.923]                           info <- base::paste(info, collapse = "; ")
[10:18:28.923]                           if (!has_future) {
[10:18:28.923]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:28.923]                               info)
[10:18:28.923]                           }
[10:18:28.923]                           else {
[10:18:28.923]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:28.923]                               info, version)
[10:18:28.923]                           }
[10:18:28.923]                           base::stop(msg)
[10:18:28.923]                         }
[10:18:28.923]                       })
[10:18:28.923]                     }
[10:18:28.923]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:28.923]                     base::options(mc.cores = 1L)
[10:18:28.923]                   }
[10:18:28.923]                   ...future.strategy.old <- future::plan("list")
[10:18:28.923]                   options(future.plan = NULL)
[10:18:28.923]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:28.923]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:28.923]                 }
[10:18:28.923]                 ...future.workdir <- getwd()
[10:18:28.923]             }
[10:18:28.923]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:28.923]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:28.923]         }
[10:18:28.923]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:28.923]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:28.923]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:28.923]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:28.923]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:28.923]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:28.923]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:28.923]             base::names(...future.oldOptions))
[10:18:28.923]     }
[10:18:28.923]     if (FALSE) {
[10:18:28.923]     }
[10:18:28.923]     else {
[10:18:28.923]         if (TRUE) {
[10:18:28.923]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:28.923]                 open = "w")
[10:18:28.923]         }
[10:18:28.923]         else {
[10:18:28.923]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:28.923]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:28.923]         }
[10:18:28.923]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:28.923]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:28.923]             base::sink(type = "output", split = FALSE)
[10:18:28.923]             base::close(...future.stdout)
[10:18:28.923]         }, add = TRUE)
[10:18:28.923]     }
[10:18:28.923]     ...future.frame <- base::sys.nframe()
[10:18:28.923]     ...future.conditions <- base::list()
[10:18:28.923]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:28.923]     if (FALSE) {
[10:18:28.923]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:28.923]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:28.923]     }
[10:18:28.923]     ...future.result <- base::tryCatch({
[10:18:28.923]         base::withCallingHandlers({
[10:18:28.923]             ...future.value <- base::withVisible(base::local({
[10:18:28.923]                 ...future.makeSendCondition <- base::local({
[10:18:28.923]                   sendCondition <- NULL
[10:18:28.923]                   function(frame = 1L) {
[10:18:28.923]                     if (is.function(sendCondition)) 
[10:18:28.923]                       return(sendCondition)
[10:18:28.923]                     ns <- getNamespace("parallel")
[10:18:28.923]                     if (exists("sendData", mode = "function", 
[10:18:28.923]                       envir = ns)) {
[10:18:28.923]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:28.923]                         envir = ns)
[10:18:28.923]                       envir <- sys.frame(frame)
[10:18:28.923]                       master <- NULL
[10:18:28.923]                       while (!identical(envir, .GlobalEnv) && 
[10:18:28.923]                         !identical(envir, emptyenv())) {
[10:18:28.923]                         if (exists("master", mode = "list", envir = envir, 
[10:18:28.923]                           inherits = FALSE)) {
[10:18:28.923]                           master <- get("master", mode = "list", 
[10:18:28.923]                             envir = envir, inherits = FALSE)
[10:18:28.923]                           if (inherits(master, c("SOCKnode", 
[10:18:28.923]                             "SOCK0node"))) {
[10:18:28.923]                             sendCondition <<- function(cond) {
[10:18:28.923]                               data <- list(type = "VALUE", value = cond, 
[10:18:28.923]                                 success = TRUE)
[10:18:28.923]                               parallel_sendData(master, data)
[10:18:28.923]                             }
[10:18:28.923]                             return(sendCondition)
[10:18:28.923]                           }
[10:18:28.923]                         }
[10:18:28.923]                         frame <- frame + 1L
[10:18:28.923]                         envir <- sys.frame(frame)
[10:18:28.923]                       }
[10:18:28.923]                     }
[10:18:28.923]                     sendCondition <<- function(cond) NULL
[10:18:28.923]                   }
[10:18:28.923]                 })
[10:18:28.923]                 withCallingHandlers({
[10:18:28.923]                   {
[10:18:28.923]                     do.call(function(...) {
[10:18:28.923]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.923]                       if (!identical(...future.globals.maxSize.org, 
[10:18:28.923]                         ...future.globals.maxSize)) {
[10:18:28.923]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.923]                         on.exit(options(oopts), add = TRUE)
[10:18:28.923]                       }
[10:18:28.923]                       {
[10:18:28.923]                         lapply(seq_along(...future.elements_ii), 
[10:18:28.923]                           FUN = function(jj) {
[10:18:28.923]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.923]                             ...future.FUN(...future.X_jj, ...)
[10:18:28.923]                           })
[10:18:28.923]                       }
[10:18:28.923]                     }, args = future.call.arguments)
[10:18:28.923]                   }
[10:18:28.923]                 }, immediateCondition = function(cond) {
[10:18:28.923]                   sendCondition <- ...future.makeSendCondition()
[10:18:28.923]                   sendCondition(cond)
[10:18:28.923]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.923]                   {
[10:18:28.923]                     inherits <- base::inherits
[10:18:28.923]                     invokeRestart <- base::invokeRestart
[10:18:28.923]                     is.null <- base::is.null
[10:18:28.923]                     muffled <- FALSE
[10:18:28.923]                     if (inherits(cond, "message")) {
[10:18:28.923]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:28.923]                       if (muffled) 
[10:18:28.923]                         invokeRestart("muffleMessage")
[10:18:28.923]                     }
[10:18:28.923]                     else if (inherits(cond, "warning")) {
[10:18:28.923]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:28.923]                       if (muffled) 
[10:18:28.923]                         invokeRestart("muffleWarning")
[10:18:28.923]                     }
[10:18:28.923]                     else if (inherits(cond, "condition")) {
[10:18:28.923]                       if (!is.null(pattern)) {
[10:18:28.923]                         computeRestarts <- base::computeRestarts
[10:18:28.923]                         grepl <- base::grepl
[10:18:28.923]                         restarts <- computeRestarts(cond)
[10:18:28.923]                         for (restart in restarts) {
[10:18:28.923]                           name <- restart$name
[10:18:28.923]                           if (is.null(name)) 
[10:18:28.923]                             next
[10:18:28.923]                           if (!grepl(pattern, name)) 
[10:18:28.923]                             next
[10:18:28.923]                           invokeRestart(restart)
[10:18:28.923]                           muffled <- TRUE
[10:18:28.923]                           break
[10:18:28.923]                         }
[10:18:28.923]                       }
[10:18:28.923]                     }
[10:18:28.923]                     invisible(muffled)
[10:18:28.923]                   }
[10:18:28.923]                   muffleCondition(cond)
[10:18:28.923]                 })
[10:18:28.923]             }))
[10:18:28.923]             future::FutureResult(value = ...future.value$value, 
[10:18:28.923]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:28.923]                   ...future.rng), globalenv = if (FALSE) 
[10:18:28.923]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:28.923]                     ...future.globalenv.names))
[10:18:28.923]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:28.923]         }, condition = base::local({
[10:18:28.923]             c <- base::c
[10:18:28.923]             inherits <- base::inherits
[10:18:28.923]             invokeRestart <- base::invokeRestart
[10:18:28.923]             length <- base::length
[10:18:28.923]             list <- base::list
[10:18:28.923]             seq.int <- base::seq.int
[10:18:28.923]             signalCondition <- base::signalCondition
[10:18:28.923]             sys.calls <- base::sys.calls
[10:18:28.923]             `[[` <- base::`[[`
[10:18:28.923]             `+` <- base::`+`
[10:18:28.923]             `<<-` <- base::`<<-`
[10:18:28.923]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:28.923]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:28.923]                   3L)]
[10:18:28.923]             }
[10:18:28.923]             function(cond) {
[10:18:28.923]                 is_error <- inherits(cond, "error")
[10:18:28.923]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:28.923]                   NULL)
[10:18:28.923]                 if (is_error) {
[10:18:28.923]                   sessionInformation <- function() {
[10:18:28.923]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:28.923]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:28.923]                       search = base::search(), system = base::Sys.info())
[10:18:28.923]                   }
[10:18:28.923]                   ...future.conditions[[length(...future.conditions) + 
[10:18:28.923]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:28.923]                     cond$call), session = sessionInformation(), 
[10:18:28.923]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:28.923]                   signalCondition(cond)
[10:18:28.923]                 }
[10:18:28.923]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:28.923]                 "immediateCondition"))) {
[10:18:28.923]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:28.923]                   ...future.conditions[[length(...future.conditions) + 
[10:18:28.923]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:28.923]                   if (TRUE && !signal) {
[10:18:28.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.923]                     {
[10:18:28.923]                       inherits <- base::inherits
[10:18:28.923]                       invokeRestart <- base::invokeRestart
[10:18:28.923]                       is.null <- base::is.null
[10:18:28.923]                       muffled <- FALSE
[10:18:28.923]                       if (inherits(cond, "message")) {
[10:18:28.923]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:28.923]                         if (muffled) 
[10:18:28.923]                           invokeRestart("muffleMessage")
[10:18:28.923]                       }
[10:18:28.923]                       else if (inherits(cond, "warning")) {
[10:18:28.923]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:28.923]                         if (muffled) 
[10:18:28.923]                           invokeRestart("muffleWarning")
[10:18:28.923]                       }
[10:18:28.923]                       else if (inherits(cond, "condition")) {
[10:18:28.923]                         if (!is.null(pattern)) {
[10:18:28.923]                           computeRestarts <- base::computeRestarts
[10:18:28.923]                           grepl <- base::grepl
[10:18:28.923]                           restarts <- computeRestarts(cond)
[10:18:28.923]                           for (restart in restarts) {
[10:18:28.923]                             name <- restart$name
[10:18:28.923]                             if (is.null(name)) 
[10:18:28.923]                               next
[10:18:28.923]                             if (!grepl(pattern, name)) 
[10:18:28.923]                               next
[10:18:28.923]                             invokeRestart(restart)
[10:18:28.923]                             muffled <- TRUE
[10:18:28.923]                             break
[10:18:28.923]                           }
[10:18:28.923]                         }
[10:18:28.923]                       }
[10:18:28.923]                       invisible(muffled)
[10:18:28.923]                     }
[10:18:28.923]                     muffleCondition(cond, pattern = "^muffle")
[10:18:28.923]                   }
[10:18:28.923]                 }
[10:18:28.923]                 else {
[10:18:28.923]                   if (TRUE) {
[10:18:28.923]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:28.923]                     {
[10:18:28.923]                       inherits <- base::inherits
[10:18:28.923]                       invokeRestart <- base::invokeRestart
[10:18:28.923]                       is.null <- base::is.null
[10:18:28.923]                       muffled <- FALSE
[10:18:28.923]                       if (inherits(cond, "message")) {
[10:18:28.923]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:28.923]                         if (muffled) 
[10:18:28.923]                           invokeRestart("muffleMessage")
[10:18:28.923]                       }
[10:18:28.923]                       else if (inherits(cond, "warning")) {
[10:18:28.923]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:28.923]                         if (muffled) 
[10:18:28.923]                           invokeRestart("muffleWarning")
[10:18:28.923]                       }
[10:18:28.923]                       else if (inherits(cond, "condition")) {
[10:18:28.923]                         if (!is.null(pattern)) {
[10:18:28.923]                           computeRestarts <- base::computeRestarts
[10:18:28.923]                           grepl <- base::grepl
[10:18:28.923]                           restarts <- computeRestarts(cond)
[10:18:28.923]                           for (restart in restarts) {
[10:18:28.923]                             name <- restart$name
[10:18:28.923]                             if (is.null(name)) 
[10:18:28.923]                               next
[10:18:28.923]                             if (!grepl(pattern, name)) 
[10:18:28.923]                               next
[10:18:28.923]                             invokeRestart(restart)
[10:18:28.923]                             muffled <- TRUE
[10:18:28.923]                             break
[10:18:28.923]                           }
[10:18:28.923]                         }
[10:18:28.923]                       }
[10:18:28.923]                       invisible(muffled)
[10:18:28.923]                     }
[10:18:28.923]                     muffleCondition(cond, pattern = "^muffle")
[10:18:28.923]                   }
[10:18:28.923]                 }
[10:18:28.923]             }
[10:18:28.923]         }))
[10:18:28.923]     }, error = function(ex) {
[10:18:28.923]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:28.923]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:28.923]                 ...future.rng), started = ...future.startTime, 
[10:18:28.923]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:28.923]             version = "1.8"), class = "FutureResult")
[10:18:28.923]     }, finally = {
[10:18:28.923]         if (!identical(...future.workdir, getwd())) 
[10:18:28.923]             setwd(...future.workdir)
[10:18:28.923]         {
[10:18:28.923]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:28.923]                 ...future.oldOptions$nwarnings <- NULL
[10:18:28.923]             }
[10:18:28.923]             base::options(...future.oldOptions)
[10:18:28.923]             if (.Platform$OS.type == "windows") {
[10:18:28.923]                 old_names <- names(...future.oldEnvVars)
[10:18:28.923]                 envs <- base::Sys.getenv()
[10:18:28.923]                 names <- names(envs)
[10:18:28.923]                 common <- intersect(names, old_names)
[10:18:28.923]                 added <- setdiff(names, old_names)
[10:18:28.923]                 removed <- setdiff(old_names, names)
[10:18:28.923]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:28.923]                   envs[common]]
[10:18:28.923]                 NAMES <- toupper(changed)
[10:18:28.923]                 args <- list()
[10:18:28.923]                 for (kk in seq_along(NAMES)) {
[10:18:28.923]                   name <- changed[[kk]]
[10:18:28.923]                   NAME <- NAMES[[kk]]
[10:18:28.923]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.923]                     next
[10:18:28.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:28.923]                 }
[10:18:28.923]                 NAMES <- toupper(added)
[10:18:28.923]                 for (kk in seq_along(NAMES)) {
[10:18:28.923]                   name <- added[[kk]]
[10:18:28.923]                   NAME <- NAMES[[kk]]
[10:18:28.923]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.923]                     next
[10:18:28.923]                   args[[name]] <- ""
[10:18:28.923]                 }
[10:18:28.923]                 NAMES <- toupper(removed)
[10:18:28.923]                 for (kk in seq_along(NAMES)) {
[10:18:28.923]                   name <- removed[[kk]]
[10:18:28.923]                   NAME <- NAMES[[kk]]
[10:18:28.923]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:28.923]                     next
[10:18:28.923]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:28.923]                 }
[10:18:28.923]                 if (length(args) > 0) 
[10:18:28.923]                   base::do.call(base::Sys.setenv, args = args)
[10:18:28.923]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:28.923]             }
[10:18:28.923]             else {
[10:18:28.923]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:28.923]             }
[10:18:28.923]             {
[10:18:28.923]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:28.923]                   0L) {
[10:18:28.923]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:28.923]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:28.923]                   base::options(opts)
[10:18:28.923]                 }
[10:18:28.923]                 {
[10:18:28.923]                   {
[10:18:28.923]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:28.923]                     NULL
[10:18:28.923]                   }
[10:18:28.923]                   options(future.plan = NULL)
[10:18:28.923]                   if (is.na(NA_character_)) 
[10:18:28.923]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:28.923]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:28.923]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:28.923]                     .init = FALSE)
[10:18:28.923]                 }
[10:18:28.923]             }
[10:18:28.923]         }
[10:18:28.923]     })
[10:18:28.923]     if (TRUE) {
[10:18:28.923]         base::sink(type = "output", split = FALSE)
[10:18:28.923]         if (TRUE) {
[10:18:28.923]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:28.923]         }
[10:18:28.923]         else {
[10:18:28.923]             ...future.result["stdout"] <- base::list(NULL)
[10:18:28.923]         }
[10:18:28.923]         base::close(...future.stdout)
[10:18:28.923]         ...future.stdout <- NULL
[10:18:28.923]     }
[10:18:28.923]     ...future.result$conditions <- ...future.conditions
[10:18:28.923]     ...future.result$finished <- base::Sys.time()
[10:18:28.923]     ...future.result
[10:18:28.923] }
[10:18:28.926] Exporting 5 global objects (31.96 KiB) to cluster node #1 ...
[10:18:28.926] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:28.926] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:28.927] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ...
[10:18:28.969] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #1 ... DONE
[10:18:28.969] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[10:18:28.969] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[10:18:28.969] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:28.970] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:28.970] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:28.970] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:28.970] Exporting 5 global objects (31.96 KiB) to cluster node #1 ... DONE
[10:18:28.971] MultisessionFuture started
[10:18:28.971] - Launch lazy future ... done
[10:18:28.971] run() for ‘MultisessionFuture’ ... done
[10:18:28.971] Created future:
[10:18:28.971] MultisessionFuture:
[10:18:28.971] Label: ‘future_apply-1’
[10:18:28.971] Expression:
[10:18:28.971] {
[10:18:28.971]     do.call(function(...) {
[10:18:28.971]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.971]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:28.971]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.971]             on.exit(options(oopts), add = TRUE)
[10:18:28.971]         }
[10:18:28.971]         {
[10:18:28.971]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:28.971]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.971]                 ...future.FUN(...future.X_jj, ...)
[10:18:28.971]             })
[10:18:28.971]         }
[10:18:28.971]     }, args = future.call.arguments)
[10:18:28.971] }
[10:18:28.971] Lazy evaluation: FALSE
[10:18:28.971] Asynchronous evaluation: TRUE
[10:18:28.971] Local evaluation: TRUE
[10:18:28.971] Environment: R_GlobalEnv
[10:18:28.971] Capture standard output: TRUE
[10:18:28.971] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:28.971] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:28.971] Packages: <none>
[10:18:28.971] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:28.971] Resolved: FALSE
[10:18:28.971] Value: <not collected>
[10:18:28.971] Conditions captured: <none>
[10:18:28.971] Early signaling: FALSE
[10:18:28.971] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:28.971] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:28.983] Chunk #1 of 2 ... DONE
[10:18:28.983] Chunk #2 of 2 ...
[10:18:28.984]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:28.984]  - seeds: <none>
[10:18:28.984]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.984] getGlobalsAndPackages() ...
[10:18:28.984] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.984] Resolving globals: FALSE
[10:18:28.984] Tweak future expression to call with '...' arguments ...
[10:18:28.984] {
[10:18:28.984]     do.call(function(...) {
[10:18:28.984]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:28.984]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:28.984]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:28.984]             on.exit(options(oopts), add = TRUE)
[10:18:28.984]         }
[10:18:28.984]         {
[10:18:28.984]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:28.984]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:28.984]                 ...future.FUN(...future.X_jj, ...)
[10:18:28.984]             })
[10:18:28.984]         }
[10:18:28.984]     }, args = future.call.arguments)
[10:18:28.984] }
[10:18:28.985] Tweak future expression to call with '...' arguments ... DONE
[10:18:28.985] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:28.985] 
[10:18:28.985] getGlobalsAndPackages() ... DONE
[10:18:28.985] run() for ‘Future’ ...
[10:18:28.986] - state: ‘created’
[10:18:28.986] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.000] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.000] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.000]   - Field: ‘node’
[10:18:29.000]   - Field: ‘label’
[10:18:29.000]   - Field: ‘local’
[10:18:29.000]   - Field: ‘owner’
[10:18:29.000]   - Field: ‘envir’
[10:18:29.000]   - Field: ‘workers’
[10:18:29.001]   - Field: ‘packages’
[10:18:29.001]   - Field: ‘gc’
[10:18:29.001]   - Field: ‘conditions’
[10:18:29.001]   - Field: ‘persistent’
[10:18:29.001]   - Field: ‘expr’
[10:18:29.001]   - Field: ‘uuid’
[10:18:29.001]   - Field: ‘seed’
[10:18:29.001]   - Field: ‘version’
[10:18:29.001]   - Field: ‘result’
[10:18:29.001]   - Field: ‘asynchronous’
[10:18:29.001]   - Field: ‘calls’
[10:18:29.001]   - Field: ‘globals’
[10:18:29.002]   - Field: ‘stdout’
[10:18:29.002]   - Field: ‘earlySignal’
[10:18:29.002]   - Field: ‘lazy’
[10:18:29.002]   - Field: ‘state’
[10:18:29.002] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.002] - Launch lazy future ...
[10:18:29.002] Packages needed by the future expression (n = 0): <none>
[10:18:29.002] Packages needed by future strategies (n = 0): <none>
[10:18:29.003] {
[10:18:29.003]     {
[10:18:29.003]         {
[10:18:29.003]             ...future.startTime <- base::Sys.time()
[10:18:29.003]             {
[10:18:29.003]                 {
[10:18:29.003]                   {
[10:18:29.003]                     {
[10:18:29.003]                       base::local({
[10:18:29.003]                         has_future <- base::requireNamespace("future", 
[10:18:29.003]                           quietly = TRUE)
[10:18:29.003]                         if (has_future) {
[10:18:29.003]                           ns <- base::getNamespace("future")
[10:18:29.003]                           version <- ns[[".package"]][["version"]]
[10:18:29.003]                           if (is.null(version)) 
[10:18:29.003]                             version <- utils::packageVersion("future")
[10:18:29.003]                         }
[10:18:29.003]                         else {
[10:18:29.003]                           version <- NULL
[10:18:29.003]                         }
[10:18:29.003]                         if (!has_future || version < "1.8.0") {
[10:18:29.003]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.003]                             "", base::R.version$version.string), 
[10:18:29.003]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.003]                               "release", "version")], collapse = " "), 
[10:18:29.003]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.003]                             info)
[10:18:29.003]                           info <- base::paste(info, collapse = "; ")
[10:18:29.003]                           if (!has_future) {
[10:18:29.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.003]                               info)
[10:18:29.003]                           }
[10:18:29.003]                           else {
[10:18:29.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.003]                               info, version)
[10:18:29.003]                           }
[10:18:29.003]                           base::stop(msg)
[10:18:29.003]                         }
[10:18:29.003]                       })
[10:18:29.003]                     }
[10:18:29.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.003]                     base::options(mc.cores = 1L)
[10:18:29.003]                   }
[10:18:29.003]                   ...future.strategy.old <- future::plan("list")
[10:18:29.003]                   options(future.plan = NULL)
[10:18:29.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.003]                 }
[10:18:29.003]                 ...future.workdir <- getwd()
[10:18:29.003]             }
[10:18:29.003]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.003]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.003]         }
[10:18:29.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.003]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.003]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.003]             base::names(...future.oldOptions))
[10:18:29.003]     }
[10:18:29.003]     if (FALSE) {
[10:18:29.003]     }
[10:18:29.003]     else {
[10:18:29.003]         if (TRUE) {
[10:18:29.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.003]                 open = "w")
[10:18:29.003]         }
[10:18:29.003]         else {
[10:18:29.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.003]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.003]         }
[10:18:29.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.003]             base::sink(type = "output", split = FALSE)
[10:18:29.003]             base::close(...future.stdout)
[10:18:29.003]         }, add = TRUE)
[10:18:29.003]     }
[10:18:29.003]     ...future.frame <- base::sys.nframe()
[10:18:29.003]     ...future.conditions <- base::list()
[10:18:29.003]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.003]     if (FALSE) {
[10:18:29.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.003]     }
[10:18:29.003]     ...future.result <- base::tryCatch({
[10:18:29.003]         base::withCallingHandlers({
[10:18:29.003]             ...future.value <- base::withVisible(base::local({
[10:18:29.003]                 ...future.makeSendCondition <- base::local({
[10:18:29.003]                   sendCondition <- NULL
[10:18:29.003]                   function(frame = 1L) {
[10:18:29.003]                     if (is.function(sendCondition)) 
[10:18:29.003]                       return(sendCondition)
[10:18:29.003]                     ns <- getNamespace("parallel")
[10:18:29.003]                     if (exists("sendData", mode = "function", 
[10:18:29.003]                       envir = ns)) {
[10:18:29.003]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.003]                         envir = ns)
[10:18:29.003]                       envir <- sys.frame(frame)
[10:18:29.003]                       master <- NULL
[10:18:29.003]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.003]                         !identical(envir, emptyenv())) {
[10:18:29.003]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.003]                           inherits = FALSE)) {
[10:18:29.003]                           master <- get("master", mode = "list", 
[10:18:29.003]                             envir = envir, inherits = FALSE)
[10:18:29.003]                           if (inherits(master, c("SOCKnode", 
[10:18:29.003]                             "SOCK0node"))) {
[10:18:29.003]                             sendCondition <<- function(cond) {
[10:18:29.003]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.003]                                 success = TRUE)
[10:18:29.003]                               parallel_sendData(master, data)
[10:18:29.003]                             }
[10:18:29.003]                             return(sendCondition)
[10:18:29.003]                           }
[10:18:29.003]                         }
[10:18:29.003]                         frame <- frame + 1L
[10:18:29.003]                         envir <- sys.frame(frame)
[10:18:29.003]                       }
[10:18:29.003]                     }
[10:18:29.003]                     sendCondition <<- function(cond) NULL
[10:18:29.003]                   }
[10:18:29.003]                 })
[10:18:29.003]                 withCallingHandlers({
[10:18:29.003]                   {
[10:18:29.003]                     do.call(function(...) {
[10:18:29.003]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.003]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.003]                         ...future.globals.maxSize)) {
[10:18:29.003]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.003]                         on.exit(options(oopts), add = TRUE)
[10:18:29.003]                       }
[10:18:29.003]                       {
[10:18:29.003]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.003]                           FUN = function(jj) {
[10:18:29.003]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.003]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.003]                           })
[10:18:29.003]                       }
[10:18:29.003]                     }, args = future.call.arguments)
[10:18:29.003]                   }
[10:18:29.003]                 }, immediateCondition = function(cond) {
[10:18:29.003]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.003]                   sendCondition(cond)
[10:18:29.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.003]                   {
[10:18:29.003]                     inherits <- base::inherits
[10:18:29.003]                     invokeRestart <- base::invokeRestart
[10:18:29.003]                     is.null <- base::is.null
[10:18:29.003]                     muffled <- FALSE
[10:18:29.003]                     if (inherits(cond, "message")) {
[10:18:29.003]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.003]                       if (muffled) 
[10:18:29.003]                         invokeRestart("muffleMessage")
[10:18:29.003]                     }
[10:18:29.003]                     else if (inherits(cond, "warning")) {
[10:18:29.003]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.003]                       if (muffled) 
[10:18:29.003]                         invokeRestart("muffleWarning")
[10:18:29.003]                     }
[10:18:29.003]                     else if (inherits(cond, "condition")) {
[10:18:29.003]                       if (!is.null(pattern)) {
[10:18:29.003]                         computeRestarts <- base::computeRestarts
[10:18:29.003]                         grepl <- base::grepl
[10:18:29.003]                         restarts <- computeRestarts(cond)
[10:18:29.003]                         for (restart in restarts) {
[10:18:29.003]                           name <- restart$name
[10:18:29.003]                           if (is.null(name)) 
[10:18:29.003]                             next
[10:18:29.003]                           if (!grepl(pattern, name)) 
[10:18:29.003]                             next
[10:18:29.003]                           invokeRestart(restart)
[10:18:29.003]                           muffled <- TRUE
[10:18:29.003]                           break
[10:18:29.003]                         }
[10:18:29.003]                       }
[10:18:29.003]                     }
[10:18:29.003]                     invisible(muffled)
[10:18:29.003]                   }
[10:18:29.003]                   muffleCondition(cond)
[10:18:29.003]                 })
[10:18:29.003]             }))
[10:18:29.003]             future::FutureResult(value = ...future.value$value, 
[10:18:29.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.003]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.003]                     ...future.globalenv.names))
[10:18:29.003]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.003]         }, condition = base::local({
[10:18:29.003]             c <- base::c
[10:18:29.003]             inherits <- base::inherits
[10:18:29.003]             invokeRestart <- base::invokeRestart
[10:18:29.003]             length <- base::length
[10:18:29.003]             list <- base::list
[10:18:29.003]             seq.int <- base::seq.int
[10:18:29.003]             signalCondition <- base::signalCondition
[10:18:29.003]             sys.calls <- base::sys.calls
[10:18:29.003]             `[[` <- base::`[[`
[10:18:29.003]             `+` <- base::`+`
[10:18:29.003]             `<<-` <- base::`<<-`
[10:18:29.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.003]                   3L)]
[10:18:29.003]             }
[10:18:29.003]             function(cond) {
[10:18:29.003]                 is_error <- inherits(cond, "error")
[10:18:29.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.003]                   NULL)
[10:18:29.003]                 if (is_error) {
[10:18:29.003]                   sessionInformation <- function() {
[10:18:29.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.003]                       search = base::search(), system = base::Sys.info())
[10:18:29.003]                   }
[10:18:29.003]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.003]                     cond$call), session = sessionInformation(), 
[10:18:29.003]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.003]                   signalCondition(cond)
[10:18:29.003]                 }
[10:18:29.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.003]                 "immediateCondition"))) {
[10:18:29.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.003]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.003]                   if (TRUE && !signal) {
[10:18:29.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.003]                     {
[10:18:29.003]                       inherits <- base::inherits
[10:18:29.003]                       invokeRestart <- base::invokeRestart
[10:18:29.003]                       is.null <- base::is.null
[10:18:29.003]                       muffled <- FALSE
[10:18:29.003]                       if (inherits(cond, "message")) {
[10:18:29.003]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.003]                         if (muffled) 
[10:18:29.003]                           invokeRestart("muffleMessage")
[10:18:29.003]                       }
[10:18:29.003]                       else if (inherits(cond, "warning")) {
[10:18:29.003]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.003]                         if (muffled) 
[10:18:29.003]                           invokeRestart("muffleWarning")
[10:18:29.003]                       }
[10:18:29.003]                       else if (inherits(cond, "condition")) {
[10:18:29.003]                         if (!is.null(pattern)) {
[10:18:29.003]                           computeRestarts <- base::computeRestarts
[10:18:29.003]                           grepl <- base::grepl
[10:18:29.003]                           restarts <- computeRestarts(cond)
[10:18:29.003]                           for (restart in restarts) {
[10:18:29.003]                             name <- restart$name
[10:18:29.003]                             if (is.null(name)) 
[10:18:29.003]                               next
[10:18:29.003]                             if (!grepl(pattern, name)) 
[10:18:29.003]                               next
[10:18:29.003]                             invokeRestart(restart)
[10:18:29.003]                             muffled <- TRUE
[10:18:29.003]                             break
[10:18:29.003]                           }
[10:18:29.003]                         }
[10:18:29.003]                       }
[10:18:29.003]                       invisible(muffled)
[10:18:29.003]                     }
[10:18:29.003]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.003]                   }
[10:18:29.003]                 }
[10:18:29.003]                 else {
[10:18:29.003]                   if (TRUE) {
[10:18:29.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.003]                     {
[10:18:29.003]                       inherits <- base::inherits
[10:18:29.003]                       invokeRestart <- base::invokeRestart
[10:18:29.003]                       is.null <- base::is.null
[10:18:29.003]                       muffled <- FALSE
[10:18:29.003]                       if (inherits(cond, "message")) {
[10:18:29.003]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.003]                         if (muffled) 
[10:18:29.003]                           invokeRestart("muffleMessage")
[10:18:29.003]                       }
[10:18:29.003]                       else if (inherits(cond, "warning")) {
[10:18:29.003]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.003]                         if (muffled) 
[10:18:29.003]                           invokeRestart("muffleWarning")
[10:18:29.003]                       }
[10:18:29.003]                       else if (inherits(cond, "condition")) {
[10:18:29.003]                         if (!is.null(pattern)) {
[10:18:29.003]                           computeRestarts <- base::computeRestarts
[10:18:29.003]                           grepl <- base::grepl
[10:18:29.003]                           restarts <- computeRestarts(cond)
[10:18:29.003]                           for (restart in restarts) {
[10:18:29.003]                             name <- restart$name
[10:18:29.003]                             if (is.null(name)) 
[10:18:29.003]                               next
[10:18:29.003]                             if (!grepl(pattern, name)) 
[10:18:29.003]                               next
[10:18:29.003]                             invokeRestart(restart)
[10:18:29.003]                             muffled <- TRUE
[10:18:29.003]                             break
[10:18:29.003]                           }
[10:18:29.003]                         }
[10:18:29.003]                       }
[10:18:29.003]                       invisible(muffled)
[10:18:29.003]                     }
[10:18:29.003]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.003]                   }
[10:18:29.003]                 }
[10:18:29.003]             }
[10:18:29.003]         }))
[10:18:29.003]     }, error = function(ex) {
[10:18:29.003]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.003]                 ...future.rng), started = ...future.startTime, 
[10:18:29.003]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.003]             version = "1.8"), class = "FutureResult")
[10:18:29.003]     }, finally = {
[10:18:29.003]         if (!identical(...future.workdir, getwd())) 
[10:18:29.003]             setwd(...future.workdir)
[10:18:29.003]         {
[10:18:29.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.003]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.003]             }
[10:18:29.003]             base::options(...future.oldOptions)
[10:18:29.003]             if (.Platform$OS.type == "windows") {
[10:18:29.003]                 old_names <- names(...future.oldEnvVars)
[10:18:29.003]                 envs <- base::Sys.getenv()
[10:18:29.003]                 names <- names(envs)
[10:18:29.003]                 common <- intersect(names, old_names)
[10:18:29.003]                 added <- setdiff(names, old_names)
[10:18:29.003]                 removed <- setdiff(old_names, names)
[10:18:29.003]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.003]                   envs[common]]
[10:18:29.003]                 NAMES <- toupper(changed)
[10:18:29.003]                 args <- list()
[10:18:29.003]                 for (kk in seq_along(NAMES)) {
[10:18:29.003]                   name <- changed[[kk]]
[10:18:29.003]                   NAME <- NAMES[[kk]]
[10:18:29.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.003]                     next
[10:18:29.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.003]                 }
[10:18:29.003]                 NAMES <- toupper(added)
[10:18:29.003]                 for (kk in seq_along(NAMES)) {
[10:18:29.003]                   name <- added[[kk]]
[10:18:29.003]                   NAME <- NAMES[[kk]]
[10:18:29.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.003]                     next
[10:18:29.003]                   args[[name]] <- ""
[10:18:29.003]                 }
[10:18:29.003]                 NAMES <- toupper(removed)
[10:18:29.003]                 for (kk in seq_along(NAMES)) {
[10:18:29.003]                   name <- removed[[kk]]
[10:18:29.003]                   NAME <- NAMES[[kk]]
[10:18:29.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.003]                     next
[10:18:29.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.003]                 }
[10:18:29.003]                 if (length(args) > 0) 
[10:18:29.003]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.003]             }
[10:18:29.003]             else {
[10:18:29.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.003]             }
[10:18:29.003]             {
[10:18:29.003]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.003]                   0L) {
[10:18:29.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.003]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.003]                   base::options(opts)
[10:18:29.003]                 }
[10:18:29.003]                 {
[10:18:29.003]                   {
[10:18:29.003]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.003]                     NULL
[10:18:29.003]                   }
[10:18:29.003]                   options(future.plan = NULL)
[10:18:29.003]                   if (is.na(NA_character_)) 
[10:18:29.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.003]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.003]                     .init = FALSE)
[10:18:29.003]                 }
[10:18:29.003]             }
[10:18:29.003]         }
[10:18:29.003]     })
[10:18:29.003]     if (TRUE) {
[10:18:29.003]         base::sink(type = "output", split = FALSE)
[10:18:29.003]         if (TRUE) {
[10:18:29.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.003]         }
[10:18:29.003]         else {
[10:18:29.003]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.003]         }
[10:18:29.003]         base::close(...future.stdout)
[10:18:29.003]         ...future.stdout <- NULL
[10:18:29.003]     }
[10:18:29.003]     ...future.result$conditions <- ...future.conditions
[10:18:29.003]     ...future.result$finished <- base::Sys.time()
[10:18:29.003]     ...future.result
[10:18:29.003] }
[10:18:29.006] Exporting 5 global objects (31.96 KiB) to cluster node #2 ...
[10:18:29.006] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:29.007] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:29.007] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ...
[10:18:29.049] Exporting ‘...future.FUN’ (31.30 KiB) to cluster node #2 ... DONE
[10:18:29.049] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[10:18:29.049] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[10:18:29.049] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:29.050] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:29.050] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:29.050] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:29.050] Exporting 5 global objects (31.96 KiB) to cluster node #2 ... DONE
[10:18:29.051] MultisessionFuture started
[10:18:29.051] - Launch lazy future ... done
[10:18:29.051] run() for ‘MultisessionFuture’ ... done
[10:18:29.051] Created future:
[10:18:29.051] MultisessionFuture:
[10:18:29.051] Label: ‘future_apply-2’
[10:18:29.051] Expression:
[10:18:29.051] {
[10:18:29.051]     do.call(function(...) {
[10:18:29.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.051]             on.exit(options(oopts), add = TRUE)
[10:18:29.051]         }
[10:18:29.051]         {
[10:18:29.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.051]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.051]             })
[10:18:29.051]         }
[10:18:29.051]     }, args = future.call.arguments)
[10:18:29.051] }
[10:18:29.051] Lazy evaluation: FALSE
[10:18:29.051] Asynchronous evaluation: TRUE
[10:18:29.051] Local evaluation: TRUE
[10:18:29.051] Environment: R_GlobalEnv
[10:18:29.051] Capture standard output: TRUE
[10:18:29.051] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.051] Globals: 5 objects totaling 31.53 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 31.30 KiB, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.051] Packages: <none>
[10:18:29.051] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.051] Resolved: FALSE
[10:18:29.051] Value: <not collected>
[10:18:29.051] Conditions captured: <none>
[10:18:29.051] Early signaling: FALSE
[10:18:29.051] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.051] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.063] Chunk #2 of 2 ... DONE
[10:18:29.063] Launching 2 futures (chunks) ... DONE
[10:18:29.063] Resolving 2 futures (chunks) ...
[10:18:29.064] resolve() on list ...
[10:18:29.064]  recursive: 0
[10:18:29.064]  length: 2
[10:18:29.064] 
[10:18:29.064] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.064] - Validating connection of MultisessionFuture
[10:18:29.065] - received message: FutureResult
[10:18:29.065] - Received FutureResult
[10:18:29.065] - Erased future from FutureRegistry
[10:18:29.065] result() for ClusterFuture ...
[10:18:29.065] - result already collected: FutureResult
[10:18:29.065] result() for ClusterFuture ... done
[10:18:29.065] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.065] Future #1
[10:18:29.065] result() for ClusterFuture ...
[10:18:29.065] - result already collected: FutureResult
[10:18:29.066] result() for ClusterFuture ... done
[10:18:29.066] result() for ClusterFuture ...
[10:18:29.066] - result already collected: FutureResult
[10:18:29.066] result() for ClusterFuture ... done
[10:18:29.066] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:29.066] - nx: 2
[10:18:29.066] - relay: TRUE
[10:18:29.066] - stdout: TRUE
[10:18:29.066] - signal: TRUE
[10:18:29.066] - resignal: FALSE
[10:18:29.066] - force: TRUE
[10:18:29.066] - relayed: [n=2] FALSE, FALSE
[10:18:29.067] - queued futures: [n=2] FALSE, FALSE
[10:18:29.067]  - until=1
[10:18:29.067]  - relaying element #1
[10:18:29.067] result() for ClusterFuture ...
[10:18:29.067] - result already collected: FutureResult
[10:18:29.067] result() for ClusterFuture ... done
[10:18:29.067] result() for ClusterFuture ...
[10:18:29.067] - result already collected: FutureResult
[10:18:29.067] result() for ClusterFuture ... done
[10:18:29.067] result() for ClusterFuture ...
[10:18:29.068] - result already collected: FutureResult
[10:18:29.068] result() for ClusterFuture ... done
[10:18:29.068] result() for ClusterFuture ...
[10:18:29.068] - result already collected: FutureResult
[10:18:29.068] result() for ClusterFuture ... done
[10:18:29.068] - relayed: [n=2] TRUE, FALSE
[10:18:29.068] - queued futures: [n=2] TRUE, FALSE
[10:18:29.068] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:29.068]  length: 1 (resolved future 1)
[10:18:29.093] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.093] - Validating connection of MultisessionFuture
[10:18:29.094] - received message: FutureResult
[10:18:29.094] - Received FutureResult
[10:18:29.094] - Erased future from FutureRegistry
[10:18:29.094] result() for ClusterFuture ...
[10:18:29.094] - result already collected: FutureResult
[10:18:29.094] result() for ClusterFuture ... done
[10:18:29.094] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.094] Future #2
[10:18:29.094] result() for ClusterFuture ...
[10:18:29.095] - result already collected: FutureResult
[10:18:29.095] result() for ClusterFuture ... done
[10:18:29.095] result() for ClusterFuture ...
[10:18:29.095] - result already collected: FutureResult
[10:18:29.095] result() for ClusterFuture ... done
[10:18:29.095] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:29.095] - nx: 2
[10:18:29.095] - relay: TRUE
[10:18:29.095] - stdout: TRUE
[10:18:29.095] - signal: TRUE
[10:18:29.095] - resignal: FALSE
[10:18:29.095] - force: TRUE
[10:18:29.096] - relayed: [n=2] TRUE, FALSE
[10:18:29.096] - queued futures: [n=2] TRUE, FALSE
[10:18:29.096]  - until=2
[10:18:29.096]  - relaying element #2
[10:18:29.096] result() for ClusterFuture ...
[10:18:29.096] - result already collected: FutureResult
[10:18:29.096] result() for ClusterFuture ... done
[10:18:29.096] result() for ClusterFuture ...
[10:18:29.096] - result already collected: FutureResult
[10:18:29.096] result() for ClusterFuture ... done
[10:18:29.096] result() for ClusterFuture ...
[10:18:29.097] - result already collected: FutureResult
[10:18:29.097] result() for ClusterFuture ... done
[10:18:29.097] result() for ClusterFuture ...
[10:18:29.097] - result already collected: FutureResult
[10:18:29.097] result() for ClusterFuture ... done
[10:18:29.097] - relayed: [n=2] TRUE, TRUE
[10:18:29.097] - queued futures: [n=2] TRUE, TRUE
[10:18:29.097] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:29.097]  length: 0 (resolved future 2)
[10:18:29.097] Relaying remaining futures
[10:18:29.097] signalConditionsASAP(NULL, pos=0) ...
[10:18:29.097] - nx: 2
[10:18:29.098] - relay: TRUE
[10:18:29.098] - stdout: TRUE
[10:18:29.098] - signal: TRUE
[10:18:29.098] - resignal: FALSE
[10:18:29.098] - force: TRUE
[10:18:29.098] - relayed: [n=2] TRUE, TRUE
[10:18:29.098] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:29.098] - relayed: [n=2] TRUE, TRUE
[10:18:29.098] - queued futures: [n=2] TRUE, TRUE
[10:18:29.098] signalConditionsASAP(NULL, pos=0) ... done
[10:18:29.098] resolve() on list ... DONE
[10:18:29.098] result() for ClusterFuture ...
[10:18:29.099] - result already collected: FutureResult
[10:18:29.099] result() for ClusterFuture ... done
[10:18:29.099] result() for ClusterFuture ...
[10:18:29.099] - result already collected: FutureResult
[10:18:29.099] result() for ClusterFuture ... done
[10:18:29.099] result() for ClusterFuture ...
[10:18:29.099] - result already collected: FutureResult
[10:18:29.099] result() for ClusterFuture ... done
[10:18:29.099] result() for ClusterFuture ...
[10:18:29.099] - result already collected: FutureResult
[10:18:29.099] result() for ClusterFuture ... done
[10:18:29.099]  - Number of value chunks collected: 2
[10:18:29.100] Resolving 2 futures (chunks) ... DONE
[10:18:29.100] Reducing values from 2 chunks ...
[10:18:29.100]  - Number of values collected after concatenation: 2
[10:18:29.100]  - Number of values expected: 2
[10:18:29.100] Reducing values from 2 chunks ... DONE
[10:18:29.100] future_lapply() ... DONE
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

[10:18:29.101] getGlobalsAndPackagesXApply() ...
[10:18:29.101]  - future.globals: TRUE
[10:18:29.101] getGlobalsAndPackages() ...
[10:18:29.101] Searching for globals...
[10:18:29.102] - globals found: [2] ‘FUN’, ‘UseMethod’
[10:18:29.102] Searching for globals ... DONE
[10:18:29.102] Resolving globals: FALSE
[10:18:29.103] The total size of the 1 globals is 311 bytes (311 bytes)
[10:18:29.103] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(1, 2, 3, 4, 1, 6, 7, 8), dim = c(2L, 4L)))’) is 311 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (311 bytes of class ‘function’)
[10:18:29.103] - globals: [1] ‘FUN’
[10:18:29.103] - packages: [1] ‘stats’
[10:18:29.103] getGlobalsAndPackages() ... DONE
[10:18:29.104]  - globals found/used: [n=1] ‘FUN’
[10:18:29.104]  - needed namespaces: [n=1] ‘stats’
[10:18:29.104] Finding globals ... DONE
[10:18:29.104]  - use_args: TRUE
[10:18:29.104]  - Getting '...' globals ...
[10:18:29.104] resolve() on list ...
[10:18:29.104]  recursive: 0
[10:18:29.104]  length: 1
[10:18:29.105]  elements: ‘...’
[10:18:29.105]  length: 0 (resolved future 1)
[10:18:29.105] resolve() on list ... DONE
[10:18:29.105]    - '...' content: [n=0] 
[10:18:29.105] List of 1
[10:18:29.105]  $ ...: list()
[10:18:29.105]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.105]  - attr(*, "where")=List of 1
[10:18:29.105]   ..$ ...:<environment: 0x556e0545faf8> 
[10:18:29.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.105]  - attr(*, "resolved")= logi TRUE
[10:18:29.105]  - attr(*, "total_size")= num NA
[10:18:29.107]  - Getting '...' globals ... DONE
[10:18:29.108] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:29.108] List of 2
[10:18:29.108]  $ ...future.FUN:function (x, ...)  
[10:18:29.108]  $ ...          : list()
[10:18:29.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.108]  - attr(*, "where")=List of 2
[10:18:29.108]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:29.108]   ..$ ...          :<environment: 0x556e0545faf8> 
[10:18:29.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.108]  - attr(*, "resolved")= logi FALSE
[10:18:29.108]  - attr(*, "total_size")= num 2586
[10:18:29.110] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:29.110] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.112] future_lapply() ...
[10:18:29.114] Number of chunks: 2
[10:18:29.114] getGlobalsAndPackagesXApply() ...
[10:18:29.114]  - future.globals: <name-value list> with names ‘list()’
[10:18:29.114]  - use_args: TRUE
[10:18:29.114] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:29.114] List of 2
[10:18:29.114]  $ ...          : list()
[10:18:29.114]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.114]  $ ...future.FUN:function (x, ...)  
[10:18:29.114]  - attr(*, "where")=List of 2
[10:18:29.114]   ..$ ...          :<environment: 0x556e0545faf8> 
[10:18:29.114]   ..$ ...future.FUN:<environment: namespace:stats> 
[10:18:29.114]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.114]  - attr(*, "resolved")= logi FALSE
[10:18:29.114]  - attr(*, "total_size")= num NA
[10:18:29.117] Packages to be attached in all futures: [n=1] ‘stats’
[10:18:29.117] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.117] Number of futures (= number of chunks): 2
[10:18:29.117] Launching 2 futures (chunks) ...
[10:18:29.118] Chunk #1 of 2 ...
[10:18:29.118]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.118]  - seeds: <none>
[10:18:29.118]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.118] getGlobalsAndPackages() ...
[10:18:29.118] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.118] Resolving globals: FALSE
[10:18:29.118] Tweak future expression to call with '...' arguments ...
[10:18:29.118] {
[10:18:29.118]     do.call(function(...) {
[10:18:29.118]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.118]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.118]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.118]             on.exit(options(oopts), add = TRUE)
[10:18:29.118]         }
[10:18:29.118]         {
[10:18:29.118]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.118]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.118]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.118]             })
[10:18:29.118]         }
[10:18:29.118]     }, args = future.call.arguments)
[10:18:29.118] }
[10:18:29.119] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.119] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.119] - packages: [1] ‘stats’
[10:18:29.119] getGlobalsAndPackages() ... DONE
[10:18:29.120] run() for ‘Future’ ...
[10:18:29.120] - state: ‘created’
[10:18:29.120] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.134] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.135]   - Field: ‘node’
[10:18:29.135]   - Field: ‘label’
[10:18:29.135]   - Field: ‘local’
[10:18:29.135]   - Field: ‘owner’
[10:18:29.135]   - Field: ‘envir’
[10:18:29.135]   - Field: ‘workers’
[10:18:29.135]   - Field: ‘packages’
[10:18:29.135]   - Field: ‘gc’
[10:18:29.135]   - Field: ‘conditions’
[10:18:29.135]   - Field: ‘persistent’
[10:18:29.135]   - Field: ‘expr’
[10:18:29.136]   - Field: ‘uuid’
[10:18:29.136]   - Field: ‘seed’
[10:18:29.136]   - Field: ‘version’
[10:18:29.136]   - Field: ‘result’
[10:18:29.136]   - Field: ‘asynchronous’
[10:18:29.136]   - Field: ‘calls’
[10:18:29.136]   - Field: ‘globals’
[10:18:29.136]   - Field: ‘stdout’
[10:18:29.136]   - Field: ‘earlySignal’
[10:18:29.136]   - Field: ‘lazy’
[10:18:29.136]   - Field: ‘state’
[10:18:29.136] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.137] - Launch lazy future ...
[10:18:29.137] Packages needed by the future expression (n = 1): ‘stats’
[10:18:29.137] Packages needed by future strategies (n = 0): <none>
[10:18:29.137] {
[10:18:29.137]     {
[10:18:29.137]         {
[10:18:29.137]             ...future.startTime <- base::Sys.time()
[10:18:29.137]             {
[10:18:29.137]                 {
[10:18:29.137]                   {
[10:18:29.137]                     {
[10:18:29.137]                       {
[10:18:29.137]                         base::local({
[10:18:29.137]                           has_future <- base::requireNamespace("future", 
[10:18:29.137]                             quietly = TRUE)
[10:18:29.137]                           if (has_future) {
[10:18:29.137]                             ns <- base::getNamespace("future")
[10:18:29.137]                             version <- ns[[".package"]][["version"]]
[10:18:29.137]                             if (is.null(version)) 
[10:18:29.137]                               version <- utils::packageVersion("future")
[10:18:29.137]                           }
[10:18:29.137]                           else {
[10:18:29.137]                             version <- NULL
[10:18:29.137]                           }
[10:18:29.137]                           if (!has_future || version < "1.8.0") {
[10:18:29.137]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.137]                               "", base::R.version$version.string), 
[10:18:29.137]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:29.137]                                 base::R.version$platform, 8 * 
[10:18:29.137]                                   base::.Machine$sizeof.pointer), 
[10:18:29.137]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.137]                                 "release", "version")], collapse = " "), 
[10:18:29.137]                               hostname = base::Sys.info()[["nodename"]])
[10:18:29.137]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.137]                               info)
[10:18:29.137]                             info <- base::paste(info, collapse = "; ")
[10:18:29.137]                             if (!has_future) {
[10:18:29.137]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.137]                                 info)
[10:18:29.137]                             }
[10:18:29.137]                             else {
[10:18:29.137]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.137]                                 info, version)
[10:18:29.137]                             }
[10:18:29.137]                             base::stop(msg)
[10:18:29.137]                           }
[10:18:29.137]                         })
[10:18:29.137]                       }
[10:18:29.137]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.137]                       base::options(mc.cores = 1L)
[10:18:29.137]                     }
[10:18:29.137]                     base::local({
[10:18:29.137]                       for (pkg in "stats") {
[10:18:29.137]                         base::loadNamespace(pkg)
[10:18:29.137]                         base::library(pkg, character.only = TRUE)
[10:18:29.137]                       }
[10:18:29.137]                     })
[10:18:29.137]                   }
[10:18:29.137]                   ...future.strategy.old <- future::plan("list")
[10:18:29.137]                   options(future.plan = NULL)
[10:18:29.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.137]                 }
[10:18:29.137]                 ...future.workdir <- getwd()
[10:18:29.137]             }
[10:18:29.137]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.137]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.137]         }
[10:18:29.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.137]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.137]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.137]             base::names(...future.oldOptions))
[10:18:29.137]     }
[10:18:29.137]     if (FALSE) {
[10:18:29.137]     }
[10:18:29.137]     else {
[10:18:29.137]         if (TRUE) {
[10:18:29.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.137]                 open = "w")
[10:18:29.137]         }
[10:18:29.137]         else {
[10:18:29.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.137]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.137]         }
[10:18:29.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.137]             base::sink(type = "output", split = FALSE)
[10:18:29.137]             base::close(...future.stdout)
[10:18:29.137]         }, add = TRUE)
[10:18:29.137]     }
[10:18:29.137]     ...future.frame <- base::sys.nframe()
[10:18:29.137]     ...future.conditions <- base::list()
[10:18:29.137]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.137]     if (FALSE) {
[10:18:29.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.137]     }
[10:18:29.137]     ...future.result <- base::tryCatch({
[10:18:29.137]         base::withCallingHandlers({
[10:18:29.137]             ...future.value <- base::withVisible(base::local({
[10:18:29.137]                 ...future.makeSendCondition <- base::local({
[10:18:29.137]                   sendCondition <- NULL
[10:18:29.137]                   function(frame = 1L) {
[10:18:29.137]                     if (is.function(sendCondition)) 
[10:18:29.137]                       return(sendCondition)
[10:18:29.137]                     ns <- getNamespace("parallel")
[10:18:29.137]                     if (exists("sendData", mode = "function", 
[10:18:29.137]                       envir = ns)) {
[10:18:29.137]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.137]                         envir = ns)
[10:18:29.137]                       envir <- sys.frame(frame)
[10:18:29.137]                       master <- NULL
[10:18:29.137]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.137]                         !identical(envir, emptyenv())) {
[10:18:29.137]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.137]                           inherits = FALSE)) {
[10:18:29.137]                           master <- get("master", mode = "list", 
[10:18:29.137]                             envir = envir, inherits = FALSE)
[10:18:29.137]                           if (inherits(master, c("SOCKnode", 
[10:18:29.137]                             "SOCK0node"))) {
[10:18:29.137]                             sendCondition <<- function(cond) {
[10:18:29.137]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.137]                                 success = TRUE)
[10:18:29.137]                               parallel_sendData(master, data)
[10:18:29.137]                             }
[10:18:29.137]                             return(sendCondition)
[10:18:29.137]                           }
[10:18:29.137]                         }
[10:18:29.137]                         frame <- frame + 1L
[10:18:29.137]                         envir <- sys.frame(frame)
[10:18:29.137]                       }
[10:18:29.137]                     }
[10:18:29.137]                     sendCondition <<- function(cond) NULL
[10:18:29.137]                   }
[10:18:29.137]                 })
[10:18:29.137]                 withCallingHandlers({
[10:18:29.137]                   {
[10:18:29.137]                     do.call(function(...) {
[10:18:29.137]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.137]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.137]                         ...future.globals.maxSize)) {
[10:18:29.137]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.137]                         on.exit(options(oopts), add = TRUE)
[10:18:29.137]                       }
[10:18:29.137]                       {
[10:18:29.137]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.137]                           FUN = function(jj) {
[10:18:29.137]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.137]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.137]                           })
[10:18:29.137]                       }
[10:18:29.137]                     }, args = future.call.arguments)
[10:18:29.137]                   }
[10:18:29.137]                 }, immediateCondition = function(cond) {
[10:18:29.137]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.137]                   sendCondition(cond)
[10:18:29.137]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.137]                   {
[10:18:29.137]                     inherits <- base::inherits
[10:18:29.137]                     invokeRestart <- base::invokeRestart
[10:18:29.137]                     is.null <- base::is.null
[10:18:29.137]                     muffled <- FALSE
[10:18:29.137]                     if (inherits(cond, "message")) {
[10:18:29.137]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.137]                       if (muffled) 
[10:18:29.137]                         invokeRestart("muffleMessage")
[10:18:29.137]                     }
[10:18:29.137]                     else if (inherits(cond, "warning")) {
[10:18:29.137]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.137]                       if (muffled) 
[10:18:29.137]                         invokeRestart("muffleWarning")
[10:18:29.137]                     }
[10:18:29.137]                     else if (inherits(cond, "condition")) {
[10:18:29.137]                       if (!is.null(pattern)) {
[10:18:29.137]                         computeRestarts <- base::computeRestarts
[10:18:29.137]                         grepl <- base::grepl
[10:18:29.137]                         restarts <- computeRestarts(cond)
[10:18:29.137]                         for (restart in restarts) {
[10:18:29.137]                           name <- restart$name
[10:18:29.137]                           if (is.null(name)) 
[10:18:29.137]                             next
[10:18:29.137]                           if (!grepl(pattern, name)) 
[10:18:29.137]                             next
[10:18:29.137]                           invokeRestart(restart)
[10:18:29.137]                           muffled <- TRUE
[10:18:29.137]                           break
[10:18:29.137]                         }
[10:18:29.137]                       }
[10:18:29.137]                     }
[10:18:29.137]                     invisible(muffled)
[10:18:29.137]                   }
[10:18:29.137]                   muffleCondition(cond)
[10:18:29.137]                 })
[10:18:29.137]             }))
[10:18:29.137]             future::FutureResult(value = ...future.value$value, 
[10:18:29.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.137]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.137]                     ...future.globalenv.names))
[10:18:29.137]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.137]         }, condition = base::local({
[10:18:29.137]             c <- base::c
[10:18:29.137]             inherits <- base::inherits
[10:18:29.137]             invokeRestart <- base::invokeRestart
[10:18:29.137]             length <- base::length
[10:18:29.137]             list <- base::list
[10:18:29.137]             seq.int <- base::seq.int
[10:18:29.137]             signalCondition <- base::signalCondition
[10:18:29.137]             sys.calls <- base::sys.calls
[10:18:29.137]             `[[` <- base::`[[`
[10:18:29.137]             `+` <- base::`+`
[10:18:29.137]             `<<-` <- base::`<<-`
[10:18:29.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.137]                   3L)]
[10:18:29.137]             }
[10:18:29.137]             function(cond) {
[10:18:29.137]                 is_error <- inherits(cond, "error")
[10:18:29.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.137]                   NULL)
[10:18:29.137]                 if (is_error) {
[10:18:29.137]                   sessionInformation <- function() {
[10:18:29.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.137]                       search = base::search(), system = base::Sys.info())
[10:18:29.137]                   }
[10:18:29.137]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.137]                     cond$call), session = sessionInformation(), 
[10:18:29.137]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.137]                   signalCondition(cond)
[10:18:29.137]                 }
[10:18:29.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.137]                 "immediateCondition"))) {
[10:18:29.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.137]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.137]                   if (TRUE && !signal) {
[10:18:29.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.137]                     {
[10:18:29.137]                       inherits <- base::inherits
[10:18:29.137]                       invokeRestart <- base::invokeRestart
[10:18:29.137]                       is.null <- base::is.null
[10:18:29.137]                       muffled <- FALSE
[10:18:29.137]                       if (inherits(cond, "message")) {
[10:18:29.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.137]                         if (muffled) 
[10:18:29.137]                           invokeRestart("muffleMessage")
[10:18:29.137]                       }
[10:18:29.137]                       else if (inherits(cond, "warning")) {
[10:18:29.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.137]                         if (muffled) 
[10:18:29.137]                           invokeRestart("muffleWarning")
[10:18:29.137]                       }
[10:18:29.137]                       else if (inherits(cond, "condition")) {
[10:18:29.137]                         if (!is.null(pattern)) {
[10:18:29.137]                           computeRestarts <- base::computeRestarts
[10:18:29.137]                           grepl <- base::grepl
[10:18:29.137]                           restarts <- computeRestarts(cond)
[10:18:29.137]                           for (restart in restarts) {
[10:18:29.137]                             name <- restart$name
[10:18:29.137]                             if (is.null(name)) 
[10:18:29.137]                               next
[10:18:29.137]                             if (!grepl(pattern, name)) 
[10:18:29.137]                               next
[10:18:29.137]                             invokeRestart(restart)
[10:18:29.137]                             muffled <- TRUE
[10:18:29.137]                             break
[10:18:29.137]                           }
[10:18:29.137]                         }
[10:18:29.137]                       }
[10:18:29.137]                       invisible(muffled)
[10:18:29.137]                     }
[10:18:29.137]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.137]                   }
[10:18:29.137]                 }
[10:18:29.137]                 else {
[10:18:29.137]                   if (TRUE) {
[10:18:29.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.137]                     {
[10:18:29.137]                       inherits <- base::inherits
[10:18:29.137]                       invokeRestart <- base::invokeRestart
[10:18:29.137]                       is.null <- base::is.null
[10:18:29.137]                       muffled <- FALSE
[10:18:29.137]                       if (inherits(cond, "message")) {
[10:18:29.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.137]                         if (muffled) 
[10:18:29.137]                           invokeRestart("muffleMessage")
[10:18:29.137]                       }
[10:18:29.137]                       else if (inherits(cond, "warning")) {
[10:18:29.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.137]                         if (muffled) 
[10:18:29.137]                           invokeRestart("muffleWarning")
[10:18:29.137]                       }
[10:18:29.137]                       else if (inherits(cond, "condition")) {
[10:18:29.137]                         if (!is.null(pattern)) {
[10:18:29.137]                           computeRestarts <- base::computeRestarts
[10:18:29.137]                           grepl <- base::grepl
[10:18:29.137]                           restarts <- computeRestarts(cond)
[10:18:29.137]                           for (restart in restarts) {
[10:18:29.137]                             name <- restart$name
[10:18:29.137]                             if (is.null(name)) 
[10:18:29.137]                               next
[10:18:29.137]                             if (!grepl(pattern, name)) 
[10:18:29.137]                               next
[10:18:29.137]                             invokeRestart(restart)
[10:18:29.137]                             muffled <- TRUE
[10:18:29.137]                             break
[10:18:29.137]                           }
[10:18:29.137]                         }
[10:18:29.137]                       }
[10:18:29.137]                       invisible(muffled)
[10:18:29.137]                     }
[10:18:29.137]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.137]                   }
[10:18:29.137]                 }
[10:18:29.137]             }
[10:18:29.137]         }))
[10:18:29.137]     }, error = function(ex) {
[10:18:29.137]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.137]                 ...future.rng), started = ...future.startTime, 
[10:18:29.137]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.137]             version = "1.8"), class = "FutureResult")
[10:18:29.137]     }, finally = {
[10:18:29.137]         if (!identical(...future.workdir, getwd())) 
[10:18:29.137]             setwd(...future.workdir)
[10:18:29.137]         {
[10:18:29.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.137]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.137]             }
[10:18:29.137]             base::options(...future.oldOptions)
[10:18:29.137]             if (.Platform$OS.type == "windows") {
[10:18:29.137]                 old_names <- names(...future.oldEnvVars)
[10:18:29.137]                 envs <- base::Sys.getenv()
[10:18:29.137]                 names <- names(envs)
[10:18:29.137]                 common <- intersect(names, old_names)
[10:18:29.137]                 added <- setdiff(names, old_names)
[10:18:29.137]                 removed <- setdiff(old_names, names)
[10:18:29.137]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.137]                   envs[common]]
[10:18:29.137]                 NAMES <- toupper(changed)
[10:18:29.137]                 args <- list()
[10:18:29.137]                 for (kk in seq_along(NAMES)) {
[10:18:29.137]                   name <- changed[[kk]]
[10:18:29.137]                   NAME <- NAMES[[kk]]
[10:18:29.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.137]                     next
[10:18:29.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.137]                 }
[10:18:29.137]                 NAMES <- toupper(added)
[10:18:29.137]                 for (kk in seq_along(NAMES)) {
[10:18:29.137]                   name <- added[[kk]]
[10:18:29.137]                   NAME <- NAMES[[kk]]
[10:18:29.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.137]                     next
[10:18:29.137]                   args[[name]] <- ""
[10:18:29.137]                 }
[10:18:29.137]                 NAMES <- toupper(removed)
[10:18:29.137]                 for (kk in seq_along(NAMES)) {
[10:18:29.137]                   name <- removed[[kk]]
[10:18:29.137]                   NAME <- NAMES[[kk]]
[10:18:29.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.137]                     next
[10:18:29.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.137]                 }
[10:18:29.137]                 if (length(args) > 0) 
[10:18:29.137]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.137]             }
[10:18:29.137]             else {
[10:18:29.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.137]             }
[10:18:29.137]             {
[10:18:29.137]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.137]                   0L) {
[10:18:29.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.137]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.137]                   base::options(opts)
[10:18:29.137]                 }
[10:18:29.137]                 {
[10:18:29.137]                   {
[10:18:29.137]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.137]                     NULL
[10:18:29.137]                   }
[10:18:29.137]                   options(future.plan = NULL)
[10:18:29.137]                   if (is.na(NA_character_)) 
[10:18:29.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.137]                     .init = FALSE)
[10:18:29.137]                 }
[10:18:29.137]             }
[10:18:29.137]         }
[10:18:29.137]     })
[10:18:29.137]     if (TRUE) {
[10:18:29.137]         base::sink(type = "output", split = FALSE)
[10:18:29.137]         if (TRUE) {
[10:18:29.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.137]         }
[10:18:29.137]         else {
[10:18:29.137]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.137]         }
[10:18:29.137]         base::close(...future.stdout)
[10:18:29.137]         ...future.stdout <- NULL
[10:18:29.137]     }
[10:18:29.137]     ...future.result$conditions <- ...future.conditions
[10:18:29.137]     ...future.result$finished <- base::Sys.time()
[10:18:29.137]     ...future.result
[10:18:29.137] }
[10:18:29.141] Exporting 5 global objects (0.98 KiB) to cluster node #1 ...
[10:18:29.141] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:29.141] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:29.141] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ...
[10:18:29.142] Exporting ‘...future.FUN’ (311 bytes) to cluster node #1 ... DONE
[10:18:29.142] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ...
[10:18:29.142] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #1 ... DONE
[10:18:29.142] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:29.143] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:29.143] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:29.143] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:29.144] Exporting 5 global objects (0.98 KiB) to cluster node #1 ... DONE
[10:18:29.144] MultisessionFuture started
[10:18:29.144] - Launch lazy future ... done
[10:18:29.144] run() for ‘MultisessionFuture’ ... done
[10:18:29.144] Created future:
[10:18:29.145] MultisessionFuture:
[10:18:29.145] Label: ‘future_apply-1’
[10:18:29.145] Expression:
[10:18:29.145] {
[10:18:29.145]     do.call(function(...) {
[10:18:29.145]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.145]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.145]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.145]             on.exit(options(oopts), add = TRUE)
[10:18:29.145]         }
[10:18:29.145]         {
[10:18:29.145]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.145]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.145]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.145]             })
[10:18:29.145]         }
[10:18:29.145]     }, args = future.call.arguments)
[10:18:29.145] }
[10:18:29.145] Lazy evaluation: FALSE
[10:18:29.145] Asynchronous evaluation: TRUE
[10:18:29.145] Local evaluation: TRUE
[10:18:29.145] Environment: R_GlobalEnv
[10:18:29.145] Capture standard output: TRUE
[10:18:29.145] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.145] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.145] Packages: 1 packages (‘stats’)
[10:18:29.145] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.145] Resolved: FALSE
[10:18:29.145] Value: <not collected>
[10:18:29.145] Conditions captured: <none>
[10:18:29.145] Early signaling: FALSE
[10:18:29.145] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.145] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.158] Chunk #1 of 2 ... DONE
[10:18:29.158] Chunk #2 of 2 ...
[10:18:29.158]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.158]  - seeds: <none>
[10:18:29.159]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.159] getGlobalsAndPackages() ...
[10:18:29.159] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.159] Resolving globals: FALSE
[10:18:29.159] Tweak future expression to call with '...' arguments ...
[10:18:29.159] {
[10:18:29.159]     do.call(function(...) {
[10:18:29.159]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.159]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.159]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.159]             on.exit(options(oopts), add = TRUE)
[10:18:29.159]         }
[10:18:29.159]         {
[10:18:29.159]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.159]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.159]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.159]             })
[10:18:29.159]         }
[10:18:29.159]     }, args = future.call.arguments)
[10:18:29.159] }
[10:18:29.159] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.160] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.160] - packages: [1] ‘stats’
[10:18:29.160] getGlobalsAndPackages() ... DONE
[10:18:29.160] run() for ‘Future’ ...
[10:18:29.160] - state: ‘created’
[10:18:29.161] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.175] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.175] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.175]   - Field: ‘node’
[10:18:29.175]   - Field: ‘label’
[10:18:29.175]   - Field: ‘local’
[10:18:29.176]   - Field: ‘owner’
[10:18:29.176]   - Field: ‘envir’
[10:18:29.176]   - Field: ‘workers’
[10:18:29.176]   - Field: ‘packages’
[10:18:29.176]   - Field: ‘gc’
[10:18:29.176]   - Field: ‘conditions’
[10:18:29.176]   - Field: ‘persistent’
[10:18:29.176]   - Field: ‘expr’
[10:18:29.176]   - Field: ‘uuid’
[10:18:29.176]   - Field: ‘seed’
[10:18:29.176]   - Field: ‘version’
[10:18:29.177]   - Field: ‘result’
[10:18:29.177]   - Field: ‘asynchronous’
[10:18:29.177]   - Field: ‘calls’
[10:18:29.177]   - Field: ‘globals’
[10:18:29.177]   - Field: ‘stdout’
[10:18:29.177]   - Field: ‘earlySignal’
[10:18:29.177]   - Field: ‘lazy’
[10:18:29.177]   - Field: ‘state’
[10:18:29.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.177] - Launch lazy future ...
[10:18:29.178] Packages needed by the future expression (n = 1): ‘stats’
[10:18:29.178] Packages needed by future strategies (n = 0): <none>
[10:18:29.178] {
[10:18:29.178]     {
[10:18:29.178]         {
[10:18:29.178]             ...future.startTime <- base::Sys.time()
[10:18:29.178]             {
[10:18:29.178]                 {
[10:18:29.178]                   {
[10:18:29.178]                     {
[10:18:29.178]                       {
[10:18:29.178]                         base::local({
[10:18:29.178]                           has_future <- base::requireNamespace("future", 
[10:18:29.178]                             quietly = TRUE)
[10:18:29.178]                           if (has_future) {
[10:18:29.178]                             ns <- base::getNamespace("future")
[10:18:29.178]                             version <- ns[[".package"]][["version"]]
[10:18:29.178]                             if (is.null(version)) 
[10:18:29.178]                               version <- utils::packageVersion("future")
[10:18:29.178]                           }
[10:18:29.178]                           else {
[10:18:29.178]                             version <- NULL
[10:18:29.178]                           }
[10:18:29.178]                           if (!has_future || version < "1.8.0") {
[10:18:29.178]                             info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.178]                               "", base::R.version$version.string), 
[10:18:29.178]                               platform = base::sprintf("%s (%s-bit)", 
[10:18:29.178]                                 base::R.version$platform, 8 * 
[10:18:29.178]                                   base::.Machine$sizeof.pointer), 
[10:18:29.178]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.178]                                 "release", "version")], collapse = " "), 
[10:18:29.178]                               hostname = base::Sys.info()[["nodename"]])
[10:18:29.178]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.178]                               info)
[10:18:29.178]                             info <- base::paste(info, collapse = "; ")
[10:18:29.178]                             if (!has_future) {
[10:18:29.178]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.178]                                 info)
[10:18:29.178]                             }
[10:18:29.178]                             else {
[10:18:29.178]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.178]                                 info, version)
[10:18:29.178]                             }
[10:18:29.178]                             base::stop(msg)
[10:18:29.178]                           }
[10:18:29.178]                         })
[10:18:29.178]                       }
[10:18:29.178]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.178]                       base::options(mc.cores = 1L)
[10:18:29.178]                     }
[10:18:29.178]                     base::local({
[10:18:29.178]                       for (pkg in "stats") {
[10:18:29.178]                         base::loadNamespace(pkg)
[10:18:29.178]                         base::library(pkg, character.only = TRUE)
[10:18:29.178]                       }
[10:18:29.178]                     })
[10:18:29.178]                   }
[10:18:29.178]                   ...future.strategy.old <- future::plan("list")
[10:18:29.178]                   options(future.plan = NULL)
[10:18:29.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.178]                 }
[10:18:29.178]                 ...future.workdir <- getwd()
[10:18:29.178]             }
[10:18:29.178]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.178]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.178]         }
[10:18:29.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.178]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.178]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.178]             base::names(...future.oldOptions))
[10:18:29.178]     }
[10:18:29.178]     if (FALSE) {
[10:18:29.178]     }
[10:18:29.178]     else {
[10:18:29.178]         if (TRUE) {
[10:18:29.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.178]                 open = "w")
[10:18:29.178]         }
[10:18:29.178]         else {
[10:18:29.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.178]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.178]         }
[10:18:29.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.178]             base::sink(type = "output", split = FALSE)
[10:18:29.178]             base::close(...future.stdout)
[10:18:29.178]         }, add = TRUE)
[10:18:29.178]     }
[10:18:29.178]     ...future.frame <- base::sys.nframe()
[10:18:29.178]     ...future.conditions <- base::list()
[10:18:29.178]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.178]     if (FALSE) {
[10:18:29.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.178]     }
[10:18:29.178]     ...future.result <- base::tryCatch({
[10:18:29.178]         base::withCallingHandlers({
[10:18:29.178]             ...future.value <- base::withVisible(base::local({
[10:18:29.178]                 ...future.makeSendCondition <- base::local({
[10:18:29.178]                   sendCondition <- NULL
[10:18:29.178]                   function(frame = 1L) {
[10:18:29.178]                     if (is.function(sendCondition)) 
[10:18:29.178]                       return(sendCondition)
[10:18:29.178]                     ns <- getNamespace("parallel")
[10:18:29.178]                     if (exists("sendData", mode = "function", 
[10:18:29.178]                       envir = ns)) {
[10:18:29.178]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.178]                         envir = ns)
[10:18:29.178]                       envir <- sys.frame(frame)
[10:18:29.178]                       master <- NULL
[10:18:29.178]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.178]                         !identical(envir, emptyenv())) {
[10:18:29.178]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.178]                           inherits = FALSE)) {
[10:18:29.178]                           master <- get("master", mode = "list", 
[10:18:29.178]                             envir = envir, inherits = FALSE)
[10:18:29.178]                           if (inherits(master, c("SOCKnode", 
[10:18:29.178]                             "SOCK0node"))) {
[10:18:29.178]                             sendCondition <<- function(cond) {
[10:18:29.178]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.178]                                 success = TRUE)
[10:18:29.178]                               parallel_sendData(master, data)
[10:18:29.178]                             }
[10:18:29.178]                             return(sendCondition)
[10:18:29.178]                           }
[10:18:29.178]                         }
[10:18:29.178]                         frame <- frame + 1L
[10:18:29.178]                         envir <- sys.frame(frame)
[10:18:29.178]                       }
[10:18:29.178]                     }
[10:18:29.178]                     sendCondition <<- function(cond) NULL
[10:18:29.178]                   }
[10:18:29.178]                 })
[10:18:29.178]                 withCallingHandlers({
[10:18:29.178]                   {
[10:18:29.178]                     do.call(function(...) {
[10:18:29.178]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.178]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.178]                         ...future.globals.maxSize)) {
[10:18:29.178]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.178]                         on.exit(options(oopts), add = TRUE)
[10:18:29.178]                       }
[10:18:29.178]                       {
[10:18:29.178]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.178]                           FUN = function(jj) {
[10:18:29.178]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.178]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.178]                           })
[10:18:29.178]                       }
[10:18:29.178]                     }, args = future.call.arguments)
[10:18:29.178]                   }
[10:18:29.178]                 }, immediateCondition = function(cond) {
[10:18:29.178]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.178]                   sendCondition(cond)
[10:18:29.178]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.178]                   {
[10:18:29.178]                     inherits <- base::inherits
[10:18:29.178]                     invokeRestart <- base::invokeRestart
[10:18:29.178]                     is.null <- base::is.null
[10:18:29.178]                     muffled <- FALSE
[10:18:29.178]                     if (inherits(cond, "message")) {
[10:18:29.178]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.178]                       if (muffled) 
[10:18:29.178]                         invokeRestart("muffleMessage")
[10:18:29.178]                     }
[10:18:29.178]                     else if (inherits(cond, "warning")) {
[10:18:29.178]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.178]                       if (muffled) 
[10:18:29.178]                         invokeRestart("muffleWarning")
[10:18:29.178]                     }
[10:18:29.178]                     else if (inherits(cond, "condition")) {
[10:18:29.178]                       if (!is.null(pattern)) {
[10:18:29.178]                         computeRestarts <- base::computeRestarts
[10:18:29.178]                         grepl <- base::grepl
[10:18:29.178]                         restarts <- computeRestarts(cond)
[10:18:29.178]                         for (restart in restarts) {
[10:18:29.178]                           name <- restart$name
[10:18:29.178]                           if (is.null(name)) 
[10:18:29.178]                             next
[10:18:29.178]                           if (!grepl(pattern, name)) 
[10:18:29.178]                             next
[10:18:29.178]                           invokeRestart(restart)
[10:18:29.178]                           muffled <- TRUE
[10:18:29.178]                           break
[10:18:29.178]                         }
[10:18:29.178]                       }
[10:18:29.178]                     }
[10:18:29.178]                     invisible(muffled)
[10:18:29.178]                   }
[10:18:29.178]                   muffleCondition(cond)
[10:18:29.178]                 })
[10:18:29.178]             }))
[10:18:29.178]             future::FutureResult(value = ...future.value$value, 
[10:18:29.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.178]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.178]                     ...future.globalenv.names))
[10:18:29.178]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.178]         }, condition = base::local({
[10:18:29.178]             c <- base::c
[10:18:29.178]             inherits <- base::inherits
[10:18:29.178]             invokeRestart <- base::invokeRestart
[10:18:29.178]             length <- base::length
[10:18:29.178]             list <- base::list
[10:18:29.178]             seq.int <- base::seq.int
[10:18:29.178]             signalCondition <- base::signalCondition
[10:18:29.178]             sys.calls <- base::sys.calls
[10:18:29.178]             `[[` <- base::`[[`
[10:18:29.178]             `+` <- base::`+`
[10:18:29.178]             `<<-` <- base::`<<-`
[10:18:29.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.178]                   3L)]
[10:18:29.178]             }
[10:18:29.178]             function(cond) {
[10:18:29.178]                 is_error <- inherits(cond, "error")
[10:18:29.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.178]                   NULL)
[10:18:29.178]                 if (is_error) {
[10:18:29.178]                   sessionInformation <- function() {
[10:18:29.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.178]                       search = base::search(), system = base::Sys.info())
[10:18:29.178]                   }
[10:18:29.178]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.178]                     cond$call), session = sessionInformation(), 
[10:18:29.178]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.178]                   signalCondition(cond)
[10:18:29.178]                 }
[10:18:29.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.178]                 "immediateCondition"))) {
[10:18:29.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.178]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.178]                   if (TRUE && !signal) {
[10:18:29.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.178]                     {
[10:18:29.178]                       inherits <- base::inherits
[10:18:29.178]                       invokeRestart <- base::invokeRestart
[10:18:29.178]                       is.null <- base::is.null
[10:18:29.178]                       muffled <- FALSE
[10:18:29.178]                       if (inherits(cond, "message")) {
[10:18:29.178]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.178]                         if (muffled) 
[10:18:29.178]                           invokeRestart("muffleMessage")
[10:18:29.178]                       }
[10:18:29.178]                       else if (inherits(cond, "warning")) {
[10:18:29.178]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.178]                         if (muffled) 
[10:18:29.178]                           invokeRestart("muffleWarning")
[10:18:29.178]                       }
[10:18:29.178]                       else if (inherits(cond, "condition")) {
[10:18:29.178]                         if (!is.null(pattern)) {
[10:18:29.178]                           computeRestarts <- base::computeRestarts
[10:18:29.178]                           grepl <- base::grepl
[10:18:29.178]                           restarts <- computeRestarts(cond)
[10:18:29.178]                           for (restart in restarts) {
[10:18:29.178]                             name <- restart$name
[10:18:29.178]                             if (is.null(name)) 
[10:18:29.178]                               next
[10:18:29.178]                             if (!grepl(pattern, name)) 
[10:18:29.178]                               next
[10:18:29.178]                             invokeRestart(restart)
[10:18:29.178]                             muffled <- TRUE
[10:18:29.178]                             break
[10:18:29.178]                           }
[10:18:29.178]                         }
[10:18:29.178]                       }
[10:18:29.178]                       invisible(muffled)
[10:18:29.178]                     }
[10:18:29.178]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.178]                   }
[10:18:29.178]                 }
[10:18:29.178]                 else {
[10:18:29.178]                   if (TRUE) {
[10:18:29.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.178]                     {
[10:18:29.178]                       inherits <- base::inherits
[10:18:29.178]                       invokeRestart <- base::invokeRestart
[10:18:29.178]                       is.null <- base::is.null
[10:18:29.178]                       muffled <- FALSE
[10:18:29.178]                       if (inherits(cond, "message")) {
[10:18:29.178]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.178]                         if (muffled) 
[10:18:29.178]                           invokeRestart("muffleMessage")
[10:18:29.178]                       }
[10:18:29.178]                       else if (inherits(cond, "warning")) {
[10:18:29.178]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.178]                         if (muffled) 
[10:18:29.178]                           invokeRestart("muffleWarning")
[10:18:29.178]                       }
[10:18:29.178]                       else if (inherits(cond, "condition")) {
[10:18:29.178]                         if (!is.null(pattern)) {
[10:18:29.178]                           computeRestarts <- base::computeRestarts
[10:18:29.178]                           grepl <- base::grepl
[10:18:29.178]                           restarts <- computeRestarts(cond)
[10:18:29.178]                           for (restart in restarts) {
[10:18:29.178]                             name <- restart$name
[10:18:29.178]                             if (is.null(name)) 
[10:18:29.178]                               next
[10:18:29.178]                             if (!grepl(pattern, name)) 
[10:18:29.178]                               next
[10:18:29.178]                             invokeRestart(restart)
[10:18:29.178]                             muffled <- TRUE
[10:18:29.178]                             break
[10:18:29.178]                           }
[10:18:29.178]                         }
[10:18:29.178]                       }
[10:18:29.178]                       invisible(muffled)
[10:18:29.178]                     }
[10:18:29.178]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.178]                   }
[10:18:29.178]                 }
[10:18:29.178]             }
[10:18:29.178]         }))
[10:18:29.178]     }, error = function(ex) {
[10:18:29.178]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.178]                 ...future.rng), started = ...future.startTime, 
[10:18:29.178]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.178]             version = "1.8"), class = "FutureResult")
[10:18:29.178]     }, finally = {
[10:18:29.178]         if (!identical(...future.workdir, getwd())) 
[10:18:29.178]             setwd(...future.workdir)
[10:18:29.178]         {
[10:18:29.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.178]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.178]             }
[10:18:29.178]             base::options(...future.oldOptions)
[10:18:29.178]             if (.Platform$OS.type == "windows") {
[10:18:29.178]                 old_names <- names(...future.oldEnvVars)
[10:18:29.178]                 envs <- base::Sys.getenv()
[10:18:29.178]                 names <- names(envs)
[10:18:29.178]                 common <- intersect(names, old_names)
[10:18:29.178]                 added <- setdiff(names, old_names)
[10:18:29.178]                 removed <- setdiff(old_names, names)
[10:18:29.178]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.178]                   envs[common]]
[10:18:29.178]                 NAMES <- toupper(changed)
[10:18:29.178]                 args <- list()
[10:18:29.178]                 for (kk in seq_along(NAMES)) {
[10:18:29.178]                   name <- changed[[kk]]
[10:18:29.178]                   NAME <- NAMES[[kk]]
[10:18:29.178]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.178]                     next
[10:18:29.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.178]                 }
[10:18:29.178]                 NAMES <- toupper(added)
[10:18:29.178]                 for (kk in seq_along(NAMES)) {
[10:18:29.178]                   name <- added[[kk]]
[10:18:29.178]                   NAME <- NAMES[[kk]]
[10:18:29.178]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.178]                     next
[10:18:29.178]                   args[[name]] <- ""
[10:18:29.178]                 }
[10:18:29.178]                 NAMES <- toupper(removed)
[10:18:29.178]                 for (kk in seq_along(NAMES)) {
[10:18:29.178]                   name <- removed[[kk]]
[10:18:29.178]                   NAME <- NAMES[[kk]]
[10:18:29.178]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.178]                     next
[10:18:29.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.178]                 }
[10:18:29.178]                 if (length(args) > 0) 
[10:18:29.178]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.178]             }
[10:18:29.178]             else {
[10:18:29.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.178]             }
[10:18:29.178]             {
[10:18:29.178]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.178]                   0L) {
[10:18:29.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.178]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.178]                   base::options(opts)
[10:18:29.178]                 }
[10:18:29.178]                 {
[10:18:29.178]                   {
[10:18:29.178]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.178]                     NULL
[10:18:29.178]                   }
[10:18:29.178]                   options(future.plan = NULL)
[10:18:29.178]                   if (is.na(NA_character_)) 
[10:18:29.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.178]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.178]                     .init = FALSE)
[10:18:29.178]                 }
[10:18:29.178]             }
[10:18:29.178]         }
[10:18:29.178]     })
[10:18:29.178]     if (TRUE) {
[10:18:29.178]         base::sink(type = "output", split = FALSE)
[10:18:29.178]         if (TRUE) {
[10:18:29.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.178]         }
[10:18:29.178]         else {
[10:18:29.178]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.178]         }
[10:18:29.178]         base::close(...future.stdout)
[10:18:29.178]         ...future.stdout <- NULL
[10:18:29.178]     }
[10:18:29.178]     ...future.result$conditions <- ...future.conditions
[10:18:29.178]     ...future.result$finished <- base::Sys.time()
[10:18:29.178]     ...future.result
[10:18:29.178] }
[10:18:29.181] Exporting 5 global objects (0.98 KiB) to cluster node #2 ...
[10:18:29.181] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:29.182] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:29.182] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ...
[10:18:29.182] Exporting ‘...future.FUN’ (311 bytes) to cluster node #2 ... DONE
[10:18:29.182] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ...
[10:18:29.183] Exporting ‘...future.elements_ii’ (71 bytes) to cluster node #2 ... DONE
[10:18:29.183] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:29.183] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:29.183] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:29.184] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:29.184] Exporting 5 global objects (0.98 KiB) to cluster node #2 ... DONE
[10:18:29.184] MultisessionFuture started
[10:18:29.185] - Launch lazy future ... done
[10:18:29.185] run() for ‘MultisessionFuture’ ... done
[10:18:29.185] Created future:
[10:18:29.185] MultisessionFuture:
[10:18:29.185] Label: ‘future_apply-2’
[10:18:29.185] Expression:
[10:18:29.185] {
[10:18:29.185]     do.call(function(...) {
[10:18:29.185]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.185]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.185]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.185]             on.exit(options(oopts), add = TRUE)
[10:18:29.185]         }
[10:18:29.185]         {
[10:18:29.185]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.185]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.185]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.185]             })
[10:18:29.185]         }
[10:18:29.185]     }, args = future.call.arguments)
[10:18:29.185] }
[10:18:29.185] Lazy evaluation: FALSE
[10:18:29.185] Asynchronous evaluation: TRUE
[10:18:29.185] Local evaluation: TRUE
[10:18:29.185] Environment: R_GlobalEnv
[10:18:29.185] Capture standard output: TRUE
[10:18:29.185] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.185] Globals: 5 objects totaling 545 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 311 bytes, list ‘...future.elements_ii’ of 71 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.185] Packages: 1 packages (‘stats’)
[10:18:29.185] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.185] Resolved: FALSE
[10:18:29.185] Value: <not collected>
[10:18:29.185] Conditions captured: <none>
[10:18:29.185] Early signaling: FALSE
[10:18:29.185] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.185] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.197] Chunk #2 of 2 ... DONE
[10:18:29.197] Launching 2 futures (chunks) ... DONE
[10:18:29.197] Resolving 2 futures (chunks) ...
[10:18:29.198] resolve() on list ...
[10:18:29.198]  recursive: 0
[10:18:29.198]  length: 2
[10:18:29.198] 
[10:18:29.198] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.199] - Validating connection of MultisessionFuture
[10:18:29.199] - received message: FutureResult
[10:18:29.199] - Received FutureResult
[10:18:29.199] - Erased future from FutureRegistry
[10:18:29.199] result() for ClusterFuture ...
[10:18:29.199] - result already collected: FutureResult
[10:18:29.199] result() for ClusterFuture ... done
[10:18:29.199] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.199] Future #1
[10:18:29.200] result() for ClusterFuture ...
[10:18:29.200] - result already collected: FutureResult
[10:18:29.200] result() for ClusterFuture ... done
[10:18:29.200] result() for ClusterFuture ...
[10:18:29.200] - result already collected: FutureResult
[10:18:29.200] result() for ClusterFuture ... done
[10:18:29.200] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:29.200] - nx: 2
[10:18:29.200] - relay: TRUE
[10:18:29.200] - stdout: TRUE
[10:18:29.200] - signal: TRUE
[10:18:29.200] - resignal: FALSE
[10:18:29.201] - force: TRUE
[10:18:29.201] - relayed: [n=2] FALSE, FALSE
[10:18:29.201] - queued futures: [n=2] FALSE, FALSE
[10:18:29.201]  - until=1
[10:18:29.201]  - relaying element #1
[10:18:29.201] result() for ClusterFuture ...
[10:18:29.201] - result already collected: FutureResult
[10:18:29.201] result() for ClusterFuture ... done
[10:18:29.201] result() for ClusterFuture ...
[10:18:29.201] - result already collected: FutureResult
[10:18:29.201] result() for ClusterFuture ... done
[10:18:29.201] result() for ClusterFuture ...
[10:18:29.202] - result already collected: FutureResult
[10:18:29.202] result() for ClusterFuture ... done
[10:18:29.202] result() for ClusterFuture ...
[10:18:29.202] - result already collected: FutureResult
[10:18:29.202] result() for ClusterFuture ... done
[10:18:29.202] - relayed: [n=2] TRUE, FALSE
[10:18:29.202] - queued futures: [n=2] TRUE, FALSE
[10:18:29.202] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:29.202]  length: 1 (resolved future 1)
[10:18:29.228] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.228] - Validating connection of MultisessionFuture
[10:18:29.228] - received message: FutureResult
[10:18:29.229] - Received FutureResult
[10:18:29.229] - Erased future from FutureRegistry
[10:18:29.229] result() for ClusterFuture ...
[10:18:29.229] - result already collected: FutureResult
[10:18:29.229] result() for ClusterFuture ... done
[10:18:29.229] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.229] Future #2
[10:18:29.229] result() for ClusterFuture ...
[10:18:29.229] - result already collected: FutureResult
[10:18:29.229] result() for ClusterFuture ... done
[10:18:29.230] result() for ClusterFuture ...
[10:18:29.230] - result already collected: FutureResult
[10:18:29.230] result() for ClusterFuture ... done
[10:18:29.230] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:29.230] - nx: 2
[10:18:29.230] - relay: TRUE
[10:18:29.230] - stdout: TRUE
[10:18:29.230] - signal: TRUE
[10:18:29.230] - resignal: FALSE
[10:18:29.230] - force: TRUE
[10:18:29.230] - relayed: [n=2] TRUE, FALSE
[10:18:29.230] - queued futures: [n=2] TRUE, FALSE
[10:18:29.231]  - until=2
[10:18:29.231]  - relaying element #2
[10:18:29.231] result() for ClusterFuture ...
[10:18:29.231] - result already collected: FutureResult
[10:18:29.231] result() for ClusterFuture ... done
[10:18:29.231] result() for ClusterFuture ...
[10:18:29.231] - result already collected: FutureResult
[10:18:29.231] result() for ClusterFuture ... done
[10:18:29.231] result() for ClusterFuture ...
[10:18:29.231] - result already collected: FutureResult
[10:18:29.231] result() for ClusterFuture ... done
[10:18:29.232] result() for ClusterFuture ...
[10:18:29.232] - result already collected: FutureResult
[10:18:29.232] result() for ClusterFuture ... done
[10:18:29.232] - relayed: [n=2] TRUE, TRUE
[10:18:29.232] - queued futures: [n=2] TRUE, TRUE
[10:18:29.232] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:29.232]  length: 0 (resolved future 2)
[10:18:29.232] Relaying remaining futures
[10:18:29.232] signalConditionsASAP(NULL, pos=0) ...
[10:18:29.232] - nx: 2
[10:18:29.232] - relay: TRUE
[10:18:29.233] - stdout: TRUE
[10:18:29.233] - signal: TRUE
[10:18:29.233] - resignal: FALSE
[10:18:29.233] - force: TRUE
[10:18:29.233] - relayed: [n=2] TRUE, TRUE
[10:18:29.233] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:29.233] - relayed: [n=2] TRUE, TRUE
[10:18:29.233] - queued futures: [n=2] TRUE, TRUE
[10:18:29.233] signalConditionsASAP(NULL, pos=0) ... done
[10:18:29.233] resolve() on list ... DONE
[10:18:29.233] result() for ClusterFuture ...
[10:18:29.233] - result already collected: FutureResult
[10:18:29.234] result() for ClusterFuture ... done
[10:18:29.234] result() for ClusterFuture ...
[10:18:29.234] - result already collected: FutureResult
[10:18:29.234] result() for ClusterFuture ... done
[10:18:29.234] result() for ClusterFuture ...
[10:18:29.234] - result already collected: FutureResult
[10:18:29.234] result() for ClusterFuture ... done
[10:18:29.234] result() for ClusterFuture ...
[10:18:29.234] - result already collected: FutureResult
[10:18:29.234] result() for ClusterFuture ... done
[10:18:29.234]  - Number of value chunks collected: 2
[10:18:29.235] Resolving 2 futures (chunks) ... DONE
[10:18:29.235] Reducing values from 2 chunks ...
[10:18:29.235]  - Number of values collected after concatenation: 2
[10:18:29.235]  - Number of values expected: 2
[10:18:29.235] Reducing values from 2 chunks ... DONE
[10:18:29.235] future_lapply() ... DONE
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
[10:18:29.235] getGlobalsAndPackagesXApply() ...
[10:18:29.236]  - future.globals: TRUE
[10:18:29.236] getGlobalsAndPackages() ...
[10:18:29.236] Searching for globals...
[10:18:29.237] - globals found: [1] ‘FUN’
[10:18:29.237] Searching for globals ... DONE
[10:18:29.237] Resolving globals: FALSE
[10:18:29.237] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:29.238] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5), dim = c(8L, 2L), dimnames = list(row = NULL, col = c("x1",; "x2"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:29.238] - globals: [1] ‘FUN’
[10:18:29.238] 
[10:18:29.238] getGlobalsAndPackages() ... DONE
[10:18:29.238]  - globals found/used: [n=1] ‘FUN’
[10:18:29.238]  - needed namespaces: [n=0] 
[10:18:29.238] Finding globals ... DONE
[10:18:29.239]  - use_args: TRUE
[10:18:29.239]  - Getting '...' globals ...
[10:18:29.239] resolve() on list ...
[10:18:29.239]  recursive: 0
[10:18:29.239]  length: 1
[10:18:29.239]  elements: ‘...’
[10:18:29.239]  length: 0 (resolved future 1)
[10:18:29.239] resolve() on list ... DONE
[10:18:29.239]    - '...' content: [n=0] 
[10:18:29.240] List of 1
[10:18:29.240]  $ ...: list()
[10:18:29.240]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.240]  - attr(*, "where")=List of 1
[10:18:29.240]   ..$ ...:<environment: 0x556e046a2f98> 
[10:18:29.240]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.240]  - attr(*, "resolved")= logi TRUE
[10:18:29.240]  - attr(*, "total_size")= num NA
[10:18:29.242]  - Getting '...' globals ... DONE
[10:18:29.242] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:29.242] List of 2
[10:18:29.242]  $ ...future.FUN:function (x)  
[10:18:29.242]  $ ...          : list()
[10:18:29.242]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.242]  - attr(*, "where")=List of 2
[10:18:29.242]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:29.242]   ..$ ...          :<environment: 0x556e046a2f98> 
[10:18:29.242]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.242]  - attr(*, "resolved")= logi FALSE
[10:18:29.242]  - attr(*, "total_size")= num 2624
[10:18:29.245] Packages to be attached in all futures: [n=0] 
[10:18:29.245] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.247] future_lapply() ...
[10:18:29.249] Number of chunks: 2
[10:18:29.249] getGlobalsAndPackagesXApply() ...
[10:18:29.249]  - future.globals: <name-value list> with names ‘list()’
[10:18:29.249]  - use_args: TRUE
[10:18:29.249] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:29.249] List of 2
[10:18:29.249]  $ ...          : list()
[10:18:29.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.249]  $ ...future.FUN:function (x)  
[10:18:29.249]  - attr(*, "where")=List of 2
[10:18:29.249]   ..$ ...          :<environment: 0x556e046a2f98> 
[10:18:29.249]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:29.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.249]  - attr(*, "resolved")= logi FALSE
[10:18:29.249]  - attr(*, "total_size")= num NA
[10:18:29.253] Packages to be attached in all futures: [n=0] 
[10:18:29.253] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.253] Number of futures (= number of chunks): 2
[10:18:29.253] Launching 2 futures (chunks) ...
[10:18:29.253] Chunk #1 of 2 ...
[10:18:29.253]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.254]  - seeds: <none>
[10:18:29.254]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.254] getGlobalsAndPackages() ...
[10:18:29.254] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.254] Resolving globals: FALSE
[10:18:29.254] Tweak future expression to call with '...' arguments ...
[10:18:29.254] {
[10:18:29.254]     do.call(function(...) {
[10:18:29.254]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.254]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.254]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.254]             on.exit(options(oopts), add = TRUE)
[10:18:29.254]         }
[10:18:29.254]         {
[10:18:29.254]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.254]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.254]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.254]             })
[10:18:29.254]         }
[10:18:29.254]     }, args = future.call.arguments)
[10:18:29.254] }
[10:18:29.254] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.255] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.255] 
[10:18:29.255] getGlobalsAndPackages() ... DONE
[10:18:29.255] run() for ‘Future’ ...
[10:18:29.255] - state: ‘created’
[10:18:29.256] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.270] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.270] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.270]   - Field: ‘node’
[10:18:29.270]   - Field: ‘label’
[10:18:29.270]   - Field: ‘local’
[10:18:29.270]   - Field: ‘owner’
[10:18:29.270]   - Field: ‘envir’
[10:18:29.270]   - Field: ‘workers’
[10:18:29.271]   - Field: ‘packages’
[10:18:29.271]   - Field: ‘gc’
[10:18:29.271]   - Field: ‘conditions’
[10:18:29.271]   - Field: ‘persistent’
[10:18:29.271]   - Field: ‘expr’
[10:18:29.271]   - Field: ‘uuid’
[10:18:29.271]   - Field: ‘seed’
[10:18:29.271]   - Field: ‘version’
[10:18:29.271]   - Field: ‘result’
[10:18:29.271]   - Field: ‘asynchronous’
[10:18:29.271]   - Field: ‘calls’
[10:18:29.271]   - Field: ‘globals’
[10:18:29.272]   - Field: ‘stdout’
[10:18:29.272]   - Field: ‘earlySignal’
[10:18:29.272]   - Field: ‘lazy’
[10:18:29.272]   - Field: ‘state’
[10:18:29.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.272] - Launch lazy future ...
[10:18:29.272] Packages needed by the future expression (n = 0): <none>
[10:18:29.272] Packages needed by future strategies (n = 0): <none>
[10:18:29.273] {
[10:18:29.273]     {
[10:18:29.273]         {
[10:18:29.273]             ...future.startTime <- base::Sys.time()
[10:18:29.273]             {
[10:18:29.273]                 {
[10:18:29.273]                   {
[10:18:29.273]                     {
[10:18:29.273]                       base::local({
[10:18:29.273]                         has_future <- base::requireNamespace("future", 
[10:18:29.273]                           quietly = TRUE)
[10:18:29.273]                         if (has_future) {
[10:18:29.273]                           ns <- base::getNamespace("future")
[10:18:29.273]                           version <- ns[[".package"]][["version"]]
[10:18:29.273]                           if (is.null(version)) 
[10:18:29.273]                             version <- utils::packageVersion("future")
[10:18:29.273]                         }
[10:18:29.273]                         else {
[10:18:29.273]                           version <- NULL
[10:18:29.273]                         }
[10:18:29.273]                         if (!has_future || version < "1.8.0") {
[10:18:29.273]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.273]                             "", base::R.version$version.string), 
[10:18:29.273]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.273]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.273]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.273]                               "release", "version")], collapse = " "), 
[10:18:29.273]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.273]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.273]                             info)
[10:18:29.273]                           info <- base::paste(info, collapse = "; ")
[10:18:29.273]                           if (!has_future) {
[10:18:29.273]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.273]                               info)
[10:18:29.273]                           }
[10:18:29.273]                           else {
[10:18:29.273]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.273]                               info, version)
[10:18:29.273]                           }
[10:18:29.273]                           base::stop(msg)
[10:18:29.273]                         }
[10:18:29.273]                       })
[10:18:29.273]                     }
[10:18:29.273]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.273]                     base::options(mc.cores = 1L)
[10:18:29.273]                   }
[10:18:29.273]                   ...future.strategy.old <- future::plan("list")
[10:18:29.273]                   options(future.plan = NULL)
[10:18:29.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.273]                 }
[10:18:29.273]                 ...future.workdir <- getwd()
[10:18:29.273]             }
[10:18:29.273]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.273]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.273]         }
[10:18:29.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.273]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.273]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.273]             base::names(...future.oldOptions))
[10:18:29.273]     }
[10:18:29.273]     if (FALSE) {
[10:18:29.273]     }
[10:18:29.273]     else {
[10:18:29.273]         if (TRUE) {
[10:18:29.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.273]                 open = "w")
[10:18:29.273]         }
[10:18:29.273]         else {
[10:18:29.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.273]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.273]         }
[10:18:29.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.273]             base::sink(type = "output", split = FALSE)
[10:18:29.273]             base::close(...future.stdout)
[10:18:29.273]         }, add = TRUE)
[10:18:29.273]     }
[10:18:29.273]     ...future.frame <- base::sys.nframe()
[10:18:29.273]     ...future.conditions <- base::list()
[10:18:29.273]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.273]     if (FALSE) {
[10:18:29.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.273]     }
[10:18:29.273]     ...future.result <- base::tryCatch({
[10:18:29.273]         base::withCallingHandlers({
[10:18:29.273]             ...future.value <- base::withVisible(base::local({
[10:18:29.273]                 ...future.makeSendCondition <- base::local({
[10:18:29.273]                   sendCondition <- NULL
[10:18:29.273]                   function(frame = 1L) {
[10:18:29.273]                     if (is.function(sendCondition)) 
[10:18:29.273]                       return(sendCondition)
[10:18:29.273]                     ns <- getNamespace("parallel")
[10:18:29.273]                     if (exists("sendData", mode = "function", 
[10:18:29.273]                       envir = ns)) {
[10:18:29.273]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.273]                         envir = ns)
[10:18:29.273]                       envir <- sys.frame(frame)
[10:18:29.273]                       master <- NULL
[10:18:29.273]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.273]                         !identical(envir, emptyenv())) {
[10:18:29.273]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.273]                           inherits = FALSE)) {
[10:18:29.273]                           master <- get("master", mode = "list", 
[10:18:29.273]                             envir = envir, inherits = FALSE)
[10:18:29.273]                           if (inherits(master, c("SOCKnode", 
[10:18:29.273]                             "SOCK0node"))) {
[10:18:29.273]                             sendCondition <<- function(cond) {
[10:18:29.273]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.273]                                 success = TRUE)
[10:18:29.273]                               parallel_sendData(master, data)
[10:18:29.273]                             }
[10:18:29.273]                             return(sendCondition)
[10:18:29.273]                           }
[10:18:29.273]                         }
[10:18:29.273]                         frame <- frame + 1L
[10:18:29.273]                         envir <- sys.frame(frame)
[10:18:29.273]                       }
[10:18:29.273]                     }
[10:18:29.273]                     sendCondition <<- function(cond) NULL
[10:18:29.273]                   }
[10:18:29.273]                 })
[10:18:29.273]                 withCallingHandlers({
[10:18:29.273]                   {
[10:18:29.273]                     do.call(function(...) {
[10:18:29.273]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.273]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.273]                         ...future.globals.maxSize)) {
[10:18:29.273]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.273]                         on.exit(options(oopts), add = TRUE)
[10:18:29.273]                       }
[10:18:29.273]                       {
[10:18:29.273]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.273]                           FUN = function(jj) {
[10:18:29.273]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.273]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.273]                           })
[10:18:29.273]                       }
[10:18:29.273]                     }, args = future.call.arguments)
[10:18:29.273]                   }
[10:18:29.273]                 }, immediateCondition = function(cond) {
[10:18:29.273]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.273]                   sendCondition(cond)
[10:18:29.273]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.273]                   {
[10:18:29.273]                     inherits <- base::inherits
[10:18:29.273]                     invokeRestart <- base::invokeRestart
[10:18:29.273]                     is.null <- base::is.null
[10:18:29.273]                     muffled <- FALSE
[10:18:29.273]                     if (inherits(cond, "message")) {
[10:18:29.273]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.273]                       if (muffled) 
[10:18:29.273]                         invokeRestart("muffleMessage")
[10:18:29.273]                     }
[10:18:29.273]                     else if (inherits(cond, "warning")) {
[10:18:29.273]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.273]                       if (muffled) 
[10:18:29.273]                         invokeRestart("muffleWarning")
[10:18:29.273]                     }
[10:18:29.273]                     else if (inherits(cond, "condition")) {
[10:18:29.273]                       if (!is.null(pattern)) {
[10:18:29.273]                         computeRestarts <- base::computeRestarts
[10:18:29.273]                         grepl <- base::grepl
[10:18:29.273]                         restarts <- computeRestarts(cond)
[10:18:29.273]                         for (restart in restarts) {
[10:18:29.273]                           name <- restart$name
[10:18:29.273]                           if (is.null(name)) 
[10:18:29.273]                             next
[10:18:29.273]                           if (!grepl(pattern, name)) 
[10:18:29.273]                             next
[10:18:29.273]                           invokeRestart(restart)
[10:18:29.273]                           muffled <- TRUE
[10:18:29.273]                           break
[10:18:29.273]                         }
[10:18:29.273]                       }
[10:18:29.273]                     }
[10:18:29.273]                     invisible(muffled)
[10:18:29.273]                   }
[10:18:29.273]                   muffleCondition(cond)
[10:18:29.273]                 })
[10:18:29.273]             }))
[10:18:29.273]             future::FutureResult(value = ...future.value$value, 
[10:18:29.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.273]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.273]                     ...future.globalenv.names))
[10:18:29.273]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.273]         }, condition = base::local({
[10:18:29.273]             c <- base::c
[10:18:29.273]             inherits <- base::inherits
[10:18:29.273]             invokeRestart <- base::invokeRestart
[10:18:29.273]             length <- base::length
[10:18:29.273]             list <- base::list
[10:18:29.273]             seq.int <- base::seq.int
[10:18:29.273]             signalCondition <- base::signalCondition
[10:18:29.273]             sys.calls <- base::sys.calls
[10:18:29.273]             `[[` <- base::`[[`
[10:18:29.273]             `+` <- base::`+`
[10:18:29.273]             `<<-` <- base::`<<-`
[10:18:29.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.273]                   3L)]
[10:18:29.273]             }
[10:18:29.273]             function(cond) {
[10:18:29.273]                 is_error <- inherits(cond, "error")
[10:18:29.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.273]                   NULL)
[10:18:29.273]                 if (is_error) {
[10:18:29.273]                   sessionInformation <- function() {
[10:18:29.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.273]                       search = base::search(), system = base::Sys.info())
[10:18:29.273]                   }
[10:18:29.273]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.273]                     cond$call), session = sessionInformation(), 
[10:18:29.273]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.273]                   signalCondition(cond)
[10:18:29.273]                 }
[10:18:29.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.273]                 "immediateCondition"))) {
[10:18:29.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.273]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.273]                   if (TRUE && !signal) {
[10:18:29.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.273]                     {
[10:18:29.273]                       inherits <- base::inherits
[10:18:29.273]                       invokeRestart <- base::invokeRestart
[10:18:29.273]                       is.null <- base::is.null
[10:18:29.273]                       muffled <- FALSE
[10:18:29.273]                       if (inherits(cond, "message")) {
[10:18:29.273]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.273]                         if (muffled) 
[10:18:29.273]                           invokeRestart("muffleMessage")
[10:18:29.273]                       }
[10:18:29.273]                       else if (inherits(cond, "warning")) {
[10:18:29.273]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.273]                         if (muffled) 
[10:18:29.273]                           invokeRestart("muffleWarning")
[10:18:29.273]                       }
[10:18:29.273]                       else if (inherits(cond, "condition")) {
[10:18:29.273]                         if (!is.null(pattern)) {
[10:18:29.273]                           computeRestarts <- base::computeRestarts
[10:18:29.273]                           grepl <- base::grepl
[10:18:29.273]                           restarts <- computeRestarts(cond)
[10:18:29.273]                           for (restart in restarts) {
[10:18:29.273]                             name <- restart$name
[10:18:29.273]                             if (is.null(name)) 
[10:18:29.273]                               next
[10:18:29.273]                             if (!grepl(pattern, name)) 
[10:18:29.273]                               next
[10:18:29.273]                             invokeRestart(restart)
[10:18:29.273]                             muffled <- TRUE
[10:18:29.273]                             break
[10:18:29.273]                           }
[10:18:29.273]                         }
[10:18:29.273]                       }
[10:18:29.273]                       invisible(muffled)
[10:18:29.273]                     }
[10:18:29.273]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.273]                   }
[10:18:29.273]                 }
[10:18:29.273]                 else {
[10:18:29.273]                   if (TRUE) {
[10:18:29.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.273]                     {
[10:18:29.273]                       inherits <- base::inherits
[10:18:29.273]                       invokeRestart <- base::invokeRestart
[10:18:29.273]                       is.null <- base::is.null
[10:18:29.273]                       muffled <- FALSE
[10:18:29.273]                       if (inherits(cond, "message")) {
[10:18:29.273]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.273]                         if (muffled) 
[10:18:29.273]                           invokeRestart("muffleMessage")
[10:18:29.273]                       }
[10:18:29.273]                       else if (inherits(cond, "warning")) {
[10:18:29.273]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.273]                         if (muffled) 
[10:18:29.273]                           invokeRestart("muffleWarning")
[10:18:29.273]                       }
[10:18:29.273]                       else if (inherits(cond, "condition")) {
[10:18:29.273]                         if (!is.null(pattern)) {
[10:18:29.273]                           computeRestarts <- base::computeRestarts
[10:18:29.273]                           grepl <- base::grepl
[10:18:29.273]                           restarts <- computeRestarts(cond)
[10:18:29.273]                           for (restart in restarts) {
[10:18:29.273]                             name <- restart$name
[10:18:29.273]                             if (is.null(name)) 
[10:18:29.273]                               next
[10:18:29.273]                             if (!grepl(pattern, name)) 
[10:18:29.273]                               next
[10:18:29.273]                             invokeRestart(restart)
[10:18:29.273]                             muffled <- TRUE
[10:18:29.273]                             break
[10:18:29.273]                           }
[10:18:29.273]                         }
[10:18:29.273]                       }
[10:18:29.273]                       invisible(muffled)
[10:18:29.273]                     }
[10:18:29.273]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.273]                   }
[10:18:29.273]                 }
[10:18:29.273]             }
[10:18:29.273]         }))
[10:18:29.273]     }, error = function(ex) {
[10:18:29.273]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.273]                 ...future.rng), started = ...future.startTime, 
[10:18:29.273]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.273]             version = "1.8"), class = "FutureResult")
[10:18:29.273]     }, finally = {
[10:18:29.273]         if (!identical(...future.workdir, getwd())) 
[10:18:29.273]             setwd(...future.workdir)
[10:18:29.273]         {
[10:18:29.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.273]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.273]             }
[10:18:29.273]             base::options(...future.oldOptions)
[10:18:29.273]             if (.Platform$OS.type == "windows") {
[10:18:29.273]                 old_names <- names(...future.oldEnvVars)
[10:18:29.273]                 envs <- base::Sys.getenv()
[10:18:29.273]                 names <- names(envs)
[10:18:29.273]                 common <- intersect(names, old_names)
[10:18:29.273]                 added <- setdiff(names, old_names)
[10:18:29.273]                 removed <- setdiff(old_names, names)
[10:18:29.273]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.273]                   envs[common]]
[10:18:29.273]                 NAMES <- toupper(changed)
[10:18:29.273]                 args <- list()
[10:18:29.273]                 for (kk in seq_along(NAMES)) {
[10:18:29.273]                   name <- changed[[kk]]
[10:18:29.273]                   NAME <- NAMES[[kk]]
[10:18:29.273]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.273]                     next
[10:18:29.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.273]                 }
[10:18:29.273]                 NAMES <- toupper(added)
[10:18:29.273]                 for (kk in seq_along(NAMES)) {
[10:18:29.273]                   name <- added[[kk]]
[10:18:29.273]                   NAME <- NAMES[[kk]]
[10:18:29.273]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.273]                     next
[10:18:29.273]                   args[[name]] <- ""
[10:18:29.273]                 }
[10:18:29.273]                 NAMES <- toupper(removed)
[10:18:29.273]                 for (kk in seq_along(NAMES)) {
[10:18:29.273]                   name <- removed[[kk]]
[10:18:29.273]                   NAME <- NAMES[[kk]]
[10:18:29.273]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.273]                     next
[10:18:29.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.273]                 }
[10:18:29.273]                 if (length(args) > 0) 
[10:18:29.273]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.273]             }
[10:18:29.273]             else {
[10:18:29.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.273]             }
[10:18:29.273]             {
[10:18:29.273]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.273]                   0L) {
[10:18:29.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.273]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.273]                   base::options(opts)
[10:18:29.273]                 }
[10:18:29.273]                 {
[10:18:29.273]                   {
[10:18:29.273]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.273]                     NULL
[10:18:29.273]                   }
[10:18:29.273]                   options(future.plan = NULL)
[10:18:29.273]                   if (is.na(NA_character_)) 
[10:18:29.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.273]                     .init = FALSE)
[10:18:29.273]                 }
[10:18:29.273]             }
[10:18:29.273]         }
[10:18:29.273]     })
[10:18:29.273]     if (TRUE) {
[10:18:29.273]         base::sink(type = "output", split = FALSE)
[10:18:29.273]         if (TRUE) {
[10:18:29.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.273]         }
[10:18:29.273]         else {
[10:18:29.273]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.273]         }
[10:18:29.273]         base::close(...future.stdout)
[10:18:29.273]         ...future.stdout <- NULL
[10:18:29.273]     }
[10:18:29.273]     ...future.result$conditions <- ...future.conditions
[10:18:29.273]     ...future.result$finished <- base::Sys.time()
[10:18:29.273]     ...future.result
[10:18:29.273] }
[10:18:29.276] Exporting 5 global objects (914 bytes) to cluster node #1 ...
[10:18:29.276] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:29.276] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:29.277] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:18:29.277] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:18:29.277] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ...
[10:18:29.277] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ... DONE
[10:18:29.278] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:29.278] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:29.278] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:29.278] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:29.279] Exporting 5 global objects (914 bytes) to cluster node #1 ... DONE
[10:18:29.279] MultisessionFuture started
[10:18:29.279] - Launch lazy future ... done
[10:18:29.279] run() for ‘MultisessionFuture’ ... done
[10:18:29.279] Created future:
[10:18:29.279] MultisessionFuture:
[10:18:29.279] Label: ‘future_apply-1’
[10:18:29.279] Expression:
[10:18:29.279] {
[10:18:29.279]     do.call(function(...) {
[10:18:29.279]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.279]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.279]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.279]             on.exit(options(oopts), add = TRUE)
[10:18:29.279]         }
[10:18:29.279]         {
[10:18:29.279]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.279]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.279]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.279]             })
[10:18:29.279]         }
[10:18:29.279]     }, args = future.call.arguments)
[10:18:29.279] }
[10:18:29.279] Lazy evaluation: FALSE
[10:18:29.279] Asynchronous evaluation: TRUE
[10:18:29.279] Local evaluation: TRUE
[10:18:29.279] Environment: R_GlobalEnv
[10:18:29.279] Capture standard output: TRUE
[10:18:29.279] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.279] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.279] Packages: <none>
[10:18:29.279] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.279] Resolved: FALSE
[10:18:29.279] Value: <not collected>
[10:18:29.279] Conditions captured: <none>
[10:18:29.279] Early signaling: FALSE
[10:18:29.279] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.279] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.291] Chunk #1 of 2 ... DONE
[10:18:29.291] Chunk #2 of 2 ...
[10:18:29.291]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.291]  - seeds: <none>
[10:18:29.291]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.292] getGlobalsAndPackages() ...
[10:18:29.292] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.292] Resolving globals: FALSE
[10:18:29.292] Tweak future expression to call with '...' arguments ...
[10:18:29.292] {
[10:18:29.292]     do.call(function(...) {
[10:18:29.292]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.292]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.292]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.292]             on.exit(options(oopts), add = TRUE)
[10:18:29.292]         }
[10:18:29.292]         {
[10:18:29.292]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.292]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.292]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.292]             })
[10:18:29.292]         }
[10:18:29.292]     }, args = future.call.arguments)
[10:18:29.292] }
[10:18:29.292] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.293] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.293] 
[10:18:29.293] getGlobalsAndPackages() ... DONE
[10:18:29.293] run() for ‘Future’ ...
[10:18:29.293] - state: ‘created’
[10:18:29.293] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.307] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.307] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.307]   - Field: ‘node’
[10:18:29.308]   - Field: ‘label’
[10:18:29.308]   - Field: ‘local’
[10:18:29.308]   - Field: ‘owner’
[10:18:29.308]   - Field: ‘envir’
[10:18:29.308]   - Field: ‘workers’
[10:18:29.308]   - Field: ‘packages’
[10:18:29.308]   - Field: ‘gc’
[10:18:29.308]   - Field: ‘conditions’
[10:18:29.308]   - Field: ‘persistent’
[10:18:29.308]   - Field: ‘expr’
[10:18:29.308]   - Field: ‘uuid’
[10:18:29.309]   - Field: ‘seed’
[10:18:29.309]   - Field: ‘version’
[10:18:29.309]   - Field: ‘result’
[10:18:29.309]   - Field: ‘asynchronous’
[10:18:29.309]   - Field: ‘calls’
[10:18:29.309]   - Field: ‘globals’
[10:18:29.309]   - Field: ‘stdout’
[10:18:29.309]   - Field: ‘earlySignal’
[10:18:29.309]   - Field: ‘lazy’
[10:18:29.309]   - Field: ‘state’
[10:18:29.309] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.309] - Launch lazy future ...
[10:18:29.310] Packages needed by the future expression (n = 0): <none>
[10:18:29.310] Packages needed by future strategies (n = 0): <none>
[10:18:29.310] {
[10:18:29.310]     {
[10:18:29.310]         {
[10:18:29.310]             ...future.startTime <- base::Sys.time()
[10:18:29.310]             {
[10:18:29.310]                 {
[10:18:29.310]                   {
[10:18:29.310]                     {
[10:18:29.310]                       base::local({
[10:18:29.310]                         has_future <- base::requireNamespace("future", 
[10:18:29.310]                           quietly = TRUE)
[10:18:29.310]                         if (has_future) {
[10:18:29.310]                           ns <- base::getNamespace("future")
[10:18:29.310]                           version <- ns[[".package"]][["version"]]
[10:18:29.310]                           if (is.null(version)) 
[10:18:29.310]                             version <- utils::packageVersion("future")
[10:18:29.310]                         }
[10:18:29.310]                         else {
[10:18:29.310]                           version <- NULL
[10:18:29.310]                         }
[10:18:29.310]                         if (!has_future || version < "1.8.0") {
[10:18:29.310]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.310]                             "", base::R.version$version.string), 
[10:18:29.310]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.310]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.310]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.310]                               "release", "version")], collapse = " "), 
[10:18:29.310]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.310]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.310]                             info)
[10:18:29.310]                           info <- base::paste(info, collapse = "; ")
[10:18:29.310]                           if (!has_future) {
[10:18:29.310]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.310]                               info)
[10:18:29.310]                           }
[10:18:29.310]                           else {
[10:18:29.310]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.310]                               info, version)
[10:18:29.310]                           }
[10:18:29.310]                           base::stop(msg)
[10:18:29.310]                         }
[10:18:29.310]                       })
[10:18:29.310]                     }
[10:18:29.310]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.310]                     base::options(mc.cores = 1L)
[10:18:29.310]                   }
[10:18:29.310]                   ...future.strategy.old <- future::plan("list")
[10:18:29.310]                   options(future.plan = NULL)
[10:18:29.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.310]                 }
[10:18:29.310]                 ...future.workdir <- getwd()
[10:18:29.310]             }
[10:18:29.310]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.310]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.310]         }
[10:18:29.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.310]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.310]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.310]             base::names(...future.oldOptions))
[10:18:29.310]     }
[10:18:29.310]     if (FALSE) {
[10:18:29.310]     }
[10:18:29.310]     else {
[10:18:29.310]         if (TRUE) {
[10:18:29.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.310]                 open = "w")
[10:18:29.310]         }
[10:18:29.310]         else {
[10:18:29.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.310]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.310]         }
[10:18:29.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.310]             base::sink(type = "output", split = FALSE)
[10:18:29.310]             base::close(...future.stdout)
[10:18:29.310]         }, add = TRUE)
[10:18:29.310]     }
[10:18:29.310]     ...future.frame <- base::sys.nframe()
[10:18:29.310]     ...future.conditions <- base::list()
[10:18:29.310]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.310]     if (FALSE) {
[10:18:29.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.310]     }
[10:18:29.310]     ...future.result <- base::tryCatch({
[10:18:29.310]         base::withCallingHandlers({
[10:18:29.310]             ...future.value <- base::withVisible(base::local({
[10:18:29.310]                 ...future.makeSendCondition <- base::local({
[10:18:29.310]                   sendCondition <- NULL
[10:18:29.310]                   function(frame = 1L) {
[10:18:29.310]                     if (is.function(sendCondition)) 
[10:18:29.310]                       return(sendCondition)
[10:18:29.310]                     ns <- getNamespace("parallel")
[10:18:29.310]                     if (exists("sendData", mode = "function", 
[10:18:29.310]                       envir = ns)) {
[10:18:29.310]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.310]                         envir = ns)
[10:18:29.310]                       envir <- sys.frame(frame)
[10:18:29.310]                       master <- NULL
[10:18:29.310]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.310]                         !identical(envir, emptyenv())) {
[10:18:29.310]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.310]                           inherits = FALSE)) {
[10:18:29.310]                           master <- get("master", mode = "list", 
[10:18:29.310]                             envir = envir, inherits = FALSE)
[10:18:29.310]                           if (inherits(master, c("SOCKnode", 
[10:18:29.310]                             "SOCK0node"))) {
[10:18:29.310]                             sendCondition <<- function(cond) {
[10:18:29.310]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.310]                                 success = TRUE)
[10:18:29.310]                               parallel_sendData(master, data)
[10:18:29.310]                             }
[10:18:29.310]                             return(sendCondition)
[10:18:29.310]                           }
[10:18:29.310]                         }
[10:18:29.310]                         frame <- frame + 1L
[10:18:29.310]                         envir <- sys.frame(frame)
[10:18:29.310]                       }
[10:18:29.310]                     }
[10:18:29.310]                     sendCondition <<- function(cond) NULL
[10:18:29.310]                   }
[10:18:29.310]                 })
[10:18:29.310]                 withCallingHandlers({
[10:18:29.310]                   {
[10:18:29.310]                     do.call(function(...) {
[10:18:29.310]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.310]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.310]                         ...future.globals.maxSize)) {
[10:18:29.310]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.310]                         on.exit(options(oopts), add = TRUE)
[10:18:29.310]                       }
[10:18:29.310]                       {
[10:18:29.310]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.310]                           FUN = function(jj) {
[10:18:29.310]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.310]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.310]                           })
[10:18:29.310]                       }
[10:18:29.310]                     }, args = future.call.arguments)
[10:18:29.310]                   }
[10:18:29.310]                 }, immediateCondition = function(cond) {
[10:18:29.310]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.310]                   sendCondition(cond)
[10:18:29.310]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.310]                   {
[10:18:29.310]                     inherits <- base::inherits
[10:18:29.310]                     invokeRestart <- base::invokeRestart
[10:18:29.310]                     is.null <- base::is.null
[10:18:29.310]                     muffled <- FALSE
[10:18:29.310]                     if (inherits(cond, "message")) {
[10:18:29.310]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.310]                       if (muffled) 
[10:18:29.310]                         invokeRestart("muffleMessage")
[10:18:29.310]                     }
[10:18:29.310]                     else if (inherits(cond, "warning")) {
[10:18:29.310]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.310]                       if (muffled) 
[10:18:29.310]                         invokeRestart("muffleWarning")
[10:18:29.310]                     }
[10:18:29.310]                     else if (inherits(cond, "condition")) {
[10:18:29.310]                       if (!is.null(pattern)) {
[10:18:29.310]                         computeRestarts <- base::computeRestarts
[10:18:29.310]                         grepl <- base::grepl
[10:18:29.310]                         restarts <- computeRestarts(cond)
[10:18:29.310]                         for (restart in restarts) {
[10:18:29.310]                           name <- restart$name
[10:18:29.310]                           if (is.null(name)) 
[10:18:29.310]                             next
[10:18:29.310]                           if (!grepl(pattern, name)) 
[10:18:29.310]                             next
[10:18:29.310]                           invokeRestart(restart)
[10:18:29.310]                           muffled <- TRUE
[10:18:29.310]                           break
[10:18:29.310]                         }
[10:18:29.310]                       }
[10:18:29.310]                     }
[10:18:29.310]                     invisible(muffled)
[10:18:29.310]                   }
[10:18:29.310]                   muffleCondition(cond)
[10:18:29.310]                 })
[10:18:29.310]             }))
[10:18:29.310]             future::FutureResult(value = ...future.value$value, 
[10:18:29.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.310]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.310]                     ...future.globalenv.names))
[10:18:29.310]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.310]         }, condition = base::local({
[10:18:29.310]             c <- base::c
[10:18:29.310]             inherits <- base::inherits
[10:18:29.310]             invokeRestart <- base::invokeRestart
[10:18:29.310]             length <- base::length
[10:18:29.310]             list <- base::list
[10:18:29.310]             seq.int <- base::seq.int
[10:18:29.310]             signalCondition <- base::signalCondition
[10:18:29.310]             sys.calls <- base::sys.calls
[10:18:29.310]             `[[` <- base::`[[`
[10:18:29.310]             `+` <- base::`+`
[10:18:29.310]             `<<-` <- base::`<<-`
[10:18:29.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.310]                   3L)]
[10:18:29.310]             }
[10:18:29.310]             function(cond) {
[10:18:29.310]                 is_error <- inherits(cond, "error")
[10:18:29.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.310]                   NULL)
[10:18:29.310]                 if (is_error) {
[10:18:29.310]                   sessionInformation <- function() {
[10:18:29.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.310]                       search = base::search(), system = base::Sys.info())
[10:18:29.310]                   }
[10:18:29.310]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.310]                     cond$call), session = sessionInformation(), 
[10:18:29.310]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.310]                   signalCondition(cond)
[10:18:29.310]                 }
[10:18:29.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.310]                 "immediateCondition"))) {
[10:18:29.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.310]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.310]                   if (TRUE && !signal) {
[10:18:29.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.310]                     {
[10:18:29.310]                       inherits <- base::inherits
[10:18:29.310]                       invokeRestart <- base::invokeRestart
[10:18:29.310]                       is.null <- base::is.null
[10:18:29.310]                       muffled <- FALSE
[10:18:29.310]                       if (inherits(cond, "message")) {
[10:18:29.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.310]                         if (muffled) 
[10:18:29.310]                           invokeRestart("muffleMessage")
[10:18:29.310]                       }
[10:18:29.310]                       else if (inherits(cond, "warning")) {
[10:18:29.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.310]                         if (muffled) 
[10:18:29.310]                           invokeRestart("muffleWarning")
[10:18:29.310]                       }
[10:18:29.310]                       else if (inherits(cond, "condition")) {
[10:18:29.310]                         if (!is.null(pattern)) {
[10:18:29.310]                           computeRestarts <- base::computeRestarts
[10:18:29.310]                           grepl <- base::grepl
[10:18:29.310]                           restarts <- computeRestarts(cond)
[10:18:29.310]                           for (restart in restarts) {
[10:18:29.310]                             name <- restart$name
[10:18:29.310]                             if (is.null(name)) 
[10:18:29.310]                               next
[10:18:29.310]                             if (!grepl(pattern, name)) 
[10:18:29.310]                               next
[10:18:29.310]                             invokeRestart(restart)
[10:18:29.310]                             muffled <- TRUE
[10:18:29.310]                             break
[10:18:29.310]                           }
[10:18:29.310]                         }
[10:18:29.310]                       }
[10:18:29.310]                       invisible(muffled)
[10:18:29.310]                     }
[10:18:29.310]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.310]                   }
[10:18:29.310]                 }
[10:18:29.310]                 else {
[10:18:29.310]                   if (TRUE) {
[10:18:29.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.310]                     {
[10:18:29.310]                       inherits <- base::inherits
[10:18:29.310]                       invokeRestart <- base::invokeRestart
[10:18:29.310]                       is.null <- base::is.null
[10:18:29.310]                       muffled <- FALSE
[10:18:29.310]                       if (inherits(cond, "message")) {
[10:18:29.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.310]                         if (muffled) 
[10:18:29.310]                           invokeRestart("muffleMessage")
[10:18:29.310]                       }
[10:18:29.310]                       else if (inherits(cond, "warning")) {
[10:18:29.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.310]                         if (muffled) 
[10:18:29.310]                           invokeRestart("muffleWarning")
[10:18:29.310]                       }
[10:18:29.310]                       else if (inherits(cond, "condition")) {
[10:18:29.310]                         if (!is.null(pattern)) {
[10:18:29.310]                           computeRestarts <- base::computeRestarts
[10:18:29.310]                           grepl <- base::grepl
[10:18:29.310]                           restarts <- computeRestarts(cond)
[10:18:29.310]                           for (restart in restarts) {
[10:18:29.310]                             name <- restart$name
[10:18:29.310]                             if (is.null(name)) 
[10:18:29.310]                               next
[10:18:29.310]                             if (!grepl(pattern, name)) 
[10:18:29.310]                               next
[10:18:29.310]                             invokeRestart(restart)
[10:18:29.310]                             muffled <- TRUE
[10:18:29.310]                             break
[10:18:29.310]                           }
[10:18:29.310]                         }
[10:18:29.310]                       }
[10:18:29.310]                       invisible(muffled)
[10:18:29.310]                     }
[10:18:29.310]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.310]                   }
[10:18:29.310]                 }
[10:18:29.310]             }
[10:18:29.310]         }))
[10:18:29.310]     }, error = function(ex) {
[10:18:29.310]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.310]                 ...future.rng), started = ...future.startTime, 
[10:18:29.310]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.310]             version = "1.8"), class = "FutureResult")
[10:18:29.310]     }, finally = {
[10:18:29.310]         if (!identical(...future.workdir, getwd())) 
[10:18:29.310]             setwd(...future.workdir)
[10:18:29.310]         {
[10:18:29.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.310]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.310]             }
[10:18:29.310]             base::options(...future.oldOptions)
[10:18:29.310]             if (.Platform$OS.type == "windows") {
[10:18:29.310]                 old_names <- names(...future.oldEnvVars)
[10:18:29.310]                 envs <- base::Sys.getenv()
[10:18:29.310]                 names <- names(envs)
[10:18:29.310]                 common <- intersect(names, old_names)
[10:18:29.310]                 added <- setdiff(names, old_names)
[10:18:29.310]                 removed <- setdiff(old_names, names)
[10:18:29.310]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.310]                   envs[common]]
[10:18:29.310]                 NAMES <- toupper(changed)
[10:18:29.310]                 args <- list()
[10:18:29.310]                 for (kk in seq_along(NAMES)) {
[10:18:29.310]                   name <- changed[[kk]]
[10:18:29.310]                   NAME <- NAMES[[kk]]
[10:18:29.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.310]                     next
[10:18:29.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.310]                 }
[10:18:29.310]                 NAMES <- toupper(added)
[10:18:29.310]                 for (kk in seq_along(NAMES)) {
[10:18:29.310]                   name <- added[[kk]]
[10:18:29.310]                   NAME <- NAMES[[kk]]
[10:18:29.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.310]                     next
[10:18:29.310]                   args[[name]] <- ""
[10:18:29.310]                 }
[10:18:29.310]                 NAMES <- toupper(removed)
[10:18:29.310]                 for (kk in seq_along(NAMES)) {
[10:18:29.310]                   name <- removed[[kk]]
[10:18:29.310]                   NAME <- NAMES[[kk]]
[10:18:29.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.310]                     next
[10:18:29.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.310]                 }
[10:18:29.310]                 if (length(args) > 0) 
[10:18:29.310]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.310]             }
[10:18:29.310]             else {
[10:18:29.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.310]             }
[10:18:29.310]             {
[10:18:29.310]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.310]                   0L) {
[10:18:29.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.310]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.310]                   base::options(opts)
[10:18:29.310]                 }
[10:18:29.310]                 {
[10:18:29.310]                   {
[10:18:29.310]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.310]                     NULL
[10:18:29.310]                   }
[10:18:29.310]                   options(future.plan = NULL)
[10:18:29.310]                   if (is.na(NA_character_)) 
[10:18:29.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.310]                     .init = FALSE)
[10:18:29.310]                 }
[10:18:29.310]             }
[10:18:29.310]         }
[10:18:29.310]     })
[10:18:29.310]     if (TRUE) {
[10:18:29.310]         base::sink(type = "output", split = FALSE)
[10:18:29.310]         if (TRUE) {
[10:18:29.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.310]         }
[10:18:29.310]         else {
[10:18:29.310]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.310]         }
[10:18:29.310]         base::close(...future.stdout)
[10:18:29.310]         ...future.stdout <- NULL
[10:18:29.310]     }
[10:18:29.310]     ...future.result$conditions <- ...future.conditions
[10:18:29.310]     ...future.result$finished <- base::Sys.time()
[10:18:29.310]     ...future.result
[10:18:29.310] }
[10:18:29.313] Exporting 5 global objects (914 bytes) to cluster node #2 ...
[10:18:29.313] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:29.314] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:29.314] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:18:29.314] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:18:29.314] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ...
[10:18:29.315] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ... DONE
[10:18:29.315] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:29.315] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:29.315] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:29.316] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:29.316] Exporting 5 global objects (914 bytes) to cluster node #2 ... DONE
[10:18:29.316] MultisessionFuture started
[10:18:29.316] - Launch lazy future ... done
[10:18:29.316] run() for ‘MultisessionFuture’ ... done
[10:18:29.316] Created future:
[10:18:29.316] MultisessionFuture:
[10:18:29.316] Label: ‘future_apply-2’
[10:18:29.316] Expression:
[10:18:29.316] {
[10:18:29.316]     do.call(function(...) {
[10:18:29.316]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.316]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.316]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.316]             on.exit(options(oopts), add = TRUE)
[10:18:29.316]         }
[10:18:29.316]         {
[10:18:29.316]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.316]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.316]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.316]             })
[10:18:29.316]         }
[10:18:29.316]     }, args = future.call.arguments)
[10:18:29.316] }
[10:18:29.316] Lazy evaluation: FALSE
[10:18:29.316] Asynchronous evaluation: TRUE
[10:18:29.316] Local evaluation: TRUE
[10:18:29.316] Environment: R_GlobalEnv
[10:18:29.316] Capture standard output: TRUE
[10:18:29.316] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.316] Globals: 5 objects totaling 451 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.316] Packages: <none>
[10:18:29.316] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.316] Resolved: FALSE
[10:18:29.316] Value: <not collected>
[10:18:29.316] Conditions captured: <none>
[10:18:29.316] Early signaling: FALSE
[10:18:29.316] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.316] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.328] Chunk #2 of 2 ... DONE
[10:18:29.328] Launching 2 futures (chunks) ... DONE
[10:18:29.328] Resolving 2 futures (chunks) ...
[10:18:29.328] resolve() on list ...
[10:18:29.328]  recursive: 0
[10:18:29.328]  length: 2
[10:18:29.328] 
[10:18:29.329] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.329] - Validating connection of MultisessionFuture
[10:18:29.329] - received message: FutureResult
[10:18:29.329] - Received FutureResult
[10:18:29.329] - Erased future from FutureRegistry
[10:18:29.330] result() for ClusterFuture ...
[10:18:29.330] - result already collected: FutureResult
[10:18:29.330] result() for ClusterFuture ... done
[10:18:29.330] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.330] Future #1
[10:18:29.330] result() for ClusterFuture ...
[10:18:29.330] - result already collected: FutureResult
[10:18:29.330] result() for ClusterFuture ... done
[10:18:29.330] result() for ClusterFuture ...
[10:18:29.330] - result already collected: FutureResult
[10:18:29.330] result() for ClusterFuture ... done
[10:18:29.330] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:29.331] - nx: 2
[10:18:29.331] - relay: TRUE
[10:18:29.331] - stdout: TRUE
[10:18:29.331] - signal: TRUE
[10:18:29.331] - resignal: FALSE
[10:18:29.331] - force: TRUE
[10:18:29.331] - relayed: [n=2] FALSE, FALSE
[10:18:29.331] - queued futures: [n=2] FALSE, FALSE
[10:18:29.331]  - until=1
[10:18:29.331]  - relaying element #1
[10:18:29.331] result() for ClusterFuture ...
[10:18:29.331] - result already collected: FutureResult
[10:18:29.332] result() for ClusterFuture ... done
[10:18:29.332] result() for ClusterFuture ...
[10:18:29.332] - result already collected: FutureResult
[10:18:29.332] result() for ClusterFuture ... done
[10:18:29.332] result() for ClusterFuture ...
[10:18:29.332] - result already collected: FutureResult
[10:18:29.332] result() for ClusterFuture ... done
[10:18:29.332] result() for ClusterFuture ...
[10:18:29.332] - result already collected: FutureResult
[10:18:29.332] result() for ClusterFuture ... done
[10:18:29.332] - relayed: [n=2] TRUE, FALSE
[10:18:29.332] - queued futures: [n=2] TRUE, FALSE
[10:18:29.333] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:29.333]  length: 1 (resolved future 1)
[10:18:29.358] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.358] - Validating connection of MultisessionFuture
[10:18:29.358] - received message: FutureResult
[10:18:29.359] - Received FutureResult
[10:18:29.359] - Erased future from FutureRegistry
[10:18:29.359] result() for ClusterFuture ...
[10:18:29.359] - result already collected: FutureResult
[10:18:29.359] result() for ClusterFuture ... done
[10:18:29.359] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.359] Future #2
[10:18:29.359] result() for ClusterFuture ...
[10:18:29.359] - result already collected: FutureResult
[10:18:29.359] result() for ClusterFuture ... done
[10:18:29.359] result() for ClusterFuture ...
[10:18:29.359] - result already collected: FutureResult
[10:18:29.360] result() for ClusterFuture ... done
[10:18:29.360] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:29.360] - nx: 2
[10:18:29.360] - relay: TRUE
[10:18:29.360] - stdout: TRUE
[10:18:29.360] - signal: TRUE
[10:18:29.360] - resignal: FALSE
[10:18:29.360] - force: TRUE
[10:18:29.360] - relayed: [n=2] TRUE, FALSE
[10:18:29.360] - queued futures: [n=2] TRUE, FALSE
[10:18:29.360]  - until=2
[10:18:29.360]  - relaying element #2
[10:18:29.361] result() for ClusterFuture ...
[10:18:29.361] - result already collected: FutureResult
[10:18:29.361] result() for ClusterFuture ... done
[10:18:29.361] result() for ClusterFuture ...
[10:18:29.361] - result already collected: FutureResult
[10:18:29.361] result() for ClusterFuture ... done
[10:18:29.361] result() for ClusterFuture ...
[10:18:29.361] - result already collected: FutureResult
[10:18:29.361] result() for ClusterFuture ... done
[10:18:29.361] result() for ClusterFuture ...
[10:18:29.361] - result already collected: FutureResult
[10:18:29.362] result() for ClusterFuture ... done
[10:18:29.362] - relayed: [n=2] TRUE, TRUE
[10:18:29.362] - queued futures: [n=2] TRUE, TRUE
[10:18:29.362] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:29.362]  length: 0 (resolved future 2)
[10:18:29.362] Relaying remaining futures
[10:18:29.362] signalConditionsASAP(NULL, pos=0) ...
[10:18:29.362] - nx: 2
[10:18:29.362] - relay: TRUE
[10:18:29.362] - stdout: TRUE
[10:18:29.362] - signal: TRUE
[10:18:29.362] - resignal: FALSE
[10:18:29.362] - force: TRUE
[10:18:29.363] - relayed: [n=2] TRUE, TRUE
[10:18:29.363] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:29.363] - relayed: [n=2] TRUE, TRUE
[10:18:29.363] - queued futures: [n=2] TRUE, TRUE
[10:18:29.363] signalConditionsASAP(NULL, pos=0) ... done
[10:18:29.363] resolve() on list ... DONE
[10:18:29.363] result() for ClusterFuture ...
[10:18:29.363] - result already collected: FutureResult
[10:18:29.363] result() for ClusterFuture ... done
[10:18:29.363] result() for ClusterFuture ...
[10:18:29.363] - result already collected: FutureResult
[10:18:29.364] result() for ClusterFuture ... done
[10:18:29.366] result() for ClusterFuture ...
[10:18:29.366] - result already collected: FutureResult
[10:18:29.366] result() for ClusterFuture ... done
[10:18:29.366] result() for ClusterFuture ...
[10:18:29.366] - result already collected: FutureResult
[10:18:29.366] result() for ClusterFuture ... done
[10:18:29.367]  - Number of value chunks collected: 2
[10:18:29.367] Resolving 2 futures (chunks) ... DONE
[10:18:29.367] Reducing values from 2 chunks ...
[10:18:29.367]  - Number of values collected after concatenation: 2
[10:18:29.367]  - Number of values expected: 2
[10:18:29.367] Reducing values from 2 chunks ... DONE
[10:18:29.367] future_lapply() ... DONE
      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5
[10:18:29.367] getGlobalsAndPackagesXApply() ...
[10:18:29.367]  - future.globals: TRUE
[10:18:29.368] getGlobalsAndPackages() ...
[10:18:29.368] Searching for globals...
[10:18:29.369] - globals found: [1] ‘FUN’
[10:18:29.369] Searching for globals ... DONE
[10:18:29.369] Resolving globals: FALSE
[10:18:29.369] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:29.370] The total size of the 1 globals exported for future expression (‘FUN(X = structure(c(3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3,; 4, 5, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5, 3, 3, 3,; 3, 3, 3, 3, 3, 4, 3, 2, 1, 2, 3, 4, 5), dim = c(8L, 2L, 3L), dimnames = list(; row = NULL, col = c("x1", "x2"), C = c("cop.1", "cop.2",; "cop.3"))))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:29.370] - globals: [1] ‘FUN’
[10:18:29.370] 
[10:18:29.370] getGlobalsAndPackages() ... DONE
[10:18:29.370]  - globals found/used: [n=1] ‘FUN’
[10:18:29.370]  - needed namespaces: [n=0] 
[10:18:29.370] Finding globals ... DONE
[10:18:29.370]  - use_args: TRUE
[10:18:29.370]  - Getting '...' globals ...
[10:18:29.371] resolve() on list ...
[10:18:29.371]  recursive: 0
[10:18:29.371]  length: 1
[10:18:29.371]  elements: ‘...’
[10:18:29.371]  length: 0 (resolved future 1)
[10:18:29.371] resolve() on list ... DONE
[10:18:29.371]    - '...' content: [n=0] 
[10:18:29.371] List of 1
[10:18:29.371]  $ ...: list()
[10:18:29.371]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.371]  - attr(*, "where")=List of 1
[10:18:29.371]   ..$ ...:<environment: 0x556e042f3220> 
[10:18:29.371]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.371]  - attr(*, "resolved")= logi TRUE
[10:18:29.371]  - attr(*, "total_size")= num NA
[10:18:29.374]  - Getting '...' globals ... DONE
[10:18:29.374] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:29.374] List of 2
[10:18:29.374]  $ ...future.FUN:function (x)  
[10:18:29.374]  $ ...          : list()
[10:18:29.374]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.374]  - attr(*, "where")=List of 2
[10:18:29.374]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:29.374]   ..$ ...          :<environment: 0x556e042f3220> 
[10:18:29.374]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.374]  - attr(*, "resolved")= logi FALSE
[10:18:29.374]  - attr(*, "total_size")= num 3563
[10:18:29.377] Packages to be attached in all futures: [n=0] 
[10:18:29.377] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.378] future_lapply() ...
[10:18:29.380] Number of chunks: 2
[10:18:29.380] getGlobalsAndPackagesXApply() ...
[10:18:29.380]  - future.globals: <name-value list> with names ‘list()’
[10:18:29.381]  - use_args: TRUE
[10:18:29.381] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:29.381] List of 2
[10:18:29.381]  $ ...          : list()
[10:18:29.381]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.381]  $ ...future.FUN:function (x)  
[10:18:29.381]  - attr(*, "where")=List of 2
[10:18:29.381]   ..$ ...          :<environment: 0x556e042f3220> 
[10:18:29.381]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:29.381]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.381]  - attr(*, "resolved")= logi FALSE
[10:18:29.381]  - attr(*, "total_size")= num NA
[10:18:29.384] Packages to be attached in all futures: [n=0] 
[10:18:29.384] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.384] Number of futures (= number of chunks): 2
[10:18:29.385] Launching 2 futures (chunks) ...
[10:18:29.385] Chunk #1 of 2 ...
[10:18:29.385]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.385]  - seeds: <none>
[10:18:29.385]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.385] getGlobalsAndPackages() ...
[10:18:29.385] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.385] Resolving globals: FALSE
[10:18:29.385] Tweak future expression to call with '...' arguments ...
[10:18:29.386] {
[10:18:29.386]     do.call(function(...) {
[10:18:29.386]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.386]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.386]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.386]             on.exit(options(oopts), add = TRUE)
[10:18:29.386]         }
[10:18:29.386]         {
[10:18:29.386]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.386]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.386]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.386]             })
[10:18:29.386]         }
[10:18:29.386]     }, args = future.call.arguments)
[10:18:29.386] }
[10:18:29.386] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.386] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.386] 
[10:18:29.386] getGlobalsAndPackages() ... DONE
[10:18:29.387] run() for ‘Future’ ...
[10:18:29.387] - state: ‘created’
[10:18:29.387] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.402] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.402]   - Field: ‘node’
[10:18:29.402]   - Field: ‘label’
[10:18:29.402]   - Field: ‘local’
[10:18:29.402]   - Field: ‘owner’
[10:18:29.403]   - Field: ‘envir’
[10:18:29.403]   - Field: ‘workers’
[10:18:29.403]   - Field: ‘packages’
[10:18:29.403]   - Field: ‘gc’
[10:18:29.403]   - Field: ‘conditions’
[10:18:29.403]   - Field: ‘persistent’
[10:18:29.403]   - Field: ‘expr’
[10:18:29.403]   - Field: ‘uuid’
[10:18:29.403]   - Field: ‘seed’
[10:18:29.403]   - Field: ‘version’
[10:18:29.403]   - Field: ‘result’
[10:18:29.404]   - Field: ‘asynchronous’
[10:18:29.404]   - Field: ‘calls’
[10:18:29.404]   - Field: ‘globals’
[10:18:29.404]   - Field: ‘stdout’
[10:18:29.404]   - Field: ‘earlySignal’
[10:18:29.404]   - Field: ‘lazy’
[10:18:29.404]   - Field: ‘state’
[10:18:29.404] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.404] - Launch lazy future ...
[10:18:29.404] Packages needed by the future expression (n = 0): <none>
[10:18:29.405] Packages needed by future strategies (n = 0): <none>
[10:18:29.405] {
[10:18:29.405]     {
[10:18:29.405]         {
[10:18:29.405]             ...future.startTime <- base::Sys.time()
[10:18:29.405]             {
[10:18:29.405]                 {
[10:18:29.405]                   {
[10:18:29.405]                     {
[10:18:29.405]                       base::local({
[10:18:29.405]                         has_future <- base::requireNamespace("future", 
[10:18:29.405]                           quietly = TRUE)
[10:18:29.405]                         if (has_future) {
[10:18:29.405]                           ns <- base::getNamespace("future")
[10:18:29.405]                           version <- ns[[".package"]][["version"]]
[10:18:29.405]                           if (is.null(version)) 
[10:18:29.405]                             version <- utils::packageVersion("future")
[10:18:29.405]                         }
[10:18:29.405]                         else {
[10:18:29.405]                           version <- NULL
[10:18:29.405]                         }
[10:18:29.405]                         if (!has_future || version < "1.8.0") {
[10:18:29.405]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.405]                             "", base::R.version$version.string), 
[10:18:29.405]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.405]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.405]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.405]                               "release", "version")], collapse = " "), 
[10:18:29.405]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.405]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.405]                             info)
[10:18:29.405]                           info <- base::paste(info, collapse = "; ")
[10:18:29.405]                           if (!has_future) {
[10:18:29.405]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.405]                               info)
[10:18:29.405]                           }
[10:18:29.405]                           else {
[10:18:29.405]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.405]                               info, version)
[10:18:29.405]                           }
[10:18:29.405]                           base::stop(msg)
[10:18:29.405]                         }
[10:18:29.405]                       })
[10:18:29.405]                     }
[10:18:29.405]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.405]                     base::options(mc.cores = 1L)
[10:18:29.405]                   }
[10:18:29.405]                   ...future.strategy.old <- future::plan("list")
[10:18:29.405]                   options(future.plan = NULL)
[10:18:29.405]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.405]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.405]                 }
[10:18:29.405]                 ...future.workdir <- getwd()
[10:18:29.405]             }
[10:18:29.405]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.405]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.405]         }
[10:18:29.405]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.405]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.405]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.405]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.405]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.405]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.405]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.405]             base::names(...future.oldOptions))
[10:18:29.405]     }
[10:18:29.405]     if (FALSE) {
[10:18:29.405]     }
[10:18:29.405]     else {
[10:18:29.405]         if (TRUE) {
[10:18:29.405]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.405]                 open = "w")
[10:18:29.405]         }
[10:18:29.405]         else {
[10:18:29.405]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.405]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.405]         }
[10:18:29.405]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.405]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.405]             base::sink(type = "output", split = FALSE)
[10:18:29.405]             base::close(...future.stdout)
[10:18:29.405]         }, add = TRUE)
[10:18:29.405]     }
[10:18:29.405]     ...future.frame <- base::sys.nframe()
[10:18:29.405]     ...future.conditions <- base::list()
[10:18:29.405]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.405]     if (FALSE) {
[10:18:29.405]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.405]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.405]     }
[10:18:29.405]     ...future.result <- base::tryCatch({
[10:18:29.405]         base::withCallingHandlers({
[10:18:29.405]             ...future.value <- base::withVisible(base::local({
[10:18:29.405]                 ...future.makeSendCondition <- base::local({
[10:18:29.405]                   sendCondition <- NULL
[10:18:29.405]                   function(frame = 1L) {
[10:18:29.405]                     if (is.function(sendCondition)) 
[10:18:29.405]                       return(sendCondition)
[10:18:29.405]                     ns <- getNamespace("parallel")
[10:18:29.405]                     if (exists("sendData", mode = "function", 
[10:18:29.405]                       envir = ns)) {
[10:18:29.405]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.405]                         envir = ns)
[10:18:29.405]                       envir <- sys.frame(frame)
[10:18:29.405]                       master <- NULL
[10:18:29.405]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.405]                         !identical(envir, emptyenv())) {
[10:18:29.405]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.405]                           inherits = FALSE)) {
[10:18:29.405]                           master <- get("master", mode = "list", 
[10:18:29.405]                             envir = envir, inherits = FALSE)
[10:18:29.405]                           if (inherits(master, c("SOCKnode", 
[10:18:29.405]                             "SOCK0node"))) {
[10:18:29.405]                             sendCondition <<- function(cond) {
[10:18:29.405]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.405]                                 success = TRUE)
[10:18:29.405]                               parallel_sendData(master, data)
[10:18:29.405]                             }
[10:18:29.405]                             return(sendCondition)
[10:18:29.405]                           }
[10:18:29.405]                         }
[10:18:29.405]                         frame <- frame + 1L
[10:18:29.405]                         envir <- sys.frame(frame)
[10:18:29.405]                       }
[10:18:29.405]                     }
[10:18:29.405]                     sendCondition <<- function(cond) NULL
[10:18:29.405]                   }
[10:18:29.405]                 })
[10:18:29.405]                 withCallingHandlers({
[10:18:29.405]                   {
[10:18:29.405]                     do.call(function(...) {
[10:18:29.405]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.405]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.405]                         ...future.globals.maxSize)) {
[10:18:29.405]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.405]                         on.exit(options(oopts), add = TRUE)
[10:18:29.405]                       }
[10:18:29.405]                       {
[10:18:29.405]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.405]                           FUN = function(jj) {
[10:18:29.405]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.405]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.405]                           })
[10:18:29.405]                       }
[10:18:29.405]                     }, args = future.call.arguments)
[10:18:29.405]                   }
[10:18:29.405]                 }, immediateCondition = function(cond) {
[10:18:29.405]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.405]                   sendCondition(cond)
[10:18:29.405]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.405]                   {
[10:18:29.405]                     inherits <- base::inherits
[10:18:29.405]                     invokeRestart <- base::invokeRestart
[10:18:29.405]                     is.null <- base::is.null
[10:18:29.405]                     muffled <- FALSE
[10:18:29.405]                     if (inherits(cond, "message")) {
[10:18:29.405]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.405]                       if (muffled) 
[10:18:29.405]                         invokeRestart("muffleMessage")
[10:18:29.405]                     }
[10:18:29.405]                     else if (inherits(cond, "warning")) {
[10:18:29.405]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.405]                       if (muffled) 
[10:18:29.405]                         invokeRestart("muffleWarning")
[10:18:29.405]                     }
[10:18:29.405]                     else if (inherits(cond, "condition")) {
[10:18:29.405]                       if (!is.null(pattern)) {
[10:18:29.405]                         computeRestarts <- base::computeRestarts
[10:18:29.405]                         grepl <- base::grepl
[10:18:29.405]                         restarts <- computeRestarts(cond)
[10:18:29.405]                         for (restart in restarts) {
[10:18:29.405]                           name <- restart$name
[10:18:29.405]                           if (is.null(name)) 
[10:18:29.405]                             next
[10:18:29.405]                           if (!grepl(pattern, name)) 
[10:18:29.405]                             next
[10:18:29.405]                           invokeRestart(restart)
[10:18:29.405]                           muffled <- TRUE
[10:18:29.405]                           break
[10:18:29.405]                         }
[10:18:29.405]                       }
[10:18:29.405]                     }
[10:18:29.405]                     invisible(muffled)
[10:18:29.405]                   }
[10:18:29.405]                   muffleCondition(cond)
[10:18:29.405]                 })
[10:18:29.405]             }))
[10:18:29.405]             future::FutureResult(value = ...future.value$value, 
[10:18:29.405]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.405]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.405]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.405]                     ...future.globalenv.names))
[10:18:29.405]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.405]         }, condition = base::local({
[10:18:29.405]             c <- base::c
[10:18:29.405]             inherits <- base::inherits
[10:18:29.405]             invokeRestart <- base::invokeRestart
[10:18:29.405]             length <- base::length
[10:18:29.405]             list <- base::list
[10:18:29.405]             seq.int <- base::seq.int
[10:18:29.405]             signalCondition <- base::signalCondition
[10:18:29.405]             sys.calls <- base::sys.calls
[10:18:29.405]             `[[` <- base::`[[`
[10:18:29.405]             `+` <- base::`+`
[10:18:29.405]             `<<-` <- base::`<<-`
[10:18:29.405]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.405]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.405]                   3L)]
[10:18:29.405]             }
[10:18:29.405]             function(cond) {
[10:18:29.405]                 is_error <- inherits(cond, "error")
[10:18:29.405]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.405]                   NULL)
[10:18:29.405]                 if (is_error) {
[10:18:29.405]                   sessionInformation <- function() {
[10:18:29.405]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.405]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.405]                       search = base::search(), system = base::Sys.info())
[10:18:29.405]                   }
[10:18:29.405]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.405]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.405]                     cond$call), session = sessionInformation(), 
[10:18:29.405]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.405]                   signalCondition(cond)
[10:18:29.405]                 }
[10:18:29.405]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.405]                 "immediateCondition"))) {
[10:18:29.405]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.405]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.405]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.405]                   if (TRUE && !signal) {
[10:18:29.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.405]                     {
[10:18:29.405]                       inherits <- base::inherits
[10:18:29.405]                       invokeRestart <- base::invokeRestart
[10:18:29.405]                       is.null <- base::is.null
[10:18:29.405]                       muffled <- FALSE
[10:18:29.405]                       if (inherits(cond, "message")) {
[10:18:29.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.405]                         if (muffled) 
[10:18:29.405]                           invokeRestart("muffleMessage")
[10:18:29.405]                       }
[10:18:29.405]                       else if (inherits(cond, "warning")) {
[10:18:29.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.405]                         if (muffled) 
[10:18:29.405]                           invokeRestart("muffleWarning")
[10:18:29.405]                       }
[10:18:29.405]                       else if (inherits(cond, "condition")) {
[10:18:29.405]                         if (!is.null(pattern)) {
[10:18:29.405]                           computeRestarts <- base::computeRestarts
[10:18:29.405]                           grepl <- base::grepl
[10:18:29.405]                           restarts <- computeRestarts(cond)
[10:18:29.405]                           for (restart in restarts) {
[10:18:29.405]                             name <- restart$name
[10:18:29.405]                             if (is.null(name)) 
[10:18:29.405]                               next
[10:18:29.405]                             if (!grepl(pattern, name)) 
[10:18:29.405]                               next
[10:18:29.405]                             invokeRestart(restart)
[10:18:29.405]                             muffled <- TRUE
[10:18:29.405]                             break
[10:18:29.405]                           }
[10:18:29.405]                         }
[10:18:29.405]                       }
[10:18:29.405]                       invisible(muffled)
[10:18:29.405]                     }
[10:18:29.405]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.405]                   }
[10:18:29.405]                 }
[10:18:29.405]                 else {
[10:18:29.405]                   if (TRUE) {
[10:18:29.405]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.405]                     {
[10:18:29.405]                       inherits <- base::inherits
[10:18:29.405]                       invokeRestart <- base::invokeRestart
[10:18:29.405]                       is.null <- base::is.null
[10:18:29.405]                       muffled <- FALSE
[10:18:29.405]                       if (inherits(cond, "message")) {
[10:18:29.405]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.405]                         if (muffled) 
[10:18:29.405]                           invokeRestart("muffleMessage")
[10:18:29.405]                       }
[10:18:29.405]                       else if (inherits(cond, "warning")) {
[10:18:29.405]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.405]                         if (muffled) 
[10:18:29.405]                           invokeRestart("muffleWarning")
[10:18:29.405]                       }
[10:18:29.405]                       else if (inherits(cond, "condition")) {
[10:18:29.405]                         if (!is.null(pattern)) {
[10:18:29.405]                           computeRestarts <- base::computeRestarts
[10:18:29.405]                           grepl <- base::grepl
[10:18:29.405]                           restarts <- computeRestarts(cond)
[10:18:29.405]                           for (restart in restarts) {
[10:18:29.405]                             name <- restart$name
[10:18:29.405]                             if (is.null(name)) 
[10:18:29.405]                               next
[10:18:29.405]                             if (!grepl(pattern, name)) 
[10:18:29.405]                               next
[10:18:29.405]                             invokeRestart(restart)
[10:18:29.405]                             muffled <- TRUE
[10:18:29.405]                             break
[10:18:29.405]                           }
[10:18:29.405]                         }
[10:18:29.405]                       }
[10:18:29.405]                       invisible(muffled)
[10:18:29.405]                     }
[10:18:29.405]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.405]                   }
[10:18:29.405]                 }
[10:18:29.405]             }
[10:18:29.405]         }))
[10:18:29.405]     }, error = function(ex) {
[10:18:29.405]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.405]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.405]                 ...future.rng), started = ...future.startTime, 
[10:18:29.405]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.405]             version = "1.8"), class = "FutureResult")
[10:18:29.405]     }, finally = {
[10:18:29.405]         if (!identical(...future.workdir, getwd())) 
[10:18:29.405]             setwd(...future.workdir)
[10:18:29.405]         {
[10:18:29.405]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.405]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.405]             }
[10:18:29.405]             base::options(...future.oldOptions)
[10:18:29.405]             if (.Platform$OS.type == "windows") {
[10:18:29.405]                 old_names <- names(...future.oldEnvVars)
[10:18:29.405]                 envs <- base::Sys.getenv()
[10:18:29.405]                 names <- names(envs)
[10:18:29.405]                 common <- intersect(names, old_names)
[10:18:29.405]                 added <- setdiff(names, old_names)
[10:18:29.405]                 removed <- setdiff(old_names, names)
[10:18:29.405]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.405]                   envs[common]]
[10:18:29.405]                 NAMES <- toupper(changed)
[10:18:29.405]                 args <- list()
[10:18:29.405]                 for (kk in seq_along(NAMES)) {
[10:18:29.405]                   name <- changed[[kk]]
[10:18:29.405]                   NAME <- NAMES[[kk]]
[10:18:29.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.405]                     next
[10:18:29.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.405]                 }
[10:18:29.405]                 NAMES <- toupper(added)
[10:18:29.405]                 for (kk in seq_along(NAMES)) {
[10:18:29.405]                   name <- added[[kk]]
[10:18:29.405]                   NAME <- NAMES[[kk]]
[10:18:29.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.405]                     next
[10:18:29.405]                   args[[name]] <- ""
[10:18:29.405]                 }
[10:18:29.405]                 NAMES <- toupper(removed)
[10:18:29.405]                 for (kk in seq_along(NAMES)) {
[10:18:29.405]                   name <- removed[[kk]]
[10:18:29.405]                   NAME <- NAMES[[kk]]
[10:18:29.405]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.405]                     next
[10:18:29.405]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.405]                 }
[10:18:29.405]                 if (length(args) > 0) 
[10:18:29.405]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.405]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.405]             }
[10:18:29.405]             else {
[10:18:29.405]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.405]             }
[10:18:29.405]             {
[10:18:29.405]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.405]                   0L) {
[10:18:29.405]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.405]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.405]                   base::options(opts)
[10:18:29.405]                 }
[10:18:29.405]                 {
[10:18:29.405]                   {
[10:18:29.405]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.405]                     NULL
[10:18:29.405]                   }
[10:18:29.405]                   options(future.plan = NULL)
[10:18:29.405]                   if (is.na(NA_character_)) 
[10:18:29.405]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.405]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.405]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.405]                     .init = FALSE)
[10:18:29.405]                 }
[10:18:29.405]             }
[10:18:29.405]         }
[10:18:29.405]     })
[10:18:29.405]     if (TRUE) {
[10:18:29.405]         base::sink(type = "output", split = FALSE)
[10:18:29.405]         if (TRUE) {
[10:18:29.405]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.405]         }
[10:18:29.405]         else {
[10:18:29.405]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.405]         }
[10:18:29.405]         base::close(...future.stdout)
[10:18:29.405]         ...future.stdout <- NULL
[10:18:29.405]     }
[10:18:29.405]     ...future.result$conditions <- ...future.conditions
[10:18:29.405]     ...future.result$finished <- base::Sys.time()
[10:18:29.405]     ...future.result
[10:18:29.405] }
[10:18:29.408] Exporting 5 global objects (1.03 KiB) to cluster node #1 ...
[10:18:29.408] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:29.408] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:29.409] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:18:29.409] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:18:29.409] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #1 ...
[10:18:29.410] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #1 ... DONE
[10:18:29.410] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:29.410] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:29.410] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:29.411] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:29.411] Exporting 5 global objects (1.03 KiB) to cluster node #1 ... DONE
[10:18:29.411] MultisessionFuture started
[10:18:29.411] - Launch lazy future ... done
[10:18:29.411] run() for ‘MultisessionFuture’ ... done
[10:18:29.412] Created future:
[10:18:29.412] MultisessionFuture:
[10:18:29.412] Label: ‘future_apply-1’
[10:18:29.412] Expression:
[10:18:29.412] {
[10:18:29.412]     do.call(function(...) {
[10:18:29.412]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.412]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.412]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.412]             on.exit(options(oopts), add = TRUE)
[10:18:29.412]         }
[10:18:29.412]         {
[10:18:29.412]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.412]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.412]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.412]             })
[10:18:29.412]         }
[10:18:29.412]     }, args = future.call.arguments)
[10:18:29.412] }
[10:18:29.412] Lazy evaluation: FALSE
[10:18:29.412] Asynchronous evaluation: TRUE
[10:18:29.412] Local evaluation: TRUE
[10:18:29.412] Environment: R_GlobalEnv
[10:18:29.412] Capture standard output: TRUE
[10:18:29.412] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.412] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.412] Packages: <none>
[10:18:29.412] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.412] Resolved: FALSE
[10:18:29.412] Value: <not collected>
[10:18:29.412] Conditions captured: <none>
[10:18:29.412] Early signaling: FALSE
[10:18:29.412] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.412] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.423] Chunk #1 of 2 ... DONE
[10:18:29.423] Chunk #2 of 2 ...
[10:18:29.423]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.423]  - seeds: <none>
[10:18:29.424]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.424] getGlobalsAndPackages() ...
[10:18:29.424] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.424] Resolving globals: FALSE
[10:18:29.424] Tweak future expression to call with '...' arguments ...
[10:18:29.424] {
[10:18:29.424]     do.call(function(...) {
[10:18:29.424]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.424]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.424]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.424]             on.exit(options(oopts), add = TRUE)
[10:18:29.424]         }
[10:18:29.424]         {
[10:18:29.424]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.424]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.424]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.424]             })
[10:18:29.424]         }
[10:18:29.424]     }, args = future.call.arguments)
[10:18:29.424] }
[10:18:29.424] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.425] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.425] 
[10:18:29.425] getGlobalsAndPackages() ... DONE
[10:18:29.425] run() for ‘Future’ ...
[10:18:29.425] - state: ‘created’
[10:18:29.425] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.439] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.440]   - Field: ‘node’
[10:18:29.440]   - Field: ‘label’
[10:18:29.440]   - Field: ‘local’
[10:18:29.440]   - Field: ‘owner’
[10:18:29.440]   - Field: ‘envir’
[10:18:29.440]   - Field: ‘workers’
[10:18:29.440]   - Field: ‘packages’
[10:18:29.440]   - Field: ‘gc’
[10:18:29.440]   - Field: ‘conditions’
[10:18:29.440]   - Field: ‘persistent’
[10:18:29.440]   - Field: ‘expr’
[10:18:29.441]   - Field: ‘uuid’
[10:18:29.441]   - Field: ‘seed’
[10:18:29.441]   - Field: ‘version’
[10:18:29.441]   - Field: ‘result’
[10:18:29.441]   - Field: ‘asynchronous’
[10:18:29.441]   - Field: ‘calls’
[10:18:29.441]   - Field: ‘globals’
[10:18:29.441]   - Field: ‘stdout’
[10:18:29.441]   - Field: ‘earlySignal’
[10:18:29.441]   - Field: ‘lazy’
[10:18:29.441]   - Field: ‘state’
[10:18:29.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.442] - Launch lazy future ...
[10:18:29.442] Packages needed by the future expression (n = 0): <none>
[10:18:29.442] Packages needed by future strategies (n = 0): <none>
[10:18:29.442] {
[10:18:29.442]     {
[10:18:29.442]         {
[10:18:29.442]             ...future.startTime <- base::Sys.time()
[10:18:29.442]             {
[10:18:29.442]                 {
[10:18:29.442]                   {
[10:18:29.442]                     {
[10:18:29.442]                       base::local({
[10:18:29.442]                         has_future <- base::requireNamespace("future", 
[10:18:29.442]                           quietly = TRUE)
[10:18:29.442]                         if (has_future) {
[10:18:29.442]                           ns <- base::getNamespace("future")
[10:18:29.442]                           version <- ns[[".package"]][["version"]]
[10:18:29.442]                           if (is.null(version)) 
[10:18:29.442]                             version <- utils::packageVersion("future")
[10:18:29.442]                         }
[10:18:29.442]                         else {
[10:18:29.442]                           version <- NULL
[10:18:29.442]                         }
[10:18:29.442]                         if (!has_future || version < "1.8.0") {
[10:18:29.442]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.442]                             "", base::R.version$version.string), 
[10:18:29.442]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.442]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.442]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.442]                               "release", "version")], collapse = " "), 
[10:18:29.442]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.442]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.442]                             info)
[10:18:29.442]                           info <- base::paste(info, collapse = "; ")
[10:18:29.442]                           if (!has_future) {
[10:18:29.442]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.442]                               info)
[10:18:29.442]                           }
[10:18:29.442]                           else {
[10:18:29.442]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.442]                               info, version)
[10:18:29.442]                           }
[10:18:29.442]                           base::stop(msg)
[10:18:29.442]                         }
[10:18:29.442]                       })
[10:18:29.442]                     }
[10:18:29.442]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.442]                     base::options(mc.cores = 1L)
[10:18:29.442]                   }
[10:18:29.442]                   ...future.strategy.old <- future::plan("list")
[10:18:29.442]                   options(future.plan = NULL)
[10:18:29.442]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.442]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.442]                 }
[10:18:29.442]                 ...future.workdir <- getwd()
[10:18:29.442]             }
[10:18:29.442]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.442]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.442]         }
[10:18:29.442]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.442]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.442]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.442]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.442]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.442]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.442]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.442]             base::names(...future.oldOptions))
[10:18:29.442]     }
[10:18:29.442]     if (FALSE) {
[10:18:29.442]     }
[10:18:29.442]     else {
[10:18:29.442]         if (TRUE) {
[10:18:29.442]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.442]                 open = "w")
[10:18:29.442]         }
[10:18:29.442]         else {
[10:18:29.442]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.442]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.442]         }
[10:18:29.442]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.442]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.442]             base::sink(type = "output", split = FALSE)
[10:18:29.442]             base::close(...future.stdout)
[10:18:29.442]         }, add = TRUE)
[10:18:29.442]     }
[10:18:29.442]     ...future.frame <- base::sys.nframe()
[10:18:29.442]     ...future.conditions <- base::list()
[10:18:29.442]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.442]     if (FALSE) {
[10:18:29.442]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.442]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.442]     }
[10:18:29.442]     ...future.result <- base::tryCatch({
[10:18:29.442]         base::withCallingHandlers({
[10:18:29.442]             ...future.value <- base::withVisible(base::local({
[10:18:29.442]                 ...future.makeSendCondition <- base::local({
[10:18:29.442]                   sendCondition <- NULL
[10:18:29.442]                   function(frame = 1L) {
[10:18:29.442]                     if (is.function(sendCondition)) 
[10:18:29.442]                       return(sendCondition)
[10:18:29.442]                     ns <- getNamespace("parallel")
[10:18:29.442]                     if (exists("sendData", mode = "function", 
[10:18:29.442]                       envir = ns)) {
[10:18:29.442]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.442]                         envir = ns)
[10:18:29.442]                       envir <- sys.frame(frame)
[10:18:29.442]                       master <- NULL
[10:18:29.442]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.442]                         !identical(envir, emptyenv())) {
[10:18:29.442]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.442]                           inherits = FALSE)) {
[10:18:29.442]                           master <- get("master", mode = "list", 
[10:18:29.442]                             envir = envir, inherits = FALSE)
[10:18:29.442]                           if (inherits(master, c("SOCKnode", 
[10:18:29.442]                             "SOCK0node"))) {
[10:18:29.442]                             sendCondition <<- function(cond) {
[10:18:29.442]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.442]                                 success = TRUE)
[10:18:29.442]                               parallel_sendData(master, data)
[10:18:29.442]                             }
[10:18:29.442]                             return(sendCondition)
[10:18:29.442]                           }
[10:18:29.442]                         }
[10:18:29.442]                         frame <- frame + 1L
[10:18:29.442]                         envir <- sys.frame(frame)
[10:18:29.442]                       }
[10:18:29.442]                     }
[10:18:29.442]                     sendCondition <<- function(cond) NULL
[10:18:29.442]                   }
[10:18:29.442]                 })
[10:18:29.442]                 withCallingHandlers({
[10:18:29.442]                   {
[10:18:29.442]                     do.call(function(...) {
[10:18:29.442]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.442]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.442]                         ...future.globals.maxSize)) {
[10:18:29.442]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.442]                         on.exit(options(oopts), add = TRUE)
[10:18:29.442]                       }
[10:18:29.442]                       {
[10:18:29.442]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.442]                           FUN = function(jj) {
[10:18:29.442]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.442]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.442]                           })
[10:18:29.442]                       }
[10:18:29.442]                     }, args = future.call.arguments)
[10:18:29.442]                   }
[10:18:29.442]                 }, immediateCondition = function(cond) {
[10:18:29.442]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.442]                   sendCondition(cond)
[10:18:29.442]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.442]                   {
[10:18:29.442]                     inherits <- base::inherits
[10:18:29.442]                     invokeRestart <- base::invokeRestart
[10:18:29.442]                     is.null <- base::is.null
[10:18:29.442]                     muffled <- FALSE
[10:18:29.442]                     if (inherits(cond, "message")) {
[10:18:29.442]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.442]                       if (muffled) 
[10:18:29.442]                         invokeRestart("muffleMessage")
[10:18:29.442]                     }
[10:18:29.442]                     else if (inherits(cond, "warning")) {
[10:18:29.442]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.442]                       if (muffled) 
[10:18:29.442]                         invokeRestart("muffleWarning")
[10:18:29.442]                     }
[10:18:29.442]                     else if (inherits(cond, "condition")) {
[10:18:29.442]                       if (!is.null(pattern)) {
[10:18:29.442]                         computeRestarts <- base::computeRestarts
[10:18:29.442]                         grepl <- base::grepl
[10:18:29.442]                         restarts <- computeRestarts(cond)
[10:18:29.442]                         for (restart in restarts) {
[10:18:29.442]                           name <- restart$name
[10:18:29.442]                           if (is.null(name)) 
[10:18:29.442]                             next
[10:18:29.442]                           if (!grepl(pattern, name)) 
[10:18:29.442]                             next
[10:18:29.442]                           invokeRestart(restart)
[10:18:29.442]                           muffled <- TRUE
[10:18:29.442]                           break
[10:18:29.442]                         }
[10:18:29.442]                       }
[10:18:29.442]                     }
[10:18:29.442]                     invisible(muffled)
[10:18:29.442]                   }
[10:18:29.442]                   muffleCondition(cond)
[10:18:29.442]                 })
[10:18:29.442]             }))
[10:18:29.442]             future::FutureResult(value = ...future.value$value, 
[10:18:29.442]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.442]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.442]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.442]                     ...future.globalenv.names))
[10:18:29.442]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.442]         }, condition = base::local({
[10:18:29.442]             c <- base::c
[10:18:29.442]             inherits <- base::inherits
[10:18:29.442]             invokeRestart <- base::invokeRestart
[10:18:29.442]             length <- base::length
[10:18:29.442]             list <- base::list
[10:18:29.442]             seq.int <- base::seq.int
[10:18:29.442]             signalCondition <- base::signalCondition
[10:18:29.442]             sys.calls <- base::sys.calls
[10:18:29.442]             `[[` <- base::`[[`
[10:18:29.442]             `+` <- base::`+`
[10:18:29.442]             `<<-` <- base::`<<-`
[10:18:29.442]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.442]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.442]                   3L)]
[10:18:29.442]             }
[10:18:29.442]             function(cond) {
[10:18:29.442]                 is_error <- inherits(cond, "error")
[10:18:29.442]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.442]                   NULL)
[10:18:29.442]                 if (is_error) {
[10:18:29.442]                   sessionInformation <- function() {
[10:18:29.442]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.442]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.442]                       search = base::search(), system = base::Sys.info())
[10:18:29.442]                   }
[10:18:29.442]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.442]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.442]                     cond$call), session = sessionInformation(), 
[10:18:29.442]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.442]                   signalCondition(cond)
[10:18:29.442]                 }
[10:18:29.442]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.442]                 "immediateCondition"))) {
[10:18:29.442]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.442]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.442]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.442]                   if (TRUE && !signal) {
[10:18:29.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.442]                     {
[10:18:29.442]                       inherits <- base::inherits
[10:18:29.442]                       invokeRestart <- base::invokeRestart
[10:18:29.442]                       is.null <- base::is.null
[10:18:29.442]                       muffled <- FALSE
[10:18:29.442]                       if (inherits(cond, "message")) {
[10:18:29.442]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.442]                         if (muffled) 
[10:18:29.442]                           invokeRestart("muffleMessage")
[10:18:29.442]                       }
[10:18:29.442]                       else if (inherits(cond, "warning")) {
[10:18:29.442]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.442]                         if (muffled) 
[10:18:29.442]                           invokeRestart("muffleWarning")
[10:18:29.442]                       }
[10:18:29.442]                       else if (inherits(cond, "condition")) {
[10:18:29.442]                         if (!is.null(pattern)) {
[10:18:29.442]                           computeRestarts <- base::computeRestarts
[10:18:29.442]                           grepl <- base::grepl
[10:18:29.442]                           restarts <- computeRestarts(cond)
[10:18:29.442]                           for (restart in restarts) {
[10:18:29.442]                             name <- restart$name
[10:18:29.442]                             if (is.null(name)) 
[10:18:29.442]                               next
[10:18:29.442]                             if (!grepl(pattern, name)) 
[10:18:29.442]                               next
[10:18:29.442]                             invokeRestart(restart)
[10:18:29.442]                             muffled <- TRUE
[10:18:29.442]                             break
[10:18:29.442]                           }
[10:18:29.442]                         }
[10:18:29.442]                       }
[10:18:29.442]                       invisible(muffled)
[10:18:29.442]                     }
[10:18:29.442]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.442]                   }
[10:18:29.442]                 }
[10:18:29.442]                 else {
[10:18:29.442]                   if (TRUE) {
[10:18:29.442]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.442]                     {
[10:18:29.442]                       inherits <- base::inherits
[10:18:29.442]                       invokeRestart <- base::invokeRestart
[10:18:29.442]                       is.null <- base::is.null
[10:18:29.442]                       muffled <- FALSE
[10:18:29.442]                       if (inherits(cond, "message")) {
[10:18:29.442]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.442]                         if (muffled) 
[10:18:29.442]                           invokeRestart("muffleMessage")
[10:18:29.442]                       }
[10:18:29.442]                       else if (inherits(cond, "warning")) {
[10:18:29.442]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.442]                         if (muffled) 
[10:18:29.442]                           invokeRestart("muffleWarning")
[10:18:29.442]                       }
[10:18:29.442]                       else if (inherits(cond, "condition")) {
[10:18:29.442]                         if (!is.null(pattern)) {
[10:18:29.442]                           computeRestarts <- base::computeRestarts
[10:18:29.442]                           grepl <- base::grepl
[10:18:29.442]                           restarts <- computeRestarts(cond)
[10:18:29.442]                           for (restart in restarts) {
[10:18:29.442]                             name <- restart$name
[10:18:29.442]                             if (is.null(name)) 
[10:18:29.442]                               next
[10:18:29.442]                             if (!grepl(pattern, name)) 
[10:18:29.442]                               next
[10:18:29.442]                             invokeRestart(restart)
[10:18:29.442]                             muffled <- TRUE
[10:18:29.442]                             break
[10:18:29.442]                           }
[10:18:29.442]                         }
[10:18:29.442]                       }
[10:18:29.442]                       invisible(muffled)
[10:18:29.442]                     }
[10:18:29.442]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.442]                   }
[10:18:29.442]                 }
[10:18:29.442]             }
[10:18:29.442]         }))
[10:18:29.442]     }, error = function(ex) {
[10:18:29.442]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.442]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.442]                 ...future.rng), started = ...future.startTime, 
[10:18:29.442]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.442]             version = "1.8"), class = "FutureResult")
[10:18:29.442]     }, finally = {
[10:18:29.442]         if (!identical(...future.workdir, getwd())) 
[10:18:29.442]             setwd(...future.workdir)
[10:18:29.442]         {
[10:18:29.442]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.442]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.442]             }
[10:18:29.442]             base::options(...future.oldOptions)
[10:18:29.442]             if (.Platform$OS.type == "windows") {
[10:18:29.442]                 old_names <- names(...future.oldEnvVars)
[10:18:29.442]                 envs <- base::Sys.getenv()
[10:18:29.442]                 names <- names(envs)
[10:18:29.442]                 common <- intersect(names, old_names)
[10:18:29.442]                 added <- setdiff(names, old_names)
[10:18:29.442]                 removed <- setdiff(old_names, names)
[10:18:29.442]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.442]                   envs[common]]
[10:18:29.442]                 NAMES <- toupper(changed)
[10:18:29.442]                 args <- list()
[10:18:29.442]                 for (kk in seq_along(NAMES)) {
[10:18:29.442]                   name <- changed[[kk]]
[10:18:29.442]                   NAME <- NAMES[[kk]]
[10:18:29.442]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.442]                     next
[10:18:29.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.442]                 }
[10:18:29.442]                 NAMES <- toupper(added)
[10:18:29.442]                 for (kk in seq_along(NAMES)) {
[10:18:29.442]                   name <- added[[kk]]
[10:18:29.442]                   NAME <- NAMES[[kk]]
[10:18:29.442]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.442]                     next
[10:18:29.442]                   args[[name]] <- ""
[10:18:29.442]                 }
[10:18:29.442]                 NAMES <- toupper(removed)
[10:18:29.442]                 for (kk in seq_along(NAMES)) {
[10:18:29.442]                   name <- removed[[kk]]
[10:18:29.442]                   NAME <- NAMES[[kk]]
[10:18:29.442]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.442]                     next
[10:18:29.442]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.442]                 }
[10:18:29.442]                 if (length(args) > 0) 
[10:18:29.442]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.442]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.442]             }
[10:18:29.442]             else {
[10:18:29.442]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.442]             }
[10:18:29.442]             {
[10:18:29.442]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.442]                   0L) {
[10:18:29.442]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.442]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.442]                   base::options(opts)
[10:18:29.442]                 }
[10:18:29.442]                 {
[10:18:29.442]                   {
[10:18:29.442]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.442]                     NULL
[10:18:29.442]                   }
[10:18:29.442]                   options(future.plan = NULL)
[10:18:29.442]                   if (is.na(NA_character_)) 
[10:18:29.442]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.442]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.442]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.442]                     .init = FALSE)
[10:18:29.442]                 }
[10:18:29.442]             }
[10:18:29.442]         }
[10:18:29.442]     })
[10:18:29.442]     if (TRUE) {
[10:18:29.442]         base::sink(type = "output", split = FALSE)
[10:18:29.442]         if (TRUE) {
[10:18:29.442]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.442]         }
[10:18:29.442]         else {
[10:18:29.442]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.442]         }
[10:18:29.442]         base::close(...future.stdout)
[10:18:29.442]         ...future.stdout <- NULL
[10:18:29.442]     }
[10:18:29.442]     ...future.result$conditions <- ...future.conditions
[10:18:29.442]     ...future.result$finished <- base::Sys.time()
[10:18:29.442]     ...future.result
[10:18:29.442] }
[10:18:29.445] Exporting 5 global objects (1.03 KiB) to cluster node #2 ...
[10:18:29.445] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:29.446] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:29.446] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:18:29.446] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:18:29.446] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #2 ...
[10:18:29.447] Exporting ‘...future.elements_ii’ (247 bytes) to cluster node #2 ... DONE
[10:18:29.447] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:29.447] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:29.447] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:29.448] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:29.448] Exporting 5 global objects (1.03 KiB) to cluster node #2 ... DONE
[10:18:29.448] MultisessionFuture started
[10:18:29.448] - Launch lazy future ... done
[10:18:29.448] run() for ‘MultisessionFuture’ ... done
[10:18:29.448] Created future:
[10:18:29.449] MultisessionFuture:
[10:18:29.449] Label: ‘future_apply-2’
[10:18:29.449] Expression:
[10:18:29.449] {
[10:18:29.449]     do.call(function(...) {
[10:18:29.449]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.449]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.449]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.449]             on.exit(options(oopts), add = TRUE)
[10:18:29.449]         }
[10:18:29.449]         {
[10:18:29.449]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.449]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.449]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.449]             })
[10:18:29.449]         }
[10:18:29.449]     }, args = future.call.arguments)
[10:18:29.449] }
[10:18:29.449] Lazy evaluation: FALSE
[10:18:29.449] Asynchronous evaluation: TRUE
[10:18:29.449] Local evaluation: TRUE
[10:18:29.449] Environment: R_GlobalEnv
[10:18:29.449] Capture standard output: TRUE
[10:18:29.449] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.449] Globals: 5 objects totaling 595 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 247 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.449] Packages: <none>
[10:18:29.449] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.449] Resolved: FALSE
[10:18:29.449] Value: <not collected>
[10:18:29.449] Conditions captured: <none>
[10:18:29.449] Early signaling: FALSE
[10:18:29.449] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.449] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.460] Chunk #2 of 2 ... DONE
[10:18:29.460] Launching 2 futures (chunks) ... DONE
[10:18:29.460] Resolving 2 futures (chunks) ...
[10:18:29.460] resolve() on list ...
[10:18:29.460]  recursive: 0
[10:18:29.461]  length: 2
[10:18:29.461] 
[10:18:29.461] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.461] - Validating connection of MultisessionFuture
[10:18:29.461] - received message: FutureResult
[10:18:29.462] - Received FutureResult
[10:18:29.462] - Erased future from FutureRegistry
[10:18:29.462] result() for ClusterFuture ...
[10:18:29.462] - result already collected: FutureResult
[10:18:29.462] result() for ClusterFuture ... done
[10:18:29.462] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.462] Future #1
[10:18:29.462] result() for ClusterFuture ...
[10:18:29.462] - result already collected: FutureResult
[10:18:29.462] result() for ClusterFuture ... done
[10:18:29.462] result() for ClusterFuture ...
[10:18:29.462] - result already collected: FutureResult
[10:18:29.463] result() for ClusterFuture ... done
[10:18:29.463] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:29.463] - nx: 2
[10:18:29.463] - relay: TRUE
[10:18:29.463] - stdout: TRUE
[10:18:29.463] - signal: TRUE
[10:18:29.463] - resignal: FALSE
[10:18:29.463] - force: TRUE
[10:18:29.463] - relayed: [n=2] FALSE, FALSE
[10:18:29.463] - queued futures: [n=2] FALSE, FALSE
[10:18:29.463]  - until=1
[10:18:29.463]  - relaying element #1
[10:18:29.464] result() for ClusterFuture ...
[10:18:29.464] - result already collected: FutureResult
[10:18:29.464] result() for ClusterFuture ... done
[10:18:29.464] result() for ClusterFuture ...
[10:18:29.464] - result already collected: FutureResult
[10:18:29.464] result() for ClusterFuture ... done
[10:18:29.464] result() for ClusterFuture ...
[10:18:29.464] - result already collected: FutureResult
[10:18:29.464] result() for ClusterFuture ... done
[10:18:29.464] result() for ClusterFuture ...
[10:18:29.464] - result already collected: FutureResult
[10:18:29.465] result() for ClusterFuture ... done
[10:18:29.465] - relayed: [n=2] TRUE, FALSE
[10:18:29.465] - queued futures: [n=2] TRUE, FALSE
[10:18:29.465] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:29.465]  length: 1 (resolved future 1)
[10:18:29.490] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.490] - Validating connection of MultisessionFuture
[10:18:29.490] - received message: FutureResult
[10:18:29.491] - Received FutureResult
[10:18:29.491] - Erased future from FutureRegistry
[10:18:29.491] result() for ClusterFuture ...
[10:18:29.491] - result already collected: FutureResult
[10:18:29.491] result() for ClusterFuture ... done
[10:18:29.491] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.491] Future #2
[10:18:29.491] result() for ClusterFuture ...
[10:18:29.491] - result already collected: FutureResult
[10:18:29.491] result() for ClusterFuture ... done
[10:18:29.492] result() for ClusterFuture ...
[10:18:29.492] - result already collected: FutureResult
[10:18:29.492] result() for ClusterFuture ... done
[10:18:29.492] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:29.492] - nx: 2
[10:18:29.492] - relay: TRUE
[10:18:29.492] - stdout: TRUE
[10:18:29.492] - signal: TRUE
[10:18:29.492] - resignal: FALSE
[10:18:29.492] - force: TRUE
[10:18:29.492] - relayed: [n=2] TRUE, FALSE
[10:18:29.493] - queued futures: [n=2] TRUE, FALSE
[10:18:29.493]  - until=2
[10:18:29.493]  - relaying element #2
[10:18:29.493] result() for ClusterFuture ...
[10:18:29.493] - result already collected: FutureResult
[10:18:29.493] result() for ClusterFuture ... done
[10:18:29.493] result() for ClusterFuture ...
[10:18:29.493] - result already collected: FutureResult
[10:18:29.493] result() for ClusterFuture ... done
[10:18:29.493] result() for ClusterFuture ...
[10:18:29.493] - result already collected: FutureResult
[10:18:29.494] result() for ClusterFuture ... done
[10:18:29.494] result() for ClusterFuture ...
[10:18:29.494] - result already collected: FutureResult
[10:18:29.494] result() for ClusterFuture ... done
[10:18:29.494] - relayed: [n=2] TRUE, TRUE
[10:18:29.494] - queued futures: [n=2] TRUE, TRUE
[10:18:29.494] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:29.494]  length: 0 (resolved future 2)
[10:18:29.494] Relaying remaining futures
[10:18:29.494] signalConditionsASAP(NULL, pos=0) ...
[10:18:29.494] - nx: 2
[10:18:29.494] - relay: TRUE
[10:18:29.495] - stdout: TRUE
[10:18:29.495] - signal: TRUE
[10:18:29.495] - resignal: FALSE
[10:18:29.495] - force: TRUE
[10:18:29.495] - relayed: [n=2] TRUE, TRUE
[10:18:29.495] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:29.495] - relayed: [n=2] TRUE, TRUE
[10:18:29.495] - queued futures: [n=2] TRUE, TRUE
[10:18:29.495] signalConditionsASAP(NULL, pos=0) ... done
[10:18:29.495] resolve() on list ... DONE
[10:18:29.495] result() for ClusterFuture ...
[10:18:29.495] - result already collected: FutureResult
[10:18:29.496] result() for ClusterFuture ... done
[10:18:29.496] result() for ClusterFuture ...
[10:18:29.496] - result already collected: FutureResult
[10:18:29.496] result() for ClusterFuture ... done
[10:18:29.496] result() for ClusterFuture ...
[10:18:29.496] - result already collected: FutureResult
[10:18:29.496] result() for ClusterFuture ... done
[10:18:29.496] result() for ClusterFuture ...
[10:18:29.496] - result already collected: FutureResult
[10:18:29.496] result() for ClusterFuture ... done
[10:18:29.496]  - Number of value chunks collected: 2
[10:18:29.496] Resolving 2 futures (chunks) ... DONE
[10:18:29.497] Reducing values from 2 chunks ...
[10:18:29.497]  - Number of values collected after concatenation: 6
[10:18:29.497]  - Number of values expected: 6
[10:18:29.497] Reducing values from 2 chunks ... DONE
[10:18:29.497] future_lapply() ... DONE
, , C = cop.1

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.2

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

, , C = cop.3

      col
row    x1 x2
  [1,]  3  4
  [2,]  3  3
  [3,]  3  2
  [4,]  3  1
  [5,]  3  2
  [6,]  3  3
  [7,]  3  4
  [8,]  3  5

[10:18:29.497] getGlobalsAndPackagesXApply() ...
[10:18:29.497]  - future.globals: TRUE
[10:18:29.497] getGlobalsAndPackages() ...
[10:18:29.498] Searching for globals...
[10:18:29.499] - globals found: [3] ‘FUN’, ‘seq_len’, ‘max’
[10:18:29.499] Searching for globals ... DONE
[10:18:29.499] Resolving globals: FALSE
[10:18:29.499] The total size of the 1 globals is 411 bytes (411 bytes)
[10:18:29.500] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:24, dim = 2:4))’) is 411 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (411 bytes of class ‘function’)
[10:18:29.500] - globals: [1] ‘FUN’
[10:18:29.500] 
[10:18:29.500] getGlobalsAndPackages() ... DONE
[10:18:29.500]  - globals found/used: [n=1] ‘FUN’
[10:18:29.500]  - needed namespaces: [n=0] 
[10:18:29.500] Finding globals ... DONE
[10:18:29.501]  - use_args: TRUE
[10:18:29.501]  - Getting '...' globals ...
[10:18:29.501] resolve() on list ...
[10:18:29.501]  recursive: 0
[10:18:29.501]  length: 1
[10:18:29.501]  elements: ‘...’
[10:18:29.501]  length: 0 (resolved future 1)
[10:18:29.501] resolve() on list ... DONE
[10:18:29.501]    - '...' content: [n=0] 
[10:18:29.502] List of 1
[10:18:29.502]  $ ...: list()
[10:18:29.502]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.502]  - attr(*, "where")=List of 1
[10:18:29.502]   ..$ ...:<environment: 0x556e0560c158> 
[10:18:29.502]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.502]  - attr(*, "resolved")= logi TRUE
[10:18:29.502]  - attr(*, "total_size")= num NA
[10:18:29.504]  - Getting '...' globals ... DONE
[10:18:29.504] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:29.504] List of 2
[10:18:29.504]  $ ...future.FUN:function (x)  
[10:18:29.504]  $ ...          : list()
[10:18:29.504]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.504]  - attr(*, "where")=List of 2
[10:18:29.504]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:29.504]   ..$ ...          :<environment: 0x556e0560c158> 
[10:18:29.504]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.504]  - attr(*, "resolved")= logi FALSE
[10:18:29.504]  - attr(*, "total_size")= num 3672
[10:18:29.507] Packages to be attached in all futures: [n=0] 
[10:18:29.507] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.508] future_lapply() ...
[10:18:29.510] Number of chunks: 2
[10:18:29.511] getGlobalsAndPackagesXApply() ...
[10:18:29.511]  - future.globals: <name-value list> with names ‘list()’
[10:18:29.511]  - use_args: TRUE
[10:18:29.511] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:29.511] List of 2
[10:18:29.511]  $ ...          : list()
[10:18:29.511]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.511]  $ ...future.FUN:function (x)  
[10:18:29.511]  - attr(*, "where")=List of 2
[10:18:29.511]   ..$ ...          :<environment: 0x556e0560c158> 
[10:18:29.511]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:18:29.511]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.511]  - attr(*, "resolved")= logi FALSE
[10:18:29.511]  - attr(*, "total_size")= num NA
[10:18:29.514] Packages to be attached in all futures: [n=0] 
[10:18:29.514] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.514] Number of futures (= number of chunks): 2
[10:18:29.514] Launching 2 futures (chunks) ...
[10:18:29.514] Chunk #1 of 2 ...
[10:18:29.514]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.514]  - seeds: <none>
[10:18:29.514]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.515] getGlobalsAndPackages() ...
[10:18:29.515] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.515] Resolving globals: FALSE
[10:18:29.515] Tweak future expression to call with '...' arguments ...
[10:18:29.515] {
[10:18:29.515]     do.call(function(...) {
[10:18:29.515]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.515]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.515]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.515]             on.exit(options(oopts), add = TRUE)
[10:18:29.515]         }
[10:18:29.515]         {
[10:18:29.515]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.515]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.515]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.515]             })
[10:18:29.515]         }
[10:18:29.515]     }, args = future.call.arguments)
[10:18:29.515] }
[10:18:29.515] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.516] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.516] 
[10:18:29.516] getGlobalsAndPackages() ... DONE
[10:18:29.516] run() for ‘Future’ ...
[10:18:29.516] - state: ‘created’
[10:18:29.516] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.530] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.530] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.531]   - Field: ‘node’
[10:18:29.531]   - Field: ‘label’
[10:18:29.531]   - Field: ‘local’
[10:18:29.531]   - Field: ‘owner’
[10:18:29.531]   - Field: ‘envir’
[10:18:29.531]   - Field: ‘workers’
[10:18:29.531]   - Field: ‘packages’
[10:18:29.531]   - Field: ‘gc’
[10:18:29.531]   - Field: ‘conditions’
[10:18:29.531]   - Field: ‘persistent’
[10:18:29.531]   - Field: ‘expr’
[10:18:29.532]   - Field: ‘uuid’
[10:18:29.532]   - Field: ‘seed’
[10:18:29.532]   - Field: ‘version’
[10:18:29.532]   - Field: ‘result’
[10:18:29.532]   - Field: ‘asynchronous’
[10:18:29.532]   - Field: ‘calls’
[10:18:29.534]   - Field: ‘globals’
[10:18:29.534]   - Field: ‘stdout’
[10:18:29.534]   - Field: ‘earlySignal’
[10:18:29.535]   - Field: ‘lazy’
[10:18:29.535]   - Field: ‘state’
[10:18:29.535] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.535] - Launch lazy future ...
[10:18:29.535] Packages needed by the future expression (n = 0): <none>
[10:18:29.535] Packages needed by future strategies (n = 0): <none>
[10:18:29.536] {
[10:18:29.536]     {
[10:18:29.536]         {
[10:18:29.536]             ...future.startTime <- base::Sys.time()
[10:18:29.536]             {
[10:18:29.536]                 {
[10:18:29.536]                   {
[10:18:29.536]                     {
[10:18:29.536]                       base::local({
[10:18:29.536]                         has_future <- base::requireNamespace("future", 
[10:18:29.536]                           quietly = TRUE)
[10:18:29.536]                         if (has_future) {
[10:18:29.536]                           ns <- base::getNamespace("future")
[10:18:29.536]                           version <- ns[[".package"]][["version"]]
[10:18:29.536]                           if (is.null(version)) 
[10:18:29.536]                             version <- utils::packageVersion("future")
[10:18:29.536]                         }
[10:18:29.536]                         else {
[10:18:29.536]                           version <- NULL
[10:18:29.536]                         }
[10:18:29.536]                         if (!has_future || version < "1.8.0") {
[10:18:29.536]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.536]                             "", base::R.version$version.string), 
[10:18:29.536]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.536]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.536]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.536]                               "release", "version")], collapse = " "), 
[10:18:29.536]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.536]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.536]                             info)
[10:18:29.536]                           info <- base::paste(info, collapse = "; ")
[10:18:29.536]                           if (!has_future) {
[10:18:29.536]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.536]                               info)
[10:18:29.536]                           }
[10:18:29.536]                           else {
[10:18:29.536]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.536]                               info, version)
[10:18:29.536]                           }
[10:18:29.536]                           base::stop(msg)
[10:18:29.536]                         }
[10:18:29.536]                       })
[10:18:29.536]                     }
[10:18:29.536]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.536]                     base::options(mc.cores = 1L)
[10:18:29.536]                   }
[10:18:29.536]                   ...future.strategy.old <- future::plan("list")
[10:18:29.536]                   options(future.plan = NULL)
[10:18:29.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.536]                 }
[10:18:29.536]                 ...future.workdir <- getwd()
[10:18:29.536]             }
[10:18:29.536]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.536]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.536]         }
[10:18:29.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.536]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.536]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.536]             base::names(...future.oldOptions))
[10:18:29.536]     }
[10:18:29.536]     if (FALSE) {
[10:18:29.536]     }
[10:18:29.536]     else {
[10:18:29.536]         if (TRUE) {
[10:18:29.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.536]                 open = "w")
[10:18:29.536]         }
[10:18:29.536]         else {
[10:18:29.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.536]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.536]         }
[10:18:29.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.536]             base::sink(type = "output", split = FALSE)
[10:18:29.536]             base::close(...future.stdout)
[10:18:29.536]         }, add = TRUE)
[10:18:29.536]     }
[10:18:29.536]     ...future.frame <- base::sys.nframe()
[10:18:29.536]     ...future.conditions <- base::list()
[10:18:29.536]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.536]     if (FALSE) {
[10:18:29.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.536]     }
[10:18:29.536]     ...future.result <- base::tryCatch({
[10:18:29.536]         base::withCallingHandlers({
[10:18:29.536]             ...future.value <- base::withVisible(base::local({
[10:18:29.536]                 ...future.makeSendCondition <- base::local({
[10:18:29.536]                   sendCondition <- NULL
[10:18:29.536]                   function(frame = 1L) {
[10:18:29.536]                     if (is.function(sendCondition)) 
[10:18:29.536]                       return(sendCondition)
[10:18:29.536]                     ns <- getNamespace("parallel")
[10:18:29.536]                     if (exists("sendData", mode = "function", 
[10:18:29.536]                       envir = ns)) {
[10:18:29.536]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.536]                         envir = ns)
[10:18:29.536]                       envir <- sys.frame(frame)
[10:18:29.536]                       master <- NULL
[10:18:29.536]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.536]                         !identical(envir, emptyenv())) {
[10:18:29.536]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.536]                           inherits = FALSE)) {
[10:18:29.536]                           master <- get("master", mode = "list", 
[10:18:29.536]                             envir = envir, inherits = FALSE)
[10:18:29.536]                           if (inherits(master, c("SOCKnode", 
[10:18:29.536]                             "SOCK0node"))) {
[10:18:29.536]                             sendCondition <<- function(cond) {
[10:18:29.536]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.536]                                 success = TRUE)
[10:18:29.536]                               parallel_sendData(master, data)
[10:18:29.536]                             }
[10:18:29.536]                             return(sendCondition)
[10:18:29.536]                           }
[10:18:29.536]                         }
[10:18:29.536]                         frame <- frame + 1L
[10:18:29.536]                         envir <- sys.frame(frame)
[10:18:29.536]                       }
[10:18:29.536]                     }
[10:18:29.536]                     sendCondition <<- function(cond) NULL
[10:18:29.536]                   }
[10:18:29.536]                 })
[10:18:29.536]                 withCallingHandlers({
[10:18:29.536]                   {
[10:18:29.536]                     do.call(function(...) {
[10:18:29.536]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.536]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.536]                         ...future.globals.maxSize)) {
[10:18:29.536]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.536]                         on.exit(options(oopts), add = TRUE)
[10:18:29.536]                       }
[10:18:29.536]                       {
[10:18:29.536]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.536]                           FUN = function(jj) {
[10:18:29.536]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.536]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.536]                           })
[10:18:29.536]                       }
[10:18:29.536]                     }, args = future.call.arguments)
[10:18:29.536]                   }
[10:18:29.536]                 }, immediateCondition = function(cond) {
[10:18:29.536]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.536]                   sendCondition(cond)
[10:18:29.536]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.536]                   {
[10:18:29.536]                     inherits <- base::inherits
[10:18:29.536]                     invokeRestart <- base::invokeRestart
[10:18:29.536]                     is.null <- base::is.null
[10:18:29.536]                     muffled <- FALSE
[10:18:29.536]                     if (inherits(cond, "message")) {
[10:18:29.536]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.536]                       if (muffled) 
[10:18:29.536]                         invokeRestart("muffleMessage")
[10:18:29.536]                     }
[10:18:29.536]                     else if (inherits(cond, "warning")) {
[10:18:29.536]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.536]                       if (muffled) 
[10:18:29.536]                         invokeRestart("muffleWarning")
[10:18:29.536]                     }
[10:18:29.536]                     else if (inherits(cond, "condition")) {
[10:18:29.536]                       if (!is.null(pattern)) {
[10:18:29.536]                         computeRestarts <- base::computeRestarts
[10:18:29.536]                         grepl <- base::grepl
[10:18:29.536]                         restarts <- computeRestarts(cond)
[10:18:29.536]                         for (restart in restarts) {
[10:18:29.536]                           name <- restart$name
[10:18:29.536]                           if (is.null(name)) 
[10:18:29.536]                             next
[10:18:29.536]                           if (!grepl(pattern, name)) 
[10:18:29.536]                             next
[10:18:29.536]                           invokeRestart(restart)
[10:18:29.536]                           muffled <- TRUE
[10:18:29.536]                           break
[10:18:29.536]                         }
[10:18:29.536]                       }
[10:18:29.536]                     }
[10:18:29.536]                     invisible(muffled)
[10:18:29.536]                   }
[10:18:29.536]                   muffleCondition(cond)
[10:18:29.536]                 })
[10:18:29.536]             }))
[10:18:29.536]             future::FutureResult(value = ...future.value$value, 
[10:18:29.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.536]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.536]                     ...future.globalenv.names))
[10:18:29.536]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.536]         }, condition = base::local({
[10:18:29.536]             c <- base::c
[10:18:29.536]             inherits <- base::inherits
[10:18:29.536]             invokeRestart <- base::invokeRestart
[10:18:29.536]             length <- base::length
[10:18:29.536]             list <- base::list
[10:18:29.536]             seq.int <- base::seq.int
[10:18:29.536]             signalCondition <- base::signalCondition
[10:18:29.536]             sys.calls <- base::sys.calls
[10:18:29.536]             `[[` <- base::`[[`
[10:18:29.536]             `+` <- base::`+`
[10:18:29.536]             `<<-` <- base::`<<-`
[10:18:29.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.536]                   3L)]
[10:18:29.536]             }
[10:18:29.536]             function(cond) {
[10:18:29.536]                 is_error <- inherits(cond, "error")
[10:18:29.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.536]                   NULL)
[10:18:29.536]                 if (is_error) {
[10:18:29.536]                   sessionInformation <- function() {
[10:18:29.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.536]                       search = base::search(), system = base::Sys.info())
[10:18:29.536]                   }
[10:18:29.536]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.536]                     cond$call), session = sessionInformation(), 
[10:18:29.536]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.536]                   signalCondition(cond)
[10:18:29.536]                 }
[10:18:29.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.536]                 "immediateCondition"))) {
[10:18:29.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.536]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.536]                   if (TRUE && !signal) {
[10:18:29.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.536]                     {
[10:18:29.536]                       inherits <- base::inherits
[10:18:29.536]                       invokeRestart <- base::invokeRestart
[10:18:29.536]                       is.null <- base::is.null
[10:18:29.536]                       muffled <- FALSE
[10:18:29.536]                       if (inherits(cond, "message")) {
[10:18:29.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.536]                         if (muffled) 
[10:18:29.536]                           invokeRestart("muffleMessage")
[10:18:29.536]                       }
[10:18:29.536]                       else if (inherits(cond, "warning")) {
[10:18:29.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.536]                         if (muffled) 
[10:18:29.536]                           invokeRestart("muffleWarning")
[10:18:29.536]                       }
[10:18:29.536]                       else if (inherits(cond, "condition")) {
[10:18:29.536]                         if (!is.null(pattern)) {
[10:18:29.536]                           computeRestarts <- base::computeRestarts
[10:18:29.536]                           grepl <- base::grepl
[10:18:29.536]                           restarts <- computeRestarts(cond)
[10:18:29.536]                           for (restart in restarts) {
[10:18:29.536]                             name <- restart$name
[10:18:29.536]                             if (is.null(name)) 
[10:18:29.536]                               next
[10:18:29.536]                             if (!grepl(pattern, name)) 
[10:18:29.536]                               next
[10:18:29.536]                             invokeRestart(restart)
[10:18:29.536]                             muffled <- TRUE
[10:18:29.536]                             break
[10:18:29.536]                           }
[10:18:29.536]                         }
[10:18:29.536]                       }
[10:18:29.536]                       invisible(muffled)
[10:18:29.536]                     }
[10:18:29.536]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.536]                   }
[10:18:29.536]                 }
[10:18:29.536]                 else {
[10:18:29.536]                   if (TRUE) {
[10:18:29.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.536]                     {
[10:18:29.536]                       inherits <- base::inherits
[10:18:29.536]                       invokeRestart <- base::invokeRestart
[10:18:29.536]                       is.null <- base::is.null
[10:18:29.536]                       muffled <- FALSE
[10:18:29.536]                       if (inherits(cond, "message")) {
[10:18:29.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.536]                         if (muffled) 
[10:18:29.536]                           invokeRestart("muffleMessage")
[10:18:29.536]                       }
[10:18:29.536]                       else if (inherits(cond, "warning")) {
[10:18:29.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.536]                         if (muffled) 
[10:18:29.536]                           invokeRestart("muffleWarning")
[10:18:29.536]                       }
[10:18:29.536]                       else if (inherits(cond, "condition")) {
[10:18:29.536]                         if (!is.null(pattern)) {
[10:18:29.536]                           computeRestarts <- base::computeRestarts
[10:18:29.536]                           grepl <- base::grepl
[10:18:29.536]                           restarts <- computeRestarts(cond)
[10:18:29.536]                           for (restart in restarts) {
[10:18:29.536]                             name <- restart$name
[10:18:29.536]                             if (is.null(name)) 
[10:18:29.536]                               next
[10:18:29.536]                             if (!grepl(pattern, name)) 
[10:18:29.536]                               next
[10:18:29.536]                             invokeRestart(restart)
[10:18:29.536]                             muffled <- TRUE
[10:18:29.536]                             break
[10:18:29.536]                           }
[10:18:29.536]                         }
[10:18:29.536]                       }
[10:18:29.536]                       invisible(muffled)
[10:18:29.536]                     }
[10:18:29.536]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.536]                   }
[10:18:29.536]                 }
[10:18:29.536]             }
[10:18:29.536]         }))
[10:18:29.536]     }, error = function(ex) {
[10:18:29.536]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.536]                 ...future.rng), started = ...future.startTime, 
[10:18:29.536]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.536]             version = "1.8"), class = "FutureResult")
[10:18:29.536]     }, finally = {
[10:18:29.536]         if (!identical(...future.workdir, getwd())) 
[10:18:29.536]             setwd(...future.workdir)
[10:18:29.536]         {
[10:18:29.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.536]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.536]             }
[10:18:29.536]             base::options(...future.oldOptions)
[10:18:29.536]             if (.Platform$OS.type == "windows") {
[10:18:29.536]                 old_names <- names(...future.oldEnvVars)
[10:18:29.536]                 envs <- base::Sys.getenv()
[10:18:29.536]                 names <- names(envs)
[10:18:29.536]                 common <- intersect(names, old_names)
[10:18:29.536]                 added <- setdiff(names, old_names)
[10:18:29.536]                 removed <- setdiff(old_names, names)
[10:18:29.536]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.536]                   envs[common]]
[10:18:29.536]                 NAMES <- toupper(changed)
[10:18:29.536]                 args <- list()
[10:18:29.536]                 for (kk in seq_along(NAMES)) {
[10:18:29.536]                   name <- changed[[kk]]
[10:18:29.536]                   NAME <- NAMES[[kk]]
[10:18:29.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.536]                     next
[10:18:29.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.536]                 }
[10:18:29.536]                 NAMES <- toupper(added)
[10:18:29.536]                 for (kk in seq_along(NAMES)) {
[10:18:29.536]                   name <- added[[kk]]
[10:18:29.536]                   NAME <- NAMES[[kk]]
[10:18:29.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.536]                     next
[10:18:29.536]                   args[[name]] <- ""
[10:18:29.536]                 }
[10:18:29.536]                 NAMES <- toupper(removed)
[10:18:29.536]                 for (kk in seq_along(NAMES)) {
[10:18:29.536]                   name <- removed[[kk]]
[10:18:29.536]                   NAME <- NAMES[[kk]]
[10:18:29.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.536]                     next
[10:18:29.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.536]                 }
[10:18:29.536]                 if (length(args) > 0) 
[10:18:29.536]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.536]             }
[10:18:29.536]             else {
[10:18:29.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.536]             }
[10:18:29.536]             {
[10:18:29.536]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.536]                   0L) {
[10:18:29.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.536]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.536]                   base::options(opts)
[10:18:29.536]                 }
[10:18:29.536]                 {
[10:18:29.536]                   {
[10:18:29.536]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.536]                     NULL
[10:18:29.536]                   }
[10:18:29.536]                   options(future.plan = NULL)
[10:18:29.536]                   if (is.na(NA_character_)) 
[10:18:29.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.536]                     .init = FALSE)
[10:18:29.536]                 }
[10:18:29.536]             }
[10:18:29.536]         }
[10:18:29.536]     })
[10:18:29.536]     if (TRUE) {
[10:18:29.536]         base::sink(type = "output", split = FALSE)
[10:18:29.536]         if (TRUE) {
[10:18:29.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.536]         }
[10:18:29.536]         else {
[10:18:29.536]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.536]         }
[10:18:29.536]         base::close(...future.stdout)
[10:18:29.536]         ...future.stdout <- NULL
[10:18:29.536]     }
[10:18:29.536]     ...future.result$conditions <- ...future.conditions
[10:18:29.536]     ...future.result$finished <- base::Sys.time()
[10:18:29.536]     ...future.result
[10:18:29.536] }
[10:18:29.539] Exporting 5 global objects (1.11 KiB) to cluster node #1 ...
[10:18:29.539] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:29.539] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:29.539] Exporting ‘...future.FUN’ (411 bytes) to cluster node #1 ...
[10:18:29.540] Exporting ‘...future.FUN’ (411 bytes) to cluster node #1 ... DONE
[10:18:29.540] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ...
[10:18:29.540] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #1 ... DONE
[10:18:29.540] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:29.541] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:29.541] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:29.541] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:29.541] Exporting 5 global objects (1.11 KiB) to cluster node #1 ... DONE
[10:18:29.542] MultisessionFuture started
[10:18:29.542] - Launch lazy future ... done
[10:18:29.542] run() for ‘MultisessionFuture’ ... done
[10:18:29.542] Created future:
[10:18:29.542] MultisessionFuture:
[10:18:29.542] Label: ‘future_apply-1’
[10:18:29.542] Expression:
[10:18:29.542] {
[10:18:29.542]     do.call(function(...) {
[10:18:29.542]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.542]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.542]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.542]             on.exit(options(oopts), add = TRUE)
[10:18:29.542]         }
[10:18:29.542]         {
[10:18:29.542]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.542]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.542]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.542]             })
[10:18:29.542]         }
[10:18:29.542]     }, args = future.call.arguments)
[10:18:29.542] }
[10:18:29.542] Lazy evaluation: FALSE
[10:18:29.542] Asynchronous evaluation: TRUE
[10:18:29.542] Local evaluation: TRUE
[10:18:29.542] Environment: R_GlobalEnv
[10:18:29.542] Capture standard output: TRUE
[10:18:29.542] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.542] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.542] Packages: <none>
[10:18:29.542] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.542] Resolved: FALSE
[10:18:29.542] Value: <not collected>
[10:18:29.542] Conditions captured: <none>
[10:18:29.542] Early signaling: FALSE
[10:18:29.542] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.542] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.554] Chunk #1 of 2 ... DONE
[10:18:29.554] Chunk #2 of 2 ...
[10:18:29.554]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.554]  - seeds: <none>
[10:18:29.554]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.554] getGlobalsAndPackages() ...
[10:18:29.554] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.554] Resolving globals: FALSE
[10:18:29.554] Tweak future expression to call with '...' arguments ...
[10:18:29.555] {
[10:18:29.555]     do.call(function(...) {
[10:18:29.555]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.555]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.555]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.555]             on.exit(options(oopts), add = TRUE)
[10:18:29.555]         }
[10:18:29.555]         {
[10:18:29.555]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.555]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.555]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.555]             })
[10:18:29.555]         }
[10:18:29.555]     }, args = future.call.arguments)
[10:18:29.555] }
[10:18:29.555] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.555] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.555] 
[10:18:29.555] getGlobalsAndPackages() ... DONE
[10:18:29.556] run() for ‘Future’ ...
[10:18:29.556] - state: ‘created’
[10:18:29.556] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.570] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.570]   - Field: ‘node’
[10:18:29.570]   - Field: ‘label’
[10:18:29.570]   - Field: ‘local’
[10:18:29.570]   - Field: ‘owner’
[10:18:29.571]   - Field: ‘envir’
[10:18:29.571]   - Field: ‘workers’
[10:18:29.571]   - Field: ‘packages’
[10:18:29.571]   - Field: ‘gc’
[10:18:29.571]   - Field: ‘conditions’
[10:18:29.571]   - Field: ‘persistent’
[10:18:29.571]   - Field: ‘expr’
[10:18:29.571]   - Field: ‘uuid’
[10:18:29.571]   - Field: ‘seed’
[10:18:29.571]   - Field: ‘version’
[10:18:29.571]   - Field: ‘result’
[10:18:29.571]   - Field: ‘asynchronous’
[10:18:29.572]   - Field: ‘calls’
[10:18:29.572]   - Field: ‘globals’
[10:18:29.572]   - Field: ‘stdout’
[10:18:29.572]   - Field: ‘earlySignal’
[10:18:29.572]   - Field: ‘lazy’
[10:18:29.572]   - Field: ‘state’
[10:18:29.572] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.572] - Launch lazy future ...
[10:18:29.572] Packages needed by the future expression (n = 0): <none>
[10:18:29.573] Packages needed by future strategies (n = 0): <none>
[10:18:29.573] {
[10:18:29.573]     {
[10:18:29.573]         {
[10:18:29.573]             ...future.startTime <- base::Sys.time()
[10:18:29.573]             {
[10:18:29.573]                 {
[10:18:29.573]                   {
[10:18:29.573]                     {
[10:18:29.573]                       base::local({
[10:18:29.573]                         has_future <- base::requireNamespace("future", 
[10:18:29.573]                           quietly = TRUE)
[10:18:29.573]                         if (has_future) {
[10:18:29.573]                           ns <- base::getNamespace("future")
[10:18:29.573]                           version <- ns[[".package"]][["version"]]
[10:18:29.573]                           if (is.null(version)) 
[10:18:29.573]                             version <- utils::packageVersion("future")
[10:18:29.573]                         }
[10:18:29.573]                         else {
[10:18:29.573]                           version <- NULL
[10:18:29.573]                         }
[10:18:29.573]                         if (!has_future || version < "1.8.0") {
[10:18:29.573]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.573]                             "", base::R.version$version.string), 
[10:18:29.573]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.573]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.573]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.573]                               "release", "version")], collapse = " "), 
[10:18:29.573]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.573]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.573]                             info)
[10:18:29.573]                           info <- base::paste(info, collapse = "; ")
[10:18:29.573]                           if (!has_future) {
[10:18:29.573]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.573]                               info)
[10:18:29.573]                           }
[10:18:29.573]                           else {
[10:18:29.573]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.573]                               info, version)
[10:18:29.573]                           }
[10:18:29.573]                           base::stop(msg)
[10:18:29.573]                         }
[10:18:29.573]                       })
[10:18:29.573]                     }
[10:18:29.573]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.573]                     base::options(mc.cores = 1L)
[10:18:29.573]                   }
[10:18:29.573]                   ...future.strategy.old <- future::plan("list")
[10:18:29.573]                   options(future.plan = NULL)
[10:18:29.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.573]                 }
[10:18:29.573]                 ...future.workdir <- getwd()
[10:18:29.573]             }
[10:18:29.573]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.573]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.573]         }
[10:18:29.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.573]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.573]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.573]             base::names(...future.oldOptions))
[10:18:29.573]     }
[10:18:29.573]     if (FALSE) {
[10:18:29.573]     }
[10:18:29.573]     else {
[10:18:29.573]         if (TRUE) {
[10:18:29.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.573]                 open = "w")
[10:18:29.573]         }
[10:18:29.573]         else {
[10:18:29.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.573]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.573]         }
[10:18:29.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.573]             base::sink(type = "output", split = FALSE)
[10:18:29.573]             base::close(...future.stdout)
[10:18:29.573]         }, add = TRUE)
[10:18:29.573]     }
[10:18:29.573]     ...future.frame <- base::sys.nframe()
[10:18:29.573]     ...future.conditions <- base::list()
[10:18:29.573]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.573]     if (FALSE) {
[10:18:29.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.573]     }
[10:18:29.573]     ...future.result <- base::tryCatch({
[10:18:29.573]         base::withCallingHandlers({
[10:18:29.573]             ...future.value <- base::withVisible(base::local({
[10:18:29.573]                 ...future.makeSendCondition <- base::local({
[10:18:29.573]                   sendCondition <- NULL
[10:18:29.573]                   function(frame = 1L) {
[10:18:29.573]                     if (is.function(sendCondition)) 
[10:18:29.573]                       return(sendCondition)
[10:18:29.573]                     ns <- getNamespace("parallel")
[10:18:29.573]                     if (exists("sendData", mode = "function", 
[10:18:29.573]                       envir = ns)) {
[10:18:29.573]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.573]                         envir = ns)
[10:18:29.573]                       envir <- sys.frame(frame)
[10:18:29.573]                       master <- NULL
[10:18:29.573]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.573]                         !identical(envir, emptyenv())) {
[10:18:29.573]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.573]                           inherits = FALSE)) {
[10:18:29.573]                           master <- get("master", mode = "list", 
[10:18:29.573]                             envir = envir, inherits = FALSE)
[10:18:29.573]                           if (inherits(master, c("SOCKnode", 
[10:18:29.573]                             "SOCK0node"))) {
[10:18:29.573]                             sendCondition <<- function(cond) {
[10:18:29.573]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.573]                                 success = TRUE)
[10:18:29.573]                               parallel_sendData(master, data)
[10:18:29.573]                             }
[10:18:29.573]                             return(sendCondition)
[10:18:29.573]                           }
[10:18:29.573]                         }
[10:18:29.573]                         frame <- frame + 1L
[10:18:29.573]                         envir <- sys.frame(frame)
[10:18:29.573]                       }
[10:18:29.573]                     }
[10:18:29.573]                     sendCondition <<- function(cond) NULL
[10:18:29.573]                   }
[10:18:29.573]                 })
[10:18:29.573]                 withCallingHandlers({
[10:18:29.573]                   {
[10:18:29.573]                     do.call(function(...) {
[10:18:29.573]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.573]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.573]                         ...future.globals.maxSize)) {
[10:18:29.573]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.573]                         on.exit(options(oopts), add = TRUE)
[10:18:29.573]                       }
[10:18:29.573]                       {
[10:18:29.573]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.573]                           FUN = function(jj) {
[10:18:29.573]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.573]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.573]                           })
[10:18:29.573]                       }
[10:18:29.573]                     }, args = future.call.arguments)
[10:18:29.573]                   }
[10:18:29.573]                 }, immediateCondition = function(cond) {
[10:18:29.573]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.573]                   sendCondition(cond)
[10:18:29.573]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.573]                   {
[10:18:29.573]                     inherits <- base::inherits
[10:18:29.573]                     invokeRestart <- base::invokeRestart
[10:18:29.573]                     is.null <- base::is.null
[10:18:29.573]                     muffled <- FALSE
[10:18:29.573]                     if (inherits(cond, "message")) {
[10:18:29.573]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.573]                       if (muffled) 
[10:18:29.573]                         invokeRestart("muffleMessage")
[10:18:29.573]                     }
[10:18:29.573]                     else if (inherits(cond, "warning")) {
[10:18:29.573]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.573]                       if (muffled) 
[10:18:29.573]                         invokeRestart("muffleWarning")
[10:18:29.573]                     }
[10:18:29.573]                     else if (inherits(cond, "condition")) {
[10:18:29.573]                       if (!is.null(pattern)) {
[10:18:29.573]                         computeRestarts <- base::computeRestarts
[10:18:29.573]                         grepl <- base::grepl
[10:18:29.573]                         restarts <- computeRestarts(cond)
[10:18:29.573]                         for (restart in restarts) {
[10:18:29.573]                           name <- restart$name
[10:18:29.573]                           if (is.null(name)) 
[10:18:29.573]                             next
[10:18:29.573]                           if (!grepl(pattern, name)) 
[10:18:29.573]                             next
[10:18:29.573]                           invokeRestart(restart)
[10:18:29.573]                           muffled <- TRUE
[10:18:29.573]                           break
[10:18:29.573]                         }
[10:18:29.573]                       }
[10:18:29.573]                     }
[10:18:29.573]                     invisible(muffled)
[10:18:29.573]                   }
[10:18:29.573]                   muffleCondition(cond)
[10:18:29.573]                 })
[10:18:29.573]             }))
[10:18:29.573]             future::FutureResult(value = ...future.value$value, 
[10:18:29.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.573]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.573]                     ...future.globalenv.names))
[10:18:29.573]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.573]         }, condition = base::local({
[10:18:29.573]             c <- base::c
[10:18:29.573]             inherits <- base::inherits
[10:18:29.573]             invokeRestart <- base::invokeRestart
[10:18:29.573]             length <- base::length
[10:18:29.573]             list <- base::list
[10:18:29.573]             seq.int <- base::seq.int
[10:18:29.573]             signalCondition <- base::signalCondition
[10:18:29.573]             sys.calls <- base::sys.calls
[10:18:29.573]             `[[` <- base::`[[`
[10:18:29.573]             `+` <- base::`+`
[10:18:29.573]             `<<-` <- base::`<<-`
[10:18:29.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.573]                   3L)]
[10:18:29.573]             }
[10:18:29.573]             function(cond) {
[10:18:29.573]                 is_error <- inherits(cond, "error")
[10:18:29.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.573]                   NULL)
[10:18:29.573]                 if (is_error) {
[10:18:29.573]                   sessionInformation <- function() {
[10:18:29.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.573]                       search = base::search(), system = base::Sys.info())
[10:18:29.573]                   }
[10:18:29.573]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.573]                     cond$call), session = sessionInformation(), 
[10:18:29.573]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.573]                   signalCondition(cond)
[10:18:29.573]                 }
[10:18:29.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.573]                 "immediateCondition"))) {
[10:18:29.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.573]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.573]                   if (TRUE && !signal) {
[10:18:29.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.573]                     {
[10:18:29.573]                       inherits <- base::inherits
[10:18:29.573]                       invokeRestart <- base::invokeRestart
[10:18:29.573]                       is.null <- base::is.null
[10:18:29.573]                       muffled <- FALSE
[10:18:29.573]                       if (inherits(cond, "message")) {
[10:18:29.573]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.573]                         if (muffled) 
[10:18:29.573]                           invokeRestart("muffleMessage")
[10:18:29.573]                       }
[10:18:29.573]                       else if (inherits(cond, "warning")) {
[10:18:29.573]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.573]                         if (muffled) 
[10:18:29.573]                           invokeRestart("muffleWarning")
[10:18:29.573]                       }
[10:18:29.573]                       else if (inherits(cond, "condition")) {
[10:18:29.573]                         if (!is.null(pattern)) {
[10:18:29.573]                           computeRestarts <- base::computeRestarts
[10:18:29.573]                           grepl <- base::grepl
[10:18:29.573]                           restarts <- computeRestarts(cond)
[10:18:29.573]                           for (restart in restarts) {
[10:18:29.573]                             name <- restart$name
[10:18:29.573]                             if (is.null(name)) 
[10:18:29.573]                               next
[10:18:29.573]                             if (!grepl(pattern, name)) 
[10:18:29.573]                               next
[10:18:29.573]                             invokeRestart(restart)
[10:18:29.573]                             muffled <- TRUE
[10:18:29.573]                             break
[10:18:29.573]                           }
[10:18:29.573]                         }
[10:18:29.573]                       }
[10:18:29.573]                       invisible(muffled)
[10:18:29.573]                     }
[10:18:29.573]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.573]                   }
[10:18:29.573]                 }
[10:18:29.573]                 else {
[10:18:29.573]                   if (TRUE) {
[10:18:29.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.573]                     {
[10:18:29.573]                       inherits <- base::inherits
[10:18:29.573]                       invokeRestart <- base::invokeRestart
[10:18:29.573]                       is.null <- base::is.null
[10:18:29.573]                       muffled <- FALSE
[10:18:29.573]                       if (inherits(cond, "message")) {
[10:18:29.573]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.573]                         if (muffled) 
[10:18:29.573]                           invokeRestart("muffleMessage")
[10:18:29.573]                       }
[10:18:29.573]                       else if (inherits(cond, "warning")) {
[10:18:29.573]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.573]                         if (muffled) 
[10:18:29.573]                           invokeRestart("muffleWarning")
[10:18:29.573]                       }
[10:18:29.573]                       else if (inherits(cond, "condition")) {
[10:18:29.573]                         if (!is.null(pattern)) {
[10:18:29.573]                           computeRestarts <- base::computeRestarts
[10:18:29.573]                           grepl <- base::grepl
[10:18:29.573]                           restarts <- computeRestarts(cond)
[10:18:29.573]                           for (restart in restarts) {
[10:18:29.573]                             name <- restart$name
[10:18:29.573]                             if (is.null(name)) 
[10:18:29.573]                               next
[10:18:29.573]                             if (!grepl(pattern, name)) 
[10:18:29.573]                               next
[10:18:29.573]                             invokeRestart(restart)
[10:18:29.573]                             muffled <- TRUE
[10:18:29.573]                             break
[10:18:29.573]                           }
[10:18:29.573]                         }
[10:18:29.573]                       }
[10:18:29.573]                       invisible(muffled)
[10:18:29.573]                     }
[10:18:29.573]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.573]                   }
[10:18:29.573]                 }
[10:18:29.573]             }
[10:18:29.573]         }))
[10:18:29.573]     }, error = function(ex) {
[10:18:29.573]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.573]                 ...future.rng), started = ...future.startTime, 
[10:18:29.573]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.573]             version = "1.8"), class = "FutureResult")
[10:18:29.573]     }, finally = {
[10:18:29.573]         if (!identical(...future.workdir, getwd())) 
[10:18:29.573]             setwd(...future.workdir)
[10:18:29.573]         {
[10:18:29.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.573]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.573]             }
[10:18:29.573]             base::options(...future.oldOptions)
[10:18:29.573]             if (.Platform$OS.type == "windows") {
[10:18:29.573]                 old_names <- names(...future.oldEnvVars)
[10:18:29.573]                 envs <- base::Sys.getenv()
[10:18:29.573]                 names <- names(envs)
[10:18:29.573]                 common <- intersect(names, old_names)
[10:18:29.573]                 added <- setdiff(names, old_names)
[10:18:29.573]                 removed <- setdiff(old_names, names)
[10:18:29.573]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.573]                   envs[common]]
[10:18:29.573]                 NAMES <- toupper(changed)
[10:18:29.573]                 args <- list()
[10:18:29.573]                 for (kk in seq_along(NAMES)) {
[10:18:29.573]                   name <- changed[[kk]]
[10:18:29.573]                   NAME <- NAMES[[kk]]
[10:18:29.573]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.573]                     next
[10:18:29.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.573]                 }
[10:18:29.573]                 NAMES <- toupper(added)
[10:18:29.573]                 for (kk in seq_along(NAMES)) {
[10:18:29.573]                   name <- added[[kk]]
[10:18:29.573]                   NAME <- NAMES[[kk]]
[10:18:29.573]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.573]                     next
[10:18:29.573]                   args[[name]] <- ""
[10:18:29.573]                 }
[10:18:29.573]                 NAMES <- toupper(removed)
[10:18:29.573]                 for (kk in seq_along(NAMES)) {
[10:18:29.573]                   name <- removed[[kk]]
[10:18:29.573]                   NAME <- NAMES[[kk]]
[10:18:29.573]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.573]                     next
[10:18:29.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.573]                 }
[10:18:29.573]                 if (length(args) > 0) 
[10:18:29.573]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.573]             }
[10:18:29.573]             else {
[10:18:29.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.573]             }
[10:18:29.573]             {
[10:18:29.573]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.573]                   0L) {
[10:18:29.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.573]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.573]                   base::options(opts)
[10:18:29.573]                 }
[10:18:29.573]                 {
[10:18:29.573]                   {
[10:18:29.573]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.573]                     NULL
[10:18:29.573]                   }
[10:18:29.573]                   options(future.plan = NULL)
[10:18:29.573]                   if (is.na(NA_character_)) 
[10:18:29.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.573]                     .init = FALSE)
[10:18:29.573]                 }
[10:18:29.573]             }
[10:18:29.573]         }
[10:18:29.573]     })
[10:18:29.573]     if (TRUE) {
[10:18:29.573]         base::sink(type = "output", split = FALSE)
[10:18:29.573]         if (TRUE) {
[10:18:29.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.573]         }
[10:18:29.573]         else {
[10:18:29.573]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.573]         }
[10:18:29.573]         base::close(...future.stdout)
[10:18:29.573]         ...future.stdout <- NULL
[10:18:29.573]     }
[10:18:29.573]     ...future.result$conditions <- ...future.conditions
[10:18:29.573]     ...future.result$finished <- base::Sys.time()
[10:18:29.573]     ...future.result
[10:18:29.573] }
[10:18:29.576] Exporting 5 global objects (1.11 KiB) to cluster node #2 ...
[10:18:29.576] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:29.576] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:29.576] Exporting ‘...future.FUN’ (411 bytes) to cluster node #2 ...
[10:18:29.577] Exporting ‘...future.FUN’ (411 bytes) to cluster node #2 ... DONE
[10:18:29.577] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ...
[10:18:29.577] Exporting ‘...future.elements_ii’ (103 bytes) to cluster node #2 ... DONE
[10:18:29.577] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:29.578] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:29.578] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:29.578] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:29.578] Exporting 5 global objects (1.11 KiB) to cluster node #2 ... DONE
[10:18:29.579] MultisessionFuture started
[10:18:29.579] - Launch lazy future ... done
[10:18:29.579] run() for ‘MultisessionFuture’ ... done
[10:18:29.579] Created future:
[10:18:29.579] MultisessionFuture:
[10:18:29.579] Label: ‘future_apply-2’
[10:18:29.579] Expression:
[10:18:29.579] {
[10:18:29.579]     do.call(function(...) {
[10:18:29.579]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.579]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.579]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.579]             on.exit(options(oopts), add = TRUE)
[10:18:29.579]         }
[10:18:29.579]         {
[10:18:29.579]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.579]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.579]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.579]             })
[10:18:29.579]         }
[10:18:29.579]     }, args = future.call.arguments)
[10:18:29.579] }
[10:18:29.579] Lazy evaluation: FALSE
[10:18:29.579] Asynchronous evaluation: TRUE
[10:18:29.579] Local evaluation: TRUE
[10:18:29.579] Environment: R_GlobalEnv
[10:18:29.579] Capture standard output: TRUE
[10:18:29.579] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.579] Globals: 5 objects totaling 677 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 411 bytes, list ‘...future.elements_ii’ of 103 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.579] Packages: <none>
[10:18:29.579] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.579] Resolved: FALSE
[10:18:29.579] Value: <not collected>
[10:18:29.579] Conditions captured: <none>
[10:18:29.579] Early signaling: FALSE
[10:18:29.579] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.579] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.591] Chunk #2 of 2 ... DONE
[10:18:29.591] Launching 2 futures (chunks) ... DONE
[10:18:29.591] Resolving 2 futures (chunks) ...
[10:18:29.591] resolve() on list ...
[10:18:29.591]  recursive: 0
[10:18:29.591]  length: 2
[10:18:29.591] 
[10:18:29.592] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.592] - Validating connection of MultisessionFuture
[10:18:29.592] - received message: FutureResult
[10:18:29.592] - Received FutureResult
[10:18:29.592] - Erased future from FutureRegistry
[10:18:29.592] result() for ClusterFuture ...
[10:18:29.593] - result already collected: FutureResult
[10:18:29.593] result() for ClusterFuture ... done
[10:18:29.593] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.593] Future #1
[10:18:29.593] result() for ClusterFuture ...
[10:18:29.593] - result already collected: FutureResult
[10:18:29.593] result() for ClusterFuture ... done
[10:18:29.593] result() for ClusterFuture ...
[10:18:29.593] - result already collected: FutureResult
[10:18:29.593] result() for ClusterFuture ... done
[10:18:29.593] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:29.593] - nx: 2
[10:18:29.594] - relay: TRUE
[10:18:29.594] - stdout: TRUE
[10:18:29.594] - signal: TRUE
[10:18:29.594] - resignal: FALSE
[10:18:29.594] - force: TRUE
[10:18:29.594] - relayed: [n=2] FALSE, FALSE
[10:18:29.594] - queued futures: [n=2] FALSE, FALSE
[10:18:29.594]  - until=1
[10:18:29.594]  - relaying element #1
[10:18:29.594] result() for ClusterFuture ...
[10:18:29.594] - result already collected: FutureResult
[10:18:29.594] result() for ClusterFuture ... done
[10:18:29.595] result() for ClusterFuture ...
[10:18:29.595] - result already collected: FutureResult
[10:18:29.595] result() for ClusterFuture ... done
[10:18:29.595] result() for ClusterFuture ...
[10:18:29.595] - result already collected: FutureResult
[10:18:29.595] result() for ClusterFuture ... done
[10:18:29.595] result() for ClusterFuture ...
[10:18:29.595] - result already collected: FutureResult
[10:18:29.595] result() for ClusterFuture ... done
[10:18:29.595] - relayed: [n=2] TRUE, FALSE
[10:18:29.595] - queued futures: [n=2] TRUE, FALSE
[10:18:29.596] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:29.596]  length: 1 (resolved future 1)
[10:18:29.621] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.621] - Validating connection of MultisessionFuture
[10:18:29.622] - received message: FutureResult
[10:18:29.622] - Received FutureResult
[10:18:29.622] - Erased future from FutureRegistry
[10:18:29.622] result() for ClusterFuture ...
[10:18:29.622] - result already collected: FutureResult
[10:18:29.622] result() for ClusterFuture ... done
[10:18:29.622] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.622] Future #2
[10:18:29.623] result() for ClusterFuture ...
[10:18:29.623] - result already collected: FutureResult
[10:18:29.623] result() for ClusterFuture ... done
[10:18:29.623] result() for ClusterFuture ...
[10:18:29.623] - result already collected: FutureResult
[10:18:29.623] result() for ClusterFuture ... done
[10:18:29.623] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:29.623] - nx: 2
[10:18:29.623] - relay: TRUE
[10:18:29.623] - stdout: TRUE
[10:18:29.623] - signal: TRUE
[10:18:29.624] - resignal: FALSE
[10:18:29.624] - force: TRUE
[10:18:29.624] - relayed: [n=2] TRUE, FALSE
[10:18:29.624] - queued futures: [n=2] TRUE, FALSE
[10:18:29.624]  - until=2
[10:18:29.624]  - relaying element #2
[10:18:29.624] result() for ClusterFuture ...
[10:18:29.624] - result already collected: FutureResult
[10:18:29.624] result() for ClusterFuture ... done
[10:18:29.624] result() for ClusterFuture ...
[10:18:29.624] - result already collected: FutureResult
[10:18:29.624] result() for ClusterFuture ... done
[10:18:29.625] result() for ClusterFuture ...
[10:18:29.625] - result already collected: FutureResult
[10:18:29.625] result() for ClusterFuture ... done
[10:18:29.625] result() for ClusterFuture ...
[10:18:29.625] - result already collected: FutureResult
[10:18:29.625] result() for ClusterFuture ... done
[10:18:29.625] - relayed: [n=2] TRUE, TRUE
[10:18:29.625] - queued futures: [n=2] TRUE, TRUE
[10:18:29.625] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:29.625]  length: 0 (resolved future 2)
[10:18:29.625] Relaying remaining futures
[10:18:29.626] signalConditionsASAP(NULL, pos=0) ...
[10:18:29.626] - nx: 2
[10:18:29.626] - relay: TRUE
[10:18:29.626] - stdout: TRUE
[10:18:29.626] - signal: TRUE
[10:18:29.626] - resignal: FALSE
[10:18:29.626] - force: TRUE
[10:18:29.626] - relayed: [n=2] TRUE, TRUE
[10:18:29.626] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:29.626] - relayed: [n=2] TRUE, TRUE
[10:18:29.626] - queued futures: [n=2] TRUE, TRUE
[10:18:29.626] signalConditionsASAP(NULL, pos=0) ... done
[10:18:29.627] resolve() on list ... DONE
[10:18:29.627] result() for ClusterFuture ...
[10:18:29.627] - result already collected: FutureResult
[10:18:29.627] result() for ClusterFuture ... done
[10:18:29.627] result() for ClusterFuture ...
[10:18:29.627] - result already collected: FutureResult
[10:18:29.627] result() for ClusterFuture ... done
[10:18:29.627] result() for ClusterFuture ...
[10:18:29.627] - result already collected: FutureResult
[10:18:29.627] result() for ClusterFuture ... done
[10:18:29.627] result() for ClusterFuture ...
[10:18:29.627] - result already collected: FutureResult
[10:18:29.628] result() for ClusterFuture ... done
[10:18:29.628]  - Number of value chunks collected: 2
[10:18:29.628] Resolving 2 futures (chunks) ... DONE
[10:18:29.628] Reducing values from 2 chunks ...
[10:18:29.628]  - Number of values collected after concatenation: 6
[10:18:29.628]  - Number of values expected: 6
[10:18:29.628] Reducing values from 2 chunks ... DONE
[10:18:29.628] future_lapply() ... DONE
     [,1]       [,2]       [,3]      
[1,] integer,19 integer,21 integer,23
[2,] integer,20 integer,22 integer,24
- apply(X, MARGIN = <character>, ...) ...
[10:18:29.629] getGlobalsAndPackagesXApply() ...
[10:18:29.629]  - future.globals: TRUE
[10:18:29.629] getGlobalsAndPackages() ...
[10:18:29.629] Searching for globals...
[10:18:29.630] - globals found: [1] ‘FUN’
[10:18:29.630] Searching for globals ... DONE
[10:18:29.630] Resolving globals: FALSE
[10:18:29.631] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:29.631] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:2, dim = 2:1, dimnames = list(rows = c("a",; "b"), NULL)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:29.631] - globals: [1] ‘FUN’
[10:18:29.631] 
[10:18:29.631] getGlobalsAndPackages() ... DONE
[10:18:29.631]  - globals found/used: [n=1] ‘FUN’
[10:18:29.631]  - needed namespaces: [n=0] 
[10:18:29.631] Finding globals ... DONE
[10:18:29.632]  - use_args: TRUE
[10:18:29.632]  - Getting '...' globals ...
[10:18:29.632] resolve() on list ...
[10:18:29.632]  recursive: 0
[10:18:29.632]  length: 1
[10:18:29.632]  elements: ‘...’
[10:18:29.632]  length: 0 (resolved future 1)
[10:18:29.632] resolve() on list ... DONE
[10:18:29.633]    - '...' content: [n=0] 
[10:18:29.633] List of 1
[10:18:29.633]  $ ...: list()
[10:18:29.633]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.633]  - attr(*, "where")=List of 1
[10:18:29.633]   ..$ ...:<environment: 0x556e04af7a60> 
[10:18:29.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.633]  - attr(*, "resolved")= logi TRUE
[10:18:29.633]  - attr(*, "total_size")= num NA
[10:18:29.635]  - Getting '...' globals ... DONE
[10:18:29.635] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:29.635] List of 2
[10:18:29.635]  $ ...future.FUN:function (x)  
[10:18:29.635]  $ ...          : list()
[10:18:29.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.635]  - attr(*, "where")=List of 2
[10:18:29.635]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:29.635]   ..$ ...          :<environment: 0x556e04af7a60> 
[10:18:29.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.635]  - attr(*, "resolved")= logi FALSE
[10:18:29.635]  - attr(*, "total_size")= num 2547
[10:18:29.638] Packages to be attached in all futures: [n=0] 
[10:18:29.638] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.640] future_lapply() ...
[10:18:29.642] Number of chunks: 2
[10:18:29.642] getGlobalsAndPackagesXApply() ...
[10:18:29.642]  - future.globals: <name-value list> with names ‘list()’
[10:18:29.642]  - use_args: TRUE
[10:18:29.643] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:29.643] List of 2
[10:18:29.643]  $ ...          : list()
[10:18:29.643]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.643]  $ ...future.FUN:function (x)  
[10:18:29.643]  - attr(*, "where")=List of 2
[10:18:29.643]   ..$ ...          :<environment: 0x556e04af7a60> 
[10:18:29.643]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:29.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.643]  - attr(*, "resolved")= logi FALSE
[10:18:29.643]  - attr(*, "total_size")= num NA
[10:18:29.646] Packages to be attached in all futures: [n=0] 
[10:18:29.646] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.647] Number of futures (= number of chunks): 2
[10:18:29.647] Launching 2 futures (chunks) ...
[10:18:29.647] Chunk #1 of 2 ...
[10:18:29.647]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.647]  - seeds: <none>
[10:18:29.647]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.647] getGlobalsAndPackages() ...
[10:18:29.647] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.648] Resolving globals: FALSE
[10:18:29.648] Tweak future expression to call with '...' arguments ...
[10:18:29.648] {
[10:18:29.648]     do.call(function(...) {
[10:18:29.648]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.648]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.648]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.648]             on.exit(options(oopts), add = TRUE)
[10:18:29.648]         }
[10:18:29.648]         {
[10:18:29.648]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.648]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.648]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.648]             })
[10:18:29.648]         }
[10:18:29.648]     }, args = future.call.arguments)
[10:18:29.648] }
[10:18:29.648] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.648] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.649] 
[10:18:29.649] getGlobalsAndPackages() ... DONE
[10:18:29.649] run() for ‘Future’ ...
[10:18:29.649] - state: ‘created’
[10:18:29.649] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.664] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.664]   - Field: ‘node’
[10:18:29.664]   - Field: ‘label’
[10:18:29.664]   - Field: ‘local’
[10:18:29.664]   - Field: ‘owner’
[10:18:29.664]   - Field: ‘envir’
[10:18:29.664]   - Field: ‘workers’
[10:18:29.665]   - Field: ‘packages’
[10:18:29.665]   - Field: ‘gc’
[10:18:29.665]   - Field: ‘conditions’
[10:18:29.665]   - Field: ‘persistent’
[10:18:29.665]   - Field: ‘expr’
[10:18:29.665]   - Field: ‘uuid’
[10:18:29.665]   - Field: ‘seed’
[10:18:29.665]   - Field: ‘version’
[10:18:29.665]   - Field: ‘result’
[10:18:29.665]   - Field: ‘asynchronous’
[10:18:29.665]   - Field: ‘calls’
[10:18:29.666]   - Field: ‘globals’
[10:18:29.666]   - Field: ‘stdout’
[10:18:29.666]   - Field: ‘earlySignal’
[10:18:29.666]   - Field: ‘lazy’
[10:18:29.666]   - Field: ‘state’
[10:18:29.666] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.666] - Launch lazy future ...
[10:18:29.666] Packages needed by the future expression (n = 0): <none>
[10:18:29.667] Packages needed by future strategies (n = 0): <none>
[10:18:29.667] {
[10:18:29.667]     {
[10:18:29.667]         {
[10:18:29.667]             ...future.startTime <- base::Sys.time()
[10:18:29.667]             {
[10:18:29.667]                 {
[10:18:29.667]                   {
[10:18:29.667]                     {
[10:18:29.667]                       base::local({
[10:18:29.667]                         has_future <- base::requireNamespace("future", 
[10:18:29.667]                           quietly = TRUE)
[10:18:29.667]                         if (has_future) {
[10:18:29.667]                           ns <- base::getNamespace("future")
[10:18:29.667]                           version <- ns[[".package"]][["version"]]
[10:18:29.667]                           if (is.null(version)) 
[10:18:29.667]                             version <- utils::packageVersion("future")
[10:18:29.667]                         }
[10:18:29.667]                         else {
[10:18:29.667]                           version <- NULL
[10:18:29.667]                         }
[10:18:29.667]                         if (!has_future || version < "1.8.0") {
[10:18:29.667]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.667]                             "", base::R.version$version.string), 
[10:18:29.667]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.667]                               "release", "version")], collapse = " "), 
[10:18:29.667]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.667]                             info)
[10:18:29.667]                           info <- base::paste(info, collapse = "; ")
[10:18:29.667]                           if (!has_future) {
[10:18:29.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.667]                               info)
[10:18:29.667]                           }
[10:18:29.667]                           else {
[10:18:29.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.667]                               info, version)
[10:18:29.667]                           }
[10:18:29.667]                           base::stop(msg)
[10:18:29.667]                         }
[10:18:29.667]                       })
[10:18:29.667]                     }
[10:18:29.667]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.667]                     base::options(mc.cores = 1L)
[10:18:29.667]                   }
[10:18:29.667]                   ...future.strategy.old <- future::plan("list")
[10:18:29.667]                   options(future.plan = NULL)
[10:18:29.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.667]                 }
[10:18:29.667]                 ...future.workdir <- getwd()
[10:18:29.667]             }
[10:18:29.667]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.667]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.667]         }
[10:18:29.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.667]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.667]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.667]             base::names(...future.oldOptions))
[10:18:29.667]     }
[10:18:29.667]     if (FALSE) {
[10:18:29.667]     }
[10:18:29.667]     else {
[10:18:29.667]         if (TRUE) {
[10:18:29.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.667]                 open = "w")
[10:18:29.667]         }
[10:18:29.667]         else {
[10:18:29.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.667]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.667]         }
[10:18:29.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.667]             base::sink(type = "output", split = FALSE)
[10:18:29.667]             base::close(...future.stdout)
[10:18:29.667]         }, add = TRUE)
[10:18:29.667]     }
[10:18:29.667]     ...future.frame <- base::sys.nframe()
[10:18:29.667]     ...future.conditions <- base::list()
[10:18:29.667]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.667]     if (FALSE) {
[10:18:29.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.667]     }
[10:18:29.667]     ...future.result <- base::tryCatch({
[10:18:29.667]         base::withCallingHandlers({
[10:18:29.667]             ...future.value <- base::withVisible(base::local({
[10:18:29.667]                 ...future.makeSendCondition <- base::local({
[10:18:29.667]                   sendCondition <- NULL
[10:18:29.667]                   function(frame = 1L) {
[10:18:29.667]                     if (is.function(sendCondition)) 
[10:18:29.667]                       return(sendCondition)
[10:18:29.667]                     ns <- getNamespace("parallel")
[10:18:29.667]                     if (exists("sendData", mode = "function", 
[10:18:29.667]                       envir = ns)) {
[10:18:29.667]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.667]                         envir = ns)
[10:18:29.667]                       envir <- sys.frame(frame)
[10:18:29.667]                       master <- NULL
[10:18:29.667]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.667]                         !identical(envir, emptyenv())) {
[10:18:29.667]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.667]                           inherits = FALSE)) {
[10:18:29.667]                           master <- get("master", mode = "list", 
[10:18:29.667]                             envir = envir, inherits = FALSE)
[10:18:29.667]                           if (inherits(master, c("SOCKnode", 
[10:18:29.667]                             "SOCK0node"))) {
[10:18:29.667]                             sendCondition <<- function(cond) {
[10:18:29.667]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.667]                                 success = TRUE)
[10:18:29.667]                               parallel_sendData(master, data)
[10:18:29.667]                             }
[10:18:29.667]                             return(sendCondition)
[10:18:29.667]                           }
[10:18:29.667]                         }
[10:18:29.667]                         frame <- frame + 1L
[10:18:29.667]                         envir <- sys.frame(frame)
[10:18:29.667]                       }
[10:18:29.667]                     }
[10:18:29.667]                     sendCondition <<- function(cond) NULL
[10:18:29.667]                   }
[10:18:29.667]                 })
[10:18:29.667]                 withCallingHandlers({
[10:18:29.667]                   {
[10:18:29.667]                     do.call(function(...) {
[10:18:29.667]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.667]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.667]                         ...future.globals.maxSize)) {
[10:18:29.667]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.667]                         on.exit(options(oopts), add = TRUE)
[10:18:29.667]                       }
[10:18:29.667]                       {
[10:18:29.667]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.667]                           FUN = function(jj) {
[10:18:29.667]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.667]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.667]                           })
[10:18:29.667]                       }
[10:18:29.667]                     }, args = future.call.arguments)
[10:18:29.667]                   }
[10:18:29.667]                 }, immediateCondition = function(cond) {
[10:18:29.667]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.667]                   sendCondition(cond)
[10:18:29.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.667]                   {
[10:18:29.667]                     inherits <- base::inherits
[10:18:29.667]                     invokeRestart <- base::invokeRestart
[10:18:29.667]                     is.null <- base::is.null
[10:18:29.667]                     muffled <- FALSE
[10:18:29.667]                     if (inherits(cond, "message")) {
[10:18:29.667]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.667]                       if (muffled) 
[10:18:29.667]                         invokeRestart("muffleMessage")
[10:18:29.667]                     }
[10:18:29.667]                     else if (inherits(cond, "warning")) {
[10:18:29.667]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.667]                       if (muffled) 
[10:18:29.667]                         invokeRestart("muffleWarning")
[10:18:29.667]                     }
[10:18:29.667]                     else if (inherits(cond, "condition")) {
[10:18:29.667]                       if (!is.null(pattern)) {
[10:18:29.667]                         computeRestarts <- base::computeRestarts
[10:18:29.667]                         grepl <- base::grepl
[10:18:29.667]                         restarts <- computeRestarts(cond)
[10:18:29.667]                         for (restart in restarts) {
[10:18:29.667]                           name <- restart$name
[10:18:29.667]                           if (is.null(name)) 
[10:18:29.667]                             next
[10:18:29.667]                           if (!grepl(pattern, name)) 
[10:18:29.667]                             next
[10:18:29.667]                           invokeRestart(restart)
[10:18:29.667]                           muffled <- TRUE
[10:18:29.667]                           break
[10:18:29.667]                         }
[10:18:29.667]                       }
[10:18:29.667]                     }
[10:18:29.667]                     invisible(muffled)
[10:18:29.667]                   }
[10:18:29.667]                   muffleCondition(cond)
[10:18:29.667]                 })
[10:18:29.667]             }))
[10:18:29.667]             future::FutureResult(value = ...future.value$value, 
[10:18:29.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.667]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.667]                     ...future.globalenv.names))
[10:18:29.667]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.667]         }, condition = base::local({
[10:18:29.667]             c <- base::c
[10:18:29.667]             inherits <- base::inherits
[10:18:29.667]             invokeRestart <- base::invokeRestart
[10:18:29.667]             length <- base::length
[10:18:29.667]             list <- base::list
[10:18:29.667]             seq.int <- base::seq.int
[10:18:29.667]             signalCondition <- base::signalCondition
[10:18:29.667]             sys.calls <- base::sys.calls
[10:18:29.667]             `[[` <- base::`[[`
[10:18:29.667]             `+` <- base::`+`
[10:18:29.667]             `<<-` <- base::`<<-`
[10:18:29.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.667]                   3L)]
[10:18:29.667]             }
[10:18:29.667]             function(cond) {
[10:18:29.667]                 is_error <- inherits(cond, "error")
[10:18:29.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.667]                   NULL)
[10:18:29.667]                 if (is_error) {
[10:18:29.667]                   sessionInformation <- function() {
[10:18:29.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.667]                       search = base::search(), system = base::Sys.info())
[10:18:29.667]                   }
[10:18:29.667]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.667]                     cond$call), session = sessionInformation(), 
[10:18:29.667]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.667]                   signalCondition(cond)
[10:18:29.667]                 }
[10:18:29.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.667]                 "immediateCondition"))) {
[10:18:29.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.667]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.667]                   if (TRUE && !signal) {
[10:18:29.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.667]                     {
[10:18:29.667]                       inherits <- base::inherits
[10:18:29.667]                       invokeRestart <- base::invokeRestart
[10:18:29.667]                       is.null <- base::is.null
[10:18:29.667]                       muffled <- FALSE
[10:18:29.667]                       if (inherits(cond, "message")) {
[10:18:29.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.667]                         if (muffled) 
[10:18:29.667]                           invokeRestart("muffleMessage")
[10:18:29.667]                       }
[10:18:29.667]                       else if (inherits(cond, "warning")) {
[10:18:29.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.667]                         if (muffled) 
[10:18:29.667]                           invokeRestart("muffleWarning")
[10:18:29.667]                       }
[10:18:29.667]                       else if (inherits(cond, "condition")) {
[10:18:29.667]                         if (!is.null(pattern)) {
[10:18:29.667]                           computeRestarts <- base::computeRestarts
[10:18:29.667]                           grepl <- base::grepl
[10:18:29.667]                           restarts <- computeRestarts(cond)
[10:18:29.667]                           for (restart in restarts) {
[10:18:29.667]                             name <- restart$name
[10:18:29.667]                             if (is.null(name)) 
[10:18:29.667]                               next
[10:18:29.667]                             if (!grepl(pattern, name)) 
[10:18:29.667]                               next
[10:18:29.667]                             invokeRestart(restart)
[10:18:29.667]                             muffled <- TRUE
[10:18:29.667]                             break
[10:18:29.667]                           }
[10:18:29.667]                         }
[10:18:29.667]                       }
[10:18:29.667]                       invisible(muffled)
[10:18:29.667]                     }
[10:18:29.667]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.667]                   }
[10:18:29.667]                 }
[10:18:29.667]                 else {
[10:18:29.667]                   if (TRUE) {
[10:18:29.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.667]                     {
[10:18:29.667]                       inherits <- base::inherits
[10:18:29.667]                       invokeRestart <- base::invokeRestart
[10:18:29.667]                       is.null <- base::is.null
[10:18:29.667]                       muffled <- FALSE
[10:18:29.667]                       if (inherits(cond, "message")) {
[10:18:29.667]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.667]                         if (muffled) 
[10:18:29.667]                           invokeRestart("muffleMessage")
[10:18:29.667]                       }
[10:18:29.667]                       else if (inherits(cond, "warning")) {
[10:18:29.667]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.667]                         if (muffled) 
[10:18:29.667]                           invokeRestart("muffleWarning")
[10:18:29.667]                       }
[10:18:29.667]                       else if (inherits(cond, "condition")) {
[10:18:29.667]                         if (!is.null(pattern)) {
[10:18:29.667]                           computeRestarts <- base::computeRestarts
[10:18:29.667]                           grepl <- base::grepl
[10:18:29.667]                           restarts <- computeRestarts(cond)
[10:18:29.667]                           for (restart in restarts) {
[10:18:29.667]                             name <- restart$name
[10:18:29.667]                             if (is.null(name)) 
[10:18:29.667]                               next
[10:18:29.667]                             if (!grepl(pattern, name)) 
[10:18:29.667]                               next
[10:18:29.667]                             invokeRestart(restart)
[10:18:29.667]                             muffled <- TRUE
[10:18:29.667]                             break
[10:18:29.667]                           }
[10:18:29.667]                         }
[10:18:29.667]                       }
[10:18:29.667]                       invisible(muffled)
[10:18:29.667]                     }
[10:18:29.667]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.667]                   }
[10:18:29.667]                 }
[10:18:29.667]             }
[10:18:29.667]         }))
[10:18:29.667]     }, error = function(ex) {
[10:18:29.667]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.667]                 ...future.rng), started = ...future.startTime, 
[10:18:29.667]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.667]             version = "1.8"), class = "FutureResult")
[10:18:29.667]     }, finally = {
[10:18:29.667]         if (!identical(...future.workdir, getwd())) 
[10:18:29.667]             setwd(...future.workdir)
[10:18:29.667]         {
[10:18:29.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.667]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.667]             }
[10:18:29.667]             base::options(...future.oldOptions)
[10:18:29.667]             if (.Platform$OS.type == "windows") {
[10:18:29.667]                 old_names <- names(...future.oldEnvVars)
[10:18:29.667]                 envs <- base::Sys.getenv()
[10:18:29.667]                 names <- names(envs)
[10:18:29.667]                 common <- intersect(names, old_names)
[10:18:29.667]                 added <- setdiff(names, old_names)
[10:18:29.667]                 removed <- setdiff(old_names, names)
[10:18:29.667]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.667]                   envs[common]]
[10:18:29.667]                 NAMES <- toupper(changed)
[10:18:29.667]                 args <- list()
[10:18:29.667]                 for (kk in seq_along(NAMES)) {
[10:18:29.667]                   name <- changed[[kk]]
[10:18:29.667]                   NAME <- NAMES[[kk]]
[10:18:29.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.667]                     next
[10:18:29.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.667]                 }
[10:18:29.667]                 NAMES <- toupper(added)
[10:18:29.667]                 for (kk in seq_along(NAMES)) {
[10:18:29.667]                   name <- added[[kk]]
[10:18:29.667]                   NAME <- NAMES[[kk]]
[10:18:29.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.667]                     next
[10:18:29.667]                   args[[name]] <- ""
[10:18:29.667]                 }
[10:18:29.667]                 NAMES <- toupper(removed)
[10:18:29.667]                 for (kk in seq_along(NAMES)) {
[10:18:29.667]                   name <- removed[[kk]]
[10:18:29.667]                   NAME <- NAMES[[kk]]
[10:18:29.667]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.667]                     next
[10:18:29.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.667]                 }
[10:18:29.667]                 if (length(args) > 0) 
[10:18:29.667]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.667]             }
[10:18:29.667]             else {
[10:18:29.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.667]             }
[10:18:29.667]             {
[10:18:29.667]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.667]                   0L) {
[10:18:29.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.667]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.667]                   base::options(opts)
[10:18:29.667]                 }
[10:18:29.667]                 {
[10:18:29.667]                   {
[10:18:29.667]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.667]                     NULL
[10:18:29.667]                   }
[10:18:29.667]                   options(future.plan = NULL)
[10:18:29.667]                   if (is.na(NA_character_)) 
[10:18:29.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.667]                     .init = FALSE)
[10:18:29.667]                 }
[10:18:29.667]             }
[10:18:29.667]         }
[10:18:29.667]     })
[10:18:29.667]     if (TRUE) {
[10:18:29.667]         base::sink(type = "output", split = FALSE)
[10:18:29.667]         if (TRUE) {
[10:18:29.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.667]         }
[10:18:29.667]         else {
[10:18:29.667]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.667]         }
[10:18:29.667]         base::close(...future.stdout)
[10:18:29.667]         ...future.stdout <- NULL
[10:18:29.667]     }
[10:18:29.667]     ...future.result$conditions <- ...future.conditions
[10:18:29.667]     ...future.result$finished <- base::Sys.time()
[10:18:29.667]     ...future.result
[10:18:29.667] }
[10:18:29.670] Exporting 5 global objects (854 bytes) to cluster node #1 ...
[10:18:29.670] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:29.671] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:29.671] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:18:29.671] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:18:29.671] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ...
[10:18:29.672] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #1 ... DONE
[10:18:29.672] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:29.672] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:29.673] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:29.673] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:29.673] Exporting 5 global objects (854 bytes) to cluster node #1 ... DONE
[10:18:29.674] MultisessionFuture started
[10:18:29.674] - Launch lazy future ... done
[10:18:29.674] run() for ‘MultisessionFuture’ ... done
[10:18:29.674] Created future:
[10:18:29.674] MultisessionFuture:
[10:18:29.674] Label: ‘future_apply-1’
[10:18:29.674] Expression:
[10:18:29.674] {
[10:18:29.674]     do.call(function(...) {
[10:18:29.674]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.674]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.674]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.674]             on.exit(options(oopts), add = TRUE)
[10:18:29.674]         }
[10:18:29.674]         {
[10:18:29.674]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.674]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.674]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.674]             })
[10:18:29.674]         }
[10:18:29.674]     }, args = future.call.arguments)
[10:18:29.674] }
[10:18:29.674] Lazy evaluation: FALSE
[10:18:29.674] Asynchronous evaluation: TRUE
[10:18:29.674] Local evaluation: TRUE
[10:18:29.674] Environment: R_GlobalEnv
[10:18:29.674] Capture standard output: TRUE
[10:18:29.674] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.674] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.674] Packages: <none>
[10:18:29.674] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.674] Resolved: FALSE
[10:18:29.674] Value: <not collected>
[10:18:29.674] Conditions captured: <none>
[10:18:29.674] Early signaling: FALSE
[10:18:29.674] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.674] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.686] Chunk #1 of 2 ... DONE
[10:18:29.686] Chunk #2 of 2 ...
[10:18:29.686]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.686]  - seeds: <none>
[10:18:29.686]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.686] getGlobalsAndPackages() ...
[10:18:29.686] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.686] Resolving globals: FALSE
[10:18:29.687] Tweak future expression to call with '...' arguments ...
[10:18:29.687] {
[10:18:29.687]     do.call(function(...) {
[10:18:29.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.687]             on.exit(options(oopts), add = TRUE)
[10:18:29.687]         }
[10:18:29.687]         {
[10:18:29.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.687]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.687]             })
[10:18:29.687]         }
[10:18:29.687]     }, args = future.call.arguments)
[10:18:29.687] }
[10:18:29.687] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.687] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.688] 
[10:18:29.688] getGlobalsAndPackages() ... DONE
[10:18:29.688] run() for ‘Future’ ...
[10:18:29.688] - state: ‘created’
[10:18:29.688] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.703] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.703] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.703]   - Field: ‘node’
[10:18:29.703]   - Field: ‘label’
[10:18:29.703]   - Field: ‘local’
[10:18:29.703]   - Field: ‘owner’
[10:18:29.703]   - Field: ‘envir’
[10:18:29.703]   - Field: ‘workers’
[10:18:29.704]   - Field: ‘packages’
[10:18:29.704]   - Field: ‘gc’
[10:18:29.704]   - Field: ‘conditions’
[10:18:29.704]   - Field: ‘persistent’
[10:18:29.704]   - Field: ‘expr’
[10:18:29.704]   - Field: ‘uuid’
[10:18:29.704]   - Field: ‘seed’
[10:18:29.704]   - Field: ‘version’
[10:18:29.704]   - Field: ‘result’
[10:18:29.704]   - Field: ‘asynchronous’
[10:18:29.704]   - Field: ‘calls’
[10:18:29.705]   - Field: ‘globals’
[10:18:29.705]   - Field: ‘stdout’
[10:18:29.705]   - Field: ‘earlySignal’
[10:18:29.705]   - Field: ‘lazy’
[10:18:29.705]   - Field: ‘state’
[10:18:29.705] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.705] - Launch lazy future ...
[10:18:29.705] Packages needed by the future expression (n = 0): <none>
[10:18:29.705] Packages needed by future strategies (n = 0): <none>
[10:18:29.706] {
[10:18:29.706]     {
[10:18:29.706]         {
[10:18:29.706]             ...future.startTime <- base::Sys.time()
[10:18:29.706]             {
[10:18:29.706]                 {
[10:18:29.706]                   {
[10:18:29.706]                     {
[10:18:29.706]                       base::local({
[10:18:29.706]                         has_future <- base::requireNamespace("future", 
[10:18:29.706]                           quietly = TRUE)
[10:18:29.706]                         if (has_future) {
[10:18:29.706]                           ns <- base::getNamespace("future")
[10:18:29.706]                           version <- ns[[".package"]][["version"]]
[10:18:29.706]                           if (is.null(version)) 
[10:18:29.706]                             version <- utils::packageVersion("future")
[10:18:29.706]                         }
[10:18:29.706]                         else {
[10:18:29.706]                           version <- NULL
[10:18:29.706]                         }
[10:18:29.706]                         if (!has_future || version < "1.8.0") {
[10:18:29.706]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.706]                             "", base::R.version$version.string), 
[10:18:29.706]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.706]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.706]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.706]                               "release", "version")], collapse = " "), 
[10:18:29.706]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.706]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.706]                             info)
[10:18:29.706]                           info <- base::paste(info, collapse = "; ")
[10:18:29.706]                           if (!has_future) {
[10:18:29.706]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.706]                               info)
[10:18:29.706]                           }
[10:18:29.706]                           else {
[10:18:29.706]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.706]                               info, version)
[10:18:29.706]                           }
[10:18:29.706]                           base::stop(msg)
[10:18:29.706]                         }
[10:18:29.706]                       })
[10:18:29.706]                     }
[10:18:29.706]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.706]                     base::options(mc.cores = 1L)
[10:18:29.706]                   }
[10:18:29.706]                   ...future.strategy.old <- future::plan("list")
[10:18:29.706]                   options(future.plan = NULL)
[10:18:29.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.706]                 }
[10:18:29.706]                 ...future.workdir <- getwd()
[10:18:29.706]             }
[10:18:29.706]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.706]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.706]         }
[10:18:29.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.706]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.706]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.706]             base::names(...future.oldOptions))
[10:18:29.706]     }
[10:18:29.706]     if (FALSE) {
[10:18:29.706]     }
[10:18:29.706]     else {
[10:18:29.706]         if (TRUE) {
[10:18:29.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.706]                 open = "w")
[10:18:29.706]         }
[10:18:29.706]         else {
[10:18:29.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.706]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.706]         }
[10:18:29.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.706]             base::sink(type = "output", split = FALSE)
[10:18:29.706]             base::close(...future.stdout)
[10:18:29.706]         }, add = TRUE)
[10:18:29.706]     }
[10:18:29.706]     ...future.frame <- base::sys.nframe()
[10:18:29.706]     ...future.conditions <- base::list()
[10:18:29.706]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.706]     if (FALSE) {
[10:18:29.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.706]     }
[10:18:29.706]     ...future.result <- base::tryCatch({
[10:18:29.706]         base::withCallingHandlers({
[10:18:29.706]             ...future.value <- base::withVisible(base::local({
[10:18:29.706]                 ...future.makeSendCondition <- base::local({
[10:18:29.706]                   sendCondition <- NULL
[10:18:29.706]                   function(frame = 1L) {
[10:18:29.706]                     if (is.function(sendCondition)) 
[10:18:29.706]                       return(sendCondition)
[10:18:29.706]                     ns <- getNamespace("parallel")
[10:18:29.706]                     if (exists("sendData", mode = "function", 
[10:18:29.706]                       envir = ns)) {
[10:18:29.706]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.706]                         envir = ns)
[10:18:29.706]                       envir <- sys.frame(frame)
[10:18:29.706]                       master <- NULL
[10:18:29.706]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.706]                         !identical(envir, emptyenv())) {
[10:18:29.706]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.706]                           inherits = FALSE)) {
[10:18:29.706]                           master <- get("master", mode = "list", 
[10:18:29.706]                             envir = envir, inherits = FALSE)
[10:18:29.706]                           if (inherits(master, c("SOCKnode", 
[10:18:29.706]                             "SOCK0node"))) {
[10:18:29.706]                             sendCondition <<- function(cond) {
[10:18:29.706]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.706]                                 success = TRUE)
[10:18:29.706]                               parallel_sendData(master, data)
[10:18:29.706]                             }
[10:18:29.706]                             return(sendCondition)
[10:18:29.706]                           }
[10:18:29.706]                         }
[10:18:29.706]                         frame <- frame + 1L
[10:18:29.706]                         envir <- sys.frame(frame)
[10:18:29.706]                       }
[10:18:29.706]                     }
[10:18:29.706]                     sendCondition <<- function(cond) NULL
[10:18:29.706]                   }
[10:18:29.706]                 })
[10:18:29.706]                 withCallingHandlers({
[10:18:29.706]                   {
[10:18:29.706]                     do.call(function(...) {
[10:18:29.706]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.706]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.706]                         ...future.globals.maxSize)) {
[10:18:29.706]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.706]                         on.exit(options(oopts), add = TRUE)
[10:18:29.706]                       }
[10:18:29.706]                       {
[10:18:29.706]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.706]                           FUN = function(jj) {
[10:18:29.706]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.706]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.706]                           })
[10:18:29.706]                       }
[10:18:29.706]                     }, args = future.call.arguments)
[10:18:29.706]                   }
[10:18:29.706]                 }, immediateCondition = function(cond) {
[10:18:29.706]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.706]                   sendCondition(cond)
[10:18:29.706]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.706]                   {
[10:18:29.706]                     inherits <- base::inherits
[10:18:29.706]                     invokeRestart <- base::invokeRestart
[10:18:29.706]                     is.null <- base::is.null
[10:18:29.706]                     muffled <- FALSE
[10:18:29.706]                     if (inherits(cond, "message")) {
[10:18:29.706]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.706]                       if (muffled) 
[10:18:29.706]                         invokeRestart("muffleMessage")
[10:18:29.706]                     }
[10:18:29.706]                     else if (inherits(cond, "warning")) {
[10:18:29.706]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.706]                       if (muffled) 
[10:18:29.706]                         invokeRestart("muffleWarning")
[10:18:29.706]                     }
[10:18:29.706]                     else if (inherits(cond, "condition")) {
[10:18:29.706]                       if (!is.null(pattern)) {
[10:18:29.706]                         computeRestarts <- base::computeRestarts
[10:18:29.706]                         grepl <- base::grepl
[10:18:29.706]                         restarts <- computeRestarts(cond)
[10:18:29.706]                         for (restart in restarts) {
[10:18:29.706]                           name <- restart$name
[10:18:29.706]                           if (is.null(name)) 
[10:18:29.706]                             next
[10:18:29.706]                           if (!grepl(pattern, name)) 
[10:18:29.706]                             next
[10:18:29.706]                           invokeRestart(restart)
[10:18:29.706]                           muffled <- TRUE
[10:18:29.706]                           break
[10:18:29.706]                         }
[10:18:29.706]                       }
[10:18:29.706]                     }
[10:18:29.706]                     invisible(muffled)
[10:18:29.706]                   }
[10:18:29.706]                   muffleCondition(cond)
[10:18:29.706]                 })
[10:18:29.706]             }))
[10:18:29.706]             future::FutureResult(value = ...future.value$value, 
[10:18:29.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.706]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.706]                     ...future.globalenv.names))
[10:18:29.706]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.706]         }, condition = base::local({
[10:18:29.706]             c <- base::c
[10:18:29.706]             inherits <- base::inherits
[10:18:29.706]             invokeRestart <- base::invokeRestart
[10:18:29.706]             length <- base::length
[10:18:29.706]             list <- base::list
[10:18:29.706]             seq.int <- base::seq.int
[10:18:29.706]             signalCondition <- base::signalCondition
[10:18:29.706]             sys.calls <- base::sys.calls
[10:18:29.706]             `[[` <- base::`[[`
[10:18:29.706]             `+` <- base::`+`
[10:18:29.706]             `<<-` <- base::`<<-`
[10:18:29.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.706]                   3L)]
[10:18:29.706]             }
[10:18:29.706]             function(cond) {
[10:18:29.706]                 is_error <- inherits(cond, "error")
[10:18:29.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.706]                   NULL)
[10:18:29.706]                 if (is_error) {
[10:18:29.706]                   sessionInformation <- function() {
[10:18:29.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.706]                       search = base::search(), system = base::Sys.info())
[10:18:29.706]                   }
[10:18:29.706]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.706]                     cond$call), session = sessionInformation(), 
[10:18:29.706]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.706]                   signalCondition(cond)
[10:18:29.706]                 }
[10:18:29.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.706]                 "immediateCondition"))) {
[10:18:29.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.706]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.706]                   if (TRUE && !signal) {
[10:18:29.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.706]                     {
[10:18:29.706]                       inherits <- base::inherits
[10:18:29.706]                       invokeRestart <- base::invokeRestart
[10:18:29.706]                       is.null <- base::is.null
[10:18:29.706]                       muffled <- FALSE
[10:18:29.706]                       if (inherits(cond, "message")) {
[10:18:29.706]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.706]                         if (muffled) 
[10:18:29.706]                           invokeRestart("muffleMessage")
[10:18:29.706]                       }
[10:18:29.706]                       else if (inherits(cond, "warning")) {
[10:18:29.706]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.706]                         if (muffled) 
[10:18:29.706]                           invokeRestart("muffleWarning")
[10:18:29.706]                       }
[10:18:29.706]                       else if (inherits(cond, "condition")) {
[10:18:29.706]                         if (!is.null(pattern)) {
[10:18:29.706]                           computeRestarts <- base::computeRestarts
[10:18:29.706]                           grepl <- base::grepl
[10:18:29.706]                           restarts <- computeRestarts(cond)
[10:18:29.706]                           for (restart in restarts) {
[10:18:29.706]                             name <- restart$name
[10:18:29.706]                             if (is.null(name)) 
[10:18:29.706]                               next
[10:18:29.706]                             if (!grepl(pattern, name)) 
[10:18:29.706]                               next
[10:18:29.706]                             invokeRestart(restart)
[10:18:29.706]                             muffled <- TRUE
[10:18:29.706]                             break
[10:18:29.706]                           }
[10:18:29.706]                         }
[10:18:29.706]                       }
[10:18:29.706]                       invisible(muffled)
[10:18:29.706]                     }
[10:18:29.706]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.706]                   }
[10:18:29.706]                 }
[10:18:29.706]                 else {
[10:18:29.706]                   if (TRUE) {
[10:18:29.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.706]                     {
[10:18:29.706]                       inherits <- base::inherits
[10:18:29.706]                       invokeRestart <- base::invokeRestart
[10:18:29.706]                       is.null <- base::is.null
[10:18:29.706]                       muffled <- FALSE
[10:18:29.706]                       if (inherits(cond, "message")) {
[10:18:29.706]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.706]                         if (muffled) 
[10:18:29.706]                           invokeRestart("muffleMessage")
[10:18:29.706]                       }
[10:18:29.706]                       else if (inherits(cond, "warning")) {
[10:18:29.706]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.706]                         if (muffled) 
[10:18:29.706]                           invokeRestart("muffleWarning")
[10:18:29.706]                       }
[10:18:29.706]                       else if (inherits(cond, "condition")) {
[10:18:29.706]                         if (!is.null(pattern)) {
[10:18:29.706]                           computeRestarts <- base::computeRestarts
[10:18:29.706]                           grepl <- base::grepl
[10:18:29.706]                           restarts <- computeRestarts(cond)
[10:18:29.706]                           for (restart in restarts) {
[10:18:29.706]                             name <- restart$name
[10:18:29.706]                             if (is.null(name)) 
[10:18:29.706]                               next
[10:18:29.706]                             if (!grepl(pattern, name)) 
[10:18:29.706]                               next
[10:18:29.706]                             invokeRestart(restart)
[10:18:29.706]                             muffled <- TRUE
[10:18:29.706]                             break
[10:18:29.706]                           }
[10:18:29.706]                         }
[10:18:29.706]                       }
[10:18:29.706]                       invisible(muffled)
[10:18:29.706]                     }
[10:18:29.706]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.706]                   }
[10:18:29.706]                 }
[10:18:29.706]             }
[10:18:29.706]         }))
[10:18:29.706]     }, error = function(ex) {
[10:18:29.706]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.706]                 ...future.rng), started = ...future.startTime, 
[10:18:29.706]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.706]             version = "1.8"), class = "FutureResult")
[10:18:29.706]     }, finally = {
[10:18:29.706]         if (!identical(...future.workdir, getwd())) 
[10:18:29.706]             setwd(...future.workdir)
[10:18:29.706]         {
[10:18:29.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.706]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.706]             }
[10:18:29.706]             base::options(...future.oldOptions)
[10:18:29.706]             if (.Platform$OS.type == "windows") {
[10:18:29.706]                 old_names <- names(...future.oldEnvVars)
[10:18:29.706]                 envs <- base::Sys.getenv()
[10:18:29.706]                 names <- names(envs)
[10:18:29.706]                 common <- intersect(names, old_names)
[10:18:29.706]                 added <- setdiff(names, old_names)
[10:18:29.706]                 removed <- setdiff(old_names, names)
[10:18:29.706]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.706]                   envs[common]]
[10:18:29.706]                 NAMES <- toupper(changed)
[10:18:29.706]                 args <- list()
[10:18:29.706]                 for (kk in seq_along(NAMES)) {
[10:18:29.706]                   name <- changed[[kk]]
[10:18:29.706]                   NAME <- NAMES[[kk]]
[10:18:29.706]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.706]                     next
[10:18:29.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.706]                 }
[10:18:29.706]                 NAMES <- toupper(added)
[10:18:29.706]                 for (kk in seq_along(NAMES)) {
[10:18:29.706]                   name <- added[[kk]]
[10:18:29.706]                   NAME <- NAMES[[kk]]
[10:18:29.706]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.706]                     next
[10:18:29.706]                   args[[name]] <- ""
[10:18:29.706]                 }
[10:18:29.706]                 NAMES <- toupper(removed)
[10:18:29.706]                 for (kk in seq_along(NAMES)) {
[10:18:29.706]                   name <- removed[[kk]]
[10:18:29.706]                   NAME <- NAMES[[kk]]
[10:18:29.706]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.706]                     next
[10:18:29.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.706]                 }
[10:18:29.706]                 if (length(args) > 0) 
[10:18:29.706]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.706]             }
[10:18:29.706]             else {
[10:18:29.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.706]             }
[10:18:29.706]             {
[10:18:29.706]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.706]                   0L) {
[10:18:29.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.706]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.706]                   base::options(opts)
[10:18:29.706]                 }
[10:18:29.706]                 {
[10:18:29.706]                   {
[10:18:29.706]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.706]                     NULL
[10:18:29.706]                   }
[10:18:29.706]                   options(future.plan = NULL)
[10:18:29.706]                   if (is.na(NA_character_)) 
[10:18:29.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.706]                     .init = FALSE)
[10:18:29.706]                 }
[10:18:29.706]             }
[10:18:29.706]         }
[10:18:29.706]     })
[10:18:29.706]     if (TRUE) {
[10:18:29.706]         base::sink(type = "output", split = FALSE)
[10:18:29.706]         if (TRUE) {
[10:18:29.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.706]         }
[10:18:29.706]         else {
[10:18:29.706]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.706]         }
[10:18:29.706]         base::close(...future.stdout)
[10:18:29.706]         ...future.stdout <- NULL
[10:18:29.706]     }
[10:18:29.706]     ...future.result$conditions <- ...future.conditions
[10:18:29.706]     ...future.result$finished <- base::Sys.time()
[10:18:29.706]     ...future.result
[10:18:29.706] }
[10:18:29.709] Exporting 5 global objects (854 bytes) to cluster node #2 ...
[10:18:29.709] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:29.710] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:29.710] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:18:29.710] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:18:29.710] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ...
[10:18:29.711] Exporting ‘...future.elements_ii’ (43 bytes) to cluster node #2 ... DONE
[10:18:29.711] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:29.711] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:29.711] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:29.712] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:29.712] Exporting 5 global objects (854 bytes) to cluster node #2 ... DONE
[10:18:29.712] MultisessionFuture started
[10:18:29.712] - Launch lazy future ... done
[10:18:29.712] run() for ‘MultisessionFuture’ ... done
[10:18:29.713] Created future:
[10:18:29.713] MultisessionFuture:
[10:18:29.713] Label: ‘future_apply-2’
[10:18:29.713] Expression:
[10:18:29.713] {
[10:18:29.713]     do.call(function(...) {
[10:18:29.713]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.713]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.713]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.713]             on.exit(options(oopts), add = TRUE)
[10:18:29.713]         }
[10:18:29.713]         {
[10:18:29.713]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.713]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.713]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.713]             })
[10:18:29.713]         }
[10:18:29.713]     }, args = future.call.arguments)
[10:18:29.713] }
[10:18:29.713] Lazy evaluation: FALSE
[10:18:29.713] Asynchronous evaluation: TRUE
[10:18:29.713] Local evaluation: TRUE
[10:18:29.713] Environment: R_GlobalEnv
[10:18:29.713] Capture standard output: TRUE
[10:18:29.713] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.713] Globals: 5 objects totaling 391 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 43 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.713] Packages: <none>
[10:18:29.713] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.713] Resolved: FALSE
[10:18:29.713] Value: <not collected>
[10:18:29.713] Conditions captured: <none>
[10:18:29.713] Early signaling: FALSE
[10:18:29.713] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.713] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.724] Chunk #2 of 2 ... DONE
[10:18:29.724] Launching 2 futures (chunks) ... DONE
[10:18:29.724] Resolving 2 futures (chunks) ...
[10:18:29.725] resolve() on list ...
[10:18:29.725]  recursive: 0
[10:18:29.725]  length: 2
[10:18:29.725] 
[10:18:29.725] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.725] - Validating connection of MultisessionFuture
[10:18:29.726] - received message: FutureResult
[10:18:29.726] - Received FutureResult
[10:18:29.726] - Erased future from FutureRegistry
[10:18:29.726] result() for ClusterFuture ...
[10:18:29.726] - result already collected: FutureResult
[10:18:29.726] result() for ClusterFuture ... done
[10:18:29.726] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.726] Future #1
[10:18:29.726] result() for ClusterFuture ...
[10:18:29.726] - result already collected: FutureResult
[10:18:29.727] result() for ClusterFuture ... done
[10:18:29.727] result() for ClusterFuture ...
[10:18:29.727] - result already collected: FutureResult
[10:18:29.727] result() for ClusterFuture ... done
[10:18:29.727] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:29.727] - nx: 2
[10:18:29.727] - relay: TRUE
[10:18:29.727] - stdout: TRUE
[10:18:29.727] - signal: TRUE
[10:18:29.727] - resignal: FALSE
[10:18:29.727] - force: TRUE
[10:18:29.727] - relayed: [n=2] FALSE, FALSE
[10:18:29.728] - queued futures: [n=2] FALSE, FALSE
[10:18:29.728]  - until=1
[10:18:29.728]  - relaying element #1
[10:18:29.728] result() for ClusterFuture ...
[10:18:29.728] - result already collected: FutureResult
[10:18:29.728] result() for ClusterFuture ... done
[10:18:29.728] result() for ClusterFuture ...
[10:18:29.728] - result already collected: FutureResult
[10:18:29.728] result() for ClusterFuture ... done
[10:18:29.728] result() for ClusterFuture ...
[10:18:29.728] - result already collected: FutureResult
[10:18:29.729] result() for ClusterFuture ... done
[10:18:29.729] result() for ClusterFuture ...
[10:18:29.729] - result already collected: FutureResult
[10:18:29.729] result() for ClusterFuture ... done
[10:18:29.729] - relayed: [n=2] TRUE, FALSE
[10:18:29.729] - queued futures: [n=2] TRUE, FALSE
[10:18:29.729] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:29.729]  length: 1 (resolved future 1)
[10:18:29.754] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.754] - Validating connection of MultisessionFuture
[10:18:29.754] - received message: FutureResult
[10:18:29.755] - Received FutureResult
[10:18:29.755] - Erased future from FutureRegistry
[10:18:29.755] result() for ClusterFuture ...
[10:18:29.755] - result already collected: FutureResult
[10:18:29.755] result() for ClusterFuture ... done
[10:18:29.755] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.755] Future #2
[10:18:29.755] result() for ClusterFuture ...
[10:18:29.755] - result already collected: FutureResult
[10:18:29.755] result() for ClusterFuture ... done
[10:18:29.756] result() for ClusterFuture ...
[10:18:29.756] - result already collected: FutureResult
[10:18:29.756] result() for ClusterFuture ... done
[10:18:29.758] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:29.758] - nx: 2
[10:18:29.759] - relay: TRUE
[10:18:29.759] - stdout: TRUE
[10:18:29.759] - signal: TRUE
[10:18:29.759] - resignal: FALSE
[10:18:29.759] - force: TRUE
[10:18:29.759] - relayed: [n=2] TRUE, FALSE
[10:18:29.759] - queued futures: [n=2] TRUE, FALSE
[10:18:29.759]  - until=2
[10:18:29.759]  - relaying element #2
[10:18:29.759] result() for ClusterFuture ...
[10:18:29.759] - result already collected: FutureResult
[10:18:29.759] result() for ClusterFuture ... done
[10:18:29.760] result() for ClusterFuture ...
[10:18:29.760] - result already collected: FutureResult
[10:18:29.760] result() for ClusterFuture ... done
[10:18:29.760] result() for ClusterFuture ...
[10:18:29.760] - result already collected: FutureResult
[10:18:29.760] result() for ClusterFuture ... done
[10:18:29.760] result() for ClusterFuture ...
[10:18:29.760] - result already collected: FutureResult
[10:18:29.760] result() for ClusterFuture ... done
[10:18:29.760] - relayed: [n=2] TRUE, TRUE
[10:18:29.760] - queued futures: [n=2] TRUE, TRUE
[10:18:29.761] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:29.761]  length: 0 (resolved future 2)
[10:18:29.761] Relaying remaining futures
[10:18:29.761] signalConditionsASAP(NULL, pos=0) ...
[10:18:29.761] - nx: 2
[10:18:29.761] - relay: TRUE
[10:18:29.761] - stdout: TRUE
[10:18:29.761] - signal: TRUE
[10:18:29.761] - resignal: FALSE
[10:18:29.761] - force: TRUE
[10:18:29.761] - relayed: [n=2] TRUE, TRUE
[10:18:29.761] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:29.762] - relayed: [n=2] TRUE, TRUE
[10:18:29.762] - queued futures: [n=2] TRUE, TRUE
[10:18:29.762] signalConditionsASAP(NULL, pos=0) ... done
[10:18:29.762] resolve() on list ... DONE
[10:18:29.762] result() for ClusterFuture ...
[10:18:29.762] - result already collected: FutureResult
[10:18:29.762] result() for ClusterFuture ... done
[10:18:29.762] result() for ClusterFuture ...
[10:18:29.762] - result already collected: FutureResult
[10:18:29.762] result() for ClusterFuture ... done
[10:18:29.762] result() for ClusterFuture ...
[10:18:29.762] - result already collected: FutureResult
[10:18:29.763] result() for ClusterFuture ... done
[10:18:29.763] result() for ClusterFuture ...
[10:18:29.763] - result already collected: FutureResult
[10:18:29.763] result() for ClusterFuture ... done
[10:18:29.763]  - Number of value chunks collected: 2
[10:18:29.763] Resolving 2 futures (chunks) ... DONE
[10:18:29.763] Reducing values from 2 chunks ...
[10:18:29.763]  - Number of values collected after concatenation: 2
[10:18:29.763]  - Number of values expected: 2
[10:18:29.763] Reducing values from 2 chunks ... DONE
[10:18:29.763] future_lapply() ... DONE
a b 
1 2 
- apply(X, ...) - dim(X) > 2 ...
[10:18:29.764] getGlobalsAndPackagesXApply() ...
[10:18:29.764]  - future.globals: TRUE
[10:18:29.764] getGlobalsAndPackages() ...
[10:18:29.764] Searching for globals...
[10:18:29.765] - globals found: [1] ‘FUN’
[10:18:29.765] Searching for globals ... DONE
[10:18:29.765] Resolving globals: FALSE
[10:18:29.766] The total size of the 1 globals is 185 bytes (185 bytes)
[10:18:29.766] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:12, dim = c(2L, 2L, 3L)))’) is 185 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (185 bytes of class ‘function’)
[10:18:29.766] - globals: [1] ‘FUN’
[10:18:29.766] 
[10:18:29.766] getGlobalsAndPackages() ... DONE
[10:18:29.766]  - globals found/used: [n=1] ‘FUN’
[10:18:29.766]  - needed namespaces: [n=0] 
[10:18:29.766] Finding globals ... DONE
[10:18:29.767]  - use_args: TRUE
[10:18:29.767]  - Getting '...' globals ...
[10:18:29.767] resolve() on list ...
[10:18:29.767]  recursive: 0
[10:18:29.767]  length: 1
[10:18:29.767]  elements: ‘...’
[10:18:29.767]  length: 0 (resolved future 1)
[10:18:29.767] resolve() on list ... DONE
[10:18:29.767]    - '...' content: [n=0] 
[10:18:29.768] List of 1
[10:18:29.768]  $ ...: list()
[10:18:29.768]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.768]  - attr(*, "where")=List of 1
[10:18:29.768]   ..$ ...:<environment: 0x556e03d98e08> 
[10:18:29.768]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.768]  - attr(*, "resolved")= logi TRUE
[10:18:29.768]  - attr(*, "total_size")= num NA
[10:18:29.770]  - Getting '...' globals ... DONE
[10:18:29.770] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:29.770] List of 2
[10:18:29.770]  $ ...future.FUN:function (x)  
[10:18:29.770]  $ ...          : list()
[10:18:29.770]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.770]  - attr(*, "where")=List of 2
[10:18:29.770]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:29.770]   ..$ ...          :<environment: 0x556e03d98e08> 
[10:18:29.770]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.770]  - attr(*, "resolved")= logi FALSE
[10:18:29.770]  - attr(*, "total_size")= num 2274
[10:18:29.773] Packages to be attached in all futures: [n=0] 
[10:18:29.773] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.774] future_lapply() ...
[10:18:29.776] Number of chunks: 2
[10:18:29.776] getGlobalsAndPackagesXApply() ...
[10:18:29.777]  - future.globals: <name-value list> with names ‘list()’
[10:18:29.777]  - use_args: TRUE
[10:18:29.777] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:29.777] List of 2
[10:18:29.777]  $ ...          : list()
[10:18:29.777]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.777]  $ ...future.FUN:function (x)  
[10:18:29.777]  - attr(*, "where")=List of 2
[10:18:29.777]   ..$ ...          :<environment: 0x556e03d98e08> 
[10:18:29.777]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:29.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.777]  - attr(*, "resolved")= logi FALSE
[10:18:29.777]  - attr(*, "total_size")= num NA
[10:18:29.781] Packages to be attached in all futures: [n=0] 
[10:18:29.781] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.781] Number of futures (= number of chunks): 2
[10:18:29.781] Launching 2 futures (chunks) ...
[10:18:29.781] Chunk #1 of 2 ...
[10:18:29.781]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.781]  - seeds: <none>
[10:18:29.781]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.781] getGlobalsAndPackages() ...
[10:18:29.782] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.782] Resolving globals: FALSE
[10:18:29.782] Tweak future expression to call with '...' arguments ...
[10:18:29.782] {
[10:18:29.782]     do.call(function(...) {
[10:18:29.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.782]             on.exit(options(oopts), add = TRUE)
[10:18:29.782]         }
[10:18:29.782]         {
[10:18:29.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.782]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.782]             })
[10:18:29.782]         }
[10:18:29.782]     }, args = future.call.arguments)
[10:18:29.782] }
[10:18:29.782] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.782] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.783] 
[10:18:29.783] getGlobalsAndPackages() ... DONE
[10:18:29.783] run() for ‘Future’ ...
[10:18:29.783] - state: ‘created’
[10:18:29.783] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.797] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.797] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.797]   - Field: ‘node’
[10:18:29.798]   - Field: ‘label’
[10:18:29.798]   - Field: ‘local’
[10:18:29.798]   - Field: ‘owner’
[10:18:29.798]   - Field: ‘envir’
[10:18:29.798]   - Field: ‘workers’
[10:18:29.798]   - Field: ‘packages’
[10:18:29.798]   - Field: ‘gc’
[10:18:29.798]   - Field: ‘conditions’
[10:18:29.798]   - Field: ‘persistent’
[10:18:29.798]   - Field: ‘expr’
[10:18:29.798]   - Field: ‘uuid’
[10:18:29.799]   - Field: ‘seed’
[10:18:29.799]   - Field: ‘version’
[10:18:29.799]   - Field: ‘result’
[10:18:29.799]   - Field: ‘asynchronous’
[10:18:29.799]   - Field: ‘calls’
[10:18:29.799]   - Field: ‘globals’
[10:18:29.799]   - Field: ‘stdout’
[10:18:29.799]   - Field: ‘earlySignal’
[10:18:29.799]   - Field: ‘lazy’
[10:18:29.799]   - Field: ‘state’
[10:18:29.799] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.799] - Launch lazy future ...
[10:18:29.800] Packages needed by the future expression (n = 0): <none>
[10:18:29.800] Packages needed by future strategies (n = 0): <none>
[10:18:29.800] {
[10:18:29.800]     {
[10:18:29.800]         {
[10:18:29.800]             ...future.startTime <- base::Sys.time()
[10:18:29.800]             {
[10:18:29.800]                 {
[10:18:29.800]                   {
[10:18:29.800]                     {
[10:18:29.800]                       base::local({
[10:18:29.800]                         has_future <- base::requireNamespace("future", 
[10:18:29.800]                           quietly = TRUE)
[10:18:29.800]                         if (has_future) {
[10:18:29.800]                           ns <- base::getNamespace("future")
[10:18:29.800]                           version <- ns[[".package"]][["version"]]
[10:18:29.800]                           if (is.null(version)) 
[10:18:29.800]                             version <- utils::packageVersion("future")
[10:18:29.800]                         }
[10:18:29.800]                         else {
[10:18:29.800]                           version <- NULL
[10:18:29.800]                         }
[10:18:29.800]                         if (!has_future || version < "1.8.0") {
[10:18:29.800]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.800]                             "", base::R.version$version.string), 
[10:18:29.800]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.800]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.800]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.800]                               "release", "version")], collapse = " "), 
[10:18:29.800]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.800]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.800]                             info)
[10:18:29.800]                           info <- base::paste(info, collapse = "; ")
[10:18:29.800]                           if (!has_future) {
[10:18:29.800]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.800]                               info)
[10:18:29.800]                           }
[10:18:29.800]                           else {
[10:18:29.800]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.800]                               info, version)
[10:18:29.800]                           }
[10:18:29.800]                           base::stop(msg)
[10:18:29.800]                         }
[10:18:29.800]                       })
[10:18:29.800]                     }
[10:18:29.800]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.800]                     base::options(mc.cores = 1L)
[10:18:29.800]                   }
[10:18:29.800]                   ...future.strategy.old <- future::plan("list")
[10:18:29.800]                   options(future.plan = NULL)
[10:18:29.800]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.800]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.800]                 }
[10:18:29.800]                 ...future.workdir <- getwd()
[10:18:29.800]             }
[10:18:29.800]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.800]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.800]         }
[10:18:29.800]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.800]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.800]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.800]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.800]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.800]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.800]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.800]             base::names(...future.oldOptions))
[10:18:29.800]     }
[10:18:29.800]     if (FALSE) {
[10:18:29.800]     }
[10:18:29.800]     else {
[10:18:29.800]         if (TRUE) {
[10:18:29.800]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.800]                 open = "w")
[10:18:29.800]         }
[10:18:29.800]         else {
[10:18:29.800]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.800]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.800]         }
[10:18:29.800]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.800]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.800]             base::sink(type = "output", split = FALSE)
[10:18:29.800]             base::close(...future.stdout)
[10:18:29.800]         }, add = TRUE)
[10:18:29.800]     }
[10:18:29.800]     ...future.frame <- base::sys.nframe()
[10:18:29.800]     ...future.conditions <- base::list()
[10:18:29.800]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.800]     if (FALSE) {
[10:18:29.800]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.800]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.800]     }
[10:18:29.800]     ...future.result <- base::tryCatch({
[10:18:29.800]         base::withCallingHandlers({
[10:18:29.800]             ...future.value <- base::withVisible(base::local({
[10:18:29.800]                 ...future.makeSendCondition <- base::local({
[10:18:29.800]                   sendCondition <- NULL
[10:18:29.800]                   function(frame = 1L) {
[10:18:29.800]                     if (is.function(sendCondition)) 
[10:18:29.800]                       return(sendCondition)
[10:18:29.800]                     ns <- getNamespace("parallel")
[10:18:29.800]                     if (exists("sendData", mode = "function", 
[10:18:29.800]                       envir = ns)) {
[10:18:29.800]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.800]                         envir = ns)
[10:18:29.800]                       envir <- sys.frame(frame)
[10:18:29.800]                       master <- NULL
[10:18:29.800]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.800]                         !identical(envir, emptyenv())) {
[10:18:29.800]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.800]                           inherits = FALSE)) {
[10:18:29.800]                           master <- get("master", mode = "list", 
[10:18:29.800]                             envir = envir, inherits = FALSE)
[10:18:29.800]                           if (inherits(master, c("SOCKnode", 
[10:18:29.800]                             "SOCK0node"))) {
[10:18:29.800]                             sendCondition <<- function(cond) {
[10:18:29.800]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.800]                                 success = TRUE)
[10:18:29.800]                               parallel_sendData(master, data)
[10:18:29.800]                             }
[10:18:29.800]                             return(sendCondition)
[10:18:29.800]                           }
[10:18:29.800]                         }
[10:18:29.800]                         frame <- frame + 1L
[10:18:29.800]                         envir <- sys.frame(frame)
[10:18:29.800]                       }
[10:18:29.800]                     }
[10:18:29.800]                     sendCondition <<- function(cond) NULL
[10:18:29.800]                   }
[10:18:29.800]                 })
[10:18:29.800]                 withCallingHandlers({
[10:18:29.800]                   {
[10:18:29.800]                     do.call(function(...) {
[10:18:29.800]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.800]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.800]                         ...future.globals.maxSize)) {
[10:18:29.800]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.800]                         on.exit(options(oopts), add = TRUE)
[10:18:29.800]                       }
[10:18:29.800]                       {
[10:18:29.800]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.800]                           FUN = function(jj) {
[10:18:29.800]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.800]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.800]                           })
[10:18:29.800]                       }
[10:18:29.800]                     }, args = future.call.arguments)
[10:18:29.800]                   }
[10:18:29.800]                 }, immediateCondition = function(cond) {
[10:18:29.800]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.800]                   sendCondition(cond)
[10:18:29.800]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.800]                   {
[10:18:29.800]                     inherits <- base::inherits
[10:18:29.800]                     invokeRestart <- base::invokeRestart
[10:18:29.800]                     is.null <- base::is.null
[10:18:29.800]                     muffled <- FALSE
[10:18:29.800]                     if (inherits(cond, "message")) {
[10:18:29.800]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.800]                       if (muffled) 
[10:18:29.800]                         invokeRestart("muffleMessage")
[10:18:29.800]                     }
[10:18:29.800]                     else if (inherits(cond, "warning")) {
[10:18:29.800]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.800]                       if (muffled) 
[10:18:29.800]                         invokeRestart("muffleWarning")
[10:18:29.800]                     }
[10:18:29.800]                     else if (inherits(cond, "condition")) {
[10:18:29.800]                       if (!is.null(pattern)) {
[10:18:29.800]                         computeRestarts <- base::computeRestarts
[10:18:29.800]                         grepl <- base::grepl
[10:18:29.800]                         restarts <- computeRestarts(cond)
[10:18:29.800]                         for (restart in restarts) {
[10:18:29.800]                           name <- restart$name
[10:18:29.800]                           if (is.null(name)) 
[10:18:29.800]                             next
[10:18:29.800]                           if (!grepl(pattern, name)) 
[10:18:29.800]                             next
[10:18:29.800]                           invokeRestart(restart)
[10:18:29.800]                           muffled <- TRUE
[10:18:29.800]                           break
[10:18:29.800]                         }
[10:18:29.800]                       }
[10:18:29.800]                     }
[10:18:29.800]                     invisible(muffled)
[10:18:29.800]                   }
[10:18:29.800]                   muffleCondition(cond)
[10:18:29.800]                 })
[10:18:29.800]             }))
[10:18:29.800]             future::FutureResult(value = ...future.value$value, 
[10:18:29.800]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.800]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.800]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.800]                     ...future.globalenv.names))
[10:18:29.800]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.800]         }, condition = base::local({
[10:18:29.800]             c <- base::c
[10:18:29.800]             inherits <- base::inherits
[10:18:29.800]             invokeRestart <- base::invokeRestart
[10:18:29.800]             length <- base::length
[10:18:29.800]             list <- base::list
[10:18:29.800]             seq.int <- base::seq.int
[10:18:29.800]             signalCondition <- base::signalCondition
[10:18:29.800]             sys.calls <- base::sys.calls
[10:18:29.800]             `[[` <- base::`[[`
[10:18:29.800]             `+` <- base::`+`
[10:18:29.800]             `<<-` <- base::`<<-`
[10:18:29.800]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.800]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.800]                   3L)]
[10:18:29.800]             }
[10:18:29.800]             function(cond) {
[10:18:29.800]                 is_error <- inherits(cond, "error")
[10:18:29.800]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.800]                   NULL)
[10:18:29.800]                 if (is_error) {
[10:18:29.800]                   sessionInformation <- function() {
[10:18:29.800]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.800]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.800]                       search = base::search(), system = base::Sys.info())
[10:18:29.800]                   }
[10:18:29.800]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.800]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.800]                     cond$call), session = sessionInformation(), 
[10:18:29.800]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.800]                   signalCondition(cond)
[10:18:29.800]                 }
[10:18:29.800]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.800]                 "immediateCondition"))) {
[10:18:29.800]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.800]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.800]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.800]                   if (TRUE && !signal) {
[10:18:29.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.800]                     {
[10:18:29.800]                       inherits <- base::inherits
[10:18:29.800]                       invokeRestart <- base::invokeRestart
[10:18:29.800]                       is.null <- base::is.null
[10:18:29.800]                       muffled <- FALSE
[10:18:29.800]                       if (inherits(cond, "message")) {
[10:18:29.800]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.800]                         if (muffled) 
[10:18:29.800]                           invokeRestart("muffleMessage")
[10:18:29.800]                       }
[10:18:29.800]                       else if (inherits(cond, "warning")) {
[10:18:29.800]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.800]                         if (muffled) 
[10:18:29.800]                           invokeRestart("muffleWarning")
[10:18:29.800]                       }
[10:18:29.800]                       else if (inherits(cond, "condition")) {
[10:18:29.800]                         if (!is.null(pattern)) {
[10:18:29.800]                           computeRestarts <- base::computeRestarts
[10:18:29.800]                           grepl <- base::grepl
[10:18:29.800]                           restarts <- computeRestarts(cond)
[10:18:29.800]                           for (restart in restarts) {
[10:18:29.800]                             name <- restart$name
[10:18:29.800]                             if (is.null(name)) 
[10:18:29.800]                               next
[10:18:29.800]                             if (!grepl(pattern, name)) 
[10:18:29.800]                               next
[10:18:29.800]                             invokeRestart(restart)
[10:18:29.800]                             muffled <- TRUE
[10:18:29.800]                             break
[10:18:29.800]                           }
[10:18:29.800]                         }
[10:18:29.800]                       }
[10:18:29.800]                       invisible(muffled)
[10:18:29.800]                     }
[10:18:29.800]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.800]                   }
[10:18:29.800]                 }
[10:18:29.800]                 else {
[10:18:29.800]                   if (TRUE) {
[10:18:29.800]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.800]                     {
[10:18:29.800]                       inherits <- base::inherits
[10:18:29.800]                       invokeRestart <- base::invokeRestart
[10:18:29.800]                       is.null <- base::is.null
[10:18:29.800]                       muffled <- FALSE
[10:18:29.800]                       if (inherits(cond, "message")) {
[10:18:29.800]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.800]                         if (muffled) 
[10:18:29.800]                           invokeRestart("muffleMessage")
[10:18:29.800]                       }
[10:18:29.800]                       else if (inherits(cond, "warning")) {
[10:18:29.800]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.800]                         if (muffled) 
[10:18:29.800]                           invokeRestart("muffleWarning")
[10:18:29.800]                       }
[10:18:29.800]                       else if (inherits(cond, "condition")) {
[10:18:29.800]                         if (!is.null(pattern)) {
[10:18:29.800]                           computeRestarts <- base::computeRestarts
[10:18:29.800]                           grepl <- base::grepl
[10:18:29.800]                           restarts <- computeRestarts(cond)
[10:18:29.800]                           for (restart in restarts) {
[10:18:29.800]                             name <- restart$name
[10:18:29.800]                             if (is.null(name)) 
[10:18:29.800]                               next
[10:18:29.800]                             if (!grepl(pattern, name)) 
[10:18:29.800]                               next
[10:18:29.800]                             invokeRestart(restart)
[10:18:29.800]                             muffled <- TRUE
[10:18:29.800]                             break
[10:18:29.800]                           }
[10:18:29.800]                         }
[10:18:29.800]                       }
[10:18:29.800]                       invisible(muffled)
[10:18:29.800]                     }
[10:18:29.800]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.800]                   }
[10:18:29.800]                 }
[10:18:29.800]             }
[10:18:29.800]         }))
[10:18:29.800]     }, error = function(ex) {
[10:18:29.800]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.800]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.800]                 ...future.rng), started = ...future.startTime, 
[10:18:29.800]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.800]             version = "1.8"), class = "FutureResult")
[10:18:29.800]     }, finally = {
[10:18:29.800]         if (!identical(...future.workdir, getwd())) 
[10:18:29.800]             setwd(...future.workdir)
[10:18:29.800]         {
[10:18:29.800]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.800]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.800]             }
[10:18:29.800]             base::options(...future.oldOptions)
[10:18:29.800]             if (.Platform$OS.type == "windows") {
[10:18:29.800]                 old_names <- names(...future.oldEnvVars)
[10:18:29.800]                 envs <- base::Sys.getenv()
[10:18:29.800]                 names <- names(envs)
[10:18:29.800]                 common <- intersect(names, old_names)
[10:18:29.800]                 added <- setdiff(names, old_names)
[10:18:29.800]                 removed <- setdiff(old_names, names)
[10:18:29.800]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.800]                   envs[common]]
[10:18:29.800]                 NAMES <- toupper(changed)
[10:18:29.800]                 args <- list()
[10:18:29.800]                 for (kk in seq_along(NAMES)) {
[10:18:29.800]                   name <- changed[[kk]]
[10:18:29.800]                   NAME <- NAMES[[kk]]
[10:18:29.800]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.800]                     next
[10:18:29.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.800]                 }
[10:18:29.800]                 NAMES <- toupper(added)
[10:18:29.800]                 for (kk in seq_along(NAMES)) {
[10:18:29.800]                   name <- added[[kk]]
[10:18:29.800]                   NAME <- NAMES[[kk]]
[10:18:29.800]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.800]                     next
[10:18:29.800]                   args[[name]] <- ""
[10:18:29.800]                 }
[10:18:29.800]                 NAMES <- toupper(removed)
[10:18:29.800]                 for (kk in seq_along(NAMES)) {
[10:18:29.800]                   name <- removed[[kk]]
[10:18:29.800]                   NAME <- NAMES[[kk]]
[10:18:29.800]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.800]                     next
[10:18:29.800]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.800]                 }
[10:18:29.800]                 if (length(args) > 0) 
[10:18:29.800]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.800]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.800]             }
[10:18:29.800]             else {
[10:18:29.800]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.800]             }
[10:18:29.800]             {
[10:18:29.800]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.800]                   0L) {
[10:18:29.800]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.800]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.800]                   base::options(opts)
[10:18:29.800]                 }
[10:18:29.800]                 {
[10:18:29.800]                   {
[10:18:29.800]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.800]                     NULL
[10:18:29.800]                   }
[10:18:29.800]                   options(future.plan = NULL)
[10:18:29.800]                   if (is.na(NA_character_)) 
[10:18:29.800]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.800]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.800]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.800]                     .init = FALSE)
[10:18:29.800]                 }
[10:18:29.800]             }
[10:18:29.800]         }
[10:18:29.800]     })
[10:18:29.800]     if (TRUE) {
[10:18:29.800]         base::sink(type = "output", split = FALSE)
[10:18:29.800]         if (TRUE) {
[10:18:29.800]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.800]         }
[10:18:29.800]         else {
[10:18:29.800]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.800]         }
[10:18:29.800]         base::close(...future.stdout)
[10:18:29.800]         ...future.stdout <- NULL
[10:18:29.800]     }
[10:18:29.800]     ...future.result$conditions <- ...future.conditions
[10:18:29.800]     ...future.result$finished <- base::Sys.time()
[10:18:29.800]     ...future.result
[10:18:29.800] }
[10:18:29.803] Exporting 5 global objects (913 bytes) to cluster node #1 ...
[10:18:29.803] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:29.804] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:29.804] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ...
[10:18:29.804] Exporting ‘...future.FUN’ (185 bytes) to cluster node #1 ... DONE
[10:18:29.804] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #1 ...
[10:18:29.805] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #1 ... DONE
[10:18:29.805] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:29.805] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:29.805] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:29.806] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:29.806] Exporting 5 global objects (913 bytes) to cluster node #1 ... DONE
[10:18:29.806] MultisessionFuture started
[10:18:29.807] - Launch lazy future ... done
[10:18:29.807] run() for ‘MultisessionFuture’ ... done
[10:18:29.807] Created future:
[10:18:29.807] MultisessionFuture:
[10:18:29.807] Label: ‘future_apply-1’
[10:18:29.807] Expression:
[10:18:29.807] {
[10:18:29.807]     do.call(function(...) {
[10:18:29.807]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.807]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.807]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.807]             on.exit(options(oopts), add = TRUE)
[10:18:29.807]         }
[10:18:29.807]         {
[10:18:29.807]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.807]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.807]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.807]             })
[10:18:29.807]         }
[10:18:29.807]     }, args = future.call.arguments)
[10:18:29.807] }
[10:18:29.807] Lazy evaluation: FALSE
[10:18:29.807] Asynchronous evaluation: TRUE
[10:18:29.807] Local evaluation: TRUE
[10:18:29.807] Environment: R_GlobalEnv
[10:18:29.807] Capture standard output: TRUE
[10:18:29.807] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.807] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.807] Packages: <none>
[10:18:29.807] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.807] Resolved: FALSE
[10:18:29.807] Value: <not collected>
[10:18:29.807] Conditions captured: <none>
[10:18:29.807] Early signaling: FALSE
[10:18:29.807] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.807] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.818] Chunk #1 of 2 ... DONE
[10:18:29.818] Chunk #2 of 2 ...
[10:18:29.819]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.819]  - seeds: <none>
[10:18:29.819]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.819] getGlobalsAndPackages() ...
[10:18:29.819] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.819] Resolving globals: FALSE
[10:18:29.819] Tweak future expression to call with '...' arguments ...
[10:18:29.819] {
[10:18:29.819]     do.call(function(...) {
[10:18:29.819]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.819]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.819]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.819]             on.exit(options(oopts), add = TRUE)
[10:18:29.819]         }
[10:18:29.819]         {
[10:18:29.819]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.819]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.819]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.819]             })
[10:18:29.819]         }
[10:18:29.819]     }, args = future.call.arguments)
[10:18:29.819] }
[10:18:29.819] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.820] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.820] 
[10:18:29.820] getGlobalsAndPackages() ... DONE
[10:18:29.820] run() for ‘Future’ ...
[10:18:29.820] - state: ‘created’
[10:18:29.821] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.834] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.835]   - Field: ‘node’
[10:18:29.835]   - Field: ‘label’
[10:18:29.835]   - Field: ‘local’
[10:18:29.835]   - Field: ‘owner’
[10:18:29.835]   - Field: ‘envir’
[10:18:29.835]   - Field: ‘workers’
[10:18:29.835]   - Field: ‘packages’
[10:18:29.835]   - Field: ‘gc’
[10:18:29.835]   - Field: ‘conditions’
[10:18:29.836]   - Field: ‘persistent’
[10:18:29.836]   - Field: ‘expr’
[10:18:29.836]   - Field: ‘uuid’
[10:18:29.836]   - Field: ‘seed’
[10:18:29.836]   - Field: ‘version’
[10:18:29.836]   - Field: ‘result’
[10:18:29.836]   - Field: ‘asynchronous’
[10:18:29.836]   - Field: ‘calls’
[10:18:29.836]   - Field: ‘globals’
[10:18:29.836]   - Field: ‘stdout’
[10:18:29.836]   - Field: ‘earlySignal’
[10:18:29.836]   - Field: ‘lazy’
[10:18:29.837]   - Field: ‘state’
[10:18:29.837] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.837] - Launch lazy future ...
[10:18:29.837] Packages needed by the future expression (n = 0): <none>
[10:18:29.837] Packages needed by future strategies (n = 0): <none>
[10:18:29.838] {
[10:18:29.838]     {
[10:18:29.838]         {
[10:18:29.838]             ...future.startTime <- base::Sys.time()
[10:18:29.838]             {
[10:18:29.838]                 {
[10:18:29.838]                   {
[10:18:29.838]                     {
[10:18:29.838]                       base::local({
[10:18:29.838]                         has_future <- base::requireNamespace("future", 
[10:18:29.838]                           quietly = TRUE)
[10:18:29.838]                         if (has_future) {
[10:18:29.838]                           ns <- base::getNamespace("future")
[10:18:29.838]                           version <- ns[[".package"]][["version"]]
[10:18:29.838]                           if (is.null(version)) 
[10:18:29.838]                             version <- utils::packageVersion("future")
[10:18:29.838]                         }
[10:18:29.838]                         else {
[10:18:29.838]                           version <- NULL
[10:18:29.838]                         }
[10:18:29.838]                         if (!has_future || version < "1.8.0") {
[10:18:29.838]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.838]                             "", base::R.version$version.string), 
[10:18:29.838]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.838]                               "release", "version")], collapse = " "), 
[10:18:29.838]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.838]                             info)
[10:18:29.838]                           info <- base::paste(info, collapse = "; ")
[10:18:29.838]                           if (!has_future) {
[10:18:29.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.838]                               info)
[10:18:29.838]                           }
[10:18:29.838]                           else {
[10:18:29.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.838]                               info, version)
[10:18:29.838]                           }
[10:18:29.838]                           base::stop(msg)
[10:18:29.838]                         }
[10:18:29.838]                       })
[10:18:29.838]                     }
[10:18:29.838]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.838]                     base::options(mc.cores = 1L)
[10:18:29.838]                   }
[10:18:29.838]                   ...future.strategy.old <- future::plan("list")
[10:18:29.838]                   options(future.plan = NULL)
[10:18:29.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.838]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.838]                 }
[10:18:29.838]                 ...future.workdir <- getwd()
[10:18:29.838]             }
[10:18:29.838]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.838]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.838]         }
[10:18:29.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.838]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.838]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.838]             base::names(...future.oldOptions))
[10:18:29.838]     }
[10:18:29.838]     if (FALSE) {
[10:18:29.838]     }
[10:18:29.838]     else {
[10:18:29.838]         if (TRUE) {
[10:18:29.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.838]                 open = "w")
[10:18:29.838]         }
[10:18:29.838]         else {
[10:18:29.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.838]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.838]         }
[10:18:29.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.838]             base::sink(type = "output", split = FALSE)
[10:18:29.838]             base::close(...future.stdout)
[10:18:29.838]         }, add = TRUE)
[10:18:29.838]     }
[10:18:29.838]     ...future.frame <- base::sys.nframe()
[10:18:29.838]     ...future.conditions <- base::list()
[10:18:29.838]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.838]     if (FALSE) {
[10:18:29.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.838]     }
[10:18:29.838]     ...future.result <- base::tryCatch({
[10:18:29.838]         base::withCallingHandlers({
[10:18:29.838]             ...future.value <- base::withVisible(base::local({
[10:18:29.838]                 ...future.makeSendCondition <- base::local({
[10:18:29.838]                   sendCondition <- NULL
[10:18:29.838]                   function(frame = 1L) {
[10:18:29.838]                     if (is.function(sendCondition)) 
[10:18:29.838]                       return(sendCondition)
[10:18:29.838]                     ns <- getNamespace("parallel")
[10:18:29.838]                     if (exists("sendData", mode = "function", 
[10:18:29.838]                       envir = ns)) {
[10:18:29.838]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.838]                         envir = ns)
[10:18:29.838]                       envir <- sys.frame(frame)
[10:18:29.838]                       master <- NULL
[10:18:29.838]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.838]                         !identical(envir, emptyenv())) {
[10:18:29.838]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.838]                           inherits = FALSE)) {
[10:18:29.838]                           master <- get("master", mode = "list", 
[10:18:29.838]                             envir = envir, inherits = FALSE)
[10:18:29.838]                           if (inherits(master, c("SOCKnode", 
[10:18:29.838]                             "SOCK0node"))) {
[10:18:29.838]                             sendCondition <<- function(cond) {
[10:18:29.838]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.838]                                 success = TRUE)
[10:18:29.838]                               parallel_sendData(master, data)
[10:18:29.838]                             }
[10:18:29.838]                             return(sendCondition)
[10:18:29.838]                           }
[10:18:29.838]                         }
[10:18:29.838]                         frame <- frame + 1L
[10:18:29.838]                         envir <- sys.frame(frame)
[10:18:29.838]                       }
[10:18:29.838]                     }
[10:18:29.838]                     sendCondition <<- function(cond) NULL
[10:18:29.838]                   }
[10:18:29.838]                 })
[10:18:29.838]                 withCallingHandlers({
[10:18:29.838]                   {
[10:18:29.838]                     do.call(function(...) {
[10:18:29.838]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.838]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.838]                         ...future.globals.maxSize)) {
[10:18:29.838]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.838]                         on.exit(options(oopts), add = TRUE)
[10:18:29.838]                       }
[10:18:29.838]                       {
[10:18:29.838]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.838]                           FUN = function(jj) {
[10:18:29.838]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.838]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.838]                           })
[10:18:29.838]                       }
[10:18:29.838]                     }, args = future.call.arguments)
[10:18:29.838]                   }
[10:18:29.838]                 }, immediateCondition = function(cond) {
[10:18:29.838]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.838]                   sendCondition(cond)
[10:18:29.838]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.838]                   {
[10:18:29.838]                     inherits <- base::inherits
[10:18:29.838]                     invokeRestart <- base::invokeRestart
[10:18:29.838]                     is.null <- base::is.null
[10:18:29.838]                     muffled <- FALSE
[10:18:29.838]                     if (inherits(cond, "message")) {
[10:18:29.838]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.838]                       if (muffled) 
[10:18:29.838]                         invokeRestart("muffleMessage")
[10:18:29.838]                     }
[10:18:29.838]                     else if (inherits(cond, "warning")) {
[10:18:29.838]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.838]                       if (muffled) 
[10:18:29.838]                         invokeRestart("muffleWarning")
[10:18:29.838]                     }
[10:18:29.838]                     else if (inherits(cond, "condition")) {
[10:18:29.838]                       if (!is.null(pattern)) {
[10:18:29.838]                         computeRestarts <- base::computeRestarts
[10:18:29.838]                         grepl <- base::grepl
[10:18:29.838]                         restarts <- computeRestarts(cond)
[10:18:29.838]                         for (restart in restarts) {
[10:18:29.838]                           name <- restart$name
[10:18:29.838]                           if (is.null(name)) 
[10:18:29.838]                             next
[10:18:29.838]                           if (!grepl(pattern, name)) 
[10:18:29.838]                             next
[10:18:29.838]                           invokeRestart(restart)
[10:18:29.838]                           muffled <- TRUE
[10:18:29.838]                           break
[10:18:29.838]                         }
[10:18:29.838]                       }
[10:18:29.838]                     }
[10:18:29.838]                     invisible(muffled)
[10:18:29.838]                   }
[10:18:29.838]                   muffleCondition(cond)
[10:18:29.838]                 })
[10:18:29.838]             }))
[10:18:29.838]             future::FutureResult(value = ...future.value$value, 
[10:18:29.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.838]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.838]                     ...future.globalenv.names))
[10:18:29.838]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.838]         }, condition = base::local({
[10:18:29.838]             c <- base::c
[10:18:29.838]             inherits <- base::inherits
[10:18:29.838]             invokeRestart <- base::invokeRestart
[10:18:29.838]             length <- base::length
[10:18:29.838]             list <- base::list
[10:18:29.838]             seq.int <- base::seq.int
[10:18:29.838]             signalCondition <- base::signalCondition
[10:18:29.838]             sys.calls <- base::sys.calls
[10:18:29.838]             `[[` <- base::`[[`
[10:18:29.838]             `+` <- base::`+`
[10:18:29.838]             `<<-` <- base::`<<-`
[10:18:29.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.838]                   3L)]
[10:18:29.838]             }
[10:18:29.838]             function(cond) {
[10:18:29.838]                 is_error <- inherits(cond, "error")
[10:18:29.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.838]                   NULL)
[10:18:29.838]                 if (is_error) {
[10:18:29.838]                   sessionInformation <- function() {
[10:18:29.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.838]                       search = base::search(), system = base::Sys.info())
[10:18:29.838]                   }
[10:18:29.838]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.838]                     cond$call), session = sessionInformation(), 
[10:18:29.838]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.838]                   signalCondition(cond)
[10:18:29.838]                 }
[10:18:29.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.838]                 "immediateCondition"))) {
[10:18:29.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.838]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.838]                   if (TRUE && !signal) {
[10:18:29.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.838]                     {
[10:18:29.838]                       inherits <- base::inherits
[10:18:29.838]                       invokeRestart <- base::invokeRestart
[10:18:29.838]                       is.null <- base::is.null
[10:18:29.838]                       muffled <- FALSE
[10:18:29.838]                       if (inherits(cond, "message")) {
[10:18:29.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.838]                         if (muffled) 
[10:18:29.838]                           invokeRestart("muffleMessage")
[10:18:29.838]                       }
[10:18:29.838]                       else if (inherits(cond, "warning")) {
[10:18:29.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.838]                         if (muffled) 
[10:18:29.838]                           invokeRestart("muffleWarning")
[10:18:29.838]                       }
[10:18:29.838]                       else if (inherits(cond, "condition")) {
[10:18:29.838]                         if (!is.null(pattern)) {
[10:18:29.838]                           computeRestarts <- base::computeRestarts
[10:18:29.838]                           grepl <- base::grepl
[10:18:29.838]                           restarts <- computeRestarts(cond)
[10:18:29.838]                           for (restart in restarts) {
[10:18:29.838]                             name <- restart$name
[10:18:29.838]                             if (is.null(name)) 
[10:18:29.838]                               next
[10:18:29.838]                             if (!grepl(pattern, name)) 
[10:18:29.838]                               next
[10:18:29.838]                             invokeRestart(restart)
[10:18:29.838]                             muffled <- TRUE
[10:18:29.838]                             break
[10:18:29.838]                           }
[10:18:29.838]                         }
[10:18:29.838]                       }
[10:18:29.838]                       invisible(muffled)
[10:18:29.838]                     }
[10:18:29.838]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.838]                   }
[10:18:29.838]                 }
[10:18:29.838]                 else {
[10:18:29.838]                   if (TRUE) {
[10:18:29.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.838]                     {
[10:18:29.838]                       inherits <- base::inherits
[10:18:29.838]                       invokeRestart <- base::invokeRestart
[10:18:29.838]                       is.null <- base::is.null
[10:18:29.838]                       muffled <- FALSE
[10:18:29.838]                       if (inherits(cond, "message")) {
[10:18:29.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.838]                         if (muffled) 
[10:18:29.838]                           invokeRestart("muffleMessage")
[10:18:29.838]                       }
[10:18:29.838]                       else if (inherits(cond, "warning")) {
[10:18:29.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.838]                         if (muffled) 
[10:18:29.838]                           invokeRestart("muffleWarning")
[10:18:29.838]                       }
[10:18:29.838]                       else if (inherits(cond, "condition")) {
[10:18:29.838]                         if (!is.null(pattern)) {
[10:18:29.838]                           computeRestarts <- base::computeRestarts
[10:18:29.838]                           grepl <- base::grepl
[10:18:29.838]                           restarts <- computeRestarts(cond)
[10:18:29.838]                           for (restart in restarts) {
[10:18:29.838]                             name <- restart$name
[10:18:29.838]                             if (is.null(name)) 
[10:18:29.838]                               next
[10:18:29.838]                             if (!grepl(pattern, name)) 
[10:18:29.838]                               next
[10:18:29.838]                             invokeRestart(restart)
[10:18:29.838]                             muffled <- TRUE
[10:18:29.838]                             break
[10:18:29.838]                           }
[10:18:29.838]                         }
[10:18:29.838]                       }
[10:18:29.838]                       invisible(muffled)
[10:18:29.838]                     }
[10:18:29.838]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.838]                   }
[10:18:29.838]                 }
[10:18:29.838]             }
[10:18:29.838]         }))
[10:18:29.838]     }, error = function(ex) {
[10:18:29.838]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.838]                 ...future.rng), started = ...future.startTime, 
[10:18:29.838]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.838]             version = "1.8"), class = "FutureResult")
[10:18:29.838]     }, finally = {
[10:18:29.838]         if (!identical(...future.workdir, getwd())) 
[10:18:29.838]             setwd(...future.workdir)
[10:18:29.838]         {
[10:18:29.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.838]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.838]             }
[10:18:29.838]             base::options(...future.oldOptions)
[10:18:29.838]             if (.Platform$OS.type == "windows") {
[10:18:29.838]                 old_names <- names(...future.oldEnvVars)
[10:18:29.838]                 envs <- base::Sys.getenv()
[10:18:29.838]                 names <- names(envs)
[10:18:29.838]                 common <- intersect(names, old_names)
[10:18:29.838]                 added <- setdiff(names, old_names)
[10:18:29.838]                 removed <- setdiff(old_names, names)
[10:18:29.838]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.838]                   envs[common]]
[10:18:29.838]                 NAMES <- toupper(changed)
[10:18:29.838]                 args <- list()
[10:18:29.838]                 for (kk in seq_along(NAMES)) {
[10:18:29.838]                   name <- changed[[kk]]
[10:18:29.838]                   NAME <- NAMES[[kk]]
[10:18:29.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.838]                     next
[10:18:29.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.838]                 }
[10:18:29.838]                 NAMES <- toupper(added)
[10:18:29.838]                 for (kk in seq_along(NAMES)) {
[10:18:29.838]                   name <- added[[kk]]
[10:18:29.838]                   NAME <- NAMES[[kk]]
[10:18:29.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.838]                     next
[10:18:29.838]                   args[[name]] <- ""
[10:18:29.838]                 }
[10:18:29.838]                 NAMES <- toupper(removed)
[10:18:29.838]                 for (kk in seq_along(NAMES)) {
[10:18:29.838]                   name <- removed[[kk]]
[10:18:29.838]                   NAME <- NAMES[[kk]]
[10:18:29.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.838]                     next
[10:18:29.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.838]                 }
[10:18:29.838]                 if (length(args) > 0) 
[10:18:29.838]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.838]             }
[10:18:29.838]             else {
[10:18:29.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.838]             }
[10:18:29.838]             {
[10:18:29.838]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.838]                   0L) {
[10:18:29.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.838]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.838]                   base::options(opts)
[10:18:29.838]                 }
[10:18:29.838]                 {
[10:18:29.838]                   {
[10:18:29.838]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.838]                     NULL
[10:18:29.838]                   }
[10:18:29.838]                   options(future.plan = NULL)
[10:18:29.838]                   if (is.na(NA_character_)) 
[10:18:29.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.838]                     .init = FALSE)
[10:18:29.838]                 }
[10:18:29.838]             }
[10:18:29.838]         }
[10:18:29.838]     })
[10:18:29.838]     if (TRUE) {
[10:18:29.838]         base::sink(type = "output", split = FALSE)
[10:18:29.838]         if (TRUE) {
[10:18:29.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.838]         }
[10:18:29.838]         else {
[10:18:29.838]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.838]         }
[10:18:29.838]         base::close(...future.stdout)
[10:18:29.838]         ...future.stdout <- NULL
[10:18:29.838]     }
[10:18:29.838]     ...future.result$conditions <- ...future.conditions
[10:18:29.838]     ...future.result$finished <- base::Sys.time()
[10:18:29.838]     ...future.result
[10:18:29.838] }
[10:18:29.840] Exporting 5 global objects (913 bytes) to cluster node #2 ...
[10:18:29.841] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:29.841] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:29.841] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ...
[10:18:29.842] Exporting ‘...future.FUN’ (185 bytes) to cluster node #2 ... DONE
[10:18:29.842] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #2 ...
[10:18:29.842] Exporting ‘...future.elements_ii’ (102 bytes) to cluster node #2 ... DONE
[10:18:29.842] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:29.843] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:29.843] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:29.843] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:29.843] Exporting 5 global objects (913 bytes) to cluster node #2 ... DONE
[10:18:29.844] MultisessionFuture started
[10:18:29.844] - Launch lazy future ... done
[10:18:29.844] run() for ‘MultisessionFuture’ ... done
[10:18:29.844] Created future:
[10:18:29.844] MultisessionFuture:
[10:18:29.844] Label: ‘future_apply-2’
[10:18:29.844] Expression:
[10:18:29.844] {
[10:18:29.844]     do.call(function(...) {
[10:18:29.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.844]             on.exit(options(oopts), add = TRUE)
[10:18:29.844]         }
[10:18:29.844]         {
[10:18:29.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.844]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.844]             })
[10:18:29.844]         }
[10:18:29.844]     }, args = future.call.arguments)
[10:18:29.844] }
[10:18:29.844] Lazy evaluation: FALSE
[10:18:29.844] Asynchronous evaluation: TRUE
[10:18:29.844] Local evaluation: TRUE
[10:18:29.844] Environment: R_GlobalEnv
[10:18:29.844] Capture standard output: TRUE
[10:18:29.844] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.844] Globals: 5 objects totaling 450 bytes (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 185 bytes, list ‘...future.elements_ii’ of 102 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.844] Packages: <none>
[10:18:29.844] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.844] Resolved: FALSE
[10:18:29.844] Value: <not collected>
[10:18:29.844] Conditions captured: <none>
[10:18:29.844] Early signaling: FALSE
[10:18:29.844] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.844] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.855] Chunk #2 of 2 ... DONE
[10:18:29.856] Launching 2 futures (chunks) ... DONE
[10:18:29.856] Resolving 2 futures (chunks) ...
[10:18:29.856] resolve() on list ...
[10:18:29.856]  recursive: 0
[10:18:29.856]  length: 2
[10:18:29.856] 
[10:18:29.856] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.857] - Validating connection of MultisessionFuture
[10:18:29.857] - received message: FutureResult
[10:18:29.857] - Received FutureResult
[10:18:29.857] - Erased future from FutureRegistry
[10:18:29.857] result() for ClusterFuture ...
[10:18:29.857] - result already collected: FutureResult
[10:18:29.857] result() for ClusterFuture ... done
[10:18:29.857] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.857] Future #1
[10:18:29.858] result() for ClusterFuture ...
[10:18:29.858] - result already collected: FutureResult
[10:18:29.858] result() for ClusterFuture ... done
[10:18:29.858] result() for ClusterFuture ...
[10:18:29.858] - result already collected: FutureResult
[10:18:29.858] result() for ClusterFuture ... done
[10:18:29.858] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:29.858] - nx: 2
[10:18:29.858] - relay: TRUE
[10:18:29.858] - stdout: TRUE
[10:18:29.858] - signal: TRUE
[10:18:29.858] - resignal: FALSE
[10:18:29.859] - force: TRUE
[10:18:29.859] - relayed: [n=2] FALSE, FALSE
[10:18:29.859] - queued futures: [n=2] FALSE, FALSE
[10:18:29.859]  - until=1
[10:18:29.859]  - relaying element #1
[10:18:29.859] result() for ClusterFuture ...
[10:18:29.859] - result already collected: FutureResult
[10:18:29.859] result() for ClusterFuture ... done
[10:18:29.859] result() for ClusterFuture ...
[10:18:29.859] - result already collected: FutureResult
[10:18:29.859] result() for ClusterFuture ... done
[10:18:29.859] result() for ClusterFuture ...
[10:18:29.860] - result already collected: FutureResult
[10:18:29.860] result() for ClusterFuture ... done
[10:18:29.860] result() for ClusterFuture ...
[10:18:29.860] - result already collected: FutureResult
[10:18:29.860] result() for ClusterFuture ... done
[10:18:29.860] - relayed: [n=2] TRUE, FALSE
[10:18:29.860] - queued futures: [n=2] TRUE, FALSE
[10:18:29.860] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:29.860]  length: 1 (resolved future 1)
[10:18:29.886] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.886] - Validating connection of MultisessionFuture
[10:18:29.886] - received message: FutureResult
[10:18:29.886] - Received FutureResult
[10:18:29.887] - Erased future from FutureRegistry
[10:18:29.887] result() for ClusterFuture ...
[10:18:29.887] - result already collected: FutureResult
[10:18:29.887] result() for ClusterFuture ... done
[10:18:29.887] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.887] Future #2
[10:18:29.887] result() for ClusterFuture ...
[10:18:29.887] - result already collected: FutureResult
[10:18:29.887] result() for ClusterFuture ... done
[10:18:29.887] result() for ClusterFuture ...
[10:18:29.887] - result already collected: FutureResult
[10:18:29.888] result() for ClusterFuture ... done
[10:18:29.888] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:29.888] - nx: 2
[10:18:29.888] - relay: TRUE
[10:18:29.888] - stdout: TRUE
[10:18:29.888] - signal: TRUE
[10:18:29.888] - resignal: FALSE
[10:18:29.888] - force: TRUE
[10:18:29.888] - relayed: [n=2] TRUE, FALSE
[10:18:29.888] - queued futures: [n=2] TRUE, FALSE
[10:18:29.888]  - until=2
[10:18:29.889]  - relaying element #2
[10:18:29.889] result() for ClusterFuture ...
[10:18:29.889] - result already collected: FutureResult
[10:18:29.889] result() for ClusterFuture ... done
[10:18:29.889] result() for ClusterFuture ...
[10:18:29.889] - result already collected: FutureResult
[10:18:29.889] result() for ClusterFuture ... done
[10:18:29.889] result() for ClusterFuture ...
[10:18:29.889] - result already collected: FutureResult
[10:18:29.889] result() for ClusterFuture ... done
[10:18:29.889] result() for ClusterFuture ...
[10:18:29.890] - result already collected: FutureResult
[10:18:29.890] result() for ClusterFuture ... done
[10:18:29.890] - relayed: [n=2] TRUE, TRUE
[10:18:29.890] - queued futures: [n=2] TRUE, TRUE
[10:18:29.890] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:29.890]  length: 0 (resolved future 2)
[10:18:29.890] Relaying remaining futures
[10:18:29.890] signalConditionsASAP(NULL, pos=0) ...
[10:18:29.890] - nx: 2
[10:18:29.890] - relay: TRUE
[10:18:29.890] - stdout: TRUE
[10:18:29.890] - signal: TRUE
[10:18:29.890] - resignal: FALSE
[10:18:29.891] - force: TRUE
[10:18:29.891] - relayed: [n=2] TRUE, TRUE
[10:18:29.891] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:29.891] - relayed: [n=2] TRUE, TRUE
[10:18:29.891] - queued futures: [n=2] TRUE, TRUE
[10:18:29.891] signalConditionsASAP(NULL, pos=0) ... done
[10:18:29.891] resolve() on list ... DONE
[10:18:29.891] result() for ClusterFuture ...
[10:18:29.891] - result already collected: FutureResult
[10:18:29.891] result() for ClusterFuture ... done
[10:18:29.891] result() for ClusterFuture ...
[10:18:29.892] - result already collected: FutureResult
[10:18:29.892] result() for ClusterFuture ... done
[10:18:29.892] result() for ClusterFuture ...
[10:18:29.892] - result already collected: FutureResult
[10:18:29.892] result() for ClusterFuture ... done
[10:18:29.892] result() for ClusterFuture ...
[10:18:29.892] - result already collected: FutureResult
[10:18:29.892] result() for ClusterFuture ... done
[10:18:29.892]  - Number of value chunks collected: 2
[10:18:29.892] Resolving 2 futures (chunks) ... DONE
[10:18:29.892] Reducing values from 2 chunks ...
[10:18:29.892]  - Number of values collected after concatenation: 2
[10:18:29.893]  - Number of values expected: 2
[10:18:29.893] Reducing values from 2 chunks ... DONE
[10:18:29.893] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
[3,]    5    6
[4,]    7    8
[5,]    9   10
[6,]   11   12
- apply(X, ...) - not all same names ...
[10:18:29.893] getGlobalsAndPackagesXApply() ...
[10:18:29.893]  - future.globals: TRUE
[10:18:29.893] getGlobalsAndPackages() ...
[10:18:29.893] Searching for globals...
[10:18:29.896] - globals found: [10] ‘FUN’, ‘{’, ‘if’, ‘==’, ‘[’, ‘<-’, ‘names’, ‘names<-’, ‘letters’, ‘seq_along’
[10:18:29.897] Searching for globals ... DONE
[10:18:29.897] Resolving globals: FALSE
[10:18:29.897] The total size of the 1 globals is 1.28 KiB (1311 bytes)
[10:18:29.898] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 1.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (1.28 KiB of class ‘function’)
[10:18:29.898] - globals: [1] ‘FUN’
[10:18:29.898] 
[10:18:29.898] getGlobalsAndPackages() ... DONE
[10:18:29.898]  - globals found/used: [n=1] ‘FUN’
[10:18:29.898]  - needed namespaces: [n=0] 
[10:18:29.898] Finding globals ... DONE
[10:18:29.898]  - use_args: TRUE
[10:18:29.899]  - Getting '...' globals ...
[10:18:29.899] resolve() on list ...
[10:18:29.899]  recursive: 0
[10:18:29.899]  length: 1
[10:18:29.899]  elements: ‘...’
[10:18:29.899]  length: 0 (resolved future 1)
[10:18:29.899] resolve() on list ... DONE
[10:18:29.899]    - '...' content: [n=0] 
[10:18:29.900] List of 1
[10:18:29.900]  $ ...: list()
[10:18:29.900]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.900]  - attr(*, "where")=List of 1
[10:18:29.900]   ..$ ...:<environment: 0x556e0582bc18> 
[10:18:29.900]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.900]  - attr(*, "resolved")= logi TRUE
[10:18:29.900]  - attr(*, "total_size")= num NA
[10:18:29.902]  - Getting '...' globals ... DONE
[10:18:29.902] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:29.902] List of 2
[10:18:29.902]  $ ...future.FUN:function (x)  
[10:18:29.902]  $ ...          : list()
[10:18:29.902]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.902]  - attr(*, "where")=List of 2
[10:18:29.902]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:29.902]   ..$ ...          :<environment: 0x556e0582bc18> 
[10:18:29.902]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.902]  - attr(*, "resolved")= logi FALSE
[10:18:29.902]  - attr(*, "total_size")= num 4449
[10:18:29.905] Packages to be attached in all futures: [n=0] 
[10:18:29.905] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.907] future_lapply() ...
[10:18:29.909] Number of chunks: 2
[10:18:29.910] getGlobalsAndPackagesXApply() ...
[10:18:29.910]  - future.globals: <name-value list> with names ‘list()’
[10:18:29.910]  - use_args: TRUE
[10:18:29.910] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:29.910] List of 2
[10:18:29.910]  $ ...          : list()
[10:18:29.910]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:29.910]  $ ...future.FUN:function (x)  
[10:18:29.910]  - attr(*, "where")=List of 2
[10:18:29.910]   ..$ ...          :<environment: 0x556e0582bc18> 
[10:18:29.910]   ..$ ...future.FUN:<environment: R_GlobalEnv> 
[10:18:29.910]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:29.910]  - attr(*, "resolved")= logi FALSE
[10:18:29.910]  - attr(*, "total_size")= num NA
[10:18:29.915] Packages to be attached in all futures: [n=0] 
[10:18:29.915] getGlobalsAndPackagesXApply() ... DONE
[10:18:29.915] Number of futures (= number of chunks): 2
[10:18:29.916] Launching 2 futures (chunks) ...
[10:18:29.916] Chunk #1 of 2 ...
[10:18:29.916]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.916]  - seeds: <none>
[10:18:29.916]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.916] getGlobalsAndPackages() ...
[10:18:29.916] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.916] Resolving globals: FALSE
[10:18:29.916] Tweak future expression to call with '...' arguments ...
[10:18:29.916] {
[10:18:29.916]     do.call(function(...) {
[10:18:29.916]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.916]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.916]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.916]             on.exit(options(oopts), add = TRUE)
[10:18:29.916]         }
[10:18:29.916]         {
[10:18:29.916]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.916]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.916]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.916]             })
[10:18:29.916]         }
[10:18:29.916]     }, args = future.call.arguments)
[10:18:29.916] }
[10:18:29.917] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.917] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.917] 
[10:18:29.917] getGlobalsAndPackages() ... DONE
[10:18:29.918] run() for ‘Future’ ...
[10:18:29.918] - state: ‘created’
[10:18:29.918] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.932] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.932]   - Field: ‘node’
[10:18:29.932]   - Field: ‘label’
[10:18:29.932]   - Field: ‘local’
[10:18:29.932]   - Field: ‘owner’
[10:18:29.932]   - Field: ‘envir’
[10:18:29.932]   - Field: ‘workers’
[10:18:29.933]   - Field: ‘packages’
[10:18:29.933]   - Field: ‘gc’
[10:18:29.933]   - Field: ‘conditions’
[10:18:29.933]   - Field: ‘persistent’
[10:18:29.933]   - Field: ‘expr’
[10:18:29.933]   - Field: ‘uuid’
[10:18:29.933]   - Field: ‘seed’
[10:18:29.933]   - Field: ‘version’
[10:18:29.933]   - Field: ‘result’
[10:18:29.933]   - Field: ‘asynchronous’
[10:18:29.933]   - Field: ‘calls’
[10:18:29.933]   - Field: ‘globals’
[10:18:29.934]   - Field: ‘stdout’
[10:18:29.934]   - Field: ‘earlySignal’
[10:18:29.934]   - Field: ‘lazy’
[10:18:29.934]   - Field: ‘state’
[10:18:29.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.934] - Launch lazy future ...
[10:18:29.934] Packages needed by the future expression (n = 0): <none>
[10:18:29.934] Packages needed by future strategies (n = 0): <none>
[10:18:29.935] {
[10:18:29.935]     {
[10:18:29.935]         {
[10:18:29.935]             ...future.startTime <- base::Sys.time()
[10:18:29.935]             {
[10:18:29.935]                 {
[10:18:29.935]                   {
[10:18:29.935]                     {
[10:18:29.935]                       base::local({
[10:18:29.935]                         has_future <- base::requireNamespace("future", 
[10:18:29.935]                           quietly = TRUE)
[10:18:29.935]                         if (has_future) {
[10:18:29.935]                           ns <- base::getNamespace("future")
[10:18:29.935]                           version <- ns[[".package"]][["version"]]
[10:18:29.935]                           if (is.null(version)) 
[10:18:29.935]                             version <- utils::packageVersion("future")
[10:18:29.935]                         }
[10:18:29.935]                         else {
[10:18:29.935]                           version <- NULL
[10:18:29.935]                         }
[10:18:29.935]                         if (!has_future || version < "1.8.0") {
[10:18:29.935]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.935]                             "", base::R.version$version.string), 
[10:18:29.935]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.935]                               "release", "version")], collapse = " "), 
[10:18:29.935]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.935]                             info)
[10:18:29.935]                           info <- base::paste(info, collapse = "; ")
[10:18:29.935]                           if (!has_future) {
[10:18:29.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.935]                               info)
[10:18:29.935]                           }
[10:18:29.935]                           else {
[10:18:29.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.935]                               info, version)
[10:18:29.935]                           }
[10:18:29.935]                           base::stop(msg)
[10:18:29.935]                         }
[10:18:29.935]                       })
[10:18:29.935]                     }
[10:18:29.935]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.935]                     base::options(mc.cores = 1L)
[10:18:29.935]                   }
[10:18:29.935]                   ...future.strategy.old <- future::plan("list")
[10:18:29.935]                   options(future.plan = NULL)
[10:18:29.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.935]                 }
[10:18:29.935]                 ...future.workdir <- getwd()
[10:18:29.935]             }
[10:18:29.935]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.935]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.935]         }
[10:18:29.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.935]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.935]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.935]             base::names(...future.oldOptions))
[10:18:29.935]     }
[10:18:29.935]     if (FALSE) {
[10:18:29.935]     }
[10:18:29.935]     else {
[10:18:29.935]         if (TRUE) {
[10:18:29.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.935]                 open = "w")
[10:18:29.935]         }
[10:18:29.935]         else {
[10:18:29.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.935]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.935]         }
[10:18:29.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.935]             base::sink(type = "output", split = FALSE)
[10:18:29.935]             base::close(...future.stdout)
[10:18:29.935]         }, add = TRUE)
[10:18:29.935]     }
[10:18:29.935]     ...future.frame <- base::sys.nframe()
[10:18:29.935]     ...future.conditions <- base::list()
[10:18:29.935]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.935]     if (FALSE) {
[10:18:29.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.935]     }
[10:18:29.935]     ...future.result <- base::tryCatch({
[10:18:29.935]         base::withCallingHandlers({
[10:18:29.935]             ...future.value <- base::withVisible(base::local({
[10:18:29.935]                 ...future.makeSendCondition <- base::local({
[10:18:29.935]                   sendCondition <- NULL
[10:18:29.935]                   function(frame = 1L) {
[10:18:29.935]                     if (is.function(sendCondition)) 
[10:18:29.935]                       return(sendCondition)
[10:18:29.935]                     ns <- getNamespace("parallel")
[10:18:29.935]                     if (exists("sendData", mode = "function", 
[10:18:29.935]                       envir = ns)) {
[10:18:29.935]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.935]                         envir = ns)
[10:18:29.935]                       envir <- sys.frame(frame)
[10:18:29.935]                       master <- NULL
[10:18:29.935]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.935]                         !identical(envir, emptyenv())) {
[10:18:29.935]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.935]                           inherits = FALSE)) {
[10:18:29.935]                           master <- get("master", mode = "list", 
[10:18:29.935]                             envir = envir, inherits = FALSE)
[10:18:29.935]                           if (inherits(master, c("SOCKnode", 
[10:18:29.935]                             "SOCK0node"))) {
[10:18:29.935]                             sendCondition <<- function(cond) {
[10:18:29.935]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.935]                                 success = TRUE)
[10:18:29.935]                               parallel_sendData(master, data)
[10:18:29.935]                             }
[10:18:29.935]                             return(sendCondition)
[10:18:29.935]                           }
[10:18:29.935]                         }
[10:18:29.935]                         frame <- frame + 1L
[10:18:29.935]                         envir <- sys.frame(frame)
[10:18:29.935]                       }
[10:18:29.935]                     }
[10:18:29.935]                     sendCondition <<- function(cond) NULL
[10:18:29.935]                   }
[10:18:29.935]                 })
[10:18:29.935]                 withCallingHandlers({
[10:18:29.935]                   {
[10:18:29.935]                     do.call(function(...) {
[10:18:29.935]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.935]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.935]                         ...future.globals.maxSize)) {
[10:18:29.935]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.935]                         on.exit(options(oopts), add = TRUE)
[10:18:29.935]                       }
[10:18:29.935]                       {
[10:18:29.935]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.935]                           FUN = function(jj) {
[10:18:29.935]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.935]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.935]                           })
[10:18:29.935]                       }
[10:18:29.935]                     }, args = future.call.arguments)
[10:18:29.935]                   }
[10:18:29.935]                 }, immediateCondition = function(cond) {
[10:18:29.935]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.935]                   sendCondition(cond)
[10:18:29.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.935]                   {
[10:18:29.935]                     inherits <- base::inherits
[10:18:29.935]                     invokeRestart <- base::invokeRestart
[10:18:29.935]                     is.null <- base::is.null
[10:18:29.935]                     muffled <- FALSE
[10:18:29.935]                     if (inherits(cond, "message")) {
[10:18:29.935]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.935]                       if (muffled) 
[10:18:29.935]                         invokeRestart("muffleMessage")
[10:18:29.935]                     }
[10:18:29.935]                     else if (inherits(cond, "warning")) {
[10:18:29.935]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.935]                       if (muffled) 
[10:18:29.935]                         invokeRestart("muffleWarning")
[10:18:29.935]                     }
[10:18:29.935]                     else if (inherits(cond, "condition")) {
[10:18:29.935]                       if (!is.null(pattern)) {
[10:18:29.935]                         computeRestarts <- base::computeRestarts
[10:18:29.935]                         grepl <- base::grepl
[10:18:29.935]                         restarts <- computeRestarts(cond)
[10:18:29.935]                         for (restart in restarts) {
[10:18:29.935]                           name <- restart$name
[10:18:29.935]                           if (is.null(name)) 
[10:18:29.935]                             next
[10:18:29.935]                           if (!grepl(pattern, name)) 
[10:18:29.935]                             next
[10:18:29.935]                           invokeRestart(restart)
[10:18:29.935]                           muffled <- TRUE
[10:18:29.935]                           break
[10:18:29.935]                         }
[10:18:29.935]                       }
[10:18:29.935]                     }
[10:18:29.935]                     invisible(muffled)
[10:18:29.935]                   }
[10:18:29.935]                   muffleCondition(cond)
[10:18:29.935]                 })
[10:18:29.935]             }))
[10:18:29.935]             future::FutureResult(value = ...future.value$value, 
[10:18:29.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.935]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.935]                     ...future.globalenv.names))
[10:18:29.935]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.935]         }, condition = base::local({
[10:18:29.935]             c <- base::c
[10:18:29.935]             inherits <- base::inherits
[10:18:29.935]             invokeRestart <- base::invokeRestart
[10:18:29.935]             length <- base::length
[10:18:29.935]             list <- base::list
[10:18:29.935]             seq.int <- base::seq.int
[10:18:29.935]             signalCondition <- base::signalCondition
[10:18:29.935]             sys.calls <- base::sys.calls
[10:18:29.935]             `[[` <- base::`[[`
[10:18:29.935]             `+` <- base::`+`
[10:18:29.935]             `<<-` <- base::`<<-`
[10:18:29.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.935]                   3L)]
[10:18:29.935]             }
[10:18:29.935]             function(cond) {
[10:18:29.935]                 is_error <- inherits(cond, "error")
[10:18:29.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.935]                   NULL)
[10:18:29.935]                 if (is_error) {
[10:18:29.935]                   sessionInformation <- function() {
[10:18:29.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.935]                       search = base::search(), system = base::Sys.info())
[10:18:29.935]                   }
[10:18:29.935]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.935]                     cond$call), session = sessionInformation(), 
[10:18:29.935]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.935]                   signalCondition(cond)
[10:18:29.935]                 }
[10:18:29.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.935]                 "immediateCondition"))) {
[10:18:29.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.935]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.935]                   if (TRUE && !signal) {
[10:18:29.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.935]                     {
[10:18:29.935]                       inherits <- base::inherits
[10:18:29.935]                       invokeRestart <- base::invokeRestart
[10:18:29.935]                       is.null <- base::is.null
[10:18:29.935]                       muffled <- FALSE
[10:18:29.935]                       if (inherits(cond, "message")) {
[10:18:29.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.935]                         if (muffled) 
[10:18:29.935]                           invokeRestart("muffleMessage")
[10:18:29.935]                       }
[10:18:29.935]                       else if (inherits(cond, "warning")) {
[10:18:29.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.935]                         if (muffled) 
[10:18:29.935]                           invokeRestart("muffleWarning")
[10:18:29.935]                       }
[10:18:29.935]                       else if (inherits(cond, "condition")) {
[10:18:29.935]                         if (!is.null(pattern)) {
[10:18:29.935]                           computeRestarts <- base::computeRestarts
[10:18:29.935]                           grepl <- base::grepl
[10:18:29.935]                           restarts <- computeRestarts(cond)
[10:18:29.935]                           for (restart in restarts) {
[10:18:29.935]                             name <- restart$name
[10:18:29.935]                             if (is.null(name)) 
[10:18:29.935]                               next
[10:18:29.935]                             if (!grepl(pattern, name)) 
[10:18:29.935]                               next
[10:18:29.935]                             invokeRestart(restart)
[10:18:29.935]                             muffled <- TRUE
[10:18:29.935]                             break
[10:18:29.935]                           }
[10:18:29.935]                         }
[10:18:29.935]                       }
[10:18:29.935]                       invisible(muffled)
[10:18:29.935]                     }
[10:18:29.935]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.935]                   }
[10:18:29.935]                 }
[10:18:29.935]                 else {
[10:18:29.935]                   if (TRUE) {
[10:18:29.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.935]                     {
[10:18:29.935]                       inherits <- base::inherits
[10:18:29.935]                       invokeRestart <- base::invokeRestart
[10:18:29.935]                       is.null <- base::is.null
[10:18:29.935]                       muffled <- FALSE
[10:18:29.935]                       if (inherits(cond, "message")) {
[10:18:29.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.935]                         if (muffled) 
[10:18:29.935]                           invokeRestart("muffleMessage")
[10:18:29.935]                       }
[10:18:29.935]                       else if (inherits(cond, "warning")) {
[10:18:29.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.935]                         if (muffled) 
[10:18:29.935]                           invokeRestart("muffleWarning")
[10:18:29.935]                       }
[10:18:29.935]                       else if (inherits(cond, "condition")) {
[10:18:29.935]                         if (!is.null(pattern)) {
[10:18:29.935]                           computeRestarts <- base::computeRestarts
[10:18:29.935]                           grepl <- base::grepl
[10:18:29.935]                           restarts <- computeRestarts(cond)
[10:18:29.935]                           for (restart in restarts) {
[10:18:29.935]                             name <- restart$name
[10:18:29.935]                             if (is.null(name)) 
[10:18:29.935]                               next
[10:18:29.935]                             if (!grepl(pattern, name)) 
[10:18:29.935]                               next
[10:18:29.935]                             invokeRestart(restart)
[10:18:29.935]                             muffled <- TRUE
[10:18:29.935]                             break
[10:18:29.935]                           }
[10:18:29.935]                         }
[10:18:29.935]                       }
[10:18:29.935]                       invisible(muffled)
[10:18:29.935]                     }
[10:18:29.935]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.935]                   }
[10:18:29.935]                 }
[10:18:29.935]             }
[10:18:29.935]         }))
[10:18:29.935]     }, error = function(ex) {
[10:18:29.935]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.935]                 ...future.rng), started = ...future.startTime, 
[10:18:29.935]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.935]             version = "1.8"), class = "FutureResult")
[10:18:29.935]     }, finally = {
[10:18:29.935]         if (!identical(...future.workdir, getwd())) 
[10:18:29.935]             setwd(...future.workdir)
[10:18:29.935]         {
[10:18:29.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.935]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.935]             }
[10:18:29.935]             base::options(...future.oldOptions)
[10:18:29.935]             if (.Platform$OS.type == "windows") {
[10:18:29.935]                 old_names <- names(...future.oldEnvVars)
[10:18:29.935]                 envs <- base::Sys.getenv()
[10:18:29.935]                 names <- names(envs)
[10:18:29.935]                 common <- intersect(names, old_names)
[10:18:29.935]                 added <- setdiff(names, old_names)
[10:18:29.935]                 removed <- setdiff(old_names, names)
[10:18:29.935]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.935]                   envs[common]]
[10:18:29.935]                 NAMES <- toupper(changed)
[10:18:29.935]                 args <- list()
[10:18:29.935]                 for (kk in seq_along(NAMES)) {
[10:18:29.935]                   name <- changed[[kk]]
[10:18:29.935]                   NAME <- NAMES[[kk]]
[10:18:29.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.935]                     next
[10:18:29.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.935]                 }
[10:18:29.935]                 NAMES <- toupper(added)
[10:18:29.935]                 for (kk in seq_along(NAMES)) {
[10:18:29.935]                   name <- added[[kk]]
[10:18:29.935]                   NAME <- NAMES[[kk]]
[10:18:29.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.935]                     next
[10:18:29.935]                   args[[name]] <- ""
[10:18:29.935]                 }
[10:18:29.935]                 NAMES <- toupper(removed)
[10:18:29.935]                 for (kk in seq_along(NAMES)) {
[10:18:29.935]                   name <- removed[[kk]]
[10:18:29.935]                   NAME <- NAMES[[kk]]
[10:18:29.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.935]                     next
[10:18:29.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.935]                 }
[10:18:29.935]                 if (length(args) > 0) 
[10:18:29.935]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.935]             }
[10:18:29.935]             else {
[10:18:29.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.935]             }
[10:18:29.935]             {
[10:18:29.935]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.935]                   0L) {
[10:18:29.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.935]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.935]                   base::options(opts)
[10:18:29.935]                 }
[10:18:29.935]                 {
[10:18:29.935]                   {
[10:18:29.935]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.935]                     NULL
[10:18:29.935]                   }
[10:18:29.935]                   options(future.plan = NULL)
[10:18:29.935]                   if (is.na(NA_character_)) 
[10:18:29.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.935]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.935]                     .init = FALSE)
[10:18:29.935]                 }
[10:18:29.935]             }
[10:18:29.935]         }
[10:18:29.935]     })
[10:18:29.935]     if (TRUE) {
[10:18:29.935]         base::sink(type = "output", split = FALSE)
[10:18:29.935]         if (TRUE) {
[10:18:29.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.935]         }
[10:18:29.935]         else {
[10:18:29.935]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.935]         }
[10:18:29.935]         base::close(...future.stdout)
[10:18:29.935]         ...future.stdout <- NULL
[10:18:29.935]     }
[10:18:29.935]     ...future.result$conditions <- ...future.conditions
[10:18:29.935]     ...future.result$finished <- base::Sys.time()
[10:18:29.935]     ...future.result
[10:18:29.935] }
[10:18:29.938] Exporting 5 global objects (1.92 KiB) to cluster node #1 ...
[10:18:29.938] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:29.938] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:29.938] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ...
[10:18:29.939] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #1 ... DONE
[10:18:29.939] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ...
[10:18:29.939] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ... DONE
[10:18:29.939] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ...
[10:18:29.940] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #1 ... DONE
[10:18:29.940] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:29.940] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:29.940] Exporting 5 global objects (1.92 KiB) to cluster node #1 ... DONE
[10:18:29.941] MultisessionFuture started
[10:18:29.941] - Launch lazy future ... done
[10:18:29.941] run() for ‘MultisessionFuture’ ... done
[10:18:29.941] Created future:
[10:18:29.941] MultisessionFuture:
[10:18:29.941] Label: ‘future_apply-1’
[10:18:29.941] Expression:
[10:18:29.941] {
[10:18:29.941]     do.call(function(...) {
[10:18:29.941]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.941]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.941]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.941]             on.exit(options(oopts), add = TRUE)
[10:18:29.941]         }
[10:18:29.941]         {
[10:18:29.941]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.941]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.941]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.941]             })
[10:18:29.941]         }
[10:18:29.941]     }, args = future.call.arguments)
[10:18:29.941] }
[10:18:29.941] Lazy evaluation: FALSE
[10:18:29.941] Asynchronous evaluation: TRUE
[10:18:29.941] Local evaluation: TRUE
[10:18:29.941] Environment: R_GlobalEnv
[10:18:29.941] Capture standard output: TRUE
[10:18:29.941] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.941] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.941] Packages: <none>
[10:18:29.941] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.941] Resolved: FALSE
[10:18:29.941] Value: <not collected>
[10:18:29.941] Conditions captured: <none>
[10:18:29.941] Early signaling: FALSE
[10:18:29.941] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.941] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.953] Chunk #1 of 2 ... DONE
[10:18:29.953] Chunk #2 of 2 ...
[10:18:29.953]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:29.953]  - seeds: <none>
[10:18:29.953]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.953] getGlobalsAndPackages() ...
[10:18:29.953] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.954] Resolving globals: FALSE
[10:18:29.954] Tweak future expression to call with '...' arguments ...
[10:18:29.954] {
[10:18:29.954]     do.call(function(...) {
[10:18:29.954]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.954]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.954]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.954]             on.exit(options(oopts), add = TRUE)
[10:18:29.954]         }
[10:18:29.954]         {
[10:18:29.954]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.954]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.954]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.954]             })
[10:18:29.954]         }
[10:18:29.954]     }, args = future.call.arguments)
[10:18:29.954] }
[10:18:29.954] Tweak future expression to call with '...' arguments ... DONE
[10:18:29.954] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:29.955] 
[10:18:29.955] getGlobalsAndPackages() ... DONE
[10:18:29.955] run() for ‘Future’ ...
[10:18:29.955] - state: ‘created’
[10:18:29.955] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:29.969] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.969] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:29.970]   - Field: ‘node’
[10:18:29.970]   - Field: ‘label’
[10:18:29.970]   - Field: ‘local’
[10:18:29.970]   - Field: ‘owner’
[10:18:29.970]   - Field: ‘envir’
[10:18:29.970]   - Field: ‘workers’
[10:18:29.970]   - Field: ‘packages’
[10:18:29.970]   - Field: ‘gc’
[10:18:29.970]   - Field: ‘conditions’
[10:18:29.970]   - Field: ‘persistent’
[10:18:29.970]   - Field: ‘expr’
[10:18:29.971]   - Field: ‘uuid’
[10:18:29.971]   - Field: ‘seed’
[10:18:29.971]   - Field: ‘version’
[10:18:29.971]   - Field: ‘result’
[10:18:29.971]   - Field: ‘asynchronous’
[10:18:29.971]   - Field: ‘calls’
[10:18:29.971]   - Field: ‘globals’
[10:18:29.971]   - Field: ‘stdout’
[10:18:29.971]   - Field: ‘earlySignal’
[10:18:29.971]   - Field: ‘lazy’
[10:18:29.971]   - Field: ‘state’
[10:18:29.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:29.972] - Launch lazy future ...
[10:18:29.972] Packages needed by the future expression (n = 0): <none>
[10:18:29.972] Packages needed by future strategies (n = 0): <none>
[10:18:29.972] {
[10:18:29.972]     {
[10:18:29.972]         {
[10:18:29.972]             ...future.startTime <- base::Sys.time()
[10:18:29.972]             {
[10:18:29.972]                 {
[10:18:29.972]                   {
[10:18:29.972]                     {
[10:18:29.972]                       base::local({
[10:18:29.972]                         has_future <- base::requireNamespace("future", 
[10:18:29.972]                           quietly = TRUE)
[10:18:29.972]                         if (has_future) {
[10:18:29.972]                           ns <- base::getNamespace("future")
[10:18:29.972]                           version <- ns[[".package"]][["version"]]
[10:18:29.972]                           if (is.null(version)) 
[10:18:29.972]                             version <- utils::packageVersion("future")
[10:18:29.972]                         }
[10:18:29.972]                         else {
[10:18:29.972]                           version <- NULL
[10:18:29.972]                         }
[10:18:29.972]                         if (!has_future || version < "1.8.0") {
[10:18:29.972]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:29.972]                             "", base::R.version$version.string), 
[10:18:29.972]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:29.972]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:29.972]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:29.972]                               "release", "version")], collapse = " "), 
[10:18:29.972]                             hostname = base::Sys.info()[["nodename"]])
[10:18:29.972]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:29.972]                             info)
[10:18:29.972]                           info <- base::paste(info, collapse = "; ")
[10:18:29.972]                           if (!has_future) {
[10:18:29.972]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:29.972]                               info)
[10:18:29.972]                           }
[10:18:29.972]                           else {
[10:18:29.972]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:29.972]                               info, version)
[10:18:29.972]                           }
[10:18:29.972]                           base::stop(msg)
[10:18:29.972]                         }
[10:18:29.972]                       })
[10:18:29.972]                     }
[10:18:29.972]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:29.972]                     base::options(mc.cores = 1L)
[10:18:29.972]                   }
[10:18:29.972]                   ...future.strategy.old <- future::plan("list")
[10:18:29.972]                   options(future.plan = NULL)
[10:18:29.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:29.972]                 }
[10:18:29.972]                 ...future.workdir <- getwd()
[10:18:29.972]             }
[10:18:29.972]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:29.972]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:29.972]         }
[10:18:29.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:29.972]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:29.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:29.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:29.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:29.972]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:29.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:29.972]             base::names(...future.oldOptions))
[10:18:29.972]     }
[10:18:29.972]     if (FALSE) {
[10:18:29.972]     }
[10:18:29.972]     else {
[10:18:29.972]         if (TRUE) {
[10:18:29.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:29.972]                 open = "w")
[10:18:29.972]         }
[10:18:29.972]         else {
[10:18:29.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:29.972]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:29.972]         }
[10:18:29.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:29.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:29.972]             base::sink(type = "output", split = FALSE)
[10:18:29.972]             base::close(...future.stdout)
[10:18:29.972]         }, add = TRUE)
[10:18:29.972]     }
[10:18:29.972]     ...future.frame <- base::sys.nframe()
[10:18:29.972]     ...future.conditions <- base::list()
[10:18:29.972]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:29.972]     if (FALSE) {
[10:18:29.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:29.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:29.972]     }
[10:18:29.972]     ...future.result <- base::tryCatch({
[10:18:29.972]         base::withCallingHandlers({
[10:18:29.972]             ...future.value <- base::withVisible(base::local({
[10:18:29.972]                 ...future.makeSendCondition <- base::local({
[10:18:29.972]                   sendCondition <- NULL
[10:18:29.972]                   function(frame = 1L) {
[10:18:29.972]                     if (is.function(sendCondition)) 
[10:18:29.972]                       return(sendCondition)
[10:18:29.972]                     ns <- getNamespace("parallel")
[10:18:29.972]                     if (exists("sendData", mode = "function", 
[10:18:29.972]                       envir = ns)) {
[10:18:29.972]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:29.972]                         envir = ns)
[10:18:29.972]                       envir <- sys.frame(frame)
[10:18:29.972]                       master <- NULL
[10:18:29.972]                       while (!identical(envir, .GlobalEnv) && 
[10:18:29.972]                         !identical(envir, emptyenv())) {
[10:18:29.972]                         if (exists("master", mode = "list", envir = envir, 
[10:18:29.972]                           inherits = FALSE)) {
[10:18:29.972]                           master <- get("master", mode = "list", 
[10:18:29.972]                             envir = envir, inherits = FALSE)
[10:18:29.972]                           if (inherits(master, c("SOCKnode", 
[10:18:29.972]                             "SOCK0node"))) {
[10:18:29.972]                             sendCondition <<- function(cond) {
[10:18:29.972]                               data <- list(type = "VALUE", value = cond, 
[10:18:29.972]                                 success = TRUE)
[10:18:29.972]                               parallel_sendData(master, data)
[10:18:29.972]                             }
[10:18:29.972]                             return(sendCondition)
[10:18:29.972]                           }
[10:18:29.972]                         }
[10:18:29.972]                         frame <- frame + 1L
[10:18:29.972]                         envir <- sys.frame(frame)
[10:18:29.972]                       }
[10:18:29.972]                     }
[10:18:29.972]                     sendCondition <<- function(cond) NULL
[10:18:29.972]                   }
[10:18:29.972]                 })
[10:18:29.972]                 withCallingHandlers({
[10:18:29.972]                   {
[10:18:29.972]                     do.call(function(...) {
[10:18:29.972]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.972]                       if (!identical(...future.globals.maxSize.org, 
[10:18:29.972]                         ...future.globals.maxSize)) {
[10:18:29.972]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.972]                         on.exit(options(oopts), add = TRUE)
[10:18:29.972]                       }
[10:18:29.972]                       {
[10:18:29.972]                         lapply(seq_along(...future.elements_ii), 
[10:18:29.972]                           FUN = function(jj) {
[10:18:29.972]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.972]                             ...future.FUN(...future.X_jj, ...)
[10:18:29.972]                           })
[10:18:29.972]                       }
[10:18:29.972]                     }, args = future.call.arguments)
[10:18:29.972]                   }
[10:18:29.972]                 }, immediateCondition = function(cond) {
[10:18:29.972]                   sendCondition <- ...future.makeSendCondition()
[10:18:29.972]                   sendCondition(cond)
[10:18:29.972]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.972]                   {
[10:18:29.972]                     inherits <- base::inherits
[10:18:29.972]                     invokeRestart <- base::invokeRestart
[10:18:29.972]                     is.null <- base::is.null
[10:18:29.972]                     muffled <- FALSE
[10:18:29.972]                     if (inherits(cond, "message")) {
[10:18:29.972]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:29.972]                       if (muffled) 
[10:18:29.972]                         invokeRestart("muffleMessage")
[10:18:29.972]                     }
[10:18:29.972]                     else if (inherits(cond, "warning")) {
[10:18:29.972]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:29.972]                       if (muffled) 
[10:18:29.972]                         invokeRestart("muffleWarning")
[10:18:29.972]                     }
[10:18:29.972]                     else if (inherits(cond, "condition")) {
[10:18:29.972]                       if (!is.null(pattern)) {
[10:18:29.972]                         computeRestarts <- base::computeRestarts
[10:18:29.972]                         grepl <- base::grepl
[10:18:29.972]                         restarts <- computeRestarts(cond)
[10:18:29.972]                         for (restart in restarts) {
[10:18:29.972]                           name <- restart$name
[10:18:29.972]                           if (is.null(name)) 
[10:18:29.972]                             next
[10:18:29.972]                           if (!grepl(pattern, name)) 
[10:18:29.972]                             next
[10:18:29.972]                           invokeRestart(restart)
[10:18:29.972]                           muffled <- TRUE
[10:18:29.972]                           break
[10:18:29.972]                         }
[10:18:29.972]                       }
[10:18:29.972]                     }
[10:18:29.972]                     invisible(muffled)
[10:18:29.972]                   }
[10:18:29.972]                   muffleCondition(cond)
[10:18:29.972]                 })
[10:18:29.972]             }))
[10:18:29.972]             future::FutureResult(value = ...future.value$value, 
[10:18:29.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.972]                   ...future.rng), globalenv = if (FALSE) 
[10:18:29.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:29.972]                     ...future.globalenv.names))
[10:18:29.972]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:29.972]         }, condition = base::local({
[10:18:29.972]             c <- base::c
[10:18:29.972]             inherits <- base::inherits
[10:18:29.972]             invokeRestart <- base::invokeRestart
[10:18:29.972]             length <- base::length
[10:18:29.972]             list <- base::list
[10:18:29.972]             seq.int <- base::seq.int
[10:18:29.972]             signalCondition <- base::signalCondition
[10:18:29.972]             sys.calls <- base::sys.calls
[10:18:29.972]             `[[` <- base::`[[`
[10:18:29.972]             `+` <- base::`+`
[10:18:29.972]             `<<-` <- base::`<<-`
[10:18:29.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:29.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:29.972]                   3L)]
[10:18:29.972]             }
[10:18:29.972]             function(cond) {
[10:18:29.972]                 is_error <- inherits(cond, "error")
[10:18:29.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:29.972]                   NULL)
[10:18:29.972]                 if (is_error) {
[10:18:29.972]                   sessionInformation <- function() {
[10:18:29.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:29.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:29.972]                       search = base::search(), system = base::Sys.info())
[10:18:29.972]                   }
[10:18:29.972]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:29.972]                     cond$call), session = sessionInformation(), 
[10:18:29.972]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:29.972]                   signalCondition(cond)
[10:18:29.972]                 }
[10:18:29.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:18:29.972]                 "immediateCondition"))) {
[10:18:29.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:29.972]                   ...future.conditions[[length(...future.conditions) + 
[10:18:29.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:29.972]                   if (TRUE && !signal) {
[10:18:29.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.972]                     {
[10:18:29.972]                       inherits <- base::inherits
[10:18:29.972]                       invokeRestart <- base::invokeRestart
[10:18:29.972]                       is.null <- base::is.null
[10:18:29.972]                       muffled <- FALSE
[10:18:29.972]                       if (inherits(cond, "message")) {
[10:18:29.972]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.972]                         if (muffled) 
[10:18:29.972]                           invokeRestart("muffleMessage")
[10:18:29.972]                       }
[10:18:29.972]                       else if (inherits(cond, "warning")) {
[10:18:29.972]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.972]                         if (muffled) 
[10:18:29.972]                           invokeRestart("muffleWarning")
[10:18:29.972]                       }
[10:18:29.972]                       else if (inherits(cond, "condition")) {
[10:18:29.972]                         if (!is.null(pattern)) {
[10:18:29.972]                           computeRestarts <- base::computeRestarts
[10:18:29.972]                           grepl <- base::grepl
[10:18:29.972]                           restarts <- computeRestarts(cond)
[10:18:29.972]                           for (restart in restarts) {
[10:18:29.972]                             name <- restart$name
[10:18:29.972]                             if (is.null(name)) 
[10:18:29.972]                               next
[10:18:29.972]                             if (!grepl(pattern, name)) 
[10:18:29.972]                               next
[10:18:29.972]                             invokeRestart(restart)
[10:18:29.972]                             muffled <- TRUE
[10:18:29.972]                             break
[10:18:29.972]                           }
[10:18:29.972]                         }
[10:18:29.972]                       }
[10:18:29.972]                       invisible(muffled)
[10:18:29.972]                     }
[10:18:29.972]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.972]                   }
[10:18:29.972]                 }
[10:18:29.972]                 else {
[10:18:29.972]                   if (TRUE) {
[10:18:29.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:29.972]                     {
[10:18:29.972]                       inherits <- base::inherits
[10:18:29.972]                       invokeRestart <- base::invokeRestart
[10:18:29.972]                       is.null <- base::is.null
[10:18:29.972]                       muffled <- FALSE
[10:18:29.972]                       if (inherits(cond, "message")) {
[10:18:29.972]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:29.972]                         if (muffled) 
[10:18:29.972]                           invokeRestart("muffleMessage")
[10:18:29.972]                       }
[10:18:29.972]                       else if (inherits(cond, "warning")) {
[10:18:29.972]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:29.972]                         if (muffled) 
[10:18:29.972]                           invokeRestart("muffleWarning")
[10:18:29.972]                       }
[10:18:29.972]                       else if (inherits(cond, "condition")) {
[10:18:29.972]                         if (!is.null(pattern)) {
[10:18:29.972]                           computeRestarts <- base::computeRestarts
[10:18:29.972]                           grepl <- base::grepl
[10:18:29.972]                           restarts <- computeRestarts(cond)
[10:18:29.972]                           for (restart in restarts) {
[10:18:29.972]                             name <- restart$name
[10:18:29.972]                             if (is.null(name)) 
[10:18:29.972]                               next
[10:18:29.972]                             if (!grepl(pattern, name)) 
[10:18:29.972]                               next
[10:18:29.972]                             invokeRestart(restart)
[10:18:29.972]                             muffled <- TRUE
[10:18:29.972]                             break
[10:18:29.972]                           }
[10:18:29.972]                         }
[10:18:29.972]                       }
[10:18:29.972]                       invisible(muffled)
[10:18:29.972]                     }
[10:18:29.972]                     muffleCondition(cond, pattern = "^muffle")
[10:18:29.972]                   }
[10:18:29.972]                 }
[10:18:29.972]             }
[10:18:29.972]         }))
[10:18:29.972]     }, error = function(ex) {
[10:18:29.972]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:29.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:29.972]                 ...future.rng), started = ...future.startTime, 
[10:18:29.972]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:29.972]             version = "1.8"), class = "FutureResult")
[10:18:29.972]     }, finally = {
[10:18:29.972]         if (!identical(...future.workdir, getwd())) 
[10:18:29.972]             setwd(...future.workdir)
[10:18:29.972]         {
[10:18:29.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:29.972]                 ...future.oldOptions$nwarnings <- NULL
[10:18:29.972]             }
[10:18:29.972]             base::options(...future.oldOptions)
[10:18:29.972]             if (.Platform$OS.type == "windows") {
[10:18:29.972]                 old_names <- names(...future.oldEnvVars)
[10:18:29.972]                 envs <- base::Sys.getenv()
[10:18:29.972]                 names <- names(envs)
[10:18:29.972]                 common <- intersect(names, old_names)
[10:18:29.972]                 added <- setdiff(names, old_names)
[10:18:29.972]                 removed <- setdiff(old_names, names)
[10:18:29.972]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:29.972]                   envs[common]]
[10:18:29.972]                 NAMES <- toupper(changed)
[10:18:29.972]                 args <- list()
[10:18:29.972]                 for (kk in seq_along(NAMES)) {
[10:18:29.972]                   name <- changed[[kk]]
[10:18:29.972]                   NAME <- NAMES[[kk]]
[10:18:29.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.972]                     next
[10:18:29.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.972]                 }
[10:18:29.972]                 NAMES <- toupper(added)
[10:18:29.972]                 for (kk in seq_along(NAMES)) {
[10:18:29.972]                   name <- added[[kk]]
[10:18:29.972]                   NAME <- NAMES[[kk]]
[10:18:29.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.972]                     next
[10:18:29.972]                   args[[name]] <- ""
[10:18:29.972]                 }
[10:18:29.972]                 NAMES <- toupper(removed)
[10:18:29.972]                 for (kk in seq_along(NAMES)) {
[10:18:29.972]                   name <- removed[[kk]]
[10:18:29.972]                   NAME <- NAMES[[kk]]
[10:18:29.972]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:29.972]                     next
[10:18:29.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:29.972]                 }
[10:18:29.972]                 if (length(args) > 0) 
[10:18:29.972]                   base::do.call(base::Sys.setenv, args = args)
[10:18:29.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:29.972]             }
[10:18:29.972]             else {
[10:18:29.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:29.972]             }
[10:18:29.972]             {
[10:18:29.972]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:29.972]                   0L) {
[10:18:29.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:29.972]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:29.972]                   base::options(opts)
[10:18:29.972]                 }
[10:18:29.972]                 {
[10:18:29.972]                   {
[10:18:29.972]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:29.972]                     NULL
[10:18:29.972]                   }
[10:18:29.972]                   options(future.plan = NULL)
[10:18:29.972]                   if (is.na(NA_character_)) 
[10:18:29.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:29.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:29.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:29.972]                     .init = FALSE)
[10:18:29.972]                 }
[10:18:29.972]             }
[10:18:29.972]         }
[10:18:29.972]     })
[10:18:29.972]     if (TRUE) {
[10:18:29.972]         base::sink(type = "output", split = FALSE)
[10:18:29.972]         if (TRUE) {
[10:18:29.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:29.972]         }
[10:18:29.972]         else {
[10:18:29.972]             ...future.result["stdout"] <- base::list(NULL)
[10:18:29.972]         }
[10:18:29.972]         base::close(...future.stdout)
[10:18:29.972]         ...future.stdout <- NULL
[10:18:29.972]     }
[10:18:29.972]     ...future.result$conditions <- ...future.conditions
[10:18:29.972]     ...future.result$finished <- base::Sys.time()
[10:18:29.972]     ...future.result
[10:18:29.972] }
[10:18:29.975] Exporting 5 global objects (1.92 KiB) to cluster node #2 ...
[10:18:29.975] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:29.976] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:29.976] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ...
[10:18:29.976] Exporting ‘...future.FUN’ (1.28 KiB) to cluster node #2 ... DONE
[10:18:29.976] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ...
[10:18:29.977] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ... DONE
[10:18:29.977] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ...
[10:18:29.977] Exporting ‘...future.seeds_ii’ (27 bytes) to cluster node #2 ... DONE
[10:18:29.977] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:29.978] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:29.978] Exporting 5 global objects (1.92 KiB) to cluster node #2 ... DONE
[10:18:29.978] MultisessionFuture started
[10:18:29.978] - Launch lazy future ... done
[10:18:29.978] run() for ‘MultisessionFuture’ ... done
[10:18:29.979] Created future:
[10:18:29.979] MultisessionFuture:
[10:18:29.979] Label: ‘future_apply-2’
[10:18:29.979] Expression:
[10:18:29.979] {
[10:18:29.979]     do.call(function(...) {
[10:18:29.979]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:29.979]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:29.979]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:29.979]             on.exit(options(oopts), add = TRUE)
[10:18:29.979]         }
[10:18:29.979]         {
[10:18:29.979]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:29.979]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:29.979]                 ...future.FUN(...future.X_jj, ...)
[10:18:29.979]             })
[10:18:29.979]         }
[10:18:29.979]     }, args = future.call.arguments)
[10:18:29.979] }
[10:18:29.979] Lazy evaluation: FALSE
[10:18:29.979] Asynchronous evaluation: TRUE
[10:18:29.979] Local evaluation: TRUE
[10:18:29.979] Environment: R_GlobalEnv
[10:18:29.979] Capture standard output: TRUE
[10:18:29.979] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:18:29.979] Globals: 5 objects totaling 1.49 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 1.28 KiB, list ‘...future.elements_ii’ of 47 bytes, NULL ‘...future.seeds_ii’ of 27 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:29.979] Packages: <none>
[10:18:29.979] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:18:29.979] Resolved: FALSE
[10:18:29.979] Value: <not collected>
[10:18:29.979] Conditions captured: <none>
[10:18:29.979] Early signaling: FALSE
[10:18:29.979] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:29.979] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:29.990] Chunk #2 of 2 ... DONE
[10:18:29.990] Launching 2 futures (chunks) ... DONE
[10:18:29.990] Resolving 2 futures (chunks) ...
[10:18:29.991] resolve() on list ...
[10:18:29.991]  recursive: 0
[10:18:29.991]  length: 2
[10:18:29.991] 
[10:18:29.991] receiveMessageFromWorker() for ClusterFuture ...
[10:18:29.991] - Validating connection of MultisessionFuture
[10:18:29.992] - received message: FutureResult
[10:18:29.992] - Received FutureResult
[10:18:29.992] - Erased future from FutureRegistry
[10:18:29.992] result() for ClusterFuture ...
[10:18:29.992] - result already collected: FutureResult
[10:18:29.992] result() for ClusterFuture ... done
[10:18:29.992] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:29.992] Future #1
[10:18:29.992] result() for ClusterFuture ...
[10:18:29.992] - result already collected: FutureResult
[10:18:29.993] result() for ClusterFuture ... done
[10:18:29.993] result() for ClusterFuture ...
[10:18:29.993] - result already collected: FutureResult
[10:18:29.993] result() for ClusterFuture ... done
[10:18:29.993] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:29.993] - nx: 2
[10:18:29.993] - relay: TRUE
[10:18:29.993] - stdout: TRUE
[10:18:29.993] - signal: TRUE
[10:18:29.993] - resignal: FALSE
[10:18:29.993] - force: TRUE
[10:18:29.993] - relayed: [n=2] FALSE, FALSE
[10:18:29.994] - queued futures: [n=2] FALSE, FALSE
[10:18:29.994]  - until=1
[10:18:29.994]  - relaying element #1
[10:18:29.994] result() for ClusterFuture ...
[10:18:29.994] - result already collected: FutureResult
[10:18:29.994] result() for ClusterFuture ... done
[10:18:29.994] result() for ClusterFuture ...
[10:18:29.994] - result already collected: FutureResult
[10:18:29.994] result() for ClusterFuture ... done
[10:18:29.994] result() for ClusterFuture ...
[10:18:29.994] - result already collected: FutureResult
[10:18:29.995] result() for ClusterFuture ... done
[10:18:29.995] result() for ClusterFuture ...
[10:18:29.995] - result already collected: FutureResult
[10:18:29.995] result() for ClusterFuture ... done
[10:18:29.995] - relayed: [n=2] TRUE, FALSE
[10:18:29.995] - queued futures: [n=2] TRUE, FALSE
[10:18:29.995] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:29.995]  length: 1 (resolved future 1)
[10:18:30.020] receiveMessageFromWorker() for ClusterFuture ...
[10:18:30.020] - Validating connection of MultisessionFuture
[10:18:30.020] - received message: FutureResult
[10:18:30.020] - Received FutureResult
[10:18:30.021] - Erased future from FutureRegistry
[10:18:30.021] result() for ClusterFuture ...
[10:18:30.021] - result already collected: FutureResult
[10:18:30.021] result() for ClusterFuture ... done
[10:18:30.021] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:30.021] Future #2
[10:18:30.021] result() for ClusterFuture ...
[10:18:30.021] - result already collected: FutureResult
[10:18:30.021] result() for ClusterFuture ... done
[10:18:30.021] result() for ClusterFuture ...
[10:18:30.021] - result already collected: FutureResult
[10:18:30.022] result() for ClusterFuture ... done
[10:18:30.022] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:30.022] - nx: 2
[10:18:30.022] - relay: TRUE
[10:18:30.022] - stdout: TRUE
[10:18:30.022] - signal: TRUE
[10:18:30.022] - resignal: FALSE
[10:18:30.022] - force: TRUE
[10:18:30.022] - relayed: [n=2] TRUE, FALSE
[10:18:30.022] - queued futures: [n=2] TRUE, FALSE
[10:18:30.022]  - until=2
[10:18:30.022]  - relaying element #2
[10:18:30.023] result() for ClusterFuture ...
[10:18:30.023] - result already collected: FutureResult
[10:18:30.023] result() for ClusterFuture ... done
[10:18:30.023] result() for ClusterFuture ...
[10:18:30.023] - result already collected: FutureResult
[10:18:30.023] result() for ClusterFuture ... done
[10:18:30.023] result() for ClusterFuture ...
[10:18:30.023] - result already collected: FutureResult
[10:18:30.023] result() for ClusterFuture ... done
[10:18:30.023] result() for ClusterFuture ...
[10:18:30.023] - result already collected: FutureResult
[10:18:30.023] result() for ClusterFuture ... done
[10:18:30.024] - relayed: [n=2] TRUE, TRUE
[10:18:30.024] - queued futures: [n=2] TRUE, TRUE
[10:18:30.024] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:30.024]  length: 0 (resolved future 2)
[10:18:30.024] Relaying remaining futures
[10:18:30.024] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.024] - nx: 2
[10:18:30.024] - relay: TRUE
[10:18:30.024] - stdout: TRUE
[10:18:30.024] - signal: TRUE
[10:18:30.024] - resignal: FALSE
[10:18:30.024] - force: TRUE
[10:18:30.025] - relayed: [n=2] TRUE, TRUE
[10:18:30.025] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:30.025] - relayed: [n=2] TRUE, TRUE
[10:18:30.025] - queued futures: [n=2] TRUE, TRUE
[10:18:30.025] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.025] resolve() on list ... DONE
[10:18:30.025] result() for ClusterFuture ...
[10:18:30.025] - result already collected: FutureResult
[10:18:30.025] result() for ClusterFuture ... done
[10:18:30.025] result() for ClusterFuture ...
[10:18:30.025] - result already collected: FutureResult
[10:18:30.025] result() for ClusterFuture ... done
[10:18:30.026] result() for ClusterFuture ...
[10:18:30.026] - result already collected: FutureResult
[10:18:30.026] result() for ClusterFuture ... done
[10:18:30.026] result() for ClusterFuture ...
[10:18:30.026] - result already collected: FutureResult
[10:18:30.026] result() for ClusterFuture ... done
[10:18:30.026]  - Number of value chunks collected: 2
[10:18:30.026] Resolving 2 futures (chunks) ... DONE
[10:18:30.026] Reducing values from 2 chunks ...
[10:18:30.026]  - Number of values collected after concatenation: 2
[10:18:30.026]  - Number of values expected: 2
[10:18:30.027] Reducing values from 2 chunks ... DONE
[10:18:30.027] future_lapply() ... DONE
     [,1] [,2]
[1,]    1    2
[2,]    3    4
- example(future_apply) - reproducible RNG ...
[10:18:30.027] getGlobalsAndPackagesXApply() ...
[10:18:30.027]  - future.globals: TRUE
[10:18:30.027] getGlobalsAndPackages() ...
[10:18:30.027] Searching for globals...
[10:18:30.030] - globals found: [13] ‘FUN’, ‘{’, ‘if’, ‘&&’, ‘==’, ‘length’, ‘is.numeric’, ‘is.finite’, ‘>=’, ‘missing’, ‘<-’, ‘sample.int’, ‘[’
[10:18:30.030] Searching for globals ... DONE
[10:18:30.030] Resolving globals: FALSE
[10:18:30.031] The total size of the 1 globals is 3.66 KiB (3746 bytes)
[10:18:30.031] The total size of the 1 globals exported for future expression (‘FUN(X = structure(1:4, dim = c(2L, 2L)))’) is 3.66 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (3.66 KiB of class ‘function’)
[10:18:30.031] - globals: [1] ‘FUN’
[10:18:30.032] 
[10:18:30.032] getGlobalsAndPackages() ... DONE
[10:18:30.032]  - globals found/used: [n=1] ‘FUN’
[10:18:30.032]  - needed namespaces: [n=0] 
[10:18:30.032] Finding globals ... DONE
[10:18:30.032]  - use_args: TRUE
[10:18:30.032]  - Getting '...' globals ...
[10:18:30.032] resolve() on list ...
[10:18:30.033]  recursive: 0
[10:18:30.033]  length: 1
[10:18:30.033]  elements: ‘...’
[10:18:30.033]  length: 0 (resolved future 1)
[10:18:30.033] resolve() on list ... DONE
[10:18:30.033]    - '...' content: [n=0] 
[10:18:30.033] List of 1
[10:18:30.033]  $ ...: list()
[10:18:30.033]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.033]  - attr(*, "where")=List of 1
[10:18:30.033]   ..$ ...:<environment: 0x556e04ea2800> 
[10:18:30.033]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.033]  - attr(*, "resolved")= logi TRUE
[10:18:30.033]  - attr(*, "total_size")= num NA
[10:18:30.036]  - Getting '...' globals ... DONE
[10:18:30.036] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:18:30.036] List of 2
[10:18:30.036]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:18:30.036]  $ ...          : list()
[10:18:30.036]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.036]  - attr(*, "where")=List of 2
[10:18:30.036]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:18:30.036]   ..$ ...          :<environment: 0x556e04ea2800> 
[10:18:30.036]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.036]  - attr(*, "resolved")= logi FALSE
[10:18:30.036]  - attr(*, "total_size")= num 9424
[10:18:30.038] Packages to be attached in all futures: [n=0] 
[10:18:30.038] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.040] future_lapply() ...
[10:18:30.042] Generating random seeds ...
[10:18:30.042] Generating random seed streams for 2 elements ...
[10:18:30.042] Generating random seed streams for 2 elements ... DONE
[10:18:30.042] Generating random seeds ... DONE
[10:18:30.042] Will set RNG state on exit: 10407, -1826006590, 1669707458, -1711085490, -1881364239, 386520512, 933615213
[10:18:30.044] Number of chunks: 2
[10:18:30.044] getGlobalsAndPackagesXApply() ...
[10:18:30.044]  - future.globals: <name-value list> with names ‘list()’
[10:18:30.044]  - use_args: TRUE
[10:18:30.045] Globals to be used in all futures (chunks): [n=2] ‘...’, ‘...future.FUN’
[10:18:30.045] List of 2
[10:18:30.045]  $ ...          : list()
[10:18:30.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:18:30.045]  $ ...future.FUN:function (x, size, replace = FALSE, prob = NULL)  
[10:18:30.045]  - attr(*, "where")=List of 2
[10:18:30.045]   ..$ ...          :<environment: 0x556e04ea2800> 
[10:18:30.045]   ..$ ...future.FUN:<environment: namespace:base> 
[10:18:30.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:18:30.045]  - attr(*, "resolved")= logi FALSE
[10:18:30.045]  - attr(*, "total_size")= num NA
[10:18:30.048] Packages to be attached in all futures: [n=0] 
[10:18:30.048] getGlobalsAndPackagesXApply() ... DONE
[10:18:30.048] Number of futures (= number of chunks): 2
[10:18:30.049] Launching 2 futures (chunks) ...
[10:18:30.049] Chunk #1 of 2 ...
[10:18:30.049]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:30.049]  - seeds: [1] <seeds>
[10:18:30.049]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.049] getGlobalsAndPackages() ...
[10:18:30.049] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.049] Resolving globals: FALSE
[10:18:30.049] Tweak future expression to call with '...' arguments ...
[10:18:30.050] {
[10:18:30.050]     do.call(function(...) {
[10:18:30.050]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.050]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.050]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.050]             on.exit(options(oopts), add = TRUE)
[10:18:30.050]         }
[10:18:30.050]         {
[10:18:30.050]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.050]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.050]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:30.050]                   envir = globalenv(), inherits = FALSE)
[10:18:30.050]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.050]             })
[10:18:30.050]         }
[10:18:30.050]     }, args = future.call.arguments)
[10:18:30.050] }
[10:18:30.050] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.050] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.050] 
[10:18:30.050] getGlobalsAndPackages() ... DONE
[10:18:30.051] run() for ‘Future’ ...
[10:18:30.051] - state: ‘created’
[10:18:30.051] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:30.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:30.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:30.066]   - Field: ‘node’
[10:18:30.066]   - Field: ‘label’
[10:18:30.066]   - Field: ‘local’
[10:18:30.066]   - Field: ‘owner’
[10:18:30.066]   - Field: ‘envir’
[10:18:30.066]   - Field: ‘workers’
[10:18:30.066]   - Field: ‘packages’
[10:18:30.066]   - Field: ‘gc’
[10:18:30.066]   - Field: ‘conditions’
[10:18:30.066]   - Field: ‘persistent’
[10:18:30.066]   - Field: ‘expr’
[10:18:30.067]   - Field: ‘uuid’
[10:18:30.067]   - Field: ‘seed’
[10:18:30.067]   - Field: ‘version’
[10:18:30.067]   - Field: ‘result’
[10:18:30.067]   - Field: ‘asynchronous’
[10:18:30.067]   - Field: ‘calls’
[10:18:30.067]   - Field: ‘globals’
[10:18:30.067]   - Field: ‘stdout’
[10:18:30.067]   - Field: ‘earlySignal’
[10:18:30.067]   - Field: ‘lazy’
[10:18:30.067]   - Field: ‘state’
[10:18:30.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:30.068] - Launch lazy future ...
[10:18:30.068] Packages needed by the future expression (n = 0): <none>
[10:18:30.068] Packages needed by future strategies (n = 0): <none>
[10:18:30.069] {
[10:18:30.069]     {
[10:18:30.069]         {
[10:18:30.069]             ...future.startTime <- base::Sys.time()
[10:18:30.069]             {
[10:18:30.069]                 {
[10:18:30.069]                   {
[10:18:30.069]                     {
[10:18:30.069]                       base::local({
[10:18:30.069]                         has_future <- base::requireNamespace("future", 
[10:18:30.069]                           quietly = TRUE)
[10:18:30.069]                         if (has_future) {
[10:18:30.069]                           ns <- base::getNamespace("future")
[10:18:30.069]                           version <- ns[[".package"]][["version"]]
[10:18:30.069]                           if (is.null(version)) 
[10:18:30.069]                             version <- utils::packageVersion("future")
[10:18:30.069]                         }
[10:18:30.069]                         else {
[10:18:30.069]                           version <- NULL
[10:18:30.069]                         }
[10:18:30.069]                         if (!has_future || version < "1.8.0") {
[10:18:30.069]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.069]                             "", base::R.version$version.string), 
[10:18:30.069]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:30.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.069]                               "release", "version")], collapse = " "), 
[10:18:30.069]                             hostname = base::Sys.info()[["nodename"]])
[10:18:30.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.069]                             info)
[10:18:30.069]                           info <- base::paste(info, collapse = "; ")
[10:18:30.069]                           if (!has_future) {
[10:18:30.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.069]                               info)
[10:18:30.069]                           }
[10:18:30.069]                           else {
[10:18:30.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.069]                               info, version)
[10:18:30.069]                           }
[10:18:30.069]                           base::stop(msg)
[10:18:30.069]                         }
[10:18:30.069]                       })
[10:18:30.069]                     }
[10:18:30.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:30.069]                     base::options(mc.cores = 1L)
[10:18:30.069]                   }
[10:18:30.069]                   ...future.strategy.old <- future::plan("list")
[10:18:30.069]                   options(future.plan = NULL)
[10:18:30.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.069]                 }
[10:18:30.069]                 ...future.workdir <- getwd()
[10:18:30.069]             }
[10:18:30.069]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.069]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.069]         }
[10:18:30.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.069]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:30.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.069]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.069]             base::names(...future.oldOptions))
[10:18:30.069]     }
[10:18:30.069]     if (FALSE) {
[10:18:30.069]     }
[10:18:30.069]     else {
[10:18:30.069]         if (TRUE) {
[10:18:30.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.069]                 open = "w")
[10:18:30.069]         }
[10:18:30.069]         else {
[10:18:30.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.069]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.069]         }
[10:18:30.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.069]             base::sink(type = "output", split = FALSE)
[10:18:30.069]             base::close(...future.stdout)
[10:18:30.069]         }, add = TRUE)
[10:18:30.069]     }
[10:18:30.069]     ...future.frame <- base::sys.nframe()
[10:18:30.069]     ...future.conditions <- base::list()
[10:18:30.069]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.069]     if (FALSE) {
[10:18:30.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.069]     }
[10:18:30.069]     ...future.result <- base::tryCatch({
[10:18:30.069]         base::withCallingHandlers({
[10:18:30.069]             ...future.value <- base::withVisible(base::local({
[10:18:30.069]                 ...future.makeSendCondition <- base::local({
[10:18:30.069]                   sendCondition <- NULL
[10:18:30.069]                   function(frame = 1L) {
[10:18:30.069]                     if (is.function(sendCondition)) 
[10:18:30.069]                       return(sendCondition)
[10:18:30.069]                     ns <- getNamespace("parallel")
[10:18:30.069]                     if (exists("sendData", mode = "function", 
[10:18:30.069]                       envir = ns)) {
[10:18:30.069]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:30.069]                         envir = ns)
[10:18:30.069]                       envir <- sys.frame(frame)
[10:18:30.069]                       master <- NULL
[10:18:30.069]                       while (!identical(envir, .GlobalEnv) && 
[10:18:30.069]                         !identical(envir, emptyenv())) {
[10:18:30.069]                         if (exists("master", mode = "list", envir = envir, 
[10:18:30.069]                           inherits = FALSE)) {
[10:18:30.069]                           master <- get("master", mode = "list", 
[10:18:30.069]                             envir = envir, inherits = FALSE)
[10:18:30.069]                           if (inherits(master, c("SOCKnode", 
[10:18:30.069]                             "SOCK0node"))) {
[10:18:30.069]                             sendCondition <<- function(cond) {
[10:18:30.069]                               data <- list(type = "VALUE", value = cond, 
[10:18:30.069]                                 success = TRUE)
[10:18:30.069]                               parallel_sendData(master, data)
[10:18:30.069]                             }
[10:18:30.069]                             return(sendCondition)
[10:18:30.069]                           }
[10:18:30.069]                         }
[10:18:30.069]                         frame <- frame + 1L
[10:18:30.069]                         envir <- sys.frame(frame)
[10:18:30.069]                       }
[10:18:30.069]                     }
[10:18:30.069]                     sendCondition <<- function(cond) NULL
[10:18:30.069]                   }
[10:18:30.069]                 })
[10:18:30.069]                 withCallingHandlers({
[10:18:30.069]                   {
[10:18:30.069]                     do.call(function(...) {
[10:18:30.069]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.069]                       if (!identical(...future.globals.maxSize.org, 
[10:18:30.069]                         ...future.globals.maxSize)) {
[10:18:30.069]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.069]                         on.exit(options(oopts), add = TRUE)
[10:18:30.069]                       }
[10:18:30.069]                       {
[10:18:30.069]                         lapply(seq_along(...future.elements_ii), 
[10:18:30.069]                           FUN = function(jj) {
[10:18:30.069]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.069]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:30.069]                               envir = globalenv(), inherits = FALSE)
[10:18:30.069]                             ...future.FUN(...future.X_jj, ...)
[10:18:30.069]                           })
[10:18:30.069]                       }
[10:18:30.069]                     }, args = future.call.arguments)
[10:18:30.069]                   }
[10:18:30.069]                 }, immediateCondition = function(cond) {
[10:18:30.069]                   sendCondition <- ...future.makeSendCondition()
[10:18:30.069]                   sendCondition(cond)
[10:18:30.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.069]                   {
[10:18:30.069]                     inherits <- base::inherits
[10:18:30.069]                     invokeRestart <- base::invokeRestart
[10:18:30.069]                     is.null <- base::is.null
[10:18:30.069]                     muffled <- FALSE
[10:18:30.069]                     if (inherits(cond, "message")) {
[10:18:30.069]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:30.069]                       if (muffled) 
[10:18:30.069]                         invokeRestart("muffleMessage")
[10:18:30.069]                     }
[10:18:30.069]                     else if (inherits(cond, "warning")) {
[10:18:30.069]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:30.069]                       if (muffled) 
[10:18:30.069]                         invokeRestart("muffleWarning")
[10:18:30.069]                     }
[10:18:30.069]                     else if (inherits(cond, "condition")) {
[10:18:30.069]                       if (!is.null(pattern)) {
[10:18:30.069]                         computeRestarts <- base::computeRestarts
[10:18:30.069]                         grepl <- base::grepl
[10:18:30.069]                         restarts <- computeRestarts(cond)
[10:18:30.069]                         for (restart in restarts) {
[10:18:30.069]                           name <- restart$name
[10:18:30.069]                           if (is.null(name)) 
[10:18:30.069]                             next
[10:18:30.069]                           if (!grepl(pattern, name)) 
[10:18:30.069]                             next
[10:18:30.069]                           invokeRestart(restart)
[10:18:30.069]                           muffled <- TRUE
[10:18:30.069]                           break
[10:18:30.069]                         }
[10:18:30.069]                       }
[10:18:30.069]                     }
[10:18:30.069]                     invisible(muffled)
[10:18:30.069]                   }
[10:18:30.069]                   muffleCondition(cond)
[10:18:30.069]                 })
[10:18:30.069]             }))
[10:18:30.069]             future::FutureResult(value = ...future.value$value, 
[10:18:30.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.069]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.069]                     ...future.globalenv.names))
[10:18:30.069]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.069]         }, condition = base::local({
[10:18:30.069]             c <- base::c
[10:18:30.069]             inherits <- base::inherits
[10:18:30.069]             invokeRestart <- base::invokeRestart
[10:18:30.069]             length <- base::length
[10:18:30.069]             list <- base::list
[10:18:30.069]             seq.int <- base::seq.int
[10:18:30.069]             signalCondition <- base::signalCondition
[10:18:30.069]             sys.calls <- base::sys.calls
[10:18:30.069]             `[[` <- base::`[[`
[10:18:30.069]             `+` <- base::`+`
[10:18:30.069]             `<<-` <- base::`<<-`
[10:18:30.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.069]                   3L)]
[10:18:30.069]             }
[10:18:30.069]             function(cond) {
[10:18:30.069]                 is_error <- inherits(cond, "error")
[10:18:30.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.069]                   NULL)
[10:18:30.069]                 if (is_error) {
[10:18:30.069]                   sessionInformation <- function() {
[10:18:30.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.069]                       search = base::search(), system = base::Sys.info())
[10:18:30.069]                   }
[10:18:30.069]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.069]                     cond$call), session = sessionInformation(), 
[10:18:30.069]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.069]                   signalCondition(cond)
[10:18:30.069]                 }
[10:18:30.069]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:18:30.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.069]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.069]                   if (TRUE && !signal) {
[10:18:30.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.069]                     {
[10:18:30.069]                       inherits <- base::inherits
[10:18:30.069]                       invokeRestart <- base::invokeRestart
[10:18:30.069]                       is.null <- base::is.null
[10:18:30.069]                       muffled <- FALSE
[10:18:30.069]                       if (inherits(cond, "message")) {
[10:18:30.069]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.069]                         if (muffled) 
[10:18:30.069]                           invokeRestart("muffleMessage")
[10:18:30.069]                       }
[10:18:30.069]                       else if (inherits(cond, "warning")) {
[10:18:30.069]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.069]                         if (muffled) 
[10:18:30.069]                           invokeRestart("muffleWarning")
[10:18:30.069]                       }
[10:18:30.069]                       else if (inherits(cond, "condition")) {
[10:18:30.069]                         if (!is.null(pattern)) {
[10:18:30.069]                           computeRestarts <- base::computeRestarts
[10:18:30.069]                           grepl <- base::grepl
[10:18:30.069]                           restarts <- computeRestarts(cond)
[10:18:30.069]                           for (restart in restarts) {
[10:18:30.069]                             name <- restart$name
[10:18:30.069]                             if (is.null(name)) 
[10:18:30.069]                               next
[10:18:30.069]                             if (!grepl(pattern, name)) 
[10:18:30.069]                               next
[10:18:30.069]                             invokeRestart(restart)
[10:18:30.069]                             muffled <- TRUE
[10:18:30.069]                             break
[10:18:30.069]                           }
[10:18:30.069]                         }
[10:18:30.069]                       }
[10:18:30.069]                       invisible(muffled)
[10:18:30.069]                     }
[10:18:30.069]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.069]                   }
[10:18:30.069]                 }
[10:18:30.069]                 else {
[10:18:30.069]                   if (TRUE) {
[10:18:30.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.069]                     {
[10:18:30.069]                       inherits <- base::inherits
[10:18:30.069]                       invokeRestart <- base::invokeRestart
[10:18:30.069]                       is.null <- base::is.null
[10:18:30.069]                       muffled <- FALSE
[10:18:30.069]                       if (inherits(cond, "message")) {
[10:18:30.069]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.069]                         if (muffled) 
[10:18:30.069]                           invokeRestart("muffleMessage")
[10:18:30.069]                       }
[10:18:30.069]                       else if (inherits(cond, "warning")) {
[10:18:30.069]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.069]                         if (muffled) 
[10:18:30.069]                           invokeRestart("muffleWarning")
[10:18:30.069]                       }
[10:18:30.069]                       else if (inherits(cond, "condition")) {
[10:18:30.069]                         if (!is.null(pattern)) {
[10:18:30.069]                           computeRestarts <- base::computeRestarts
[10:18:30.069]                           grepl <- base::grepl
[10:18:30.069]                           restarts <- computeRestarts(cond)
[10:18:30.069]                           for (restart in restarts) {
[10:18:30.069]                             name <- restart$name
[10:18:30.069]                             if (is.null(name)) 
[10:18:30.069]                               next
[10:18:30.069]                             if (!grepl(pattern, name)) 
[10:18:30.069]                               next
[10:18:30.069]                             invokeRestart(restart)
[10:18:30.069]                             muffled <- TRUE
[10:18:30.069]                             break
[10:18:30.069]                           }
[10:18:30.069]                         }
[10:18:30.069]                       }
[10:18:30.069]                       invisible(muffled)
[10:18:30.069]                     }
[10:18:30.069]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.069]                   }
[10:18:30.069]                 }
[10:18:30.069]             }
[10:18:30.069]         }))
[10:18:30.069]     }, error = function(ex) {
[10:18:30.069]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.069]                 ...future.rng), started = ...future.startTime, 
[10:18:30.069]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.069]             version = "1.8"), class = "FutureResult")
[10:18:30.069]     }, finally = {
[10:18:30.069]         if (!identical(...future.workdir, getwd())) 
[10:18:30.069]             setwd(...future.workdir)
[10:18:30.069]         {
[10:18:30.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.069]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.069]             }
[10:18:30.069]             base::options(...future.oldOptions)
[10:18:30.069]             if (.Platform$OS.type == "windows") {
[10:18:30.069]                 old_names <- names(...future.oldEnvVars)
[10:18:30.069]                 envs <- base::Sys.getenv()
[10:18:30.069]                 names <- names(envs)
[10:18:30.069]                 common <- intersect(names, old_names)
[10:18:30.069]                 added <- setdiff(names, old_names)
[10:18:30.069]                 removed <- setdiff(old_names, names)
[10:18:30.069]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.069]                   envs[common]]
[10:18:30.069]                 NAMES <- toupper(changed)
[10:18:30.069]                 args <- list()
[10:18:30.069]                 for (kk in seq_along(NAMES)) {
[10:18:30.069]                   name <- changed[[kk]]
[10:18:30.069]                   NAME <- NAMES[[kk]]
[10:18:30.069]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.069]                     next
[10:18:30.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.069]                 }
[10:18:30.069]                 NAMES <- toupper(added)
[10:18:30.069]                 for (kk in seq_along(NAMES)) {
[10:18:30.069]                   name <- added[[kk]]
[10:18:30.069]                   NAME <- NAMES[[kk]]
[10:18:30.069]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.069]                     next
[10:18:30.069]                   args[[name]] <- ""
[10:18:30.069]                 }
[10:18:30.069]                 NAMES <- toupper(removed)
[10:18:30.069]                 for (kk in seq_along(NAMES)) {
[10:18:30.069]                   name <- removed[[kk]]
[10:18:30.069]                   NAME <- NAMES[[kk]]
[10:18:30.069]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.069]                     next
[10:18:30.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.069]                 }
[10:18:30.069]                 if (length(args) > 0) 
[10:18:30.069]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.069]             }
[10:18:30.069]             else {
[10:18:30.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.069]             }
[10:18:30.069]             {
[10:18:30.069]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.069]                   0L) {
[10:18:30.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.069]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.069]                   base::options(opts)
[10:18:30.069]                 }
[10:18:30.069]                 {
[10:18:30.069]                   {
[10:18:30.069]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:30.069]                     NULL
[10:18:30.069]                   }
[10:18:30.069]                   options(future.plan = NULL)
[10:18:30.069]                   if (is.na(NA_character_)) 
[10:18:30.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.069]                     .init = FALSE)
[10:18:30.069]                 }
[10:18:30.069]             }
[10:18:30.069]         }
[10:18:30.069]     })
[10:18:30.069]     if (TRUE) {
[10:18:30.069]         base::sink(type = "output", split = FALSE)
[10:18:30.069]         if (TRUE) {
[10:18:30.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.069]         }
[10:18:30.069]         else {
[10:18:30.069]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.069]         }
[10:18:30.069]         base::close(...future.stdout)
[10:18:30.069]         ...future.stdout <- NULL
[10:18:30.069]     }
[10:18:30.069]     ...future.result$conditions <- ...future.conditions
[10:18:30.069]     ...future.result$finished <- base::Sys.time()
[10:18:30.069]     ...future.result
[10:18:30.069] }
[10:18:30.072] Exporting 5 global objects (4.35 KiB) to cluster node #1 ...
[10:18:30.072] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ...
[10:18:30.072] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #1 ... DONE
[10:18:30.072] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #1 ...
[10:18:30.114] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #1 ... DONE
[10:18:30.114] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ...
[10:18:30.114] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #1 ... DONE
[10:18:30.115] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ...
[10:18:30.115] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #1 ... DONE
[10:18:30.115] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ...
[10:18:30.116] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #1 ... DONE
[10:18:30.116] Exporting 5 global objects (4.35 KiB) to cluster node #1 ... DONE
[10:18:30.116] MultisessionFuture started
[10:18:30.116] - Launch lazy future ... done
[10:18:30.116] run() for ‘MultisessionFuture’ ... done
[10:18:30.117] Created future:
[10:18:30.117] MultisessionFuture:
[10:18:30.117] Label: ‘future_apply-1’
[10:18:30.117] Expression:
[10:18:30.117] {
[10:18:30.117]     do.call(function(...) {
[10:18:30.117]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.117]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.117]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.117]             on.exit(options(oopts), add = TRUE)
[10:18:30.117]         }
[10:18:30.117]         {
[10:18:30.117]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.117]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.117]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:30.117]                   envir = globalenv(), inherits = FALSE)
[10:18:30.117]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.117]             })
[10:18:30.117]         }
[10:18:30.117]     }, args = future.call.arguments)
[10:18:30.117] }
[10:18:30.117] Lazy evaluation: FALSE
[10:18:30.117] Asynchronous evaluation: TRUE
[10:18:30.117] Local evaluation: TRUE
[10:18:30.117] Environment: R_GlobalEnv
[10:18:30.117] Capture standard output: TRUE
[10:18:30.117] Capture condition classes: <none>
[10:18:30.117] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:30.117] Packages: <none>
[10:18:30.117] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:18:30.117] Resolved: FALSE
[10:18:30.117] Value: <not collected>
[10:18:30.117] Conditions captured: <none>
[10:18:30.117] Early signaling: FALSE
[10:18:30.117] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:30.117] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:30.128] Chunk #1 of 2 ... DONE
[10:18:30.128] Chunk #2 of 2 ...
[10:18:30.129]  - Adjusted option 'future.globals.maxSize': Inf -> 2 * Inf = Inf (bytes)
[10:18:30.129]  - seeds: [1] <seeds>
[10:18:30.129]  - All globals exported: [n=5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.129] getGlobalsAndPackages() ...
[10:18:30.129] - globals passed as-is: [5] ‘...’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.129] Resolving globals: FALSE
[10:18:30.129] Tweak future expression to call with '...' arguments ...
[10:18:30.129] {
[10:18:30.129]     do.call(function(...) {
[10:18:30.129]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.129]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.129]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.129]             on.exit(options(oopts), add = TRUE)
[10:18:30.129]         }
[10:18:30.129]         {
[10:18:30.129]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.129]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.129]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:30.129]                   envir = globalenv(), inherits = FALSE)
[10:18:30.129]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.129]             })
[10:18:30.129]         }
[10:18:30.129]     }, args = future.call.arguments)
[10:18:30.129] }
[10:18:30.130] Tweak future expression to call with '...' arguments ... DONE
[10:18:30.130] - globals: [5] ‘future.call.arguments’, ‘...future.FUN’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:18:30.130] 
[10:18:30.130] getGlobalsAndPackages() ... DONE
[10:18:30.131] run() for ‘Future’ ...
[10:18:30.131] - state: ‘created’
[10:18:30.131] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:18:30.148] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:30.148] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:18:30.149]   - Field: ‘node’
[10:18:30.149]   - Field: ‘label’
[10:18:30.149]   - Field: ‘local’
[10:18:30.149]   - Field: ‘owner’
[10:18:30.149]   - Field: ‘envir’
[10:18:30.149]   - Field: ‘workers’
[10:18:30.149]   - Field: ‘packages’
[10:18:30.149]   - Field: ‘gc’
[10:18:30.149]   - Field: ‘conditions’
[10:18:30.149]   - Field: ‘persistent’
[10:18:30.149]   - Field: ‘expr’
[10:18:30.150]   - Field: ‘uuid’
[10:18:30.150]   - Field: ‘seed’
[10:18:30.150]   - Field: ‘version’
[10:18:30.150]   - Field: ‘result’
[10:18:30.150]   - Field: ‘asynchronous’
[10:18:30.150]   - Field: ‘calls’
[10:18:30.150]   - Field: ‘globals’
[10:18:30.150]   - Field: ‘stdout’
[10:18:30.150]   - Field: ‘earlySignal’
[10:18:30.150]   - Field: ‘lazy’
[10:18:30.150]   - Field: ‘state’
[10:18:30.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:18:30.151] - Launch lazy future ...
[10:18:30.151] Packages needed by the future expression (n = 0): <none>
[10:18:30.151] Packages needed by future strategies (n = 0): <none>
[10:18:30.151] {
[10:18:30.151]     {
[10:18:30.151]         {
[10:18:30.151]             ...future.startTime <- base::Sys.time()
[10:18:30.151]             {
[10:18:30.151]                 {
[10:18:30.151]                   {
[10:18:30.151]                     {
[10:18:30.151]                       base::local({
[10:18:30.151]                         has_future <- base::requireNamespace("future", 
[10:18:30.151]                           quietly = TRUE)
[10:18:30.151]                         if (has_future) {
[10:18:30.151]                           ns <- base::getNamespace("future")
[10:18:30.151]                           version <- ns[[".package"]][["version"]]
[10:18:30.151]                           if (is.null(version)) 
[10:18:30.151]                             version <- utils::packageVersion("future")
[10:18:30.151]                         }
[10:18:30.151]                         else {
[10:18:30.151]                           version <- NULL
[10:18:30.151]                         }
[10:18:30.151]                         if (!has_future || version < "1.8.0") {
[10:18:30.151]                           info <- base::c(r_version = base::gsub("R version ", 
[10:18:30.151]                             "", base::R.version$version.string), 
[10:18:30.151]                             platform = base::sprintf("%s (%s-bit)", 
[10:18:30.151]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:18:30.151]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:18:30.151]                               "release", "version")], collapse = " "), 
[10:18:30.151]                             hostname = base::Sys.info()[["nodename"]])
[10:18:30.151]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:18:30.151]                             info)
[10:18:30.151]                           info <- base::paste(info, collapse = "; ")
[10:18:30.151]                           if (!has_future) {
[10:18:30.151]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:18:30.151]                               info)
[10:18:30.151]                           }
[10:18:30.151]                           else {
[10:18:30.151]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:18:30.151]                               info, version)
[10:18:30.151]                           }
[10:18:30.151]                           base::stop(msg)
[10:18:30.151]                         }
[10:18:30.151]                       })
[10:18:30.151]                     }
[10:18:30.151]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:18:30.151]                     base::options(mc.cores = 1L)
[10:18:30.151]                   }
[10:18:30.151]                   ...future.strategy.old <- future::plan("list")
[10:18:30.151]                   options(future.plan = NULL)
[10:18:30.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:18:30.151]                 }
[10:18:30.151]                 ...future.workdir <- getwd()
[10:18:30.151]             }
[10:18:30.151]             ...future.oldOptions <- base::as.list(base::.Options)
[10:18:30.151]             ...future.oldEnvVars <- base::Sys.getenv()
[10:18:30.151]         }
[10:18:30.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:18:30.151]             future.globals.maxSize = Inf, future.globals.method = NULL, 
[10:18:30.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:18:30.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:18:30.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:18:30.151]             future.stdout.windows.reencode = NULL, width = 80L)
[10:18:30.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:18:30.151]             base::names(...future.oldOptions))
[10:18:30.151]     }
[10:18:30.151]     if (FALSE) {
[10:18:30.151]     }
[10:18:30.151]     else {
[10:18:30.151]         if (TRUE) {
[10:18:30.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:18:30.151]                 open = "w")
[10:18:30.151]         }
[10:18:30.151]         else {
[10:18:30.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:18:30.151]                 windows = "NUL", "/dev/null"), open = "w")
[10:18:30.151]         }
[10:18:30.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:18:30.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:18:30.151]             base::sink(type = "output", split = FALSE)
[10:18:30.151]             base::close(...future.stdout)
[10:18:30.151]         }, add = TRUE)
[10:18:30.151]     }
[10:18:30.151]     ...future.frame <- base::sys.nframe()
[10:18:30.151]     ...future.conditions <- base::list()
[10:18:30.151]     ...future.rng <- base::globalenv()$.Random.seed
[10:18:30.151]     if (FALSE) {
[10:18:30.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:18:30.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:18:30.151]     }
[10:18:30.151]     ...future.result <- base::tryCatch({
[10:18:30.151]         base::withCallingHandlers({
[10:18:30.151]             ...future.value <- base::withVisible(base::local({
[10:18:30.151]                 ...future.makeSendCondition <- base::local({
[10:18:30.151]                   sendCondition <- NULL
[10:18:30.151]                   function(frame = 1L) {
[10:18:30.151]                     if (is.function(sendCondition)) 
[10:18:30.151]                       return(sendCondition)
[10:18:30.151]                     ns <- getNamespace("parallel")
[10:18:30.151]                     if (exists("sendData", mode = "function", 
[10:18:30.151]                       envir = ns)) {
[10:18:30.151]                       parallel_sendData <- get("sendData", mode = "function", 
[10:18:30.151]                         envir = ns)
[10:18:30.151]                       envir <- sys.frame(frame)
[10:18:30.151]                       master <- NULL
[10:18:30.151]                       while (!identical(envir, .GlobalEnv) && 
[10:18:30.151]                         !identical(envir, emptyenv())) {
[10:18:30.151]                         if (exists("master", mode = "list", envir = envir, 
[10:18:30.151]                           inherits = FALSE)) {
[10:18:30.151]                           master <- get("master", mode = "list", 
[10:18:30.151]                             envir = envir, inherits = FALSE)
[10:18:30.151]                           if (inherits(master, c("SOCKnode", 
[10:18:30.151]                             "SOCK0node"))) {
[10:18:30.151]                             sendCondition <<- function(cond) {
[10:18:30.151]                               data <- list(type = "VALUE", value = cond, 
[10:18:30.151]                                 success = TRUE)
[10:18:30.151]                               parallel_sendData(master, data)
[10:18:30.151]                             }
[10:18:30.151]                             return(sendCondition)
[10:18:30.151]                           }
[10:18:30.151]                         }
[10:18:30.151]                         frame <- frame + 1L
[10:18:30.151]                         envir <- sys.frame(frame)
[10:18:30.151]                       }
[10:18:30.151]                     }
[10:18:30.151]                     sendCondition <<- function(cond) NULL
[10:18:30.151]                   }
[10:18:30.151]                 })
[10:18:30.151]                 withCallingHandlers({
[10:18:30.151]                   {
[10:18:30.151]                     do.call(function(...) {
[10:18:30.151]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.151]                       if (!identical(...future.globals.maxSize.org, 
[10:18:30.151]                         ...future.globals.maxSize)) {
[10:18:30.151]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.151]                         on.exit(options(oopts), add = TRUE)
[10:18:30.151]                       }
[10:18:30.151]                       {
[10:18:30.151]                         lapply(seq_along(...future.elements_ii), 
[10:18:30.151]                           FUN = function(jj) {
[10:18:30.151]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.151]                             assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:30.151]                               envir = globalenv(), inherits = FALSE)
[10:18:30.151]                             ...future.FUN(...future.X_jj, ...)
[10:18:30.151]                           })
[10:18:30.151]                       }
[10:18:30.151]                     }, args = future.call.arguments)
[10:18:30.151]                   }
[10:18:30.151]                 }, immediateCondition = function(cond) {
[10:18:30.151]                   sendCondition <- ...future.makeSendCondition()
[10:18:30.151]                   sendCondition(cond)
[10:18:30.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.151]                   {
[10:18:30.151]                     inherits <- base::inherits
[10:18:30.151]                     invokeRestart <- base::invokeRestart
[10:18:30.151]                     is.null <- base::is.null
[10:18:30.151]                     muffled <- FALSE
[10:18:30.151]                     if (inherits(cond, "message")) {
[10:18:30.151]                       muffled <- grepl(pattern, "muffleMessage")
[10:18:30.151]                       if (muffled) 
[10:18:30.151]                         invokeRestart("muffleMessage")
[10:18:30.151]                     }
[10:18:30.151]                     else if (inherits(cond, "warning")) {
[10:18:30.151]                       muffled <- grepl(pattern, "muffleWarning")
[10:18:30.151]                       if (muffled) 
[10:18:30.151]                         invokeRestart("muffleWarning")
[10:18:30.151]                     }
[10:18:30.151]                     else if (inherits(cond, "condition")) {
[10:18:30.151]                       if (!is.null(pattern)) {
[10:18:30.151]                         computeRestarts <- base::computeRestarts
[10:18:30.151]                         grepl <- base::grepl
[10:18:30.151]                         restarts <- computeRestarts(cond)
[10:18:30.151]                         for (restart in restarts) {
[10:18:30.151]                           name <- restart$name
[10:18:30.151]                           if (is.null(name)) 
[10:18:30.151]                             next
[10:18:30.151]                           if (!grepl(pattern, name)) 
[10:18:30.151]                             next
[10:18:30.151]                           invokeRestart(restart)
[10:18:30.151]                           muffled <- TRUE
[10:18:30.151]                           break
[10:18:30.151]                         }
[10:18:30.151]                       }
[10:18:30.151]                     }
[10:18:30.151]                     invisible(muffled)
[10:18:30.151]                   }
[10:18:30.151]                   muffleCondition(cond)
[10:18:30.151]                 })
[10:18:30.151]             }))
[10:18:30.151]             future::FutureResult(value = ...future.value$value, 
[10:18:30.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.151]                   ...future.rng), globalenv = if (FALSE) 
[10:18:30.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:18:30.151]                     ...future.globalenv.names))
[10:18:30.151]                 else NULL, started = ...future.startTime, version = "1.8")
[10:18:30.151]         }, condition = base::local({
[10:18:30.151]             c <- base::c
[10:18:30.151]             inherits <- base::inherits
[10:18:30.151]             invokeRestart <- base::invokeRestart
[10:18:30.151]             length <- base::length
[10:18:30.151]             list <- base::list
[10:18:30.151]             seq.int <- base::seq.int
[10:18:30.151]             signalCondition <- base::signalCondition
[10:18:30.151]             sys.calls <- base::sys.calls
[10:18:30.151]             `[[` <- base::`[[`
[10:18:30.151]             `+` <- base::`+`
[10:18:30.151]             `<<-` <- base::`<<-`
[10:18:30.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:18:30.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:18:30.151]                   3L)]
[10:18:30.151]             }
[10:18:30.151]             function(cond) {
[10:18:30.151]                 is_error <- inherits(cond, "error")
[10:18:30.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:18:30.151]                   NULL)
[10:18:30.151]                 if (is_error) {
[10:18:30.151]                   sessionInformation <- function() {
[10:18:30.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:18:30.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:18:30.151]                       search = base::search(), system = base::Sys.info())
[10:18:30.151]                   }
[10:18:30.151]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:18:30.151]                     cond$call), session = sessionInformation(), 
[10:18:30.151]                     timestamp = base::Sys.time(), signaled = 0L)
[10:18:30.151]                   signalCondition(cond)
[10:18:30.151]                 }
[10:18:30.151]                 else if (!ignore && TRUE && inherits(cond, "immediateCondition")) {
[10:18:30.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:18:30.151]                   ...future.conditions[[length(...future.conditions) + 
[10:18:30.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:18:30.151]                   if (TRUE && !signal) {
[10:18:30.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.151]                     {
[10:18:30.151]                       inherits <- base::inherits
[10:18:30.151]                       invokeRestart <- base::invokeRestart
[10:18:30.151]                       is.null <- base::is.null
[10:18:30.151]                       muffled <- FALSE
[10:18:30.151]                       if (inherits(cond, "message")) {
[10:18:30.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.151]                         if (muffled) 
[10:18:30.151]                           invokeRestart("muffleMessage")
[10:18:30.151]                       }
[10:18:30.151]                       else if (inherits(cond, "warning")) {
[10:18:30.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.151]                         if (muffled) 
[10:18:30.151]                           invokeRestart("muffleWarning")
[10:18:30.151]                       }
[10:18:30.151]                       else if (inherits(cond, "condition")) {
[10:18:30.151]                         if (!is.null(pattern)) {
[10:18:30.151]                           computeRestarts <- base::computeRestarts
[10:18:30.151]                           grepl <- base::grepl
[10:18:30.151]                           restarts <- computeRestarts(cond)
[10:18:30.151]                           for (restart in restarts) {
[10:18:30.151]                             name <- restart$name
[10:18:30.151]                             if (is.null(name)) 
[10:18:30.151]                               next
[10:18:30.151]                             if (!grepl(pattern, name)) 
[10:18:30.151]                               next
[10:18:30.151]                             invokeRestart(restart)
[10:18:30.151]                             muffled <- TRUE
[10:18:30.151]                             break
[10:18:30.151]                           }
[10:18:30.151]                         }
[10:18:30.151]                       }
[10:18:30.151]                       invisible(muffled)
[10:18:30.151]                     }
[10:18:30.151]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.151]                   }
[10:18:30.151]                 }
[10:18:30.151]                 else {
[10:18:30.151]                   if (TRUE) {
[10:18:30.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:18:30.151]                     {
[10:18:30.151]                       inherits <- base::inherits
[10:18:30.151]                       invokeRestart <- base::invokeRestart
[10:18:30.151]                       is.null <- base::is.null
[10:18:30.151]                       muffled <- FALSE
[10:18:30.151]                       if (inherits(cond, "message")) {
[10:18:30.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:18:30.151]                         if (muffled) 
[10:18:30.151]                           invokeRestart("muffleMessage")
[10:18:30.151]                       }
[10:18:30.151]                       else if (inherits(cond, "warning")) {
[10:18:30.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:18:30.151]                         if (muffled) 
[10:18:30.151]                           invokeRestart("muffleWarning")
[10:18:30.151]                       }
[10:18:30.151]                       else if (inherits(cond, "condition")) {
[10:18:30.151]                         if (!is.null(pattern)) {
[10:18:30.151]                           computeRestarts <- base::computeRestarts
[10:18:30.151]                           grepl <- base::grepl
[10:18:30.151]                           restarts <- computeRestarts(cond)
[10:18:30.151]                           for (restart in restarts) {
[10:18:30.151]                             name <- restart$name
[10:18:30.151]                             if (is.null(name)) 
[10:18:30.151]                               next
[10:18:30.151]                             if (!grepl(pattern, name)) 
[10:18:30.151]                               next
[10:18:30.151]                             invokeRestart(restart)
[10:18:30.151]                             muffled <- TRUE
[10:18:30.151]                             break
[10:18:30.151]                           }
[10:18:30.151]                         }
[10:18:30.151]                       }
[10:18:30.151]                       invisible(muffled)
[10:18:30.151]                     }
[10:18:30.151]                     muffleCondition(cond, pattern = "^muffle")
[10:18:30.151]                   }
[10:18:30.151]                 }
[10:18:30.151]             }
[10:18:30.151]         }))
[10:18:30.151]     }, error = function(ex) {
[10:18:30.151]         base::structure(base::list(value = NULL, visible = NULL, 
[10:18:30.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:18:30.151]                 ...future.rng), started = ...future.startTime, 
[10:18:30.151]             finished = Sys.time(), session_uuid = NA_character_, 
[10:18:30.151]             version = "1.8"), class = "FutureResult")
[10:18:30.151]     }, finally = {
[10:18:30.151]         if (!identical(...future.workdir, getwd())) 
[10:18:30.151]             setwd(...future.workdir)
[10:18:30.151]         {
[10:18:30.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:18:30.151]                 ...future.oldOptions$nwarnings <- NULL
[10:18:30.151]             }
[10:18:30.151]             base::options(...future.oldOptions)
[10:18:30.151]             if (.Platform$OS.type == "windows") {
[10:18:30.151]                 old_names <- names(...future.oldEnvVars)
[10:18:30.151]                 envs <- base::Sys.getenv()
[10:18:30.151]                 names <- names(envs)
[10:18:30.151]                 common <- intersect(names, old_names)
[10:18:30.151]                 added <- setdiff(names, old_names)
[10:18:30.151]                 removed <- setdiff(old_names, names)
[10:18:30.151]                 changed <- common[...future.oldEnvVars[common] != 
[10:18:30.151]                   envs[common]]
[10:18:30.151]                 NAMES <- toupper(changed)
[10:18:30.151]                 args <- list()
[10:18:30.151]                 for (kk in seq_along(NAMES)) {
[10:18:30.151]                   name <- changed[[kk]]
[10:18:30.151]                   NAME <- NAMES[[kk]]
[10:18:30.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.151]                     next
[10:18:30.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.151]                 }
[10:18:30.151]                 NAMES <- toupper(added)
[10:18:30.151]                 for (kk in seq_along(NAMES)) {
[10:18:30.151]                   name <- added[[kk]]
[10:18:30.151]                   NAME <- NAMES[[kk]]
[10:18:30.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.151]                     next
[10:18:30.151]                   args[[name]] <- ""
[10:18:30.151]                 }
[10:18:30.151]                 NAMES <- toupper(removed)
[10:18:30.151]                 for (kk in seq_along(NAMES)) {
[10:18:30.151]                   name <- removed[[kk]]
[10:18:30.151]                   NAME <- NAMES[[kk]]
[10:18:30.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:18:30.151]                     next
[10:18:30.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:18:30.151]                 }
[10:18:30.151]                 if (length(args) > 0) 
[10:18:30.151]                   base::do.call(base::Sys.setenv, args = args)
[10:18:30.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:18:30.151]             }
[10:18:30.151]             else {
[10:18:30.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:18:30.151]             }
[10:18:30.151]             {
[10:18:30.151]                 if (base::length(...future.futureOptionsAdded) > 
[10:18:30.151]                   0L) {
[10:18:30.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:18:30.151]                   base::names(opts) <- ...future.futureOptionsAdded
[10:18:30.151]                   base::options(opts)
[10:18:30.151]                 }
[10:18:30.151]                 {
[10:18:30.151]                   {
[10:18:30.151]                     base::options(mc.cores = ...future.mc.cores.old)
[10:18:30.151]                     NULL
[10:18:30.151]                   }
[10:18:30.151]                   options(future.plan = NULL)
[10:18:30.151]                   if (is.na(NA_character_)) 
[10:18:30.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:18:30.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:18:30.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:18:30.151]                     .init = FALSE)
[10:18:30.151]                 }
[10:18:30.151]             }
[10:18:30.151]         }
[10:18:30.151]     })
[10:18:30.151]     if (TRUE) {
[10:18:30.151]         base::sink(type = "output", split = FALSE)
[10:18:30.151]         if (TRUE) {
[10:18:30.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:18:30.151]         }
[10:18:30.151]         else {
[10:18:30.151]             ...future.result["stdout"] <- base::list(NULL)
[10:18:30.151]         }
[10:18:30.151]         base::close(...future.stdout)
[10:18:30.151]         ...future.stdout <- NULL
[10:18:30.151]     }
[10:18:30.151]     ...future.result$conditions <- ...future.conditions
[10:18:30.151]     ...future.result$finished <- base::Sys.time()
[10:18:30.151]     ...future.result
[10:18:30.151] }
[10:18:30.154] Exporting 5 global objects (4.35 KiB) to cluster node #2 ...
[10:18:30.155] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ...
[10:18:30.155] Exporting ‘future.call.arguments’ (97 bytes) to cluster node #2 ... DONE
[10:18:30.155] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #2 ...
[10:18:30.196] Exporting ‘...future.FUN’ (3.66 KiB) to cluster node #2 ... DONE
[10:18:30.197] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ...
[10:18:30.197] Exporting ‘...future.elements_ii’ (47 bytes) to cluster node #2 ... DONE
[10:18:30.197] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ...
[10:18:30.197] Exporting ‘...future.seeds_ii’ (67 bytes) to cluster node #2 ... DONE
[10:18:30.198] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ...
[10:18:30.198] Exporting ‘...future.globals.maxSize’ (39 bytes) to cluster node #2 ... DONE
[10:18:30.198] Exporting 5 global objects (4.35 KiB) to cluster node #2 ... DONE
[10:18:30.199] MultisessionFuture started
[10:18:30.199] - Launch lazy future ... done
[10:18:30.199] run() for ‘MultisessionFuture’ ... done
[10:18:30.199] Created future:
[10:18:30.199] MultisessionFuture:
[10:18:30.199] Label: ‘future_apply-2’
[10:18:30.199] Expression:
[10:18:30.199] {
[10:18:30.199]     do.call(function(...) {
[10:18:30.199]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:18:30.199]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:18:30.199]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:18:30.199]             on.exit(options(oopts), add = TRUE)
[10:18:30.199]         }
[10:18:30.199]         {
[10:18:30.199]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:18:30.199]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:18:30.199]                 assign(".Random.seed", ...future.seeds_ii[[jj]], 
[10:18:30.199]                   envir = globalenv(), inherits = FALSE)
[10:18:30.199]                 ...future.FUN(...future.X_jj, ...)
[10:18:30.199]             })
[10:18:30.199]         }
[10:18:30.199]     }, args = future.call.arguments)
[10:18:30.199] }
[10:18:30.199] Lazy evaluation: FALSE
[10:18:30.199] Asynchronous evaluation: TRUE
[10:18:30.199] Local evaluation: TRUE
[10:18:30.199] Environment: R_GlobalEnv
[10:18:30.199] Capture standard output: TRUE
[10:18:30.199] Capture condition classes: <none>
[10:18:30.199] Globals: 5 objects totaling 3.90 KiB (DotDotDotList ‘future.call.arguments’ of 97 bytes, function ‘...future.FUN’ of 3.66 KiB, list ‘...future.elements_ii’ of 47 bytes, list ‘...future.seeds_ii’ of 67 bytes, numeric ‘...future.globals.maxSize’ of 39 bytes)
[10:18:30.199] Packages: <none>
[10:18:30.199] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[10:18:30.199] Resolved: FALSE
[10:18:30.199] Value: <not collected>
[10:18:30.199] Conditions captured: <none>
[10:18:30.199] Early signaling: FALSE
[10:18:30.199] Owner process: 0ecb0c1c-04d9-8826-8c15-d9705fa8a866
[10:18:30.199] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:18:30.211] Chunk #2 of 2 ... DONE
[10:18:30.211] Launching 2 futures (chunks) ... DONE
[10:18:30.211] Resolving 2 futures (chunks) ...
[10:18:30.211] resolve() on list ...
[10:18:30.211]  recursive: 0
[10:18:30.211]  length: 2
[10:18:30.211] 
[10:18:30.212] receiveMessageFromWorker() for ClusterFuture ...
[10:18:30.212] - Validating connection of MultisessionFuture
[10:18:30.212] - received message: FutureResult
[10:18:30.212] - Received FutureResult
[10:18:30.212] - Erased future from FutureRegistry
[10:18:30.212] result() for ClusterFuture ...
[10:18:30.212] - result already collected: FutureResult
[10:18:30.212] result() for ClusterFuture ... done
[10:18:30.212] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:30.213] Future #1
[10:18:30.213] result() for ClusterFuture ...
[10:18:30.213] - result already collected: FutureResult
[10:18:30.213] result() for ClusterFuture ... done
[10:18:30.213] result() for ClusterFuture ...
[10:18:30.213] - result already collected: FutureResult
[10:18:30.213] result() for ClusterFuture ... done
[10:18:30.213] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:18:30.213] - nx: 2
[10:18:30.213] - relay: TRUE
[10:18:30.213] - stdout: TRUE
[10:18:30.214] - signal: TRUE
[10:18:30.214] - resignal: FALSE
[10:18:30.214] - force: TRUE
[10:18:30.214] - relayed: [n=2] FALSE, FALSE
[10:18:30.214] - queued futures: [n=2] FALSE, FALSE
[10:18:30.214]  - until=1
[10:18:30.214]  - relaying element #1
[10:18:30.214] result() for ClusterFuture ...
[10:18:30.214] - result already collected: FutureResult
[10:18:30.214] result() for ClusterFuture ... done
[10:18:30.214] result() for ClusterFuture ...
[10:18:30.214] - result already collected: FutureResult
[10:18:30.215] result() for ClusterFuture ... done
[10:18:30.215] result() for ClusterFuture ...
[10:18:30.215] - result already collected: FutureResult
[10:18:30.215] result() for ClusterFuture ... done
[10:18:30.215] result() for ClusterFuture ...
[10:18:30.215] - result already collected: FutureResult
[10:18:30.215] result() for ClusterFuture ... done
[10:18:30.215] - relayed: [n=2] TRUE, FALSE
[10:18:30.215] - queued futures: [n=2] TRUE, FALSE
[10:18:30.215] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:18:30.215]  length: 1 (resolved future 1)
[10:18:30.241] receiveMessageFromWorker() for ClusterFuture ...
[10:18:30.241] - Validating connection of MultisessionFuture
[10:18:30.241] - received message: FutureResult
[10:18:30.242] - Received FutureResult
[10:18:30.242] - Erased future from FutureRegistry
[10:18:30.242] result() for ClusterFuture ...
[10:18:30.242] - result already collected: FutureResult
[10:18:30.242] result() for ClusterFuture ... done
[10:18:30.242] receiveMessageFromWorker() for ClusterFuture ... done
[10:18:30.242] Future #2
[10:18:30.242] result() for ClusterFuture ...
[10:18:30.242] - result already collected: FutureResult
[10:18:30.242] result() for ClusterFuture ... done
[10:18:30.243] result() for ClusterFuture ...
[10:18:30.243] - result already collected: FutureResult
[10:18:30.243] result() for ClusterFuture ... done
[10:18:30.243] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:18:30.243] - nx: 2
[10:18:30.243] - relay: TRUE
[10:18:30.243] - stdout: TRUE
[10:18:30.243] - signal: TRUE
[10:18:30.243] - resignal: FALSE
[10:18:30.243] - force: TRUE
[10:18:30.243] - relayed: [n=2] TRUE, FALSE
[10:18:30.243] - queued futures: [n=2] TRUE, FALSE
[10:18:30.244]  - until=2
[10:18:30.244]  - relaying element #2
[10:18:30.244] result() for ClusterFuture ...
[10:18:30.244] - result already collected: FutureResult
[10:18:30.244] result() for ClusterFuture ... done
[10:18:30.244] result() for ClusterFuture ...
[10:18:30.244] - result already collected: FutureResult
[10:18:30.244] result() for ClusterFuture ... done
[10:18:30.244] result() for ClusterFuture ...
[10:18:30.244] - result already collected: FutureResult
[10:18:30.244] result() for ClusterFuture ... done
[10:18:30.245] result() for ClusterFuture ...
[10:18:30.245] - result already collected: FutureResult
[10:18:30.245] result() for ClusterFuture ... done
[10:18:30.245] - relayed: [n=2] TRUE, TRUE
[10:18:30.245] - queued futures: [n=2] TRUE, TRUE
[10:18:30.245] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:18:30.245]  length: 0 (resolved future 2)
[10:18:30.245] Relaying remaining futures
[10:18:30.245] signalConditionsASAP(NULL, pos=0) ...
[10:18:30.245] - nx: 2
[10:18:30.245] - relay: TRUE
[10:18:30.245] - stdout: TRUE
[10:18:30.245] - signal: TRUE
[10:18:30.246] - resignal: FALSE
[10:18:30.246] - force: TRUE
[10:18:30.246] - relayed: [n=2] TRUE, TRUE
[10:18:30.246] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:18:30.246] - relayed: [n=2] TRUE, TRUE
[10:18:30.246] - queued futures: [n=2] TRUE, TRUE
[10:18:30.246] signalConditionsASAP(NULL, pos=0) ... done
[10:18:30.246] resolve() on list ... DONE
[10:18:30.246] result() for ClusterFuture ...
[10:18:30.246] - result already collected: FutureResult
[10:18:30.246] result() for ClusterFuture ... done
[10:18:30.246] result() for ClusterFuture ...
[10:18:30.247] - result already collected: FutureResult
[10:18:30.247] result() for ClusterFuture ... done
[10:18:30.247] result() for ClusterFuture ...
[10:18:30.247] - result already collected: FutureResult
[10:18:30.247] result() for ClusterFuture ... done
[10:18:30.247] result() for ClusterFuture ...
[10:18:30.247] - result already collected: FutureResult
[10:18:30.247] result() for ClusterFuture ... done
[10:18:30.247]  - Number of value chunks collected: 2
[10:18:30.247] Resolving 2 futures (chunks) ... DONE
[10:18:30.247] Reducing values from 2 chunks ...
[10:18:30.248]  - Number of values collected after concatenation: 2
[10:18:30.248]  - Number of values expected: 2
[10:18:30.248] Reducing values from 2 chunks ... DONE
[10:18:30.248] future_lapply() ... DONE
     [,1] [,2]
[1,]    3    2
[2,]    1    4
[10:18:30.248] plan(): Setting new future strategy stack:
[10:18:30.248] List of future strategies:
[10:18:30.248] 1. sequential:
[10:18:30.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.248]    - tweaked: FALSE
[10:18:30.248]    - call: plan(sequential)
[10:18:30.249] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...")
*** apply(X, ...) - prod(dim(X)) == 0 [non-parallel] ...
> X <- matrix(nrow = 0L, ncol = 2L)
> y0 <- apply(X, MARGIN = 1L, FUN = identity)
> y1 <- future_apply(X, MARGIN = 1L, FUN = identity)
> print(y1)
logical(0)
> stopifnot(identical(y1, y0))
>   
> 
> message("*** exceptions ...")
*** exceptions ...
> 
> ## Error: dim(X) must have a positive length
> res <- tryCatch({
+   y <- future_apply(1L, MARGIN = 1L, FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: 'X' must have named dimnames
> X <- matrix(1:2, nrow = 2L, ncol = 1L)
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "rows", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> ## Error: not all elements of 'MARGIN' are names of dimensions
> X <- matrix(1:2, nrow = 2L, ncol = 1L, dimnames = list(rows = c("a", "b")))
> res <- tryCatch({
+   y <- future_apply(X, MARGIN = "cols", FUN = identity)
+ }, error = identity)
> stopifnot(inherits(res, "error"))
> 
> 
> message("*** future_apply() ... DONE")
*** future_apply() ... DONE
> 
> source("incl/end.R")
[10:18:30.251] plan(): Setting new future strategy stack:
[10:18:30.251] List of future strategies:
[10:18:30.251] 1. FutureStrategy:
[10:18:30.251]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:18:30.251]    - tweaked: FALSE
[10:18:30.251]    - call: future::plan(oplan)
[10:18:30.252] plan(): nbrOfWorkers() = 1
> 
