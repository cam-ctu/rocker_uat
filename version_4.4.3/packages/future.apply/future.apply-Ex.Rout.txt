
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "future.apply"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('future.apply')
Loading required package: future
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("future.apply.options")
> ### * future.apply.options
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: future.apply.options
> ### Title: Options used for future.apply
> ### Aliases: future.apply.options future.apply.debug R_FUTURE_APPLY_DEBUG
> 
> ### ** Examples
> 
> ## Not run: 
> ##D options(future.apply.debug = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("future_apply")
> ### * future_apply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: future_apply
> ### Title: Apply Functions Over Array Margins via Futures
> ### Aliases: future_apply
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------
> ## apply()
> ## ---------------------------------------------------------
> X <- matrix(c(1:4, 1, 6:8), nrow = 2L)
> 
> Y0 <- apply(X, MARGIN = 1L, FUN = table)
> Y1 <- future_apply(X, MARGIN = 1L, FUN = table)
> print(Y1)
[[1]]
...future.X_jj
1 3 7 
2 1 1 

[[2]]
...future.X_jj
2 4 6 8 
1 1 1 1 

> stopifnot(all.equal(Y1, Y0, check.attributes = FALSE)) ## FIXME
> 
> Y0 <- apply(X, MARGIN = 1L, FUN = stats::quantile)
> Y1 <- future_apply(X, MARGIN = 1L, FUN = stats::quantile)
> print(Y1)
     [,1] [,2]
0%      1  2.0
25%     1  3.5
50%     2  5.0
75%     4  6.5
100%    7  8.0
> stopifnot(all.equal(Y1, Y0))
> 
> 
> ## ---------------------------------------------------------
> ## Parallel Random Number Generation
> ## ---------------------------------------------------------
> 
> ## Don't show: 
> ## R CMD check: make sure any open connections are closed afterward
> if (!inherits(plan(), "sequential")) plan(sequential)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("future_by")
> ### * future_by
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: future_by
> ### Title: Apply a Function to a Data Frame Split by Factors via Futures
> ### Aliases: future_by
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------
> ## by()
> ## ---------------------------------------------------------
> library(datasets) ## warpbreaks
> library(stats)    ## lm()
> 
> y0 <- by(warpbreaks, warpbreaks[,"tension"],
+          function(x) lm(breaks ~ wool, data = x))
> 
> plan(multisession)
> y1 <- future_by(warpbreaks, warpbreaks[,"tension"],
+                 function(x) lm(breaks ~ wool, data = x))
> 
> plan(sequential)
> y2 <- future_by(warpbreaks, warpbreaks[,"tension"],
+                 function(x) lm(breaks ~ wool, data = x))
> 
> 
> 
> cleanEx()
> nameEx("future_lapply")
> ### * future_lapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: future_eapply
> ### Title: Apply a Function over a List or Vector via Futures
> ### Aliases: future_eapply future_lapply future_replicate future_sapply
> ###   future_tapply future_vapply
> ### Keywords: iteration manip programming
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------
> ## lapply(), sapply(), tapply()
> ## ---------------------------------------------------------
> x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
> y0 <- lapply(x, FUN = quantile, probs = 1:3/4)
> y1 <- future_lapply(x, FUN = quantile, probs = 1:3/4)
> print(y1)
$a
 25%  50%  75% 
3.25 5.50 7.75 

$beta
      25%       50%       75% 
0.2516074 1.0000000 5.0536690 

$logic
25% 50% 75% 
0.0 0.5 1.0 

> stopifnot(all.equal(y1, y0))
> 
> y0 <- sapply(x, FUN = quantile)
> y1 <- future_sapply(x, FUN = quantile)
> print(y1)
         a        beta logic
0%    1.00  0.04978707   0.0
25%   3.25  0.25160736   0.0
50%   5.50  1.00000000   0.5
75%   7.75  5.05366896   1.0
100% 10.00 20.08553692   1.0
> stopifnot(all.equal(y1, y0))
> 
> y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
> y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
> print(y1)
         a        beta logic
0%    1.00  0.04978707   0.0
25%   3.25  0.25160736   0.0
50%   5.50  1.00000000   0.5
75%   7.75  5.05366896   1.0
100% 10.00 20.08553692   1.0
> stopifnot(all.equal(y1, y0))
> 
> 
> ## ---------------------------------------------------------
> ## Parallel Random Number Generation
> ## ---------------------------------------------------------
> 
> 
> ## ---------------------------------------------------------
> ## Process chunks of data.frame rows in parallel
> ## ---------------------------------------------------------
> iris <- datasets::iris
> chunks <- split(iris, seq(1, nrow(iris), length.out = 3L))
> y0 <- lapply(chunks, FUN = function(iris) sum(iris$Sepal.Length))
> y0 <- do.call(sum, y0)
> y1 <- future_lapply(chunks, FUN = function(iris) sum(iris$Sepal.Length))
> y1 <- do.call(sum, y1)
> print(y1)
[1] 876.5
> stopifnot(all.equal(y1, y0))
> 
> 
> ## Don't show: 
> ## R CMD check: make sure any open connections are closed afterward
> if (!inherits(plan(), "sequential")) plan(sequential)
> ## End(Don't show)
> 
> 
> 
> cleanEx()
> nameEx("future_mapply")
> ### * future_mapply
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: future_Map
> ### Title: Apply a Function to Multiple List or Vector Arguments
> ### Aliases: future_Map future_mapply future_.mapply
> ### Keywords: iteration manip programming
> 
> ### ** Examples
> 
> ## ---------------------------------------------------------
> ## mapply()
> ## ---------------------------------------------------------
> y0 <- mapply(rep, 1:4, 4:1)
> y1 <- future_mapply(rep, 1:4, 4:1)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(rep, times = 1:4, x = 4:1)
> y1 <- future_mapply(rep, times = 1:4, x = 4:1)
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(rep, times = 1:4, MoreArgs = list(x = 42))
> y1 <- future_mapply(rep, times = 1:4, MoreArgs = list(x = 42))
> stopifnot(identical(y1, y0))
> 
> y0 <- mapply(function(x, y) seq_len(x) + y,
+              c(a =  1, b = 2, c = 3),  # names from first
+              c(A = 10, B = 0, C = -10))
> y1 <- future_mapply(function(x, y) seq_len(x) + y,
+                     c(a =  1, b = 2, c = 3),  # names from first
+                     c(A = 10, B = 0, C = -10))
> stopifnot(identical(y1, y0))
> 
> word <- function(C, k) paste(rep.int(C, k), collapse = "")
> y0 <- mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE)
> y1 <- future_mapply(word, LETTERS[1:6], 6:1, SIMPLIFY = FALSE)
> stopifnot(identical(y1, y0))
> 
> 
> ## ---------------------------------------------------------
> ## Parallel Random Number Generation
> ## ---------------------------------------------------------
> 
> ## Don't show: 
> ## R CMD check: make sure any open connections are closed afterward
> if (!inherits(plan(), "sequential")) plan(sequential)
> ## End(Don't show)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.5 0.034 1.336 0.186 0.333 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
