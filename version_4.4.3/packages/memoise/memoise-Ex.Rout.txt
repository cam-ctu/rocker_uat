
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "memoise"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('memoise')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("cache_filesystem")
> ### * cache_filesystem
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cache_filesystem
> ### Title: Filesystem Cache
> ### Aliases: cache_filesystem
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D # Use with Dropbox
> ##D 
> ##D db <- cache_filesystem("~/Dropbox/.rcache")
> ##D 
> ##D mem_runif <- memoise(runif, cache = db)
> ##D 
> ##D # Use with Google Drive
> ##D 
> ##D gd <- cache_filesystem("~/Google Drive/.rcache")
> ##D 
> ##D mem_runif <- memoise(runif, cache = gd)
> ##D 
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("cache_gcs")
> ### * cache_gcs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cache_gcs
> ### Title: Google Cloud Storage Cache Google Cloud Storage backed cache,
> ###   for remote caching.
> ### Aliases: cache_gcs
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D library(googleCloudStorageR)
> ##D # Set GCS credentials.
> ##D Sys.setenv("GCS_AUTH_FILE"="<google-service-json>",
> ##D            "GCS_DEFAULT_BUCKET"="unique-bucket-name")
> ##D 
> ##D gcs <- cache_gcs("unique-bucket-name")
> ##D mem_runif <- memoise(runif, cache = gcs)
> ## End(Not run)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("cache_s3")
> ### * cache_s3
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cache_s3
> ### Title: Amazon Web Services S3 Cache Amazon Web Services S3 backed
> ###   cache, for remote caching.
> ### Aliases: cache_s3
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D # Set AWS credentials.
> ##D Sys.setenv("AWS_ACCESS_KEY_ID" = "<access key>",
> ##D            "AWS_SECRET_ACCESS_KEY" = "<access secret>")
> ##D 
> ##D # Set up a unique bucket name.
> ##D s3 <- cache_s3("unique-bucket-name")
> ##D mem_runif <- memoise(runif, cache = s3)
> ## End(Not run)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("drop_cache")
> ### * drop_cache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: drop_cache
> ### Title: Drops the cache of a memoised function for particular arguments.
> ### Aliases: drop_cache
> 
> ### ** Examples
> 
> mem_sum <- memoise(sum)
> mem_sum(1, 2, 3)
[1] 6
> mem_sum(2, 3, 4)
[1] 9
> has_cache(mem_sum)(1, 2, 3) # TRUE
[1] TRUE
> has_cache(mem_sum)(2, 3, 4) # TRUE
[1] TRUE
> drop_cache(mem_sum)(1, 2, 3) # TRUE
[1] TRUE
> has_cache(mem_sum)(1, 2, 3) # FALSE
[1] FALSE
> has_cache(mem_sum)(2, 3, 4) # TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("forget")
> ### * forget
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: forget
> ### Title: Forget past results. Resets the cache of a memoised function.
> ###   Use 'drop_cache' to reset the cache only for particular arguments.
> ### Aliases: forget
> 
> ### ** Examples
> 
> memX <- memoise(function() { Sys.sleep(1); runif(1) })
> # The forget() function
> system.time(print(memX()))
[1] 0.2655087
   user  system elapsed 
  0.000   0.000   1.001 
> system.time(print(memX()))
[1] 0.2655087
   user  system elapsed 
      0       0       0 
> forget(memX)
[1] TRUE
> system.time(print(memX()))
[1] 0.3721239
   user  system elapsed 
  0.001   0.000   1.003 
> 
> 
> 
> cleanEx()
> nameEx("has_cache")
> ### * has_cache
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: has_cache
> ### Title: Test whether a memoised function has been cached for particular
> ###   arguments.
> ### Aliases: has_cache
> 
> ### ** Examples
> 
> mem_sum <- memoise(sum)
> has_cache(mem_sum)(1, 2, 3) # FALSE
[1] FALSE
> mem_sum(1, 2, 3)
[1] 6
> has_cache(mem_sum)(1, 2, 3) # TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("is.memoised")
> ### * is.memoised
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.memoised
> ### Title: Test whether a function is a memoised copy. Memoised copies of
> ###   functions carry an attribute 'memoised = TRUE', which is what
> ###   'is.memoised()' tests for.
> ### Aliases: is.memoised is.memoized
> 
> ### ** Examples
> 
> mem_lm <- memoise(lm)
> is.memoised(lm) # FALSE
[1] FALSE
> is.memoised(mem_lm) # TRUE
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("memoise")
> ### * memoise
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: memoise
> ### Title: Memoise a function
> ### Aliases: memoise memoize
> 
> ### ** Examples
> 
> # a() is evaluated anew each time. memA() is only re-evaluated
> # when you call it with a new set of parameters.
> a <- function(n) { runif(n) }
> memA <- memoise(a)
> replicate(5, a(2))
          [,1]      [,2]      [,3]      [,4]       [,5]
[1,] 0.2655087 0.5728534 0.2016819 0.9446753 0.62911404
[2,] 0.3721239 0.9082078 0.8983897 0.6607978 0.06178627
> replicate(5, memA(2))
          [,1]      [,2]      [,3]      [,4]      [,5]
[1,] 0.2059746 0.2059746 0.2059746 0.2059746 0.2059746
[2,] 0.1765568 0.1765568 0.1765568 0.1765568 0.1765568
> 
> # Caching is done based on parameters' value, so same-name-but-
> # changed-value correctly produces two different outcomes...
> N <- 4; memA(N)
[1] 0.6870228 0.3841037 0.7698414 0.4976992
> N <- 5; memA(N)
[1] 0.7176185 0.9919061 0.3800352 0.7774452 0.9347052
> # ... and same-value-but-different-name correctly produces
> #     the same cached outcome.
> N <- 4; memA(N)
[1] 0.6870228 0.3841037 0.7698414 0.4976992
> N2 <- 4; memA(N2)
[1] 0.6870228 0.3841037 0.7698414 0.4976992
> 
> # memoise() knows about default parameters.
> b <- function(n, dummy="a") { runif(n) }
> memB <- memoise(b)
> memB(2)
[1] 0.2121425 0.6516738
> memB(2, dummy="a")
[1] 0.2121425 0.6516738
> # This works, because the interface of the memoised function is the same as
> # that of the original function.
> formals(b)
$n


$dummy
[1] "a"

> formals(memB)
$n


$dummy
[1] "a"

> # However, it doesn't know about parameter relevance.
> # Different call means different caching, no matter
> # that the outcome is the same.
> memB(2, dummy="b")
[1] 0.1255551 0.2672207
> 
> # You can create multiple memoisations of the same function,
> # and they'll be independent.
> memA(2)
[1] 0.2059746 0.1765568
> memA2 <- memoise(a)
> memA(2)  # Still the same outcome
[1] 0.2059746 0.1765568
> memA2(2) # Different cache, different outcome
[1] 0.38611409 0.01339033
> 
> # Multiple memoized functions can share a cache.
> cm <- cachem::cache_mem(max_size = 50 * 1024^2)
> memA <- memoise(a, cache = cm)
> memB <- memoise(b, cache = cm)
> 
> # Don't do the same memoisation assignment twice: a brand-new
> # memoised function also means a brand-new cache, and *that*
> # you could as easily and more legibly achieve using forget().
> # (If you're not sure whether you already memoised something,
> #  use is.memoised() to check.)
> memA(2)
[1] 0.3823880 0.8696908
> memA <- memoise(a)
> memA(2)
[1] 0.3403490 0.4820801
> 
> # Make a memoized result automatically time out after 10 seconds.
> memA3 <- memoise(a, cache = cachem::cache_mem(max_age = 10))
> memA3(2)
[1] 0.5995658 0.4935413
> 
> 
> 
> cleanEx()
> nameEx("timeout")
> ### * timeout
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: timeout
> ### Title: Return a new number after a given number of seconds
> ### Aliases: timeout
> 
> ### ** Examples
> 
> a <- function(n) { runif(n) }
> memA <- memoise(a, ~timeout(10))
> memA(2)
[1] 0.2655087 0.3721239
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  0.225 0.011 2.238 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
