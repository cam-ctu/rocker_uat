
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:06.622] plan(): Setting new future strategy stack:
[10:21:06.623] List of future strategies:
[10:21:06.623] 1. sequential:
[10:21:06.623]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.623]    - tweaked: FALSE
[10:21:06.623]    - call: future::plan("sequential")
[10:21:06.637] plan(): nbrOfWorkers() = 1
> 
> message("*** Futures - labels ...")
*** Futures - labels ...
> 
> strategies <- supportedStrategies()
> 
> ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
> if (!fullTest && isWin32) strategies <- NULL
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   for (label in list(NULL, sprintf("strategy = %s", strategy))) {
+     fcn <- get(strategy, mode = "function")
+     stopifnot(inherits(fcn, strategy))
+     f <- fcn(42, label = label)
+     print(f)
+     stopifnot(identical(f$label, label))
+     v <- value(f)
+     stopifnot(v == 42)
+     
+     f <- future(42, label = label)
+     print(f)
+     stopifnot(identical(f$label, label))
+     v <- value(f)
+     stopifnot(v == 42)
+ 
+     v %<-% { 42 } %label% label
+     f <- futureOf(v)
+     print(f)
+     stopifnot(identical(f$label, label))
+     stopifnot(v == 42)
+ 
+   } ## for (label ...)
+ 
+   message(sprintf("- plan('%s') ... DONE", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[10:21:06.665] plan(): Setting new future strategy stack:
[10:21:06.665] List of future strategies:
[10:21:06.665] 1. sequential:
[10:21:06.665]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.665]    - tweaked: FALSE
[10:21:06.665]    - call: plan(strategy)
[10:21:06.678] plan(): nbrOfWorkers() = 1
[10:21:06.679] getGlobalsAndPackages() ...
[10:21:06.679] Searching for globals...
[10:21:06.681] 
[10:21:06.681] Searching for globals ... DONE
[10:21:06.681] - globals: [0] <none>
[10:21:06.681] getGlobalsAndPackages() ... DONE
[10:21:06.682] Packages needed by the future expression (n = 0): <none>
[10:21:06.682] Packages needed by future strategies (n = 0): <none>
[10:21:06.683] {
[10:21:06.683]     {
[10:21:06.683]         {
[10:21:06.683]             ...future.startTime <- base::Sys.time()
[10:21:06.683]             {
[10:21:06.683]                 {
[10:21:06.683]                   {
[10:21:06.683]                     base::local({
[10:21:06.683]                       has_future <- base::requireNamespace("future", 
[10:21:06.683]                         quietly = TRUE)
[10:21:06.683]                       if (has_future) {
[10:21:06.683]                         ns <- base::getNamespace("future")
[10:21:06.683]                         version <- ns[[".package"]][["version"]]
[10:21:06.683]                         if (is.null(version)) 
[10:21:06.683]                           version <- utils::packageVersion("future")
[10:21:06.683]                       }
[10:21:06.683]                       else {
[10:21:06.683]                         version <- NULL
[10:21:06.683]                       }
[10:21:06.683]                       if (!has_future || version < "1.8.0") {
[10:21:06.683]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.683]                           "", base::R.version$version.string), 
[10:21:06.683]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:06.683]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.683]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.683]                             "release", "version")], collapse = " "), 
[10:21:06.683]                           hostname = base::Sys.info()[["nodename"]])
[10:21:06.683]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.683]                           info)
[10:21:06.683]                         info <- base::paste(info, collapse = "; ")
[10:21:06.683]                         if (!has_future) {
[10:21:06.683]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.683]                             info)
[10:21:06.683]                         }
[10:21:06.683]                         else {
[10:21:06.683]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.683]                             info, version)
[10:21:06.683]                         }
[10:21:06.683]                         base::stop(msg)
[10:21:06.683]                       }
[10:21:06.683]                     })
[10:21:06.683]                   }
[10:21:06.683]                   ...future.strategy.old <- future::plan("list")
[10:21:06.683]                   options(future.plan = NULL)
[10:21:06.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.683]                 }
[10:21:06.683]                 ...future.workdir <- getwd()
[10:21:06.683]             }
[10:21:06.683]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.683]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.683]         }
[10:21:06.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.683]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.683]             base::names(...future.oldOptions))
[10:21:06.683]     }
[10:21:06.683]     if (FALSE) {
[10:21:06.683]     }
[10:21:06.683]     else {
[10:21:06.683]         if (TRUE) {
[10:21:06.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.683]                 open = "w")
[10:21:06.683]         }
[10:21:06.683]         else {
[10:21:06.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.683]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.683]         }
[10:21:06.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.683]             base::sink(type = "output", split = FALSE)
[10:21:06.683]             base::close(...future.stdout)
[10:21:06.683]         }, add = TRUE)
[10:21:06.683]     }
[10:21:06.683]     ...future.frame <- base::sys.nframe()
[10:21:06.683]     ...future.conditions <- base::list()
[10:21:06.683]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.683]     if (FALSE) {
[10:21:06.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.683]     }
[10:21:06.683]     ...future.result <- base::tryCatch({
[10:21:06.683]         base::withCallingHandlers({
[10:21:06.683]             ...future.value <- base::withVisible(base::local(42))
[10:21:06.683]             future::FutureResult(value = ...future.value$value, 
[10:21:06.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.683]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.683]                     ...future.globalenv.names))
[10:21:06.683]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.683]         }, condition = base::local({
[10:21:06.683]             c <- base::c
[10:21:06.683]             inherits <- base::inherits
[10:21:06.683]             invokeRestart <- base::invokeRestart
[10:21:06.683]             length <- base::length
[10:21:06.683]             list <- base::list
[10:21:06.683]             seq.int <- base::seq.int
[10:21:06.683]             signalCondition <- base::signalCondition
[10:21:06.683]             sys.calls <- base::sys.calls
[10:21:06.683]             `[[` <- base::`[[`
[10:21:06.683]             `+` <- base::`+`
[10:21:06.683]             `<<-` <- base::`<<-`
[10:21:06.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.683]                   3L)]
[10:21:06.683]             }
[10:21:06.683]             function(cond) {
[10:21:06.683]                 is_error <- inherits(cond, "error")
[10:21:06.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.683]                   NULL)
[10:21:06.683]                 if (is_error) {
[10:21:06.683]                   sessionInformation <- function() {
[10:21:06.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.683]                       search = base::search(), system = base::Sys.info())
[10:21:06.683]                   }
[10:21:06.683]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.683]                     cond$call), session = sessionInformation(), 
[10:21:06.683]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.683]                   signalCondition(cond)
[10:21:06.683]                 }
[10:21:06.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.683]                 "immediateCondition"))) {
[10:21:06.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.683]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.683]                   if (TRUE && !signal) {
[10:21:06.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.683]                     {
[10:21:06.683]                       inherits <- base::inherits
[10:21:06.683]                       invokeRestart <- base::invokeRestart
[10:21:06.683]                       is.null <- base::is.null
[10:21:06.683]                       muffled <- FALSE
[10:21:06.683]                       if (inherits(cond, "message")) {
[10:21:06.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.683]                         if (muffled) 
[10:21:06.683]                           invokeRestart("muffleMessage")
[10:21:06.683]                       }
[10:21:06.683]                       else if (inherits(cond, "warning")) {
[10:21:06.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.683]                         if (muffled) 
[10:21:06.683]                           invokeRestart("muffleWarning")
[10:21:06.683]                       }
[10:21:06.683]                       else if (inherits(cond, "condition")) {
[10:21:06.683]                         if (!is.null(pattern)) {
[10:21:06.683]                           computeRestarts <- base::computeRestarts
[10:21:06.683]                           grepl <- base::grepl
[10:21:06.683]                           restarts <- computeRestarts(cond)
[10:21:06.683]                           for (restart in restarts) {
[10:21:06.683]                             name <- restart$name
[10:21:06.683]                             if (is.null(name)) 
[10:21:06.683]                               next
[10:21:06.683]                             if (!grepl(pattern, name)) 
[10:21:06.683]                               next
[10:21:06.683]                             invokeRestart(restart)
[10:21:06.683]                             muffled <- TRUE
[10:21:06.683]                             break
[10:21:06.683]                           }
[10:21:06.683]                         }
[10:21:06.683]                       }
[10:21:06.683]                       invisible(muffled)
[10:21:06.683]                     }
[10:21:06.683]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.683]                   }
[10:21:06.683]                 }
[10:21:06.683]                 else {
[10:21:06.683]                   if (TRUE) {
[10:21:06.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.683]                     {
[10:21:06.683]                       inherits <- base::inherits
[10:21:06.683]                       invokeRestart <- base::invokeRestart
[10:21:06.683]                       is.null <- base::is.null
[10:21:06.683]                       muffled <- FALSE
[10:21:06.683]                       if (inherits(cond, "message")) {
[10:21:06.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.683]                         if (muffled) 
[10:21:06.683]                           invokeRestart("muffleMessage")
[10:21:06.683]                       }
[10:21:06.683]                       else if (inherits(cond, "warning")) {
[10:21:06.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.683]                         if (muffled) 
[10:21:06.683]                           invokeRestart("muffleWarning")
[10:21:06.683]                       }
[10:21:06.683]                       else if (inherits(cond, "condition")) {
[10:21:06.683]                         if (!is.null(pattern)) {
[10:21:06.683]                           computeRestarts <- base::computeRestarts
[10:21:06.683]                           grepl <- base::grepl
[10:21:06.683]                           restarts <- computeRestarts(cond)
[10:21:06.683]                           for (restart in restarts) {
[10:21:06.683]                             name <- restart$name
[10:21:06.683]                             if (is.null(name)) 
[10:21:06.683]                               next
[10:21:06.683]                             if (!grepl(pattern, name)) 
[10:21:06.683]                               next
[10:21:06.683]                             invokeRestart(restart)
[10:21:06.683]                             muffled <- TRUE
[10:21:06.683]                             break
[10:21:06.683]                           }
[10:21:06.683]                         }
[10:21:06.683]                       }
[10:21:06.683]                       invisible(muffled)
[10:21:06.683]                     }
[10:21:06.683]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.683]                   }
[10:21:06.683]                 }
[10:21:06.683]             }
[10:21:06.683]         }))
[10:21:06.683]     }, error = function(ex) {
[10:21:06.683]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.683]                 ...future.rng), started = ...future.startTime, 
[10:21:06.683]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.683]             version = "1.8"), class = "FutureResult")
[10:21:06.683]     }, finally = {
[10:21:06.683]         if (!identical(...future.workdir, getwd())) 
[10:21:06.683]             setwd(...future.workdir)
[10:21:06.683]         {
[10:21:06.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.683]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.683]             }
[10:21:06.683]             base::options(...future.oldOptions)
[10:21:06.683]             if (.Platform$OS.type == "windows") {
[10:21:06.683]                 old_names <- names(...future.oldEnvVars)
[10:21:06.683]                 envs <- base::Sys.getenv()
[10:21:06.683]                 names <- names(envs)
[10:21:06.683]                 common <- intersect(names, old_names)
[10:21:06.683]                 added <- setdiff(names, old_names)
[10:21:06.683]                 removed <- setdiff(old_names, names)
[10:21:06.683]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.683]                   envs[common]]
[10:21:06.683]                 NAMES <- toupper(changed)
[10:21:06.683]                 args <- list()
[10:21:06.683]                 for (kk in seq_along(NAMES)) {
[10:21:06.683]                   name <- changed[[kk]]
[10:21:06.683]                   NAME <- NAMES[[kk]]
[10:21:06.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.683]                     next
[10:21:06.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.683]                 }
[10:21:06.683]                 NAMES <- toupper(added)
[10:21:06.683]                 for (kk in seq_along(NAMES)) {
[10:21:06.683]                   name <- added[[kk]]
[10:21:06.683]                   NAME <- NAMES[[kk]]
[10:21:06.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.683]                     next
[10:21:06.683]                   args[[name]] <- ""
[10:21:06.683]                 }
[10:21:06.683]                 NAMES <- toupper(removed)
[10:21:06.683]                 for (kk in seq_along(NAMES)) {
[10:21:06.683]                   name <- removed[[kk]]
[10:21:06.683]                   NAME <- NAMES[[kk]]
[10:21:06.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.683]                     next
[10:21:06.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.683]                 }
[10:21:06.683]                 if (length(args) > 0) 
[10:21:06.683]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.683]             }
[10:21:06.683]             else {
[10:21:06.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.683]             }
[10:21:06.683]             {
[10:21:06.683]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.683]                   0L) {
[10:21:06.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.683]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.683]                   base::options(opts)
[10:21:06.683]                 }
[10:21:06.683]                 {
[10:21:06.683]                   {
[10:21:06.683]                     NULL
[10:21:06.683]                     RNGkind("Mersenne-Twister")
[10:21:06.683]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:06.683]                       inherits = FALSE)
[10:21:06.683]                   }
[10:21:06.683]                   options(future.plan = NULL)
[10:21:06.683]                   if (is.na(NA_character_)) 
[10:21:06.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.683]                     .init = FALSE)
[10:21:06.683]                 }
[10:21:06.683]             }
[10:21:06.683]         }
[10:21:06.683]     })
[10:21:06.683]     if (TRUE) {
[10:21:06.683]         base::sink(type = "output", split = FALSE)
[10:21:06.683]         if (TRUE) {
[10:21:06.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.683]         }
[10:21:06.683]         else {
[10:21:06.683]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.683]         }
[10:21:06.683]         base::close(...future.stdout)
[10:21:06.683]         ...future.stdout <- NULL
[10:21:06.683]     }
[10:21:06.683]     ...future.result$conditions <- ...future.conditions
[10:21:06.683]     ...future.result$finished <- base::Sys.time()
[10:21:06.683]     ...future.result
[10:21:06.683] }
[10:21:06.685] plan(): Setting new future strategy stack:
[10:21:06.685] List of future strategies:
[10:21:06.685] 1. sequential:
[10:21:06.685]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.685]    - tweaked: FALSE
[10:21:06.685]    - call: NULL
[10:21:06.686] plan(): nbrOfWorkers() = 1
[10:21:06.687] plan(): Setting new future strategy stack:
[10:21:06.687] List of future strategies:
[10:21:06.687] 1. sequential:
[10:21:06.687]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.687]    - tweaked: FALSE
[10:21:06.687]    - call: plan(strategy)
[10:21:06.687] plan(): nbrOfWorkers() = 1
[10:21:06.687] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:06.689] getGlobalsAndPackages() ...
[10:21:06.689] Searching for globals...
[10:21:06.689] 
[10:21:06.689] Searching for globals ... DONE
[10:21:06.689] - globals: [0] <none>
[10:21:06.689] getGlobalsAndPackages() ... DONE
[10:21:06.690] run() for ‘Future’ ...
[10:21:06.690] - state: ‘created’
[10:21:06.690] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:06.690] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:06.690] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:06.691]   - Field: ‘label’
[10:21:06.691]   - Field: ‘local’
[10:21:06.691]   - Field: ‘owner’
[10:21:06.691]   - Field: ‘envir’
[10:21:06.691]   - Field: ‘packages’
[10:21:06.691]   - Field: ‘gc’
[10:21:06.691]   - Field: ‘conditions’
[10:21:06.691]   - Field: ‘expr’
[10:21:06.691]   - Field: ‘uuid’
[10:21:06.691]   - Field: ‘seed’
[10:21:06.691]   - Field: ‘version’
[10:21:06.691]   - Field: ‘result’
[10:21:06.692]   - Field: ‘asynchronous’
[10:21:06.692]   - Field: ‘calls’
[10:21:06.692]   - Field: ‘globals’
[10:21:06.692]   - Field: ‘stdout’
[10:21:06.692]   - Field: ‘earlySignal’
[10:21:06.692]   - Field: ‘lazy’
[10:21:06.692]   - Field: ‘state’
[10:21:06.692] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:06.692] - Launch lazy future ...
[10:21:06.692] Packages needed by the future expression (n = 0): <none>
[10:21:06.692] Packages needed by future strategies (n = 0): <none>
[10:21:06.693] {
[10:21:06.693]     {
[10:21:06.693]         {
[10:21:06.693]             ...future.startTime <- base::Sys.time()
[10:21:06.693]             {
[10:21:06.693]                 {
[10:21:06.693]                   {
[10:21:06.693]                     base::local({
[10:21:06.693]                       has_future <- base::requireNamespace("future", 
[10:21:06.693]                         quietly = TRUE)
[10:21:06.693]                       if (has_future) {
[10:21:06.693]                         ns <- base::getNamespace("future")
[10:21:06.693]                         version <- ns[[".package"]][["version"]]
[10:21:06.693]                         if (is.null(version)) 
[10:21:06.693]                           version <- utils::packageVersion("future")
[10:21:06.693]                       }
[10:21:06.693]                       else {
[10:21:06.693]                         version <- NULL
[10:21:06.693]                       }
[10:21:06.693]                       if (!has_future || version < "1.8.0") {
[10:21:06.693]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.693]                           "", base::R.version$version.string), 
[10:21:06.693]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:06.693]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.693]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.693]                             "release", "version")], collapse = " "), 
[10:21:06.693]                           hostname = base::Sys.info()[["nodename"]])
[10:21:06.693]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.693]                           info)
[10:21:06.693]                         info <- base::paste(info, collapse = "; ")
[10:21:06.693]                         if (!has_future) {
[10:21:06.693]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.693]                             info)
[10:21:06.693]                         }
[10:21:06.693]                         else {
[10:21:06.693]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.693]                             info, version)
[10:21:06.693]                         }
[10:21:06.693]                         base::stop(msg)
[10:21:06.693]                       }
[10:21:06.693]                     })
[10:21:06.693]                   }
[10:21:06.693]                   ...future.strategy.old <- future::plan("list")
[10:21:06.693]                   options(future.plan = NULL)
[10:21:06.693]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.693]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.693]                 }
[10:21:06.693]                 ...future.workdir <- getwd()
[10:21:06.693]             }
[10:21:06.693]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.693]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.693]         }
[10:21:06.693]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.693]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.693]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.693]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.693]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.693]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.693]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.693]             base::names(...future.oldOptions))
[10:21:06.693]     }
[10:21:06.693]     if (FALSE) {
[10:21:06.693]     }
[10:21:06.693]     else {
[10:21:06.693]         if (TRUE) {
[10:21:06.693]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.693]                 open = "w")
[10:21:06.693]         }
[10:21:06.693]         else {
[10:21:06.693]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.693]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.693]         }
[10:21:06.693]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.693]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.693]             base::sink(type = "output", split = FALSE)
[10:21:06.693]             base::close(...future.stdout)
[10:21:06.693]         }, add = TRUE)
[10:21:06.693]     }
[10:21:06.693]     ...future.frame <- base::sys.nframe()
[10:21:06.693]     ...future.conditions <- base::list()
[10:21:06.693]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.693]     if (FALSE) {
[10:21:06.693]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.693]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.693]     }
[10:21:06.693]     ...future.result <- base::tryCatch({
[10:21:06.693]         base::withCallingHandlers({
[10:21:06.693]             ...future.value <- base::withVisible(base::local(42))
[10:21:06.693]             future::FutureResult(value = ...future.value$value, 
[10:21:06.693]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.693]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.693]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.693]                     ...future.globalenv.names))
[10:21:06.693]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.693]         }, condition = base::local({
[10:21:06.693]             c <- base::c
[10:21:06.693]             inherits <- base::inherits
[10:21:06.693]             invokeRestart <- base::invokeRestart
[10:21:06.693]             length <- base::length
[10:21:06.693]             list <- base::list
[10:21:06.693]             seq.int <- base::seq.int
[10:21:06.693]             signalCondition <- base::signalCondition
[10:21:06.693]             sys.calls <- base::sys.calls
[10:21:06.693]             `[[` <- base::`[[`
[10:21:06.693]             `+` <- base::`+`
[10:21:06.693]             `<<-` <- base::`<<-`
[10:21:06.693]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.693]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.693]                   3L)]
[10:21:06.693]             }
[10:21:06.693]             function(cond) {
[10:21:06.693]                 is_error <- inherits(cond, "error")
[10:21:06.693]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.693]                   NULL)
[10:21:06.693]                 if (is_error) {
[10:21:06.693]                   sessionInformation <- function() {
[10:21:06.693]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.693]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.693]                       search = base::search(), system = base::Sys.info())
[10:21:06.693]                   }
[10:21:06.693]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.693]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.693]                     cond$call), session = sessionInformation(), 
[10:21:06.693]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.693]                   signalCondition(cond)
[10:21:06.693]                 }
[10:21:06.693]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.693]                 "immediateCondition"))) {
[10:21:06.693]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.693]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.693]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.693]                   if (TRUE && !signal) {
[10:21:06.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.693]                     {
[10:21:06.693]                       inherits <- base::inherits
[10:21:06.693]                       invokeRestart <- base::invokeRestart
[10:21:06.693]                       is.null <- base::is.null
[10:21:06.693]                       muffled <- FALSE
[10:21:06.693]                       if (inherits(cond, "message")) {
[10:21:06.693]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.693]                         if (muffled) 
[10:21:06.693]                           invokeRestart("muffleMessage")
[10:21:06.693]                       }
[10:21:06.693]                       else if (inherits(cond, "warning")) {
[10:21:06.693]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.693]                         if (muffled) 
[10:21:06.693]                           invokeRestart("muffleWarning")
[10:21:06.693]                       }
[10:21:06.693]                       else if (inherits(cond, "condition")) {
[10:21:06.693]                         if (!is.null(pattern)) {
[10:21:06.693]                           computeRestarts <- base::computeRestarts
[10:21:06.693]                           grepl <- base::grepl
[10:21:06.693]                           restarts <- computeRestarts(cond)
[10:21:06.693]                           for (restart in restarts) {
[10:21:06.693]                             name <- restart$name
[10:21:06.693]                             if (is.null(name)) 
[10:21:06.693]                               next
[10:21:06.693]                             if (!grepl(pattern, name)) 
[10:21:06.693]                               next
[10:21:06.693]                             invokeRestart(restart)
[10:21:06.693]                             muffled <- TRUE
[10:21:06.693]                             break
[10:21:06.693]                           }
[10:21:06.693]                         }
[10:21:06.693]                       }
[10:21:06.693]                       invisible(muffled)
[10:21:06.693]                     }
[10:21:06.693]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.693]                   }
[10:21:06.693]                 }
[10:21:06.693]                 else {
[10:21:06.693]                   if (TRUE) {
[10:21:06.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.693]                     {
[10:21:06.693]                       inherits <- base::inherits
[10:21:06.693]                       invokeRestart <- base::invokeRestart
[10:21:06.693]                       is.null <- base::is.null
[10:21:06.693]                       muffled <- FALSE
[10:21:06.693]                       if (inherits(cond, "message")) {
[10:21:06.693]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.693]                         if (muffled) 
[10:21:06.693]                           invokeRestart("muffleMessage")
[10:21:06.693]                       }
[10:21:06.693]                       else if (inherits(cond, "warning")) {
[10:21:06.693]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.693]                         if (muffled) 
[10:21:06.693]                           invokeRestart("muffleWarning")
[10:21:06.693]                       }
[10:21:06.693]                       else if (inherits(cond, "condition")) {
[10:21:06.693]                         if (!is.null(pattern)) {
[10:21:06.693]                           computeRestarts <- base::computeRestarts
[10:21:06.693]                           grepl <- base::grepl
[10:21:06.693]                           restarts <- computeRestarts(cond)
[10:21:06.693]                           for (restart in restarts) {
[10:21:06.693]                             name <- restart$name
[10:21:06.693]                             if (is.null(name)) 
[10:21:06.693]                               next
[10:21:06.693]                             if (!grepl(pattern, name)) 
[10:21:06.693]                               next
[10:21:06.693]                             invokeRestart(restart)
[10:21:06.693]                             muffled <- TRUE
[10:21:06.693]                             break
[10:21:06.693]                           }
[10:21:06.693]                         }
[10:21:06.693]                       }
[10:21:06.693]                       invisible(muffled)
[10:21:06.693]                     }
[10:21:06.693]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.693]                   }
[10:21:06.693]                 }
[10:21:06.693]             }
[10:21:06.693]         }))
[10:21:06.693]     }, error = function(ex) {
[10:21:06.693]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.693]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.693]                 ...future.rng), started = ...future.startTime, 
[10:21:06.693]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.693]             version = "1.8"), class = "FutureResult")
[10:21:06.693]     }, finally = {
[10:21:06.693]         if (!identical(...future.workdir, getwd())) 
[10:21:06.693]             setwd(...future.workdir)
[10:21:06.693]         {
[10:21:06.693]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.693]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.693]             }
[10:21:06.693]             base::options(...future.oldOptions)
[10:21:06.693]             if (.Platform$OS.type == "windows") {
[10:21:06.693]                 old_names <- names(...future.oldEnvVars)
[10:21:06.693]                 envs <- base::Sys.getenv()
[10:21:06.693]                 names <- names(envs)
[10:21:06.693]                 common <- intersect(names, old_names)
[10:21:06.693]                 added <- setdiff(names, old_names)
[10:21:06.693]                 removed <- setdiff(old_names, names)
[10:21:06.693]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.693]                   envs[common]]
[10:21:06.693]                 NAMES <- toupper(changed)
[10:21:06.693]                 args <- list()
[10:21:06.693]                 for (kk in seq_along(NAMES)) {
[10:21:06.693]                   name <- changed[[kk]]
[10:21:06.693]                   NAME <- NAMES[[kk]]
[10:21:06.693]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.693]                     next
[10:21:06.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.693]                 }
[10:21:06.693]                 NAMES <- toupper(added)
[10:21:06.693]                 for (kk in seq_along(NAMES)) {
[10:21:06.693]                   name <- added[[kk]]
[10:21:06.693]                   NAME <- NAMES[[kk]]
[10:21:06.693]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.693]                     next
[10:21:06.693]                   args[[name]] <- ""
[10:21:06.693]                 }
[10:21:06.693]                 NAMES <- toupper(removed)
[10:21:06.693]                 for (kk in seq_along(NAMES)) {
[10:21:06.693]                   name <- removed[[kk]]
[10:21:06.693]                   NAME <- NAMES[[kk]]
[10:21:06.693]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.693]                     next
[10:21:06.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.693]                 }
[10:21:06.693]                 if (length(args) > 0) 
[10:21:06.693]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.693]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.693]             }
[10:21:06.693]             else {
[10:21:06.693]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.693]             }
[10:21:06.693]             {
[10:21:06.693]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.693]                   0L) {
[10:21:06.693]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.693]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.693]                   base::options(opts)
[10:21:06.693]                 }
[10:21:06.693]                 {
[10:21:06.693]                   {
[10:21:06.693]                     NULL
[10:21:06.693]                     RNGkind("Mersenne-Twister")
[10:21:06.693]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:06.693]                       inherits = FALSE)
[10:21:06.693]                   }
[10:21:06.693]                   options(future.plan = NULL)
[10:21:06.693]                   if (is.na(NA_character_)) 
[10:21:06.693]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.693]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.693]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.693]                     .init = FALSE)
[10:21:06.693]                 }
[10:21:06.693]             }
[10:21:06.693]         }
[10:21:06.693]     })
[10:21:06.693]     if (TRUE) {
[10:21:06.693]         base::sink(type = "output", split = FALSE)
[10:21:06.693]         if (TRUE) {
[10:21:06.693]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.693]         }
[10:21:06.693]         else {
[10:21:06.693]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.693]         }
[10:21:06.693]         base::close(...future.stdout)
[10:21:06.693]         ...future.stdout <- NULL
[10:21:06.693]     }
[10:21:06.693]     ...future.result$conditions <- ...future.conditions
[10:21:06.693]     ...future.result$finished <- base::Sys.time()
[10:21:06.693]     ...future.result
[10:21:06.693] }
[10:21:06.695] plan(): Setting new future strategy stack:
[10:21:06.695] List of future strategies:
[10:21:06.695] 1. sequential:
[10:21:06.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.695]    - tweaked: FALSE
[10:21:06.695]    - call: NULL
[10:21:06.695] plan(): nbrOfWorkers() = 1
[10:21:06.696] plan(): Setting new future strategy stack:
[10:21:06.696] List of future strategies:
[10:21:06.696] 1. sequential:
[10:21:06.696]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.696]    - tweaked: FALSE
[10:21:06.696]    - call: plan(strategy)
[10:21:06.696] plan(): nbrOfWorkers() = 1
[10:21:06.696] SequentialFuture started (and completed)
[10:21:06.697] - Launch lazy future ... done
[10:21:06.697] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:06.698] getGlobalsAndPackages() ...
[10:21:06.698] Searching for globals...
[10:21:06.699] - globals found: [1] ‘{’
[10:21:06.699] Searching for globals ... DONE
[10:21:06.699] Resolving globals: FALSE
[10:21:06.700] 
[10:21:06.700] 
[10:21:06.700] getGlobalsAndPackages() ... DONE
[10:21:06.700] run() for ‘Future’ ...
[10:21:06.700] - state: ‘created’
[10:21:06.700] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:06.701] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:06.701] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:06.701]   - Field: ‘label’
[10:21:06.701]   - Field: ‘local’
[10:21:06.701]   - Field: ‘owner’
[10:21:06.701]   - Field: ‘envir’
[10:21:06.701]   - Field: ‘packages’
[10:21:06.701]   - Field: ‘gc’
[10:21:06.701]   - Field: ‘conditions’
[10:21:06.701]   - Field: ‘expr’
[10:21:06.702]   - Field: ‘uuid’
[10:21:06.702]   - Field: ‘seed’
[10:21:06.702]   - Field: ‘version’
[10:21:06.702]   - Field: ‘result’
[10:21:06.702]   - Field: ‘asynchronous’
[10:21:06.702]   - Field: ‘calls’
[10:21:06.702]   - Field: ‘globals’
[10:21:06.702]   - Field: ‘stdout’
[10:21:06.702]   - Field: ‘earlySignal’
[10:21:06.702]   - Field: ‘lazy’
[10:21:06.702]   - Field: ‘state’
[10:21:06.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:06.703] - Launch lazy future ...
[10:21:06.703] Packages needed by the future expression (n = 0): <none>
[10:21:06.703] Packages needed by future strategies (n = 0): <none>
[10:21:06.703] {
[10:21:06.703]     {
[10:21:06.703]         {
[10:21:06.703]             ...future.startTime <- base::Sys.time()
[10:21:06.703]             {
[10:21:06.703]                 {
[10:21:06.703]                   {
[10:21:06.703]                     base::local({
[10:21:06.703]                       has_future <- base::requireNamespace("future", 
[10:21:06.703]                         quietly = TRUE)
[10:21:06.703]                       if (has_future) {
[10:21:06.703]                         ns <- base::getNamespace("future")
[10:21:06.703]                         version <- ns[[".package"]][["version"]]
[10:21:06.703]                         if (is.null(version)) 
[10:21:06.703]                           version <- utils::packageVersion("future")
[10:21:06.703]                       }
[10:21:06.703]                       else {
[10:21:06.703]                         version <- NULL
[10:21:06.703]                       }
[10:21:06.703]                       if (!has_future || version < "1.8.0") {
[10:21:06.703]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.703]                           "", base::R.version$version.string), 
[10:21:06.703]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:06.703]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.703]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.703]                             "release", "version")], collapse = " "), 
[10:21:06.703]                           hostname = base::Sys.info()[["nodename"]])
[10:21:06.703]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.703]                           info)
[10:21:06.703]                         info <- base::paste(info, collapse = "; ")
[10:21:06.703]                         if (!has_future) {
[10:21:06.703]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.703]                             info)
[10:21:06.703]                         }
[10:21:06.703]                         else {
[10:21:06.703]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.703]                             info, version)
[10:21:06.703]                         }
[10:21:06.703]                         base::stop(msg)
[10:21:06.703]                       }
[10:21:06.703]                     })
[10:21:06.703]                   }
[10:21:06.703]                   ...future.strategy.old <- future::plan("list")
[10:21:06.703]                   options(future.plan = NULL)
[10:21:06.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.703]                 }
[10:21:06.703]                 ...future.workdir <- getwd()
[10:21:06.703]             }
[10:21:06.703]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.703]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.703]         }
[10:21:06.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.703]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.703]             base::names(...future.oldOptions))
[10:21:06.703]     }
[10:21:06.703]     if (FALSE) {
[10:21:06.703]     }
[10:21:06.703]     else {
[10:21:06.703]         if (TRUE) {
[10:21:06.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.703]                 open = "w")
[10:21:06.703]         }
[10:21:06.703]         else {
[10:21:06.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.703]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.703]         }
[10:21:06.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.703]             base::sink(type = "output", split = FALSE)
[10:21:06.703]             base::close(...future.stdout)
[10:21:06.703]         }, add = TRUE)
[10:21:06.703]     }
[10:21:06.703]     ...future.frame <- base::sys.nframe()
[10:21:06.703]     ...future.conditions <- base::list()
[10:21:06.703]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.703]     if (FALSE) {
[10:21:06.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.703]     }
[10:21:06.703]     ...future.result <- base::tryCatch({
[10:21:06.703]         base::withCallingHandlers({
[10:21:06.703]             ...future.value <- base::withVisible(base::local({
[10:21:06.703]                 42
[10:21:06.703]             }))
[10:21:06.703]             future::FutureResult(value = ...future.value$value, 
[10:21:06.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.703]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.703]                     ...future.globalenv.names))
[10:21:06.703]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.703]         }, condition = base::local({
[10:21:06.703]             c <- base::c
[10:21:06.703]             inherits <- base::inherits
[10:21:06.703]             invokeRestart <- base::invokeRestart
[10:21:06.703]             length <- base::length
[10:21:06.703]             list <- base::list
[10:21:06.703]             seq.int <- base::seq.int
[10:21:06.703]             signalCondition <- base::signalCondition
[10:21:06.703]             sys.calls <- base::sys.calls
[10:21:06.703]             `[[` <- base::`[[`
[10:21:06.703]             `+` <- base::`+`
[10:21:06.703]             `<<-` <- base::`<<-`
[10:21:06.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.703]                   3L)]
[10:21:06.703]             }
[10:21:06.703]             function(cond) {
[10:21:06.703]                 is_error <- inherits(cond, "error")
[10:21:06.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.703]                   NULL)
[10:21:06.703]                 if (is_error) {
[10:21:06.703]                   sessionInformation <- function() {
[10:21:06.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.703]                       search = base::search(), system = base::Sys.info())
[10:21:06.703]                   }
[10:21:06.703]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.703]                     cond$call), session = sessionInformation(), 
[10:21:06.703]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.703]                   signalCondition(cond)
[10:21:06.703]                 }
[10:21:06.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.703]                 "immediateCondition"))) {
[10:21:06.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.703]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.703]                   if (TRUE && !signal) {
[10:21:06.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.703]                     {
[10:21:06.703]                       inherits <- base::inherits
[10:21:06.703]                       invokeRestart <- base::invokeRestart
[10:21:06.703]                       is.null <- base::is.null
[10:21:06.703]                       muffled <- FALSE
[10:21:06.703]                       if (inherits(cond, "message")) {
[10:21:06.703]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.703]                         if (muffled) 
[10:21:06.703]                           invokeRestart("muffleMessage")
[10:21:06.703]                       }
[10:21:06.703]                       else if (inherits(cond, "warning")) {
[10:21:06.703]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.703]                         if (muffled) 
[10:21:06.703]                           invokeRestart("muffleWarning")
[10:21:06.703]                       }
[10:21:06.703]                       else if (inherits(cond, "condition")) {
[10:21:06.703]                         if (!is.null(pattern)) {
[10:21:06.703]                           computeRestarts <- base::computeRestarts
[10:21:06.703]                           grepl <- base::grepl
[10:21:06.703]                           restarts <- computeRestarts(cond)
[10:21:06.703]                           for (restart in restarts) {
[10:21:06.703]                             name <- restart$name
[10:21:06.703]                             if (is.null(name)) 
[10:21:06.703]                               next
[10:21:06.703]                             if (!grepl(pattern, name)) 
[10:21:06.703]                               next
[10:21:06.703]                             invokeRestart(restart)
[10:21:06.703]                             muffled <- TRUE
[10:21:06.703]                             break
[10:21:06.703]                           }
[10:21:06.703]                         }
[10:21:06.703]                       }
[10:21:06.703]                       invisible(muffled)
[10:21:06.703]                     }
[10:21:06.703]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.703]                   }
[10:21:06.703]                 }
[10:21:06.703]                 else {
[10:21:06.703]                   if (TRUE) {
[10:21:06.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.703]                     {
[10:21:06.703]                       inherits <- base::inherits
[10:21:06.703]                       invokeRestart <- base::invokeRestart
[10:21:06.703]                       is.null <- base::is.null
[10:21:06.703]                       muffled <- FALSE
[10:21:06.703]                       if (inherits(cond, "message")) {
[10:21:06.703]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.703]                         if (muffled) 
[10:21:06.703]                           invokeRestart("muffleMessage")
[10:21:06.703]                       }
[10:21:06.703]                       else if (inherits(cond, "warning")) {
[10:21:06.703]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.703]                         if (muffled) 
[10:21:06.703]                           invokeRestart("muffleWarning")
[10:21:06.703]                       }
[10:21:06.703]                       else if (inherits(cond, "condition")) {
[10:21:06.703]                         if (!is.null(pattern)) {
[10:21:06.703]                           computeRestarts <- base::computeRestarts
[10:21:06.703]                           grepl <- base::grepl
[10:21:06.703]                           restarts <- computeRestarts(cond)
[10:21:06.703]                           for (restart in restarts) {
[10:21:06.703]                             name <- restart$name
[10:21:06.703]                             if (is.null(name)) 
[10:21:06.703]                               next
[10:21:06.703]                             if (!grepl(pattern, name)) 
[10:21:06.703]                               next
[10:21:06.703]                             invokeRestart(restart)
[10:21:06.703]                             muffled <- TRUE
[10:21:06.703]                             break
[10:21:06.703]                           }
[10:21:06.703]                         }
[10:21:06.703]                       }
[10:21:06.703]                       invisible(muffled)
[10:21:06.703]                     }
[10:21:06.703]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.703]                   }
[10:21:06.703]                 }
[10:21:06.703]             }
[10:21:06.703]         }))
[10:21:06.703]     }, error = function(ex) {
[10:21:06.703]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.703]                 ...future.rng), started = ...future.startTime, 
[10:21:06.703]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.703]             version = "1.8"), class = "FutureResult")
[10:21:06.703]     }, finally = {
[10:21:06.703]         if (!identical(...future.workdir, getwd())) 
[10:21:06.703]             setwd(...future.workdir)
[10:21:06.703]         {
[10:21:06.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.703]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.703]             }
[10:21:06.703]             base::options(...future.oldOptions)
[10:21:06.703]             if (.Platform$OS.type == "windows") {
[10:21:06.703]                 old_names <- names(...future.oldEnvVars)
[10:21:06.703]                 envs <- base::Sys.getenv()
[10:21:06.703]                 names <- names(envs)
[10:21:06.703]                 common <- intersect(names, old_names)
[10:21:06.703]                 added <- setdiff(names, old_names)
[10:21:06.703]                 removed <- setdiff(old_names, names)
[10:21:06.703]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.703]                   envs[common]]
[10:21:06.703]                 NAMES <- toupper(changed)
[10:21:06.703]                 args <- list()
[10:21:06.703]                 for (kk in seq_along(NAMES)) {
[10:21:06.703]                   name <- changed[[kk]]
[10:21:06.703]                   NAME <- NAMES[[kk]]
[10:21:06.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.703]                     next
[10:21:06.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.703]                 }
[10:21:06.703]                 NAMES <- toupper(added)
[10:21:06.703]                 for (kk in seq_along(NAMES)) {
[10:21:06.703]                   name <- added[[kk]]
[10:21:06.703]                   NAME <- NAMES[[kk]]
[10:21:06.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.703]                     next
[10:21:06.703]                   args[[name]] <- ""
[10:21:06.703]                 }
[10:21:06.703]                 NAMES <- toupper(removed)
[10:21:06.703]                 for (kk in seq_along(NAMES)) {
[10:21:06.703]                   name <- removed[[kk]]
[10:21:06.703]                   NAME <- NAMES[[kk]]
[10:21:06.703]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.703]                     next
[10:21:06.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.703]                 }
[10:21:06.703]                 if (length(args) > 0) 
[10:21:06.703]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.703]             }
[10:21:06.703]             else {
[10:21:06.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.703]             }
[10:21:06.703]             {
[10:21:06.703]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.703]                   0L) {
[10:21:06.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.703]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.703]                   base::options(opts)
[10:21:06.703]                 }
[10:21:06.703]                 {
[10:21:06.703]                   {
[10:21:06.703]                     NULL
[10:21:06.703]                     RNGkind("Mersenne-Twister")
[10:21:06.703]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:06.703]                       inherits = FALSE)
[10:21:06.703]                   }
[10:21:06.703]                   options(future.plan = NULL)
[10:21:06.703]                   if (is.na(NA_character_)) 
[10:21:06.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.703]                     .init = FALSE)
[10:21:06.703]                 }
[10:21:06.703]             }
[10:21:06.703]         }
[10:21:06.703]     })
[10:21:06.703]     if (TRUE) {
[10:21:06.703]         base::sink(type = "output", split = FALSE)
[10:21:06.703]         if (TRUE) {
[10:21:06.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.703]         }
[10:21:06.703]         else {
[10:21:06.703]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.703]         }
[10:21:06.703]         base::close(...future.stdout)
[10:21:06.703]         ...future.stdout <- NULL
[10:21:06.703]     }
[10:21:06.703]     ...future.result$conditions <- ...future.conditions
[10:21:06.703]     ...future.result$finished <- base::Sys.time()
[10:21:06.703]     ...future.result
[10:21:06.703] }
[10:21:06.705] plan(): Setting new future strategy stack:
[10:21:06.705] List of future strategies:
[10:21:06.705] 1. sequential:
[10:21:06.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.705]    - tweaked: FALSE
[10:21:06.705]    - call: NULL
[10:21:06.706] plan(): nbrOfWorkers() = 1
[10:21:06.706] plan(): Setting new future strategy stack:
[10:21:06.706] List of future strategies:
[10:21:06.706] 1. sequential:
[10:21:06.706]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.706]    - tweaked: FALSE
[10:21:06.706]    - call: plan(strategy)
[10:21:06.707] plan(): nbrOfWorkers() = 1
[10:21:06.707] SequentialFuture started (and completed)
[10:21:06.707] - Launch lazy future ... done
[10:21:06.707] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:06.708] getGlobalsAndPackages() ...
[10:21:06.708] Searching for globals...
[10:21:06.708] 
[10:21:06.708] Searching for globals ... DONE
[10:21:06.708] - globals: [0] <none>
[10:21:06.709] getGlobalsAndPackages() ... DONE
[10:21:06.709] Packages needed by the future expression (n = 0): <none>
[10:21:06.709] Packages needed by future strategies (n = 0): <none>
[10:21:06.709] {
[10:21:06.709]     {
[10:21:06.709]         {
[10:21:06.709]             ...future.startTime <- base::Sys.time()
[10:21:06.709]             {
[10:21:06.709]                 {
[10:21:06.709]                   {
[10:21:06.709]                     base::local({
[10:21:06.709]                       has_future <- base::requireNamespace("future", 
[10:21:06.709]                         quietly = TRUE)
[10:21:06.709]                       if (has_future) {
[10:21:06.709]                         ns <- base::getNamespace("future")
[10:21:06.709]                         version <- ns[[".package"]][["version"]]
[10:21:06.709]                         if (is.null(version)) 
[10:21:06.709]                           version <- utils::packageVersion("future")
[10:21:06.709]                       }
[10:21:06.709]                       else {
[10:21:06.709]                         version <- NULL
[10:21:06.709]                       }
[10:21:06.709]                       if (!has_future || version < "1.8.0") {
[10:21:06.709]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.709]                           "", base::R.version$version.string), 
[10:21:06.709]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:06.709]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.709]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.709]                             "release", "version")], collapse = " "), 
[10:21:06.709]                           hostname = base::Sys.info()[["nodename"]])
[10:21:06.709]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.709]                           info)
[10:21:06.709]                         info <- base::paste(info, collapse = "; ")
[10:21:06.709]                         if (!has_future) {
[10:21:06.709]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.709]                             info)
[10:21:06.709]                         }
[10:21:06.709]                         else {
[10:21:06.709]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.709]                             info, version)
[10:21:06.709]                         }
[10:21:06.709]                         base::stop(msg)
[10:21:06.709]                       }
[10:21:06.709]                     })
[10:21:06.709]                   }
[10:21:06.709]                   ...future.strategy.old <- future::plan("list")
[10:21:06.709]                   options(future.plan = NULL)
[10:21:06.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.709]                 }
[10:21:06.709]                 ...future.workdir <- getwd()
[10:21:06.709]             }
[10:21:06.709]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.709]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.709]         }
[10:21:06.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.709]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.709]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.709]             base::names(...future.oldOptions))
[10:21:06.709]     }
[10:21:06.709]     if (FALSE) {
[10:21:06.709]     }
[10:21:06.709]     else {
[10:21:06.709]         if (TRUE) {
[10:21:06.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.709]                 open = "w")
[10:21:06.709]         }
[10:21:06.709]         else {
[10:21:06.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.709]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.709]         }
[10:21:06.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.709]             base::sink(type = "output", split = FALSE)
[10:21:06.709]             base::close(...future.stdout)
[10:21:06.709]         }, add = TRUE)
[10:21:06.709]     }
[10:21:06.709]     ...future.frame <- base::sys.nframe()
[10:21:06.709]     ...future.conditions <- base::list()
[10:21:06.709]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.709]     if (FALSE) {
[10:21:06.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.709]     }
[10:21:06.709]     ...future.result <- base::tryCatch({
[10:21:06.709]         base::withCallingHandlers({
[10:21:06.709]             ...future.value <- base::withVisible(base::local(42))
[10:21:06.709]             future::FutureResult(value = ...future.value$value, 
[10:21:06.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.709]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.709]                     ...future.globalenv.names))
[10:21:06.709]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.709]         }, condition = base::local({
[10:21:06.709]             c <- base::c
[10:21:06.709]             inherits <- base::inherits
[10:21:06.709]             invokeRestart <- base::invokeRestart
[10:21:06.709]             length <- base::length
[10:21:06.709]             list <- base::list
[10:21:06.709]             seq.int <- base::seq.int
[10:21:06.709]             signalCondition <- base::signalCondition
[10:21:06.709]             sys.calls <- base::sys.calls
[10:21:06.709]             `[[` <- base::`[[`
[10:21:06.709]             `+` <- base::`+`
[10:21:06.709]             `<<-` <- base::`<<-`
[10:21:06.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.709]                   3L)]
[10:21:06.709]             }
[10:21:06.709]             function(cond) {
[10:21:06.709]                 is_error <- inherits(cond, "error")
[10:21:06.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.709]                   NULL)
[10:21:06.709]                 if (is_error) {
[10:21:06.709]                   sessionInformation <- function() {
[10:21:06.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.709]                       search = base::search(), system = base::Sys.info())
[10:21:06.709]                   }
[10:21:06.709]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.709]                     cond$call), session = sessionInformation(), 
[10:21:06.709]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.709]                   signalCondition(cond)
[10:21:06.709]                 }
[10:21:06.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.709]                 "immediateCondition"))) {
[10:21:06.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.709]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.709]                   if (TRUE && !signal) {
[10:21:06.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.709]                     {
[10:21:06.709]                       inherits <- base::inherits
[10:21:06.709]                       invokeRestart <- base::invokeRestart
[10:21:06.709]                       is.null <- base::is.null
[10:21:06.709]                       muffled <- FALSE
[10:21:06.709]                       if (inherits(cond, "message")) {
[10:21:06.709]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.709]                         if (muffled) 
[10:21:06.709]                           invokeRestart("muffleMessage")
[10:21:06.709]                       }
[10:21:06.709]                       else if (inherits(cond, "warning")) {
[10:21:06.709]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.709]                         if (muffled) 
[10:21:06.709]                           invokeRestart("muffleWarning")
[10:21:06.709]                       }
[10:21:06.709]                       else if (inherits(cond, "condition")) {
[10:21:06.709]                         if (!is.null(pattern)) {
[10:21:06.709]                           computeRestarts <- base::computeRestarts
[10:21:06.709]                           grepl <- base::grepl
[10:21:06.709]                           restarts <- computeRestarts(cond)
[10:21:06.709]                           for (restart in restarts) {
[10:21:06.709]                             name <- restart$name
[10:21:06.709]                             if (is.null(name)) 
[10:21:06.709]                               next
[10:21:06.709]                             if (!grepl(pattern, name)) 
[10:21:06.709]                               next
[10:21:06.709]                             invokeRestart(restart)
[10:21:06.709]                             muffled <- TRUE
[10:21:06.709]                             break
[10:21:06.709]                           }
[10:21:06.709]                         }
[10:21:06.709]                       }
[10:21:06.709]                       invisible(muffled)
[10:21:06.709]                     }
[10:21:06.709]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.709]                   }
[10:21:06.709]                 }
[10:21:06.709]                 else {
[10:21:06.709]                   if (TRUE) {
[10:21:06.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.709]                     {
[10:21:06.709]                       inherits <- base::inherits
[10:21:06.709]                       invokeRestart <- base::invokeRestart
[10:21:06.709]                       is.null <- base::is.null
[10:21:06.709]                       muffled <- FALSE
[10:21:06.709]                       if (inherits(cond, "message")) {
[10:21:06.709]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.709]                         if (muffled) 
[10:21:06.709]                           invokeRestart("muffleMessage")
[10:21:06.709]                       }
[10:21:06.709]                       else if (inherits(cond, "warning")) {
[10:21:06.709]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.709]                         if (muffled) 
[10:21:06.709]                           invokeRestart("muffleWarning")
[10:21:06.709]                       }
[10:21:06.709]                       else if (inherits(cond, "condition")) {
[10:21:06.709]                         if (!is.null(pattern)) {
[10:21:06.709]                           computeRestarts <- base::computeRestarts
[10:21:06.709]                           grepl <- base::grepl
[10:21:06.709]                           restarts <- computeRestarts(cond)
[10:21:06.709]                           for (restart in restarts) {
[10:21:06.709]                             name <- restart$name
[10:21:06.709]                             if (is.null(name)) 
[10:21:06.709]                               next
[10:21:06.709]                             if (!grepl(pattern, name)) 
[10:21:06.709]                               next
[10:21:06.709]                             invokeRestart(restart)
[10:21:06.709]                             muffled <- TRUE
[10:21:06.709]                             break
[10:21:06.709]                           }
[10:21:06.709]                         }
[10:21:06.709]                       }
[10:21:06.709]                       invisible(muffled)
[10:21:06.709]                     }
[10:21:06.709]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.709]                   }
[10:21:06.709]                 }
[10:21:06.709]             }
[10:21:06.709]         }))
[10:21:06.709]     }, error = function(ex) {
[10:21:06.709]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.709]                 ...future.rng), started = ...future.startTime, 
[10:21:06.709]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.709]             version = "1.8"), class = "FutureResult")
[10:21:06.709]     }, finally = {
[10:21:06.709]         if (!identical(...future.workdir, getwd())) 
[10:21:06.709]             setwd(...future.workdir)
[10:21:06.709]         {
[10:21:06.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.709]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.709]             }
[10:21:06.709]             base::options(...future.oldOptions)
[10:21:06.709]             if (.Platform$OS.type == "windows") {
[10:21:06.709]                 old_names <- names(...future.oldEnvVars)
[10:21:06.709]                 envs <- base::Sys.getenv()
[10:21:06.709]                 names <- names(envs)
[10:21:06.709]                 common <- intersect(names, old_names)
[10:21:06.709]                 added <- setdiff(names, old_names)
[10:21:06.709]                 removed <- setdiff(old_names, names)
[10:21:06.709]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.709]                   envs[common]]
[10:21:06.709]                 NAMES <- toupper(changed)
[10:21:06.709]                 args <- list()
[10:21:06.709]                 for (kk in seq_along(NAMES)) {
[10:21:06.709]                   name <- changed[[kk]]
[10:21:06.709]                   NAME <- NAMES[[kk]]
[10:21:06.709]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.709]                     next
[10:21:06.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.709]                 }
[10:21:06.709]                 NAMES <- toupper(added)
[10:21:06.709]                 for (kk in seq_along(NAMES)) {
[10:21:06.709]                   name <- added[[kk]]
[10:21:06.709]                   NAME <- NAMES[[kk]]
[10:21:06.709]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.709]                     next
[10:21:06.709]                   args[[name]] <- ""
[10:21:06.709]                 }
[10:21:06.709]                 NAMES <- toupper(removed)
[10:21:06.709]                 for (kk in seq_along(NAMES)) {
[10:21:06.709]                   name <- removed[[kk]]
[10:21:06.709]                   NAME <- NAMES[[kk]]
[10:21:06.709]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.709]                     next
[10:21:06.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.709]                 }
[10:21:06.709]                 if (length(args) > 0) 
[10:21:06.709]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.709]             }
[10:21:06.709]             else {
[10:21:06.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.709]             }
[10:21:06.709]             {
[10:21:06.709]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.709]                   0L) {
[10:21:06.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.709]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.709]                   base::options(opts)
[10:21:06.709]                 }
[10:21:06.709]                 {
[10:21:06.709]                   {
[10:21:06.709]                     NULL
[10:21:06.709]                     RNGkind("Mersenne-Twister")
[10:21:06.709]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:06.709]                       inherits = FALSE)
[10:21:06.709]                   }
[10:21:06.709]                   options(future.plan = NULL)
[10:21:06.709]                   if (is.na(NA_character_)) 
[10:21:06.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.709]                     .init = FALSE)
[10:21:06.709]                 }
[10:21:06.709]             }
[10:21:06.709]         }
[10:21:06.709]     })
[10:21:06.709]     if (TRUE) {
[10:21:06.709]         base::sink(type = "output", split = FALSE)
[10:21:06.709]         if (TRUE) {
[10:21:06.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.709]         }
[10:21:06.709]         else {
[10:21:06.709]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.709]         }
[10:21:06.709]         base::close(...future.stdout)
[10:21:06.709]         ...future.stdout <- NULL
[10:21:06.709]     }
[10:21:06.709]     ...future.result$conditions <- ...future.conditions
[10:21:06.709]     ...future.result$finished <- base::Sys.time()
[10:21:06.709]     ...future.result
[10:21:06.709] }
[10:21:06.711] plan(): Setting new future strategy stack:
[10:21:06.711] List of future strategies:
[10:21:06.711] 1. sequential:
[10:21:06.711]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.711]    - tweaked: FALSE
[10:21:06.711]    - call: NULL
[10:21:06.712] plan(): nbrOfWorkers() = 1
[10:21:06.712] plan(): Setting new future strategy stack:
[10:21:06.712] List of future strategies:
[10:21:06.712] 1. sequential:
[10:21:06.712]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.712]    - tweaked: FALSE
[10:21:06.712]    - call: plan(strategy)
[10:21:06.713] plan(): nbrOfWorkers() = 1
[10:21:06.715] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘strategy = sequential’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:06.716] getGlobalsAndPackages() ...
[10:21:06.716] Searching for globals...
[10:21:06.716] 
[10:21:06.716] Searching for globals ... DONE
[10:21:06.717] - globals: [0] <none>
[10:21:06.717] getGlobalsAndPackages() ... DONE
[10:21:06.717] run() for ‘Future’ ...
[10:21:06.717] - state: ‘created’
[10:21:06.717] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:06.717] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:06.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:06.717]   - Field: ‘label’
[10:21:06.718]   - Field: ‘local’
[10:21:06.718]   - Field: ‘owner’
[10:21:06.718]   - Field: ‘envir’
[10:21:06.718]   - Field: ‘packages’
[10:21:06.718]   - Field: ‘gc’
[10:21:06.718]   - Field: ‘conditions’
[10:21:06.718]   - Field: ‘expr’
[10:21:06.718]   - Field: ‘uuid’
[10:21:06.718]   - Field: ‘seed’
[10:21:06.718]   - Field: ‘version’
[10:21:06.718]   - Field: ‘result’
[10:21:06.719]   - Field: ‘asynchronous’
[10:21:06.719]   - Field: ‘calls’
[10:21:06.719]   - Field: ‘globals’
[10:21:06.719]   - Field: ‘stdout’
[10:21:06.719]   - Field: ‘earlySignal’
[10:21:06.719]   - Field: ‘lazy’
[10:21:06.719]   - Field: ‘state’
[10:21:06.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:06.719] - Launch lazy future ...
[10:21:06.719] Packages needed by the future expression (n = 0): <none>
[10:21:06.719] Packages needed by future strategies (n = 0): <none>
[10:21:06.720] {
[10:21:06.720]     {
[10:21:06.720]         {
[10:21:06.720]             ...future.startTime <- base::Sys.time()
[10:21:06.720]             {
[10:21:06.720]                 {
[10:21:06.720]                   {
[10:21:06.720]                     base::local({
[10:21:06.720]                       has_future <- base::requireNamespace("future", 
[10:21:06.720]                         quietly = TRUE)
[10:21:06.720]                       if (has_future) {
[10:21:06.720]                         ns <- base::getNamespace("future")
[10:21:06.720]                         version <- ns[[".package"]][["version"]]
[10:21:06.720]                         if (is.null(version)) 
[10:21:06.720]                           version <- utils::packageVersion("future")
[10:21:06.720]                       }
[10:21:06.720]                       else {
[10:21:06.720]                         version <- NULL
[10:21:06.720]                       }
[10:21:06.720]                       if (!has_future || version < "1.8.0") {
[10:21:06.720]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.720]                           "", base::R.version$version.string), 
[10:21:06.720]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:06.720]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.720]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.720]                             "release", "version")], collapse = " "), 
[10:21:06.720]                           hostname = base::Sys.info()[["nodename"]])
[10:21:06.720]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.720]                           info)
[10:21:06.720]                         info <- base::paste(info, collapse = "; ")
[10:21:06.720]                         if (!has_future) {
[10:21:06.720]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.720]                             info)
[10:21:06.720]                         }
[10:21:06.720]                         else {
[10:21:06.720]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.720]                             info, version)
[10:21:06.720]                         }
[10:21:06.720]                         base::stop(msg)
[10:21:06.720]                       }
[10:21:06.720]                     })
[10:21:06.720]                   }
[10:21:06.720]                   ...future.strategy.old <- future::plan("list")
[10:21:06.720]                   options(future.plan = NULL)
[10:21:06.720]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.720]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.720]                 }
[10:21:06.720]                 ...future.workdir <- getwd()
[10:21:06.720]             }
[10:21:06.720]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.720]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.720]         }
[10:21:06.720]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.720]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.720]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.720]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.720]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.720]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.720]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.720]             base::names(...future.oldOptions))
[10:21:06.720]     }
[10:21:06.720]     if (FALSE) {
[10:21:06.720]     }
[10:21:06.720]     else {
[10:21:06.720]         if (TRUE) {
[10:21:06.720]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.720]                 open = "w")
[10:21:06.720]         }
[10:21:06.720]         else {
[10:21:06.720]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.720]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.720]         }
[10:21:06.720]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.720]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.720]             base::sink(type = "output", split = FALSE)
[10:21:06.720]             base::close(...future.stdout)
[10:21:06.720]         }, add = TRUE)
[10:21:06.720]     }
[10:21:06.720]     ...future.frame <- base::sys.nframe()
[10:21:06.720]     ...future.conditions <- base::list()
[10:21:06.720]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.720]     if (FALSE) {
[10:21:06.720]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.720]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.720]     }
[10:21:06.720]     ...future.result <- base::tryCatch({
[10:21:06.720]         base::withCallingHandlers({
[10:21:06.720]             ...future.value <- base::withVisible(base::local(42))
[10:21:06.720]             future::FutureResult(value = ...future.value$value, 
[10:21:06.720]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.720]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.720]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.720]                     ...future.globalenv.names))
[10:21:06.720]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.720]         }, condition = base::local({
[10:21:06.720]             c <- base::c
[10:21:06.720]             inherits <- base::inherits
[10:21:06.720]             invokeRestart <- base::invokeRestart
[10:21:06.720]             length <- base::length
[10:21:06.720]             list <- base::list
[10:21:06.720]             seq.int <- base::seq.int
[10:21:06.720]             signalCondition <- base::signalCondition
[10:21:06.720]             sys.calls <- base::sys.calls
[10:21:06.720]             `[[` <- base::`[[`
[10:21:06.720]             `+` <- base::`+`
[10:21:06.720]             `<<-` <- base::`<<-`
[10:21:06.720]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.720]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.720]                   3L)]
[10:21:06.720]             }
[10:21:06.720]             function(cond) {
[10:21:06.720]                 is_error <- inherits(cond, "error")
[10:21:06.720]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.720]                   NULL)
[10:21:06.720]                 if (is_error) {
[10:21:06.720]                   sessionInformation <- function() {
[10:21:06.720]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.720]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.720]                       search = base::search(), system = base::Sys.info())
[10:21:06.720]                   }
[10:21:06.720]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.720]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.720]                     cond$call), session = sessionInformation(), 
[10:21:06.720]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.720]                   signalCondition(cond)
[10:21:06.720]                 }
[10:21:06.720]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.720]                 "immediateCondition"))) {
[10:21:06.720]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.720]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.720]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.720]                   if (TRUE && !signal) {
[10:21:06.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.720]                     {
[10:21:06.720]                       inherits <- base::inherits
[10:21:06.720]                       invokeRestart <- base::invokeRestart
[10:21:06.720]                       is.null <- base::is.null
[10:21:06.720]                       muffled <- FALSE
[10:21:06.720]                       if (inherits(cond, "message")) {
[10:21:06.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.720]                         if (muffled) 
[10:21:06.720]                           invokeRestart("muffleMessage")
[10:21:06.720]                       }
[10:21:06.720]                       else if (inherits(cond, "warning")) {
[10:21:06.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.720]                         if (muffled) 
[10:21:06.720]                           invokeRestart("muffleWarning")
[10:21:06.720]                       }
[10:21:06.720]                       else if (inherits(cond, "condition")) {
[10:21:06.720]                         if (!is.null(pattern)) {
[10:21:06.720]                           computeRestarts <- base::computeRestarts
[10:21:06.720]                           grepl <- base::grepl
[10:21:06.720]                           restarts <- computeRestarts(cond)
[10:21:06.720]                           for (restart in restarts) {
[10:21:06.720]                             name <- restart$name
[10:21:06.720]                             if (is.null(name)) 
[10:21:06.720]                               next
[10:21:06.720]                             if (!grepl(pattern, name)) 
[10:21:06.720]                               next
[10:21:06.720]                             invokeRestart(restart)
[10:21:06.720]                             muffled <- TRUE
[10:21:06.720]                             break
[10:21:06.720]                           }
[10:21:06.720]                         }
[10:21:06.720]                       }
[10:21:06.720]                       invisible(muffled)
[10:21:06.720]                     }
[10:21:06.720]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.720]                   }
[10:21:06.720]                 }
[10:21:06.720]                 else {
[10:21:06.720]                   if (TRUE) {
[10:21:06.720]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.720]                     {
[10:21:06.720]                       inherits <- base::inherits
[10:21:06.720]                       invokeRestart <- base::invokeRestart
[10:21:06.720]                       is.null <- base::is.null
[10:21:06.720]                       muffled <- FALSE
[10:21:06.720]                       if (inherits(cond, "message")) {
[10:21:06.720]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.720]                         if (muffled) 
[10:21:06.720]                           invokeRestart("muffleMessage")
[10:21:06.720]                       }
[10:21:06.720]                       else if (inherits(cond, "warning")) {
[10:21:06.720]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.720]                         if (muffled) 
[10:21:06.720]                           invokeRestart("muffleWarning")
[10:21:06.720]                       }
[10:21:06.720]                       else if (inherits(cond, "condition")) {
[10:21:06.720]                         if (!is.null(pattern)) {
[10:21:06.720]                           computeRestarts <- base::computeRestarts
[10:21:06.720]                           grepl <- base::grepl
[10:21:06.720]                           restarts <- computeRestarts(cond)
[10:21:06.720]                           for (restart in restarts) {
[10:21:06.720]                             name <- restart$name
[10:21:06.720]                             if (is.null(name)) 
[10:21:06.720]                               next
[10:21:06.720]                             if (!grepl(pattern, name)) 
[10:21:06.720]                               next
[10:21:06.720]                             invokeRestart(restart)
[10:21:06.720]                             muffled <- TRUE
[10:21:06.720]                             break
[10:21:06.720]                           }
[10:21:06.720]                         }
[10:21:06.720]                       }
[10:21:06.720]                       invisible(muffled)
[10:21:06.720]                     }
[10:21:06.720]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.720]                   }
[10:21:06.720]                 }
[10:21:06.720]             }
[10:21:06.720]         }))
[10:21:06.720]     }, error = function(ex) {
[10:21:06.720]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.720]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.720]                 ...future.rng), started = ...future.startTime, 
[10:21:06.720]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.720]             version = "1.8"), class = "FutureResult")
[10:21:06.720]     }, finally = {
[10:21:06.720]         if (!identical(...future.workdir, getwd())) 
[10:21:06.720]             setwd(...future.workdir)
[10:21:06.720]         {
[10:21:06.720]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.720]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.720]             }
[10:21:06.720]             base::options(...future.oldOptions)
[10:21:06.720]             if (.Platform$OS.type == "windows") {
[10:21:06.720]                 old_names <- names(...future.oldEnvVars)
[10:21:06.720]                 envs <- base::Sys.getenv()
[10:21:06.720]                 names <- names(envs)
[10:21:06.720]                 common <- intersect(names, old_names)
[10:21:06.720]                 added <- setdiff(names, old_names)
[10:21:06.720]                 removed <- setdiff(old_names, names)
[10:21:06.720]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.720]                   envs[common]]
[10:21:06.720]                 NAMES <- toupper(changed)
[10:21:06.720]                 args <- list()
[10:21:06.720]                 for (kk in seq_along(NAMES)) {
[10:21:06.720]                   name <- changed[[kk]]
[10:21:06.720]                   NAME <- NAMES[[kk]]
[10:21:06.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.720]                     next
[10:21:06.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.720]                 }
[10:21:06.720]                 NAMES <- toupper(added)
[10:21:06.720]                 for (kk in seq_along(NAMES)) {
[10:21:06.720]                   name <- added[[kk]]
[10:21:06.720]                   NAME <- NAMES[[kk]]
[10:21:06.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.720]                     next
[10:21:06.720]                   args[[name]] <- ""
[10:21:06.720]                 }
[10:21:06.720]                 NAMES <- toupper(removed)
[10:21:06.720]                 for (kk in seq_along(NAMES)) {
[10:21:06.720]                   name <- removed[[kk]]
[10:21:06.720]                   NAME <- NAMES[[kk]]
[10:21:06.720]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.720]                     next
[10:21:06.720]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.720]                 }
[10:21:06.720]                 if (length(args) > 0) 
[10:21:06.720]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.720]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.720]             }
[10:21:06.720]             else {
[10:21:06.720]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.720]             }
[10:21:06.720]             {
[10:21:06.720]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.720]                   0L) {
[10:21:06.720]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.720]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.720]                   base::options(opts)
[10:21:06.720]                 }
[10:21:06.720]                 {
[10:21:06.720]                   {
[10:21:06.720]                     NULL
[10:21:06.720]                     RNGkind("Mersenne-Twister")
[10:21:06.720]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:06.720]                       inherits = FALSE)
[10:21:06.720]                   }
[10:21:06.720]                   options(future.plan = NULL)
[10:21:06.720]                   if (is.na(NA_character_)) 
[10:21:06.720]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.720]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.720]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.720]                     .init = FALSE)
[10:21:06.720]                 }
[10:21:06.720]             }
[10:21:06.720]         }
[10:21:06.720]     })
[10:21:06.720]     if (TRUE) {
[10:21:06.720]         base::sink(type = "output", split = FALSE)
[10:21:06.720]         if (TRUE) {
[10:21:06.720]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.720]         }
[10:21:06.720]         else {
[10:21:06.720]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.720]         }
[10:21:06.720]         base::close(...future.stdout)
[10:21:06.720]         ...future.stdout <- NULL
[10:21:06.720]     }
[10:21:06.720]     ...future.result$conditions <- ...future.conditions
[10:21:06.720]     ...future.result$finished <- base::Sys.time()
[10:21:06.720]     ...future.result
[10:21:06.720] }
[10:21:06.722] plan(): Setting new future strategy stack:
[10:21:06.722] List of future strategies:
[10:21:06.722] 1. sequential:
[10:21:06.722]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.722]    - tweaked: FALSE
[10:21:06.722]    - call: NULL
[10:21:06.722] plan(): nbrOfWorkers() = 1
[10:21:06.723] plan(): Setting new future strategy stack:
[10:21:06.723] List of future strategies:
[10:21:06.723] 1. sequential:
[10:21:06.723]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.723]    - tweaked: FALSE
[10:21:06.723]    - call: plan(strategy)
[10:21:06.723] plan(): nbrOfWorkers() = 1
[10:21:06.723] SequentialFuture started (and completed)
[10:21:06.724] - Launch lazy future ... done
[10:21:06.724] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘strategy = sequential’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:06.724] getGlobalsAndPackages() ...
[10:21:06.724] Searching for globals...
[10:21:06.725] - globals found: [1] ‘{’
[10:21:06.725] Searching for globals ... DONE
[10:21:06.725] Resolving globals: FALSE
[10:21:06.725] 
[10:21:06.725] 
[10:21:06.726] getGlobalsAndPackages() ... DONE
[10:21:06.726] run() for ‘Future’ ...
[10:21:06.726] - state: ‘created’
[10:21:06.726] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:06.726] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:06.726] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:06.726]   - Field: ‘label’
[10:21:06.726]   - Field: ‘local’
[10:21:06.727]   - Field: ‘owner’
[10:21:06.727]   - Field: ‘envir’
[10:21:06.727]   - Field: ‘packages’
[10:21:06.727]   - Field: ‘gc’
[10:21:06.727]   - Field: ‘conditions’
[10:21:06.727]   - Field: ‘expr’
[10:21:06.727]   - Field: ‘uuid’
[10:21:06.727]   - Field: ‘seed’
[10:21:06.727]   - Field: ‘version’
[10:21:06.727]   - Field: ‘result’
[10:21:06.727]   - Field: ‘asynchronous’
[10:21:06.728]   - Field: ‘calls’
[10:21:06.728]   - Field: ‘globals’
[10:21:06.728]   - Field: ‘stdout’
[10:21:06.728]   - Field: ‘earlySignal’
[10:21:06.728]   - Field: ‘lazy’
[10:21:06.728]   - Field: ‘state’
[10:21:06.728] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:06.728] - Launch lazy future ...
[10:21:06.728] Packages needed by the future expression (n = 0): <none>
[10:21:06.728] Packages needed by future strategies (n = 0): <none>
[10:21:06.729] {
[10:21:06.729]     {
[10:21:06.729]         {
[10:21:06.729]             ...future.startTime <- base::Sys.time()
[10:21:06.729]             {
[10:21:06.729]                 {
[10:21:06.729]                   {
[10:21:06.729]                     base::local({
[10:21:06.729]                       has_future <- base::requireNamespace("future", 
[10:21:06.729]                         quietly = TRUE)
[10:21:06.729]                       if (has_future) {
[10:21:06.729]                         ns <- base::getNamespace("future")
[10:21:06.729]                         version <- ns[[".package"]][["version"]]
[10:21:06.729]                         if (is.null(version)) 
[10:21:06.729]                           version <- utils::packageVersion("future")
[10:21:06.729]                       }
[10:21:06.729]                       else {
[10:21:06.729]                         version <- NULL
[10:21:06.729]                       }
[10:21:06.729]                       if (!has_future || version < "1.8.0") {
[10:21:06.729]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.729]                           "", base::R.version$version.string), 
[10:21:06.729]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:06.729]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.729]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.729]                             "release", "version")], collapse = " "), 
[10:21:06.729]                           hostname = base::Sys.info()[["nodename"]])
[10:21:06.729]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.729]                           info)
[10:21:06.729]                         info <- base::paste(info, collapse = "; ")
[10:21:06.729]                         if (!has_future) {
[10:21:06.729]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.729]                             info)
[10:21:06.729]                         }
[10:21:06.729]                         else {
[10:21:06.729]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.729]                             info, version)
[10:21:06.729]                         }
[10:21:06.729]                         base::stop(msg)
[10:21:06.729]                       }
[10:21:06.729]                     })
[10:21:06.729]                   }
[10:21:06.729]                   ...future.strategy.old <- future::plan("list")
[10:21:06.729]                   options(future.plan = NULL)
[10:21:06.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.729]                 }
[10:21:06.729]                 ...future.workdir <- getwd()
[10:21:06.729]             }
[10:21:06.729]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.729]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.729]         }
[10:21:06.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.729]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.729]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.729]             base::names(...future.oldOptions))
[10:21:06.729]     }
[10:21:06.729]     if (FALSE) {
[10:21:06.729]     }
[10:21:06.729]     else {
[10:21:06.729]         if (TRUE) {
[10:21:06.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.729]                 open = "w")
[10:21:06.729]         }
[10:21:06.729]         else {
[10:21:06.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.729]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.729]         }
[10:21:06.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.729]             base::sink(type = "output", split = FALSE)
[10:21:06.729]             base::close(...future.stdout)
[10:21:06.729]         }, add = TRUE)
[10:21:06.729]     }
[10:21:06.729]     ...future.frame <- base::sys.nframe()
[10:21:06.729]     ...future.conditions <- base::list()
[10:21:06.729]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.729]     if (FALSE) {
[10:21:06.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.729]     }
[10:21:06.729]     ...future.result <- base::tryCatch({
[10:21:06.729]         base::withCallingHandlers({
[10:21:06.729]             ...future.value <- base::withVisible(base::local({
[10:21:06.729]                 42
[10:21:06.729]             }))
[10:21:06.729]             future::FutureResult(value = ...future.value$value, 
[10:21:06.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.729]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.729]                     ...future.globalenv.names))
[10:21:06.729]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.729]         }, condition = base::local({
[10:21:06.729]             c <- base::c
[10:21:06.729]             inherits <- base::inherits
[10:21:06.729]             invokeRestart <- base::invokeRestart
[10:21:06.729]             length <- base::length
[10:21:06.729]             list <- base::list
[10:21:06.729]             seq.int <- base::seq.int
[10:21:06.729]             signalCondition <- base::signalCondition
[10:21:06.729]             sys.calls <- base::sys.calls
[10:21:06.729]             `[[` <- base::`[[`
[10:21:06.729]             `+` <- base::`+`
[10:21:06.729]             `<<-` <- base::`<<-`
[10:21:06.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.729]                   3L)]
[10:21:06.729]             }
[10:21:06.729]             function(cond) {
[10:21:06.729]                 is_error <- inherits(cond, "error")
[10:21:06.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.729]                   NULL)
[10:21:06.729]                 if (is_error) {
[10:21:06.729]                   sessionInformation <- function() {
[10:21:06.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.729]                       search = base::search(), system = base::Sys.info())
[10:21:06.729]                   }
[10:21:06.729]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.729]                     cond$call), session = sessionInformation(), 
[10:21:06.729]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.729]                   signalCondition(cond)
[10:21:06.729]                 }
[10:21:06.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.729]                 "immediateCondition"))) {
[10:21:06.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.729]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.729]                   if (TRUE && !signal) {
[10:21:06.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.729]                     {
[10:21:06.729]                       inherits <- base::inherits
[10:21:06.729]                       invokeRestart <- base::invokeRestart
[10:21:06.729]                       is.null <- base::is.null
[10:21:06.729]                       muffled <- FALSE
[10:21:06.729]                       if (inherits(cond, "message")) {
[10:21:06.729]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.729]                         if (muffled) 
[10:21:06.729]                           invokeRestart("muffleMessage")
[10:21:06.729]                       }
[10:21:06.729]                       else if (inherits(cond, "warning")) {
[10:21:06.729]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.729]                         if (muffled) 
[10:21:06.729]                           invokeRestart("muffleWarning")
[10:21:06.729]                       }
[10:21:06.729]                       else if (inherits(cond, "condition")) {
[10:21:06.729]                         if (!is.null(pattern)) {
[10:21:06.729]                           computeRestarts <- base::computeRestarts
[10:21:06.729]                           grepl <- base::grepl
[10:21:06.729]                           restarts <- computeRestarts(cond)
[10:21:06.729]                           for (restart in restarts) {
[10:21:06.729]                             name <- restart$name
[10:21:06.729]                             if (is.null(name)) 
[10:21:06.729]                               next
[10:21:06.729]                             if (!grepl(pattern, name)) 
[10:21:06.729]                               next
[10:21:06.729]                             invokeRestart(restart)
[10:21:06.729]                             muffled <- TRUE
[10:21:06.729]                             break
[10:21:06.729]                           }
[10:21:06.729]                         }
[10:21:06.729]                       }
[10:21:06.729]                       invisible(muffled)
[10:21:06.729]                     }
[10:21:06.729]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.729]                   }
[10:21:06.729]                 }
[10:21:06.729]                 else {
[10:21:06.729]                   if (TRUE) {
[10:21:06.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.729]                     {
[10:21:06.729]                       inherits <- base::inherits
[10:21:06.729]                       invokeRestart <- base::invokeRestart
[10:21:06.729]                       is.null <- base::is.null
[10:21:06.729]                       muffled <- FALSE
[10:21:06.729]                       if (inherits(cond, "message")) {
[10:21:06.729]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.729]                         if (muffled) 
[10:21:06.729]                           invokeRestart("muffleMessage")
[10:21:06.729]                       }
[10:21:06.729]                       else if (inherits(cond, "warning")) {
[10:21:06.729]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.729]                         if (muffled) 
[10:21:06.729]                           invokeRestart("muffleWarning")
[10:21:06.729]                       }
[10:21:06.729]                       else if (inherits(cond, "condition")) {
[10:21:06.729]                         if (!is.null(pattern)) {
[10:21:06.729]                           computeRestarts <- base::computeRestarts
[10:21:06.729]                           grepl <- base::grepl
[10:21:06.729]                           restarts <- computeRestarts(cond)
[10:21:06.729]                           for (restart in restarts) {
[10:21:06.729]                             name <- restart$name
[10:21:06.729]                             if (is.null(name)) 
[10:21:06.729]                               next
[10:21:06.729]                             if (!grepl(pattern, name)) 
[10:21:06.729]                               next
[10:21:06.729]                             invokeRestart(restart)
[10:21:06.729]                             muffled <- TRUE
[10:21:06.729]                             break
[10:21:06.729]                           }
[10:21:06.729]                         }
[10:21:06.729]                       }
[10:21:06.729]                       invisible(muffled)
[10:21:06.729]                     }
[10:21:06.729]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.729]                   }
[10:21:06.729]                 }
[10:21:06.729]             }
[10:21:06.729]         }))
[10:21:06.729]     }, error = function(ex) {
[10:21:06.729]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.729]                 ...future.rng), started = ...future.startTime, 
[10:21:06.729]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.729]             version = "1.8"), class = "FutureResult")
[10:21:06.729]     }, finally = {
[10:21:06.729]         if (!identical(...future.workdir, getwd())) 
[10:21:06.729]             setwd(...future.workdir)
[10:21:06.729]         {
[10:21:06.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.729]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.729]             }
[10:21:06.729]             base::options(...future.oldOptions)
[10:21:06.729]             if (.Platform$OS.type == "windows") {
[10:21:06.729]                 old_names <- names(...future.oldEnvVars)
[10:21:06.729]                 envs <- base::Sys.getenv()
[10:21:06.729]                 names <- names(envs)
[10:21:06.729]                 common <- intersect(names, old_names)
[10:21:06.729]                 added <- setdiff(names, old_names)
[10:21:06.729]                 removed <- setdiff(old_names, names)
[10:21:06.729]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.729]                   envs[common]]
[10:21:06.729]                 NAMES <- toupper(changed)
[10:21:06.729]                 args <- list()
[10:21:06.729]                 for (kk in seq_along(NAMES)) {
[10:21:06.729]                   name <- changed[[kk]]
[10:21:06.729]                   NAME <- NAMES[[kk]]
[10:21:06.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.729]                     next
[10:21:06.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.729]                 }
[10:21:06.729]                 NAMES <- toupper(added)
[10:21:06.729]                 for (kk in seq_along(NAMES)) {
[10:21:06.729]                   name <- added[[kk]]
[10:21:06.729]                   NAME <- NAMES[[kk]]
[10:21:06.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.729]                     next
[10:21:06.729]                   args[[name]] <- ""
[10:21:06.729]                 }
[10:21:06.729]                 NAMES <- toupper(removed)
[10:21:06.729]                 for (kk in seq_along(NAMES)) {
[10:21:06.729]                   name <- removed[[kk]]
[10:21:06.729]                   NAME <- NAMES[[kk]]
[10:21:06.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.729]                     next
[10:21:06.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.729]                 }
[10:21:06.729]                 if (length(args) > 0) 
[10:21:06.729]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.729]             }
[10:21:06.729]             else {
[10:21:06.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.729]             }
[10:21:06.729]             {
[10:21:06.729]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.729]                   0L) {
[10:21:06.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.729]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.729]                   base::options(opts)
[10:21:06.729]                 }
[10:21:06.729]                 {
[10:21:06.729]                   {
[10:21:06.729]                     NULL
[10:21:06.729]                     RNGkind("Mersenne-Twister")
[10:21:06.729]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:06.729]                       inherits = FALSE)
[10:21:06.729]                   }
[10:21:06.729]                   options(future.plan = NULL)
[10:21:06.729]                   if (is.na(NA_character_)) 
[10:21:06.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.729]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.729]                     .init = FALSE)
[10:21:06.729]                 }
[10:21:06.729]             }
[10:21:06.729]         }
[10:21:06.729]     })
[10:21:06.729]     if (TRUE) {
[10:21:06.729]         base::sink(type = "output", split = FALSE)
[10:21:06.729]         if (TRUE) {
[10:21:06.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.729]         }
[10:21:06.729]         else {
[10:21:06.729]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.729]         }
[10:21:06.729]         base::close(...future.stdout)
[10:21:06.729]         ...future.stdout <- NULL
[10:21:06.729]     }
[10:21:06.729]     ...future.result$conditions <- ...future.conditions
[10:21:06.729]     ...future.result$finished <- base::Sys.time()
[10:21:06.729]     ...future.result
[10:21:06.729] }
[10:21:06.731] plan(): Setting new future strategy stack:
[10:21:06.731] List of future strategies:
[10:21:06.731] 1. sequential:
[10:21:06.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.731]    - tweaked: FALSE
[10:21:06.731]    - call: NULL
[10:21:06.731] plan(): nbrOfWorkers() = 1
[10:21:06.732] plan(): Setting new future strategy stack:
[10:21:06.732] List of future strategies:
[10:21:06.732] 1. sequential:
[10:21:06.732]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.732]    - tweaked: FALSE
[10:21:06.732]    - call: plan(strategy)
[10:21:06.732] plan(): nbrOfWorkers() = 1
[10:21:06.732] SequentialFuture started (and completed)
[10:21:06.733] - Launch lazy future ... done
[10:21:06.733] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘strategy = sequential’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
- plan('sequential') ... DONE
- plan('multicore') ...
[10:21:06.734] plan(): Setting new future strategy stack:
[10:21:06.734] List of future strategies:
[10:21:06.734] 1. multicore:
[10:21:06.734]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:06.734]    - tweaked: FALSE
[10:21:06.734]    - call: plan(strategy)
[10:21:06.735] plan(): nbrOfWorkers() = 2
[10:21:06.737] getGlobalsAndPackages() ...
[10:21:06.737] 
[10:21:06.737] - globals: [0] <none>
[10:21:06.737] getGlobalsAndPackages() ... DONE
[10:21:06.738] Packages needed by the future expression (n = 0): <none>
[10:21:06.739] Packages needed by future strategies (n = 0): <none>
[10:21:06.739] {
[10:21:06.739]     {
[10:21:06.739]         {
[10:21:06.739]             ...future.startTime <- base::Sys.time()
[10:21:06.739]             {
[10:21:06.739]                 {
[10:21:06.739]                   {
[10:21:06.739]                     {
[10:21:06.739]                       base::local({
[10:21:06.739]                         has_future <- base::requireNamespace("future", 
[10:21:06.739]                           quietly = TRUE)
[10:21:06.739]                         if (has_future) {
[10:21:06.739]                           ns <- base::getNamespace("future")
[10:21:06.739]                           version <- ns[[".package"]][["version"]]
[10:21:06.739]                           if (is.null(version)) 
[10:21:06.739]                             version <- utils::packageVersion("future")
[10:21:06.739]                         }
[10:21:06.739]                         else {
[10:21:06.739]                           version <- NULL
[10:21:06.739]                         }
[10:21:06.739]                         if (!has_future || version < "1.8.0") {
[10:21:06.739]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.739]                             "", base::R.version$version.string), 
[10:21:06.739]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:06.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.739]                               "release", "version")], collapse = " "), 
[10:21:06.739]                             hostname = base::Sys.info()[["nodename"]])
[10:21:06.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.739]                             info)
[10:21:06.739]                           info <- base::paste(info, collapse = "; ")
[10:21:06.739]                           if (!has_future) {
[10:21:06.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.739]                               info)
[10:21:06.739]                           }
[10:21:06.739]                           else {
[10:21:06.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.739]                               info, version)
[10:21:06.739]                           }
[10:21:06.739]                           base::stop(msg)
[10:21:06.739]                         }
[10:21:06.739]                       })
[10:21:06.739]                     }
[10:21:06.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:06.739]                     base::options(mc.cores = 1L)
[10:21:06.739]                   }
[10:21:06.739]                   ...future.strategy.old <- future::plan("list")
[10:21:06.739]                   options(future.plan = NULL)
[10:21:06.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.739]                 }
[10:21:06.739]                 ...future.workdir <- getwd()
[10:21:06.739]             }
[10:21:06.739]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.739]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.739]         }
[10:21:06.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.739]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.739]             base::names(...future.oldOptions))
[10:21:06.739]     }
[10:21:06.739]     if (FALSE) {
[10:21:06.739]     }
[10:21:06.739]     else {
[10:21:06.739]         if (TRUE) {
[10:21:06.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.739]                 open = "w")
[10:21:06.739]         }
[10:21:06.739]         else {
[10:21:06.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.739]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.739]         }
[10:21:06.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.739]             base::sink(type = "output", split = FALSE)
[10:21:06.739]             base::close(...future.stdout)
[10:21:06.739]         }, add = TRUE)
[10:21:06.739]     }
[10:21:06.739]     ...future.frame <- base::sys.nframe()
[10:21:06.739]     ...future.conditions <- base::list()
[10:21:06.739]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.739]     if (FALSE) {
[10:21:06.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.739]     }
[10:21:06.739]     ...future.result <- base::tryCatch({
[10:21:06.739]         base::withCallingHandlers({
[10:21:06.739]             ...future.value <- base::withVisible(base::local({
[10:21:06.739]                 withCallingHandlers({
[10:21:06.739]                   42
[10:21:06.739]                 }, immediateCondition = function(cond) {
[10:21:06.739]                   save_rds <- function (object, pathname, ...) 
[10:21:06.739]                   {
[10:21:06.739]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:06.739]                     if (file_test("-f", pathname_tmp)) {
[10:21:06.739]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.739]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:06.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.739]                         fi_tmp[["mtime"]])
[10:21:06.739]                     }
[10:21:06.739]                     tryCatch({
[10:21:06.739]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:06.739]                     }, error = function(ex) {
[10:21:06.739]                       msg <- conditionMessage(ex)
[10:21:06.739]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.739]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:06.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.739]                         fi_tmp[["mtime"]], msg)
[10:21:06.739]                       ex$message <- msg
[10:21:06.739]                       stop(ex)
[10:21:06.739]                     })
[10:21:06.739]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:06.739]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:06.739]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:06.739]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.739]                       fi <- file.info(pathname)
[10:21:06.739]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:06.739]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.739]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:06.739]                         fi[["size"]], fi[["mtime"]])
[10:21:06.739]                       stop(msg)
[10:21:06.739]                     }
[10:21:06.739]                     invisible(pathname)
[10:21:06.739]                   }
[10:21:06.739]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:06.739]                     rootPath = tempdir()) 
[10:21:06.739]                   {
[10:21:06.739]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:06.739]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:06.739]                       tmpdir = path, fileext = ".rds")
[10:21:06.739]                     save_rds(obj, file)
[10:21:06.739]                   }
[10:21:06.739]                   saveImmediateCondition(cond, path = "/tmp/RtmpkhXhLs/.future/immediateConditions")
[10:21:06.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.739]                   {
[10:21:06.739]                     inherits <- base::inherits
[10:21:06.739]                     invokeRestart <- base::invokeRestart
[10:21:06.739]                     is.null <- base::is.null
[10:21:06.739]                     muffled <- FALSE
[10:21:06.739]                     if (inherits(cond, "message")) {
[10:21:06.739]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:06.739]                       if (muffled) 
[10:21:06.739]                         invokeRestart("muffleMessage")
[10:21:06.739]                     }
[10:21:06.739]                     else if (inherits(cond, "warning")) {
[10:21:06.739]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:06.739]                       if (muffled) 
[10:21:06.739]                         invokeRestart("muffleWarning")
[10:21:06.739]                     }
[10:21:06.739]                     else if (inherits(cond, "condition")) {
[10:21:06.739]                       if (!is.null(pattern)) {
[10:21:06.739]                         computeRestarts <- base::computeRestarts
[10:21:06.739]                         grepl <- base::grepl
[10:21:06.739]                         restarts <- computeRestarts(cond)
[10:21:06.739]                         for (restart in restarts) {
[10:21:06.739]                           name <- restart$name
[10:21:06.739]                           if (is.null(name)) 
[10:21:06.739]                             next
[10:21:06.739]                           if (!grepl(pattern, name)) 
[10:21:06.739]                             next
[10:21:06.739]                           invokeRestart(restart)
[10:21:06.739]                           muffled <- TRUE
[10:21:06.739]                           break
[10:21:06.739]                         }
[10:21:06.739]                       }
[10:21:06.739]                     }
[10:21:06.739]                     invisible(muffled)
[10:21:06.739]                   }
[10:21:06.739]                   muffleCondition(cond)
[10:21:06.739]                 })
[10:21:06.739]             }))
[10:21:06.739]             future::FutureResult(value = ...future.value$value, 
[10:21:06.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.739]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.739]                     ...future.globalenv.names))
[10:21:06.739]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.739]         }, condition = base::local({
[10:21:06.739]             c <- base::c
[10:21:06.739]             inherits <- base::inherits
[10:21:06.739]             invokeRestart <- base::invokeRestart
[10:21:06.739]             length <- base::length
[10:21:06.739]             list <- base::list
[10:21:06.739]             seq.int <- base::seq.int
[10:21:06.739]             signalCondition <- base::signalCondition
[10:21:06.739]             sys.calls <- base::sys.calls
[10:21:06.739]             `[[` <- base::`[[`
[10:21:06.739]             `+` <- base::`+`
[10:21:06.739]             `<<-` <- base::`<<-`
[10:21:06.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.739]                   3L)]
[10:21:06.739]             }
[10:21:06.739]             function(cond) {
[10:21:06.739]                 is_error <- inherits(cond, "error")
[10:21:06.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.739]                   NULL)
[10:21:06.739]                 if (is_error) {
[10:21:06.739]                   sessionInformation <- function() {
[10:21:06.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.739]                       search = base::search(), system = base::Sys.info())
[10:21:06.739]                   }
[10:21:06.739]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.739]                     cond$call), session = sessionInformation(), 
[10:21:06.739]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.739]                   signalCondition(cond)
[10:21:06.739]                 }
[10:21:06.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.739]                 "immediateCondition"))) {
[10:21:06.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.739]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.739]                   if (TRUE && !signal) {
[10:21:06.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.739]                     {
[10:21:06.739]                       inherits <- base::inherits
[10:21:06.739]                       invokeRestart <- base::invokeRestart
[10:21:06.739]                       is.null <- base::is.null
[10:21:06.739]                       muffled <- FALSE
[10:21:06.739]                       if (inherits(cond, "message")) {
[10:21:06.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.739]                         if (muffled) 
[10:21:06.739]                           invokeRestart("muffleMessage")
[10:21:06.739]                       }
[10:21:06.739]                       else if (inherits(cond, "warning")) {
[10:21:06.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.739]                         if (muffled) 
[10:21:06.739]                           invokeRestart("muffleWarning")
[10:21:06.739]                       }
[10:21:06.739]                       else if (inherits(cond, "condition")) {
[10:21:06.739]                         if (!is.null(pattern)) {
[10:21:06.739]                           computeRestarts <- base::computeRestarts
[10:21:06.739]                           grepl <- base::grepl
[10:21:06.739]                           restarts <- computeRestarts(cond)
[10:21:06.739]                           for (restart in restarts) {
[10:21:06.739]                             name <- restart$name
[10:21:06.739]                             if (is.null(name)) 
[10:21:06.739]                               next
[10:21:06.739]                             if (!grepl(pattern, name)) 
[10:21:06.739]                               next
[10:21:06.739]                             invokeRestart(restart)
[10:21:06.739]                             muffled <- TRUE
[10:21:06.739]                             break
[10:21:06.739]                           }
[10:21:06.739]                         }
[10:21:06.739]                       }
[10:21:06.739]                       invisible(muffled)
[10:21:06.739]                     }
[10:21:06.739]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.739]                   }
[10:21:06.739]                 }
[10:21:06.739]                 else {
[10:21:06.739]                   if (TRUE) {
[10:21:06.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.739]                     {
[10:21:06.739]                       inherits <- base::inherits
[10:21:06.739]                       invokeRestart <- base::invokeRestart
[10:21:06.739]                       is.null <- base::is.null
[10:21:06.739]                       muffled <- FALSE
[10:21:06.739]                       if (inherits(cond, "message")) {
[10:21:06.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.739]                         if (muffled) 
[10:21:06.739]                           invokeRestart("muffleMessage")
[10:21:06.739]                       }
[10:21:06.739]                       else if (inherits(cond, "warning")) {
[10:21:06.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.739]                         if (muffled) 
[10:21:06.739]                           invokeRestart("muffleWarning")
[10:21:06.739]                       }
[10:21:06.739]                       else if (inherits(cond, "condition")) {
[10:21:06.739]                         if (!is.null(pattern)) {
[10:21:06.739]                           computeRestarts <- base::computeRestarts
[10:21:06.739]                           grepl <- base::grepl
[10:21:06.739]                           restarts <- computeRestarts(cond)
[10:21:06.739]                           for (restart in restarts) {
[10:21:06.739]                             name <- restart$name
[10:21:06.739]                             if (is.null(name)) 
[10:21:06.739]                               next
[10:21:06.739]                             if (!grepl(pattern, name)) 
[10:21:06.739]                               next
[10:21:06.739]                             invokeRestart(restart)
[10:21:06.739]                             muffled <- TRUE
[10:21:06.739]                             break
[10:21:06.739]                           }
[10:21:06.739]                         }
[10:21:06.739]                       }
[10:21:06.739]                       invisible(muffled)
[10:21:06.739]                     }
[10:21:06.739]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.739]                   }
[10:21:06.739]                 }
[10:21:06.739]             }
[10:21:06.739]         }))
[10:21:06.739]     }, error = function(ex) {
[10:21:06.739]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.739]                 ...future.rng), started = ...future.startTime, 
[10:21:06.739]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.739]             version = "1.8"), class = "FutureResult")
[10:21:06.739]     }, finally = {
[10:21:06.739]         if (!identical(...future.workdir, getwd())) 
[10:21:06.739]             setwd(...future.workdir)
[10:21:06.739]         {
[10:21:06.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.739]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.739]             }
[10:21:06.739]             base::options(...future.oldOptions)
[10:21:06.739]             if (.Platform$OS.type == "windows") {
[10:21:06.739]                 old_names <- names(...future.oldEnvVars)
[10:21:06.739]                 envs <- base::Sys.getenv()
[10:21:06.739]                 names <- names(envs)
[10:21:06.739]                 common <- intersect(names, old_names)
[10:21:06.739]                 added <- setdiff(names, old_names)
[10:21:06.739]                 removed <- setdiff(old_names, names)
[10:21:06.739]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.739]                   envs[common]]
[10:21:06.739]                 NAMES <- toupper(changed)
[10:21:06.739]                 args <- list()
[10:21:06.739]                 for (kk in seq_along(NAMES)) {
[10:21:06.739]                   name <- changed[[kk]]
[10:21:06.739]                   NAME <- NAMES[[kk]]
[10:21:06.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.739]                     next
[10:21:06.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.739]                 }
[10:21:06.739]                 NAMES <- toupper(added)
[10:21:06.739]                 for (kk in seq_along(NAMES)) {
[10:21:06.739]                   name <- added[[kk]]
[10:21:06.739]                   NAME <- NAMES[[kk]]
[10:21:06.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.739]                     next
[10:21:06.739]                   args[[name]] <- ""
[10:21:06.739]                 }
[10:21:06.739]                 NAMES <- toupper(removed)
[10:21:06.739]                 for (kk in seq_along(NAMES)) {
[10:21:06.739]                   name <- removed[[kk]]
[10:21:06.739]                   NAME <- NAMES[[kk]]
[10:21:06.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.739]                     next
[10:21:06.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.739]                 }
[10:21:06.739]                 if (length(args) > 0) 
[10:21:06.739]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.739]             }
[10:21:06.739]             else {
[10:21:06.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.739]             }
[10:21:06.739]             {
[10:21:06.739]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.739]                   0L) {
[10:21:06.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.739]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.739]                   base::options(opts)
[10:21:06.739]                 }
[10:21:06.739]                 {
[10:21:06.739]                   {
[10:21:06.739]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:06.739]                     NULL
[10:21:06.739]                   }
[10:21:06.739]                   options(future.plan = NULL)
[10:21:06.739]                   if (is.na(NA_character_)) 
[10:21:06.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.739]                     .init = FALSE)
[10:21:06.739]                 }
[10:21:06.739]             }
[10:21:06.739]         }
[10:21:06.739]     })
[10:21:06.739]     if (TRUE) {
[10:21:06.739]         base::sink(type = "output", split = FALSE)
[10:21:06.739]         if (TRUE) {
[10:21:06.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.739]         }
[10:21:06.739]         else {
[10:21:06.739]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.739]         }
[10:21:06.739]         base::close(...future.stdout)
[10:21:06.739]         ...future.stdout <- NULL
[10:21:06.739]     }
[10:21:06.739]     ...future.result$conditions <- ...future.conditions
[10:21:06.739]     ...future.result$finished <- base::Sys.time()
[10:21:06.739]     ...future.result
[10:21:06.739] }
[10:21:06.741] requestCore(): workers = 2
[10:21:06.744] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
[10:21:06.745] plan(): Setting new future strategy stack:
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:21:06.745] List of future strategies:
[10:21:06.745] 1. sequential:
[10:21:06.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.745]    - tweaked: FALSE
[10:21:06.745]    - call: NULL
[10:21:06.746] plan(): nbrOfWorkers() = 1
[10:21:06.748] plan(): Setting new future strategy stack:
[10:21:06.748] List of future strategies:
[10:21:06.748] 1. multicore:
[10:21:06.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:06.748]    - tweaked: FALSE
[10:21:06.748]    - call: plan(strategy)
[10:21:06.751] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.753] result() for MulticoreFuture ...
[10:21:06.758] result() for MulticoreFuture ...
[10:21:06.758] result() for MulticoreFuture ... done
[10:21:06.758] result() for MulticoreFuture ... done
[10:21:06.758] result() for MulticoreFuture ...
[10:21:06.758] result() for MulticoreFuture ... done
[10:21:06.759] getGlobalsAndPackages() ...
[10:21:06.759] Searching for globals...
[10:21:06.759] 
[10:21:06.759] Searching for globals ... DONE
[10:21:06.759] - globals: [0] <none>
[10:21:06.760] getGlobalsAndPackages() ... DONE
[10:21:06.760] run() for ‘Future’ ...
[10:21:06.760] - state: ‘created’
[10:21:06.760] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:06.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:06.763]   - Field: ‘label’
[10:21:06.766]   - Field: ‘local’
[10:21:06.766]   - Field: ‘owner’
[10:21:06.766]   - Field: ‘envir’
[10:21:06.766]   - Field: ‘workers’
[10:21:06.766]   - Field: ‘packages’
[10:21:06.766]   - Field: ‘gc’
[10:21:06.766]   - Field: ‘job’
[10:21:06.766]   - Field: ‘conditions’
[10:21:06.767]   - Field: ‘expr’
[10:21:06.767]   - Field: ‘uuid’
[10:21:06.767]   - Field: ‘seed’
[10:21:06.767]   - Field: ‘version’
[10:21:06.767]   - Field: ‘result’
[10:21:06.767]   - Field: ‘asynchronous’
[10:21:06.767]   - Field: ‘calls’
[10:21:06.767]   - Field: ‘globals’
[10:21:06.768]   - Field: ‘stdout’
[10:21:06.768]   - Field: ‘earlySignal’
[10:21:06.768]   - Field: ‘lazy’
[10:21:06.768]   - Field: ‘state’
[10:21:06.768] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:06.768] - Launch lazy future ...
[10:21:06.768] Packages needed by the future expression (n = 0): <none>
[10:21:06.769] Packages needed by future strategies (n = 0): <none>
[10:21:06.769] {
[10:21:06.769]     {
[10:21:06.769]         {
[10:21:06.769]             ...future.startTime <- base::Sys.time()
[10:21:06.769]             {
[10:21:06.769]                 {
[10:21:06.769]                   {
[10:21:06.769]                     {
[10:21:06.769]                       base::local({
[10:21:06.769]                         has_future <- base::requireNamespace("future", 
[10:21:06.769]                           quietly = TRUE)
[10:21:06.769]                         if (has_future) {
[10:21:06.769]                           ns <- base::getNamespace("future")
[10:21:06.769]                           version <- ns[[".package"]][["version"]]
[10:21:06.769]                           if (is.null(version)) 
[10:21:06.769]                             version <- utils::packageVersion("future")
[10:21:06.769]                         }
[10:21:06.769]                         else {
[10:21:06.769]                           version <- NULL
[10:21:06.769]                         }
[10:21:06.769]                         if (!has_future || version < "1.8.0") {
[10:21:06.769]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.769]                             "", base::R.version$version.string), 
[10:21:06.769]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:06.769]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.769]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.769]                               "release", "version")], collapse = " "), 
[10:21:06.769]                             hostname = base::Sys.info()[["nodename"]])
[10:21:06.769]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.769]                             info)
[10:21:06.769]                           info <- base::paste(info, collapse = "; ")
[10:21:06.769]                           if (!has_future) {
[10:21:06.769]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.769]                               info)
[10:21:06.769]                           }
[10:21:06.769]                           else {
[10:21:06.769]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.769]                               info, version)
[10:21:06.769]                           }
[10:21:06.769]                           base::stop(msg)
[10:21:06.769]                         }
[10:21:06.769]                       })
[10:21:06.769]                     }
[10:21:06.769]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:06.769]                     base::options(mc.cores = 1L)
[10:21:06.769]                   }
[10:21:06.769]                   ...future.strategy.old <- future::plan("list")
[10:21:06.769]                   options(future.plan = NULL)
[10:21:06.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.769]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.769]                 }
[10:21:06.769]                 ...future.workdir <- getwd()
[10:21:06.769]             }
[10:21:06.769]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.769]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.769]         }
[10:21:06.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.769]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.769]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.769]             base::names(...future.oldOptions))
[10:21:06.769]     }
[10:21:06.769]     if (FALSE) {
[10:21:06.769]     }
[10:21:06.769]     else {
[10:21:06.769]         if (TRUE) {
[10:21:06.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.769]                 open = "w")
[10:21:06.769]         }
[10:21:06.769]         else {
[10:21:06.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.769]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.769]         }
[10:21:06.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.769]             base::sink(type = "output", split = FALSE)
[10:21:06.769]             base::close(...future.stdout)
[10:21:06.769]         }, add = TRUE)
[10:21:06.769]     }
[10:21:06.769]     ...future.frame <- base::sys.nframe()
[10:21:06.769]     ...future.conditions <- base::list()
[10:21:06.769]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.769]     if (FALSE) {
[10:21:06.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.769]     }
[10:21:06.769]     ...future.result <- base::tryCatch({
[10:21:06.769]         base::withCallingHandlers({
[10:21:06.769]             ...future.value <- base::withVisible(base::local({
[10:21:06.769]                 withCallingHandlers({
[10:21:06.769]                   42
[10:21:06.769]                 }, immediateCondition = function(cond) {
[10:21:06.769]                   save_rds <- function (object, pathname, ...) 
[10:21:06.769]                   {
[10:21:06.769]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:06.769]                     if (file_test("-f", pathname_tmp)) {
[10:21:06.769]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.769]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:06.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.769]                         fi_tmp[["mtime"]])
[10:21:06.769]                     }
[10:21:06.769]                     tryCatch({
[10:21:06.769]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:06.769]                     }, error = function(ex) {
[10:21:06.769]                       msg <- conditionMessage(ex)
[10:21:06.769]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.769]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:06.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.769]                         fi_tmp[["mtime"]], msg)
[10:21:06.769]                       ex$message <- msg
[10:21:06.769]                       stop(ex)
[10:21:06.769]                     })
[10:21:06.769]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:06.769]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:06.769]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:06.769]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.769]                       fi <- file.info(pathname)
[10:21:06.769]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:06.769]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.769]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:06.769]                         fi[["size"]], fi[["mtime"]])
[10:21:06.769]                       stop(msg)
[10:21:06.769]                     }
[10:21:06.769]                     invisible(pathname)
[10:21:06.769]                   }
[10:21:06.769]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:06.769]                     rootPath = tempdir()) 
[10:21:06.769]                   {
[10:21:06.769]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:06.769]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:06.769]                       tmpdir = path, fileext = ".rds")
[10:21:06.769]                     save_rds(obj, file)
[10:21:06.769]                   }
[10:21:06.769]                   saveImmediateCondition(cond, path = "/tmp/RtmpkhXhLs/.future/immediateConditions")
[10:21:06.769]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.769]                   {
[10:21:06.769]                     inherits <- base::inherits
[10:21:06.769]                     invokeRestart <- base::invokeRestart
[10:21:06.769]                     is.null <- base::is.null
[10:21:06.769]                     muffled <- FALSE
[10:21:06.769]                     if (inherits(cond, "message")) {
[10:21:06.769]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:06.769]                       if (muffled) 
[10:21:06.769]                         invokeRestart("muffleMessage")
[10:21:06.769]                     }
[10:21:06.769]                     else if (inherits(cond, "warning")) {
[10:21:06.769]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:06.769]                       if (muffled) 
[10:21:06.769]                         invokeRestart("muffleWarning")
[10:21:06.769]                     }
[10:21:06.769]                     else if (inherits(cond, "condition")) {
[10:21:06.769]                       if (!is.null(pattern)) {
[10:21:06.769]                         computeRestarts <- base::computeRestarts
[10:21:06.769]                         grepl <- base::grepl
[10:21:06.769]                         restarts <- computeRestarts(cond)
[10:21:06.769]                         for (restart in restarts) {
[10:21:06.769]                           name <- restart$name
[10:21:06.769]                           if (is.null(name)) 
[10:21:06.769]                             next
[10:21:06.769]                           if (!grepl(pattern, name)) 
[10:21:06.769]                             next
[10:21:06.769]                           invokeRestart(restart)
[10:21:06.769]                           muffled <- TRUE
[10:21:06.769]                           break
[10:21:06.769]                         }
[10:21:06.769]                       }
[10:21:06.769]                     }
[10:21:06.769]                     invisible(muffled)
[10:21:06.769]                   }
[10:21:06.769]                   muffleCondition(cond)
[10:21:06.769]                 })
[10:21:06.769]             }))
[10:21:06.769]             future::FutureResult(value = ...future.value$value, 
[10:21:06.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.769]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.769]                     ...future.globalenv.names))
[10:21:06.769]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.769]         }, condition = base::local({
[10:21:06.769]             c <- base::c
[10:21:06.769]             inherits <- base::inherits
[10:21:06.769]             invokeRestart <- base::invokeRestart
[10:21:06.769]             length <- base::length
[10:21:06.769]             list <- base::list
[10:21:06.769]             seq.int <- base::seq.int
[10:21:06.769]             signalCondition <- base::signalCondition
[10:21:06.769]             sys.calls <- base::sys.calls
[10:21:06.769]             `[[` <- base::`[[`
[10:21:06.769]             `+` <- base::`+`
[10:21:06.769]             `<<-` <- base::`<<-`
[10:21:06.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.769]                   3L)]
[10:21:06.769]             }
[10:21:06.769]             function(cond) {
[10:21:06.769]                 is_error <- inherits(cond, "error")
[10:21:06.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.769]                   NULL)
[10:21:06.769]                 if (is_error) {
[10:21:06.769]                   sessionInformation <- function() {
[10:21:06.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.769]                       search = base::search(), system = base::Sys.info())
[10:21:06.769]                   }
[10:21:06.769]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.769]                     cond$call), session = sessionInformation(), 
[10:21:06.769]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.769]                   signalCondition(cond)
[10:21:06.769]                 }
[10:21:06.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.769]                 "immediateCondition"))) {
[10:21:06.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.769]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.769]                   if (TRUE && !signal) {
[10:21:06.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.769]                     {
[10:21:06.769]                       inherits <- base::inherits
[10:21:06.769]                       invokeRestart <- base::invokeRestart
[10:21:06.769]                       is.null <- base::is.null
[10:21:06.769]                       muffled <- FALSE
[10:21:06.769]                       if (inherits(cond, "message")) {
[10:21:06.769]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.769]                         if (muffled) 
[10:21:06.769]                           invokeRestart("muffleMessage")
[10:21:06.769]                       }
[10:21:06.769]                       else if (inherits(cond, "warning")) {
[10:21:06.769]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.769]                         if (muffled) 
[10:21:06.769]                           invokeRestart("muffleWarning")
[10:21:06.769]                       }
[10:21:06.769]                       else if (inherits(cond, "condition")) {
[10:21:06.769]                         if (!is.null(pattern)) {
[10:21:06.769]                           computeRestarts <- base::computeRestarts
[10:21:06.769]                           grepl <- base::grepl
[10:21:06.769]                           restarts <- computeRestarts(cond)
[10:21:06.769]                           for (restart in restarts) {
[10:21:06.769]                             name <- restart$name
[10:21:06.769]                             if (is.null(name)) 
[10:21:06.769]                               next
[10:21:06.769]                             if (!grepl(pattern, name)) 
[10:21:06.769]                               next
[10:21:06.769]                             invokeRestart(restart)
[10:21:06.769]                             muffled <- TRUE
[10:21:06.769]                             break
[10:21:06.769]                           }
[10:21:06.769]                         }
[10:21:06.769]                       }
[10:21:06.769]                       invisible(muffled)
[10:21:06.769]                     }
[10:21:06.769]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.769]                   }
[10:21:06.769]                 }
[10:21:06.769]                 else {
[10:21:06.769]                   if (TRUE) {
[10:21:06.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.769]                     {
[10:21:06.769]                       inherits <- base::inherits
[10:21:06.769]                       invokeRestart <- base::invokeRestart
[10:21:06.769]                       is.null <- base::is.null
[10:21:06.769]                       muffled <- FALSE
[10:21:06.769]                       if (inherits(cond, "message")) {
[10:21:06.769]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.769]                         if (muffled) 
[10:21:06.769]                           invokeRestart("muffleMessage")
[10:21:06.769]                       }
[10:21:06.769]                       else if (inherits(cond, "warning")) {
[10:21:06.769]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.769]                         if (muffled) 
[10:21:06.769]                           invokeRestart("muffleWarning")
[10:21:06.769]                       }
[10:21:06.769]                       else if (inherits(cond, "condition")) {
[10:21:06.769]                         if (!is.null(pattern)) {
[10:21:06.769]                           computeRestarts <- base::computeRestarts
[10:21:06.769]                           grepl <- base::grepl
[10:21:06.769]                           restarts <- computeRestarts(cond)
[10:21:06.769]                           for (restart in restarts) {
[10:21:06.769]                             name <- restart$name
[10:21:06.769]                             if (is.null(name)) 
[10:21:06.769]                               next
[10:21:06.769]                             if (!grepl(pattern, name)) 
[10:21:06.769]                               next
[10:21:06.769]                             invokeRestart(restart)
[10:21:06.769]                             muffled <- TRUE
[10:21:06.769]                             break
[10:21:06.769]                           }
[10:21:06.769]                         }
[10:21:06.769]                       }
[10:21:06.769]                       invisible(muffled)
[10:21:06.769]                     }
[10:21:06.769]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.769]                   }
[10:21:06.769]                 }
[10:21:06.769]             }
[10:21:06.769]         }))
[10:21:06.769]     }, error = function(ex) {
[10:21:06.769]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.769]                 ...future.rng), started = ...future.startTime, 
[10:21:06.769]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.769]             version = "1.8"), class = "FutureResult")
[10:21:06.769]     }, finally = {
[10:21:06.769]         if (!identical(...future.workdir, getwd())) 
[10:21:06.769]             setwd(...future.workdir)
[10:21:06.769]         {
[10:21:06.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.769]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.769]             }
[10:21:06.769]             base::options(...future.oldOptions)
[10:21:06.769]             if (.Platform$OS.type == "windows") {
[10:21:06.769]                 old_names <- names(...future.oldEnvVars)
[10:21:06.769]                 envs <- base::Sys.getenv()
[10:21:06.769]                 names <- names(envs)
[10:21:06.769]                 common <- intersect(names, old_names)
[10:21:06.769]                 added <- setdiff(names, old_names)
[10:21:06.769]                 removed <- setdiff(old_names, names)
[10:21:06.769]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.769]                   envs[common]]
[10:21:06.769]                 NAMES <- toupper(changed)
[10:21:06.769]                 args <- list()
[10:21:06.769]                 for (kk in seq_along(NAMES)) {
[10:21:06.769]                   name <- changed[[kk]]
[10:21:06.769]                   NAME <- NAMES[[kk]]
[10:21:06.769]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.769]                     next
[10:21:06.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.769]                 }
[10:21:06.769]                 NAMES <- toupper(added)
[10:21:06.769]                 for (kk in seq_along(NAMES)) {
[10:21:06.769]                   name <- added[[kk]]
[10:21:06.769]                   NAME <- NAMES[[kk]]
[10:21:06.769]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.769]                     next
[10:21:06.769]                   args[[name]] <- ""
[10:21:06.769]                 }
[10:21:06.769]                 NAMES <- toupper(removed)
[10:21:06.769]                 for (kk in seq_along(NAMES)) {
[10:21:06.769]                   name <- removed[[kk]]
[10:21:06.769]                   NAME <- NAMES[[kk]]
[10:21:06.769]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.769]                     next
[10:21:06.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.769]                 }
[10:21:06.769]                 if (length(args) > 0) 
[10:21:06.769]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.769]             }
[10:21:06.769]             else {
[10:21:06.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.769]             }
[10:21:06.769]             {
[10:21:06.769]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.769]                   0L) {
[10:21:06.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.769]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.769]                   base::options(opts)
[10:21:06.769]                 }
[10:21:06.769]                 {
[10:21:06.769]                   {
[10:21:06.769]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:06.769]                     NULL
[10:21:06.769]                   }
[10:21:06.769]                   options(future.plan = NULL)
[10:21:06.769]                   if (is.na(NA_character_)) 
[10:21:06.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.769]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.769]                     .init = FALSE)
[10:21:06.769]                 }
[10:21:06.769]             }
[10:21:06.769]         }
[10:21:06.769]     })
[10:21:06.769]     if (TRUE) {
[10:21:06.769]         base::sink(type = "output", split = FALSE)
[10:21:06.769]         if (TRUE) {
[10:21:06.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.769]         }
[10:21:06.769]         else {
[10:21:06.769]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.769]         }
[10:21:06.769]         base::close(...future.stdout)
[10:21:06.769]         ...future.stdout <- NULL
[10:21:06.769]     }
[10:21:06.769]     ...future.result$conditions <- ...future.conditions
[10:21:06.769]     ...future.result$finished <- base::Sys.time()
[10:21:06.769]     ...future.result
[10:21:06.769] }
[10:21:06.772] requestCore(): workers = 2
[10:21:06.773] MulticoreFuture started
[10:21:06.774] - Launch lazy future ... done
[10:21:06.774] run() for ‘MulticoreFuture’ ... done
MulticoreFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:21:06.774] plan(): Setting new future strategy stack:
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:21:06.775] List of future strategies:
[10:21:06.775] 1. sequential:
[10:21:06.775]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.775]    - tweaked: FALSE
[10:21:06.775]    - call: NULL
[10:21:06.776] plan(): nbrOfWorkers() = 1
[10:21:06.778] plan(): Setting new future strategy stack:
[10:21:06.778] List of future strategies:
[10:21:06.778] 1. multicore:
[10:21:06.778]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:06.778]    - tweaked: FALSE
[10:21:06.778]    - call: plan(strategy)
[10:21:06.781] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.782] result() for MulticoreFuture ...
[10:21:06.783] result() for MulticoreFuture ...
[10:21:06.783] result() for MulticoreFuture ... done
[10:21:06.783] result() for MulticoreFuture ... done
[10:21:06.783] result() for MulticoreFuture ...
[10:21:06.783] result() for MulticoreFuture ... done
[10:21:06.784] getGlobalsAndPackages() ...
[10:21:06.784] Searching for globals...
[10:21:06.785] - globals found: [1] ‘{’
[10:21:06.785] Searching for globals ... DONE
[10:21:06.785] Resolving globals: FALSE
[10:21:06.786] 
[10:21:06.786] 
[10:21:06.786] getGlobalsAndPackages() ... DONE
[10:21:06.786] run() for ‘Future’ ...
[10:21:06.786] - state: ‘created’
[10:21:06.786] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:06.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.789] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:06.789]   - Field: ‘label’
[10:21:06.789]   - Field: ‘local’
[10:21:06.789]   - Field: ‘owner’
[10:21:06.789]   - Field: ‘envir’
[10:21:06.789]   - Field: ‘workers’
[10:21:06.789]   - Field: ‘packages’
[10:21:06.789]   - Field: ‘gc’
[10:21:06.790]   - Field: ‘job’
[10:21:06.790]   - Field: ‘conditions’
[10:21:06.790]   - Field: ‘expr’
[10:21:06.790]   - Field: ‘uuid’
[10:21:06.790]   - Field: ‘seed’
[10:21:06.790]   - Field: ‘version’
[10:21:06.790]   - Field: ‘result’
[10:21:06.790]   - Field: ‘asynchronous’
[10:21:06.790]   - Field: ‘calls’
[10:21:06.791]   - Field: ‘globals’
[10:21:06.791]   - Field: ‘stdout’
[10:21:06.791]   - Field: ‘earlySignal’
[10:21:06.791]   - Field: ‘lazy’
[10:21:06.791]   - Field: ‘state’
[10:21:06.791] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:06.791] - Launch lazy future ...
[10:21:06.792] Packages needed by the future expression (n = 0): <none>
[10:21:06.792] Packages needed by future strategies (n = 0): <none>
[10:21:06.792] {
[10:21:06.792]     {
[10:21:06.792]         {
[10:21:06.792]             ...future.startTime <- base::Sys.time()
[10:21:06.792]             {
[10:21:06.792]                 {
[10:21:06.792]                   {
[10:21:06.792]                     {
[10:21:06.792]                       base::local({
[10:21:06.792]                         has_future <- base::requireNamespace("future", 
[10:21:06.792]                           quietly = TRUE)
[10:21:06.792]                         if (has_future) {
[10:21:06.792]                           ns <- base::getNamespace("future")
[10:21:06.792]                           version <- ns[[".package"]][["version"]]
[10:21:06.792]                           if (is.null(version)) 
[10:21:06.792]                             version <- utils::packageVersion("future")
[10:21:06.792]                         }
[10:21:06.792]                         else {
[10:21:06.792]                           version <- NULL
[10:21:06.792]                         }
[10:21:06.792]                         if (!has_future || version < "1.8.0") {
[10:21:06.792]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.792]                             "", base::R.version$version.string), 
[10:21:06.792]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:06.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.792]                               "release", "version")], collapse = " "), 
[10:21:06.792]                             hostname = base::Sys.info()[["nodename"]])
[10:21:06.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.792]                             info)
[10:21:06.792]                           info <- base::paste(info, collapse = "; ")
[10:21:06.792]                           if (!has_future) {
[10:21:06.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.792]                               info)
[10:21:06.792]                           }
[10:21:06.792]                           else {
[10:21:06.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.792]                               info, version)
[10:21:06.792]                           }
[10:21:06.792]                           base::stop(msg)
[10:21:06.792]                         }
[10:21:06.792]                       })
[10:21:06.792]                     }
[10:21:06.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:06.792]                     base::options(mc.cores = 1L)
[10:21:06.792]                   }
[10:21:06.792]                   ...future.strategy.old <- future::plan("list")
[10:21:06.792]                   options(future.plan = NULL)
[10:21:06.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.792]                 }
[10:21:06.792]                 ...future.workdir <- getwd()
[10:21:06.792]             }
[10:21:06.792]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.792]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.792]         }
[10:21:06.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.792]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.792]             base::names(...future.oldOptions))
[10:21:06.792]     }
[10:21:06.792]     if (FALSE) {
[10:21:06.792]     }
[10:21:06.792]     else {
[10:21:06.792]         if (TRUE) {
[10:21:06.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.792]                 open = "w")
[10:21:06.792]         }
[10:21:06.792]         else {
[10:21:06.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.792]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.792]         }
[10:21:06.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.792]             base::sink(type = "output", split = FALSE)
[10:21:06.792]             base::close(...future.stdout)
[10:21:06.792]         }, add = TRUE)
[10:21:06.792]     }
[10:21:06.792]     ...future.frame <- base::sys.nframe()
[10:21:06.792]     ...future.conditions <- base::list()
[10:21:06.792]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.792]     if (FALSE) {
[10:21:06.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.792]     }
[10:21:06.792]     ...future.result <- base::tryCatch({
[10:21:06.792]         base::withCallingHandlers({
[10:21:06.792]             ...future.value <- base::withVisible(base::local({
[10:21:06.792]                 withCallingHandlers({
[10:21:06.792]                   {
[10:21:06.792]                     42
[10:21:06.792]                   }
[10:21:06.792]                 }, immediateCondition = function(cond) {
[10:21:06.792]                   save_rds <- function (object, pathname, ...) 
[10:21:06.792]                   {
[10:21:06.792]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:06.792]                     if (file_test("-f", pathname_tmp)) {
[10:21:06.792]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.792]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:06.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.792]                         fi_tmp[["mtime"]])
[10:21:06.792]                     }
[10:21:06.792]                     tryCatch({
[10:21:06.792]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:06.792]                     }, error = function(ex) {
[10:21:06.792]                       msg <- conditionMessage(ex)
[10:21:06.792]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.792]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:06.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.792]                         fi_tmp[["mtime"]], msg)
[10:21:06.792]                       ex$message <- msg
[10:21:06.792]                       stop(ex)
[10:21:06.792]                     })
[10:21:06.792]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:06.792]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:06.792]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:06.792]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.792]                       fi <- file.info(pathname)
[10:21:06.792]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:06.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.792]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:06.792]                         fi[["size"]], fi[["mtime"]])
[10:21:06.792]                       stop(msg)
[10:21:06.792]                     }
[10:21:06.792]                     invisible(pathname)
[10:21:06.792]                   }
[10:21:06.792]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:06.792]                     rootPath = tempdir()) 
[10:21:06.792]                   {
[10:21:06.792]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:06.792]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:06.792]                       tmpdir = path, fileext = ".rds")
[10:21:06.792]                     save_rds(obj, file)
[10:21:06.792]                   }
[10:21:06.792]                   saveImmediateCondition(cond, path = "/tmp/RtmpkhXhLs/.future/immediateConditions")
[10:21:06.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.792]                   {
[10:21:06.792]                     inherits <- base::inherits
[10:21:06.792]                     invokeRestart <- base::invokeRestart
[10:21:06.792]                     is.null <- base::is.null
[10:21:06.792]                     muffled <- FALSE
[10:21:06.792]                     if (inherits(cond, "message")) {
[10:21:06.792]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:06.792]                       if (muffled) 
[10:21:06.792]                         invokeRestart("muffleMessage")
[10:21:06.792]                     }
[10:21:06.792]                     else if (inherits(cond, "warning")) {
[10:21:06.792]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:06.792]                       if (muffled) 
[10:21:06.792]                         invokeRestart("muffleWarning")
[10:21:06.792]                     }
[10:21:06.792]                     else if (inherits(cond, "condition")) {
[10:21:06.792]                       if (!is.null(pattern)) {
[10:21:06.792]                         computeRestarts <- base::computeRestarts
[10:21:06.792]                         grepl <- base::grepl
[10:21:06.792]                         restarts <- computeRestarts(cond)
[10:21:06.792]                         for (restart in restarts) {
[10:21:06.792]                           name <- restart$name
[10:21:06.792]                           if (is.null(name)) 
[10:21:06.792]                             next
[10:21:06.792]                           if (!grepl(pattern, name)) 
[10:21:06.792]                             next
[10:21:06.792]                           invokeRestart(restart)
[10:21:06.792]                           muffled <- TRUE
[10:21:06.792]                           break
[10:21:06.792]                         }
[10:21:06.792]                       }
[10:21:06.792]                     }
[10:21:06.792]                     invisible(muffled)
[10:21:06.792]                   }
[10:21:06.792]                   muffleCondition(cond)
[10:21:06.792]                 })
[10:21:06.792]             }))
[10:21:06.792]             future::FutureResult(value = ...future.value$value, 
[10:21:06.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.792]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.792]                     ...future.globalenv.names))
[10:21:06.792]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.792]         }, condition = base::local({
[10:21:06.792]             c <- base::c
[10:21:06.792]             inherits <- base::inherits
[10:21:06.792]             invokeRestart <- base::invokeRestart
[10:21:06.792]             length <- base::length
[10:21:06.792]             list <- base::list
[10:21:06.792]             seq.int <- base::seq.int
[10:21:06.792]             signalCondition <- base::signalCondition
[10:21:06.792]             sys.calls <- base::sys.calls
[10:21:06.792]             `[[` <- base::`[[`
[10:21:06.792]             `+` <- base::`+`
[10:21:06.792]             `<<-` <- base::`<<-`
[10:21:06.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.792]                   3L)]
[10:21:06.792]             }
[10:21:06.792]             function(cond) {
[10:21:06.792]                 is_error <- inherits(cond, "error")
[10:21:06.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.792]                   NULL)
[10:21:06.792]                 if (is_error) {
[10:21:06.792]                   sessionInformation <- function() {
[10:21:06.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.792]                       search = base::search(), system = base::Sys.info())
[10:21:06.792]                   }
[10:21:06.792]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.792]                     cond$call), session = sessionInformation(), 
[10:21:06.792]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.792]                   signalCondition(cond)
[10:21:06.792]                 }
[10:21:06.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.792]                 "immediateCondition"))) {
[10:21:06.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.792]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.792]                   if (TRUE && !signal) {
[10:21:06.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.792]                     {
[10:21:06.792]                       inherits <- base::inherits
[10:21:06.792]                       invokeRestart <- base::invokeRestart
[10:21:06.792]                       is.null <- base::is.null
[10:21:06.792]                       muffled <- FALSE
[10:21:06.792]                       if (inherits(cond, "message")) {
[10:21:06.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.792]                         if (muffled) 
[10:21:06.792]                           invokeRestart("muffleMessage")
[10:21:06.792]                       }
[10:21:06.792]                       else if (inherits(cond, "warning")) {
[10:21:06.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.792]                         if (muffled) 
[10:21:06.792]                           invokeRestart("muffleWarning")
[10:21:06.792]                       }
[10:21:06.792]                       else if (inherits(cond, "condition")) {
[10:21:06.792]                         if (!is.null(pattern)) {
[10:21:06.792]                           computeRestarts <- base::computeRestarts
[10:21:06.792]                           grepl <- base::grepl
[10:21:06.792]                           restarts <- computeRestarts(cond)
[10:21:06.792]                           for (restart in restarts) {
[10:21:06.792]                             name <- restart$name
[10:21:06.792]                             if (is.null(name)) 
[10:21:06.792]                               next
[10:21:06.792]                             if (!grepl(pattern, name)) 
[10:21:06.792]                               next
[10:21:06.792]                             invokeRestart(restart)
[10:21:06.792]                             muffled <- TRUE
[10:21:06.792]                             break
[10:21:06.792]                           }
[10:21:06.792]                         }
[10:21:06.792]                       }
[10:21:06.792]                       invisible(muffled)
[10:21:06.792]                     }
[10:21:06.792]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.792]                   }
[10:21:06.792]                 }
[10:21:06.792]                 else {
[10:21:06.792]                   if (TRUE) {
[10:21:06.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.792]                     {
[10:21:06.792]                       inherits <- base::inherits
[10:21:06.792]                       invokeRestart <- base::invokeRestart
[10:21:06.792]                       is.null <- base::is.null
[10:21:06.792]                       muffled <- FALSE
[10:21:06.792]                       if (inherits(cond, "message")) {
[10:21:06.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.792]                         if (muffled) 
[10:21:06.792]                           invokeRestart("muffleMessage")
[10:21:06.792]                       }
[10:21:06.792]                       else if (inherits(cond, "warning")) {
[10:21:06.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.792]                         if (muffled) 
[10:21:06.792]                           invokeRestart("muffleWarning")
[10:21:06.792]                       }
[10:21:06.792]                       else if (inherits(cond, "condition")) {
[10:21:06.792]                         if (!is.null(pattern)) {
[10:21:06.792]                           computeRestarts <- base::computeRestarts
[10:21:06.792]                           grepl <- base::grepl
[10:21:06.792]                           restarts <- computeRestarts(cond)
[10:21:06.792]                           for (restart in restarts) {
[10:21:06.792]                             name <- restart$name
[10:21:06.792]                             if (is.null(name)) 
[10:21:06.792]                               next
[10:21:06.792]                             if (!grepl(pattern, name)) 
[10:21:06.792]                               next
[10:21:06.792]                             invokeRestart(restart)
[10:21:06.792]                             muffled <- TRUE
[10:21:06.792]                             break
[10:21:06.792]                           }
[10:21:06.792]                         }
[10:21:06.792]                       }
[10:21:06.792]                       invisible(muffled)
[10:21:06.792]                     }
[10:21:06.792]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.792]                   }
[10:21:06.792]                 }
[10:21:06.792]             }
[10:21:06.792]         }))
[10:21:06.792]     }, error = function(ex) {
[10:21:06.792]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.792]                 ...future.rng), started = ...future.startTime, 
[10:21:06.792]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.792]             version = "1.8"), class = "FutureResult")
[10:21:06.792]     }, finally = {
[10:21:06.792]         if (!identical(...future.workdir, getwd())) 
[10:21:06.792]             setwd(...future.workdir)
[10:21:06.792]         {
[10:21:06.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.792]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.792]             }
[10:21:06.792]             base::options(...future.oldOptions)
[10:21:06.792]             if (.Platform$OS.type == "windows") {
[10:21:06.792]                 old_names <- names(...future.oldEnvVars)
[10:21:06.792]                 envs <- base::Sys.getenv()
[10:21:06.792]                 names <- names(envs)
[10:21:06.792]                 common <- intersect(names, old_names)
[10:21:06.792]                 added <- setdiff(names, old_names)
[10:21:06.792]                 removed <- setdiff(old_names, names)
[10:21:06.792]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.792]                   envs[common]]
[10:21:06.792]                 NAMES <- toupper(changed)
[10:21:06.792]                 args <- list()
[10:21:06.792]                 for (kk in seq_along(NAMES)) {
[10:21:06.792]                   name <- changed[[kk]]
[10:21:06.792]                   NAME <- NAMES[[kk]]
[10:21:06.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.792]                     next
[10:21:06.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.792]                 }
[10:21:06.792]                 NAMES <- toupper(added)
[10:21:06.792]                 for (kk in seq_along(NAMES)) {
[10:21:06.792]                   name <- added[[kk]]
[10:21:06.792]                   NAME <- NAMES[[kk]]
[10:21:06.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.792]                     next
[10:21:06.792]                   args[[name]] <- ""
[10:21:06.792]                 }
[10:21:06.792]                 NAMES <- toupper(removed)
[10:21:06.792]                 for (kk in seq_along(NAMES)) {
[10:21:06.792]                   name <- removed[[kk]]
[10:21:06.792]                   NAME <- NAMES[[kk]]
[10:21:06.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.792]                     next
[10:21:06.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.792]                 }
[10:21:06.792]                 if (length(args) > 0) 
[10:21:06.792]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.792]             }
[10:21:06.792]             else {
[10:21:06.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.792]             }
[10:21:06.792]             {
[10:21:06.792]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.792]                   0L) {
[10:21:06.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.792]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.792]                   base::options(opts)
[10:21:06.792]                 }
[10:21:06.792]                 {
[10:21:06.792]                   {
[10:21:06.792]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:06.792]                     NULL
[10:21:06.792]                   }
[10:21:06.792]                   options(future.plan = NULL)
[10:21:06.792]                   if (is.na(NA_character_)) 
[10:21:06.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.792]                     .init = FALSE)
[10:21:06.792]                 }
[10:21:06.792]             }
[10:21:06.792]         }
[10:21:06.792]     })
[10:21:06.792]     if (TRUE) {
[10:21:06.792]         base::sink(type = "output", split = FALSE)
[10:21:06.792]         if (TRUE) {
[10:21:06.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.792]         }
[10:21:06.792]         else {
[10:21:06.792]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.792]         }
[10:21:06.792]         base::close(...future.stdout)
[10:21:06.792]         ...future.stdout <- NULL
[10:21:06.792]     }
[10:21:06.792]     ...future.result$conditions <- ...future.conditions
[10:21:06.792]     ...future.result$finished <- base::Sys.time()
[10:21:06.792]     ...future.result
[10:21:06.792] }
[10:21:06.795] requestCore(): workers = 2
[10:21:06.797] MulticoreFuture started
[10:21:06.797] - Launch lazy future ... done
[10:21:06.797] run() for ‘MulticoreFuture’ ... done
[10:21:06.798] plan(): Setting new future strategy stack:
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:21:06.798] List of future strategies:
[10:21:06.798] 1. sequential:
[10:21:06.798]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.798]    - tweaked: FALSE
[10:21:06.798]    - call: NULL
[10:21:06.799] plan(): nbrOfWorkers() = 1
[10:21:06.801] plan(): Setting new future strategy stack:
[10:21:06.801] List of future strategies:
[10:21:06.801] 1. multicore:
[10:21:06.801]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:06.801]    - tweaked: FALSE
[10:21:06.801]    - call: plan(strategy)
[10:21:06.804] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.805] result() for MulticoreFuture ...
[10:21:06.806] result() for MulticoreFuture ...
[10:21:06.806] result() for MulticoreFuture ... done
[10:21:06.806] result() for MulticoreFuture ... done
[10:21:06.806] result() for MulticoreFuture ...
[10:21:06.806] result() for MulticoreFuture ... done
[10:21:06.808] getGlobalsAndPackages() ...
[10:21:06.808] 
[10:21:06.808] - globals: [0] <none>
[10:21:06.809] getGlobalsAndPackages() ... DONE
[10:21:06.809] Packages needed by the future expression (n = 0): <none>
[10:21:06.809] Packages needed by future strategies (n = 0): <none>
[10:21:06.810] {
[10:21:06.810]     {
[10:21:06.810]         {
[10:21:06.810]             ...future.startTime <- base::Sys.time()
[10:21:06.810]             {
[10:21:06.810]                 {
[10:21:06.810]                   {
[10:21:06.810]                     {
[10:21:06.810]                       base::local({
[10:21:06.810]                         has_future <- base::requireNamespace("future", 
[10:21:06.810]                           quietly = TRUE)
[10:21:06.810]                         if (has_future) {
[10:21:06.810]                           ns <- base::getNamespace("future")
[10:21:06.810]                           version <- ns[[".package"]][["version"]]
[10:21:06.810]                           if (is.null(version)) 
[10:21:06.810]                             version <- utils::packageVersion("future")
[10:21:06.810]                         }
[10:21:06.810]                         else {
[10:21:06.810]                           version <- NULL
[10:21:06.810]                         }
[10:21:06.810]                         if (!has_future || version < "1.8.0") {
[10:21:06.810]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.810]                             "", base::R.version$version.string), 
[10:21:06.810]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:06.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.810]                               "release", "version")], collapse = " "), 
[10:21:06.810]                             hostname = base::Sys.info()[["nodename"]])
[10:21:06.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.810]                             info)
[10:21:06.810]                           info <- base::paste(info, collapse = "; ")
[10:21:06.810]                           if (!has_future) {
[10:21:06.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.810]                               info)
[10:21:06.810]                           }
[10:21:06.810]                           else {
[10:21:06.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.810]                               info, version)
[10:21:06.810]                           }
[10:21:06.810]                           base::stop(msg)
[10:21:06.810]                         }
[10:21:06.810]                       })
[10:21:06.810]                     }
[10:21:06.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:06.810]                     base::options(mc.cores = 1L)
[10:21:06.810]                   }
[10:21:06.810]                   ...future.strategy.old <- future::plan("list")
[10:21:06.810]                   options(future.plan = NULL)
[10:21:06.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.810]                 }
[10:21:06.810]                 ...future.workdir <- getwd()
[10:21:06.810]             }
[10:21:06.810]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.810]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.810]         }
[10:21:06.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.810]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.810]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.810]             base::names(...future.oldOptions))
[10:21:06.810]     }
[10:21:06.810]     if (FALSE) {
[10:21:06.810]     }
[10:21:06.810]     else {
[10:21:06.810]         if (TRUE) {
[10:21:06.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.810]                 open = "w")
[10:21:06.810]         }
[10:21:06.810]         else {
[10:21:06.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.810]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.810]         }
[10:21:06.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.810]             base::sink(type = "output", split = FALSE)
[10:21:06.810]             base::close(...future.stdout)
[10:21:06.810]         }, add = TRUE)
[10:21:06.810]     }
[10:21:06.810]     ...future.frame <- base::sys.nframe()
[10:21:06.810]     ...future.conditions <- base::list()
[10:21:06.810]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.810]     if (FALSE) {
[10:21:06.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.810]     }
[10:21:06.810]     ...future.result <- base::tryCatch({
[10:21:06.810]         base::withCallingHandlers({
[10:21:06.810]             ...future.value <- base::withVisible(base::local({
[10:21:06.810]                 withCallingHandlers({
[10:21:06.810]                   42
[10:21:06.810]                 }, immediateCondition = function(cond) {
[10:21:06.810]                   save_rds <- function (object, pathname, ...) 
[10:21:06.810]                   {
[10:21:06.810]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:06.810]                     if (file_test("-f", pathname_tmp)) {
[10:21:06.810]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.810]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:06.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.810]                         fi_tmp[["mtime"]])
[10:21:06.810]                     }
[10:21:06.810]                     tryCatch({
[10:21:06.810]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:06.810]                     }, error = function(ex) {
[10:21:06.810]                       msg <- conditionMessage(ex)
[10:21:06.810]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.810]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:06.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.810]                         fi_tmp[["mtime"]], msg)
[10:21:06.810]                       ex$message <- msg
[10:21:06.810]                       stop(ex)
[10:21:06.810]                     })
[10:21:06.810]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:06.810]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:06.810]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:06.810]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.810]                       fi <- file.info(pathname)
[10:21:06.810]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:06.810]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.810]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:06.810]                         fi[["size"]], fi[["mtime"]])
[10:21:06.810]                       stop(msg)
[10:21:06.810]                     }
[10:21:06.810]                     invisible(pathname)
[10:21:06.810]                   }
[10:21:06.810]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:06.810]                     rootPath = tempdir()) 
[10:21:06.810]                   {
[10:21:06.810]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:06.810]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:06.810]                       tmpdir = path, fileext = ".rds")
[10:21:06.810]                     save_rds(obj, file)
[10:21:06.810]                   }
[10:21:06.810]                   saveImmediateCondition(cond, path = "/tmp/RtmpkhXhLs/.future/immediateConditions")
[10:21:06.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.810]                   {
[10:21:06.810]                     inherits <- base::inherits
[10:21:06.810]                     invokeRestart <- base::invokeRestart
[10:21:06.810]                     is.null <- base::is.null
[10:21:06.810]                     muffled <- FALSE
[10:21:06.810]                     if (inherits(cond, "message")) {
[10:21:06.810]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:06.810]                       if (muffled) 
[10:21:06.810]                         invokeRestart("muffleMessage")
[10:21:06.810]                     }
[10:21:06.810]                     else if (inherits(cond, "warning")) {
[10:21:06.810]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:06.810]                       if (muffled) 
[10:21:06.810]                         invokeRestart("muffleWarning")
[10:21:06.810]                     }
[10:21:06.810]                     else if (inherits(cond, "condition")) {
[10:21:06.810]                       if (!is.null(pattern)) {
[10:21:06.810]                         computeRestarts <- base::computeRestarts
[10:21:06.810]                         grepl <- base::grepl
[10:21:06.810]                         restarts <- computeRestarts(cond)
[10:21:06.810]                         for (restart in restarts) {
[10:21:06.810]                           name <- restart$name
[10:21:06.810]                           if (is.null(name)) 
[10:21:06.810]                             next
[10:21:06.810]                           if (!grepl(pattern, name)) 
[10:21:06.810]                             next
[10:21:06.810]                           invokeRestart(restart)
[10:21:06.810]                           muffled <- TRUE
[10:21:06.810]                           break
[10:21:06.810]                         }
[10:21:06.810]                       }
[10:21:06.810]                     }
[10:21:06.810]                     invisible(muffled)
[10:21:06.810]                   }
[10:21:06.810]                   muffleCondition(cond)
[10:21:06.810]                 })
[10:21:06.810]             }))
[10:21:06.810]             future::FutureResult(value = ...future.value$value, 
[10:21:06.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.810]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.810]                     ...future.globalenv.names))
[10:21:06.810]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.810]         }, condition = base::local({
[10:21:06.810]             c <- base::c
[10:21:06.810]             inherits <- base::inherits
[10:21:06.810]             invokeRestart <- base::invokeRestart
[10:21:06.810]             length <- base::length
[10:21:06.810]             list <- base::list
[10:21:06.810]             seq.int <- base::seq.int
[10:21:06.810]             signalCondition <- base::signalCondition
[10:21:06.810]             sys.calls <- base::sys.calls
[10:21:06.810]             `[[` <- base::`[[`
[10:21:06.810]             `+` <- base::`+`
[10:21:06.810]             `<<-` <- base::`<<-`
[10:21:06.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.810]                   3L)]
[10:21:06.810]             }
[10:21:06.810]             function(cond) {
[10:21:06.810]                 is_error <- inherits(cond, "error")
[10:21:06.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.810]                   NULL)
[10:21:06.810]                 if (is_error) {
[10:21:06.810]                   sessionInformation <- function() {
[10:21:06.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.810]                       search = base::search(), system = base::Sys.info())
[10:21:06.810]                   }
[10:21:06.810]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.810]                     cond$call), session = sessionInformation(), 
[10:21:06.810]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.810]                   signalCondition(cond)
[10:21:06.810]                 }
[10:21:06.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.810]                 "immediateCondition"))) {
[10:21:06.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.810]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.810]                   if (TRUE && !signal) {
[10:21:06.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.810]                     {
[10:21:06.810]                       inherits <- base::inherits
[10:21:06.810]                       invokeRestart <- base::invokeRestart
[10:21:06.810]                       is.null <- base::is.null
[10:21:06.810]                       muffled <- FALSE
[10:21:06.810]                       if (inherits(cond, "message")) {
[10:21:06.810]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.810]                         if (muffled) 
[10:21:06.810]                           invokeRestart("muffleMessage")
[10:21:06.810]                       }
[10:21:06.810]                       else if (inherits(cond, "warning")) {
[10:21:06.810]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.810]                         if (muffled) 
[10:21:06.810]                           invokeRestart("muffleWarning")
[10:21:06.810]                       }
[10:21:06.810]                       else if (inherits(cond, "condition")) {
[10:21:06.810]                         if (!is.null(pattern)) {
[10:21:06.810]                           computeRestarts <- base::computeRestarts
[10:21:06.810]                           grepl <- base::grepl
[10:21:06.810]                           restarts <- computeRestarts(cond)
[10:21:06.810]                           for (restart in restarts) {
[10:21:06.810]                             name <- restart$name
[10:21:06.810]                             if (is.null(name)) 
[10:21:06.810]                               next
[10:21:06.810]                             if (!grepl(pattern, name)) 
[10:21:06.810]                               next
[10:21:06.810]                             invokeRestart(restart)
[10:21:06.810]                             muffled <- TRUE
[10:21:06.810]                             break
[10:21:06.810]                           }
[10:21:06.810]                         }
[10:21:06.810]                       }
[10:21:06.810]                       invisible(muffled)
[10:21:06.810]                     }
[10:21:06.810]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.810]                   }
[10:21:06.810]                 }
[10:21:06.810]                 else {
[10:21:06.810]                   if (TRUE) {
[10:21:06.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.810]                     {
[10:21:06.810]                       inherits <- base::inherits
[10:21:06.810]                       invokeRestart <- base::invokeRestart
[10:21:06.810]                       is.null <- base::is.null
[10:21:06.810]                       muffled <- FALSE
[10:21:06.810]                       if (inherits(cond, "message")) {
[10:21:06.810]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.810]                         if (muffled) 
[10:21:06.810]                           invokeRestart("muffleMessage")
[10:21:06.810]                       }
[10:21:06.810]                       else if (inherits(cond, "warning")) {
[10:21:06.810]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.810]                         if (muffled) 
[10:21:06.810]                           invokeRestart("muffleWarning")
[10:21:06.810]                       }
[10:21:06.810]                       else if (inherits(cond, "condition")) {
[10:21:06.810]                         if (!is.null(pattern)) {
[10:21:06.810]                           computeRestarts <- base::computeRestarts
[10:21:06.810]                           grepl <- base::grepl
[10:21:06.810]                           restarts <- computeRestarts(cond)
[10:21:06.810]                           for (restart in restarts) {
[10:21:06.810]                             name <- restart$name
[10:21:06.810]                             if (is.null(name)) 
[10:21:06.810]                               next
[10:21:06.810]                             if (!grepl(pattern, name)) 
[10:21:06.810]                               next
[10:21:06.810]                             invokeRestart(restart)
[10:21:06.810]                             muffled <- TRUE
[10:21:06.810]                             break
[10:21:06.810]                           }
[10:21:06.810]                         }
[10:21:06.810]                       }
[10:21:06.810]                       invisible(muffled)
[10:21:06.810]                     }
[10:21:06.810]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.810]                   }
[10:21:06.810]                 }
[10:21:06.810]             }
[10:21:06.810]         }))
[10:21:06.810]     }, error = function(ex) {
[10:21:06.810]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.810]                 ...future.rng), started = ...future.startTime, 
[10:21:06.810]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.810]             version = "1.8"), class = "FutureResult")
[10:21:06.810]     }, finally = {
[10:21:06.810]         if (!identical(...future.workdir, getwd())) 
[10:21:06.810]             setwd(...future.workdir)
[10:21:06.810]         {
[10:21:06.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.810]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.810]             }
[10:21:06.810]             base::options(...future.oldOptions)
[10:21:06.810]             if (.Platform$OS.type == "windows") {
[10:21:06.810]                 old_names <- names(...future.oldEnvVars)
[10:21:06.810]                 envs <- base::Sys.getenv()
[10:21:06.810]                 names <- names(envs)
[10:21:06.810]                 common <- intersect(names, old_names)
[10:21:06.810]                 added <- setdiff(names, old_names)
[10:21:06.810]                 removed <- setdiff(old_names, names)
[10:21:06.810]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.810]                   envs[common]]
[10:21:06.810]                 NAMES <- toupper(changed)
[10:21:06.810]                 args <- list()
[10:21:06.810]                 for (kk in seq_along(NAMES)) {
[10:21:06.810]                   name <- changed[[kk]]
[10:21:06.810]                   NAME <- NAMES[[kk]]
[10:21:06.810]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.810]                     next
[10:21:06.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.810]                 }
[10:21:06.810]                 NAMES <- toupper(added)
[10:21:06.810]                 for (kk in seq_along(NAMES)) {
[10:21:06.810]                   name <- added[[kk]]
[10:21:06.810]                   NAME <- NAMES[[kk]]
[10:21:06.810]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.810]                     next
[10:21:06.810]                   args[[name]] <- ""
[10:21:06.810]                 }
[10:21:06.810]                 NAMES <- toupper(removed)
[10:21:06.810]                 for (kk in seq_along(NAMES)) {
[10:21:06.810]                   name <- removed[[kk]]
[10:21:06.810]                   NAME <- NAMES[[kk]]
[10:21:06.810]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.810]                     next
[10:21:06.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.810]                 }
[10:21:06.810]                 if (length(args) > 0) 
[10:21:06.810]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.810]             }
[10:21:06.810]             else {
[10:21:06.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.810]             }
[10:21:06.810]             {
[10:21:06.810]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.810]                   0L) {
[10:21:06.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.810]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.810]                   base::options(opts)
[10:21:06.810]                 }
[10:21:06.810]                 {
[10:21:06.810]                   {
[10:21:06.810]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:06.810]                     NULL
[10:21:06.810]                   }
[10:21:06.810]                   options(future.plan = NULL)
[10:21:06.810]                   if (is.na(NA_character_)) 
[10:21:06.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.810]                     .init = FALSE)
[10:21:06.810]                 }
[10:21:06.810]             }
[10:21:06.810]         }
[10:21:06.810]     })
[10:21:06.810]     if (TRUE) {
[10:21:06.810]         base::sink(type = "output", split = FALSE)
[10:21:06.810]         if (TRUE) {
[10:21:06.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.810]         }
[10:21:06.810]         else {
[10:21:06.810]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.810]         }
[10:21:06.810]         base::close(...future.stdout)
[10:21:06.810]         ...future.stdout <- NULL
[10:21:06.810]     }
[10:21:06.810]     ...future.result$conditions <- ...future.conditions
[10:21:06.810]     ...future.result$finished <- base::Sys.time()
[10:21:06.810]     ...future.result
[10:21:06.810] }
[10:21:06.813] requestCore(): workers = 2
[10:21:06.814] MulticoreFuture started
MulticoreFuture:
Label: ‘strategy = multicore’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:21:06.815] plan(): Setting new future strategy stack:
[10:21:06.815] List of future strategies:
[10:21:06.815] 1. sequential:
[10:21:06.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.815]    - tweaked: FALSE
[10:21:06.815]    - call: NULL
[10:21:06.816] plan(): nbrOfWorkers() = 1
[10:21:06.818] plan(): Setting new future strategy stack:
[10:21:06.819] List of future strategies:
[10:21:06.819] 1. multicore:
[10:21:06.819]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:06.819]    - tweaked: FALSE
[10:21:06.819]    - call: plan(strategy)
[10:21:06.822] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.822] result() for MulticoreFuture ...
[10:21:06.823] result() for MulticoreFuture ...
[10:21:06.823] result() for MulticoreFuture ... done
[10:21:06.824] result() for MulticoreFuture ... done
[10:21:06.824] result() for MulticoreFuture ...
[10:21:06.824] result() for MulticoreFuture ... done
[10:21:06.824] getGlobalsAndPackages() ...
[10:21:06.824] Searching for globals...
[10:21:06.825] 
[10:21:06.825] Searching for globals ... DONE
[10:21:06.825] - globals: [0] <none>
[10:21:06.825] getGlobalsAndPackages() ... DONE
[10:21:06.825] run() for ‘Future’ ...
[10:21:06.826] - state: ‘created’
[10:21:06.826] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:06.828] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.828] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:06.828]   - Field: ‘label’
[10:21:06.828]   - Field: ‘local’
[10:21:06.828]   - Field: ‘owner’
[10:21:06.829]   - Field: ‘envir’
[10:21:06.829]   - Field: ‘workers’
[10:21:06.829]   - Field: ‘packages’
[10:21:06.829]   - Field: ‘gc’
[10:21:06.829]   - Field: ‘job’
[10:21:06.829]   - Field: ‘conditions’
[10:21:06.829]   - Field: ‘expr’
[10:21:06.829]   - Field: ‘uuid’
[10:21:06.829]   - Field: ‘seed’
[10:21:06.829]   - Field: ‘version’
[10:21:06.830]   - Field: ‘result’
[10:21:06.830]   - Field: ‘asynchronous’
[10:21:06.830]   - Field: ‘calls’
[10:21:06.830]   - Field: ‘globals’
[10:21:06.830]   - Field: ‘stdout’
[10:21:06.830]   - Field: ‘earlySignal’
[10:21:06.830]   - Field: ‘lazy’
[10:21:06.830]   - Field: ‘state’
[10:21:06.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:06.831] - Launch lazy future ...
[10:21:06.831] Packages needed by the future expression (n = 0): <none>
[10:21:06.831] Packages needed by future strategies (n = 0): <none>
[10:21:06.832] {
[10:21:06.832]     {
[10:21:06.832]         {
[10:21:06.832]             ...future.startTime <- base::Sys.time()
[10:21:06.832]             {
[10:21:06.832]                 {
[10:21:06.832]                   {
[10:21:06.832]                     {
[10:21:06.832]                       base::local({
[10:21:06.832]                         has_future <- base::requireNamespace("future", 
[10:21:06.832]                           quietly = TRUE)
[10:21:06.832]                         if (has_future) {
[10:21:06.832]                           ns <- base::getNamespace("future")
[10:21:06.832]                           version <- ns[[".package"]][["version"]]
[10:21:06.832]                           if (is.null(version)) 
[10:21:06.832]                             version <- utils::packageVersion("future")
[10:21:06.832]                         }
[10:21:06.832]                         else {
[10:21:06.832]                           version <- NULL
[10:21:06.832]                         }
[10:21:06.832]                         if (!has_future || version < "1.8.0") {
[10:21:06.832]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.832]                             "", base::R.version$version.string), 
[10:21:06.832]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:06.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.832]                               "release", "version")], collapse = " "), 
[10:21:06.832]                             hostname = base::Sys.info()[["nodename"]])
[10:21:06.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.832]                             info)
[10:21:06.832]                           info <- base::paste(info, collapse = "; ")
[10:21:06.832]                           if (!has_future) {
[10:21:06.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.832]                               info)
[10:21:06.832]                           }
[10:21:06.832]                           else {
[10:21:06.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.832]                               info, version)
[10:21:06.832]                           }
[10:21:06.832]                           base::stop(msg)
[10:21:06.832]                         }
[10:21:06.832]                       })
[10:21:06.832]                     }
[10:21:06.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:06.832]                     base::options(mc.cores = 1L)
[10:21:06.832]                   }
[10:21:06.832]                   ...future.strategy.old <- future::plan("list")
[10:21:06.832]                   options(future.plan = NULL)
[10:21:06.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.832]                 }
[10:21:06.832]                 ...future.workdir <- getwd()
[10:21:06.832]             }
[10:21:06.832]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.832]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.832]         }
[10:21:06.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.832]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.832]             base::names(...future.oldOptions))
[10:21:06.832]     }
[10:21:06.832]     if (FALSE) {
[10:21:06.832]     }
[10:21:06.832]     else {
[10:21:06.832]         if (TRUE) {
[10:21:06.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.832]                 open = "w")
[10:21:06.832]         }
[10:21:06.832]         else {
[10:21:06.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.832]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.832]         }
[10:21:06.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.832]             base::sink(type = "output", split = FALSE)
[10:21:06.832]             base::close(...future.stdout)
[10:21:06.832]         }, add = TRUE)
[10:21:06.832]     }
[10:21:06.832]     ...future.frame <- base::sys.nframe()
[10:21:06.832]     ...future.conditions <- base::list()
[10:21:06.832]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.832]     if (FALSE) {
[10:21:06.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.832]     }
[10:21:06.832]     ...future.result <- base::tryCatch({
[10:21:06.832]         base::withCallingHandlers({
[10:21:06.832]             ...future.value <- base::withVisible(base::local({
[10:21:06.832]                 withCallingHandlers({
[10:21:06.832]                   42
[10:21:06.832]                 }, immediateCondition = function(cond) {
[10:21:06.832]                   save_rds <- function (object, pathname, ...) 
[10:21:06.832]                   {
[10:21:06.832]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:06.832]                     if (file_test("-f", pathname_tmp)) {
[10:21:06.832]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.832]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:06.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.832]                         fi_tmp[["mtime"]])
[10:21:06.832]                     }
[10:21:06.832]                     tryCatch({
[10:21:06.832]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:06.832]                     }, error = function(ex) {
[10:21:06.832]                       msg <- conditionMessage(ex)
[10:21:06.832]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.832]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:06.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.832]                         fi_tmp[["mtime"]], msg)
[10:21:06.832]                       ex$message <- msg
[10:21:06.832]                       stop(ex)
[10:21:06.832]                     })
[10:21:06.832]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:06.832]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:06.832]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:06.832]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.832]                       fi <- file.info(pathname)
[10:21:06.832]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:06.832]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.832]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:06.832]                         fi[["size"]], fi[["mtime"]])
[10:21:06.832]                       stop(msg)
[10:21:06.832]                     }
[10:21:06.832]                     invisible(pathname)
[10:21:06.832]                   }
[10:21:06.832]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:06.832]                     rootPath = tempdir()) 
[10:21:06.832]                   {
[10:21:06.832]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:06.832]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:06.832]                       tmpdir = path, fileext = ".rds")
[10:21:06.832]                     save_rds(obj, file)
[10:21:06.832]                   }
[10:21:06.832]                   saveImmediateCondition(cond, path = "/tmp/RtmpkhXhLs/.future/immediateConditions")
[10:21:06.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.832]                   {
[10:21:06.832]                     inherits <- base::inherits
[10:21:06.832]                     invokeRestart <- base::invokeRestart
[10:21:06.832]                     is.null <- base::is.null
[10:21:06.832]                     muffled <- FALSE
[10:21:06.832]                     if (inherits(cond, "message")) {
[10:21:06.832]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:06.832]                       if (muffled) 
[10:21:06.832]                         invokeRestart("muffleMessage")
[10:21:06.832]                     }
[10:21:06.832]                     else if (inherits(cond, "warning")) {
[10:21:06.832]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:06.832]                       if (muffled) 
[10:21:06.832]                         invokeRestart("muffleWarning")
[10:21:06.832]                     }
[10:21:06.832]                     else if (inherits(cond, "condition")) {
[10:21:06.832]                       if (!is.null(pattern)) {
[10:21:06.832]                         computeRestarts <- base::computeRestarts
[10:21:06.832]                         grepl <- base::grepl
[10:21:06.832]                         restarts <- computeRestarts(cond)
[10:21:06.832]                         for (restart in restarts) {
[10:21:06.832]                           name <- restart$name
[10:21:06.832]                           if (is.null(name)) 
[10:21:06.832]                             next
[10:21:06.832]                           if (!grepl(pattern, name)) 
[10:21:06.832]                             next
[10:21:06.832]                           invokeRestart(restart)
[10:21:06.832]                           muffled <- TRUE
[10:21:06.832]                           break
[10:21:06.832]                         }
[10:21:06.832]                       }
[10:21:06.832]                     }
[10:21:06.832]                     invisible(muffled)
[10:21:06.832]                   }
[10:21:06.832]                   muffleCondition(cond)
[10:21:06.832]                 })
[10:21:06.832]             }))
[10:21:06.832]             future::FutureResult(value = ...future.value$value, 
[10:21:06.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.832]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.832]                     ...future.globalenv.names))
[10:21:06.832]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.832]         }, condition = base::local({
[10:21:06.832]             c <- base::c
[10:21:06.832]             inherits <- base::inherits
[10:21:06.832]             invokeRestart <- base::invokeRestart
[10:21:06.832]             length <- base::length
[10:21:06.832]             list <- base::list
[10:21:06.832]             seq.int <- base::seq.int
[10:21:06.832]             signalCondition <- base::signalCondition
[10:21:06.832]             sys.calls <- base::sys.calls
[10:21:06.832]             `[[` <- base::`[[`
[10:21:06.832]             `+` <- base::`+`
[10:21:06.832]             `<<-` <- base::`<<-`
[10:21:06.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.832]                   3L)]
[10:21:06.832]             }
[10:21:06.832]             function(cond) {
[10:21:06.832]                 is_error <- inherits(cond, "error")
[10:21:06.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.832]                   NULL)
[10:21:06.832]                 if (is_error) {
[10:21:06.832]                   sessionInformation <- function() {
[10:21:06.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.832]                       search = base::search(), system = base::Sys.info())
[10:21:06.832]                   }
[10:21:06.832]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.832]                     cond$call), session = sessionInformation(), 
[10:21:06.832]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.832]                   signalCondition(cond)
[10:21:06.832]                 }
[10:21:06.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.832]                 "immediateCondition"))) {
[10:21:06.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.832]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.832]                   if (TRUE && !signal) {
[10:21:06.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.832]                     {
[10:21:06.832]                       inherits <- base::inherits
[10:21:06.832]                       invokeRestart <- base::invokeRestart
[10:21:06.832]                       is.null <- base::is.null
[10:21:06.832]                       muffled <- FALSE
[10:21:06.832]                       if (inherits(cond, "message")) {
[10:21:06.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.832]                         if (muffled) 
[10:21:06.832]                           invokeRestart("muffleMessage")
[10:21:06.832]                       }
[10:21:06.832]                       else if (inherits(cond, "warning")) {
[10:21:06.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.832]                         if (muffled) 
[10:21:06.832]                           invokeRestart("muffleWarning")
[10:21:06.832]                       }
[10:21:06.832]                       else if (inherits(cond, "condition")) {
[10:21:06.832]                         if (!is.null(pattern)) {
[10:21:06.832]                           computeRestarts <- base::computeRestarts
[10:21:06.832]                           grepl <- base::grepl
[10:21:06.832]                           restarts <- computeRestarts(cond)
[10:21:06.832]                           for (restart in restarts) {
[10:21:06.832]                             name <- restart$name
[10:21:06.832]                             if (is.null(name)) 
[10:21:06.832]                               next
[10:21:06.832]                             if (!grepl(pattern, name)) 
[10:21:06.832]                               next
[10:21:06.832]                             invokeRestart(restart)
[10:21:06.832]                             muffled <- TRUE
[10:21:06.832]                             break
[10:21:06.832]                           }
[10:21:06.832]                         }
[10:21:06.832]                       }
[10:21:06.832]                       invisible(muffled)
[10:21:06.832]                     }
[10:21:06.832]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.832]                   }
[10:21:06.832]                 }
[10:21:06.832]                 else {
[10:21:06.832]                   if (TRUE) {
[10:21:06.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.832]                     {
[10:21:06.832]                       inherits <- base::inherits
[10:21:06.832]                       invokeRestart <- base::invokeRestart
[10:21:06.832]                       is.null <- base::is.null
[10:21:06.832]                       muffled <- FALSE
[10:21:06.832]                       if (inherits(cond, "message")) {
[10:21:06.832]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.832]                         if (muffled) 
[10:21:06.832]                           invokeRestart("muffleMessage")
[10:21:06.832]                       }
[10:21:06.832]                       else if (inherits(cond, "warning")) {
[10:21:06.832]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.832]                         if (muffled) 
[10:21:06.832]                           invokeRestart("muffleWarning")
[10:21:06.832]                       }
[10:21:06.832]                       else if (inherits(cond, "condition")) {
[10:21:06.832]                         if (!is.null(pattern)) {
[10:21:06.832]                           computeRestarts <- base::computeRestarts
[10:21:06.832]                           grepl <- base::grepl
[10:21:06.832]                           restarts <- computeRestarts(cond)
[10:21:06.832]                           for (restart in restarts) {
[10:21:06.832]                             name <- restart$name
[10:21:06.832]                             if (is.null(name)) 
[10:21:06.832]                               next
[10:21:06.832]                             if (!grepl(pattern, name)) 
[10:21:06.832]                               next
[10:21:06.832]                             invokeRestart(restart)
[10:21:06.832]                             muffled <- TRUE
[10:21:06.832]                             break
[10:21:06.832]                           }
[10:21:06.832]                         }
[10:21:06.832]                       }
[10:21:06.832]                       invisible(muffled)
[10:21:06.832]                     }
[10:21:06.832]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.832]                   }
[10:21:06.832]                 }
[10:21:06.832]             }
[10:21:06.832]         }))
[10:21:06.832]     }, error = function(ex) {
[10:21:06.832]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.832]                 ...future.rng), started = ...future.startTime, 
[10:21:06.832]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.832]             version = "1.8"), class = "FutureResult")
[10:21:06.832]     }, finally = {
[10:21:06.832]         if (!identical(...future.workdir, getwd())) 
[10:21:06.832]             setwd(...future.workdir)
[10:21:06.832]         {
[10:21:06.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.832]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.832]             }
[10:21:06.832]             base::options(...future.oldOptions)
[10:21:06.832]             if (.Platform$OS.type == "windows") {
[10:21:06.832]                 old_names <- names(...future.oldEnvVars)
[10:21:06.832]                 envs <- base::Sys.getenv()
[10:21:06.832]                 names <- names(envs)
[10:21:06.832]                 common <- intersect(names, old_names)
[10:21:06.832]                 added <- setdiff(names, old_names)
[10:21:06.832]                 removed <- setdiff(old_names, names)
[10:21:06.832]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.832]                   envs[common]]
[10:21:06.832]                 NAMES <- toupper(changed)
[10:21:06.832]                 args <- list()
[10:21:06.832]                 for (kk in seq_along(NAMES)) {
[10:21:06.832]                   name <- changed[[kk]]
[10:21:06.832]                   NAME <- NAMES[[kk]]
[10:21:06.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.832]                     next
[10:21:06.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.832]                 }
[10:21:06.832]                 NAMES <- toupper(added)
[10:21:06.832]                 for (kk in seq_along(NAMES)) {
[10:21:06.832]                   name <- added[[kk]]
[10:21:06.832]                   NAME <- NAMES[[kk]]
[10:21:06.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.832]                     next
[10:21:06.832]                   args[[name]] <- ""
[10:21:06.832]                 }
[10:21:06.832]                 NAMES <- toupper(removed)
[10:21:06.832]                 for (kk in seq_along(NAMES)) {
[10:21:06.832]                   name <- removed[[kk]]
[10:21:06.832]                   NAME <- NAMES[[kk]]
[10:21:06.832]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.832]                     next
[10:21:06.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.832]                 }
[10:21:06.832]                 if (length(args) > 0) 
[10:21:06.832]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.832]             }
[10:21:06.832]             else {
[10:21:06.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.832]             }
[10:21:06.832]             {
[10:21:06.832]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.832]                   0L) {
[10:21:06.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.832]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.832]                   base::options(opts)
[10:21:06.832]                 }
[10:21:06.832]                 {
[10:21:06.832]                   {
[10:21:06.832]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:06.832]                     NULL
[10:21:06.832]                   }
[10:21:06.832]                   options(future.plan = NULL)
[10:21:06.832]                   if (is.na(NA_character_)) 
[10:21:06.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.832]                     .init = FALSE)
[10:21:06.832]                 }
[10:21:06.832]             }
[10:21:06.832]         }
[10:21:06.832]     })
[10:21:06.832]     if (TRUE) {
[10:21:06.832]         base::sink(type = "output", split = FALSE)
[10:21:06.832]         if (TRUE) {
[10:21:06.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.832]         }
[10:21:06.832]         else {
[10:21:06.832]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.832]         }
[10:21:06.832]         base::close(...future.stdout)
[10:21:06.832]         ...future.stdout <- NULL
[10:21:06.832]     }
[10:21:06.832]     ...future.result$conditions <- ...future.conditions
[10:21:06.832]     ...future.result$finished <- base::Sys.time()
[10:21:06.832]     ...future.result
[10:21:06.832] }
[10:21:06.834] requestCore(): workers = 2
[10:21:06.836] MulticoreFuture started
[10:21:06.836] - Launch lazy future ... done
[10:21:06.837] run() for ‘MulticoreFuture’ ... done
MulticoreFuture:
Label: ‘strategy = multicore’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
[10:21:06.837] plan(): Setting new future strategy stack:
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:21:06.837] List of future strategies:
[10:21:06.837] 1. sequential:
[10:21:06.837]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.837]    - tweaked: FALSE
[10:21:06.837]    - call: NULL
[10:21:06.838] plan(): nbrOfWorkers() = 1
[10:21:06.840] plan(): Setting new future strategy stack:
[10:21:06.840] List of future strategies:
[10:21:06.840] 1. multicore:
[10:21:06.840]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:06.840]    - tweaked: FALSE
[10:21:06.840]    - call: plan(strategy)
[10:21:06.843] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.844] result() for MulticoreFuture ...
[10:21:06.845] result() for MulticoreFuture ...
[10:21:06.845] result() for MulticoreFuture ... done
[10:21:06.845] result() for MulticoreFuture ... done
[10:21:06.845] result() for MulticoreFuture ...
[10:21:06.845] result() for MulticoreFuture ... done
[10:21:06.846] getGlobalsAndPackages() ...
[10:21:06.846] Searching for globals...
[10:21:06.847] - globals found: [1] ‘{’
[10:21:06.847] Searching for globals ... DONE
[10:21:06.847] Resolving globals: FALSE
[10:21:06.848] 
[10:21:06.848] 
[10:21:06.848] getGlobalsAndPackages() ... DONE
[10:21:06.848] run() for ‘Future’ ...
[10:21:06.851] - state: ‘created’
[10:21:06.852] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:06.854] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:06.854]   - Field: ‘label’
[10:21:06.854]   - Field: ‘local’
[10:21:06.854]   - Field: ‘owner’
[10:21:06.855]   - Field: ‘envir’
[10:21:06.855]   - Field: ‘workers’
[10:21:06.855]   - Field: ‘packages’
[10:21:06.855]   - Field: ‘gc’
[10:21:06.855]   - Field: ‘job’
[10:21:06.855]   - Field: ‘conditions’
[10:21:06.855]   - Field: ‘expr’
[10:21:06.855]   - Field: ‘uuid’
[10:21:06.855]   - Field: ‘seed’
[10:21:06.856]   - Field: ‘version’
[10:21:06.856]   - Field: ‘result’
[10:21:06.856]   - Field: ‘asynchronous’
[10:21:06.856]   - Field: ‘calls’
[10:21:06.856]   - Field: ‘globals’
[10:21:06.856]   - Field: ‘stdout’
[10:21:06.856]   - Field: ‘earlySignal’
[10:21:06.856]   - Field: ‘lazy’
[10:21:06.857]   - Field: ‘state’
[10:21:06.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:06.857] - Launch lazy future ...
[10:21:06.857] Packages needed by the future expression (n = 0): <none>
[10:21:06.857] Packages needed by future strategies (n = 0): <none>
[10:21:06.858] {
[10:21:06.858]     {
[10:21:06.858]         {
[10:21:06.858]             ...future.startTime <- base::Sys.time()
[10:21:06.858]             {
[10:21:06.858]                 {
[10:21:06.858]                   {
[10:21:06.858]                     {
[10:21:06.858]                       base::local({
[10:21:06.858]                         has_future <- base::requireNamespace("future", 
[10:21:06.858]                           quietly = TRUE)
[10:21:06.858]                         if (has_future) {
[10:21:06.858]                           ns <- base::getNamespace("future")
[10:21:06.858]                           version <- ns[[".package"]][["version"]]
[10:21:06.858]                           if (is.null(version)) 
[10:21:06.858]                             version <- utils::packageVersion("future")
[10:21:06.858]                         }
[10:21:06.858]                         else {
[10:21:06.858]                           version <- NULL
[10:21:06.858]                         }
[10:21:06.858]                         if (!has_future || version < "1.8.0") {
[10:21:06.858]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:06.858]                             "", base::R.version$version.string), 
[10:21:06.858]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:06.858]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:06.858]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:06.858]                               "release", "version")], collapse = " "), 
[10:21:06.858]                             hostname = base::Sys.info()[["nodename"]])
[10:21:06.858]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:06.858]                             info)
[10:21:06.858]                           info <- base::paste(info, collapse = "; ")
[10:21:06.858]                           if (!has_future) {
[10:21:06.858]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:06.858]                               info)
[10:21:06.858]                           }
[10:21:06.858]                           else {
[10:21:06.858]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:06.858]                               info, version)
[10:21:06.858]                           }
[10:21:06.858]                           base::stop(msg)
[10:21:06.858]                         }
[10:21:06.858]                       })
[10:21:06.858]                     }
[10:21:06.858]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:06.858]                     base::options(mc.cores = 1L)
[10:21:06.858]                   }
[10:21:06.858]                   ...future.strategy.old <- future::plan("list")
[10:21:06.858]                   options(future.plan = NULL)
[10:21:06.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:06.858]                 }
[10:21:06.858]                 ...future.workdir <- getwd()
[10:21:06.858]             }
[10:21:06.858]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:06.858]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:06.858]         }
[10:21:06.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:06.858]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:06.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:06.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:06.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:06.858]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:06.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:06.858]             base::names(...future.oldOptions))
[10:21:06.858]     }
[10:21:06.858]     if (FALSE) {
[10:21:06.858]     }
[10:21:06.858]     else {
[10:21:06.858]         if (TRUE) {
[10:21:06.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:06.858]                 open = "w")
[10:21:06.858]         }
[10:21:06.858]         else {
[10:21:06.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:06.858]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:06.858]         }
[10:21:06.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:06.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:06.858]             base::sink(type = "output", split = FALSE)
[10:21:06.858]             base::close(...future.stdout)
[10:21:06.858]         }, add = TRUE)
[10:21:06.858]     }
[10:21:06.858]     ...future.frame <- base::sys.nframe()
[10:21:06.858]     ...future.conditions <- base::list()
[10:21:06.858]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:06.858]     if (FALSE) {
[10:21:06.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:06.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:06.858]     }
[10:21:06.858]     ...future.result <- base::tryCatch({
[10:21:06.858]         base::withCallingHandlers({
[10:21:06.858]             ...future.value <- base::withVisible(base::local({
[10:21:06.858]                 withCallingHandlers({
[10:21:06.858]                   {
[10:21:06.858]                     42
[10:21:06.858]                   }
[10:21:06.858]                 }, immediateCondition = function(cond) {
[10:21:06.858]                   save_rds <- function (object, pathname, ...) 
[10:21:06.858]                   {
[10:21:06.858]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:06.858]                     if (file_test("-f", pathname_tmp)) {
[10:21:06.858]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.858]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:06.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.858]                         fi_tmp[["mtime"]])
[10:21:06.858]                     }
[10:21:06.858]                     tryCatch({
[10:21:06.858]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:06.858]                     }, error = function(ex) {
[10:21:06.858]                       msg <- conditionMessage(ex)
[10:21:06.858]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.858]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:06.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.858]                         fi_tmp[["mtime"]], msg)
[10:21:06.858]                       ex$message <- msg
[10:21:06.858]                       stop(ex)
[10:21:06.858]                     })
[10:21:06.858]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:06.858]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:06.858]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:06.858]                       fi_tmp <- file.info(pathname_tmp)
[10:21:06.858]                       fi <- file.info(pathname)
[10:21:06.858]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:06.858]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:06.858]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:06.858]                         fi[["size"]], fi[["mtime"]])
[10:21:06.858]                       stop(msg)
[10:21:06.858]                     }
[10:21:06.858]                     invisible(pathname)
[10:21:06.858]                   }
[10:21:06.858]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:06.858]                     rootPath = tempdir()) 
[10:21:06.858]                   {
[10:21:06.858]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:06.858]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:06.858]                       tmpdir = path, fileext = ".rds")
[10:21:06.858]                     save_rds(obj, file)
[10:21:06.858]                   }
[10:21:06.858]                   saveImmediateCondition(cond, path = "/tmp/RtmpkhXhLs/.future/immediateConditions")
[10:21:06.858]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.858]                   {
[10:21:06.858]                     inherits <- base::inherits
[10:21:06.858]                     invokeRestart <- base::invokeRestart
[10:21:06.858]                     is.null <- base::is.null
[10:21:06.858]                     muffled <- FALSE
[10:21:06.858]                     if (inherits(cond, "message")) {
[10:21:06.858]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:06.858]                       if (muffled) 
[10:21:06.858]                         invokeRestart("muffleMessage")
[10:21:06.858]                     }
[10:21:06.858]                     else if (inherits(cond, "warning")) {
[10:21:06.858]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:06.858]                       if (muffled) 
[10:21:06.858]                         invokeRestart("muffleWarning")
[10:21:06.858]                     }
[10:21:06.858]                     else if (inherits(cond, "condition")) {
[10:21:06.858]                       if (!is.null(pattern)) {
[10:21:06.858]                         computeRestarts <- base::computeRestarts
[10:21:06.858]                         grepl <- base::grepl
[10:21:06.858]                         restarts <- computeRestarts(cond)
[10:21:06.858]                         for (restart in restarts) {
[10:21:06.858]                           name <- restart$name
[10:21:06.858]                           if (is.null(name)) 
[10:21:06.858]                             next
[10:21:06.858]                           if (!grepl(pattern, name)) 
[10:21:06.858]                             next
[10:21:06.858]                           invokeRestart(restart)
[10:21:06.858]                           muffled <- TRUE
[10:21:06.858]                           break
[10:21:06.858]                         }
[10:21:06.858]                       }
[10:21:06.858]                     }
[10:21:06.858]                     invisible(muffled)
[10:21:06.858]                   }
[10:21:06.858]                   muffleCondition(cond)
[10:21:06.858]                 })
[10:21:06.858]             }))
[10:21:06.858]             future::FutureResult(value = ...future.value$value, 
[10:21:06.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.858]                   ...future.rng), globalenv = if (FALSE) 
[10:21:06.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:06.858]                     ...future.globalenv.names))
[10:21:06.858]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:06.858]         }, condition = base::local({
[10:21:06.858]             c <- base::c
[10:21:06.858]             inherits <- base::inherits
[10:21:06.858]             invokeRestart <- base::invokeRestart
[10:21:06.858]             length <- base::length
[10:21:06.858]             list <- base::list
[10:21:06.858]             seq.int <- base::seq.int
[10:21:06.858]             signalCondition <- base::signalCondition
[10:21:06.858]             sys.calls <- base::sys.calls
[10:21:06.858]             `[[` <- base::`[[`
[10:21:06.858]             `+` <- base::`+`
[10:21:06.858]             `<<-` <- base::`<<-`
[10:21:06.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:06.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:06.858]                   3L)]
[10:21:06.858]             }
[10:21:06.858]             function(cond) {
[10:21:06.858]                 is_error <- inherits(cond, "error")
[10:21:06.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:06.858]                   NULL)
[10:21:06.858]                 if (is_error) {
[10:21:06.858]                   sessionInformation <- function() {
[10:21:06.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:06.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:06.858]                       search = base::search(), system = base::Sys.info())
[10:21:06.858]                   }
[10:21:06.858]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:06.858]                     cond$call), session = sessionInformation(), 
[10:21:06.858]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:06.858]                   signalCondition(cond)
[10:21:06.858]                 }
[10:21:06.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:06.858]                 "immediateCondition"))) {
[10:21:06.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:06.858]                   ...future.conditions[[length(...future.conditions) + 
[10:21:06.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:06.858]                   if (TRUE && !signal) {
[10:21:06.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.858]                     {
[10:21:06.858]                       inherits <- base::inherits
[10:21:06.858]                       invokeRestart <- base::invokeRestart
[10:21:06.858]                       is.null <- base::is.null
[10:21:06.858]                       muffled <- FALSE
[10:21:06.858]                       if (inherits(cond, "message")) {
[10:21:06.858]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.858]                         if (muffled) 
[10:21:06.858]                           invokeRestart("muffleMessage")
[10:21:06.858]                       }
[10:21:06.858]                       else if (inherits(cond, "warning")) {
[10:21:06.858]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.858]                         if (muffled) 
[10:21:06.858]                           invokeRestart("muffleWarning")
[10:21:06.858]                       }
[10:21:06.858]                       else if (inherits(cond, "condition")) {
[10:21:06.858]                         if (!is.null(pattern)) {
[10:21:06.858]                           computeRestarts <- base::computeRestarts
[10:21:06.858]                           grepl <- base::grepl
[10:21:06.858]                           restarts <- computeRestarts(cond)
[10:21:06.858]                           for (restart in restarts) {
[10:21:06.858]                             name <- restart$name
[10:21:06.858]                             if (is.null(name)) 
[10:21:06.858]                               next
[10:21:06.858]                             if (!grepl(pattern, name)) 
[10:21:06.858]                               next
[10:21:06.858]                             invokeRestart(restart)
[10:21:06.858]                             muffled <- TRUE
[10:21:06.858]                             break
[10:21:06.858]                           }
[10:21:06.858]                         }
[10:21:06.858]                       }
[10:21:06.858]                       invisible(muffled)
[10:21:06.858]                     }
[10:21:06.858]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.858]                   }
[10:21:06.858]                 }
[10:21:06.858]                 else {
[10:21:06.858]                   if (TRUE) {
[10:21:06.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:06.858]                     {
[10:21:06.858]                       inherits <- base::inherits
[10:21:06.858]                       invokeRestart <- base::invokeRestart
[10:21:06.858]                       is.null <- base::is.null
[10:21:06.858]                       muffled <- FALSE
[10:21:06.858]                       if (inherits(cond, "message")) {
[10:21:06.858]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:06.858]                         if (muffled) 
[10:21:06.858]                           invokeRestart("muffleMessage")
[10:21:06.858]                       }
[10:21:06.858]                       else if (inherits(cond, "warning")) {
[10:21:06.858]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:06.858]                         if (muffled) 
[10:21:06.858]                           invokeRestart("muffleWarning")
[10:21:06.858]                       }
[10:21:06.858]                       else if (inherits(cond, "condition")) {
[10:21:06.858]                         if (!is.null(pattern)) {
[10:21:06.858]                           computeRestarts <- base::computeRestarts
[10:21:06.858]                           grepl <- base::grepl
[10:21:06.858]                           restarts <- computeRestarts(cond)
[10:21:06.858]                           for (restart in restarts) {
[10:21:06.858]                             name <- restart$name
[10:21:06.858]                             if (is.null(name)) 
[10:21:06.858]                               next
[10:21:06.858]                             if (!grepl(pattern, name)) 
[10:21:06.858]                               next
[10:21:06.858]                             invokeRestart(restart)
[10:21:06.858]                             muffled <- TRUE
[10:21:06.858]                             break
[10:21:06.858]                           }
[10:21:06.858]                         }
[10:21:06.858]                       }
[10:21:06.858]                       invisible(muffled)
[10:21:06.858]                     }
[10:21:06.858]                     muffleCondition(cond, pattern = "^muffle")
[10:21:06.858]                   }
[10:21:06.858]                 }
[10:21:06.858]             }
[10:21:06.858]         }))
[10:21:06.858]     }, error = function(ex) {
[10:21:06.858]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:06.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:06.858]                 ...future.rng), started = ...future.startTime, 
[10:21:06.858]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:06.858]             version = "1.8"), class = "FutureResult")
[10:21:06.858]     }, finally = {
[10:21:06.858]         if (!identical(...future.workdir, getwd())) 
[10:21:06.858]             setwd(...future.workdir)
[10:21:06.858]         {
[10:21:06.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:06.858]                 ...future.oldOptions$nwarnings <- NULL
[10:21:06.858]             }
[10:21:06.858]             base::options(...future.oldOptions)
[10:21:06.858]             if (.Platform$OS.type == "windows") {
[10:21:06.858]                 old_names <- names(...future.oldEnvVars)
[10:21:06.858]                 envs <- base::Sys.getenv()
[10:21:06.858]                 names <- names(envs)
[10:21:06.858]                 common <- intersect(names, old_names)
[10:21:06.858]                 added <- setdiff(names, old_names)
[10:21:06.858]                 removed <- setdiff(old_names, names)
[10:21:06.858]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:06.858]                   envs[common]]
[10:21:06.858]                 NAMES <- toupper(changed)
[10:21:06.858]                 args <- list()
[10:21:06.858]                 for (kk in seq_along(NAMES)) {
[10:21:06.858]                   name <- changed[[kk]]
[10:21:06.858]                   NAME <- NAMES[[kk]]
[10:21:06.858]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.858]                     next
[10:21:06.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.858]                 }
[10:21:06.858]                 NAMES <- toupper(added)
[10:21:06.858]                 for (kk in seq_along(NAMES)) {
[10:21:06.858]                   name <- added[[kk]]
[10:21:06.858]                   NAME <- NAMES[[kk]]
[10:21:06.858]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.858]                     next
[10:21:06.858]                   args[[name]] <- ""
[10:21:06.858]                 }
[10:21:06.858]                 NAMES <- toupper(removed)
[10:21:06.858]                 for (kk in seq_along(NAMES)) {
[10:21:06.858]                   name <- removed[[kk]]
[10:21:06.858]                   NAME <- NAMES[[kk]]
[10:21:06.858]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:06.858]                     next
[10:21:06.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:06.858]                 }
[10:21:06.858]                 if (length(args) > 0) 
[10:21:06.858]                   base::do.call(base::Sys.setenv, args = args)
[10:21:06.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:06.858]             }
[10:21:06.858]             else {
[10:21:06.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:06.858]             }
[10:21:06.858]             {
[10:21:06.858]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:06.858]                   0L) {
[10:21:06.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:06.858]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:06.858]                   base::options(opts)
[10:21:06.858]                 }
[10:21:06.858]                 {
[10:21:06.858]                   {
[10:21:06.858]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:06.858]                     NULL
[10:21:06.858]                   }
[10:21:06.858]                   options(future.plan = NULL)
[10:21:06.858]                   if (is.na(NA_character_)) 
[10:21:06.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:06.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:06.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:06.858]                     .init = FALSE)
[10:21:06.858]                 }
[10:21:06.858]             }
[10:21:06.858]         }
[10:21:06.858]     })
[10:21:06.858]     if (TRUE) {
[10:21:06.858]         base::sink(type = "output", split = FALSE)
[10:21:06.858]         if (TRUE) {
[10:21:06.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:06.858]         }
[10:21:06.858]         else {
[10:21:06.858]             ...future.result["stdout"] <- base::list(NULL)
[10:21:06.858]         }
[10:21:06.858]         base::close(...future.stdout)
[10:21:06.858]         ...future.stdout <- NULL
[10:21:06.858]     }
[10:21:06.858]     ...future.result$conditions <- ...future.conditions
[10:21:06.858]     ...future.result$finished <- base::Sys.time()
[10:21:06.858]     ...future.result
[10:21:06.858] }
[10:21:06.860] requestCore(): workers = 2
[10:21:06.862] MulticoreFuture started
[10:21:06.862] - Launch lazy future ... done
[10:21:06.862] run() for ‘MulticoreFuture’ ... done
[10:21:06.863] plan(): Setting new future strategy stack:
MulticoreFuture:
Label: ‘strategy = multicore’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:21:06.863] List of future strategies:
[10:21:06.863] 1. sequential:
[10:21:06.863]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:06.863]    - tweaked: FALSE
[10:21:06.863]    - call: NULL
[10:21:06.864] plan(): nbrOfWorkers() = 1
[10:21:06.867] plan(): Setting new future strategy stack:
[10:21:06.867] List of future strategies:
[10:21:06.867] 1. multicore:
[10:21:06.867]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:06.867]    - tweaked: FALSE
[10:21:06.867]    - call: plan(strategy)
[10:21:06.870] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:06.871] result() for MulticoreFuture ...
[10:21:06.872] result() for MulticoreFuture ...
[10:21:06.872] result() for MulticoreFuture ... done
[10:21:06.872] result() for MulticoreFuture ... done
[10:21:06.872] result() for MulticoreFuture ...
[10:21:06.872] result() for MulticoreFuture ... done
- plan('multicore') ... DONE
- plan('multisession') ...
[10:21:06.873] plan(): Setting new future strategy stack:
[10:21:06.873] List of future strategies:
[10:21:06.873] 1. multisession:
[10:21:06.873]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:06.873]    - tweaked: FALSE
[10:21:06.873]    - call: plan(strategy)
[10:21:06.873] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:06.874] multisession:
[10:21:06.874] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:06.874] - tweaked: FALSE
[10:21:06.874] - call: plan(strategy)
[10:21:06.878] getGlobalsAndPackages() ...
[10:21:06.878] Not searching for globals
[10:21:06.879] - globals: [0] <none>
[10:21:06.879] getGlobalsAndPackages() ... DONE
[10:21:07.371] Packages needed by the future expression (n = 0): <none>
[10:21:07.372] Packages needed by future strategies (n = 0): <none>
[10:21:07.372] {
[10:21:07.372]     {
[10:21:07.372]         {
[10:21:07.372]             ...future.startTime <- base::Sys.time()
[10:21:07.372]             {
[10:21:07.372]                 {
[10:21:07.372]                   {
[10:21:07.372]                     {
[10:21:07.372]                       base::local({
[10:21:07.372]                         has_future <- base::requireNamespace("future", 
[10:21:07.372]                           quietly = TRUE)
[10:21:07.372]                         if (has_future) {
[10:21:07.372]                           ns <- base::getNamespace("future")
[10:21:07.372]                           version <- ns[[".package"]][["version"]]
[10:21:07.372]                           if (is.null(version)) 
[10:21:07.372]                             version <- utils::packageVersion("future")
[10:21:07.372]                         }
[10:21:07.372]                         else {
[10:21:07.372]                           version <- NULL
[10:21:07.372]                         }
[10:21:07.372]                         if (!has_future || version < "1.8.0") {
[10:21:07.372]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:07.372]                             "", base::R.version$version.string), 
[10:21:07.372]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:07.372]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:07.372]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:07.372]                               "release", "version")], collapse = " "), 
[10:21:07.372]                             hostname = base::Sys.info()[["nodename"]])
[10:21:07.372]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:07.372]                             info)
[10:21:07.372]                           info <- base::paste(info, collapse = "; ")
[10:21:07.372]                           if (!has_future) {
[10:21:07.372]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:07.372]                               info)
[10:21:07.372]                           }
[10:21:07.372]                           else {
[10:21:07.372]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:07.372]                               info, version)
[10:21:07.372]                           }
[10:21:07.372]                           base::stop(msg)
[10:21:07.372]                         }
[10:21:07.372]                       })
[10:21:07.372]                     }
[10:21:07.372]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:07.372]                     base::options(mc.cores = 1L)
[10:21:07.372]                   }
[10:21:07.372]                   ...future.strategy.old <- future::plan("list")
[10:21:07.372]                   options(future.plan = NULL)
[10:21:07.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:07.372]                 }
[10:21:07.372]                 ...future.workdir <- getwd()
[10:21:07.372]             }
[10:21:07.372]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:07.372]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:07.372]         }
[10:21:07.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:07.372]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:07.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:07.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:07.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:07.372]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:07.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:07.372]             base::names(...future.oldOptions))
[10:21:07.372]     }
[10:21:07.372]     if (FALSE) {
[10:21:07.372]     }
[10:21:07.372]     else {
[10:21:07.372]         if (TRUE) {
[10:21:07.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:07.372]                 open = "w")
[10:21:07.372]         }
[10:21:07.372]         else {
[10:21:07.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:07.372]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:07.372]         }
[10:21:07.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:07.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:07.372]             base::sink(type = "output", split = FALSE)
[10:21:07.372]             base::close(...future.stdout)
[10:21:07.372]         }, add = TRUE)
[10:21:07.372]     }
[10:21:07.372]     ...future.frame <- base::sys.nframe()
[10:21:07.372]     ...future.conditions <- base::list()
[10:21:07.372]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:07.372]     if (FALSE) {
[10:21:07.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:07.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:07.372]     }
[10:21:07.372]     ...future.result <- base::tryCatch({
[10:21:07.372]         base::withCallingHandlers({
[10:21:07.372]             ...future.value <- base::withVisible(base::local({
[10:21:07.372]                 ...future.makeSendCondition <- base::local({
[10:21:07.372]                   sendCondition <- NULL
[10:21:07.372]                   function(frame = 1L) {
[10:21:07.372]                     if (is.function(sendCondition)) 
[10:21:07.372]                       return(sendCondition)
[10:21:07.372]                     ns <- getNamespace("parallel")
[10:21:07.372]                     if (exists("sendData", mode = "function", 
[10:21:07.372]                       envir = ns)) {
[10:21:07.372]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:07.372]                         envir = ns)
[10:21:07.372]                       envir <- sys.frame(frame)
[10:21:07.372]                       master <- NULL
[10:21:07.372]                       while (!identical(envir, .GlobalEnv) && 
[10:21:07.372]                         !identical(envir, emptyenv())) {
[10:21:07.372]                         if (exists("master", mode = "list", envir = envir, 
[10:21:07.372]                           inherits = FALSE)) {
[10:21:07.372]                           master <- get("master", mode = "list", 
[10:21:07.372]                             envir = envir, inherits = FALSE)
[10:21:07.372]                           if (inherits(master, c("SOCKnode", 
[10:21:07.372]                             "SOCK0node"))) {
[10:21:07.372]                             sendCondition <<- function(cond) {
[10:21:07.372]                               data <- list(type = "VALUE", value = cond, 
[10:21:07.372]                                 success = TRUE)
[10:21:07.372]                               parallel_sendData(master, data)
[10:21:07.372]                             }
[10:21:07.372]                             return(sendCondition)
[10:21:07.372]                           }
[10:21:07.372]                         }
[10:21:07.372]                         frame <- frame + 1L
[10:21:07.372]                         envir <- sys.frame(frame)
[10:21:07.372]                       }
[10:21:07.372]                     }
[10:21:07.372]                     sendCondition <<- function(cond) NULL
[10:21:07.372]                   }
[10:21:07.372]                 })
[10:21:07.372]                 withCallingHandlers({
[10:21:07.372]                   NA
[10:21:07.372]                 }, immediateCondition = function(cond) {
[10:21:07.372]                   sendCondition <- ...future.makeSendCondition()
[10:21:07.372]                   sendCondition(cond)
[10:21:07.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.372]                   {
[10:21:07.372]                     inherits <- base::inherits
[10:21:07.372]                     invokeRestart <- base::invokeRestart
[10:21:07.372]                     is.null <- base::is.null
[10:21:07.372]                     muffled <- FALSE
[10:21:07.372]                     if (inherits(cond, "message")) {
[10:21:07.372]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:07.372]                       if (muffled) 
[10:21:07.372]                         invokeRestart("muffleMessage")
[10:21:07.372]                     }
[10:21:07.372]                     else if (inherits(cond, "warning")) {
[10:21:07.372]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:07.372]                       if (muffled) 
[10:21:07.372]                         invokeRestart("muffleWarning")
[10:21:07.372]                     }
[10:21:07.372]                     else if (inherits(cond, "condition")) {
[10:21:07.372]                       if (!is.null(pattern)) {
[10:21:07.372]                         computeRestarts <- base::computeRestarts
[10:21:07.372]                         grepl <- base::grepl
[10:21:07.372]                         restarts <- computeRestarts(cond)
[10:21:07.372]                         for (restart in restarts) {
[10:21:07.372]                           name <- restart$name
[10:21:07.372]                           if (is.null(name)) 
[10:21:07.372]                             next
[10:21:07.372]                           if (!grepl(pattern, name)) 
[10:21:07.372]                             next
[10:21:07.372]                           invokeRestart(restart)
[10:21:07.372]                           muffled <- TRUE
[10:21:07.372]                           break
[10:21:07.372]                         }
[10:21:07.372]                       }
[10:21:07.372]                     }
[10:21:07.372]                     invisible(muffled)
[10:21:07.372]                   }
[10:21:07.372]                   muffleCondition(cond)
[10:21:07.372]                 })
[10:21:07.372]             }))
[10:21:07.372]             future::FutureResult(value = ...future.value$value, 
[10:21:07.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.372]                   ...future.rng), globalenv = if (FALSE) 
[10:21:07.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:07.372]                     ...future.globalenv.names))
[10:21:07.372]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:07.372]         }, condition = base::local({
[10:21:07.372]             c <- base::c
[10:21:07.372]             inherits <- base::inherits
[10:21:07.372]             invokeRestart <- base::invokeRestart
[10:21:07.372]             length <- base::length
[10:21:07.372]             list <- base::list
[10:21:07.372]             seq.int <- base::seq.int
[10:21:07.372]             signalCondition <- base::signalCondition
[10:21:07.372]             sys.calls <- base::sys.calls
[10:21:07.372]             `[[` <- base::`[[`
[10:21:07.372]             `+` <- base::`+`
[10:21:07.372]             `<<-` <- base::`<<-`
[10:21:07.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:07.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:07.372]                   3L)]
[10:21:07.372]             }
[10:21:07.372]             function(cond) {
[10:21:07.372]                 is_error <- inherits(cond, "error")
[10:21:07.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:07.372]                   NULL)
[10:21:07.372]                 if (is_error) {
[10:21:07.372]                   sessionInformation <- function() {
[10:21:07.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:07.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:07.372]                       search = base::search(), system = base::Sys.info())
[10:21:07.372]                   }
[10:21:07.372]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:07.372]                     cond$call), session = sessionInformation(), 
[10:21:07.372]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:07.372]                   signalCondition(cond)
[10:21:07.372]                 }
[10:21:07.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:07.372]                 "immediateCondition"))) {
[10:21:07.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:07.372]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:07.372]                   if (TRUE && !signal) {
[10:21:07.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.372]                     {
[10:21:07.372]                       inherits <- base::inherits
[10:21:07.372]                       invokeRestart <- base::invokeRestart
[10:21:07.372]                       is.null <- base::is.null
[10:21:07.372]                       muffled <- FALSE
[10:21:07.372]                       if (inherits(cond, "message")) {
[10:21:07.372]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.372]                         if (muffled) 
[10:21:07.372]                           invokeRestart("muffleMessage")
[10:21:07.372]                       }
[10:21:07.372]                       else if (inherits(cond, "warning")) {
[10:21:07.372]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.372]                         if (muffled) 
[10:21:07.372]                           invokeRestart("muffleWarning")
[10:21:07.372]                       }
[10:21:07.372]                       else if (inherits(cond, "condition")) {
[10:21:07.372]                         if (!is.null(pattern)) {
[10:21:07.372]                           computeRestarts <- base::computeRestarts
[10:21:07.372]                           grepl <- base::grepl
[10:21:07.372]                           restarts <- computeRestarts(cond)
[10:21:07.372]                           for (restart in restarts) {
[10:21:07.372]                             name <- restart$name
[10:21:07.372]                             if (is.null(name)) 
[10:21:07.372]                               next
[10:21:07.372]                             if (!grepl(pattern, name)) 
[10:21:07.372]                               next
[10:21:07.372]                             invokeRestart(restart)
[10:21:07.372]                             muffled <- TRUE
[10:21:07.372]                             break
[10:21:07.372]                           }
[10:21:07.372]                         }
[10:21:07.372]                       }
[10:21:07.372]                       invisible(muffled)
[10:21:07.372]                     }
[10:21:07.372]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.372]                   }
[10:21:07.372]                 }
[10:21:07.372]                 else {
[10:21:07.372]                   if (TRUE) {
[10:21:07.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.372]                     {
[10:21:07.372]                       inherits <- base::inherits
[10:21:07.372]                       invokeRestart <- base::invokeRestart
[10:21:07.372]                       is.null <- base::is.null
[10:21:07.372]                       muffled <- FALSE
[10:21:07.372]                       if (inherits(cond, "message")) {
[10:21:07.372]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.372]                         if (muffled) 
[10:21:07.372]                           invokeRestart("muffleMessage")
[10:21:07.372]                       }
[10:21:07.372]                       else if (inherits(cond, "warning")) {
[10:21:07.372]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.372]                         if (muffled) 
[10:21:07.372]                           invokeRestart("muffleWarning")
[10:21:07.372]                       }
[10:21:07.372]                       else if (inherits(cond, "condition")) {
[10:21:07.372]                         if (!is.null(pattern)) {
[10:21:07.372]                           computeRestarts <- base::computeRestarts
[10:21:07.372]                           grepl <- base::grepl
[10:21:07.372]                           restarts <- computeRestarts(cond)
[10:21:07.372]                           for (restart in restarts) {
[10:21:07.372]                             name <- restart$name
[10:21:07.372]                             if (is.null(name)) 
[10:21:07.372]                               next
[10:21:07.372]                             if (!grepl(pattern, name)) 
[10:21:07.372]                               next
[10:21:07.372]                             invokeRestart(restart)
[10:21:07.372]                             muffled <- TRUE
[10:21:07.372]                             break
[10:21:07.372]                           }
[10:21:07.372]                         }
[10:21:07.372]                       }
[10:21:07.372]                       invisible(muffled)
[10:21:07.372]                     }
[10:21:07.372]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.372]                   }
[10:21:07.372]                 }
[10:21:07.372]             }
[10:21:07.372]         }))
[10:21:07.372]     }, error = function(ex) {
[10:21:07.372]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:07.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.372]                 ...future.rng), started = ...future.startTime, 
[10:21:07.372]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:07.372]             version = "1.8"), class = "FutureResult")
[10:21:07.372]     }, finally = {
[10:21:07.372]         if (!identical(...future.workdir, getwd())) 
[10:21:07.372]             setwd(...future.workdir)
[10:21:07.372]         {
[10:21:07.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:07.372]                 ...future.oldOptions$nwarnings <- NULL
[10:21:07.372]             }
[10:21:07.372]             base::options(...future.oldOptions)
[10:21:07.372]             if (.Platform$OS.type == "windows") {
[10:21:07.372]                 old_names <- names(...future.oldEnvVars)
[10:21:07.372]                 envs <- base::Sys.getenv()
[10:21:07.372]                 names <- names(envs)
[10:21:07.372]                 common <- intersect(names, old_names)
[10:21:07.372]                 added <- setdiff(names, old_names)
[10:21:07.372]                 removed <- setdiff(old_names, names)
[10:21:07.372]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:07.372]                   envs[common]]
[10:21:07.372]                 NAMES <- toupper(changed)
[10:21:07.372]                 args <- list()
[10:21:07.372]                 for (kk in seq_along(NAMES)) {
[10:21:07.372]                   name <- changed[[kk]]
[10:21:07.372]                   NAME <- NAMES[[kk]]
[10:21:07.372]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.372]                     next
[10:21:07.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.372]                 }
[10:21:07.372]                 NAMES <- toupper(added)
[10:21:07.372]                 for (kk in seq_along(NAMES)) {
[10:21:07.372]                   name <- added[[kk]]
[10:21:07.372]                   NAME <- NAMES[[kk]]
[10:21:07.372]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.372]                     next
[10:21:07.372]                   args[[name]] <- ""
[10:21:07.372]                 }
[10:21:07.372]                 NAMES <- toupper(removed)
[10:21:07.372]                 for (kk in seq_along(NAMES)) {
[10:21:07.372]                   name <- removed[[kk]]
[10:21:07.372]                   NAME <- NAMES[[kk]]
[10:21:07.372]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.372]                     next
[10:21:07.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.372]                 }
[10:21:07.372]                 if (length(args) > 0) 
[10:21:07.372]                   base::do.call(base::Sys.setenv, args = args)
[10:21:07.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:07.372]             }
[10:21:07.372]             else {
[10:21:07.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:07.372]             }
[10:21:07.372]             {
[10:21:07.372]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:07.372]                   0L) {
[10:21:07.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:07.372]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:07.372]                   base::options(opts)
[10:21:07.372]                 }
[10:21:07.372]                 {
[10:21:07.372]                   {
[10:21:07.372]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:07.372]                     NULL
[10:21:07.372]                   }
[10:21:07.372]                   options(future.plan = NULL)
[10:21:07.372]                   if (is.na(NA_character_)) 
[10:21:07.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:07.372]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:07.372]                     .init = FALSE)
[10:21:07.372]                 }
[10:21:07.372]             }
[10:21:07.372]         }
[10:21:07.372]     })
[10:21:07.372]     if (TRUE) {
[10:21:07.372]         base::sink(type = "output", split = FALSE)
[10:21:07.372]         if (TRUE) {
[10:21:07.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:07.372]         }
[10:21:07.372]         else {
[10:21:07.372]             ...future.result["stdout"] <- base::list(NULL)
[10:21:07.372]         }
[10:21:07.372]         base::close(...future.stdout)
[10:21:07.372]         ...future.stdout <- NULL
[10:21:07.372]     }
[10:21:07.372]     ...future.result$conditions <- ...future.conditions
[10:21:07.372]     ...future.result$finished <- base::Sys.time()
[10:21:07.372]     ...future.result
[10:21:07.372] }
[10:21:07.426] MultisessionFuture started
[10:21:07.426] result() for ClusterFuture ...
[10:21:07.427] receiveMessageFromWorker() for ClusterFuture ...
[10:21:07.427] - Validating connection of MultisessionFuture
[10:21:07.458] - received message: FutureResult
[10:21:07.459] - Received FutureResult
[10:21:07.459] - Erased future from FutureRegistry
[10:21:07.459] result() for ClusterFuture ...
[10:21:07.459] - result already collected: FutureResult
[10:21:07.459] result() for ClusterFuture ... done
[10:21:07.459] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:07.459] result() for ClusterFuture ... done
[10:21:07.459] result() for ClusterFuture ...
[10:21:07.459] - result already collected: FutureResult
[10:21:07.459] result() for ClusterFuture ... done
[10:21:07.460] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:07.461] plan(): nbrOfWorkers() = 2
[10:21:07.463] getGlobalsAndPackages() ...
[10:21:07.463] 
[10:21:07.463] - globals: [0] <none>
[10:21:07.463] getGlobalsAndPackages() ... DONE
[10:21:07.476] Packages needed by the future expression (n = 0): <none>
[10:21:07.476] Packages needed by future strategies (n = 0): <none>
[10:21:07.476] {
[10:21:07.476]     {
[10:21:07.476]         {
[10:21:07.476]             ...future.startTime <- base::Sys.time()
[10:21:07.476]             {
[10:21:07.476]                 {
[10:21:07.476]                   {
[10:21:07.476]                     {
[10:21:07.476]                       base::local({
[10:21:07.476]                         has_future <- base::requireNamespace("future", 
[10:21:07.476]                           quietly = TRUE)
[10:21:07.476]                         if (has_future) {
[10:21:07.476]                           ns <- base::getNamespace("future")
[10:21:07.476]                           version <- ns[[".package"]][["version"]]
[10:21:07.476]                           if (is.null(version)) 
[10:21:07.476]                             version <- utils::packageVersion("future")
[10:21:07.476]                         }
[10:21:07.476]                         else {
[10:21:07.476]                           version <- NULL
[10:21:07.476]                         }
[10:21:07.476]                         if (!has_future || version < "1.8.0") {
[10:21:07.476]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:07.476]                             "", base::R.version$version.string), 
[10:21:07.476]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:07.476]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:07.476]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:07.476]                               "release", "version")], collapse = " "), 
[10:21:07.476]                             hostname = base::Sys.info()[["nodename"]])
[10:21:07.476]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:07.476]                             info)
[10:21:07.476]                           info <- base::paste(info, collapse = "; ")
[10:21:07.476]                           if (!has_future) {
[10:21:07.476]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:07.476]                               info)
[10:21:07.476]                           }
[10:21:07.476]                           else {
[10:21:07.476]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:07.476]                               info, version)
[10:21:07.476]                           }
[10:21:07.476]                           base::stop(msg)
[10:21:07.476]                         }
[10:21:07.476]                       })
[10:21:07.476]                     }
[10:21:07.476]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:07.476]                     base::options(mc.cores = 1L)
[10:21:07.476]                   }
[10:21:07.476]                   ...future.strategy.old <- future::plan("list")
[10:21:07.476]                   options(future.plan = NULL)
[10:21:07.476]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.476]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:07.476]                 }
[10:21:07.476]                 ...future.workdir <- getwd()
[10:21:07.476]             }
[10:21:07.476]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:07.476]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:07.476]         }
[10:21:07.476]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:07.476]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:07.476]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:07.476]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:07.476]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:07.476]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:07.476]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:07.476]             base::names(...future.oldOptions))
[10:21:07.476]     }
[10:21:07.476]     if (FALSE) {
[10:21:07.476]     }
[10:21:07.476]     else {
[10:21:07.476]         if (TRUE) {
[10:21:07.476]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:07.476]                 open = "w")
[10:21:07.476]         }
[10:21:07.476]         else {
[10:21:07.476]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:07.476]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:07.476]         }
[10:21:07.476]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:07.476]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:07.476]             base::sink(type = "output", split = FALSE)
[10:21:07.476]             base::close(...future.stdout)
[10:21:07.476]         }, add = TRUE)
[10:21:07.476]     }
[10:21:07.476]     ...future.frame <- base::sys.nframe()
[10:21:07.476]     ...future.conditions <- base::list()
[10:21:07.476]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:07.476]     if (FALSE) {
[10:21:07.476]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:07.476]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:07.476]     }
[10:21:07.476]     ...future.result <- base::tryCatch({
[10:21:07.476]         base::withCallingHandlers({
[10:21:07.476]             ...future.value <- base::withVisible(base::local({
[10:21:07.476]                 ...future.makeSendCondition <- base::local({
[10:21:07.476]                   sendCondition <- NULL
[10:21:07.476]                   function(frame = 1L) {
[10:21:07.476]                     if (is.function(sendCondition)) 
[10:21:07.476]                       return(sendCondition)
[10:21:07.476]                     ns <- getNamespace("parallel")
[10:21:07.476]                     if (exists("sendData", mode = "function", 
[10:21:07.476]                       envir = ns)) {
[10:21:07.476]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:07.476]                         envir = ns)
[10:21:07.476]                       envir <- sys.frame(frame)
[10:21:07.476]                       master <- NULL
[10:21:07.476]                       while (!identical(envir, .GlobalEnv) && 
[10:21:07.476]                         !identical(envir, emptyenv())) {
[10:21:07.476]                         if (exists("master", mode = "list", envir = envir, 
[10:21:07.476]                           inherits = FALSE)) {
[10:21:07.476]                           master <- get("master", mode = "list", 
[10:21:07.476]                             envir = envir, inherits = FALSE)
[10:21:07.476]                           if (inherits(master, c("SOCKnode", 
[10:21:07.476]                             "SOCK0node"))) {
[10:21:07.476]                             sendCondition <<- function(cond) {
[10:21:07.476]                               data <- list(type = "VALUE", value = cond, 
[10:21:07.476]                                 success = TRUE)
[10:21:07.476]                               parallel_sendData(master, data)
[10:21:07.476]                             }
[10:21:07.476]                             return(sendCondition)
[10:21:07.476]                           }
[10:21:07.476]                         }
[10:21:07.476]                         frame <- frame + 1L
[10:21:07.476]                         envir <- sys.frame(frame)
[10:21:07.476]                       }
[10:21:07.476]                     }
[10:21:07.476]                     sendCondition <<- function(cond) NULL
[10:21:07.476]                   }
[10:21:07.476]                 })
[10:21:07.476]                 withCallingHandlers({
[10:21:07.476]                   42
[10:21:07.476]                 }, immediateCondition = function(cond) {
[10:21:07.476]                   sendCondition <- ...future.makeSendCondition()
[10:21:07.476]                   sendCondition(cond)
[10:21:07.476]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.476]                   {
[10:21:07.476]                     inherits <- base::inherits
[10:21:07.476]                     invokeRestart <- base::invokeRestart
[10:21:07.476]                     is.null <- base::is.null
[10:21:07.476]                     muffled <- FALSE
[10:21:07.476]                     if (inherits(cond, "message")) {
[10:21:07.476]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:07.476]                       if (muffled) 
[10:21:07.476]                         invokeRestart("muffleMessage")
[10:21:07.476]                     }
[10:21:07.476]                     else if (inherits(cond, "warning")) {
[10:21:07.476]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:07.476]                       if (muffled) 
[10:21:07.476]                         invokeRestart("muffleWarning")
[10:21:07.476]                     }
[10:21:07.476]                     else if (inherits(cond, "condition")) {
[10:21:07.476]                       if (!is.null(pattern)) {
[10:21:07.476]                         computeRestarts <- base::computeRestarts
[10:21:07.476]                         grepl <- base::grepl
[10:21:07.476]                         restarts <- computeRestarts(cond)
[10:21:07.476]                         for (restart in restarts) {
[10:21:07.476]                           name <- restart$name
[10:21:07.476]                           if (is.null(name)) 
[10:21:07.476]                             next
[10:21:07.476]                           if (!grepl(pattern, name)) 
[10:21:07.476]                             next
[10:21:07.476]                           invokeRestart(restart)
[10:21:07.476]                           muffled <- TRUE
[10:21:07.476]                           break
[10:21:07.476]                         }
[10:21:07.476]                       }
[10:21:07.476]                     }
[10:21:07.476]                     invisible(muffled)
[10:21:07.476]                   }
[10:21:07.476]                   muffleCondition(cond)
[10:21:07.476]                 })
[10:21:07.476]             }))
[10:21:07.476]             future::FutureResult(value = ...future.value$value, 
[10:21:07.476]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.476]                   ...future.rng), globalenv = if (FALSE) 
[10:21:07.476]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:07.476]                     ...future.globalenv.names))
[10:21:07.476]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:07.476]         }, condition = base::local({
[10:21:07.476]             c <- base::c
[10:21:07.476]             inherits <- base::inherits
[10:21:07.476]             invokeRestart <- base::invokeRestart
[10:21:07.476]             length <- base::length
[10:21:07.476]             list <- base::list
[10:21:07.476]             seq.int <- base::seq.int
[10:21:07.476]             signalCondition <- base::signalCondition
[10:21:07.476]             sys.calls <- base::sys.calls
[10:21:07.476]             `[[` <- base::`[[`
[10:21:07.476]             `+` <- base::`+`
[10:21:07.476]             `<<-` <- base::`<<-`
[10:21:07.476]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:07.476]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:07.476]                   3L)]
[10:21:07.476]             }
[10:21:07.476]             function(cond) {
[10:21:07.476]                 is_error <- inherits(cond, "error")
[10:21:07.476]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:07.476]                   NULL)
[10:21:07.476]                 if (is_error) {
[10:21:07.476]                   sessionInformation <- function() {
[10:21:07.476]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:07.476]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:07.476]                       search = base::search(), system = base::Sys.info())
[10:21:07.476]                   }
[10:21:07.476]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.476]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:07.476]                     cond$call), session = sessionInformation(), 
[10:21:07.476]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:07.476]                   signalCondition(cond)
[10:21:07.476]                 }
[10:21:07.476]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:07.476]                 "immediateCondition"))) {
[10:21:07.476]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:07.476]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.476]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:07.476]                   if (TRUE && !signal) {
[10:21:07.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.476]                     {
[10:21:07.476]                       inherits <- base::inherits
[10:21:07.476]                       invokeRestart <- base::invokeRestart
[10:21:07.476]                       is.null <- base::is.null
[10:21:07.476]                       muffled <- FALSE
[10:21:07.476]                       if (inherits(cond, "message")) {
[10:21:07.476]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.476]                         if (muffled) 
[10:21:07.476]                           invokeRestart("muffleMessage")
[10:21:07.476]                       }
[10:21:07.476]                       else if (inherits(cond, "warning")) {
[10:21:07.476]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.476]                         if (muffled) 
[10:21:07.476]                           invokeRestart("muffleWarning")
[10:21:07.476]                       }
[10:21:07.476]                       else if (inherits(cond, "condition")) {
[10:21:07.476]                         if (!is.null(pattern)) {
[10:21:07.476]                           computeRestarts <- base::computeRestarts
[10:21:07.476]                           grepl <- base::grepl
[10:21:07.476]                           restarts <- computeRestarts(cond)
[10:21:07.476]                           for (restart in restarts) {
[10:21:07.476]                             name <- restart$name
[10:21:07.476]                             if (is.null(name)) 
[10:21:07.476]                               next
[10:21:07.476]                             if (!grepl(pattern, name)) 
[10:21:07.476]                               next
[10:21:07.476]                             invokeRestart(restart)
[10:21:07.476]                             muffled <- TRUE
[10:21:07.476]                             break
[10:21:07.476]                           }
[10:21:07.476]                         }
[10:21:07.476]                       }
[10:21:07.476]                       invisible(muffled)
[10:21:07.476]                     }
[10:21:07.476]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.476]                   }
[10:21:07.476]                 }
[10:21:07.476]                 else {
[10:21:07.476]                   if (TRUE) {
[10:21:07.476]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.476]                     {
[10:21:07.476]                       inherits <- base::inherits
[10:21:07.476]                       invokeRestart <- base::invokeRestart
[10:21:07.476]                       is.null <- base::is.null
[10:21:07.476]                       muffled <- FALSE
[10:21:07.476]                       if (inherits(cond, "message")) {
[10:21:07.476]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.476]                         if (muffled) 
[10:21:07.476]                           invokeRestart("muffleMessage")
[10:21:07.476]                       }
[10:21:07.476]                       else if (inherits(cond, "warning")) {
[10:21:07.476]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.476]                         if (muffled) 
[10:21:07.476]                           invokeRestart("muffleWarning")
[10:21:07.476]                       }
[10:21:07.476]                       else if (inherits(cond, "condition")) {
[10:21:07.476]                         if (!is.null(pattern)) {
[10:21:07.476]                           computeRestarts <- base::computeRestarts
[10:21:07.476]                           grepl <- base::grepl
[10:21:07.476]                           restarts <- computeRestarts(cond)
[10:21:07.476]                           for (restart in restarts) {
[10:21:07.476]                             name <- restart$name
[10:21:07.476]                             if (is.null(name)) 
[10:21:07.476]                               next
[10:21:07.476]                             if (!grepl(pattern, name)) 
[10:21:07.476]                               next
[10:21:07.476]                             invokeRestart(restart)
[10:21:07.476]                             muffled <- TRUE
[10:21:07.476]                             break
[10:21:07.476]                           }
[10:21:07.476]                         }
[10:21:07.476]                       }
[10:21:07.476]                       invisible(muffled)
[10:21:07.476]                     }
[10:21:07.476]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.476]                   }
[10:21:07.476]                 }
[10:21:07.476]             }
[10:21:07.476]         }))
[10:21:07.476]     }, error = function(ex) {
[10:21:07.476]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:07.476]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.476]                 ...future.rng), started = ...future.startTime, 
[10:21:07.476]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:07.476]             version = "1.8"), class = "FutureResult")
[10:21:07.476]     }, finally = {
[10:21:07.476]         if (!identical(...future.workdir, getwd())) 
[10:21:07.476]             setwd(...future.workdir)
[10:21:07.476]         {
[10:21:07.476]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:07.476]                 ...future.oldOptions$nwarnings <- NULL
[10:21:07.476]             }
[10:21:07.476]             base::options(...future.oldOptions)
[10:21:07.476]             if (.Platform$OS.type == "windows") {
[10:21:07.476]                 old_names <- names(...future.oldEnvVars)
[10:21:07.476]                 envs <- base::Sys.getenv()
[10:21:07.476]                 names <- names(envs)
[10:21:07.476]                 common <- intersect(names, old_names)
[10:21:07.476]                 added <- setdiff(names, old_names)
[10:21:07.476]                 removed <- setdiff(old_names, names)
[10:21:07.476]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:07.476]                   envs[common]]
[10:21:07.476]                 NAMES <- toupper(changed)
[10:21:07.476]                 args <- list()
[10:21:07.476]                 for (kk in seq_along(NAMES)) {
[10:21:07.476]                   name <- changed[[kk]]
[10:21:07.476]                   NAME <- NAMES[[kk]]
[10:21:07.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.476]                     next
[10:21:07.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.476]                 }
[10:21:07.476]                 NAMES <- toupper(added)
[10:21:07.476]                 for (kk in seq_along(NAMES)) {
[10:21:07.476]                   name <- added[[kk]]
[10:21:07.476]                   NAME <- NAMES[[kk]]
[10:21:07.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.476]                     next
[10:21:07.476]                   args[[name]] <- ""
[10:21:07.476]                 }
[10:21:07.476]                 NAMES <- toupper(removed)
[10:21:07.476]                 for (kk in seq_along(NAMES)) {
[10:21:07.476]                   name <- removed[[kk]]
[10:21:07.476]                   NAME <- NAMES[[kk]]
[10:21:07.476]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.476]                     next
[10:21:07.476]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.476]                 }
[10:21:07.476]                 if (length(args) > 0) 
[10:21:07.476]                   base::do.call(base::Sys.setenv, args = args)
[10:21:07.476]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:07.476]             }
[10:21:07.476]             else {
[10:21:07.476]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:07.476]             }
[10:21:07.476]             {
[10:21:07.476]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:07.476]                   0L) {
[10:21:07.476]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:07.476]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:07.476]                   base::options(opts)
[10:21:07.476]                 }
[10:21:07.476]                 {
[10:21:07.476]                   {
[10:21:07.476]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:07.476]                     NULL
[10:21:07.476]                   }
[10:21:07.476]                   options(future.plan = NULL)
[10:21:07.476]                   if (is.na(NA_character_)) 
[10:21:07.476]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.476]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:07.476]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:07.476]                     .init = FALSE)
[10:21:07.476]                 }
[10:21:07.476]             }
[10:21:07.476]         }
[10:21:07.476]     })
[10:21:07.476]     if (TRUE) {
[10:21:07.476]         base::sink(type = "output", split = FALSE)
[10:21:07.476]         if (TRUE) {
[10:21:07.476]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:07.476]         }
[10:21:07.476]         else {
[10:21:07.476]             ...future.result["stdout"] <- base::list(NULL)
[10:21:07.476]         }
[10:21:07.476]         base::close(...future.stdout)
[10:21:07.476]         ...future.stdout <- NULL
[10:21:07.476]     }
[10:21:07.476]     ...future.result$conditions <- ...future.conditions
[10:21:07.476]     ...future.result$finished <- base::Sys.time()
[10:21:07.476]     ...future.result
[10:21:07.476] }
[10:21:07.479] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.491] result() for ClusterFuture ...
[10:21:07.491] receiveMessageFromWorker() for ClusterFuture ...
[10:21:07.491] - Validating connection of MultisessionFuture
[10:21:07.521] - received message: FutureResult
[10:21:07.521] - Received FutureResult
[10:21:07.521] - Erased future from FutureRegistry
[10:21:07.522] result() for ClusterFuture ...
[10:21:07.522] - result already collected: FutureResult
[10:21:07.522] result() for ClusterFuture ... done
[10:21:07.522] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:07.522] result() for ClusterFuture ... done
[10:21:07.522] result() for ClusterFuture ...
[10:21:07.522] - result already collected: FutureResult
[10:21:07.522] result() for ClusterFuture ... done
[10:21:07.522] getGlobalsAndPackages() ...
[10:21:07.523] Searching for globals...
[10:21:07.523] 
[10:21:07.523] Searching for globals ... DONE
[10:21:07.523] - globals: [0] <none>
[10:21:07.523] getGlobalsAndPackages() ... DONE
[10:21:07.523] run() for ‘Future’ ...
[10:21:07.524] - state: ‘created’
[10:21:07.524] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:07.538] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:07.538]   - Field: ‘node’
[10:21:07.539]   - Field: ‘label’
[10:21:07.539]   - Field: ‘local’
[10:21:07.539]   - Field: ‘owner’
[10:21:07.539]   - Field: ‘envir’
[10:21:07.539]   - Field: ‘workers’
[10:21:07.539]   - Field: ‘packages’
[10:21:07.539]   - Field: ‘gc’
[10:21:07.539]   - Field: ‘conditions’
[10:21:07.539]   - Field: ‘persistent’
[10:21:07.539]   - Field: ‘expr’
[10:21:07.539]   - Field: ‘uuid’
[10:21:07.539]   - Field: ‘seed’
[10:21:07.540]   - Field: ‘version’
[10:21:07.540]   - Field: ‘result’
[10:21:07.540]   - Field: ‘asynchronous’
[10:21:07.540]   - Field: ‘calls’
[10:21:07.540]   - Field: ‘globals’
[10:21:07.540]   - Field: ‘stdout’
[10:21:07.540]   - Field: ‘earlySignal’
[10:21:07.540]   - Field: ‘lazy’
[10:21:07.540]   - Field: ‘state’
[10:21:07.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:07.540] - Launch lazy future ...
[10:21:07.541] Packages needed by the future expression (n = 0): <none>
[10:21:07.541] Packages needed by future strategies (n = 0): <none>
[10:21:07.541] {
[10:21:07.541]     {
[10:21:07.541]         {
[10:21:07.541]             ...future.startTime <- base::Sys.time()
[10:21:07.541]             {
[10:21:07.541]                 {
[10:21:07.541]                   {
[10:21:07.541]                     {
[10:21:07.541]                       base::local({
[10:21:07.541]                         has_future <- base::requireNamespace("future", 
[10:21:07.541]                           quietly = TRUE)
[10:21:07.541]                         if (has_future) {
[10:21:07.541]                           ns <- base::getNamespace("future")
[10:21:07.541]                           version <- ns[[".package"]][["version"]]
[10:21:07.541]                           if (is.null(version)) 
[10:21:07.541]                             version <- utils::packageVersion("future")
[10:21:07.541]                         }
[10:21:07.541]                         else {
[10:21:07.541]                           version <- NULL
[10:21:07.541]                         }
[10:21:07.541]                         if (!has_future || version < "1.8.0") {
[10:21:07.541]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:07.541]                             "", base::R.version$version.string), 
[10:21:07.541]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:07.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:07.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:07.541]                               "release", "version")], collapse = " "), 
[10:21:07.541]                             hostname = base::Sys.info()[["nodename"]])
[10:21:07.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:07.541]                             info)
[10:21:07.541]                           info <- base::paste(info, collapse = "; ")
[10:21:07.541]                           if (!has_future) {
[10:21:07.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:07.541]                               info)
[10:21:07.541]                           }
[10:21:07.541]                           else {
[10:21:07.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:07.541]                               info, version)
[10:21:07.541]                           }
[10:21:07.541]                           base::stop(msg)
[10:21:07.541]                         }
[10:21:07.541]                       })
[10:21:07.541]                     }
[10:21:07.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:07.541]                     base::options(mc.cores = 1L)
[10:21:07.541]                   }
[10:21:07.541]                   ...future.strategy.old <- future::plan("list")
[10:21:07.541]                   options(future.plan = NULL)
[10:21:07.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:07.541]                 }
[10:21:07.541]                 ...future.workdir <- getwd()
[10:21:07.541]             }
[10:21:07.541]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:07.541]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:07.541]         }
[10:21:07.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:07.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:07.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:07.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:07.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:07.541]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:07.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:07.541]             base::names(...future.oldOptions))
[10:21:07.541]     }
[10:21:07.541]     if (FALSE) {
[10:21:07.541]     }
[10:21:07.541]     else {
[10:21:07.541]         if (TRUE) {
[10:21:07.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:07.541]                 open = "w")
[10:21:07.541]         }
[10:21:07.541]         else {
[10:21:07.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:07.541]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:07.541]         }
[10:21:07.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:07.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:07.541]             base::sink(type = "output", split = FALSE)
[10:21:07.541]             base::close(...future.stdout)
[10:21:07.541]         }, add = TRUE)
[10:21:07.541]     }
[10:21:07.541]     ...future.frame <- base::sys.nframe()
[10:21:07.541]     ...future.conditions <- base::list()
[10:21:07.541]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:07.541]     if (FALSE) {
[10:21:07.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:07.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:07.541]     }
[10:21:07.541]     ...future.result <- base::tryCatch({
[10:21:07.541]         base::withCallingHandlers({
[10:21:07.541]             ...future.value <- base::withVisible(base::local({
[10:21:07.541]                 ...future.makeSendCondition <- base::local({
[10:21:07.541]                   sendCondition <- NULL
[10:21:07.541]                   function(frame = 1L) {
[10:21:07.541]                     if (is.function(sendCondition)) 
[10:21:07.541]                       return(sendCondition)
[10:21:07.541]                     ns <- getNamespace("parallel")
[10:21:07.541]                     if (exists("sendData", mode = "function", 
[10:21:07.541]                       envir = ns)) {
[10:21:07.541]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:07.541]                         envir = ns)
[10:21:07.541]                       envir <- sys.frame(frame)
[10:21:07.541]                       master <- NULL
[10:21:07.541]                       while (!identical(envir, .GlobalEnv) && 
[10:21:07.541]                         !identical(envir, emptyenv())) {
[10:21:07.541]                         if (exists("master", mode = "list", envir = envir, 
[10:21:07.541]                           inherits = FALSE)) {
[10:21:07.541]                           master <- get("master", mode = "list", 
[10:21:07.541]                             envir = envir, inherits = FALSE)
[10:21:07.541]                           if (inherits(master, c("SOCKnode", 
[10:21:07.541]                             "SOCK0node"))) {
[10:21:07.541]                             sendCondition <<- function(cond) {
[10:21:07.541]                               data <- list(type = "VALUE", value = cond, 
[10:21:07.541]                                 success = TRUE)
[10:21:07.541]                               parallel_sendData(master, data)
[10:21:07.541]                             }
[10:21:07.541]                             return(sendCondition)
[10:21:07.541]                           }
[10:21:07.541]                         }
[10:21:07.541]                         frame <- frame + 1L
[10:21:07.541]                         envir <- sys.frame(frame)
[10:21:07.541]                       }
[10:21:07.541]                     }
[10:21:07.541]                     sendCondition <<- function(cond) NULL
[10:21:07.541]                   }
[10:21:07.541]                 })
[10:21:07.541]                 withCallingHandlers({
[10:21:07.541]                   42
[10:21:07.541]                 }, immediateCondition = function(cond) {
[10:21:07.541]                   sendCondition <- ...future.makeSendCondition()
[10:21:07.541]                   sendCondition(cond)
[10:21:07.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.541]                   {
[10:21:07.541]                     inherits <- base::inherits
[10:21:07.541]                     invokeRestart <- base::invokeRestart
[10:21:07.541]                     is.null <- base::is.null
[10:21:07.541]                     muffled <- FALSE
[10:21:07.541]                     if (inherits(cond, "message")) {
[10:21:07.541]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:07.541]                       if (muffled) 
[10:21:07.541]                         invokeRestart("muffleMessage")
[10:21:07.541]                     }
[10:21:07.541]                     else if (inherits(cond, "warning")) {
[10:21:07.541]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:07.541]                       if (muffled) 
[10:21:07.541]                         invokeRestart("muffleWarning")
[10:21:07.541]                     }
[10:21:07.541]                     else if (inherits(cond, "condition")) {
[10:21:07.541]                       if (!is.null(pattern)) {
[10:21:07.541]                         computeRestarts <- base::computeRestarts
[10:21:07.541]                         grepl <- base::grepl
[10:21:07.541]                         restarts <- computeRestarts(cond)
[10:21:07.541]                         for (restart in restarts) {
[10:21:07.541]                           name <- restart$name
[10:21:07.541]                           if (is.null(name)) 
[10:21:07.541]                             next
[10:21:07.541]                           if (!grepl(pattern, name)) 
[10:21:07.541]                             next
[10:21:07.541]                           invokeRestart(restart)
[10:21:07.541]                           muffled <- TRUE
[10:21:07.541]                           break
[10:21:07.541]                         }
[10:21:07.541]                       }
[10:21:07.541]                     }
[10:21:07.541]                     invisible(muffled)
[10:21:07.541]                   }
[10:21:07.541]                   muffleCondition(cond)
[10:21:07.541]                 })
[10:21:07.541]             }))
[10:21:07.541]             future::FutureResult(value = ...future.value$value, 
[10:21:07.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.541]                   ...future.rng), globalenv = if (FALSE) 
[10:21:07.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:07.541]                     ...future.globalenv.names))
[10:21:07.541]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:07.541]         }, condition = base::local({
[10:21:07.541]             c <- base::c
[10:21:07.541]             inherits <- base::inherits
[10:21:07.541]             invokeRestart <- base::invokeRestart
[10:21:07.541]             length <- base::length
[10:21:07.541]             list <- base::list
[10:21:07.541]             seq.int <- base::seq.int
[10:21:07.541]             signalCondition <- base::signalCondition
[10:21:07.541]             sys.calls <- base::sys.calls
[10:21:07.541]             `[[` <- base::`[[`
[10:21:07.541]             `+` <- base::`+`
[10:21:07.541]             `<<-` <- base::`<<-`
[10:21:07.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:07.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:07.541]                   3L)]
[10:21:07.541]             }
[10:21:07.541]             function(cond) {
[10:21:07.541]                 is_error <- inherits(cond, "error")
[10:21:07.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:07.541]                   NULL)
[10:21:07.541]                 if (is_error) {
[10:21:07.541]                   sessionInformation <- function() {
[10:21:07.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:07.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:07.541]                       search = base::search(), system = base::Sys.info())
[10:21:07.541]                   }
[10:21:07.541]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:07.541]                     cond$call), session = sessionInformation(), 
[10:21:07.541]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:07.541]                   signalCondition(cond)
[10:21:07.541]                 }
[10:21:07.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:07.541]                 "immediateCondition"))) {
[10:21:07.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:07.541]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:07.541]                   if (TRUE && !signal) {
[10:21:07.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.541]                     {
[10:21:07.541]                       inherits <- base::inherits
[10:21:07.541]                       invokeRestart <- base::invokeRestart
[10:21:07.541]                       is.null <- base::is.null
[10:21:07.541]                       muffled <- FALSE
[10:21:07.541]                       if (inherits(cond, "message")) {
[10:21:07.541]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.541]                         if (muffled) 
[10:21:07.541]                           invokeRestart("muffleMessage")
[10:21:07.541]                       }
[10:21:07.541]                       else if (inherits(cond, "warning")) {
[10:21:07.541]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.541]                         if (muffled) 
[10:21:07.541]                           invokeRestart("muffleWarning")
[10:21:07.541]                       }
[10:21:07.541]                       else if (inherits(cond, "condition")) {
[10:21:07.541]                         if (!is.null(pattern)) {
[10:21:07.541]                           computeRestarts <- base::computeRestarts
[10:21:07.541]                           grepl <- base::grepl
[10:21:07.541]                           restarts <- computeRestarts(cond)
[10:21:07.541]                           for (restart in restarts) {
[10:21:07.541]                             name <- restart$name
[10:21:07.541]                             if (is.null(name)) 
[10:21:07.541]                               next
[10:21:07.541]                             if (!grepl(pattern, name)) 
[10:21:07.541]                               next
[10:21:07.541]                             invokeRestart(restart)
[10:21:07.541]                             muffled <- TRUE
[10:21:07.541]                             break
[10:21:07.541]                           }
[10:21:07.541]                         }
[10:21:07.541]                       }
[10:21:07.541]                       invisible(muffled)
[10:21:07.541]                     }
[10:21:07.541]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.541]                   }
[10:21:07.541]                 }
[10:21:07.541]                 else {
[10:21:07.541]                   if (TRUE) {
[10:21:07.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.541]                     {
[10:21:07.541]                       inherits <- base::inherits
[10:21:07.541]                       invokeRestart <- base::invokeRestart
[10:21:07.541]                       is.null <- base::is.null
[10:21:07.541]                       muffled <- FALSE
[10:21:07.541]                       if (inherits(cond, "message")) {
[10:21:07.541]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.541]                         if (muffled) 
[10:21:07.541]                           invokeRestart("muffleMessage")
[10:21:07.541]                       }
[10:21:07.541]                       else if (inherits(cond, "warning")) {
[10:21:07.541]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.541]                         if (muffled) 
[10:21:07.541]                           invokeRestart("muffleWarning")
[10:21:07.541]                       }
[10:21:07.541]                       else if (inherits(cond, "condition")) {
[10:21:07.541]                         if (!is.null(pattern)) {
[10:21:07.541]                           computeRestarts <- base::computeRestarts
[10:21:07.541]                           grepl <- base::grepl
[10:21:07.541]                           restarts <- computeRestarts(cond)
[10:21:07.541]                           for (restart in restarts) {
[10:21:07.541]                             name <- restart$name
[10:21:07.541]                             if (is.null(name)) 
[10:21:07.541]                               next
[10:21:07.541]                             if (!grepl(pattern, name)) 
[10:21:07.541]                               next
[10:21:07.541]                             invokeRestart(restart)
[10:21:07.541]                             muffled <- TRUE
[10:21:07.541]                             break
[10:21:07.541]                           }
[10:21:07.541]                         }
[10:21:07.541]                       }
[10:21:07.541]                       invisible(muffled)
[10:21:07.541]                     }
[10:21:07.541]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.541]                   }
[10:21:07.541]                 }
[10:21:07.541]             }
[10:21:07.541]         }))
[10:21:07.541]     }, error = function(ex) {
[10:21:07.541]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:07.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.541]                 ...future.rng), started = ...future.startTime, 
[10:21:07.541]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:07.541]             version = "1.8"), class = "FutureResult")
[10:21:07.541]     }, finally = {
[10:21:07.541]         if (!identical(...future.workdir, getwd())) 
[10:21:07.541]             setwd(...future.workdir)
[10:21:07.541]         {
[10:21:07.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:07.541]                 ...future.oldOptions$nwarnings <- NULL
[10:21:07.541]             }
[10:21:07.541]             base::options(...future.oldOptions)
[10:21:07.541]             if (.Platform$OS.type == "windows") {
[10:21:07.541]                 old_names <- names(...future.oldEnvVars)
[10:21:07.541]                 envs <- base::Sys.getenv()
[10:21:07.541]                 names <- names(envs)
[10:21:07.541]                 common <- intersect(names, old_names)
[10:21:07.541]                 added <- setdiff(names, old_names)
[10:21:07.541]                 removed <- setdiff(old_names, names)
[10:21:07.541]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:07.541]                   envs[common]]
[10:21:07.541]                 NAMES <- toupper(changed)
[10:21:07.541]                 args <- list()
[10:21:07.541]                 for (kk in seq_along(NAMES)) {
[10:21:07.541]                   name <- changed[[kk]]
[10:21:07.541]                   NAME <- NAMES[[kk]]
[10:21:07.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.541]                     next
[10:21:07.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.541]                 }
[10:21:07.541]                 NAMES <- toupper(added)
[10:21:07.541]                 for (kk in seq_along(NAMES)) {
[10:21:07.541]                   name <- added[[kk]]
[10:21:07.541]                   NAME <- NAMES[[kk]]
[10:21:07.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.541]                     next
[10:21:07.541]                   args[[name]] <- ""
[10:21:07.541]                 }
[10:21:07.541]                 NAMES <- toupper(removed)
[10:21:07.541]                 for (kk in seq_along(NAMES)) {
[10:21:07.541]                   name <- removed[[kk]]
[10:21:07.541]                   NAME <- NAMES[[kk]]
[10:21:07.541]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.541]                     next
[10:21:07.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.541]                 }
[10:21:07.541]                 if (length(args) > 0) 
[10:21:07.541]                   base::do.call(base::Sys.setenv, args = args)
[10:21:07.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:07.541]             }
[10:21:07.541]             else {
[10:21:07.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:07.541]             }
[10:21:07.541]             {
[10:21:07.541]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:07.541]                   0L) {
[10:21:07.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:07.541]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:07.541]                   base::options(opts)
[10:21:07.541]                 }
[10:21:07.541]                 {
[10:21:07.541]                   {
[10:21:07.541]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:07.541]                     NULL
[10:21:07.541]                   }
[10:21:07.541]                   options(future.plan = NULL)
[10:21:07.541]                   if (is.na(NA_character_)) 
[10:21:07.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:07.541]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:07.541]                     .init = FALSE)
[10:21:07.541]                 }
[10:21:07.541]             }
[10:21:07.541]         }
[10:21:07.541]     })
[10:21:07.541]     if (TRUE) {
[10:21:07.541]         base::sink(type = "output", split = FALSE)
[10:21:07.541]         if (TRUE) {
[10:21:07.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:07.541]         }
[10:21:07.541]         else {
[10:21:07.541]             ...future.result["stdout"] <- base::list(NULL)
[10:21:07.541]         }
[10:21:07.541]         base::close(...future.stdout)
[10:21:07.541]         ...future.stdout <- NULL
[10:21:07.541]     }
[10:21:07.541]     ...future.result$conditions <- ...future.conditions
[10:21:07.541]     ...future.result$finished <- base::Sys.time()
[10:21:07.541]     ...future.result
[10:21:07.541] }
[10:21:07.544] MultisessionFuture started
[10:21:07.545] - Launch lazy future ... done
[10:21:07.545] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.556] result() for ClusterFuture ...
[10:21:07.556] receiveMessageFromWorker() for ClusterFuture ...
[10:21:07.556] - Validating connection of MultisessionFuture
[10:21:07.587] - received message: FutureResult
[10:21:07.588] - Received FutureResult
[10:21:07.588] - Erased future from FutureRegistry
[10:21:07.588] result() for ClusterFuture ...
[10:21:07.588] - result already collected: FutureResult
[10:21:07.588] result() for ClusterFuture ... done
[10:21:07.588] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:07.588] result() for ClusterFuture ... done
[10:21:07.588] result() for ClusterFuture ...
[10:21:07.589] - result already collected: FutureResult
[10:21:07.589] result() for ClusterFuture ... done
[10:21:07.589] getGlobalsAndPackages() ...
[10:21:07.589] Searching for globals...
[10:21:07.590] - globals found: [1] ‘{’
[10:21:07.590] Searching for globals ... DONE
[10:21:07.590] Resolving globals: FALSE
[10:21:07.590] 
[10:21:07.591] 
[10:21:07.591] getGlobalsAndPackages() ... DONE
[10:21:07.591] run() for ‘Future’ ...
[10:21:07.591] - state: ‘created’
[10:21:07.591] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:07.606] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.606] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:07.606]   - Field: ‘node’
[10:21:07.606]   - Field: ‘label’
[10:21:07.606]   - Field: ‘local’
[10:21:07.606]   - Field: ‘owner’
[10:21:07.606]   - Field: ‘envir’
[10:21:07.606]   - Field: ‘workers’
[10:21:07.606]   - Field: ‘packages’
[10:21:07.607]   - Field: ‘gc’
[10:21:07.607]   - Field: ‘conditions’
[10:21:07.607]   - Field: ‘persistent’
[10:21:07.607]   - Field: ‘expr’
[10:21:07.607]   - Field: ‘uuid’
[10:21:07.607]   - Field: ‘seed’
[10:21:07.607]   - Field: ‘version’
[10:21:07.607]   - Field: ‘result’
[10:21:07.607]   - Field: ‘asynchronous’
[10:21:07.608]   - Field: ‘calls’
[10:21:07.608]   - Field: ‘globals’
[10:21:07.608]   - Field: ‘stdout’
[10:21:07.608]   - Field: ‘earlySignal’
[10:21:07.608]   - Field: ‘lazy’
[10:21:07.608]   - Field: ‘state’
[10:21:07.608] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:07.608] - Launch lazy future ...
[10:21:07.609] Packages needed by the future expression (n = 0): <none>
[10:21:07.609] Packages needed by future strategies (n = 0): <none>
[10:21:07.609] {
[10:21:07.609]     {
[10:21:07.609]         {
[10:21:07.609]             ...future.startTime <- base::Sys.time()
[10:21:07.609]             {
[10:21:07.609]                 {
[10:21:07.609]                   {
[10:21:07.609]                     {
[10:21:07.609]                       base::local({
[10:21:07.609]                         has_future <- base::requireNamespace("future", 
[10:21:07.609]                           quietly = TRUE)
[10:21:07.609]                         if (has_future) {
[10:21:07.609]                           ns <- base::getNamespace("future")
[10:21:07.609]                           version <- ns[[".package"]][["version"]]
[10:21:07.609]                           if (is.null(version)) 
[10:21:07.609]                             version <- utils::packageVersion("future")
[10:21:07.609]                         }
[10:21:07.609]                         else {
[10:21:07.609]                           version <- NULL
[10:21:07.609]                         }
[10:21:07.609]                         if (!has_future || version < "1.8.0") {
[10:21:07.609]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:07.609]                             "", base::R.version$version.string), 
[10:21:07.609]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:07.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:07.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:07.609]                               "release", "version")], collapse = " "), 
[10:21:07.609]                             hostname = base::Sys.info()[["nodename"]])
[10:21:07.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:07.609]                             info)
[10:21:07.609]                           info <- base::paste(info, collapse = "; ")
[10:21:07.609]                           if (!has_future) {
[10:21:07.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:07.609]                               info)
[10:21:07.609]                           }
[10:21:07.609]                           else {
[10:21:07.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:07.609]                               info, version)
[10:21:07.609]                           }
[10:21:07.609]                           base::stop(msg)
[10:21:07.609]                         }
[10:21:07.609]                       })
[10:21:07.609]                     }
[10:21:07.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:07.609]                     base::options(mc.cores = 1L)
[10:21:07.609]                   }
[10:21:07.609]                   ...future.strategy.old <- future::plan("list")
[10:21:07.609]                   options(future.plan = NULL)
[10:21:07.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:07.609]                 }
[10:21:07.609]                 ...future.workdir <- getwd()
[10:21:07.609]             }
[10:21:07.609]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:07.609]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:07.609]         }
[10:21:07.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:07.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:07.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:07.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:07.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:07.609]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:07.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:07.609]             base::names(...future.oldOptions))
[10:21:07.609]     }
[10:21:07.609]     if (FALSE) {
[10:21:07.609]     }
[10:21:07.609]     else {
[10:21:07.609]         if (TRUE) {
[10:21:07.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:07.609]                 open = "w")
[10:21:07.609]         }
[10:21:07.609]         else {
[10:21:07.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:07.609]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:07.609]         }
[10:21:07.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:07.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:07.609]             base::sink(type = "output", split = FALSE)
[10:21:07.609]             base::close(...future.stdout)
[10:21:07.609]         }, add = TRUE)
[10:21:07.609]     }
[10:21:07.609]     ...future.frame <- base::sys.nframe()
[10:21:07.609]     ...future.conditions <- base::list()
[10:21:07.609]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:07.609]     if (FALSE) {
[10:21:07.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:07.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:07.609]     }
[10:21:07.609]     ...future.result <- base::tryCatch({
[10:21:07.609]         base::withCallingHandlers({
[10:21:07.609]             ...future.value <- base::withVisible(base::local({
[10:21:07.609]                 ...future.makeSendCondition <- base::local({
[10:21:07.609]                   sendCondition <- NULL
[10:21:07.609]                   function(frame = 1L) {
[10:21:07.609]                     if (is.function(sendCondition)) 
[10:21:07.609]                       return(sendCondition)
[10:21:07.609]                     ns <- getNamespace("parallel")
[10:21:07.609]                     if (exists("sendData", mode = "function", 
[10:21:07.609]                       envir = ns)) {
[10:21:07.609]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:07.609]                         envir = ns)
[10:21:07.609]                       envir <- sys.frame(frame)
[10:21:07.609]                       master <- NULL
[10:21:07.609]                       while (!identical(envir, .GlobalEnv) && 
[10:21:07.609]                         !identical(envir, emptyenv())) {
[10:21:07.609]                         if (exists("master", mode = "list", envir = envir, 
[10:21:07.609]                           inherits = FALSE)) {
[10:21:07.609]                           master <- get("master", mode = "list", 
[10:21:07.609]                             envir = envir, inherits = FALSE)
[10:21:07.609]                           if (inherits(master, c("SOCKnode", 
[10:21:07.609]                             "SOCK0node"))) {
[10:21:07.609]                             sendCondition <<- function(cond) {
[10:21:07.609]                               data <- list(type = "VALUE", value = cond, 
[10:21:07.609]                                 success = TRUE)
[10:21:07.609]                               parallel_sendData(master, data)
[10:21:07.609]                             }
[10:21:07.609]                             return(sendCondition)
[10:21:07.609]                           }
[10:21:07.609]                         }
[10:21:07.609]                         frame <- frame + 1L
[10:21:07.609]                         envir <- sys.frame(frame)
[10:21:07.609]                       }
[10:21:07.609]                     }
[10:21:07.609]                     sendCondition <<- function(cond) NULL
[10:21:07.609]                   }
[10:21:07.609]                 })
[10:21:07.609]                 withCallingHandlers({
[10:21:07.609]                   {
[10:21:07.609]                     42
[10:21:07.609]                   }
[10:21:07.609]                 }, immediateCondition = function(cond) {
[10:21:07.609]                   sendCondition <- ...future.makeSendCondition()
[10:21:07.609]                   sendCondition(cond)
[10:21:07.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.609]                   {
[10:21:07.609]                     inherits <- base::inherits
[10:21:07.609]                     invokeRestart <- base::invokeRestart
[10:21:07.609]                     is.null <- base::is.null
[10:21:07.609]                     muffled <- FALSE
[10:21:07.609]                     if (inherits(cond, "message")) {
[10:21:07.609]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:07.609]                       if (muffled) 
[10:21:07.609]                         invokeRestart("muffleMessage")
[10:21:07.609]                     }
[10:21:07.609]                     else if (inherits(cond, "warning")) {
[10:21:07.609]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:07.609]                       if (muffled) 
[10:21:07.609]                         invokeRestart("muffleWarning")
[10:21:07.609]                     }
[10:21:07.609]                     else if (inherits(cond, "condition")) {
[10:21:07.609]                       if (!is.null(pattern)) {
[10:21:07.609]                         computeRestarts <- base::computeRestarts
[10:21:07.609]                         grepl <- base::grepl
[10:21:07.609]                         restarts <- computeRestarts(cond)
[10:21:07.609]                         for (restart in restarts) {
[10:21:07.609]                           name <- restart$name
[10:21:07.609]                           if (is.null(name)) 
[10:21:07.609]                             next
[10:21:07.609]                           if (!grepl(pattern, name)) 
[10:21:07.609]                             next
[10:21:07.609]                           invokeRestart(restart)
[10:21:07.609]                           muffled <- TRUE
[10:21:07.609]                           break
[10:21:07.609]                         }
[10:21:07.609]                       }
[10:21:07.609]                     }
[10:21:07.609]                     invisible(muffled)
[10:21:07.609]                   }
[10:21:07.609]                   muffleCondition(cond)
[10:21:07.609]                 })
[10:21:07.609]             }))
[10:21:07.609]             future::FutureResult(value = ...future.value$value, 
[10:21:07.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.609]                   ...future.rng), globalenv = if (FALSE) 
[10:21:07.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:07.609]                     ...future.globalenv.names))
[10:21:07.609]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:07.609]         }, condition = base::local({
[10:21:07.609]             c <- base::c
[10:21:07.609]             inherits <- base::inherits
[10:21:07.609]             invokeRestart <- base::invokeRestart
[10:21:07.609]             length <- base::length
[10:21:07.609]             list <- base::list
[10:21:07.609]             seq.int <- base::seq.int
[10:21:07.609]             signalCondition <- base::signalCondition
[10:21:07.609]             sys.calls <- base::sys.calls
[10:21:07.609]             `[[` <- base::`[[`
[10:21:07.609]             `+` <- base::`+`
[10:21:07.609]             `<<-` <- base::`<<-`
[10:21:07.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:07.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:07.609]                   3L)]
[10:21:07.609]             }
[10:21:07.609]             function(cond) {
[10:21:07.609]                 is_error <- inherits(cond, "error")
[10:21:07.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:07.609]                   NULL)
[10:21:07.609]                 if (is_error) {
[10:21:07.609]                   sessionInformation <- function() {
[10:21:07.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:07.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:07.609]                       search = base::search(), system = base::Sys.info())
[10:21:07.609]                   }
[10:21:07.609]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:07.609]                     cond$call), session = sessionInformation(), 
[10:21:07.609]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:07.609]                   signalCondition(cond)
[10:21:07.609]                 }
[10:21:07.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:07.609]                 "immediateCondition"))) {
[10:21:07.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:07.609]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:07.609]                   if (TRUE && !signal) {
[10:21:07.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.609]                     {
[10:21:07.609]                       inherits <- base::inherits
[10:21:07.609]                       invokeRestart <- base::invokeRestart
[10:21:07.609]                       is.null <- base::is.null
[10:21:07.609]                       muffled <- FALSE
[10:21:07.609]                       if (inherits(cond, "message")) {
[10:21:07.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.609]                         if (muffled) 
[10:21:07.609]                           invokeRestart("muffleMessage")
[10:21:07.609]                       }
[10:21:07.609]                       else if (inherits(cond, "warning")) {
[10:21:07.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.609]                         if (muffled) 
[10:21:07.609]                           invokeRestart("muffleWarning")
[10:21:07.609]                       }
[10:21:07.609]                       else if (inherits(cond, "condition")) {
[10:21:07.609]                         if (!is.null(pattern)) {
[10:21:07.609]                           computeRestarts <- base::computeRestarts
[10:21:07.609]                           grepl <- base::grepl
[10:21:07.609]                           restarts <- computeRestarts(cond)
[10:21:07.609]                           for (restart in restarts) {
[10:21:07.609]                             name <- restart$name
[10:21:07.609]                             if (is.null(name)) 
[10:21:07.609]                               next
[10:21:07.609]                             if (!grepl(pattern, name)) 
[10:21:07.609]                               next
[10:21:07.609]                             invokeRestart(restart)
[10:21:07.609]                             muffled <- TRUE
[10:21:07.609]                             break
[10:21:07.609]                           }
[10:21:07.609]                         }
[10:21:07.609]                       }
[10:21:07.609]                       invisible(muffled)
[10:21:07.609]                     }
[10:21:07.609]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.609]                   }
[10:21:07.609]                 }
[10:21:07.609]                 else {
[10:21:07.609]                   if (TRUE) {
[10:21:07.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.609]                     {
[10:21:07.609]                       inherits <- base::inherits
[10:21:07.609]                       invokeRestart <- base::invokeRestart
[10:21:07.609]                       is.null <- base::is.null
[10:21:07.609]                       muffled <- FALSE
[10:21:07.609]                       if (inherits(cond, "message")) {
[10:21:07.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.609]                         if (muffled) 
[10:21:07.609]                           invokeRestart("muffleMessage")
[10:21:07.609]                       }
[10:21:07.609]                       else if (inherits(cond, "warning")) {
[10:21:07.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.609]                         if (muffled) 
[10:21:07.609]                           invokeRestart("muffleWarning")
[10:21:07.609]                       }
[10:21:07.609]                       else if (inherits(cond, "condition")) {
[10:21:07.609]                         if (!is.null(pattern)) {
[10:21:07.609]                           computeRestarts <- base::computeRestarts
[10:21:07.609]                           grepl <- base::grepl
[10:21:07.609]                           restarts <- computeRestarts(cond)
[10:21:07.609]                           for (restart in restarts) {
[10:21:07.609]                             name <- restart$name
[10:21:07.609]                             if (is.null(name)) 
[10:21:07.609]                               next
[10:21:07.609]                             if (!grepl(pattern, name)) 
[10:21:07.609]                               next
[10:21:07.609]                             invokeRestart(restart)
[10:21:07.609]                             muffled <- TRUE
[10:21:07.609]                             break
[10:21:07.609]                           }
[10:21:07.609]                         }
[10:21:07.609]                       }
[10:21:07.609]                       invisible(muffled)
[10:21:07.609]                     }
[10:21:07.609]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.609]                   }
[10:21:07.609]                 }
[10:21:07.609]             }
[10:21:07.609]         }))
[10:21:07.609]     }, error = function(ex) {
[10:21:07.609]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:07.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.609]                 ...future.rng), started = ...future.startTime, 
[10:21:07.609]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:07.609]             version = "1.8"), class = "FutureResult")
[10:21:07.609]     }, finally = {
[10:21:07.609]         if (!identical(...future.workdir, getwd())) 
[10:21:07.609]             setwd(...future.workdir)
[10:21:07.609]         {
[10:21:07.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:07.609]                 ...future.oldOptions$nwarnings <- NULL
[10:21:07.609]             }
[10:21:07.609]             base::options(...future.oldOptions)
[10:21:07.609]             if (.Platform$OS.type == "windows") {
[10:21:07.609]                 old_names <- names(...future.oldEnvVars)
[10:21:07.609]                 envs <- base::Sys.getenv()
[10:21:07.609]                 names <- names(envs)
[10:21:07.609]                 common <- intersect(names, old_names)
[10:21:07.609]                 added <- setdiff(names, old_names)
[10:21:07.609]                 removed <- setdiff(old_names, names)
[10:21:07.609]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:07.609]                   envs[common]]
[10:21:07.609]                 NAMES <- toupper(changed)
[10:21:07.609]                 args <- list()
[10:21:07.609]                 for (kk in seq_along(NAMES)) {
[10:21:07.609]                   name <- changed[[kk]]
[10:21:07.609]                   NAME <- NAMES[[kk]]
[10:21:07.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.609]                     next
[10:21:07.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.609]                 }
[10:21:07.609]                 NAMES <- toupper(added)
[10:21:07.609]                 for (kk in seq_along(NAMES)) {
[10:21:07.609]                   name <- added[[kk]]
[10:21:07.609]                   NAME <- NAMES[[kk]]
[10:21:07.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.609]                     next
[10:21:07.609]                   args[[name]] <- ""
[10:21:07.609]                 }
[10:21:07.609]                 NAMES <- toupper(removed)
[10:21:07.609]                 for (kk in seq_along(NAMES)) {
[10:21:07.609]                   name <- removed[[kk]]
[10:21:07.609]                   NAME <- NAMES[[kk]]
[10:21:07.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.609]                     next
[10:21:07.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.609]                 }
[10:21:07.609]                 if (length(args) > 0) 
[10:21:07.609]                   base::do.call(base::Sys.setenv, args = args)
[10:21:07.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:07.609]             }
[10:21:07.609]             else {
[10:21:07.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:07.609]             }
[10:21:07.609]             {
[10:21:07.609]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:07.609]                   0L) {
[10:21:07.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:07.609]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:07.609]                   base::options(opts)
[10:21:07.609]                 }
[10:21:07.609]                 {
[10:21:07.609]                   {
[10:21:07.609]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:07.609]                     NULL
[10:21:07.609]                   }
[10:21:07.609]                   options(future.plan = NULL)
[10:21:07.609]                   if (is.na(NA_character_)) 
[10:21:07.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:07.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:07.609]                     .init = FALSE)
[10:21:07.609]                 }
[10:21:07.609]             }
[10:21:07.609]         }
[10:21:07.609]     })
[10:21:07.609]     if (TRUE) {
[10:21:07.609]         base::sink(type = "output", split = FALSE)
[10:21:07.609]         if (TRUE) {
[10:21:07.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:07.609]         }
[10:21:07.609]         else {
[10:21:07.609]             ...future.result["stdout"] <- base::list(NULL)
[10:21:07.609]         }
[10:21:07.609]         base::close(...future.stdout)
[10:21:07.609]         ...future.stdout <- NULL
[10:21:07.609]     }
[10:21:07.609]     ...future.result$conditions <- ...future.conditions
[10:21:07.609]     ...future.result$finished <- base::Sys.time()
[10:21:07.609]     ...future.result
[10:21:07.609] }
[10:21:07.613] MultisessionFuture started
[10:21:07.613] - Launch lazy future ... done
[10:21:07.613] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.625] result() for ClusterFuture ...
[10:21:07.625] receiveMessageFromWorker() for ClusterFuture ...
[10:21:07.625] - Validating connection of MultisessionFuture
[10:21:07.655] - received message: FutureResult
[10:21:07.655] - Received FutureResult
[10:21:07.655] - Erased future from FutureRegistry
[10:21:07.656] result() for ClusterFuture ...
[10:21:07.656] - result already collected: FutureResult
[10:21:07.656] result() for ClusterFuture ... done
[10:21:07.656] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:07.656] result() for ClusterFuture ... done
[10:21:07.656] result() for ClusterFuture ...
[10:21:07.656] - result already collected: FutureResult
[10:21:07.656] result() for ClusterFuture ... done
[10:21:07.658] getGlobalsAndPackages() ...
[10:21:07.658] 
[10:21:07.659] - globals: [0] <none>
[10:21:07.659] getGlobalsAndPackages() ... DONE
[10:21:07.672] Packages needed by the future expression (n = 0): <none>
[10:21:07.672] Packages needed by future strategies (n = 0): <none>
[10:21:07.673] {
[10:21:07.673]     {
[10:21:07.673]         {
[10:21:07.673]             ...future.startTime <- base::Sys.time()
[10:21:07.673]             {
[10:21:07.673]                 {
[10:21:07.673]                   {
[10:21:07.673]                     {
[10:21:07.673]                       base::local({
[10:21:07.673]                         has_future <- base::requireNamespace("future", 
[10:21:07.673]                           quietly = TRUE)
[10:21:07.673]                         if (has_future) {
[10:21:07.673]                           ns <- base::getNamespace("future")
[10:21:07.673]                           version <- ns[[".package"]][["version"]]
[10:21:07.673]                           if (is.null(version)) 
[10:21:07.673]                             version <- utils::packageVersion("future")
[10:21:07.673]                         }
[10:21:07.673]                         else {
[10:21:07.673]                           version <- NULL
[10:21:07.673]                         }
[10:21:07.673]                         if (!has_future || version < "1.8.0") {
[10:21:07.673]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:07.673]                             "", base::R.version$version.string), 
[10:21:07.673]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:07.673]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:07.673]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:07.673]                               "release", "version")], collapse = " "), 
[10:21:07.673]                             hostname = base::Sys.info()[["nodename"]])
[10:21:07.673]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:07.673]                             info)
[10:21:07.673]                           info <- base::paste(info, collapse = "; ")
[10:21:07.673]                           if (!has_future) {
[10:21:07.673]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:07.673]                               info)
[10:21:07.673]                           }
[10:21:07.673]                           else {
[10:21:07.673]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:07.673]                               info, version)
[10:21:07.673]                           }
[10:21:07.673]                           base::stop(msg)
[10:21:07.673]                         }
[10:21:07.673]                       })
[10:21:07.673]                     }
[10:21:07.673]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:07.673]                     base::options(mc.cores = 1L)
[10:21:07.673]                   }
[10:21:07.673]                   ...future.strategy.old <- future::plan("list")
[10:21:07.673]                   options(future.plan = NULL)
[10:21:07.673]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.673]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:07.673]                 }
[10:21:07.673]                 ...future.workdir <- getwd()
[10:21:07.673]             }
[10:21:07.673]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:07.673]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:07.673]         }
[10:21:07.673]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:07.673]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:07.673]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:07.673]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:07.673]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:07.673]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:07.673]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:07.673]             base::names(...future.oldOptions))
[10:21:07.673]     }
[10:21:07.673]     if (FALSE) {
[10:21:07.673]     }
[10:21:07.673]     else {
[10:21:07.673]         if (TRUE) {
[10:21:07.673]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:07.673]                 open = "w")
[10:21:07.673]         }
[10:21:07.673]         else {
[10:21:07.673]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:07.673]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:07.673]         }
[10:21:07.673]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:07.673]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:07.673]             base::sink(type = "output", split = FALSE)
[10:21:07.673]             base::close(...future.stdout)
[10:21:07.673]         }, add = TRUE)
[10:21:07.673]     }
[10:21:07.673]     ...future.frame <- base::sys.nframe()
[10:21:07.673]     ...future.conditions <- base::list()
[10:21:07.673]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:07.673]     if (FALSE) {
[10:21:07.673]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:07.673]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:07.673]     }
[10:21:07.673]     ...future.result <- base::tryCatch({
[10:21:07.673]         base::withCallingHandlers({
[10:21:07.673]             ...future.value <- base::withVisible(base::local({
[10:21:07.673]                 ...future.makeSendCondition <- base::local({
[10:21:07.673]                   sendCondition <- NULL
[10:21:07.673]                   function(frame = 1L) {
[10:21:07.673]                     if (is.function(sendCondition)) 
[10:21:07.673]                       return(sendCondition)
[10:21:07.673]                     ns <- getNamespace("parallel")
[10:21:07.673]                     if (exists("sendData", mode = "function", 
[10:21:07.673]                       envir = ns)) {
[10:21:07.673]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:07.673]                         envir = ns)
[10:21:07.673]                       envir <- sys.frame(frame)
[10:21:07.673]                       master <- NULL
[10:21:07.673]                       while (!identical(envir, .GlobalEnv) && 
[10:21:07.673]                         !identical(envir, emptyenv())) {
[10:21:07.673]                         if (exists("master", mode = "list", envir = envir, 
[10:21:07.673]                           inherits = FALSE)) {
[10:21:07.673]                           master <- get("master", mode = "list", 
[10:21:07.673]                             envir = envir, inherits = FALSE)
[10:21:07.673]                           if (inherits(master, c("SOCKnode", 
[10:21:07.673]                             "SOCK0node"))) {
[10:21:07.673]                             sendCondition <<- function(cond) {
[10:21:07.673]                               data <- list(type = "VALUE", value = cond, 
[10:21:07.673]                                 success = TRUE)
[10:21:07.673]                               parallel_sendData(master, data)
[10:21:07.673]                             }
[10:21:07.673]                             return(sendCondition)
[10:21:07.673]                           }
[10:21:07.673]                         }
[10:21:07.673]                         frame <- frame + 1L
[10:21:07.673]                         envir <- sys.frame(frame)
[10:21:07.673]                       }
[10:21:07.673]                     }
[10:21:07.673]                     sendCondition <<- function(cond) NULL
[10:21:07.673]                   }
[10:21:07.673]                 })
[10:21:07.673]                 withCallingHandlers({
[10:21:07.673]                   42
[10:21:07.673]                 }, immediateCondition = function(cond) {
[10:21:07.673]                   sendCondition <- ...future.makeSendCondition()
[10:21:07.673]                   sendCondition(cond)
[10:21:07.673]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.673]                   {
[10:21:07.673]                     inherits <- base::inherits
[10:21:07.673]                     invokeRestart <- base::invokeRestart
[10:21:07.673]                     is.null <- base::is.null
[10:21:07.673]                     muffled <- FALSE
[10:21:07.673]                     if (inherits(cond, "message")) {
[10:21:07.673]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:07.673]                       if (muffled) 
[10:21:07.673]                         invokeRestart("muffleMessage")
[10:21:07.673]                     }
[10:21:07.673]                     else if (inherits(cond, "warning")) {
[10:21:07.673]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:07.673]                       if (muffled) 
[10:21:07.673]                         invokeRestart("muffleWarning")
[10:21:07.673]                     }
[10:21:07.673]                     else if (inherits(cond, "condition")) {
[10:21:07.673]                       if (!is.null(pattern)) {
[10:21:07.673]                         computeRestarts <- base::computeRestarts
[10:21:07.673]                         grepl <- base::grepl
[10:21:07.673]                         restarts <- computeRestarts(cond)
[10:21:07.673]                         for (restart in restarts) {
[10:21:07.673]                           name <- restart$name
[10:21:07.673]                           if (is.null(name)) 
[10:21:07.673]                             next
[10:21:07.673]                           if (!grepl(pattern, name)) 
[10:21:07.673]                             next
[10:21:07.673]                           invokeRestart(restart)
[10:21:07.673]                           muffled <- TRUE
[10:21:07.673]                           break
[10:21:07.673]                         }
[10:21:07.673]                       }
[10:21:07.673]                     }
[10:21:07.673]                     invisible(muffled)
[10:21:07.673]                   }
[10:21:07.673]                   muffleCondition(cond)
[10:21:07.673]                 })
[10:21:07.673]             }))
[10:21:07.673]             future::FutureResult(value = ...future.value$value, 
[10:21:07.673]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.673]                   ...future.rng), globalenv = if (FALSE) 
[10:21:07.673]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:07.673]                     ...future.globalenv.names))
[10:21:07.673]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:07.673]         }, condition = base::local({
[10:21:07.673]             c <- base::c
[10:21:07.673]             inherits <- base::inherits
[10:21:07.673]             invokeRestart <- base::invokeRestart
[10:21:07.673]             length <- base::length
[10:21:07.673]             list <- base::list
[10:21:07.673]             seq.int <- base::seq.int
[10:21:07.673]             signalCondition <- base::signalCondition
[10:21:07.673]             sys.calls <- base::sys.calls
[10:21:07.673]             `[[` <- base::`[[`
[10:21:07.673]             `+` <- base::`+`
[10:21:07.673]             `<<-` <- base::`<<-`
[10:21:07.673]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:07.673]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:07.673]                   3L)]
[10:21:07.673]             }
[10:21:07.673]             function(cond) {
[10:21:07.673]                 is_error <- inherits(cond, "error")
[10:21:07.673]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:07.673]                   NULL)
[10:21:07.673]                 if (is_error) {
[10:21:07.673]                   sessionInformation <- function() {
[10:21:07.673]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:07.673]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:07.673]                       search = base::search(), system = base::Sys.info())
[10:21:07.673]                   }
[10:21:07.673]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.673]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:07.673]                     cond$call), session = sessionInformation(), 
[10:21:07.673]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:07.673]                   signalCondition(cond)
[10:21:07.673]                 }
[10:21:07.673]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:07.673]                 "immediateCondition"))) {
[10:21:07.673]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:07.673]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.673]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:07.673]                   if (TRUE && !signal) {
[10:21:07.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.673]                     {
[10:21:07.673]                       inherits <- base::inherits
[10:21:07.673]                       invokeRestart <- base::invokeRestart
[10:21:07.673]                       is.null <- base::is.null
[10:21:07.673]                       muffled <- FALSE
[10:21:07.673]                       if (inherits(cond, "message")) {
[10:21:07.673]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.673]                         if (muffled) 
[10:21:07.673]                           invokeRestart("muffleMessage")
[10:21:07.673]                       }
[10:21:07.673]                       else if (inherits(cond, "warning")) {
[10:21:07.673]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.673]                         if (muffled) 
[10:21:07.673]                           invokeRestart("muffleWarning")
[10:21:07.673]                       }
[10:21:07.673]                       else if (inherits(cond, "condition")) {
[10:21:07.673]                         if (!is.null(pattern)) {
[10:21:07.673]                           computeRestarts <- base::computeRestarts
[10:21:07.673]                           grepl <- base::grepl
[10:21:07.673]                           restarts <- computeRestarts(cond)
[10:21:07.673]                           for (restart in restarts) {
[10:21:07.673]                             name <- restart$name
[10:21:07.673]                             if (is.null(name)) 
[10:21:07.673]                               next
[10:21:07.673]                             if (!grepl(pattern, name)) 
[10:21:07.673]                               next
[10:21:07.673]                             invokeRestart(restart)
[10:21:07.673]                             muffled <- TRUE
[10:21:07.673]                             break
[10:21:07.673]                           }
[10:21:07.673]                         }
[10:21:07.673]                       }
[10:21:07.673]                       invisible(muffled)
[10:21:07.673]                     }
[10:21:07.673]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.673]                   }
[10:21:07.673]                 }
[10:21:07.673]                 else {
[10:21:07.673]                   if (TRUE) {
[10:21:07.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.673]                     {
[10:21:07.673]                       inherits <- base::inherits
[10:21:07.673]                       invokeRestart <- base::invokeRestart
[10:21:07.673]                       is.null <- base::is.null
[10:21:07.673]                       muffled <- FALSE
[10:21:07.673]                       if (inherits(cond, "message")) {
[10:21:07.673]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.673]                         if (muffled) 
[10:21:07.673]                           invokeRestart("muffleMessage")
[10:21:07.673]                       }
[10:21:07.673]                       else if (inherits(cond, "warning")) {
[10:21:07.673]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.673]                         if (muffled) 
[10:21:07.673]                           invokeRestart("muffleWarning")
[10:21:07.673]                       }
[10:21:07.673]                       else if (inherits(cond, "condition")) {
[10:21:07.673]                         if (!is.null(pattern)) {
[10:21:07.673]                           computeRestarts <- base::computeRestarts
[10:21:07.673]                           grepl <- base::grepl
[10:21:07.673]                           restarts <- computeRestarts(cond)
[10:21:07.673]                           for (restart in restarts) {
[10:21:07.673]                             name <- restart$name
[10:21:07.673]                             if (is.null(name)) 
[10:21:07.673]                               next
[10:21:07.673]                             if (!grepl(pattern, name)) 
[10:21:07.673]                               next
[10:21:07.673]                             invokeRestart(restart)
[10:21:07.673]                             muffled <- TRUE
[10:21:07.673]                             break
[10:21:07.673]                           }
[10:21:07.673]                         }
[10:21:07.673]                       }
[10:21:07.673]                       invisible(muffled)
[10:21:07.673]                     }
[10:21:07.673]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.673]                   }
[10:21:07.673]                 }
[10:21:07.673]             }
[10:21:07.673]         }))
[10:21:07.673]     }, error = function(ex) {
[10:21:07.673]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:07.673]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.673]                 ...future.rng), started = ...future.startTime, 
[10:21:07.673]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:07.673]             version = "1.8"), class = "FutureResult")
[10:21:07.673]     }, finally = {
[10:21:07.673]         if (!identical(...future.workdir, getwd())) 
[10:21:07.673]             setwd(...future.workdir)
[10:21:07.673]         {
[10:21:07.673]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:07.673]                 ...future.oldOptions$nwarnings <- NULL
[10:21:07.673]             }
[10:21:07.673]             base::options(...future.oldOptions)
[10:21:07.673]             if (.Platform$OS.type == "windows") {
[10:21:07.673]                 old_names <- names(...future.oldEnvVars)
[10:21:07.673]                 envs <- base::Sys.getenv()
[10:21:07.673]                 names <- names(envs)
[10:21:07.673]                 common <- intersect(names, old_names)
[10:21:07.673]                 added <- setdiff(names, old_names)
[10:21:07.673]                 removed <- setdiff(old_names, names)
[10:21:07.673]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:07.673]                   envs[common]]
[10:21:07.673]                 NAMES <- toupper(changed)
[10:21:07.673]                 args <- list()
[10:21:07.673]                 for (kk in seq_along(NAMES)) {
[10:21:07.673]                   name <- changed[[kk]]
[10:21:07.673]                   NAME <- NAMES[[kk]]
[10:21:07.673]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.673]                     next
[10:21:07.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.673]                 }
[10:21:07.673]                 NAMES <- toupper(added)
[10:21:07.673]                 for (kk in seq_along(NAMES)) {
[10:21:07.673]                   name <- added[[kk]]
[10:21:07.673]                   NAME <- NAMES[[kk]]
[10:21:07.673]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.673]                     next
[10:21:07.673]                   args[[name]] <- ""
[10:21:07.673]                 }
[10:21:07.673]                 NAMES <- toupper(removed)
[10:21:07.673]                 for (kk in seq_along(NAMES)) {
[10:21:07.673]                   name <- removed[[kk]]
[10:21:07.673]                   NAME <- NAMES[[kk]]
[10:21:07.673]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.673]                     next
[10:21:07.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.673]                 }
[10:21:07.673]                 if (length(args) > 0) 
[10:21:07.673]                   base::do.call(base::Sys.setenv, args = args)
[10:21:07.673]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:07.673]             }
[10:21:07.673]             else {
[10:21:07.673]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:07.673]             }
[10:21:07.673]             {
[10:21:07.673]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:07.673]                   0L) {
[10:21:07.673]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:07.673]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:07.673]                   base::options(opts)
[10:21:07.673]                 }
[10:21:07.673]                 {
[10:21:07.673]                   {
[10:21:07.673]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:07.673]                     NULL
[10:21:07.673]                   }
[10:21:07.673]                   options(future.plan = NULL)
[10:21:07.673]                   if (is.na(NA_character_)) 
[10:21:07.673]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.673]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:07.673]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:07.673]                     .init = FALSE)
[10:21:07.673]                 }
[10:21:07.673]             }
[10:21:07.673]         }
[10:21:07.673]     })
[10:21:07.673]     if (TRUE) {
[10:21:07.673]         base::sink(type = "output", split = FALSE)
[10:21:07.673]         if (TRUE) {
[10:21:07.673]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:07.673]         }
[10:21:07.673]         else {
[10:21:07.673]             ...future.result["stdout"] <- base::list(NULL)
[10:21:07.673]         }
[10:21:07.673]         base::close(...future.stdout)
[10:21:07.673]         ...future.stdout <- NULL
[10:21:07.673]     }
[10:21:07.673]     ...future.result$conditions <- ...future.conditions
[10:21:07.673]     ...future.result$finished <- base::Sys.time()
[10:21:07.673]     ...future.result
[10:21:07.673] }
[10:21:07.676] MultisessionFuture started
MultisessionFuture:
Label: ‘strategy = multisession’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.687] result() for ClusterFuture ...
[10:21:07.687] receiveMessageFromWorker() for ClusterFuture ...
[10:21:07.687] - Validating connection of MultisessionFuture
[10:21:07.718] - received message: FutureResult
[10:21:07.718] - Received FutureResult
[10:21:07.719] - Erased future from FutureRegistry
[10:21:07.719] result() for ClusterFuture ...
[10:21:07.719] - result already collected: FutureResult
[10:21:07.719] result() for ClusterFuture ... done
[10:21:07.719] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:07.719] result() for ClusterFuture ... done
[10:21:07.719] result() for ClusterFuture ...
[10:21:07.719] - result already collected: FutureResult
[10:21:07.719] result() for ClusterFuture ... done
[10:21:07.720] getGlobalsAndPackages() ...
[10:21:07.720] Searching for globals...
[10:21:07.720] 
[10:21:07.720] Searching for globals ... DONE
[10:21:07.721] - globals: [0] <none>
[10:21:07.721] getGlobalsAndPackages() ... DONE
[10:21:07.721] run() for ‘Future’ ...
[10:21:07.721] - state: ‘created’
[10:21:07.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:07.736] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:07.736]   - Field: ‘node’
[10:21:07.736]   - Field: ‘label’
[10:21:07.736]   - Field: ‘local’
[10:21:07.736]   - Field: ‘owner’
[10:21:07.737]   - Field: ‘envir’
[10:21:07.737]   - Field: ‘workers’
[10:21:07.737]   - Field: ‘packages’
[10:21:07.737]   - Field: ‘gc’
[10:21:07.737]   - Field: ‘conditions’
[10:21:07.737]   - Field: ‘persistent’
[10:21:07.737]   - Field: ‘expr’
[10:21:07.737]   - Field: ‘uuid’
[10:21:07.737]   - Field: ‘seed’
[10:21:07.738]   - Field: ‘version’
[10:21:07.738]   - Field: ‘result’
[10:21:07.738]   - Field: ‘asynchronous’
[10:21:07.738]   - Field: ‘calls’
[10:21:07.738]   - Field: ‘globals’
[10:21:07.738]   - Field: ‘stdout’
[10:21:07.738]   - Field: ‘earlySignal’
[10:21:07.738]   - Field: ‘lazy’
[10:21:07.738]   - Field: ‘state’
[10:21:07.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:07.739] - Launch lazy future ...
[10:21:07.739] Packages needed by the future expression (n = 0): <none>
[10:21:07.739] Packages needed by future strategies (n = 0): <none>
[10:21:07.740] {
[10:21:07.740]     {
[10:21:07.740]         {
[10:21:07.740]             ...future.startTime <- base::Sys.time()
[10:21:07.740]             {
[10:21:07.740]                 {
[10:21:07.740]                   {
[10:21:07.740]                     {
[10:21:07.740]                       base::local({
[10:21:07.740]                         has_future <- base::requireNamespace("future", 
[10:21:07.740]                           quietly = TRUE)
[10:21:07.740]                         if (has_future) {
[10:21:07.740]                           ns <- base::getNamespace("future")
[10:21:07.740]                           version <- ns[[".package"]][["version"]]
[10:21:07.740]                           if (is.null(version)) 
[10:21:07.740]                             version <- utils::packageVersion("future")
[10:21:07.740]                         }
[10:21:07.740]                         else {
[10:21:07.740]                           version <- NULL
[10:21:07.740]                         }
[10:21:07.740]                         if (!has_future || version < "1.8.0") {
[10:21:07.740]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:07.740]                             "", base::R.version$version.string), 
[10:21:07.740]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:07.740]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:07.740]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:07.740]                               "release", "version")], collapse = " "), 
[10:21:07.740]                             hostname = base::Sys.info()[["nodename"]])
[10:21:07.740]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:07.740]                             info)
[10:21:07.740]                           info <- base::paste(info, collapse = "; ")
[10:21:07.740]                           if (!has_future) {
[10:21:07.740]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:07.740]                               info)
[10:21:07.740]                           }
[10:21:07.740]                           else {
[10:21:07.740]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:07.740]                               info, version)
[10:21:07.740]                           }
[10:21:07.740]                           base::stop(msg)
[10:21:07.740]                         }
[10:21:07.740]                       })
[10:21:07.740]                     }
[10:21:07.740]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:07.740]                     base::options(mc.cores = 1L)
[10:21:07.740]                   }
[10:21:07.740]                   ...future.strategy.old <- future::plan("list")
[10:21:07.740]                   options(future.plan = NULL)
[10:21:07.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:07.740]                 }
[10:21:07.740]                 ...future.workdir <- getwd()
[10:21:07.740]             }
[10:21:07.740]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:07.740]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:07.740]         }
[10:21:07.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:07.740]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:07.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:07.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:07.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:07.740]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:07.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:07.740]             base::names(...future.oldOptions))
[10:21:07.740]     }
[10:21:07.740]     if (FALSE) {
[10:21:07.740]     }
[10:21:07.740]     else {
[10:21:07.740]         if (TRUE) {
[10:21:07.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:07.740]                 open = "w")
[10:21:07.740]         }
[10:21:07.740]         else {
[10:21:07.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:07.740]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:07.740]         }
[10:21:07.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:07.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:07.740]             base::sink(type = "output", split = FALSE)
[10:21:07.740]             base::close(...future.stdout)
[10:21:07.740]         }, add = TRUE)
[10:21:07.740]     }
[10:21:07.740]     ...future.frame <- base::sys.nframe()
[10:21:07.740]     ...future.conditions <- base::list()
[10:21:07.740]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:07.740]     if (FALSE) {
[10:21:07.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:07.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:07.740]     }
[10:21:07.740]     ...future.result <- base::tryCatch({
[10:21:07.740]         base::withCallingHandlers({
[10:21:07.740]             ...future.value <- base::withVisible(base::local({
[10:21:07.740]                 ...future.makeSendCondition <- base::local({
[10:21:07.740]                   sendCondition <- NULL
[10:21:07.740]                   function(frame = 1L) {
[10:21:07.740]                     if (is.function(sendCondition)) 
[10:21:07.740]                       return(sendCondition)
[10:21:07.740]                     ns <- getNamespace("parallel")
[10:21:07.740]                     if (exists("sendData", mode = "function", 
[10:21:07.740]                       envir = ns)) {
[10:21:07.740]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:07.740]                         envir = ns)
[10:21:07.740]                       envir <- sys.frame(frame)
[10:21:07.740]                       master <- NULL
[10:21:07.740]                       while (!identical(envir, .GlobalEnv) && 
[10:21:07.740]                         !identical(envir, emptyenv())) {
[10:21:07.740]                         if (exists("master", mode = "list", envir = envir, 
[10:21:07.740]                           inherits = FALSE)) {
[10:21:07.740]                           master <- get("master", mode = "list", 
[10:21:07.740]                             envir = envir, inherits = FALSE)
[10:21:07.740]                           if (inherits(master, c("SOCKnode", 
[10:21:07.740]                             "SOCK0node"))) {
[10:21:07.740]                             sendCondition <<- function(cond) {
[10:21:07.740]                               data <- list(type = "VALUE", value = cond, 
[10:21:07.740]                                 success = TRUE)
[10:21:07.740]                               parallel_sendData(master, data)
[10:21:07.740]                             }
[10:21:07.740]                             return(sendCondition)
[10:21:07.740]                           }
[10:21:07.740]                         }
[10:21:07.740]                         frame <- frame + 1L
[10:21:07.740]                         envir <- sys.frame(frame)
[10:21:07.740]                       }
[10:21:07.740]                     }
[10:21:07.740]                     sendCondition <<- function(cond) NULL
[10:21:07.740]                   }
[10:21:07.740]                 })
[10:21:07.740]                 withCallingHandlers({
[10:21:07.740]                   42
[10:21:07.740]                 }, immediateCondition = function(cond) {
[10:21:07.740]                   sendCondition <- ...future.makeSendCondition()
[10:21:07.740]                   sendCondition(cond)
[10:21:07.740]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.740]                   {
[10:21:07.740]                     inherits <- base::inherits
[10:21:07.740]                     invokeRestart <- base::invokeRestart
[10:21:07.740]                     is.null <- base::is.null
[10:21:07.740]                     muffled <- FALSE
[10:21:07.740]                     if (inherits(cond, "message")) {
[10:21:07.740]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:07.740]                       if (muffled) 
[10:21:07.740]                         invokeRestart("muffleMessage")
[10:21:07.740]                     }
[10:21:07.740]                     else if (inherits(cond, "warning")) {
[10:21:07.740]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:07.740]                       if (muffled) 
[10:21:07.740]                         invokeRestart("muffleWarning")
[10:21:07.740]                     }
[10:21:07.740]                     else if (inherits(cond, "condition")) {
[10:21:07.740]                       if (!is.null(pattern)) {
[10:21:07.740]                         computeRestarts <- base::computeRestarts
[10:21:07.740]                         grepl <- base::grepl
[10:21:07.740]                         restarts <- computeRestarts(cond)
[10:21:07.740]                         for (restart in restarts) {
[10:21:07.740]                           name <- restart$name
[10:21:07.740]                           if (is.null(name)) 
[10:21:07.740]                             next
[10:21:07.740]                           if (!grepl(pattern, name)) 
[10:21:07.740]                             next
[10:21:07.740]                           invokeRestart(restart)
[10:21:07.740]                           muffled <- TRUE
[10:21:07.740]                           break
[10:21:07.740]                         }
[10:21:07.740]                       }
[10:21:07.740]                     }
[10:21:07.740]                     invisible(muffled)
[10:21:07.740]                   }
[10:21:07.740]                   muffleCondition(cond)
[10:21:07.740]                 })
[10:21:07.740]             }))
[10:21:07.740]             future::FutureResult(value = ...future.value$value, 
[10:21:07.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.740]                   ...future.rng), globalenv = if (FALSE) 
[10:21:07.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:07.740]                     ...future.globalenv.names))
[10:21:07.740]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:07.740]         }, condition = base::local({
[10:21:07.740]             c <- base::c
[10:21:07.740]             inherits <- base::inherits
[10:21:07.740]             invokeRestart <- base::invokeRestart
[10:21:07.740]             length <- base::length
[10:21:07.740]             list <- base::list
[10:21:07.740]             seq.int <- base::seq.int
[10:21:07.740]             signalCondition <- base::signalCondition
[10:21:07.740]             sys.calls <- base::sys.calls
[10:21:07.740]             `[[` <- base::`[[`
[10:21:07.740]             `+` <- base::`+`
[10:21:07.740]             `<<-` <- base::`<<-`
[10:21:07.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:07.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:07.740]                   3L)]
[10:21:07.740]             }
[10:21:07.740]             function(cond) {
[10:21:07.740]                 is_error <- inherits(cond, "error")
[10:21:07.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:07.740]                   NULL)
[10:21:07.740]                 if (is_error) {
[10:21:07.740]                   sessionInformation <- function() {
[10:21:07.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:07.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:07.740]                       search = base::search(), system = base::Sys.info())
[10:21:07.740]                   }
[10:21:07.740]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:07.740]                     cond$call), session = sessionInformation(), 
[10:21:07.740]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:07.740]                   signalCondition(cond)
[10:21:07.740]                 }
[10:21:07.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:07.740]                 "immediateCondition"))) {
[10:21:07.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:07.740]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:07.740]                   if (TRUE && !signal) {
[10:21:07.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.740]                     {
[10:21:07.740]                       inherits <- base::inherits
[10:21:07.740]                       invokeRestart <- base::invokeRestart
[10:21:07.740]                       is.null <- base::is.null
[10:21:07.740]                       muffled <- FALSE
[10:21:07.740]                       if (inherits(cond, "message")) {
[10:21:07.740]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.740]                         if (muffled) 
[10:21:07.740]                           invokeRestart("muffleMessage")
[10:21:07.740]                       }
[10:21:07.740]                       else if (inherits(cond, "warning")) {
[10:21:07.740]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.740]                         if (muffled) 
[10:21:07.740]                           invokeRestart("muffleWarning")
[10:21:07.740]                       }
[10:21:07.740]                       else if (inherits(cond, "condition")) {
[10:21:07.740]                         if (!is.null(pattern)) {
[10:21:07.740]                           computeRestarts <- base::computeRestarts
[10:21:07.740]                           grepl <- base::grepl
[10:21:07.740]                           restarts <- computeRestarts(cond)
[10:21:07.740]                           for (restart in restarts) {
[10:21:07.740]                             name <- restart$name
[10:21:07.740]                             if (is.null(name)) 
[10:21:07.740]                               next
[10:21:07.740]                             if (!grepl(pattern, name)) 
[10:21:07.740]                               next
[10:21:07.740]                             invokeRestart(restart)
[10:21:07.740]                             muffled <- TRUE
[10:21:07.740]                             break
[10:21:07.740]                           }
[10:21:07.740]                         }
[10:21:07.740]                       }
[10:21:07.740]                       invisible(muffled)
[10:21:07.740]                     }
[10:21:07.740]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.740]                   }
[10:21:07.740]                 }
[10:21:07.740]                 else {
[10:21:07.740]                   if (TRUE) {
[10:21:07.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.740]                     {
[10:21:07.740]                       inherits <- base::inherits
[10:21:07.740]                       invokeRestart <- base::invokeRestart
[10:21:07.740]                       is.null <- base::is.null
[10:21:07.740]                       muffled <- FALSE
[10:21:07.740]                       if (inherits(cond, "message")) {
[10:21:07.740]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.740]                         if (muffled) 
[10:21:07.740]                           invokeRestart("muffleMessage")
[10:21:07.740]                       }
[10:21:07.740]                       else if (inherits(cond, "warning")) {
[10:21:07.740]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.740]                         if (muffled) 
[10:21:07.740]                           invokeRestart("muffleWarning")
[10:21:07.740]                       }
[10:21:07.740]                       else if (inherits(cond, "condition")) {
[10:21:07.740]                         if (!is.null(pattern)) {
[10:21:07.740]                           computeRestarts <- base::computeRestarts
[10:21:07.740]                           grepl <- base::grepl
[10:21:07.740]                           restarts <- computeRestarts(cond)
[10:21:07.740]                           for (restart in restarts) {
[10:21:07.740]                             name <- restart$name
[10:21:07.740]                             if (is.null(name)) 
[10:21:07.740]                               next
[10:21:07.740]                             if (!grepl(pattern, name)) 
[10:21:07.740]                               next
[10:21:07.740]                             invokeRestart(restart)
[10:21:07.740]                             muffled <- TRUE
[10:21:07.740]                             break
[10:21:07.740]                           }
[10:21:07.740]                         }
[10:21:07.740]                       }
[10:21:07.740]                       invisible(muffled)
[10:21:07.740]                     }
[10:21:07.740]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.740]                   }
[10:21:07.740]                 }
[10:21:07.740]             }
[10:21:07.740]         }))
[10:21:07.740]     }, error = function(ex) {
[10:21:07.740]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:07.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.740]                 ...future.rng), started = ...future.startTime, 
[10:21:07.740]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:07.740]             version = "1.8"), class = "FutureResult")
[10:21:07.740]     }, finally = {
[10:21:07.740]         if (!identical(...future.workdir, getwd())) 
[10:21:07.740]             setwd(...future.workdir)
[10:21:07.740]         {
[10:21:07.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:07.740]                 ...future.oldOptions$nwarnings <- NULL
[10:21:07.740]             }
[10:21:07.740]             base::options(...future.oldOptions)
[10:21:07.740]             if (.Platform$OS.type == "windows") {
[10:21:07.740]                 old_names <- names(...future.oldEnvVars)
[10:21:07.740]                 envs <- base::Sys.getenv()
[10:21:07.740]                 names <- names(envs)
[10:21:07.740]                 common <- intersect(names, old_names)
[10:21:07.740]                 added <- setdiff(names, old_names)
[10:21:07.740]                 removed <- setdiff(old_names, names)
[10:21:07.740]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:07.740]                   envs[common]]
[10:21:07.740]                 NAMES <- toupper(changed)
[10:21:07.740]                 args <- list()
[10:21:07.740]                 for (kk in seq_along(NAMES)) {
[10:21:07.740]                   name <- changed[[kk]]
[10:21:07.740]                   NAME <- NAMES[[kk]]
[10:21:07.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.740]                     next
[10:21:07.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.740]                 }
[10:21:07.740]                 NAMES <- toupper(added)
[10:21:07.740]                 for (kk in seq_along(NAMES)) {
[10:21:07.740]                   name <- added[[kk]]
[10:21:07.740]                   NAME <- NAMES[[kk]]
[10:21:07.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.740]                     next
[10:21:07.740]                   args[[name]] <- ""
[10:21:07.740]                 }
[10:21:07.740]                 NAMES <- toupper(removed)
[10:21:07.740]                 for (kk in seq_along(NAMES)) {
[10:21:07.740]                   name <- removed[[kk]]
[10:21:07.740]                   NAME <- NAMES[[kk]]
[10:21:07.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.740]                     next
[10:21:07.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.740]                 }
[10:21:07.740]                 if (length(args) > 0) 
[10:21:07.740]                   base::do.call(base::Sys.setenv, args = args)
[10:21:07.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:07.740]             }
[10:21:07.740]             else {
[10:21:07.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:07.740]             }
[10:21:07.740]             {
[10:21:07.740]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:07.740]                   0L) {
[10:21:07.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:07.740]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:07.740]                   base::options(opts)
[10:21:07.740]                 }
[10:21:07.740]                 {
[10:21:07.740]                   {
[10:21:07.740]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:07.740]                     NULL
[10:21:07.740]                   }
[10:21:07.740]                   options(future.plan = NULL)
[10:21:07.740]                   if (is.na(NA_character_)) 
[10:21:07.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:07.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:07.740]                     .init = FALSE)
[10:21:07.740]                 }
[10:21:07.740]             }
[10:21:07.740]         }
[10:21:07.740]     })
[10:21:07.740]     if (TRUE) {
[10:21:07.740]         base::sink(type = "output", split = FALSE)
[10:21:07.740]         if (TRUE) {
[10:21:07.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:07.740]         }
[10:21:07.740]         else {
[10:21:07.740]             ...future.result["stdout"] <- base::list(NULL)
[10:21:07.740]         }
[10:21:07.740]         base::close(...future.stdout)
[10:21:07.740]         ...future.stdout <- NULL
[10:21:07.740]     }
[10:21:07.740]     ...future.result$conditions <- ...future.conditions
[10:21:07.740]     ...future.result$finished <- base::Sys.time()
[10:21:07.740]     ...future.result
[10:21:07.740] }
[10:21:07.743] MultisessionFuture started
[10:21:07.743] - Launch lazy future ... done
[10:21:07.743] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘strategy = multisession’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.755] result() for ClusterFuture ...
[10:21:07.755] receiveMessageFromWorker() for ClusterFuture ...
[10:21:07.755] - Validating connection of MultisessionFuture
[10:21:07.785] - received message: FutureResult
[10:21:07.786] - Received FutureResult
[10:21:07.786] - Erased future from FutureRegistry
[10:21:07.786] result() for ClusterFuture ...
[10:21:07.786] - result already collected: FutureResult
[10:21:07.786] result() for ClusterFuture ... done
[10:21:07.786] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:07.786] result() for ClusterFuture ... done
[10:21:07.786] result() for ClusterFuture ...
[10:21:07.787] - result already collected: FutureResult
[10:21:07.787] result() for ClusterFuture ... done
[10:21:07.787] getGlobalsAndPackages() ...
[10:21:07.787] Searching for globals...
[10:21:07.788] - globals found: [1] ‘{’
[10:21:07.788] Searching for globals ... DONE
[10:21:07.788] Resolving globals: FALSE
[10:21:07.789] 
[10:21:07.789] 
[10:21:07.789] getGlobalsAndPackages() ... DONE
[10:21:07.789] run() for ‘Future’ ...
[10:21:07.789] - state: ‘created’
[10:21:07.789] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:07.804] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.804] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:07.805]   - Field: ‘node’
[10:21:07.805]   - Field: ‘label’
[10:21:07.805]   - Field: ‘local’
[10:21:07.805]   - Field: ‘owner’
[10:21:07.805]   - Field: ‘envir’
[10:21:07.805]   - Field: ‘workers’
[10:21:07.805]   - Field: ‘packages’
[10:21:07.805]   - Field: ‘gc’
[10:21:07.805]   - Field: ‘conditions’
[10:21:07.805]   - Field: ‘persistent’
[10:21:07.806]   - Field: ‘expr’
[10:21:07.806]   - Field: ‘uuid’
[10:21:07.806]   - Field: ‘seed’
[10:21:07.806]   - Field: ‘version’
[10:21:07.806]   - Field: ‘result’
[10:21:07.806]   - Field: ‘asynchronous’
[10:21:07.806]   - Field: ‘calls’
[10:21:07.806]   - Field: ‘globals’
[10:21:07.806]   - Field: ‘stdout’
[10:21:07.807]   - Field: ‘earlySignal’
[10:21:07.807]   - Field: ‘lazy’
[10:21:07.807]   - Field: ‘state’
[10:21:07.807] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:07.807] - Launch lazy future ...
[10:21:07.807] Packages needed by the future expression (n = 0): <none>
[10:21:07.807] Packages needed by future strategies (n = 0): <none>
[10:21:07.808] {
[10:21:07.808]     {
[10:21:07.808]         {
[10:21:07.808]             ...future.startTime <- base::Sys.time()
[10:21:07.808]             {
[10:21:07.808]                 {
[10:21:07.808]                   {
[10:21:07.808]                     {
[10:21:07.808]                       base::local({
[10:21:07.808]                         has_future <- base::requireNamespace("future", 
[10:21:07.808]                           quietly = TRUE)
[10:21:07.808]                         if (has_future) {
[10:21:07.808]                           ns <- base::getNamespace("future")
[10:21:07.808]                           version <- ns[[".package"]][["version"]]
[10:21:07.808]                           if (is.null(version)) 
[10:21:07.808]                             version <- utils::packageVersion("future")
[10:21:07.808]                         }
[10:21:07.808]                         else {
[10:21:07.808]                           version <- NULL
[10:21:07.808]                         }
[10:21:07.808]                         if (!has_future || version < "1.8.0") {
[10:21:07.808]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:07.808]                             "", base::R.version$version.string), 
[10:21:07.808]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:07.808]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:07.808]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:07.808]                               "release", "version")], collapse = " "), 
[10:21:07.808]                             hostname = base::Sys.info()[["nodename"]])
[10:21:07.808]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:07.808]                             info)
[10:21:07.808]                           info <- base::paste(info, collapse = "; ")
[10:21:07.808]                           if (!has_future) {
[10:21:07.808]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:07.808]                               info)
[10:21:07.808]                           }
[10:21:07.808]                           else {
[10:21:07.808]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:07.808]                               info, version)
[10:21:07.808]                           }
[10:21:07.808]                           base::stop(msg)
[10:21:07.808]                         }
[10:21:07.808]                       })
[10:21:07.808]                     }
[10:21:07.808]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:07.808]                     base::options(mc.cores = 1L)
[10:21:07.808]                   }
[10:21:07.808]                   ...future.strategy.old <- future::plan("list")
[10:21:07.808]                   options(future.plan = NULL)
[10:21:07.808]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.808]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:07.808]                 }
[10:21:07.808]                 ...future.workdir <- getwd()
[10:21:07.808]             }
[10:21:07.808]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:07.808]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:07.808]         }
[10:21:07.808]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:07.808]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:07.808]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:07.808]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:07.808]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:07.808]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:07.808]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:07.808]             base::names(...future.oldOptions))
[10:21:07.808]     }
[10:21:07.808]     if (FALSE) {
[10:21:07.808]     }
[10:21:07.808]     else {
[10:21:07.808]         if (TRUE) {
[10:21:07.808]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:07.808]                 open = "w")
[10:21:07.808]         }
[10:21:07.808]         else {
[10:21:07.808]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:07.808]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:07.808]         }
[10:21:07.808]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:07.808]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:07.808]             base::sink(type = "output", split = FALSE)
[10:21:07.808]             base::close(...future.stdout)
[10:21:07.808]         }, add = TRUE)
[10:21:07.808]     }
[10:21:07.808]     ...future.frame <- base::sys.nframe()
[10:21:07.808]     ...future.conditions <- base::list()
[10:21:07.808]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:07.808]     if (FALSE) {
[10:21:07.808]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:07.808]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:07.808]     }
[10:21:07.808]     ...future.result <- base::tryCatch({
[10:21:07.808]         base::withCallingHandlers({
[10:21:07.808]             ...future.value <- base::withVisible(base::local({
[10:21:07.808]                 ...future.makeSendCondition <- base::local({
[10:21:07.808]                   sendCondition <- NULL
[10:21:07.808]                   function(frame = 1L) {
[10:21:07.808]                     if (is.function(sendCondition)) 
[10:21:07.808]                       return(sendCondition)
[10:21:07.808]                     ns <- getNamespace("parallel")
[10:21:07.808]                     if (exists("sendData", mode = "function", 
[10:21:07.808]                       envir = ns)) {
[10:21:07.808]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:07.808]                         envir = ns)
[10:21:07.808]                       envir <- sys.frame(frame)
[10:21:07.808]                       master <- NULL
[10:21:07.808]                       while (!identical(envir, .GlobalEnv) && 
[10:21:07.808]                         !identical(envir, emptyenv())) {
[10:21:07.808]                         if (exists("master", mode = "list", envir = envir, 
[10:21:07.808]                           inherits = FALSE)) {
[10:21:07.808]                           master <- get("master", mode = "list", 
[10:21:07.808]                             envir = envir, inherits = FALSE)
[10:21:07.808]                           if (inherits(master, c("SOCKnode", 
[10:21:07.808]                             "SOCK0node"))) {
[10:21:07.808]                             sendCondition <<- function(cond) {
[10:21:07.808]                               data <- list(type = "VALUE", value = cond, 
[10:21:07.808]                                 success = TRUE)
[10:21:07.808]                               parallel_sendData(master, data)
[10:21:07.808]                             }
[10:21:07.808]                             return(sendCondition)
[10:21:07.808]                           }
[10:21:07.808]                         }
[10:21:07.808]                         frame <- frame + 1L
[10:21:07.808]                         envir <- sys.frame(frame)
[10:21:07.808]                       }
[10:21:07.808]                     }
[10:21:07.808]                     sendCondition <<- function(cond) NULL
[10:21:07.808]                   }
[10:21:07.808]                 })
[10:21:07.808]                 withCallingHandlers({
[10:21:07.808]                   {
[10:21:07.808]                     42
[10:21:07.808]                   }
[10:21:07.808]                 }, immediateCondition = function(cond) {
[10:21:07.808]                   sendCondition <- ...future.makeSendCondition()
[10:21:07.808]                   sendCondition(cond)
[10:21:07.808]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.808]                   {
[10:21:07.808]                     inherits <- base::inherits
[10:21:07.808]                     invokeRestart <- base::invokeRestart
[10:21:07.808]                     is.null <- base::is.null
[10:21:07.808]                     muffled <- FALSE
[10:21:07.808]                     if (inherits(cond, "message")) {
[10:21:07.808]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:07.808]                       if (muffled) 
[10:21:07.808]                         invokeRestart("muffleMessage")
[10:21:07.808]                     }
[10:21:07.808]                     else if (inherits(cond, "warning")) {
[10:21:07.808]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:07.808]                       if (muffled) 
[10:21:07.808]                         invokeRestart("muffleWarning")
[10:21:07.808]                     }
[10:21:07.808]                     else if (inherits(cond, "condition")) {
[10:21:07.808]                       if (!is.null(pattern)) {
[10:21:07.808]                         computeRestarts <- base::computeRestarts
[10:21:07.808]                         grepl <- base::grepl
[10:21:07.808]                         restarts <- computeRestarts(cond)
[10:21:07.808]                         for (restart in restarts) {
[10:21:07.808]                           name <- restart$name
[10:21:07.808]                           if (is.null(name)) 
[10:21:07.808]                             next
[10:21:07.808]                           if (!grepl(pattern, name)) 
[10:21:07.808]                             next
[10:21:07.808]                           invokeRestart(restart)
[10:21:07.808]                           muffled <- TRUE
[10:21:07.808]                           break
[10:21:07.808]                         }
[10:21:07.808]                       }
[10:21:07.808]                     }
[10:21:07.808]                     invisible(muffled)
[10:21:07.808]                   }
[10:21:07.808]                   muffleCondition(cond)
[10:21:07.808]                 })
[10:21:07.808]             }))
[10:21:07.808]             future::FutureResult(value = ...future.value$value, 
[10:21:07.808]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.808]                   ...future.rng), globalenv = if (FALSE) 
[10:21:07.808]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:07.808]                     ...future.globalenv.names))
[10:21:07.808]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:07.808]         }, condition = base::local({
[10:21:07.808]             c <- base::c
[10:21:07.808]             inherits <- base::inherits
[10:21:07.808]             invokeRestart <- base::invokeRestart
[10:21:07.808]             length <- base::length
[10:21:07.808]             list <- base::list
[10:21:07.808]             seq.int <- base::seq.int
[10:21:07.808]             signalCondition <- base::signalCondition
[10:21:07.808]             sys.calls <- base::sys.calls
[10:21:07.808]             `[[` <- base::`[[`
[10:21:07.808]             `+` <- base::`+`
[10:21:07.808]             `<<-` <- base::`<<-`
[10:21:07.808]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:07.808]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:07.808]                   3L)]
[10:21:07.808]             }
[10:21:07.808]             function(cond) {
[10:21:07.808]                 is_error <- inherits(cond, "error")
[10:21:07.808]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:07.808]                   NULL)
[10:21:07.808]                 if (is_error) {
[10:21:07.808]                   sessionInformation <- function() {
[10:21:07.808]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:07.808]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:07.808]                       search = base::search(), system = base::Sys.info())
[10:21:07.808]                   }
[10:21:07.808]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.808]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:07.808]                     cond$call), session = sessionInformation(), 
[10:21:07.808]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:07.808]                   signalCondition(cond)
[10:21:07.808]                 }
[10:21:07.808]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:07.808]                 "immediateCondition"))) {
[10:21:07.808]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:07.808]                   ...future.conditions[[length(...future.conditions) + 
[10:21:07.808]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:07.808]                   if (TRUE && !signal) {
[10:21:07.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.808]                     {
[10:21:07.808]                       inherits <- base::inherits
[10:21:07.808]                       invokeRestart <- base::invokeRestart
[10:21:07.808]                       is.null <- base::is.null
[10:21:07.808]                       muffled <- FALSE
[10:21:07.808]                       if (inherits(cond, "message")) {
[10:21:07.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.808]                         if (muffled) 
[10:21:07.808]                           invokeRestart("muffleMessage")
[10:21:07.808]                       }
[10:21:07.808]                       else if (inherits(cond, "warning")) {
[10:21:07.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.808]                         if (muffled) 
[10:21:07.808]                           invokeRestart("muffleWarning")
[10:21:07.808]                       }
[10:21:07.808]                       else if (inherits(cond, "condition")) {
[10:21:07.808]                         if (!is.null(pattern)) {
[10:21:07.808]                           computeRestarts <- base::computeRestarts
[10:21:07.808]                           grepl <- base::grepl
[10:21:07.808]                           restarts <- computeRestarts(cond)
[10:21:07.808]                           for (restart in restarts) {
[10:21:07.808]                             name <- restart$name
[10:21:07.808]                             if (is.null(name)) 
[10:21:07.808]                               next
[10:21:07.808]                             if (!grepl(pattern, name)) 
[10:21:07.808]                               next
[10:21:07.808]                             invokeRestart(restart)
[10:21:07.808]                             muffled <- TRUE
[10:21:07.808]                             break
[10:21:07.808]                           }
[10:21:07.808]                         }
[10:21:07.808]                       }
[10:21:07.808]                       invisible(muffled)
[10:21:07.808]                     }
[10:21:07.808]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.808]                   }
[10:21:07.808]                 }
[10:21:07.808]                 else {
[10:21:07.808]                   if (TRUE) {
[10:21:07.808]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:07.808]                     {
[10:21:07.808]                       inherits <- base::inherits
[10:21:07.808]                       invokeRestart <- base::invokeRestart
[10:21:07.808]                       is.null <- base::is.null
[10:21:07.808]                       muffled <- FALSE
[10:21:07.808]                       if (inherits(cond, "message")) {
[10:21:07.808]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:07.808]                         if (muffled) 
[10:21:07.808]                           invokeRestart("muffleMessage")
[10:21:07.808]                       }
[10:21:07.808]                       else if (inherits(cond, "warning")) {
[10:21:07.808]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:07.808]                         if (muffled) 
[10:21:07.808]                           invokeRestart("muffleWarning")
[10:21:07.808]                       }
[10:21:07.808]                       else if (inherits(cond, "condition")) {
[10:21:07.808]                         if (!is.null(pattern)) {
[10:21:07.808]                           computeRestarts <- base::computeRestarts
[10:21:07.808]                           grepl <- base::grepl
[10:21:07.808]                           restarts <- computeRestarts(cond)
[10:21:07.808]                           for (restart in restarts) {
[10:21:07.808]                             name <- restart$name
[10:21:07.808]                             if (is.null(name)) 
[10:21:07.808]                               next
[10:21:07.808]                             if (!grepl(pattern, name)) 
[10:21:07.808]                               next
[10:21:07.808]                             invokeRestart(restart)
[10:21:07.808]                             muffled <- TRUE
[10:21:07.808]                             break
[10:21:07.808]                           }
[10:21:07.808]                         }
[10:21:07.808]                       }
[10:21:07.808]                       invisible(muffled)
[10:21:07.808]                     }
[10:21:07.808]                     muffleCondition(cond, pattern = "^muffle")
[10:21:07.808]                   }
[10:21:07.808]                 }
[10:21:07.808]             }
[10:21:07.808]         }))
[10:21:07.808]     }, error = function(ex) {
[10:21:07.808]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:07.808]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:07.808]                 ...future.rng), started = ...future.startTime, 
[10:21:07.808]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:07.808]             version = "1.8"), class = "FutureResult")
[10:21:07.808]     }, finally = {
[10:21:07.808]         if (!identical(...future.workdir, getwd())) 
[10:21:07.808]             setwd(...future.workdir)
[10:21:07.808]         {
[10:21:07.808]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:07.808]                 ...future.oldOptions$nwarnings <- NULL
[10:21:07.808]             }
[10:21:07.808]             base::options(...future.oldOptions)
[10:21:07.808]             if (.Platform$OS.type == "windows") {
[10:21:07.808]                 old_names <- names(...future.oldEnvVars)
[10:21:07.808]                 envs <- base::Sys.getenv()
[10:21:07.808]                 names <- names(envs)
[10:21:07.808]                 common <- intersect(names, old_names)
[10:21:07.808]                 added <- setdiff(names, old_names)
[10:21:07.808]                 removed <- setdiff(old_names, names)
[10:21:07.808]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:07.808]                   envs[common]]
[10:21:07.808]                 NAMES <- toupper(changed)
[10:21:07.808]                 args <- list()
[10:21:07.808]                 for (kk in seq_along(NAMES)) {
[10:21:07.808]                   name <- changed[[kk]]
[10:21:07.808]                   NAME <- NAMES[[kk]]
[10:21:07.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.808]                     next
[10:21:07.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.808]                 }
[10:21:07.808]                 NAMES <- toupper(added)
[10:21:07.808]                 for (kk in seq_along(NAMES)) {
[10:21:07.808]                   name <- added[[kk]]
[10:21:07.808]                   NAME <- NAMES[[kk]]
[10:21:07.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.808]                     next
[10:21:07.808]                   args[[name]] <- ""
[10:21:07.808]                 }
[10:21:07.808]                 NAMES <- toupper(removed)
[10:21:07.808]                 for (kk in seq_along(NAMES)) {
[10:21:07.808]                   name <- removed[[kk]]
[10:21:07.808]                   NAME <- NAMES[[kk]]
[10:21:07.808]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:07.808]                     next
[10:21:07.808]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:07.808]                 }
[10:21:07.808]                 if (length(args) > 0) 
[10:21:07.808]                   base::do.call(base::Sys.setenv, args = args)
[10:21:07.808]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:07.808]             }
[10:21:07.808]             else {
[10:21:07.808]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:07.808]             }
[10:21:07.808]             {
[10:21:07.808]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:07.808]                   0L) {
[10:21:07.808]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:07.808]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:07.808]                   base::options(opts)
[10:21:07.808]                 }
[10:21:07.808]                 {
[10:21:07.808]                   {
[10:21:07.808]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:07.808]                     NULL
[10:21:07.808]                   }
[10:21:07.808]                   options(future.plan = NULL)
[10:21:07.808]                   if (is.na(NA_character_)) 
[10:21:07.808]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:07.808]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:07.808]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:07.808]                     .init = FALSE)
[10:21:07.808]                 }
[10:21:07.808]             }
[10:21:07.808]         }
[10:21:07.808]     })
[10:21:07.808]     if (TRUE) {
[10:21:07.808]         base::sink(type = "output", split = FALSE)
[10:21:07.808]         if (TRUE) {
[10:21:07.808]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:07.808]         }
[10:21:07.808]         else {
[10:21:07.808]             ...future.result["stdout"] <- base::list(NULL)
[10:21:07.808]         }
[10:21:07.808]         base::close(...future.stdout)
[10:21:07.808]         ...future.stdout <- NULL
[10:21:07.808]     }
[10:21:07.808]     ...future.result$conditions <- ...future.conditions
[10:21:07.808]     ...future.result$finished <- base::Sys.time()
[10:21:07.808]     ...future.result
[10:21:07.808] }
[10:21:07.812] MultisessionFuture started
[10:21:07.812] - Launch lazy future ... done
[10:21:07.812] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘strategy = multisession’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: 5d3ef0ed-db9e-ae6b-42bb-ee90a6584f1a
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:07.823] result() for ClusterFuture ...
[10:21:07.823] receiveMessageFromWorker() for ClusterFuture ...
[10:21:07.824] - Validating connection of MultisessionFuture
[10:21:07.854] - received message: FutureResult
[10:21:07.854] - Received FutureResult
[10:21:07.855] - Erased future from FutureRegistry
[10:21:07.855] result() for ClusterFuture ...
[10:21:07.855] - result already collected: FutureResult
[10:21:07.855] result() for ClusterFuture ... done
[10:21:07.855] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:07.855] result() for ClusterFuture ... done
[10:21:07.855] result() for ClusterFuture ...
[10:21:07.855] - result already collected: FutureResult
[10:21:07.856] result() for ClusterFuture ... done
- plan('multisession') ... DONE
> 
> message("*** Futures - labels ... DONE")
*** Futures - labels ... DONE
> 
> source("incl/end.R")
[10:21:07.856] plan(): Setting new future strategy stack:
[10:21:07.857] List of future strategies:
[10:21:07.857] 1. FutureStrategy:
[10:21:07.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:07.857]    - tweaked: FALSE
[10:21:07.857]    - call: future::plan(oplan)
[10:21:07.858] plan(): nbrOfWorkers() = 1
> 
