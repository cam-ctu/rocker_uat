
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:27:37.331] plan(): Setting new future strategy stack:
[08:27:37.331] List of future strategies:
[08:27:37.331] 1. sequential:
[08:27:37.331]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.331]    - tweaked: FALSE
[08:27:37.331]    - call: future::plan("sequential")
[08:27:37.345] plan(): nbrOfWorkers() = 1
> 
> message("*** Futures - labels ...")
*** Futures - labels ...
> 
> strategies <- supportedStrategies()
> 
> ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
> if (!fullTest && isWin32) strategies <- NULL
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   for (label in list(NULL, sprintf("strategy = %s", strategy))) {
+     fcn <- get(strategy, mode = "function")
+     stopifnot(inherits(fcn, strategy))
+     f <- fcn(42, label = label)
+     print(f)
+     stopifnot(identical(f$label, label))
+     v <- value(f)
+     stopifnot(v == 42)
+     
+     f <- future(42, label = label)
+     print(f)
+     stopifnot(identical(f$label, label))
+     v <- value(f)
+     stopifnot(v == 42)
+ 
+     v %<-% { 42 } %label% label
+     f <- futureOf(v)
+     print(f)
+     stopifnot(identical(f$label, label))
+     stopifnot(v == 42)
+ 
+   } ## for (label ...)
+ 
+   message(sprintf("- plan('%s') ... DONE", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[08:27:37.374] plan(): Setting new future strategy stack:
[08:27:37.374] List of future strategies:
[08:27:37.374] 1. sequential:
[08:27:37.374]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.374]    - tweaked: FALSE
[08:27:37.374]    - call: plan(strategy)
[08:27:37.387] plan(): nbrOfWorkers() = 1
[08:27:37.388] getGlobalsAndPackages() ...
[08:27:37.388] Searching for globals...
[08:27:37.390] 
[08:27:37.390] Searching for globals ... DONE
[08:27:37.390] - globals: [0] <none>
[08:27:37.391] getGlobalsAndPackages() ... DONE
[08:27:37.391] Packages needed by the future expression (n = 0): <none>
[08:27:37.392] Packages needed by future strategies (n = 0): <none>
[08:27:37.392] {
[08:27:37.392]     {
[08:27:37.392]         {
[08:27:37.392]             ...future.startTime <- base::Sys.time()
[08:27:37.392]             {
[08:27:37.392]                 {
[08:27:37.392]                   {
[08:27:37.392]                     base::local({
[08:27:37.392]                       has_future <- base::requireNamespace("future", 
[08:27:37.392]                         quietly = TRUE)
[08:27:37.392]                       if (has_future) {
[08:27:37.392]                         ns <- base::getNamespace("future")
[08:27:37.392]                         version <- ns[[".package"]][["version"]]
[08:27:37.392]                         if (is.null(version)) 
[08:27:37.392]                           version <- utils::packageVersion("future")
[08:27:37.392]                       }
[08:27:37.392]                       else {
[08:27:37.392]                         version <- NULL
[08:27:37.392]                       }
[08:27:37.392]                       if (!has_future || version < "1.8.0") {
[08:27:37.392]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.392]                           "", base::R.version$version.string), 
[08:27:37.392]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:37.392]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.392]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.392]                             "release", "version")], collapse = " "), 
[08:27:37.392]                           hostname = base::Sys.info()[["nodename"]])
[08:27:37.392]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.392]                           info)
[08:27:37.392]                         info <- base::paste(info, collapse = "; ")
[08:27:37.392]                         if (!has_future) {
[08:27:37.392]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.392]                             info)
[08:27:37.392]                         }
[08:27:37.392]                         else {
[08:27:37.392]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.392]                             info, version)
[08:27:37.392]                         }
[08:27:37.392]                         base::stop(msg)
[08:27:37.392]                       }
[08:27:37.392]                     })
[08:27:37.392]                   }
[08:27:37.392]                   ...future.strategy.old <- future::plan("list")
[08:27:37.392]                   options(future.plan = NULL)
[08:27:37.392]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.392]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.392]                 }
[08:27:37.392]                 ...future.workdir <- getwd()
[08:27:37.392]             }
[08:27:37.392]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.392]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.392]         }
[08:27:37.392]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.392]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.392]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.392]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.392]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.392]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.392]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.392]             base::names(...future.oldOptions))
[08:27:37.392]     }
[08:27:37.392]     if (FALSE) {
[08:27:37.392]     }
[08:27:37.392]     else {
[08:27:37.392]         if (TRUE) {
[08:27:37.392]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.392]                 open = "w")
[08:27:37.392]         }
[08:27:37.392]         else {
[08:27:37.392]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.392]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.392]         }
[08:27:37.392]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.392]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.392]             base::sink(type = "output", split = FALSE)
[08:27:37.392]             base::close(...future.stdout)
[08:27:37.392]         }, add = TRUE)
[08:27:37.392]     }
[08:27:37.392]     ...future.frame <- base::sys.nframe()
[08:27:37.392]     ...future.conditions <- base::list()
[08:27:37.392]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.392]     if (FALSE) {
[08:27:37.392]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.392]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.392]     }
[08:27:37.392]     ...future.result <- base::tryCatch({
[08:27:37.392]         base::withCallingHandlers({
[08:27:37.392]             ...future.value <- base::withVisible(base::local(42))
[08:27:37.392]             future::FutureResult(value = ...future.value$value, 
[08:27:37.392]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.392]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.392]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.392]                     ...future.globalenv.names))
[08:27:37.392]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.392]         }, condition = base::local({
[08:27:37.392]             c <- base::c
[08:27:37.392]             inherits <- base::inherits
[08:27:37.392]             invokeRestart <- base::invokeRestart
[08:27:37.392]             length <- base::length
[08:27:37.392]             list <- base::list
[08:27:37.392]             seq.int <- base::seq.int
[08:27:37.392]             signalCondition <- base::signalCondition
[08:27:37.392]             sys.calls <- base::sys.calls
[08:27:37.392]             `[[` <- base::`[[`
[08:27:37.392]             `+` <- base::`+`
[08:27:37.392]             `<<-` <- base::`<<-`
[08:27:37.392]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.392]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.392]                   3L)]
[08:27:37.392]             }
[08:27:37.392]             function(cond) {
[08:27:37.392]                 is_error <- inherits(cond, "error")
[08:27:37.392]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.392]                   NULL)
[08:27:37.392]                 if (is_error) {
[08:27:37.392]                   sessionInformation <- function() {
[08:27:37.392]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.392]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.392]                       search = base::search(), system = base::Sys.info())
[08:27:37.392]                   }
[08:27:37.392]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.392]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.392]                     cond$call), session = sessionInformation(), 
[08:27:37.392]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.392]                   signalCondition(cond)
[08:27:37.392]                 }
[08:27:37.392]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.392]                 "immediateCondition"))) {
[08:27:37.392]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.392]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.392]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.392]                   if (TRUE && !signal) {
[08:27:37.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.392]                     {
[08:27:37.392]                       inherits <- base::inherits
[08:27:37.392]                       invokeRestart <- base::invokeRestart
[08:27:37.392]                       is.null <- base::is.null
[08:27:37.392]                       muffled <- FALSE
[08:27:37.392]                       if (inherits(cond, "message")) {
[08:27:37.392]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.392]                         if (muffled) 
[08:27:37.392]                           invokeRestart("muffleMessage")
[08:27:37.392]                       }
[08:27:37.392]                       else if (inherits(cond, "warning")) {
[08:27:37.392]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.392]                         if (muffled) 
[08:27:37.392]                           invokeRestart("muffleWarning")
[08:27:37.392]                       }
[08:27:37.392]                       else if (inherits(cond, "condition")) {
[08:27:37.392]                         if (!is.null(pattern)) {
[08:27:37.392]                           computeRestarts <- base::computeRestarts
[08:27:37.392]                           grepl <- base::grepl
[08:27:37.392]                           restarts <- computeRestarts(cond)
[08:27:37.392]                           for (restart in restarts) {
[08:27:37.392]                             name <- restart$name
[08:27:37.392]                             if (is.null(name)) 
[08:27:37.392]                               next
[08:27:37.392]                             if (!grepl(pattern, name)) 
[08:27:37.392]                               next
[08:27:37.392]                             invokeRestart(restart)
[08:27:37.392]                             muffled <- TRUE
[08:27:37.392]                             break
[08:27:37.392]                           }
[08:27:37.392]                         }
[08:27:37.392]                       }
[08:27:37.392]                       invisible(muffled)
[08:27:37.392]                     }
[08:27:37.392]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.392]                   }
[08:27:37.392]                 }
[08:27:37.392]                 else {
[08:27:37.392]                   if (TRUE) {
[08:27:37.392]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.392]                     {
[08:27:37.392]                       inherits <- base::inherits
[08:27:37.392]                       invokeRestart <- base::invokeRestart
[08:27:37.392]                       is.null <- base::is.null
[08:27:37.392]                       muffled <- FALSE
[08:27:37.392]                       if (inherits(cond, "message")) {
[08:27:37.392]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.392]                         if (muffled) 
[08:27:37.392]                           invokeRestart("muffleMessage")
[08:27:37.392]                       }
[08:27:37.392]                       else if (inherits(cond, "warning")) {
[08:27:37.392]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.392]                         if (muffled) 
[08:27:37.392]                           invokeRestart("muffleWarning")
[08:27:37.392]                       }
[08:27:37.392]                       else if (inherits(cond, "condition")) {
[08:27:37.392]                         if (!is.null(pattern)) {
[08:27:37.392]                           computeRestarts <- base::computeRestarts
[08:27:37.392]                           grepl <- base::grepl
[08:27:37.392]                           restarts <- computeRestarts(cond)
[08:27:37.392]                           for (restart in restarts) {
[08:27:37.392]                             name <- restart$name
[08:27:37.392]                             if (is.null(name)) 
[08:27:37.392]                               next
[08:27:37.392]                             if (!grepl(pattern, name)) 
[08:27:37.392]                               next
[08:27:37.392]                             invokeRestart(restart)
[08:27:37.392]                             muffled <- TRUE
[08:27:37.392]                             break
[08:27:37.392]                           }
[08:27:37.392]                         }
[08:27:37.392]                       }
[08:27:37.392]                       invisible(muffled)
[08:27:37.392]                     }
[08:27:37.392]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.392]                   }
[08:27:37.392]                 }
[08:27:37.392]             }
[08:27:37.392]         }))
[08:27:37.392]     }, error = function(ex) {
[08:27:37.392]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.392]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.392]                 ...future.rng), started = ...future.startTime, 
[08:27:37.392]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.392]             version = "1.8"), class = "FutureResult")
[08:27:37.392]     }, finally = {
[08:27:37.392]         if (!identical(...future.workdir, getwd())) 
[08:27:37.392]             setwd(...future.workdir)
[08:27:37.392]         {
[08:27:37.392]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.392]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.392]             }
[08:27:37.392]             base::options(...future.oldOptions)
[08:27:37.392]             if (.Platform$OS.type == "windows") {
[08:27:37.392]                 old_names <- names(...future.oldEnvVars)
[08:27:37.392]                 envs <- base::Sys.getenv()
[08:27:37.392]                 names <- names(envs)
[08:27:37.392]                 common <- intersect(names, old_names)
[08:27:37.392]                 added <- setdiff(names, old_names)
[08:27:37.392]                 removed <- setdiff(old_names, names)
[08:27:37.392]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.392]                   envs[common]]
[08:27:37.392]                 NAMES <- toupper(changed)
[08:27:37.392]                 args <- list()
[08:27:37.392]                 for (kk in seq_along(NAMES)) {
[08:27:37.392]                   name <- changed[[kk]]
[08:27:37.392]                   NAME <- NAMES[[kk]]
[08:27:37.392]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.392]                     next
[08:27:37.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.392]                 }
[08:27:37.392]                 NAMES <- toupper(added)
[08:27:37.392]                 for (kk in seq_along(NAMES)) {
[08:27:37.392]                   name <- added[[kk]]
[08:27:37.392]                   NAME <- NAMES[[kk]]
[08:27:37.392]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.392]                     next
[08:27:37.392]                   args[[name]] <- ""
[08:27:37.392]                 }
[08:27:37.392]                 NAMES <- toupper(removed)
[08:27:37.392]                 for (kk in seq_along(NAMES)) {
[08:27:37.392]                   name <- removed[[kk]]
[08:27:37.392]                   NAME <- NAMES[[kk]]
[08:27:37.392]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.392]                     next
[08:27:37.392]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.392]                 }
[08:27:37.392]                 if (length(args) > 0) 
[08:27:37.392]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.392]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.392]             }
[08:27:37.392]             else {
[08:27:37.392]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.392]             }
[08:27:37.392]             {
[08:27:37.392]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.392]                   0L) {
[08:27:37.392]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.392]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.392]                   base::options(opts)
[08:27:37.392]                 }
[08:27:37.392]                 {
[08:27:37.392]                   {
[08:27:37.392]                     NULL
[08:27:37.392]                     RNGkind("Mersenne-Twister")
[08:27:37.392]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:37.392]                       inherits = FALSE)
[08:27:37.392]                   }
[08:27:37.392]                   options(future.plan = NULL)
[08:27:37.392]                   if (is.na(NA_character_)) 
[08:27:37.392]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.392]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.392]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.392]                     .init = FALSE)
[08:27:37.392]                 }
[08:27:37.392]             }
[08:27:37.392]         }
[08:27:37.392]     })
[08:27:37.392]     if (TRUE) {
[08:27:37.392]         base::sink(type = "output", split = FALSE)
[08:27:37.392]         if (TRUE) {
[08:27:37.392]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.392]         }
[08:27:37.392]         else {
[08:27:37.392]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.392]         }
[08:27:37.392]         base::close(...future.stdout)
[08:27:37.392]         ...future.stdout <- NULL
[08:27:37.392]     }
[08:27:37.392]     ...future.result$conditions <- ...future.conditions
[08:27:37.392]     ...future.result$finished <- base::Sys.time()
[08:27:37.392]     ...future.result
[08:27:37.392] }
[08:27:37.394] plan(): Setting new future strategy stack:
[08:27:37.394] List of future strategies:
[08:27:37.394] 1. sequential:
[08:27:37.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.394]    - tweaked: FALSE
[08:27:37.394]    - call: NULL
[08:27:37.395] plan(): nbrOfWorkers() = 1
[08:27:37.396] plan(): Setting new future strategy stack:
[08:27:37.396] List of future strategies:
[08:27:37.396] 1. sequential:
[08:27:37.396]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.396]    - tweaked: FALSE
[08:27:37.396]    - call: plan(strategy)
[08:27:37.397] plan(): nbrOfWorkers() = 1
[08:27:37.397] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:37.398] getGlobalsAndPackages() ...
[08:27:37.398] Searching for globals...
[08:27:37.399] 
[08:27:37.399] Searching for globals ... DONE
[08:27:37.399] - globals: [0] <none>
[08:27:37.399] getGlobalsAndPackages() ... DONE
[08:27:37.399] run() for ‘Future’ ...
[08:27:37.399] - state: ‘created’
[08:27:37.399] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:37.400] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:37.400] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:37.400]   - Field: ‘label’
[08:27:37.400]   - Field: ‘local’
[08:27:37.400]   - Field: ‘owner’
[08:27:37.400]   - Field: ‘envir’
[08:27:37.400]   - Field: ‘packages’
[08:27:37.400]   - Field: ‘gc’
[08:27:37.400]   - Field: ‘conditions’
[08:27:37.401]   - Field: ‘expr’
[08:27:37.401]   - Field: ‘uuid’
[08:27:37.401]   - Field: ‘seed’
[08:27:37.401]   - Field: ‘version’
[08:27:37.401]   - Field: ‘result’
[08:27:37.401]   - Field: ‘asynchronous’
[08:27:37.401]   - Field: ‘calls’
[08:27:37.401]   - Field: ‘globals’
[08:27:37.401]   - Field: ‘stdout’
[08:27:37.401]   - Field: ‘earlySignal’
[08:27:37.401]   - Field: ‘lazy’
[08:27:37.401]   - Field: ‘state’
[08:27:37.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:37.402] - Launch lazy future ...
[08:27:37.402] Packages needed by the future expression (n = 0): <none>
[08:27:37.402] Packages needed by future strategies (n = 0): <none>
[08:27:37.402] {
[08:27:37.402]     {
[08:27:37.402]         {
[08:27:37.402]             ...future.startTime <- base::Sys.time()
[08:27:37.402]             {
[08:27:37.402]                 {
[08:27:37.402]                   {
[08:27:37.402]                     base::local({
[08:27:37.402]                       has_future <- base::requireNamespace("future", 
[08:27:37.402]                         quietly = TRUE)
[08:27:37.402]                       if (has_future) {
[08:27:37.402]                         ns <- base::getNamespace("future")
[08:27:37.402]                         version <- ns[[".package"]][["version"]]
[08:27:37.402]                         if (is.null(version)) 
[08:27:37.402]                           version <- utils::packageVersion("future")
[08:27:37.402]                       }
[08:27:37.402]                       else {
[08:27:37.402]                         version <- NULL
[08:27:37.402]                       }
[08:27:37.402]                       if (!has_future || version < "1.8.0") {
[08:27:37.402]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.402]                           "", base::R.version$version.string), 
[08:27:37.402]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:37.402]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.402]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.402]                             "release", "version")], collapse = " "), 
[08:27:37.402]                           hostname = base::Sys.info()[["nodename"]])
[08:27:37.402]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.402]                           info)
[08:27:37.402]                         info <- base::paste(info, collapse = "; ")
[08:27:37.402]                         if (!has_future) {
[08:27:37.402]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.402]                             info)
[08:27:37.402]                         }
[08:27:37.402]                         else {
[08:27:37.402]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.402]                             info, version)
[08:27:37.402]                         }
[08:27:37.402]                         base::stop(msg)
[08:27:37.402]                       }
[08:27:37.402]                     })
[08:27:37.402]                   }
[08:27:37.402]                   ...future.strategy.old <- future::plan("list")
[08:27:37.402]                   options(future.plan = NULL)
[08:27:37.402]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.402]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.402]                 }
[08:27:37.402]                 ...future.workdir <- getwd()
[08:27:37.402]             }
[08:27:37.402]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.402]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.402]         }
[08:27:37.402]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.402]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.402]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.402]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.402]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.402]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.402]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.402]             base::names(...future.oldOptions))
[08:27:37.402]     }
[08:27:37.402]     if (FALSE) {
[08:27:37.402]     }
[08:27:37.402]     else {
[08:27:37.402]         if (TRUE) {
[08:27:37.402]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.402]                 open = "w")
[08:27:37.402]         }
[08:27:37.402]         else {
[08:27:37.402]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.402]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.402]         }
[08:27:37.402]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.402]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.402]             base::sink(type = "output", split = FALSE)
[08:27:37.402]             base::close(...future.stdout)
[08:27:37.402]         }, add = TRUE)
[08:27:37.402]     }
[08:27:37.402]     ...future.frame <- base::sys.nframe()
[08:27:37.402]     ...future.conditions <- base::list()
[08:27:37.402]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.402]     if (FALSE) {
[08:27:37.402]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.402]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.402]     }
[08:27:37.402]     ...future.result <- base::tryCatch({
[08:27:37.402]         base::withCallingHandlers({
[08:27:37.402]             ...future.value <- base::withVisible(base::local(42))
[08:27:37.402]             future::FutureResult(value = ...future.value$value, 
[08:27:37.402]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.402]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.402]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.402]                     ...future.globalenv.names))
[08:27:37.402]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.402]         }, condition = base::local({
[08:27:37.402]             c <- base::c
[08:27:37.402]             inherits <- base::inherits
[08:27:37.402]             invokeRestart <- base::invokeRestart
[08:27:37.402]             length <- base::length
[08:27:37.402]             list <- base::list
[08:27:37.402]             seq.int <- base::seq.int
[08:27:37.402]             signalCondition <- base::signalCondition
[08:27:37.402]             sys.calls <- base::sys.calls
[08:27:37.402]             `[[` <- base::`[[`
[08:27:37.402]             `+` <- base::`+`
[08:27:37.402]             `<<-` <- base::`<<-`
[08:27:37.402]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.402]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.402]                   3L)]
[08:27:37.402]             }
[08:27:37.402]             function(cond) {
[08:27:37.402]                 is_error <- inherits(cond, "error")
[08:27:37.402]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.402]                   NULL)
[08:27:37.402]                 if (is_error) {
[08:27:37.402]                   sessionInformation <- function() {
[08:27:37.402]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.402]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.402]                       search = base::search(), system = base::Sys.info())
[08:27:37.402]                   }
[08:27:37.402]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.402]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.402]                     cond$call), session = sessionInformation(), 
[08:27:37.402]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.402]                   signalCondition(cond)
[08:27:37.402]                 }
[08:27:37.402]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.402]                 "immediateCondition"))) {
[08:27:37.402]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.402]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.402]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.402]                   if (TRUE && !signal) {
[08:27:37.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.402]                     {
[08:27:37.402]                       inherits <- base::inherits
[08:27:37.402]                       invokeRestart <- base::invokeRestart
[08:27:37.402]                       is.null <- base::is.null
[08:27:37.402]                       muffled <- FALSE
[08:27:37.402]                       if (inherits(cond, "message")) {
[08:27:37.402]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.402]                         if (muffled) 
[08:27:37.402]                           invokeRestart("muffleMessage")
[08:27:37.402]                       }
[08:27:37.402]                       else if (inherits(cond, "warning")) {
[08:27:37.402]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.402]                         if (muffled) 
[08:27:37.402]                           invokeRestart("muffleWarning")
[08:27:37.402]                       }
[08:27:37.402]                       else if (inherits(cond, "condition")) {
[08:27:37.402]                         if (!is.null(pattern)) {
[08:27:37.402]                           computeRestarts <- base::computeRestarts
[08:27:37.402]                           grepl <- base::grepl
[08:27:37.402]                           restarts <- computeRestarts(cond)
[08:27:37.402]                           for (restart in restarts) {
[08:27:37.402]                             name <- restart$name
[08:27:37.402]                             if (is.null(name)) 
[08:27:37.402]                               next
[08:27:37.402]                             if (!grepl(pattern, name)) 
[08:27:37.402]                               next
[08:27:37.402]                             invokeRestart(restart)
[08:27:37.402]                             muffled <- TRUE
[08:27:37.402]                             break
[08:27:37.402]                           }
[08:27:37.402]                         }
[08:27:37.402]                       }
[08:27:37.402]                       invisible(muffled)
[08:27:37.402]                     }
[08:27:37.402]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.402]                   }
[08:27:37.402]                 }
[08:27:37.402]                 else {
[08:27:37.402]                   if (TRUE) {
[08:27:37.402]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.402]                     {
[08:27:37.402]                       inherits <- base::inherits
[08:27:37.402]                       invokeRestart <- base::invokeRestart
[08:27:37.402]                       is.null <- base::is.null
[08:27:37.402]                       muffled <- FALSE
[08:27:37.402]                       if (inherits(cond, "message")) {
[08:27:37.402]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.402]                         if (muffled) 
[08:27:37.402]                           invokeRestart("muffleMessage")
[08:27:37.402]                       }
[08:27:37.402]                       else if (inherits(cond, "warning")) {
[08:27:37.402]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.402]                         if (muffled) 
[08:27:37.402]                           invokeRestart("muffleWarning")
[08:27:37.402]                       }
[08:27:37.402]                       else if (inherits(cond, "condition")) {
[08:27:37.402]                         if (!is.null(pattern)) {
[08:27:37.402]                           computeRestarts <- base::computeRestarts
[08:27:37.402]                           grepl <- base::grepl
[08:27:37.402]                           restarts <- computeRestarts(cond)
[08:27:37.402]                           for (restart in restarts) {
[08:27:37.402]                             name <- restart$name
[08:27:37.402]                             if (is.null(name)) 
[08:27:37.402]                               next
[08:27:37.402]                             if (!grepl(pattern, name)) 
[08:27:37.402]                               next
[08:27:37.402]                             invokeRestart(restart)
[08:27:37.402]                             muffled <- TRUE
[08:27:37.402]                             break
[08:27:37.402]                           }
[08:27:37.402]                         }
[08:27:37.402]                       }
[08:27:37.402]                       invisible(muffled)
[08:27:37.402]                     }
[08:27:37.402]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.402]                   }
[08:27:37.402]                 }
[08:27:37.402]             }
[08:27:37.402]         }))
[08:27:37.402]     }, error = function(ex) {
[08:27:37.402]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.402]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.402]                 ...future.rng), started = ...future.startTime, 
[08:27:37.402]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.402]             version = "1.8"), class = "FutureResult")
[08:27:37.402]     }, finally = {
[08:27:37.402]         if (!identical(...future.workdir, getwd())) 
[08:27:37.402]             setwd(...future.workdir)
[08:27:37.402]         {
[08:27:37.402]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.402]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.402]             }
[08:27:37.402]             base::options(...future.oldOptions)
[08:27:37.402]             if (.Platform$OS.type == "windows") {
[08:27:37.402]                 old_names <- names(...future.oldEnvVars)
[08:27:37.402]                 envs <- base::Sys.getenv()
[08:27:37.402]                 names <- names(envs)
[08:27:37.402]                 common <- intersect(names, old_names)
[08:27:37.402]                 added <- setdiff(names, old_names)
[08:27:37.402]                 removed <- setdiff(old_names, names)
[08:27:37.402]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.402]                   envs[common]]
[08:27:37.402]                 NAMES <- toupper(changed)
[08:27:37.402]                 args <- list()
[08:27:37.402]                 for (kk in seq_along(NAMES)) {
[08:27:37.402]                   name <- changed[[kk]]
[08:27:37.402]                   NAME <- NAMES[[kk]]
[08:27:37.402]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.402]                     next
[08:27:37.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.402]                 }
[08:27:37.402]                 NAMES <- toupper(added)
[08:27:37.402]                 for (kk in seq_along(NAMES)) {
[08:27:37.402]                   name <- added[[kk]]
[08:27:37.402]                   NAME <- NAMES[[kk]]
[08:27:37.402]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.402]                     next
[08:27:37.402]                   args[[name]] <- ""
[08:27:37.402]                 }
[08:27:37.402]                 NAMES <- toupper(removed)
[08:27:37.402]                 for (kk in seq_along(NAMES)) {
[08:27:37.402]                   name <- removed[[kk]]
[08:27:37.402]                   NAME <- NAMES[[kk]]
[08:27:37.402]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.402]                     next
[08:27:37.402]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.402]                 }
[08:27:37.402]                 if (length(args) > 0) 
[08:27:37.402]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.402]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.402]             }
[08:27:37.402]             else {
[08:27:37.402]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.402]             }
[08:27:37.402]             {
[08:27:37.402]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.402]                   0L) {
[08:27:37.402]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.402]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.402]                   base::options(opts)
[08:27:37.402]                 }
[08:27:37.402]                 {
[08:27:37.402]                   {
[08:27:37.402]                     NULL
[08:27:37.402]                     RNGkind("Mersenne-Twister")
[08:27:37.402]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:37.402]                       inherits = FALSE)
[08:27:37.402]                   }
[08:27:37.402]                   options(future.plan = NULL)
[08:27:37.402]                   if (is.na(NA_character_)) 
[08:27:37.402]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.402]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.402]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.402]                     .init = FALSE)
[08:27:37.402]                 }
[08:27:37.402]             }
[08:27:37.402]         }
[08:27:37.402]     })
[08:27:37.402]     if (TRUE) {
[08:27:37.402]         base::sink(type = "output", split = FALSE)
[08:27:37.402]         if (TRUE) {
[08:27:37.402]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.402]         }
[08:27:37.402]         else {
[08:27:37.402]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.402]         }
[08:27:37.402]         base::close(...future.stdout)
[08:27:37.402]         ...future.stdout <- NULL
[08:27:37.402]     }
[08:27:37.402]     ...future.result$conditions <- ...future.conditions
[08:27:37.402]     ...future.result$finished <- base::Sys.time()
[08:27:37.402]     ...future.result
[08:27:37.402] }
[08:27:37.404] plan(): Setting new future strategy stack:
[08:27:37.404] List of future strategies:
[08:27:37.404] 1. sequential:
[08:27:37.404]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.404]    - tweaked: FALSE
[08:27:37.404]    - call: NULL
[08:27:37.405] plan(): nbrOfWorkers() = 1
[08:27:37.405] plan(): Setting new future strategy stack:
[08:27:37.406] List of future strategies:
[08:27:37.406] 1. sequential:
[08:27:37.406]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.406]    - tweaked: FALSE
[08:27:37.406]    - call: plan(strategy)
[08:27:37.406] plan(): nbrOfWorkers() = 1
[08:27:37.406] SequentialFuture started (and completed)
[08:27:37.406] - Launch lazy future ... done
[08:27:37.406] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:37.408] getGlobalsAndPackages() ...
[08:27:37.408] Searching for globals...
[08:27:37.409] - globals found: [1] ‘{’
[08:27:37.409] Searching for globals ... DONE
[08:27:37.409] Resolving globals: FALSE
[08:27:37.410] 
[08:27:37.410] 
[08:27:37.410] getGlobalsAndPackages() ... DONE
[08:27:37.410] run() for ‘Future’ ...
[08:27:37.410] - state: ‘created’
[08:27:37.410] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:37.411] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:37.411] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:37.411]   - Field: ‘label’
[08:27:37.411]   - Field: ‘local’
[08:27:37.411]   - Field: ‘owner’
[08:27:37.411]   - Field: ‘envir’
[08:27:37.411]   - Field: ‘packages’
[08:27:37.411]   - Field: ‘gc’
[08:27:37.411]   - Field: ‘conditions’
[08:27:37.411]   - Field: ‘expr’
[08:27:37.411]   - Field: ‘uuid’
[08:27:37.412]   - Field: ‘seed’
[08:27:37.412]   - Field: ‘version’
[08:27:37.412]   - Field: ‘result’
[08:27:37.412]   - Field: ‘asynchronous’
[08:27:37.412]   - Field: ‘calls’
[08:27:37.412]   - Field: ‘globals’
[08:27:37.412]   - Field: ‘stdout’
[08:27:37.412]   - Field: ‘earlySignal’
[08:27:37.412]   - Field: ‘lazy’
[08:27:37.412]   - Field: ‘state’
[08:27:37.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:37.412] - Launch lazy future ...
[08:27:37.413] Packages needed by the future expression (n = 0): <none>
[08:27:37.413] Packages needed by future strategies (n = 0): <none>
[08:27:37.413] {
[08:27:37.413]     {
[08:27:37.413]         {
[08:27:37.413]             ...future.startTime <- base::Sys.time()
[08:27:37.413]             {
[08:27:37.413]                 {
[08:27:37.413]                   {
[08:27:37.413]                     base::local({
[08:27:37.413]                       has_future <- base::requireNamespace("future", 
[08:27:37.413]                         quietly = TRUE)
[08:27:37.413]                       if (has_future) {
[08:27:37.413]                         ns <- base::getNamespace("future")
[08:27:37.413]                         version <- ns[[".package"]][["version"]]
[08:27:37.413]                         if (is.null(version)) 
[08:27:37.413]                           version <- utils::packageVersion("future")
[08:27:37.413]                       }
[08:27:37.413]                       else {
[08:27:37.413]                         version <- NULL
[08:27:37.413]                       }
[08:27:37.413]                       if (!has_future || version < "1.8.0") {
[08:27:37.413]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.413]                           "", base::R.version$version.string), 
[08:27:37.413]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:37.413]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.413]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.413]                             "release", "version")], collapse = " "), 
[08:27:37.413]                           hostname = base::Sys.info()[["nodename"]])
[08:27:37.413]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.413]                           info)
[08:27:37.413]                         info <- base::paste(info, collapse = "; ")
[08:27:37.413]                         if (!has_future) {
[08:27:37.413]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.413]                             info)
[08:27:37.413]                         }
[08:27:37.413]                         else {
[08:27:37.413]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.413]                             info, version)
[08:27:37.413]                         }
[08:27:37.413]                         base::stop(msg)
[08:27:37.413]                       }
[08:27:37.413]                     })
[08:27:37.413]                   }
[08:27:37.413]                   ...future.strategy.old <- future::plan("list")
[08:27:37.413]                   options(future.plan = NULL)
[08:27:37.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.413]                 }
[08:27:37.413]                 ...future.workdir <- getwd()
[08:27:37.413]             }
[08:27:37.413]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.413]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.413]         }
[08:27:37.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.413]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.413]             base::names(...future.oldOptions))
[08:27:37.413]     }
[08:27:37.413]     if (FALSE) {
[08:27:37.413]     }
[08:27:37.413]     else {
[08:27:37.413]         if (TRUE) {
[08:27:37.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.413]                 open = "w")
[08:27:37.413]         }
[08:27:37.413]         else {
[08:27:37.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.413]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.413]         }
[08:27:37.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.413]             base::sink(type = "output", split = FALSE)
[08:27:37.413]             base::close(...future.stdout)
[08:27:37.413]         }, add = TRUE)
[08:27:37.413]     }
[08:27:37.413]     ...future.frame <- base::sys.nframe()
[08:27:37.413]     ...future.conditions <- base::list()
[08:27:37.413]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.413]     if (FALSE) {
[08:27:37.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.413]     }
[08:27:37.413]     ...future.result <- base::tryCatch({
[08:27:37.413]         base::withCallingHandlers({
[08:27:37.413]             ...future.value <- base::withVisible(base::local({
[08:27:37.413]                 42
[08:27:37.413]             }))
[08:27:37.413]             future::FutureResult(value = ...future.value$value, 
[08:27:37.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.413]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.413]                     ...future.globalenv.names))
[08:27:37.413]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.413]         }, condition = base::local({
[08:27:37.413]             c <- base::c
[08:27:37.413]             inherits <- base::inherits
[08:27:37.413]             invokeRestart <- base::invokeRestart
[08:27:37.413]             length <- base::length
[08:27:37.413]             list <- base::list
[08:27:37.413]             seq.int <- base::seq.int
[08:27:37.413]             signalCondition <- base::signalCondition
[08:27:37.413]             sys.calls <- base::sys.calls
[08:27:37.413]             `[[` <- base::`[[`
[08:27:37.413]             `+` <- base::`+`
[08:27:37.413]             `<<-` <- base::`<<-`
[08:27:37.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.413]                   3L)]
[08:27:37.413]             }
[08:27:37.413]             function(cond) {
[08:27:37.413]                 is_error <- inherits(cond, "error")
[08:27:37.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.413]                   NULL)
[08:27:37.413]                 if (is_error) {
[08:27:37.413]                   sessionInformation <- function() {
[08:27:37.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.413]                       search = base::search(), system = base::Sys.info())
[08:27:37.413]                   }
[08:27:37.413]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.413]                     cond$call), session = sessionInformation(), 
[08:27:37.413]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.413]                   signalCondition(cond)
[08:27:37.413]                 }
[08:27:37.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.413]                 "immediateCondition"))) {
[08:27:37.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.413]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.413]                   if (TRUE && !signal) {
[08:27:37.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.413]                     {
[08:27:37.413]                       inherits <- base::inherits
[08:27:37.413]                       invokeRestart <- base::invokeRestart
[08:27:37.413]                       is.null <- base::is.null
[08:27:37.413]                       muffled <- FALSE
[08:27:37.413]                       if (inherits(cond, "message")) {
[08:27:37.413]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.413]                         if (muffled) 
[08:27:37.413]                           invokeRestart("muffleMessage")
[08:27:37.413]                       }
[08:27:37.413]                       else if (inherits(cond, "warning")) {
[08:27:37.413]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.413]                         if (muffled) 
[08:27:37.413]                           invokeRestart("muffleWarning")
[08:27:37.413]                       }
[08:27:37.413]                       else if (inherits(cond, "condition")) {
[08:27:37.413]                         if (!is.null(pattern)) {
[08:27:37.413]                           computeRestarts <- base::computeRestarts
[08:27:37.413]                           grepl <- base::grepl
[08:27:37.413]                           restarts <- computeRestarts(cond)
[08:27:37.413]                           for (restart in restarts) {
[08:27:37.413]                             name <- restart$name
[08:27:37.413]                             if (is.null(name)) 
[08:27:37.413]                               next
[08:27:37.413]                             if (!grepl(pattern, name)) 
[08:27:37.413]                               next
[08:27:37.413]                             invokeRestart(restart)
[08:27:37.413]                             muffled <- TRUE
[08:27:37.413]                             break
[08:27:37.413]                           }
[08:27:37.413]                         }
[08:27:37.413]                       }
[08:27:37.413]                       invisible(muffled)
[08:27:37.413]                     }
[08:27:37.413]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.413]                   }
[08:27:37.413]                 }
[08:27:37.413]                 else {
[08:27:37.413]                   if (TRUE) {
[08:27:37.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.413]                     {
[08:27:37.413]                       inherits <- base::inherits
[08:27:37.413]                       invokeRestart <- base::invokeRestart
[08:27:37.413]                       is.null <- base::is.null
[08:27:37.413]                       muffled <- FALSE
[08:27:37.413]                       if (inherits(cond, "message")) {
[08:27:37.413]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.413]                         if (muffled) 
[08:27:37.413]                           invokeRestart("muffleMessage")
[08:27:37.413]                       }
[08:27:37.413]                       else if (inherits(cond, "warning")) {
[08:27:37.413]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.413]                         if (muffled) 
[08:27:37.413]                           invokeRestart("muffleWarning")
[08:27:37.413]                       }
[08:27:37.413]                       else if (inherits(cond, "condition")) {
[08:27:37.413]                         if (!is.null(pattern)) {
[08:27:37.413]                           computeRestarts <- base::computeRestarts
[08:27:37.413]                           grepl <- base::grepl
[08:27:37.413]                           restarts <- computeRestarts(cond)
[08:27:37.413]                           for (restart in restarts) {
[08:27:37.413]                             name <- restart$name
[08:27:37.413]                             if (is.null(name)) 
[08:27:37.413]                               next
[08:27:37.413]                             if (!grepl(pattern, name)) 
[08:27:37.413]                               next
[08:27:37.413]                             invokeRestart(restart)
[08:27:37.413]                             muffled <- TRUE
[08:27:37.413]                             break
[08:27:37.413]                           }
[08:27:37.413]                         }
[08:27:37.413]                       }
[08:27:37.413]                       invisible(muffled)
[08:27:37.413]                     }
[08:27:37.413]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.413]                   }
[08:27:37.413]                 }
[08:27:37.413]             }
[08:27:37.413]         }))
[08:27:37.413]     }, error = function(ex) {
[08:27:37.413]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.413]                 ...future.rng), started = ...future.startTime, 
[08:27:37.413]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.413]             version = "1.8"), class = "FutureResult")
[08:27:37.413]     }, finally = {
[08:27:37.413]         if (!identical(...future.workdir, getwd())) 
[08:27:37.413]             setwd(...future.workdir)
[08:27:37.413]         {
[08:27:37.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.413]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.413]             }
[08:27:37.413]             base::options(...future.oldOptions)
[08:27:37.413]             if (.Platform$OS.type == "windows") {
[08:27:37.413]                 old_names <- names(...future.oldEnvVars)
[08:27:37.413]                 envs <- base::Sys.getenv()
[08:27:37.413]                 names <- names(envs)
[08:27:37.413]                 common <- intersect(names, old_names)
[08:27:37.413]                 added <- setdiff(names, old_names)
[08:27:37.413]                 removed <- setdiff(old_names, names)
[08:27:37.413]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.413]                   envs[common]]
[08:27:37.413]                 NAMES <- toupper(changed)
[08:27:37.413]                 args <- list()
[08:27:37.413]                 for (kk in seq_along(NAMES)) {
[08:27:37.413]                   name <- changed[[kk]]
[08:27:37.413]                   NAME <- NAMES[[kk]]
[08:27:37.413]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.413]                     next
[08:27:37.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.413]                 }
[08:27:37.413]                 NAMES <- toupper(added)
[08:27:37.413]                 for (kk in seq_along(NAMES)) {
[08:27:37.413]                   name <- added[[kk]]
[08:27:37.413]                   NAME <- NAMES[[kk]]
[08:27:37.413]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.413]                     next
[08:27:37.413]                   args[[name]] <- ""
[08:27:37.413]                 }
[08:27:37.413]                 NAMES <- toupper(removed)
[08:27:37.413]                 for (kk in seq_along(NAMES)) {
[08:27:37.413]                   name <- removed[[kk]]
[08:27:37.413]                   NAME <- NAMES[[kk]]
[08:27:37.413]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.413]                     next
[08:27:37.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.413]                 }
[08:27:37.413]                 if (length(args) > 0) 
[08:27:37.413]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.413]             }
[08:27:37.413]             else {
[08:27:37.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.413]             }
[08:27:37.413]             {
[08:27:37.413]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.413]                   0L) {
[08:27:37.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.413]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.413]                   base::options(opts)
[08:27:37.413]                 }
[08:27:37.413]                 {
[08:27:37.413]                   {
[08:27:37.413]                     NULL
[08:27:37.413]                     RNGkind("Mersenne-Twister")
[08:27:37.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:37.413]                       inherits = FALSE)
[08:27:37.413]                   }
[08:27:37.413]                   options(future.plan = NULL)
[08:27:37.413]                   if (is.na(NA_character_)) 
[08:27:37.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.413]                     .init = FALSE)
[08:27:37.413]                 }
[08:27:37.413]             }
[08:27:37.413]         }
[08:27:37.413]     })
[08:27:37.413]     if (TRUE) {
[08:27:37.413]         base::sink(type = "output", split = FALSE)
[08:27:37.413]         if (TRUE) {
[08:27:37.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.413]         }
[08:27:37.413]         else {
[08:27:37.413]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.413]         }
[08:27:37.413]         base::close(...future.stdout)
[08:27:37.413]         ...future.stdout <- NULL
[08:27:37.413]     }
[08:27:37.413]     ...future.result$conditions <- ...future.conditions
[08:27:37.413]     ...future.result$finished <- base::Sys.time()
[08:27:37.413]     ...future.result
[08:27:37.413] }
[08:27:37.415] plan(): Setting new future strategy stack:
[08:27:37.415] List of future strategies:
[08:27:37.415] 1. sequential:
[08:27:37.415]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.415]    - tweaked: FALSE
[08:27:37.415]    - call: NULL
[08:27:37.415] plan(): nbrOfWorkers() = 1
[08:27:37.416] plan(): Setting new future strategy stack:
[08:27:37.416] List of future strategies:
[08:27:37.416] 1. sequential:
[08:27:37.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.416]    - tweaked: FALSE
[08:27:37.416]    - call: plan(strategy)
[08:27:37.417] plan(): nbrOfWorkers() = 1
[08:27:37.417] SequentialFuture started (and completed)
[08:27:37.417] - Launch lazy future ... done
[08:27:37.417] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘<none>’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:37.418] getGlobalsAndPackages() ...
[08:27:37.418] Searching for globals...
[08:27:37.418] 
[08:27:37.418] Searching for globals ... DONE
[08:27:37.418] - globals: [0] <none>
[08:27:37.418] getGlobalsAndPackages() ... DONE
[08:27:37.419] Packages needed by the future expression (n = 0): <none>
[08:27:37.419] Packages needed by future strategies (n = 0): <none>
[08:27:37.419] {
[08:27:37.419]     {
[08:27:37.419]         {
[08:27:37.419]             ...future.startTime <- base::Sys.time()
[08:27:37.419]             {
[08:27:37.419]                 {
[08:27:37.419]                   {
[08:27:37.419]                     base::local({
[08:27:37.419]                       has_future <- base::requireNamespace("future", 
[08:27:37.419]                         quietly = TRUE)
[08:27:37.419]                       if (has_future) {
[08:27:37.419]                         ns <- base::getNamespace("future")
[08:27:37.419]                         version <- ns[[".package"]][["version"]]
[08:27:37.419]                         if (is.null(version)) 
[08:27:37.419]                           version <- utils::packageVersion("future")
[08:27:37.419]                       }
[08:27:37.419]                       else {
[08:27:37.419]                         version <- NULL
[08:27:37.419]                       }
[08:27:37.419]                       if (!has_future || version < "1.8.0") {
[08:27:37.419]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.419]                           "", base::R.version$version.string), 
[08:27:37.419]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:37.419]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.419]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.419]                             "release", "version")], collapse = " "), 
[08:27:37.419]                           hostname = base::Sys.info()[["nodename"]])
[08:27:37.419]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.419]                           info)
[08:27:37.419]                         info <- base::paste(info, collapse = "; ")
[08:27:37.419]                         if (!has_future) {
[08:27:37.419]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.419]                             info)
[08:27:37.419]                         }
[08:27:37.419]                         else {
[08:27:37.419]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.419]                             info, version)
[08:27:37.419]                         }
[08:27:37.419]                         base::stop(msg)
[08:27:37.419]                       }
[08:27:37.419]                     })
[08:27:37.419]                   }
[08:27:37.419]                   ...future.strategy.old <- future::plan("list")
[08:27:37.419]                   options(future.plan = NULL)
[08:27:37.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.419]                 }
[08:27:37.419]                 ...future.workdir <- getwd()
[08:27:37.419]             }
[08:27:37.419]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.419]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.419]         }
[08:27:37.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.419]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.419]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.419]             base::names(...future.oldOptions))
[08:27:37.419]     }
[08:27:37.419]     if (FALSE) {
[08:27:37.419]     }
[08:27:37.419]     else {
[08:27:37.419]         if (TRUE) {
[08:27:37.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.419]                 open = "w")
[08:27:37.419]         }
[08:27:37.419]         else {
[08:27:37.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.419]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.419]         }
[08:27:37.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.419]             base::sink(type = "output", split = FALSE)
[08:27:37.419]             base::close(...future.stdout)
[08:27:37.419]         }, add = TRUE)
[08:27:37.419]     }
[08:27:37.419]     ...future.frame <- base::sys.nframe()
[08:27:37.419]     ...future.conditions <- base::list()
[08:27:37.419]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.419]     if (FALSE) {
[08:27:37.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.419]     }
[08:27:37.419]     ...future.result <- base::tryCatch({
[08:27:37.419]         base::withCallingHandlers({
[08:27:37.419]             ...future.value <- base::withVisible(base::local(42))
[08:27:37.419]             future::FutureResult(value = ...future.value$value, 
[08:27:37.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.419]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.419]                     ...future.globalenv.names))
[08:27:37.419]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.419]         }, condition = base::local({
[08:27:37.419]             c <- base::c
[08:27:37.419]             inherits <- base::inherits
[08:27:37.419]             invokeRestart <- base::invokeRestart
[08:27:37.419]             length <- base::length
[08:27:37.419]             list <- base::list
[08:27:37.419]             seq.int <- base::seq.int
[08:27:37.419]             signalCondition <- base::signalCondition
[08:27:37.419]             sys.calls <- base::sys.calls
[08:27:37.419]             `[[` <- base::`[[`
[08:27:37.419]             `+` <- base::`+`
[08:27:37.419]             `<<-` <- base::`<<-`
[08:27:37.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.419]                   3L)]
[08:27:37.419]             }
[08:27:37.419]             function(cond) {
[08:27:37.419]                 is_error <- inherits(cond, "error")
[08:27:37.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.419]                   NULL)
[08:27:37.419]                 if (is_error) {
[08:27:37.419]                   sessionInformation <- function() {
[08:27:37.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.419]                       search = base::search(), system = base::Sys.info())
[08:27:37.419]                   }
[08:27:37.419]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.419]                     cond$call), session = sessionInformation(), 
[08:27:37.419]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.419]                   signalCondition(cond)
[08:27:37.419]                 }
[08:27:37.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.419]                 "immediateCondition"))) {
[08:27:37.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.419]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.419]                   if (TRUE && !signal) {
[08:27:37.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.419]                     {
[08:27:37.419]                       inherits <- base::inherits
[08:27:37.419]                       invokeRestart <- base::invokeRestart
[08:27:37.419]                       is.null <- base::is.null
[08:27:37.419]                       muffled <- FALSE
[08:27:37.419]                       if (inherits(cond, "message")) {
[08:27:37.419]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.419]                         if (muffled) 
[08:27:37.419]                           invokeRestart("muffleMessage")
[08:27:37.419]                       }
[08:27:37.419]                       else if (inherits(cond, "warning")) {
[08:27:37.419]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.419]                         if (muffled) 
[08:27:37.419]                           invokeRestart("muffleWarning")
[08:27:37.419]                       }
[08:27:37.419]                       else if (inherits(cond, "condition")) {
[08:27:37.419]                         if (!is.null(pattern)) {
[08:27:37.419]                           computeRestarts <- base::computeRestarts
[08:27:37.419]                           grepl <- base::grepl
[08:27:37.419]                           restarts <- computeRestarts(cond)
[08:27:37.419]                           for (restart in restarts) {
[08:27:37.419]                             name <- restart$name
[08:27:37.419]                             if (is.null(name)) 
[08:27:37.419]                               next
[08:27:37.419]                             if (!grepl(pattern, name)) 
[08:27:37.419]                               next
[08:27:37.419]                             invokeRestart(restart)
[08:27:37.419]                             muffled <- TRUE
[08:27:37.419]                             break
[08:27:37.419]                           }
[08:27:37.419]                         }
[08:27:37.419]                       }
[08:27:37.419]                       invisible(muffled)
[08:27:37.419]                     }
[08:27:37.419]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.419]                   }
[08:27:37.419]                 }
[08:27:37.419]                 else {
[08:27:37.419]                   if (TRUE) {
[08:27:37.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.419]                     {
[08:27:37.419]                       inherits <- base::inherits
[08:27:37.419]                       invokeRestart <- base::invokeRestart
[08:27:37.419]                       is.null <- base::is.null
[08:27:37.419]                       muffled <- FALSE
[08:27:37.419]                       if (inherits(cond, "message")) {
[08:27:37.419]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.419]                         if (muffled) 
[08:27:37.419]                           invokeRestart("muffleMessage")
[08:27:37.419]                       }
[08:27:37.419]                       else if (inherits(cond, "warning")) {
[08:27:37.419]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.419]                         if (muffled) 
[08:27:37.419]                           invokeRestart("muffleWarning")
[08:27:37.419]                       }
[08:27:37.419]                       else if (inherits(cond, "condition")) {
[08:27:37.419]                         if (!is.null(pattern)) {
[08:27:37.419]                           computeRestarts <- base::computeRestarts
[08:27:37.419]                           grepl <- base::grepl
[08:27:37.419]                           restarts <- computeRestarts(cond)
[08:27:37.419]                           for (restart in restarts) {
[08:27:37.419]                             name <- restart$name
[08:27:37.419]                             if (is.null(name)) 
[08:27:37.419]                               next
[08:27:37.419]                             if (!grepl(pattern, name)) 
[08:27:37.419]                               next
[08:27:37.419]                             invokeRestart(restart)
[08:27:37.419]                             muffled <- TRUE
[08:27:37.419]                             break
[08:27:37.419]                           }
[08:27:37.419]                         }
[08:27:37.419]                       }
[08:27:37.419]                       invisible(muffled)
[08:27:37.419]                     }
[08:27:37.419]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.419]                   }
[08:27:37.419]                 }
[08:27:37.419]             }
[08:27:37.419]         }))
[08:27:37.419]     }, error = function(ex) {
[08:27:37.419]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.419]                 ...future.rng), started = ...future.startTime, 
[08:27:37.419]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.419]             version = "1.8"), class = "FutureResult")
[08:27:37.419]     }, finally = {
[08:27:37.419]         if (!identical(...future.workdir, getwd())) 
[08:27:37.419]             setwd(...future.workdir)
[08:27:37.419]         {
[08:27:37.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.419]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.419]             }
[08:27:37.419]             base::options(...future.oldOptions)
[08:27:37.419]             if (.Platform$OS.type == "windows") {
[08:27:37.419]                 old_names <- names(...future.oldEnvVars)
[08:27:37.419]                 envs <- base::Sys.getenv()
[08:27:37.419]                 names <- names(envs)
[08:27:37.419]                 common <- intersect(names, old_names)
[08:27:37.419]                 added <- setdiff(names, old_names)
[08:27:37.419]                 removed <- setdiff(old_names, names)
[08:27:37.419]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.419]                   envs[common]]
[08:27:37.419]                 NAMES <- toupper(changed)
[08:27:37.419]                 args <- list()
[08:27:37.419]                 for (kk in seq_along(NAMES)) {
[08:27:37.419]                   name <- changed[[kk]]
[08:27:37.419]                   NAME <- NAMES[[kk]]
[08:27:37.419]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.419]                     next
[08:27:37.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.419]                 }
[08:27:37.419]                 NAMES <- toupper(added)
[08:27:37.419]                 for (kk in seq_along(NAMES)) {
[08:27:37.419]                   name <- added[[kk]]
[08:27:37.419]                   NAME <- NAMES[[kk]]
[08:27:37.419]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.419]                     next
[08:27:37.419]                   args[[name]] <- ""
[08:27:37.419]                 }
[08:27:37.419]                 NAMES <- toupper(removed)
[08:27:37.419]                 for (kk in seq_along(NAMES)) {
[08:27:37.419]                   name <- removed[[kk]]
[08:27:37.419]                   NAME <- NAMES[[kk]]
[08:27:37.419]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.419]                     next
[08:27:37.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.419]                 }
[08:27:37.419]                 if (length(args) > 0) 
[08:27:37.419]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.419]             }
[08:27:37.419]             else {
[08:27:37.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.419]             }
[08:27:37.419]             {
[08:27:37.419]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.419]                   0L) {
[08:27:37.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.419]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.419]                   base::options(opts)
[08:27:37.419]                 }
[08:27:37.419]                 {
[08:27:37.419]                   {
[08:27:37.419]                     NULL
[08:27:37.419]                     RNGkind("Mersenne-Twister")
[08:27:37.419]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:37.419]                       inherits = FALSE)
[08:27:37.419]                   }
[08:27:37.419]                   options(future.plan = NULL)
[08:27:37.419]                   if (is.na(NA_character_)) 
[08:27:37.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.419]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.419]                     .init = FALSE)
[08:27:37.419]                 }
[08:27:37.419]             }
[08:27:37.419]         }
[08:27:37.419]     })
[08:27:37.419]     if (TRUE) {
[08:27:37.419]         base::sink(type = "output", split = FALSE)
[08:27:37.419]         if (TRUE) {
[08:27:37.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.419]         }
[08:27:37.419]         else {
[08:27:37.419]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.419]         }
[08:27:37.419]         base::close(...future.stdout)
[08:27:37.419]         ...future.stdout <- NULL
[08:27:37.419]     }
[08:27:37.419]     ...future.result$conditions <- ...future.conditions
[08:27:37.419]     ...future.result$finished <- base::Sys.time()
[08:27:37.419]     ...future.result
[08:27:37.419] }
[08:27:37.421] plan(): Setting new future strategy stack:
[08:27:37.421] List of future strategies:
[08:27:37.421] 1. sequential:
[08:27:37.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.421]    - tweaked: FALSE
[08:27:37.421]    - call: NULL
[08:27:37.422] plan(): nbrOfWorkers() = 1
[08:27:37.422] plan(): Setting new future strategy stack:
[08:27:37.423] List of future strategies:
[08:27:37.423] 1. sequential:
[08:27:37.423]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.423]    - tweaked: FALSE
[08:27:37.423]    - call: plan(strategy)
[08:27:37.423] plan(): nbrOfWorkers() = 1
[08:27:37.426] SequentialFuture started (and completed)
SequentialFuture:
Label: ‘strategy = sequential’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:37.426] getGlobalsAndPackages() ...
[08:27:37.427] Searching for globals...
[08:27:37.427] 
[08:27:37.427] Searching for globals ... DONE
[08:27:37.427] - globals: [0] <none>
[08:27:37.427] getGlobalsAndPackages() ... DONE
[08:27:37.427] run() for ‘Future’ ...
[08:27:37.427] - state: ‘created’
[08:27:37.428] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:37.428] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:37.428] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:37.428]   - Field: ‘label’
[08:27:37.428]   - Field: ‘local’
[08:27:37.428]   - Field: ‘owner’
[08:27:37.428]   - Field: ‘envir’
[08:27:37.428]   - Field: ‘packages’
[08:27:37.429]   - Field: ‘gc’
[08:27:37.429]   - Field: ‘conditions’
[08:27:37.429]   - Field: ‘expr’
[08:27:37.429]   - Field: ‘uuid’
[08:27:37.429]   - Field: ‘seed’
[08:27:37.429]   - Field: ‘version’
[08:27:37.429]   - Field: ‘result’
[08:27:37.429]   - Field: ‘asynchronous’
[08:27:37.429]   - Field: ‘calls’
[08:27:37.429]   - Field: ‘globals’
[08:27:37.429]   - Field: ‘stdout’
[08:27:37.429]   - Field: ‘earlySignal’
[08:27:37.430]   - Field: ‘lazy’
[08:27:37.430]   - Field: ‘state’
[08:27:37.430] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:37.430] - Launch lazy future ...
[08:27:37.430] Packages needed by the future expression (n = 0): <none>
[08:27:37.430] Packages needed by future strategies (n = 0): <none>
[08:27:37.431] {
[08:27:37.431]     {
[08:27:37.431]         {
[08:27:37.431]             ...future.startTime <- base::Sys.time()
[08:27:37.431]             {
[08:27:37.431]                 {
[08:27:37.431]                   {
[08:27:37.431]                     base::local({
[08:27:37.431]                       has_future <- base::requireNamespace("future", 
[08:27:37.431]                         quietly = TRUE)
[08:27:37.431]                       if (has_future) {
[08:27:37.431]                         ns <- base::getNamespace("future")
[08:27:37.431]                         version <- ns[[".package"]][["version"]]
[08:27:37.431]                         if (is.null(version)) 
[08:27:37.431]                           version <- utils::packageVersion("future")
[08:27:37.431]                       }
[08:27:37.431]                       else {
[08:27:37.431]                         version <- NULL
[08:27:37.431]                       }
[08:27:37.431]                       if (!has_future || version < "1.8.0") {
[08:27:37.431]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.431]                           "", base::R.version$version.string), 
[08:27:37.431]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:37.431]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.431]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.431]                             "release", "version")], collapse = " "), 
[08:27:37.431]                           hostname = base::Sys.info()[["nodename"]])
[08:27:37.431]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.431]                           info)
[08:27:37.431]                         info <- base::paste(info, collapse = "; ")
[08:27:37.431]                         if (!has_future) {
[08:27:37.431]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.431]                             info)
[08:27:37.431]                         }
[08:27:37.431]                         else {
[08:27:37.431]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.431]                             info, version)
[08:27:37.431]                         }
[08:27:37.431]                         base::stop(msg)
[08:27:37.431]                       }
[08:27:37.431]                     })
[08:27:37.431]                   }
[08:27:37.431]                   ...future.strategy.old <- future::plan("list")
[08:27:37.431]                   options(future.plan = NULL)
[08:27:37.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.431]                 }
[08:27:37.431]                 ...future.workdir <- getwd()
[08:27:37.431]             }
[08:27:37.431]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.431]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.431]         }
[08:27:37.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.431]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.431]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.431]             base::names(...future.oldOptions))
[08:27:37.431]     }
[08:27:37.431]     if (FALSE) {
[08:27:37.431]     }
[08:27:37.431]     else {
[08:27:37.431]         if (TRUE) {
[08:27:37.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.431]                 open = "w")
[08:27:37.431]         }
[08:27:37.431]         else {
[08:27:37.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.431]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.431]         }
[08:27:37.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.431]             base::sink(type = "output", split = FALSE)
[08:27:37.431]             base::close(...future.stdout)
[08:27:37.431]         }, add = TRUE)
[08:27:37.431]     }
[08:27:37.431]     ...future.frame <- base::sys.nframe()
[08:27:37.431]     ...future.conditions <- base::list()
[08:27:37.431]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.431]     if (FALSE) {
[08:27:37.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.431]     }
[08:27:37.431]     ...future.result <- base::tryCatch({
[08:27:37.431]         base::withCallingHandlers({
[08:27:37.431]             ...future.value <- base::withVisible(base::local(42))
[08:27:37.431]             future::FutureResult(value = ...future.value$value, 
[08:27:37.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.431]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.431]                     ...future.globalenv.names))
[08:27:37.431]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.431]         }, condition = base::local({
[08:27:37.431]             c <- base::c
[08:27:37.431]             inherits <- base::inherits
[08:27:37.431]             invokeRestart <- base::invokeRestart
[08:27:37.431]             length <- base::length
[08:27:37.431]             list <- base::list
[08:27:37.431]             seq.int <- base::seq.int
[08:27:37.431]             signalCondition <- base::signalCondition
[08:27:37.431]             sys.calls <- base::sys.calls
[08:27:37.431]             `[[` <- base::`[[`
[08:27:37.431]             `+` <- base::`+`
[08:27:37.431]             `<<-` <- base::`<<-`
[08:27:37.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.431]                   3L)]
[08:27:37.431]             }
[08:27:37.431]             function(cond) {
[08:27:37.431]                 is_error <- inherits(cond, "error")
[08:27:37.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.431]                   NULL)
[08:27:37.431]                 if (is_error) {
[08:27:37.431]                   sessionInformation <- function() {
[08:27:37.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.431]                       search = base::search(), system = base::Sys.info())
[08:27:37.431]                   }
[08:27:37.431]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.431]                     cond$call), session = sessionInformation(), 
[08:27:37.431]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.431]                   signalCondition(cond)
[08:27:37.431]                 }
[08:27:37.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.431]                 "immediateCondition"))) {
[08:27:37.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.431]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.431]                   if (TRUE && !signal) {
[08:27:37.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.431]                     {
[08:27:37.431]                       inherits <- base::inherits
[08:27:37.431]                       invokeRestart <- base::invokeRestart
[08:27:37.431]                       is.null <- base::is.null
[08:27:37.431]                       muffled <- FALSE
[08:27:37.431]                       if (inherits(cond, "message")) {
[08:27:37.431]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.431]                         if (muffled) 
[08:27:37.431]                           invokeRestart("muffleMessage")
[08:27:37.431]                       }
[08:27:37.431]                       else if (inherits(cond, "warning")) {
[08:27:37.431]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.431]                         if (muffled) 
[08:27:37.431]                           invokeRestart("muffleWarning")
[08:27:37.431]                       }
[08:27:37.431]                       else if (inherits(cond, "condition")) {
[08:27:37.431]                         if (!is.null(pattern)) {
[08:27:37.431]                           computeRestarts <- base::computeRestarts
[08:27:37.431]                           grepl <- base::grepl
[08:27:37.431]                           restarts <- computeRestarts(cond)
[08:27:37.431]                           for (restart in restarts) {
[08:27:37.431]                             name <- restart$name
[08:27:37.431]                             if (is.null(name)) 
[08:27:37.431]                               next
[08:27:37.431]                             if (!grepl(pattern, name)) 
[08:27:37.431]                               next
[08:27:37.431]                             invokeRestart(restart)
[08:27:37.431]                             muffled <- TRUE
[08:27:37.431]                             break
[08:27:37.431]                           }
[08:27:37.431]                         }
[08:27:37.431]                       }
[08:27:37.431]                       invisible(muffled)
[08:27:37.431]                     }
[08:27:37.431]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.431]                   }
[08:27:37.431]                 }
[08:27:37.431]                 else {
[08:27:37.431]                   if (TRUE) {
[08:27:37.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.431]                     {
[08:27:37.431]                       inherits <- base::inherits
[08:27:37.431]                       invokeRestart <- base::invokeRestart
[08:27:37.431]                       is.null <- base::is.null
[08:27:37.431]                       muffled <- FALSE
[08:27:37.431]                       if (inherits(cond, "message")) {
[08:27:37.431]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.431]                         if (muffled) 
[08:27:37.431]                           invokeRestart("muffleMessage")
[08:27:37.431]                       }
[08:27:37.431]                       else if (inherits(cond, "warning")) {
[08:27:37.431]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.431]                         if (muffled) 
[08:27:37.431]                           invokeRestart("muffleWarning")
[08:27:37.431]                       }
[08:27:37.431]                       else if (inherits(cond, "condition")) {
[08:27:37.431]                         if (!is.null(pattern)) {
[08:27:37.431]                           computeRestarts <- base::computeRestarts
[08:27:37.431]                           grepl <- base::grepl
[08:27:37.431]                           restarts <- computeRestarts(cond)
[08:27:37.431]                           for (restart in restarts) {
[08:27:37.431]                             name <- restart$name
[08:27:37.431]                             if (is.null(name)) 
[08:27:37.431]                               next
[08:27:37.431]                             if (!grepl(pattern, name)) 
[08:27:37.431]                               next
[08:27:37.431]                             invokeRestart(restart)
[08:27:37.431]                             muffled <- TRUE
[08:27:37.431]                             break
[08:27:37.431]                           }
[08:27:37.431]                         }
[08:27:37.431]                       }
[08:27:37.431]                       invisible(muffled)
[08:27:37.431]                     }
[08:27:37.431]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.431]                   }
[08:27:37.431]                 }
[08:27:37.431]             }
[08:27:37.431]         }))
[08:27:37.431]     }, error = function(ex) {
[08:27:37.431]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.431]                 ...future.rng), started = ...future.startTime, 
[08:27:37.431]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.431]             version = "1.8"), class = "FutureResult")
[08:27:37.431]     }, finally = {
[08:27:37.431]         if (!identical(...future.workdir, getwd())) 
[08:27:37.431]             setwd(...future.workdir)
[08:27:37.431]         {
[08:27:37.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.431]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.431]             }
[08:27:37.431]             base::options(...future.oldOptions)
[08:27:37.431]             if (.Platform$OS.type == "windows") {
[08:27:37.431]                 old_names <- names(...future.oldEnvVars)
[08:27:37.431]                 envs <- base::Sys.getenv()
[08:27:37.431]                 names <- names(envs)
[08:27:37.431]                 common <- intersect(names, old_names)
[08:27:37.431]                 added <- setdiff(names, old_names)
[08:27:37.431]                 removed <- setdiff(old_names, names)
[08:27:37.431]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.431]                   envs[common]]
[08:27:37.431]                 NAMES <- toupper(changed)
[08:27:37.431]                 args <- list()
[08:27:37.431]                 for (kk in seq_along(NAMES)) {
[08:27:37.431]                   name <- changed[[kk]]
[08:27:37.431]                   NAME <- NAMES[[kk]]
[08:27:37.431]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.431]                     next
[08:27:37.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.431]                 }
[08:27:37.431]                 NAMES <- toupper(added)
[08:27:37.431]                 for (kk in seq_along(NAMES)) {
[08:27:37.431]                   name <- added[[kk]]
[08:27:37.431]                   NAME <- NAMES[[kk]]
[08:27:37.431]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.431]                     next
[08:27:37.431]                   args[[name]] <- ""
[08:27:37.431]                 }
[08:27:37.431]                 NAMES <- toupper(removed)
[08:27:37.431]                 for (kk in seq_along(NAMES)) {
[08:27:37.431]                   name <- removed[[kk]]
[08:27:37.431]                   NAME <- NAMES[[kk]]
[08:27:37.431]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.431]                     next
[08:27:37.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.431]                 }
[08:27:37.431]                 if (length(args) > 0) 
[08:27:37.431]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.431]             }
[08:27:37.431]             else {
[08:27:37.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.431]             }
[08:27:37.431]             {
[08:27:37.431]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.431]                   0L) {
[08:27:37.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.431]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.431]                   base::options(opts)
[08:27:37.431]                 }
[08:27:37.431]                 {
[08:27:37.431]                   {
[08:27:37.431]                     NULL
[08:27:37.431]                     RNGkind("Mersenne-Twister")
[08:27:37.431]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:37.431]                       inherits = FALSE)
[08:27:37.431]                   }
[08:27:37.431]                   options(future.plan = NULL)
[08:27:37.431]                   if (is.na(NA_character_)) 
[08:27:37.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.431]                     .init = FALSE)
[08:27:37.431]                 }
[08:27:37.431]             }
[08:27:37.431]         }
[08:27:37.431]     })
[08:27:37.431]     if (TRUE) {
[08:27:37.431]         base::sink(type = "output", split = FALSE)
[08:27:37.431]         if (TRUE) {
[08:27:37.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.431]         }
[08:27:37.431]         else {
[08:27:37.431]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.431]         }
[08:27:37.431]         base::close(...future.stdout)
[08:27:37.431]         ...future.stdout <- NULL
[08:27:37.431]     }
[08:27:37.431]     ...future.result$conditions <- ...future.conditions
[08:27:37.431]     ...future.result$finished <- base::Sys.time()
[08:27:37.431]     ...future.result
[08:27:37.431] }
[08:27:37.432] plan(): Setting new future strategy stack:
[08:27:37.432] List of future strategies:
[08:27:37.432] 1. sequential:
[08:27:37.432]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.432]    - tweaked: FALSE
[08:27:37.432]    - call: NULL
[08:27:37.433] plan(): nbrOfWorkers() = 1
[08:27:37.434] plan(): Setting new future strategy stack:
[08:27:37.434] List of future strategies:
[08:27:37.434] 1. sequential:
[08:27:37.434]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.434]    - tweaked: FALSE
[08:27:37.434]    - call: plan(strategy)
[08:27:37.434] plan(): nbrOfWorkers() = 1
[08:27:37.434] SequentialFuture started (and completed)
[08:27:37.434] - Launch lazy future ... done
[08:27:37.435] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘strategy = sequential’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:37.435] getGlobalsAndPackages() ...
[08:27:37.435] Searching for globals...
[08:27:37.436] - globals found: [1] ‘{’
[08:27:37.436] Searching for globals ... DONE
[08:27:37.436] Resolving globals: FALSE
[08:27:37.436] 
[08:27:37.436] 
[08:27:37.437] getGlobalsAndPackages() ... DONE
[08:27:37.437] run() for ‘Future’ ...
[08:27:37.437] - state: ‘created’
[08:27:37.437] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:37.437] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:37.437] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:37.437]   - Field: ‘label’
[08:27:37.438]   - Field: ‘local’
[08:27:37.438]   - Field: ‘owner’
[08:27:37.438]   - Field: ‘envir’
[08:27:37.438]   - Field: ‘packages’
[08:27:37.438]   - Field: ‘gc’
[08:27:37.438]   - Field: ‘conditions’
[08:27:37.438]   - Field: ‘expr’
[08:27:37.438]   - Field: ‘uuid’
[08:27:37.438]   - Field: ‘seed’
[08:27:37.438]   - Field: ‘version’
[08:27:37.438]   - Field: ‘result’
[08:27:37.438]   - Field: ‘asynchronous’
[08:27:37.439]   - Field: ‘calls’
[08:27:37.439]   - Field: ‘globals’
[08:27:37.439]   - Field: ‘stdout’
[08:27:37.439]   - Field: ‘earlySignal’
[08:27:37.439]   - Field: ‘lazy’
[08:27:37.439]   - Field: ‘state’
[08:27:37.439] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:37.439] - Launch lazy future ...
[08:27:37.439] Packages needed by the future expression (n = 0): <none>
[08:27:37.439] Packages needed by future strategies (n = 0): <none>
[08:27:37.440] {
[08:27:37.440]     {
[08:27:37.440]         {
[08:27:37.440]             ...future.startTime <- base::Sys.time()
[08:27:37.440]             {
[08:27:37.440]                 {
[08:27:37.440]                   {
[08:27:37.440]                     base::local({
[08:27:37.440]                       has_future <- base::requireNamespace("future", 
[08:27:37.440]                         quietly = TRUE)
[08:27:37.440]                       if (has_future) {
[08:27:37.440]                         ns <- base::getNamespace("future")
[08:27:37.440]                         version <- ns[[".package"]][["version"]]
[08:27:37.440]                         if (is.null(version)) 
[08:27:37.440]                           version <- utils::packageVersion("future")
[08:27:37.440]                       }
[08:27:37.440]                       else {
[08:27:37.440]                         version <- NULL
[08:27:37.440]                       }
[08:27:37.440]                       if (!has_future || version < "1.8.0") {
[08:27:37.440]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.440]                           "", base::R.version$version.string), 
[08:27:37.440]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:37.440]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.440]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.440]                             "release", "version")], collapse = " "), 
[08:27:37.440]                           hostname = base::Sys.info()[["nodename"]])
[08:27:37.440]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.440]                           info)
[08:27:37.440]                         info <- base::paste(info, collapse = "; ")
[08:27:37.440]                         if (!has_future) {
[08:27:37.440]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.440]                             info)
[08:27:37.440]                         }
[08:27:37.440]                         else {
[08:27:37.440]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.440]                             info, version)
[08:27:37.440]                         }
[08:27:37.440]                         base::stop(msg)
[08:27:37.440]                       }
[08:27:37.440]                     })
[08:27:37.440]                   }
[08:27:37.440]                   ...future.strategy.old <- future::plan("list")
[08:27:37.440]                   options(future.plan = NULL)
[08:27:37.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.440]                 }
[08:27:37.440]                 ...future.workdir <- getwd()
[08:27:37.440]             }
[08:27:37.440]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.440]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.440]         }
[08:27:37.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.440]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.440]             base::names(...future.oldOptions))
[08:27:37.440]     }
[08:27:37.440]     if (FALSE) {
[08:27:37.440]     }
[08:27:37.440]     else {
[08:27:37.440]         if (TRUE) {
[08:27:37.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.440]                 open = "w")
[08:27:37.440]         }
[08:27:37.440]         else {
[08:27:37.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.440]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.440]         }
[08:27:37.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.440]             base::sink(type = "output", split = FALSE)
[08:27:37.440]             base::close(...future.stdout)
[08:27:37.440]         }, add = TRUE)
[08:27:37.440]     }
[08:27:37.440]     ...future.frame <- base::sys.nframe()
[08:27:37.440]     ...future.conditions <- base::list()
[08:27:37.440]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.440]     if (FALSE) {
[08:27:37.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.440]     }
[08:27:37.440]     ...future.result <- base::tryCatch({
[08:27:37.440]         base::withCallingHandlers({
[08:27:37.440]             ...future.value <- base::withVisible(base::local({
[08:27:37.440]                 42
[08:27:37.440]             }))
[08:27:37.440]             future::FutureResult(value = ...future.value$value, 
[08:27:37.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.440]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.440]                     ...future.globalenv.names))
[08:27:37.440]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.440]         }, condition = base::local({
[08:27:37.440]             c <- base::c
[08:27:37.440]             inherits <- base::inherits
[08:27:37.440]             invokeRestart <- base::invokeRestart
[08:27:37.440]             length <- base::length
[08:27:37.440]             list <- base::list
[08:27:37.440]             seq.int <- base::seq.int
[08:27:37.440]             signalCondition <- base::signalCondition
[08:27:37.440]             sys.calls <- base::sys.calls
[08:27:37.440]             `[[` <- base::`[[`
[08:27:37.440]             `+` <- base::`+`
[08:27:37.440]             `<<-` <- base::`<<-`
[08:27:37.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.440]                   3L)]
[08:27:37.440]             }
[08:27:37.440]             function(cond) {
[08:27:37.440]                 is_error <- inherits(cond, "error")
[08:27:37.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.440]                   NULL)
[08:27:37.440]                 if (is_error) {
[08:27:37.440]                   sessionInformation <- function() {
[08:27:37.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.440]                       search = base::search(), system = base::Sys.info())
[08:27:37.440]                   }
[08:27:37.440]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.440]                     cond$call), session = sessionInformation(), 
[08:27:37.440]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.440]                   signalCondition(cond)
[08:27:37.440]                 }
[08:27:37.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.440]                 "immediateCondition"))) {
[08:27:37.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.440]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.440]                   if (TRUE && !signal) {
[08:27:37.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.440]                     {
[08:27:37.440]                       inherits <- base::inherits
[08:27:37.440]                       invokeRestart <- base::invokeRestart
[08:27:37.440]                       is.null <- base::is.null
[08:27:37.440]                       muffled <- FALSE
[08:27:37.440]                       if (inherits(cond, "message")) {
[08:27:37.440]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.440]                         if (muffled) 
[08:27:37.440]                           invokeRestart("muffleMessage")
[08:27:37.440]                       }
[08:27:37.440]                       else if (inherits(cond, "warning")) {
[08:27:37.440]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.440]                         if (muffled) 
[08:27:37.440]                           invokeRestart("muffleWarning")
[08:27:37.440]                       }
[08:27:37.440]                       else if (inherits(cond, "condition")) {
[08:27:37.440]                         if (!is.null(pattern)) {
[08:27:37.440]                           computeRestarts <- base::computeRestarts
[08:27:37.440]                           grepl <- base::grepl
[08:27:37.440]                           restarts <- computeRestarts(cond)
[08:27:37.440]                           for (restart in restarts) {
[08:27:37.440]                             name <- restart$name
[08:27:37.440]                             if (is.null(name)) 
[08:27:37.440]                               next
[08:27:37.440]                             if (!grepl(pattern, name)) 
[08:27:37.440]                               next
[08:27:37.440]                             invokeRestart(restart)
[08:27:37.440]                             muffled <- TRUE
[08:27:37.440]                             break
[08:27:37.440]                           }
[08:27:37.440]                         }
[08:27:37.440]                       }
[08:27:37.440]                       invisible(muffled)
[08:27:37.440]                     }
[08:27:37.440]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.440]                   }
[08:27:37.440]                 }
[08:27:37.440]                 else {
[08:27:37.440]                   if (TRUE) {
[08:27:37.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.440]                     {
[08:27:37.440]                       inherits <- base::inherits
[08:27:37.440]                       invokeRestart <- base::invokeRestart
[08:27:37.440]                       is.null <- base::is.null
[08:27:37.440]                       muffled <- FALSE
[08:27:37.440]                       if (inherits(cond, "message")) {
[08:27:37.440]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.440]                         if (muffled) 
[08:27:37.440]                           invokeRestart("muffleMessage")
[08:27:37.440]                       }
[08:27:37.440]                       else if (inherits(cond, "warning")) {
[08:27:37.440]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.440]                         if (muffled) 
[08:27:37.440]                           invokeRestart("muffleWarning")
[08:27:37.440]                       }
[08:27:37.440]                       else if (inherits(cond, "condition")) {
[08:27:37.440]                         if (!is.null(pattern)) {
[08:27:37.440]                           computeRestarts <- base::computeRestarts
[08:27:37.440]                           grepl <- base::grepl
[08:27:37.440]                           restarts <- computeRestarts(cond)
[08:27:37.440]                           for (restart in restarts) {
[08:27:37.440]                             name <- restart$name
[08:27:37.440]                             if (is.null(name)) 
[08:27:37.440]                               next
[08:27:37.440]                             if (!grepl(pattern, name)) 
[08:27:37.440]                               next
[08:27:37.440]                             invokeRestart(restart)
[08:27:37.440]                             muffled <- TRUE
[08:27:37.440]                             break
[08:27:37.440]                           }
[08:27:37.440]                         }
[08:27:37.440]                       }
[08:27:37.440]                       invisible(muffled)
[08:27:37.440]                     }
[08:27:37.440]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.440]                   }
[08:27:37.440]                 }
[08:27:37.440]             }
[08:27:37.440]         }))
[08:27:37.440]     }, error = function(ex) {
[08:27:37.440]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.440]                 ...future.rng), started = ...future.startTime, 
[08:27:37.440]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.440]             version = "1.8"), class = "FutureResult")
[08:27:37.440]     }, finally = {
[08:27:37.440]         if (!identical(...future.workdir, getwd())) 
[08:27:37.440]             setwd(...future.workdir)
[08:27:37.440]         {
[08:27:37.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.440]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.440]             }
[08:27:37.440]             base::options(...future.oldOptions)
[08:27:37.440]             if (.Platform$OS.type == "windows") {
[08:27:37.440]                 old_names <- names(...future.oldEnvVars)
[08:27:37.440]                 envs <- base::Sys.getenv()
[08:27:37.440]                 names <- names(envs)
[08:27:37.440]                 common <- intersect(names, old_names)
[08:27:37.440]                 added <- setdiff(names, old_names)
[08:27:37.440]                 removed <- setdiff(old_names, names)
[08:27:37.440]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.440]                   envs[common]]
[08:27:37.440]                 NAMES <- toupper(changed)
[08:27:37.440]                 args <- list()
[08:27:37.440]                 for (kk in seq_along(NAMES)) {
[08:27:37.440]                   name <- changed[[kk]]
[08:27:37.440]                   NAME <- NAMES[[kk]]
[08:27:37.440]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.440]                     next
[08:27:37.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.440]                 }
[08:27:37.440]                 NAMES <- toupper(added)
[08:27:37.440]                 for (kk in seq_along(NAMES)) {
[08:27:37.440]                   name <- added[[kk]]
[08:27:37.440]                   NAME <- NAMES[[kk]]
[08:27:37.440]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.440]                     next
[08:27:37.440]                   args[[name]] <- ""
[08:27:37.440]                 }
[08:27:37.440]                 NAMES <- toupper(removed)
[08:27:37.440]                 for (kk in seq_along(NAMES)) {
[08:27:37.440]                   name <- removed[[kk]]
[08:27:37.440]                   NAME <- NAMES[[kk]]
[08:27:37.440]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.440]                     next
[08:27:37.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.440]                 }
[08:27:37.440]                 if (length(args) > 0) 
[08:27:37.440]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.440]             }
[08:27:37.440]             else {
[08:27:37.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.440]             }
[08:27:37.440]             {
[08:27:37.440]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.440]                   0L) {
[08:27:37.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.440]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.440]                   base::options(opts)
[08:27:37.440]                 }
[08:27:37.440]                 {
[08:27:37.440]                   {
[08:27:37.440]                     NULL
[08:27:37.440]                     RNGkind("Mersenne-Twister")
[08:27:37.440]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:37.440]                       inherits = FALSE)
[08:27:37.440]                   }
[08:27:37.440]                   options(future.plan = NULL)
[08:27:37.440]                   if (is.na(NA_character_)) 
[08:27:37.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.440]                     .init = FALSE)
[08:27:37.440]                 }
[08:27:37.440]             }
[08:27:37.440]         }
[08:27:37.440]     })
[08:27:37.440]     if (TRUE) {
[08:27:37.440]         base::sink(type = "output", split = FALSE)
[08:27:37.440]         if (TRUE) {
[08:27:37.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.440]         }
[08:27:37.440]         else {
[08:27:37.440]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.440]         }
[08:27:37.440]         base::close(...future.stdout)
[08:27:37.440]         ...future.stdout <- NULL
[08:27:37.440]     }
[08:27:37.440]     ...future.result$conditions <- ...future.conditions
[08:27:37.440]     ...future.result$finished <- base::Sys.time()
[08:27:37.440]     ...future.result
[08:27:37.440] }
[08:27:37.442] plan(): Setting new future strategy stack:
[08:27:37.442] List of future strategies:
[08:27:37.442] 1. sequential:
[08:27:37.442]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.442]    - tweaked: FALSE
[08:27:37.442]    - call: NULL
[08:27:37.442] plan(): nbrOfWorkers() = 1
[08:27:37.443] plan(): Setting new future strategy stack:
[08:27:37.443] List of future strategies:
[08:27:37.443] 1. sequential:
[08:27:37.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.443]    - tweaked: FALSE
[08:27:37.443]    - call: plan(strategy)
[08:27:37.443] plan(): nbrOfWorkers() = 1
[08:27:37.444] SequentialFuture started (and completed)
[08:27:37.444] - Launch lazy future ... done
[08:27:37.444] run() for ‘SequentialFuture’ ... done
SequentialFuture:
Label: ‘strategy = sequential’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: FALSE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: TRUE
Value: 39 bytes of class ‘numeric’
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
- plan('sequential') ... DONE
- plan('multicore') ...
[08:27:37.445] plan(): Setting new future strategy stack:
[08:27:37.445] List of future strategies:
[08:27:37.445] 1. multicore:
[08:27:37.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:37.445]    - tweaked: FALSE
[08:27:37.445]    - call: plan(strategy)
[08:27:37.447] plan(): nbrOfWorkers() = 2
[08:27:37.448] getGlobalsAndPackages() ...
[08:27:37.448] 
[08:27:37.448] - globals: [0] <none>
[08:27:37.449] getGlobalsAndPackages() ... DONE
[08:27:37.450] Packages needed by the future expression (n = 0): <none>
[08:27:37.450] Packages needed by future strategies (n = 0): <none>
[08:27:37.450] {
[08:27:37.450]     {
[08:27:37.450]         {
[08:27:37.450]             ...future.startTime <- base::Sys.time()
[08:27:37.450]             {
[08:27:37.450]                 {
[08:27:37.450]                   {
[08:27:37.450]                     {
[08:27:37.450]                       base::local({
[08:27:37.450]                         has_future <- base::requireNamespace("future", 
[08:27:37.450]                           quietly = TRUE)
[08:27:37.450]                         if (has_future) {
[08:27:37.450]                           ns <- base::getNamespace("future")
[08:27:37.450]                           version <- ns[[".package"]][["version"]]
[08:27:37.450]                           if (is.null(version)) 
[08:27:37.450]                             version <- utils::packageVersion("future")
[08:27:37.450]                         }
[08:27:37.450]                         else {
[08:27:37.450]                           version <- NULL
[08:27:37.450]                         }
[08:27:37.450]                         if (!has_future || version < "1.8.0") {
[08:27:37.450]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.450]                             "", base::R.version$version.string), 
[08:27:37.450]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:37.450]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.450]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.450]                               "release", "version")], collapse = " "), 
[08:27:37.450]                             hostname = base::Sys.info()[["nodename"]])
[08:27:37.450]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.450]                             info)
[08:27:37.450]                           info <- base::paste(info, collapse = "; ")
[08:27:37.450]                           if (!has_future) {
[08:27:37.450]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.450]                               info)
[08:27:37.450]                           }
[08:27:37.450]                           else {
[08:27:37.450]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.450]                               info, version)
[08:27:37.450]                           }
[08:27:37.450]                           base::stop(msg)
[08:27:37.450]                         }
[08:27:37.450]                       })
[08:27:37.450]                     }
[08:27:37.450]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:37.450]                     base::options(mc.cores = 1L)
[08:27:37.450]                   }
[08:27:37.450]                   ...future.strategy.old <- future::plan("list")
[08:27:37.450]                   options(future.plan = NULL)
[08:27:37.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.450]                 }
[08:27:37.450]                 ...future.workdir <- getwd()
[08:27:37.450]             }
[08:27:37.450]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.450]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.450]         }
[08:27:37.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.450]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.450]             base::names(...future.oldOptions))
[08:27:37.450]     }
[08:27:37.450]     if (FALSE) {
[08:27:37.450]     }
[08:27:37.450]     else {
[08:27:37.450]         if (TRUE) {
[08:27:37.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.450]                 open = "w")
[08:27:37.450]         }
[08:27:37.450]         else {
[08:27:37.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.450]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.450]         }
[08:27:37.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.450]             base::sink(type = "output", split = FALSE)
[08:27:37.450]             base::close(...future.stdout)
[08:27:37.450]         }, add = TRUE)
[08:27:37.450]     }
[08:27:37.450]     ...future.frame <- base::sys.nframe()
[08:27:37.450]     ...future.conditions <- base::list()
[08:27:37.450]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.450]     if (FALSE) {
[08:27:37.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.450]     }
[08:27:37.450]     ...future.result <- base::tryCatch({
[08:27:37.450]         base::withCallingHandlers({
[08:27:37.450]             ...future.value <- base::withVisible(base::local({
[08:27:37.450]                 withCallingHandlers({
[08:27:37.450]                   42
[08:27:37.450]                 }, immediateCondition = function(cond) {
[08:27:37.450]                   save_rds <- function (object, pathname, ...) 
[08:27:37.450]                   {
[08:27:37.450]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:37.450]                     if (file_test("-f", pathname_tmp)) {
[08:27:37.450]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.450]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:37.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.450]                         fi_tmp[["mtime"]])
[08:27:37.450]                     }
[08:27:37.450]                     tryCatch({
[08:27:37.450]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:37.450]                     }, error = function(ex) {
[08:27:37.450]                       msg <- conditionMessage(ex)
[08:27:37.450]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.450]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:37.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.450]                         fi_tmp[["mtime"]], msg)
[08:27:37.450]                       ex$message <- msg
[08:27:37.450]                       stop(ex)
[08:27:37.450]                     })
[08:27:37.450]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:37.450]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:37.450]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:37.450]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.450]                       fi <- file.info(pathname)
[08:27:37.450]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:37.450]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.450]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:37.450]                         fi[["size"]], fi[["mtime"]])
[08:27:37.450]                       stop(msg)
[08:27:37.450]                     }
[08:27:37.450]                     invisible(pathname)
[08:27:37.450]                   }
[08:27:37.450]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:37.450]                     rootPath = tempdir()) 
[08:27:37.450]                   {
[08:27:37.450]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:37.450]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:37.450]                       tmpdir = path, fileext = ".rds")
[08:27:37.450]                     save_rds(obj, file)
[08:27:37.450]                   }
[08:27:37.450]                   saveImmediateCondition(cond, path = "/tmp/Rtmp36ZR1r/.future/immediateConditions")
[08:27:37.450]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.450]                   {
[08:27:37.450]                     inherits <- base::inherits
[08:27:37.450]                     invokeRestart <- base::invokeRestart
[08:27:37.450]                     is.null <- base::is.null
[08:27:37.450]                     muffled <- FALSE
[08:27:37.450]                     if (inherits(cond, "message")) {
[08:27:37.450]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:37.450]                       if (muffled) 
[08:27:37.450]                         invokeRestart("muffleMessage")
[08:27:37.450]                     }
[08:27:37.450]                     else if (inherits(cond, "warning")) {
[08:27:37.450]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:37.450]                       if (muffled) 
[08:27:37.450]                         invokeRestart("muffleWarning")
[08:27:37.450]                     }
[08:27:37.450]                     else if (inherits(cond, "condition")) {
[08:27:37.450]                       if (!is.null(pattern)) {
[08:27:37.450]                         computeRestarts <- base::computeRestarts
[08:27:37.450]                         grepl <- base::grepl
[08:27:37.450]                         restarts <- computeRestarts(cond)
[08:27:37.450]                         for (restart in restarts) {
[08:27:37.450]                           name <- restart$name
[08:27:37.450]                           if (is.null(name)) 
[08:27:37.450]                             next
[08:27:37.450]                           if (!grepl(pattern, name)) 
[08:27:37.450]                             next
[08:27:37.450]                           invokeRestart(restart)
[08:27:37.450]                           muffled <- TRUE
[08:27:37.450]                           break
[08:27:37.450]                         }
[08:27:37.450]                       }
[08:27:37.450]                     }
[08:27:37.450]                     invisible(muffled)
[08:27:37.450]                   }
[08:27:37.450]                   muffleCondition(cond)
[08:27:37.450]                 })
[08:27:37.450]             }))
[08:27:37.450]             future::FutureResult(value = ...future.value$value, 
[08:27:37.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.450]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.450]                     ...future.globalenv.names))
[08:27:37.450]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.450]         }, condition = base::local({
[08:27:37.450]             c <- base::c
[08:27:37.450]             inherits <- base::inherits
[08:27:37.450]             invokeRestart <- base::invokeRestart
[08:27:37.450]             length <- base::length
[08:27:37.450]             list <- base::list
[08:27:37.450]             seq.int <- base::seq.int
[08:27:37.450]             signalCondition <- base::signalCondition
[08:27:37.450]             sys.calls <- base::sys.calls
[08:27:37.450]             `[[` <- base::`[[`
[08:27:37.450]             `+` <- base::`+`
[08:27:37.450]             `<<-` <- base::`<<-`
[08:27:37.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.450]                   3L)]
[08:27:37.450]             }
[08:27:37.450]             function(cond) {
[08:27:37.450]                 is_error <- inherits(cond, "error")
[08:27:37.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.450]                   NULL)
[08:27:37.450]                 if (is_error) {
[08:27:37.450]                   sessionInformation <- function() {
[08:27:37.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.450]                       search = base::search(), system = base::Sys.info())
[08:27:37.450]                   }
[08:27:37.450]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.450]                     cond$call), session = sessionInformation(), 
[08:27:37.450]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.450]                   signalCondition(cond)
[08:27:37.450]                 }
[08:27:37.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.450]                 "immediateCondition"))) {
[08:27:37.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.450]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.450]                   if (TRUE && !signal) {
[08:27:37.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.450]                     {
[08:27:37.450]                       inherits <- base::inherits
[08:27:37.450]                       invokeRestart <- base::invokeRestart
[08:27:37.450]                       is.null <- base::is.null
[08:27:37.450]                       muffled <- FALSE
[08:27:37.450]                       if (inherits(cond, "message")) {
[08:27:37.450]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.450]                         if (muffled) 
[08:27:37.450]                           invokeRestart("muffleMessage")
[08:27:37.450]                       }
[08:27:37.450]                       else if (inherits(cond, "warning")) {
[08:27:37.450]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.450]                         if (muffled) 
[08:27:37.450]                           invokeRestart("muffleWarning")
[08:27:37.450]                       }
[08:27:37.450]                       else if (inherits(cond, "condition")) {
[08:27:37.450]                         if (!is.null(pattern)) {
[08:27:37.450]                           computeRestarts <- base::computeRestarts
[08:27:37.450]                           grepl <- base::grepl
[08:27:37.450]                           restarts <- computeRestarts(cond)
[08:27:37.450]                           for (restart in restarts) {
[08:27:37.450]                             name <- restart$name
[08:27:37.450]                             if (is.null(name)) 
[08:27:37.450]                               next
[08:27:37.450]                             if (!grepl(pattern, name)) 
[08:27:37.450]                               next
[08:27:37.450]                             invokeRestart(restart)
[08:27:37.450]                             muffled <- TRUE
[08:27:37.450]                             break
[08:27:37.450]                           }
[08:27:37.450]                         }
[08:27:37.450]                       }
[08:27:37.450]                       invisible(muffled)
[08:27:37.450]                     }
[08:27:37.450]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.450]                   }
[08:27:37.450]                 }
[08:27:37.450]                 else {
[08:27:37.450]                   if (TRUE) {
[08:27:37.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.450]                     {
[08:27:37.450]                       inherits <- base::inherits
[08:27:37.450]                       invokeRestart <- base::invokeRestart
[08:27:37.450]                       is.null <- base::is.null
[08:27:37.450]                       muffled <- FALSE
[08:27:37.450]                       if (inherits(cond, "message")) {
[08:27:37.450]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.450]                         if (muffled) 
[08:27:37.450]                           invokeRestart("muffleMessage")
[08:27:37.450]                       }
[08:27:37.450]                       else if (inherits(cond, "warning")) {
[08:27:37.450]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.450]                         if (muffled) 
[08:27:37.450]                           invokeRestart("muffleWarning")
[08:27:37.450]                       }
[08:27:37.450]                       else if (inherits(cond, "condition")) {
[08:27:37.450]                         if (!is.null(pattern)) {
[08:27:37.450]                           computeRestarts <- base::computeRestarts
[08:27:37.450]                           grepl <- base::grepl
[08:27:37.450]                           restarts <- computeRestarts(cond)
[08:27:37.450]                           for (restart in restarts) {
[08:27:37.450]                             name <- restart$name
[08:27:37.450]                             if (is.null(name)) 
[08:27:37.450]                               next
[08:27:37.450]                             if (!grepl(pattern, name)) 
[08:27:37.450]                               next
[08:27:37.450]                             invokeRestart(restart)
[08:27:37.450]                             muffled <- TRUE
[08:27:37.450]                             break
[08:27:37.450]                           }
[08:27:37.450]                         }
[08:27:37.450]                       }
[08:27:37.450]                       invisible(muffled)
[08:27:37.450]                     }
[08:27:37.450]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.450]                   }
[08:27:37.450]                 }
[08:27:37.450]             }
[08:27:37.450]         }))
[08:27:37.450]     }, error = function(ex) {
[08:27:37.450]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.450]                 ...future.rng), started = ...future.startTime, 
[08:27:37.450]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.450]             version = "1.8"), class = "FutureResult")
[08:27:37.450]     }, finally = {
[08:27:37.450]         if (!identical(...future.workdir, getwd())) 
[08:27:37.450]             setwd(...future.workdir)
[08:27:37.450]         {
[08:27:37.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.450]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.450]             }
[08:27:37.450]             base::options(...future.oldOptions)
[08:27:37.450]             if (.Platform$OS.type == "windows") {
[08:27:37.450]                 old_names <- names(...future.oldEnvVars)
[08:27:37.450]                 envs <- base::Sys.getenv()
[08:27:37.450]                 names <- names(envs)
[08:27:37.450]                 common <- intersect(names, old_names)
[08:27:37.450]                 added <- setdiff(names, old_names)
[08:27:37.450]                 removed <- setdiff(old_names, names)
[08:27:37.450]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.450]                   envs[common]]
[08:27:37.450]                 NAMES <- toupper(changed)
[08:27:37.450]                 args <- list()
[08:27:37.450]                 for (kk in seq_along(NAMES)) {
[08:27:37.450]                   name <- changed[[kk]]
[08:27:37.450]                   NAME <- NAMES[[kk]]
[08:27:37.450]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.450]                     next
[08:27:37.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.450]                 }
[08:27:37.450]                 NAMES <- toupper(added)
[08:27:37.450]                 for (kk in seq_along(NAMES)) {
[08:27:37.450]                   name <- added[[kk]]
[08:27:37.450]                   NAME <- NAMES[[kk]]
[08:27:37.450]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.450]                     next
[08:27:37.450]                   args[[name]] <- ""
[08:27:37.450]                 }
[08:27:37.450]                 NAMES <- toupper(removed)
[08:27:37.450]                 for (kk in seq_along(NAMES)) {
[08:27:37.450]                   name <- removed[[kk]]
[08:27:37.450]                   NAME <- NAMES[[kk]]
[08:27:37.450]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.450]                     next
[08:27:37.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.450]                 }
[08:27:37.450]                 if (length(args) > 0) 
[08:27:37.450]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.450]             }
[08:27:37.450]             else {
[08:27:37.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.450]             }
[08:27:37.450]             {
[08:27:37.450]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.450]                   0L) {
[08:27:37.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.450]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.450]                   base::options(opts)
[08:27:37.450]                 }
[08:27:37.450]                 {
[08:27:37.450]                   {
[08:27:37.450]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:37.450]                     NULL
[08:27:37.450]                   }
[08:27:37.450]                   options(future.plan = NULL)
[08:27:37.450]                   if (is.na(NA_character_)) 
[08:27:37.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.450]                     .init = FALSE)
[08:27:37.450]                 }
[08:27:37.450]             }
[08:27:37.450]         }
[08:27:37.450]     })
[08:27:37.450]     if (TRUE) {
[08:27:37.450]         base::sink(type = "output", split = FALSE)
[08:27:37.450]         if (TRUE) {
[08:27:37.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.450]         }
[08:27:37.450]         else {
[08:27:37.450]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.450]         }
[08:27:37.450]         base::close(...future.stdout)
[08:27:37.450]         ...future.stdout <- NULL
[08:27:37.450]     }
[08:27:37.450]     ...future.result$conditions <- ...future.conditions
[08:27:37.450]     ...future.result$finished <- base::Sys.time()
[08:27:37.450]     ...future.result
[08:27:37.450] }
[08:27:37.452] requestCore(): workers = 2
[08:27:37.455] MulticoreFuture started
MulticoreFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
[08:27:37.456] plan(): Setting new future strategy stack:
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:27:37.456] List of future strategies:
[08:27:37.456] 1. sequential:
[08:27:37.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.456]    - tweaked: FALSE
[08:27:37.456]    - call: NULL
[08:27:37.457] plan(): nbrOfWorkers() = 1
[08:27:37.459] plan(): Setting new future strategy stack:
[08:27:37.459] List of future strategies:
[08:27:37.459] 1. multicore:
[08:27:37.459]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:37.459]    - tweaked: FALSE
[08:27:37.459]    - call: plan(strategy)
[08:27:37.463] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.464] result() for MulticoreFuture ...
[08:27:37.470] result() for MulticoreFuture ...
[08:27:37.470] result() for MulticoreFuture ... done
[08:27:37.470] result() for MulticoreFuture ... done
[08:27:37.470] result() for MulticoreFuture ...
[08:27:37.470] result() for MulticoreFuture ... done
[08:27:37.470] getGlobalsAndPackages() ...
[08:27:37.470] Searching for globals...
[08:27:37.471] 
[08:27:37.471] Searching for globals ... DONE
[08:27:37.471] - globals: [0] <none>
[08:27:37.471] getGlobalsAndPackages() ... DONE
[08:27:37.472] run() for ‘Future’ ...
[08:27:37.472] - state: ‘created’
[08:27:37.472] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:37.474] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.474] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:37.474]   - Field: ‘label’
[08:27:37.477]   - Field: ‘local’
[08:27:37.477]   - Field: ‘owner’
[08:27:37.478]   - Field: ‘envir’
[08:27:37.478]   - Field: ‘workers’
[08:27:37.478]   - Field: ‘packages’
[08:27:37.478]   - Field: ‘gc’
[08:27:37.478]   - Field: ‘job’
[08:27:37.478]   - Field: ‘conditions’
[08:27:37.478]   - Field: ‘expr’
[08:27:37.479]   - Field: ‘uuid’
[08:27:37.479]   - Field: ‘seed’
[08:27:37.479]   - Field: ‘version’
[08:27:37.479]   - Field: ‘result’
[08:27:37.479]   - Field: ‘asynchronous’
[08:27:37.479]   - Field: ‘calls’
[08:27:37.479]   - Field: ‘globals’
[08:27:37.479]   - Field: ‘stdout’
[08:27:37.480]   - Field: ‘earlySignal’
[08:27:37.480]   - Field: ‘lazy’
[08:27:37.480]   - Field: ‘state’
[08:27:37.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:37.480] - Launch lazy future ...
[08:27:37.480] Packages needed by the future expression (n = 0): <none>
[08:27:37.480] Packages needed by future strategies (n = 0): <none>
[08:27:37.481] {
[08:27:37.481]     {
[08:27:37.481]         {
[08:27:37.481]             ...future.startTime <- base::Sys.time()
[08:27:37.481]             {
[08:27:37.481]                 {
[08:27:37.481]                   {
[08:27:37.481]                     {
[08:27:37.481]                       base::local({
[08:27:37.481]                         has_future <- base::requireNamespace("future", 
[08:27:37.481]                           quietly = TRUE)
[08:27:37.481]                         if (has_future) {
[08:27:37.481]                           ns <- base::getNamespace("future")
[08:27:37.481]                           version <- ns[[".package"]][["version"]]
[08:27:37.481]                           if (is.null(version)) 
[08:27:37.481]                             version <- utils::packageVersion("future")
[08:27:37.481]                         }
[08:27:37.481]                         else {
[08:27:37.481]                           version <- NULL
[08:27:37.481]                         }
[08:27:37.481]                         if (!has_future || version < "1.8.0") {
[08:27:37.481]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.481]                             "", base::R.version$version.string), 
[08:27:37.481]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:37.481]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.481]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.481]                               "release", "version")], collapse = " "), 
[08:27:37.481]                             hostname = base::Sys.info()[["nodename"]])
[08:27:37.481]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.481]                             info)
[08:27:37.481]                           info <- base::paste(info, collapse = "; ")
[08:27:37.481]                           if (!has_future) {
[08:27:37.481]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.481]                               info)
[08:27:37.481]                           }
[08:27:37.481]                           else {
[08:27:37.481]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.481]                               info, version)
[08:27:37.481]                           }
[08:27:37.481]                           base::stop(msg)
[08:27:37.481]                         }
[08:27:37.481]                       })
[08:27:37.481]                     }
[08:27:37.481]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:37.481]                     base::options(mc.cores = 1L)
[08:27:37.481]                   }
[08:27:37.481]                   ...future.strategy.old <- future::plan("list")
[08:27:37.481]                   options(future.plan = NULL)
[08:27:37.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.481]                 }
[08:27:37.481]                 ...future.workdir <- getwd()
[08:27:37.481]             }
[08:27:37.481]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.481]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.481]         }
[08:27:37.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.481]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.481]             base::names(...future.oldOptions))
[08:27:37.481]     }
[08:27:37.481]     if (FALSE) {
[08:27:37.481]     }
[08:27:37.481]     else {
[08:27:37.481]         if (TRUE) {
[08:27:37.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.481]                 open = "w")
[08:27:37.481]         }
[08:27:37.481]         else {
[08:27:37.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.481]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.481]         }
[08:27:37.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.481]             base::sink(type = "output", split = FALSE)
[08:27:37.481]             base::close(...future.stdout)
[08:27:37.481]         }, add = TRUE)
[08:27:37.481]     }
[08:27:37.481]     ...future.frame <- base::sys.nframe()
[08:27:37.481]     ...future.conditions <- base::list()
[08:27:37.481]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.481]     if (FALSE) {
[08:27:37.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.481]     }
[08:27:37.481]     ...future.result <- base::tryCatch({
[08:27:37.481]         base::withCallingHandlers({
[08:27:37.481]             ...future.value <- base::withVisible(base::local({
[08:27:37.481]                 withCallingHandlers({
[08:27:37.481]                   42
[08:27:37.481]                 }, immediateCondition = function(cond) {
[08:27:37.481]                   save_rds <- function (object, pathname, ...) 
[08:27:37.481]                   {
[08:27:37.481]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:37.481]                     if (file_test("-f", pathname_tmp)) {
[08:27:37.481]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.481]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:37.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.481]                         fi_tmp[["mtime"]])
[08:27:37.481]                     }
[08:27:37.481]                     tryCatch({
[08:27:37.481]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:37.481]                     }, error = function(ex) {
[08:27:37.481]                       msg <- conditionMessage(ex)
[08:27:37.481]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.481]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:37.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.481]                         fi_tmp[["mtime"]], msg)
[08:27:37.481]                       ex$message <- msg
[08:27:37.481]                       stop(ex)
[08:27:37.481]                     })
[08:27:37.481]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:37.481]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:37.481]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:37.481]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.481]                       fi <- file.info(pathname)
[08:27:37.481]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:37.481]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.481]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:37.481]                         fi[["size"]], fi[["mtime"]])
[08:27:37.481]                       stop(msg)
[08:27:37.481]                     }
[08:27:37.481]                     invisible(pathname)
[08:27:37.481]                   }
[08:27:37.481]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:37.481]                     rootPath = tempdir()) 
[08:27:37.481]                   {
[08:27:37.481]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:37.481]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:37.481]                       tmpdir = path, fileext = ".rds")
[08:27:37.481]                     save_rds(obj, file)
[08:27:37.481]                   }
[08:27:37.481]                   saveImmediateCondition(cond, path = "/tmp/Rtmp36ZR1r/.future/immediateConditions")
[08:27:37.481]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.481]                   {
[08:27:37.481]                     inherits <- base::inherits
[08:27:37.481]                     invokeRestart <- base::invokeRestart
[08:27:37.481]                     is.null <- base::is.null
[08:27:37.481]                     muffled <- FALSE
[08:27:37.481]                     if (inherits(cond, "message")) {
[08:27:37.481]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:37.481]                       if (muffled) 
[08:27:37.481]                         invokeRestart("muffleMessage")
[08:27:37.481]                     }
[08:27:37.481]                     else if (inherits(cond, "warning")) {
[08:27:37.481]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:37.481]                       if (muffled) 
[08:27:37.481]                         invokeRestart("muffleWarning")
[08:27:37.481]                     }
[08:27:37.481]                     else if (inherits(cond, "condition")) {
[08:27:37.481]                       if (!is.null(pattern)) {
[08:27:37.481]                         computeRestarts <- base::computeRestarts
[08:27:37.481]                         grepl <- base::grepl
[08:27:37.481]                         restarts <- computeRestarts(cond)
[08:27:37.481]                         for (restart in restarts) {
[08:27:37.481]                           name <- restart$name
[08:27:37.481]                           if (is.null(name)) 
[08:27:37.481]                             next
[08:27:37.481]                           if (!grepl(pattern, name)) 
[08:27:37.481]                             next
[08:27:37.481]                           invokeRestart(restart)
[08:27:37.481]                           muffled <- TRUE
[08:27:37.481]                           break
[08:27:37.481]                         }
[08:27:37.481]                       }
[08:27:37.481]                     }
[08:27:37.481]                     invisible(muffled)
[08:27:37.481]                   }
[08:27:37.481]                   muffleCondition(cond)
[08:27:37.481]                 })
[08:27:37.481]             }))
[08:27:37.481]             future::FutureResult(value = ...future.value$value, 
[08:27:37.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.481]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.481]                     ...future.globalenv.names))
[08:27:37.481]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.481]         }, condition = base::local({
[08:27:37.481]             c <- base::c
[08:27:37.481]             inherits <- base::inherits
[08:27:37.481]             invokeRestart <- base::invokeRestart
[08:27:37.481]             length <- base::length
[08:27:37.481]             list <- base::list
[08:27:37.481]             seq.int <- base::seq.int
[08:27:37.481]             signalCondition <- base::signalCondition
[08:27:37.481]             sys.calls <- base::sys.calls
[08:27:37.481]             `[[` <- base::`[[`
[08:27:37.481]             `+` <- base::`+`
[08:27:37.481]             `<<-` <- base::`<<-`
[08:27:37.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.481]                   3L)]
[08:27:37.481]             }
[08:27:37.481]             function(cond) {
[08:27:37.481]                 is_error <- inherits(cond, "error")
[08:27:37.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.481]                   NULL)
[08:27:37.481]                 if (is_error) {
[08:27:37.481]                   sessionInformation <- function() {
[08:27:37.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.481]                       search = base::search(), system = base::Sys.info())
[08:27:37.481]                   }
[08:27:37.481]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.481]                     cond$call), session = sessionInformation(), 
[08:27:37.481]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.481]                   signalCondition(cond)
[08:27:37.481]                 }
[08:27:37.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.481]                 "immediateCondition"))) {
[08:27:37.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.481]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.481]                   if (TRUE && !signal) {
[08:27:37.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.481]                     {
[08:27:37.481]                       inherits <- base::inherits
[08:27:37.481]                       invokeRestart <- base::invokeRestart
[08:27:37.481]                       is.null <- base::is.null
[08:27:37.481]                       muffled <- FALSE
[08:27:37.481]                       if (inherits(cond, "message")) {
[08:27:37.481]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.481]                         if (muffled) 
[08:27:37.481]                           invokeRestart("muffleMessage")
[08:27:37.481]                       }
[08:27:37.481]                       else if (inherits(cond, "warning")) {
[08:27:37.481]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.481]                         if (muffled) 
[08:27:37.481]                           invokeRestart("muffleWarning")
[08:27:37.481]                       }
[08:27:37.481]                       else if (inherits(cond, "condition")) {
[08:27:37.481]                         if (!is.null(pattern)) {
[08:27:37.481]                           computeRestarts <- base::computeRestarts
[08:27:37.481]                           grepl <- base::grepl
[08:27:37.481]                           restarts <- computeRestarts(cond)
[08:27:37.481]                           for (restart in restarts) {
[08:27:37.481]                             name <- restart$name
[08:27:37.481]                             if (is.null(name)) 
[08:27:37.481]                               next
[08:27:37.481]                             if (!grepl(pattern, name)) 
[08:27:37.481]                               next
[08:27:37.481]                             invokeRestart(restart)
[08:27:37.481]                             muffled <- TRUE
[08:27:37.481]                             break
[08:27:37.481]                           }
[08:27:37.481]                         }
[08:27:37.481]                       }
[08:27:37.481]                       invisible(muffled)
[08:27:37.481]                     }
[08:27:37.481]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.481]                   }
[08:27:37.481]                 }
[08:27:37.481]                 else {
[08:27:37.481]                   if (TRUE) {
[08:27:37.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.481]                     {
[08:27:37.481]                       inherits <- base::inherits
[08:27:37.481]                       invokeRestart <- base::invokeRestart
[08:27:37.481]                       is.null <- base::is.null
[08:27:37.481]                       muffled <- FALSE
[08:27:37.481]                       if (inherits(cond, "message")) {
[08:27:37.481]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.481]                         if (muffled) 
[08:27:37.481]                           invokeRestart("muffleMessage")
[08:27:37.481]                       }
[08:27:37.481]                       else if (inherits(cond, "warning")) {
[08:27:37.481]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.481]                         if (muffled) 
[08:27:37.481]                           invokeRestart("muffleWarning")
[08:27:37.481]                       }
[08:27:37.481]                       else if (inherits(cond, "condition")) {
[08:27:37.481]                         if (!is.null(pattern)) {
[08:27:37.481]                           computeRestarts <- base::computeRestarts
[08:27:37.481]                           grepl <- base::grepl
[08:27:37.481]                           restarts <- computeRestarts(cond)
[08:27:37.481]                           for (restart in restarts) {
[08:27:37.481]                             name <- restart$name
[08:27:37.481]                             if (is.null(name)) 
[08:27:37.481]                               next
[08:27:37.481]                             if (!grepl(pattern, name)) 
[08:27:37.481]                               next
[08:27:37.481]                             invokeRestart(restart)
[08:27:37.481]                             muffled <- TRUE
[08:27:37.481]                             break
[08:27:37.481]                           }
[08:27:37.481]                         }
[08:27:37.481]                       }
[08:27:37.481]                       invisible(muffled)
[08:27:37.481]                     }
[08:27:37.481]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.481]                   }
[08:27:37.481]                 }
[08:27:37.481]             }
[08:27:37.481]         }))
[08:27:37.481]     }, error = function(ex) {
[08:27:37.481]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.481]                 ...future.rng), started = ...future.startTime, 
[08:27:37.481]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.481]             version = "1.8"), class = "FutureResult")
[08:27:37.481]     }, finally = {
[08:27:37.481]         if (!identical(...future.workdir, getwd())) 
[08:27:37.481]             setwd(...future.workdir)
[08:27:37.481]         {
[08:27:37.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.481]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.481]             }
[08:27:37.481]             base::options(...future.oldOptions)
[08:27:37.481]             if (.Platform$OS.type == "windows") {
[08:27:37.481]                 old_names <- names(...future.oldEnvVars)
[08:27:37.481]                 envs <- base::Sys.getenv()
[08:27:37.481]                 names <- names(envs)
[08:27:37.481]                 common <- intersect(names, old_names)
[08:27:37.481]                 added <- setdiff(names, old_names)
[08:27:37.481]                 removed <- setdiff(old_names, names)
[08:27:37.481]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.481]                   envs[common]]
[08:27:37.481]                 NAMES <- toupper(changed)
[08:27:37.481]                 args <- list()
[08:27:37.481]                 for (kk in seq_along(NAMES)) {
[08:27:37.481]                   name <- changed[[kk]]
[08:27:37.481]                   NAME <- NAMES[[kk]]
[08:27:37.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.481]                     next
[08:27:37.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.481]                 }
[08:27:37.481]                 NAMES <- toupper(added)
[08:27:37.481]                 for (kk in seq_along(NAMES)) {
[08:27:37.481]                   name <- added[[kk]]
[08:27:37.481]                   NAME <- NAMES[[kk]]
[08:27:37.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.481]                     next
[08:27:37.481]                   args[[name]] <- ""
[08:27:37.481]                 }
[08:27:37.481]                 NAMES <- toupper(removed)
[08:27:37.481]                 for (kk in seq_along(NAMES)) {
[08:27:37.481]                   name <- removed[[kk]]
[08:27:37.481]                   NAME <- NAMES[[kk]]
[08:27:37.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.481]                     next
[08:27:37.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.481]                 }
[08:27:37.481]                 if (length(args) > 0) 
[08:27:37.481]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.481]             }
[08:27:37.481]             else {
[08:27:37.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.481]             }
[08:27:37.481]             {
[08:27:37.481]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.481]                   0L) {
[08:27:37.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.481]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.481]                   base::options(opts)
[08:27:37.481]                 }
[08:27:37.481]                 {
[08:27:37.481]                   {
[08:27:37.481]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:37.481]                     NULL
[08:27:37.481]                   }
[08:27:37.481]                   options(future.plan = NULL)
[08:27:37.481]                   if (is.na(NA_character_)) 
[08:27:37.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.481]                     .init = FALSE)
[08:27:37.481]                 }
[08:27:37.481]             }
[08:27:37.481]         }
[08:27:37.481]     })
[08:27:37.481]     if (TRUE) {
[08:27:37.481]         base::sink(type = "output", split = FALSE)
[08:27:37.481]         if (TRUE) {
[08:27:37.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.481]         }
[08:27:37.481]         else {
[08:27:37.481]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.481]         }
[08:27:37.481]         base::close(...future.stdout)
[08:27:37.481]         ...future.stdout <- NULL
[08:27:37.481]     }
[08:27:37.481]     ...future.result$conditions <- ...future.conditions
[08:27:37.481]     ...future.result$finished <- base::Sys.time()
[08:27:37.481]     ...future.result
[08:27:37.481] }
[08:27:37.484] requestCore(): workers = 2
[08:27:37.486] MulticoreFuture started
[08:27:37.487] - Launch lazy future ... done
[08:27:37.487] plan(): Setting new future strategy stack:
[08:27:37.487] run() for ‘MulticoreFuture’ ... done
MulticoreFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:27:37.487] List of future strategies:
[08:27:37.487] 1. sequential:
[08:27:37.487]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.487]    - tweaked: FALSE
[08:27:37.487]    - call: NULL
[08:27:37.488] plan(): nbrOfWorkers() = 1
[08:27:37.491] plan(): Setting new future strategy stack:
[08:27:37.491] List of future strategies:
[08:27:37.491] 1. multicore:
[08:27:37.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:37.491]    - tweaked: FALSE
[08:27:37.491]    - call: plan(strategy)
[08:27:37.494] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.495] result() for MulticoreFuture ...
[08:27:37.496] result() for MulticoreFuture ...
[08:27:37.496] result() for MulticoreFuture ... done
[08:27:37.496] result() for MulticoreFuture ... done
[08:27:37.496] result() for MulticoreFuture ...
[08:27:37.496] result() for MulticoreFuture ... done
[08:27:37.497] getGlobalsAndPackages() ...
[08:27:37.497] Searching for globals...
[08:27:37.498] - globals found: [1] ‘{’
[08:27:37.498] Searching for globals ... DONE
[08:27:37.498] Resolving globals: FALSE
[08:27:37.499] 
[08:27:37.499] 
[08:27:37.499] getGlobalsAndPackages() ... DONE
[08:27:37.499] run() for ‘Future’ ...
[08:27:37.500] - state: ‘created’
[08:27:37.500] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:37.502] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:37.502]   - Field: ‘label’
[08:27:37.502]   - Field: ‘local’
[08:27:37.502]   - Field: ‘owner’
[08:27:37.502]   - Field: ‘envir’
[08:27:37.503]   - Field: ‘workers’
[08:27:37.503]   - Field: ‘packages’
[08:27:37.503]   - Field: ‘gc’
[08:27:37.503]   - Field: ‘job’
[08:27:37.503]   - Field: ‘conditions’
[08:27:37.503]   - Field: ‘expr’
[08:27:37.503]   - Field: ‘uuid’
[08:27:37.503]   - Field: ‘seed’
[08:27:37.503]   - Field: ‘version’
[08:27:37.504]   - Field: ‘result’
[08:27:37.504]   - Field: ‘asynchronous’
[08:27:37.504]   - Field: ‘calls’
[08:27:37.504]   - Field: ‘globals’
[08:27:37.504]   - Field: ‘stdout’
[08:27:37.504]   - Field: ‘earlySignal’
[08:27:37.504]   - Field: ‘lazy’
[08:27:37.504]   - Field: ‘state’
[08:27:37.504] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:37.504] - Launch lazy future ...
[08:27:37.505] Packages needed by the future expression (n = 0): <none>
[08:27:37.505] Packages needed by future strategies (n = 0): <none>
[08:27:37.505] {
[08:27:37.505]     {
[08:27:37.505]         {
[08:27:37.505]             ...future.startTime <- base::Sys.time()
[08:27:37.505]             {
[08:27:37.505]                 {
[08:27:37.505]                   {
[08:27:37.505]                     {
[08:27:37.505]                       base::local({
[08:27:37.505]                         has_future <- base::requireNamespace("future", 
[08:27:37.505]                           quietly = TRUE)
[08:27:37.505]                         if (has_future) {
[08:27:37.505]                           ns <- base::getNamespace("future")
[08:27:37.505]                           version <- ns[[".package"]][["version"]]
[08:27:37.505]                           if (is.null(version)) 
[08:27:37.505]                             version <- utils::packageVersion("future")
[08:27:37.505]                         }
[08:27:37.505]                         else {
[08:27:37.505]                           version <- NULL
[08:27:37.505]                         }
[08:27:37.505]                         if (!has_future || version < "1.8.0") {
[08:27:37.505]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.505]                             "", base::R.version$version.string), 
[08:27:37.505]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:37.505]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.505]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.505]                               "release", "version")], collapse = " "), 
[08:27:37.505]                             hostname = base::Sys.info()[["nodename"]])
[08:27:37.505]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.505]                             info)
[08:27:37.505]                           info <- base::paste(info, collapse = "; ")
[08:27:37.505]                           if (!has_future) {
[08:27:37.505]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.505]                               info)
[08:27:37.505]                           }
[08:27:37.505]                           else {
[08:27:37.505]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.505]                               info, version)
[08:27:37.505]                           }
[08:27:37.505]                           base::stop(msg)
[08:27:37.505]                         }
[08:27:37.505]                       })
[08:27:37.505]                     }
[08:27:37.505]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:37.505]                     base::options(mc.cores = 1L)
[08:27:37.505]                   }
[08:27:37.505]                   ...future.strategy.old <- future::plan("list")
[08:27:37.505]                   options(future.plan = NULL)
[08:27:37.505]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.505]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.505]                 }
[08:27:37.505]                 ...future.workdir <- getwd()
[08:27:37.505]             }
[08:27:37.505]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.505]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.505]         }
[08:27:37.505]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.505]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.505]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.505]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.505]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.505]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.505]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.505]             base::names(...future.oldOptions))
[08:27:37.505]     }
[08:27:37.505]     if (FALSE) {
[08:27:37.505]     }
[08:27:37.505]     else {
[08:27:37.505]         if (TRUE) {
[08:27:37.505]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.505]                 open = "w")
[08:27:37.505]         }
[08:27:37.505]         else {
[08:27:37.505]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.505]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.505]         }
[08:27:37.505]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.505]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.505]             base::sink(type = "output", split = FALSE)
[08:27:37.505]             base::close(...future.stdout)
[08:27:37.505]         }, add = TRUE)
[08:27:37.505]     }
[08:27:37.505]     ...future.frame <- base::sys.nframe()
[08:27:37.505]     ...future.conditions <- base::list()
[08:27:37.505]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.505]     if (FALSE) {
[08:27:37.505]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.505]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.505]     }
[08:27:37.505]     ...future.result <- base::tryCatch({
[08:27:37.505]         base::withCallingHandlers({
[08:27:37.505]             ...future.value <- base::withVisible(base::local({
[08:27:37.505]                 withCallingHandlers({
[08:27:37.505]                   {
[08:27:37.505]                     42
[08:27:37.505]                   }
[08:27:37.505]                 }, immediateCondition = function(cond) {
[08:27:37.505]                   save_rds <- function (object, pathname, ...) 
[08:27:37.505]                   {
[08:27:37.505]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:37.505]                     if (file_test("-f", pathname_tmp)) {
[08:27:37.505]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.505]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:37.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.505]                         fi_tmp[["mtime"]])
[08:27:37.505]                     }
[08:27:37.505]                     tryCatch({
[08:27:37.505]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:37.505]                     }, error = function(ex) {
[08:27:37.505]                       msg <- conditionMessage(ex)
[08:27:37.505]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.505]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:37.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.505]                         fi_tmp[["mtime"]], msg)
[08:27:37.505]                       ex$message <- msg
[08:27:37.505]                       stop(ex)
[08:27:37.505]                     })
[08:27:37.505]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:37.505]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:37.505]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:37.505]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.505]                       fi <- file.info(pathname)
[08:27:37.505]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:37.505]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.505]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:37.505]                         fi[["size"]], fi[["mtime"]])
[08:27:37.505]                       stop(msg)
[08:27:37.505]                     }
[08:27:37.505]                     invisible(pathname)
[08:27:37.505]                   }
[08:27:37.505]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:37.505]                     rootPath = tempdir()) 
[08:27:37.505]                   {
[08:27:37.505]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:37.505]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:37.505]                       tmpdir = path, fileext = ".rds")
[08:27:37.505]                     save_rds(obj, file)
[08:27:37.505]                   }
[08:27:37.505]                   saveImmediateCondition(cond, path = "/tmp/Rtmp36ZR1r/.future/immediateConditions")
[08:27:37.505]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.505]                   {
[08:27:37.505]                     inherits <- base::inherits
[08:27:37.505]                     invokeRestart <- base::invokeRestart
[08:27:37.505]                     is.null <- base::is.null
[08:27:37.505]                     muffled <- FALSE
[08:27:37.505]                     if (inherits(cond, "message")) {
[08:27:37.505]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:37.505]                       if (muffled) 
[08:27:37.505]                         invokeRestart("muffleMessage")
[08:27:37.505]                     }
[08:27:37.505]                     else if (inherits(cond, "warning")) {
[08:27:37.505]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:37.505]                       if (muffled) 
[08:27:37.505]                         invokeRestart("muffleWarning")
[08:27:37.505]                     }
[08:27:37.505]                     else if (inherits(cond, "condition")) {
[08:27:37.505]                       if (!is.null(pattern)) {
[08:27:37.505]                         computeRestarts <- base::computeRestarts
[08:27:37.505]                         grepl <- base::grepl
[08:27:37.505]                         restarts <- computeRestarts(cond)
[08:27:37.505]                         for (restart in restarts) {
[08:27:37.505]                           name <- restart$name
[08:27:37.505]                           if (is.null(name)) 
[08:27:37.505]                             next
[08:27:37.505]                           if (!grepl(pattern, name)) 
[08:27:37.505]                             next
[08:27:37.505]                           invokeRestart(restart)
[08:27:37.505]                           muffled <- TRUE
[08:27:37.505]                           break
[08:27:37.505]                         }
[08:27:37.505]                       }
[08:27:37.505]                     }
[08:27:37.505]                     invisible(muffled)
[08:27:37.505]                   }
[08:27:37.505]                   muffleCondition(cond)
[08:27:37.505]                 })
[08:27:37.505]             }))
[08:27:37.505]             future::FutureResult(value = ...future.value$value, 
[08:27:37.505]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.505]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.505]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.505]                     ...future.globalenv.names))
[08:27:37.505]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.505]         }, condition = base::local({
[08:27:37.505]             c <- base::c
[08:27:37.505]             inherits <- base::inherits
[08:27:37.505]             invokeRestart <- base::invokeRestart
[08:27:37.505]             length <- base::length
[08:27:37.505]             list <- base::list
[08:27:37.505]             seq.int <- base::seq.int
[08:27:37.505]             signalCondition <- base::signalCondition
[08:27:37.505]             sys.calls <- base::sys.calls
[08:27:37.505]             `[[` <- base::`[[`
[08:27:37.505]             `+` <- base::`+`
[08:27:37.505]             `<<-` <- base::`<<-`
[08:27:37.505]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.505]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.505]                   3L)]
[08:27:37.505]             }
[08:27:37.505]             function(cond) {
[08:27:37.505]                 is_error <- inherits(cond, "error")
[08:27:37.505]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.505]                   NULL)
[08:27:37.505]                 if (is_error) {
[08:27:37.505]                   sessionInformation <- function() {
[08:27:37.505]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.505]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.505]                       search = base::search(), system = base::Sys.info())
[08:27:37.505]                   }
[08:27:37.505]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.505]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.505]                     cond$call), session = sessionInformation(), 
[08:27:37.505]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.505]                   signalCondition(cond)
[08:27:37.505]                 }
[08:27:37.505]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.505]                 "immediateCondition"))) {
[08:27:37.505]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.505]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.505]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.505]                   if (TRUE && !signal) {
[08:27:37.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.505]                     {
[08:27:37.505]                       inherits <- base::inherits
[08:27:37.505]                       invokeRestart <- base::invokeRestart
[08:27:37.505]                       is.null <- base::is.null
[08:27:37.505]                       muffled <- FALSE
[08:27:37.505]                       if (inherits(cond, "message")) {
[08:27:37.505]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.505]                         if (muffled) 
[08:27:37.505]                           invokeRestart("muffleMessage")
[08:27:37.505]                       }
[08:27:37.505]                       else if (inherits(cond, "warning")) {
[08:27:37.505]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.505]                         if (muffled) 
[08:27:37.505]                           invokeRestart("muffleWarning")
[08:27:37.505]                       }
[08:27:37.505]                       else if (inherits(cond, "condition")) {
[08:27:37.505]                         if (!is.null(pattern)) {
[08:27:37.505]                           computeRestarts <- base::computeRestarts
[08:27:37.505]                           grepl <- base::grepl
[08:27:37.505]                           restarts <- computeRestarts(cond)
[08:27:37.505]                           for (restart in restarts) {
[08:27:37.505]                             name <- restart$name
[08:27:37.505]                             if (is.null(name)) 
[08:27:37.505]                               next
[08:27:37.505]                             if (!grepl(pattern, name)) 
[08:27:37.505]                               next
[08:27:37.505]                             invokeRestart(restart)
[08:27:37.505]                             muffled <- TRUE
[08:27:37.505]                             break
[08:27:37.505]                           }
[08:27:37.505]                         }
[08:27:37.505]                       }
[08:27:37.505]                       invisible(muffled)
[08:27:37.505]                     }
[08:27:37.505]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.505]                   }
[08:27:37.505]                 }
[08:27:37.505]                 else {
[08:27:37.505]                   if (TRUE) {
[08:27:37.505]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.505]                     {
[08:27:37.505]                       inherits <- base::inherits
[08:27:37.505]                       invokeRestart <- base::invokeRestart
[08:27:37.505]                       is.null <- base::is.null
[08:27:37.505]                       muffled <- FALSE
[08:27:37.505]                       if (inherits(cond, "message")) {
[08:27:37.505]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.505]                         if (muffled) 
[08:27:37.505]                           invokeRestart("muffleMessage")
[08:27:37.505]                       }
[08:27:37.505]                       else if (inherits(cond, "warning")) {
[08:27:37.505]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.505]                         if (muffled) 
[08:27:37.505]                           invokeRestart("muffleWarning")
[08:27:37.505]                       }
[08:27:37.505]                       else if (inherits(cond, "condition")) {
[08:27:37.505]                         if (!is.null(pattern)) {
[08:27:37.505]                           computeRestarts <- base::computeRestarts
[08:27:37.505]                           grepl <- base::grepl
[08:27:37.505]                           restarts <- computeRestarts(cond)
[08:27:37.505]                           for (restart in restarts) {
[08:27:37.505]                             name <- restart$name
[08:27:37.505]                             if (is.null(name)) 
[08:27:37.505]                               next
[08:27:37.505]                             if (!grepl(pattern, name)) 
[08:27:37.505]                               next
[08:27:37.505]                             invokeRestart(restart)
[08:27:37.505]                             muffled <- TRUE
[08:27:37.505]                             break
[08:27:37.505]                           }
[08:27:37.505]                         }
[08:27:37.505]                       }
[08:27:37.505]                       invisible(muffled)
[08:27:37.505]                     }
[08:27:37.505]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.505]                   }
[08:27:37.505]                 }
[08:27:37.505]             }
[08:27:37.505]         }))
[08:27:37.505]     }, error = function(ex) {
[08:27:37.505]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.505]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.505]                 ...future.rng), started = ...future.startTime, 
[08:27:37.505]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.505]             version = "1.8"), class = "FutureResult")
[08:27:37.505]     }, finally = {
[08:27:37.505]         if (!identical(...future.workdir, getwd())) 
[08:27:37.505]             setwd(...future.workdir)
[08:27:37.505]         {
[08:27:37.505]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.505]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.505]             }
[08:27:37.505]             base::options(...future.oldOptions)
[08:27:37.505]             if (.Platform$OS.type == "windows") {
[08:27:37.505]                 old_names <- names(...future.oldEnvVars)
[08:27:37.505]                 envs <- base::Sys.getenv()
[08:27:37.505]                 names <- names(envs)
[08:27:37.505]                 common <- intersect(names, old_names)
[08:27:37.505]                 added <- setdiff(names, old_names)
[08:27:37.505]                 removed <- setdiff(old_names, names)
[08:27:37.505]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.505]                   envs[common]]
[08:27:37.505]                 NAMES <- toupper(changed)
[08:27:37.505]                 args <- list()
[08:27:37.505]                 for (kk in seq_along(NAMES)) {
[08:27:37.505]                   name <- changed[[kk]]
[08:27:37.505]                   NAME <- NAMES[[kk]]
[08:27:37.505]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.505]                     next
[08:27:37.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.505]                 }
[08:27:37.505]                 NAMES <- toupper(added)
[08:27:37.505]                 for (kk in seq_along(NAMES)) {
[08:27:37.505]                   name <- added[[kk]]
[08:27:37.505]                   NAME <- NAMES[[kk]]
[08:27:37.505]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.505]                     next
[08:27:37.505]                   args[[name]] <- ""
[08:27:37.505]                 }
[08:27:37.505]                 NAMES <- toupper(removed)
[08:27:37.505]                 for (kk in seq_along(NAMES)) {
[08:27:37.505]                   name <- removed[[kk]]
[08:27:37.505]                   NAME <- NAMES[[kk]]
[08:27:37.505]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.505]                     next
[08:27:37.505]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.505]                 }
[08:27:37.505]                 if (length(args) > 0) 
[08:27:37.505]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.505]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.505]             }
[08:27:37.505]             else {
[08:27:37.505]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.505]             }
[08:27:37.505]             {
[08:27:37.505]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.505]                   0L) {
[08:27:37.505]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.505]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.505]                   base::options(opts)
[08:27:37.505]                 }
[08:27:37.505]                 {
[08:27:37.505]                   {
[08:27:37.505]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:37.505]                     NULL
[08:27:37.505]                   }
[08:27:37.505]                   options(future.plan = NULL)
[08:27:37.505]                   if (is.na(NA_character_)) 
[08:27:37.505]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.505]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.505]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.505]                     .init = FALSE)
[08:27:37.505]                 }
[08:27:37.505]             }
[08:27:37.505]         }
[08:27:37.505]     })
[08:27:37.505]     if (TRUE) {
[08:27:37.505]         base::sink(type = "output", split = FALSE)
[08:27:37.505]         if (TRUE) {
[08:27:37.505]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.505]         }
[08:27:37.505]         else {
[08:27:37.505]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.505]         }
[08:27:37.505]         base::close(...future.stdout)
[08:27:37.505]         ...future.stdout <- NULL
[08:27:37.505]     }
[08:27:37.505]     ...future.result$conditions <- ...future.conditions
[08:27:37.505]     ...future.result$finished <- base::Sys.time()
[08:27:37.505]     ...future.result
[08:27:37.505] }
[08:27:37.508] requestCore(): workers = 2
[08:27:37.510] MulticoreFuture started
[08:27:37.510] - Launch lazy future ... done
[08:27:37.511] run() for ‘MulticoreFuture’ ... done
[08:27:37.511] plan(): Setting new future strategy stack:
MulticoreFuture:
Label: ‘<none>’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:27:37.511] List of future strategies:
[08:27:37.511] 1. sequential:
[08:27:37.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.511]    - tweaked: FALSE
[08:27:37.511]    - call: NULL
[08:27:37.512] plan(): nbrOfWorkers() = 1
[08:27:37.514] plan(): Setting new future strategy stack:
[08:27:37.514] List of future strategies:
[08:27:37.514] 1. multicore:
[08:27:37.514]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:37.514]    - tweaked: FALSE
[08:27:37.514]    - call: plan(strategy)
[08:27:37.518] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.518] result() for MulticoreFuture ...
[08:27:37.519] result() for MulticoreFuture ...
[08:27:37.519] result() for MulticoreFuture ... done
[08:27:37.519] result() for MulticoreFuture ... done
[08:27:37.520] result() for MulticoreFuture ...
[08:27:37.520] result() for MulticoreFuture ... done
[08:27:37.522] getGlobalsAndPackages() ...
[08:27:37.522] 
[08:27:37.522] - globals: [0] <none>
[08:27:37.522] getGlobalsAndPackages() ... DONE
[08:27:37.523] Packages needed by the future expression (n = 0): <none>
[08:27:37.523] Packages needed by future strategies (n = 0): <none>
[08:27:37.523] {
[08:27:37.523]     {
[08:27:37.523]         {
[08:27:37.523]             ...future.startTime <- base::Sys.time()
[08:27:37.523]             {
[08:27:37.523]                 {
[08:27:37.523]                   {
[08:27:37.523]                     {
[08:27:37.523]                       base::local({
[08:27:37.523]                         has_future <- base::requireNamespace("future", 
[08:27:37.523]                           quietly = TRUE)
[08:27:37.523]                         if (has_future) {
[08:27:37.523]                           ns <- base::getNamespace("future")
[08:27:37.523]                           version <- ns[[".package"]][["version"]]
[08:27:37.523]                           if (is.null(version)) 
[08:27:37.523]                             version <- utils::packageVersion("future")
[08:27:37.523]                         }
[08:27:37.523]                         else {
[08:27:37.523]                           version <- NULL
[08:27:37.523]                         }
[08:27:37.523]                         if (!has_future || version < "1.8.0") {
[08:27:37.523]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.523]                             "", base::R.version$version.string), 
[08:27:37.523]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:37.523]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.523]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.523]                               "release", "version")], collapse = " "), 
[08:27:37.523]                             hostname = base::Sys.info()[["nodename"]])
[08:27:37.523]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.523]                             info)
[08:27:37.523]                           info <- base::paste(info, collapse = "; ")
[08:27:37.523]                           if (!has_future) {
[08:27:37.523]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.523]                               info)
[08:27:37.523]                           }
[08:27:37.523]                           else {
[08:27:37.523]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.523]                               info, version)
[08:27:37.523]                           }
[08:27:37.523]                           base::stop(msg)
[08:27:37.523]                         }
[08:27:37.523]                       })
[08:27:37.523]                     }
[08:27:37.523]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:37.523]                     base::options(mc.cores = 1L)
[08:27:37.523]                   }
[08:27:37.523]                   ...future.strategy.old <- future::plan("list")
[08:27:37.523]                   options(future.plan = NULL)
[08:27:37.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.523]                 }
[08:27:37.523]                 ...future.workdir <- getwd()
[08:27:37.523]             }
[08:27:37.523]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.523]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.523]         }
[08:27:37.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.523]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.523]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.523]             base::names(...future.oldOptions))
[08:27:37.523]     }
[08:27:37.523]     if (FALSE) {
[08:27:37.523]     }
[08:27:37.523]     else {
[08:27:37.523]         if (TRUE) {
[08:27:37.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.523]                 open = "w")
[08:27:37.523]         }
[08:27:37.523]         else {
[08:27:37.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.523]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.523]         }
[08:27:37.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.523]             base::sink(type = "output", split = FALSE)
[08:27:37.523]             base::close(...future.stdout)
[08:27:37.523]         }, add = TRUE)
[08:27:37.523]     }
[08:27:37.523]     ...future.frame <- base::sys.nframe()
[08:27:37.523]     ...future.conditions <- base::list()
[08:27:37.523]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.523]     if (FALSE) {
[08:27:37.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.523]     }
[08:27:37.523]     ...future.result <- base::tryCatch({
[08:27:37.523]         base::withCallingHandlers({
[08:27:37.523]             ...future.value <- base::withVisible(base::local({
[08:27:37.523]                 withCallingHandlers({
[08:27:37.523]                   42
[08:27:37.523]                 }, immediateCondition = function(cond) {
[08:27:37.523]                   save_rds <- function (object, pathname, ...) 
[08:27:37.523]                   {
[08:27:37.523]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:37.523]                     if (file_test("-f", pathname_tmp)) {
[08:27:37.523]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.523]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:37.523]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.523]                         fi_tmp[["mtime"]])
[08:27:37.523]                     }
[08:27:37.523]                     tryCatch({
[08:27:37.523]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:37.523]                     }, error = function(ex) {
[08:27:37.523]                       msg <- conditionMessage(ex)
[08:27:37.523]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.523]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:37.523]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.523]                         fi_tmp[["mtime"]], msg)
[08:27:37.523]                       ex$message <- msg
[08:27:37.523]                       stop(ex)
[08:27:37.523]                     })
[08:27:37.523]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:37.523]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:37.523]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:37.523]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.523]                       fi <- file.info(pathname)
[08:27:37.523]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:37.523]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.523]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:37.523]                         fi[["size"]], fi[["mtime"]])
[08:27:37.523]                       stop(msg)
[08:27:37.523]                     }
[08:27:37.523]                     invisible(pathname)
[08:27:37.523]                   }
[08:27:37.523]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:37.523]                     rootPath = tempdir()) 
[08:27:37.523]                   {
[08:27:37.523]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:37.523]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:37.523]                       tmpdir = path, fileext = ".rds")
[08:27:37.523]                     save_rds(obj, file)
[08:27:37.523]                   }
[08:27:37.523]                   saveImmediateCondition(cond, path = "/tmp/Rtmp36ZR1r/.future/immediateConditions")
[08:27:37.523]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.523]                   {
[08:27:37.523]                     inherits <- base::inherits
[08:27:37.523]                     invokeRestart <- base::invokeRestart
[08:27:37.523]                     is.null <- base::is.null
[08:27:37.523]                     muffled <- FALSE
[08:27:37.523]                     if (inherits(cond, "message")) {
[08:27:37.523]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:37.523]                       if (muffled) 
[08:27:37.523]                         invokeRestart("muffleMessage")
[08:27:37.523]                     }
[08:27:37.523]                     else if (inherits(cond, "warning")) {
[08:27:37.523]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:37.523]                       if (muffled) 
[08:27:37.523]                         invokeRestart("muffleWarning")
[08:27:37.523]                     }
[08:27:37.523]                     else if (inherits(cond, "condition")) {
[08:27:37.523]                       if (!is.null(pattern)) {
[08:27:37.523]                         computeRestarts <- base::computeRestarts
[08:27:37.523]                         grepl <- base::grepl
[08:27:37.523]                         restarts <- computeRestarts(cond)
[08:27:37.523]                         for (restart in restarts) {
[08:27:37.523]                           name <- restart$name
[08:27:37.523]                           if (is.null(name)) 
[08:27:37.523]                             next
[08:27:37.523]                           if (!grepl(pattern, name)) 
[08:27:37.523]                             next
[08:27:37.523]                           invokeRestart(restart)
[08:27:37.523]                           muffled <- TRUE
[08:27:37.523]                           break
[08:27:37.523]                         }
[08:27:37.523]                       }
[08:27:37.523]                     }
[08:27:37.523]                     invisible(muffled)
[08:27:37.523]                   }
[08:27:37.523]                   muffleCondition(cond)
[08:27:37.523]                 })
[08:27:37.523]             }))
[08:27:37.523]             future::FutureResult(value = ...future.value$value, 
[08:27:37.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.523]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.523]                     ...future.globalenv.names))
[08:27:37.523]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.523]         }, condition = base::local({
[08:27:37.523]             c <- base::c
[08:27:37.523]             inherits <- base::inherits
[08:27:37.523]             invokeRestart <- base::invokeRestart
[08:27:37.523]             length <- base::length
[08:27:37.523]             list <- base::list
[08:27:37.523]             seq.int <- base::seq.int
[08:27:37.523]             signalCondition <- base::signalCondition
[08:27:37.523]             sys.calls <- base::sys.calls
[08:27:37.523]             `[[` <- base::`[[`
[08:27:37.523]             `+` <- base::`+`
[08:27:37.523]             `<<-` <- base::`<<-`
[08:27:37.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.523]                   3L)]
[08:27:37.523]             }
[08:27:37.523]             function(cond) {
[08:27:37.523]                 is_error <- inherits(cond, "error")
[08:27:37.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.523]                   NULL)
[08:27:37.523]                 if (is_error) {
[08:27:37.523]                   sessionInformation <- function() {
[08:27:37.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.523]                       search = base::search(), system = base::Sys.info())
[08:27:37.523]                   }
[08:27:37.523]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.523]                     cond$call), session = sessionInformation(), 
[08:27:37.523]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.523]                   signalCondition(cond)
[08:27:37.523]                 }
[08:27:37.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.523]                 "immediateCondition"))) {
[08:27:37.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.523]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.523]                   if (TRUE && !signal) {
[08:27:37.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.523]                     {
[08:27:37.523]                       inherits <- base::inherits
[08:27:37.523]                       invokeRestart <- base::invokeRestart
[08:27:37.523]                       is.null <- base::is.null
[08:27:37.523]                       muffled <- FALSE
[08:27:37.523]                       if (inherits(cond, "message")) {
[08:27:37.523]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.523]                         if (muffled) 
[08:27:37.523]                           invokeRestart("muffleMessage")
[08:27:37.523]                       }
[08:27:37.523]                       else if (inherits(cond, "warning")) {
[08:27:37.523]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.523]                         if (muffled) 
[08:27:37.523]                           invokeRestart("muffleWarning")
[08:27:37.523]                       }
[08:27:37.523]                       else if (inherits(cond, "condition")) {
[08:27:37.523]                         if (!is.null(pattern)) {
[08:27:37.523]                           computeRestarts <- base::computeRestarts
[08:27:37.523]                           grepl <- base::grepl
[08:27:37.523]                           restarts <- computeRestarts(cond)
[08:27:37.523]                           for (restart in restarts) {
[08:27:37.523]                             name <- restart$name
[08:27:37.523]                             if (is.null(name)) 
[08:27:37.523]                               next
[08:27:37.523]                             if (!grepl(pattern, name)) 
[08:27:37.523]                               next
[08:27:37.523]                             invokeRestart(restart)
[08:27:37.523]                             muffled <- TRUE
[08:27:37.523]                             break
[08:27:37.523]                           }
[08:27:37.523]                         }
[08:27:37.523]                       }
[08:27:37.523]                       invisible(muffled)
[08:27:37.523]                     }
[08:27:37.523]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.523]                   }
[08:27:37.523]                 }
[08:27:37.523]                 else {
[08:27:37.523]                   if (TRUE) {
[08:27:37.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.523]                     {
[08:27:37.523]                       inherits <- base::inherits
[08:27:37.523]                       invokeRestart <- base::invokeRestart
[08:27:37.523]                       is.null <- base::is.null
[08:27:37.523]                       muffled <- FALSE
[08:27:37.523]                       if (inherits(cond, "message")) {
[08:27:37.523]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.523]                         if (muffled) 
[08:27:37.523]                           invokeRestart("muffleMessage")
[08:27:37.523]                       }
[08:27:37.523]                       else if (inherits(cond, "warning")) {
[08:27:37.523]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.523]                         if (muffled) 
[08:27:37.523]                           invokeRestart("muffleWarning")
[08:27:37.523]                       }
[08:27:37.523]                       else if (inherits(cond, "condition")) {
[08:27:37.523]                         if (!is.null(pattern)) {
[08:27:37.523]                           computeRestarts <- base::computeRestarts
[08:27:37.523]                           grepl <- base::grepl
[08:27:37.523]                           restarts <- computeRestarts(cond)
[08:27:37.523]                           for (restart in restarts) {
[08:27:37.523]                             name <- restart$name
[08:27:37.523]                             if (is.null(name)) 
[08:27:37.523]                               next
[08:27:37.523]                             if (!grepl(pattern, name)) 
[08:27:37.523]                               next
[08:27:37.523]                             invokeRestart(restart)
[08:27:37.523]                             muffled <- TRUE
[08:27:37.523]                             break
[08:27:37.523]                           }
[08:27:37.523]                         }
[08:27:37.523]                       }
[08:27:37.523]                       invisible(muffled)
[08:27:37.523]                     }
[08:27:37.523]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.523]                   }
[08:27:37.523]                 }
[08:27:37.523]             }
[08:27:37.523]         }))
[08:27:37.523]     }, error = function(ex) {
[08:27:37.523]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.523]                 ...future.rng), started = ...future.startTime, 
[08:27:37.523]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.523]             version = "1.8"), class = "FutureResult")
[08:27:37.523]     }, finally = {
[08:27:37.523]         if (!identical(...future.workdir, getwd())) 
[08:27:37.523]             setwd(...future.workdir)
[08:27:37.523]         {
[08:27:37.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.523]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.523]             }
[08:27:37.523]             base::options(...future.oldOptions)
[08:27:37.523]             if (.Platform$OS.type == "windows") {
[08:27:37.523]                 old_names <- names(...future.oldEnvVars)
[08:27:37.523]                 envs <- base::Sys.getenv()
[08:27:37.523]                 names <- names(envs)
[08:27:37.523]                 common <- intersect(names, old_names)
[08:27:37.523]                 added <- setdiff(names, old_names)
[08:27:37.523]                 removed <- setdiff(old_names, names)
[08:27:37.523]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.523]                   envs[common]]
[08:27:37.523]                 NAMES <- toupper(changed)
[08:27:37.523]                 args <- list()
[08:27:37.523]                 for (kk in seq_along(NAMES)) {
[08:27:37.523]                   name <- changed[[kk]]
[08:27:37.523]                   NAME <- NAMES[[kk]]
[08:27:37.523]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.523]                     next
[08:27:37.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.523]                 }
[08:27:37.523]                 NAMES <- toupper(added)
[08:27:37.523]                 for (kk in seq_along(NAMES)) {
[08:27:37.523]                   name <- added[[kk]]
[08:27:37.523]                   NAME <- NAMES[[kk]]
[08:27:37.523]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.523]                     next
[08:27:37.523]                   args[[name]] <- ""
[08:27:37.523]                 }
[08:27:37.523]                 NAMES <- toupper(removed)
[08:27:37.523]                 for (kk in seq_along(NAMES)) {
[08:27:37.523]                   name <- removed[[kk]]
[08:27:37.523]                   NAME <- NAMES[[kk]]
[08:27:37.523]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.523]                     next
[08:27:37.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.523]                 }
[08:27:37.523]                 if (length(args) > 0) 
[08:27:37.523]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.523]             }
[08:27:37.523]             else {
[08:27:37.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.523]             }
[08:27:37.523]             {
[08:27:37.523]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.523]                   0L) {
[08:27:37.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.523]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.523]                   base::options(opts)
[08:27:37.523]                 }
[08:27:37.523]                 {
[08:27:37.523]                   {
[08:27:37.523]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:37.523]                     NULL
[08:27:37.523]                   }
[08:27:37.523]                   options(future.plan = NULL)
[08:27:37.523]                   if (is.na(NA_character_)) 
[08:27:37.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.523]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.523]                     .init = FALSE)
[08:27:37.523]                 }
[08:27:37.523]             }
[08:27:37.523]         }
[08:27:37.523]     })
[08:27:37.523]     if (TRUE) {
[08:27:37.523]         base::sink(type = "output", split = FALSE)
[08:27:37.523]         if (TRUE) {
[08:27:37.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.523]         }
[08:27:37.523]         else {
[08:27:37.523]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.523]         }
[08:27:37.523]         base::close(...future.stdout)
[08:27:37.523]         ...future.stdout <- NULL
[08:27:37.523]     }
[08:27:37.523]     ...future.result$conditions <- ...future.conditions
[08:27:37.523]     ...future.result$finished <- base::Sys.time()
[08:27:37.523]     ...future.result
[08:27:37.523] }
[08:27:37.526] requestCore(): workers = 2
[08:27:37.528] MulticoreFuture started
MulticoreFuture:
Label: ‘strategy = multicore’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:27:37.529] plan(): Setting new future strategy stack:
[08:27:37.529] List of future strategies:
[08:27:37.529] 1. sequential:
[08:27:37.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.529]    - tweaked: FALSE
[08:27:37.529]    - call: NULL
[08:27:37.530] plan(): nbrOfWorkers() = 1
[08:27:37.532] plan(): Setting new future strategy stack:
[08:27:37.532] List of future strategies:
[08:27:37.532] 1. multicore:
[08:27:37.532]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:37.532]    - tweaked: FALSE
[08:27:37.532]    - call: plan(strategy)
[08:27:37.536] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.536] result() for MulticoreFuture ...
[08:27:37.537] result() for MulticoreFuture ...
[08:27:37.538] result() for MulticoreFuture ... done
[08:27:37.538] result() for MulticoreFuture ... done
[08:27:37.538] result() for MulticoreFuture ...
[08:27:37.538] result() for MulticoreFuture ... done
[08:27:37.538] getGlobalsAndPackages() ...
[08:27:37.538] Searching for globals...
[08:27:37.539] 
[08:27:37.539] Searching for globals ... DONE
[08:27:37.539] - globals: [0] <none>
[08:27:37.539] getGlobalsAndPackages() ... DONE
[08:27:37.540] run() for ‘Future’ ...
[08:27:37.540] - state: ‘created’
[08:27:37.540] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:37.542] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.542] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:37.542]   - Field: ‘label’
[08:27:37.542]   - Field: ‘local’
[08:27:37.543]   - Field: ‘owner’
[08:27:37.543]   - Field: ‘envir’
[08:27:37.543]   - Field: ‘workers’
[08:27:37.543]   - Field: ‘packages’
[08:27:37.543]   - Field: ‘gc’
[08:27:37.543]   - Field: ‘job’
[08:27:37.543]   - Field: ‘conditions’
[08:27:37.543]   - Field: ‘expr’
[08:27:37.543]   - Field: ‘uuid’
[08:27:37.544]   - Field: ‘seed’
[08:27:37.544]   - Field: ‘version’
[08:27:37.544]   - Field: ‘result’
[08:27:37.544]   - Field: ‘asynchronous’
[08:27:37.544]   - Field: ‘calls’
[08:27:37.544]   - Field: ‘globals’
[08:27:37.544]   - Field: ‘stdout’
[08:27:37.544]   - Field: ‘earlySignal’
[08:27:37.544]   - Field: ‘lazy’
[08:27:37.545]   - Field: ‘state’
[08:27:37.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:37.545] - Launch lazy future ...
[08:27:37.545] Packages needed by the future expression (n = 0): <none>
[08:27:37.545] Packages needed by future strategies (n = 0): <none>
[08:27:37.546] {
[08:27:37.546]     {
[08:27:37.546]         {
[08:27:37.546]             ...future.startTime <- base::Sys.time()
[08:27:37.546]             {
[08:27:37.546]                 {
[08:27:37.546]                   {
[08:27:37.546]                     {
[08:27:37.546]                       base::local({
[08:27:37.546]                         has_future <- base::requireNamespace("future", 
[08:27:37.546]                           quietly = TRUE)
[08:27:37.546]                         if (has_future) {
[08:27:37.546]                           ns <- base::getNamespace("future")
[08:27:37.546]                           version <- ns[[".package"]][["version"]]
[08:27:37.546]                           if (is.null(version)) 
[08:27:37.546]                             version <- utils::packageVersion("future")
[08:27:37.546]                         }
[08:27:37.546]                         else {
[08:27:37.546]                           version <- NULL
[08:27:37.546]                         }
[08:27:37.546]                         if (!has_future || version < "1.8.0") {
[08:27:37.546]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.546]                             "", base::R.version$version.string), 
[08:27:37.546]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:37.546]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.546]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.546]                               "release", "version")], collapse = " "), 
[08:27:37.546]                             hostname = base::Sys.info()[["nodename"]])
[08:27:37.546]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.546]                             info)
[08:27:37.546]                           info <- base::paste(info, collapse = "; ")
[08:27:37.546]                           if (!has_future) {
[08:27:37.546]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.546]                               info)
[08:27:37.546]                           }
[08:27:37.546]                           else {
[08:27:37.546]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.546]                               info, version)
[08:27:37.546]                           }
[08:27:37.546]                           base::stop(msg)
[08:27:37.546]                         }
[08:27:37.546]                       })
[08:27:37.546]                     }
[08:27:37.546]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:37.546]                     base::options(mc.cores = 1L)
[08:27:37.546]                   }
[08:27:37.546]                   ...future.strategy.old <- future::plan("list")
[08:27:37.546]                   options(future.plan = NULL)
[08:27:37.546]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.546]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.546]                 }
[08:27:37.546]                 ...future.workdir <- getwd()
[08:27:37.546]             }
[08:27:37.546]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.546]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.546]         }
[08:27:37.546]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.546]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.546]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.546]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.546]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.546]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.546]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.546]             base::names(...future.oldOptions))
[08:27:37.546]     }
[08:27:37.546]     if (FALSE) {
[08:27:37.546]     }
[08:27:37.546]     else {
[08:27:37.546]         if (TRUE) {
[08:27:37.546]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.546]                 open = "w")
[08:27:37.546]         }
[08:27:37.546]         else {
[08:27:37.546]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.546]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.546]         }
[08:27:37.546]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.546]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.546]             base::sink(type = "output", split = FALSE)
[08:27:37.546]             base::close(...future.stdout)
[08:27:37.546]         }, add = TRUE)
[08:27:37.546]     }
[08:27:37.546]     ...future.frame <- base::sys.nframe()
[08:27:37.546]     ...future.conditions <- base::list()
[08:27:37.546]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.546]     if (FALSE) {
[08:27:37.546]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.546]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.546]     }
[08:27:37.546]     ...future.result <- base::tryCatch({
[08:27:37.546]         base::withCallingHandlers({
[08:27:37.546]             ...future.value <- base::withVisible(base::local({
[08:27:37.546]                 withCallingHandlers({
[08:27:37.546]                   42
[08:27:37.546]                 }, immediateCondition = function(cond) {
[08:27:37.546]                   save_rds <- function (object, pathname, ...) 
[08:27:37.546]                   {
[08:27:37.546]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:37.546]                     if (file_test("-f", pathname_tmp)) {
[08:27:37.546]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.546]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:37.546]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.546]                         fi_tmp[["mtime"]])
[08:27:37.546]                     }
[08:27:37.546]                     tryCatch({
[08:27:37.546]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:37.546]                     }, error = function(ex) {
[08:27:37.546]                       msg <- conditionMessage(ex)
[08:27:37.546]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.546]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:37.546]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.546]                         fi_tmp[["mtime"]], msg)
[08:27:37.546]                       ex$message <- msg
[08:27:37.546]                       stop(ex)
[08:27:37.546]                     })
[08:27:37.546]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:37.546]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:37.546]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:37.546]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.546]                       fi <- file.info(pathname)
[08:27:37.546]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:37.546]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.546]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:37.546]                         fi[["size"]], fi[["mtime"]])
[08:27:37.546]                       stop(msg)
[08:27:37.546]                     }
[08:27:37.546]                     invisible(pathname)
[08:27:37.546]                   }
[08:27:37.546]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:37.546]                     rootPath = tempdir()) 
[08:27:37.546]                   {
[08:27:37.546]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:37.546]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:37.546]                       tmpdir = path, fileext = ".rds")
[08:27:37.546]                     save_rds(obj, file)
[08:27:37.546]                   }
[08:27:37.546]                   saveImmediateCondition(cond, path = "/tmp/Rtmp36ZR1r/.future/immediateConditions")
[08:27:37.546]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.546]                   {
[08:27:37.546]                     inherits <- base::inherits
[08:27:37.546]                     invokeRestart <- base::invokeRestart
[08:27:37.546]                     is.null <- base::is.null
[08:27:37.546]                     muffled <- FALSE
[08:27:37.546]                     if (inherits(cond, "message")) {
[08:27:37.546]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:37.546]                       if (muffled) 
[08:27:37.546]                         invokeRestart("muffleMessage")
[08:27:37.546]                     }
[08:27:37.546]                     else if (inherits(cond, "warning")) {
[08:27:37.546]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:37.546]                       if (muffled) 
[08:27:37.546]                         invokeRestart("muffleWarning")
[08:27:37.546]                     }
[08:27:37.546]                     else if (inherits(cond, "condition")) {
[08:27:37.546]                       if (!is.null(pattern)) {
[08:27:37.546]                         computeRestarts <- base::computeRestarts
[08:27:37.546]                         grepl <- base::grepl
[08:27:37.546]                         restarts <- computeRestarts(cond)
[08:27:37.546]                         for (restart in restarts) {
[08:27:37.546]                           name <- restart$name
[08:27:37.546]                           if (is.null(name)) 
[08:27:37.546]                             next
[08:27:37.546]                           if (!grepl(pattern, name)) 
[08:27:37.546]                             next
[08:27:37.546]                           invokeRestart(restart)
[08:27:37.546]                           muffled <- TRUE
[08:27:37.546]                           break
[08:27:37.546]                         }
[08:27:37.546]                       }
[08:27:37.546]                     }
[08:27:37.546]                     invisible(muffled)
[08:27:37.546]                   }
[08:27:37.546]                   muffleCondition(cond)
[08:27:37.546]                 })
[08:27:37.546]             }))
[08:27:37.546]             future::FutureResult(value = ...future.value$value, 
[08:27:37.546]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.546]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.546]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.546]                     ...future.globalenv.names))
[08:27:37.546]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.546]         }, condition = base::local({
[08:27:37.546]             c <- base::c
[08:27:37.546]             inherits <- base::inherits
[08:27:37.546]             invokeRestart <- base::invokeRestart
[08:27:37.546]             length <- base::length
[08:27:37.546]             list <- base::list
[08:27:37.546]             seq.int <- base::seq.int
[08:27:37.546]             signalCondition <- base::signalCondition
[08:27:37.546]             sys.calls <- base::sys.calls
[08:27:37.546]             `[[` <- base::`[[`
[08:27:37.546]             `+` <- base::`+`
[08:27:37.546]             `<<-` <- base::`<<-`
[08:27:37.546]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.546]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.546]                   3L)]
[08:27:37.546]             }
[08:27:37.546]             function(cond) {
[08:27:37.546]                 is_error <- inherits(cond, "error")
[08:27:37.546]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.546]                   NULL)
[08:27:37.546]                 if (is_error) {
[08:27:37.546]                   sessionInformation <- function() {
[08:27:37.546]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.546]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.546]                       search = base::search(), system = base::Sys.info())
[08:27:37.546]                   }
[08:27:37.546]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.546]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.546]                     cond$call), session = sessionInformation(), 
[08:27:37.546]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.546]                   signalCondition(cond)
[08:27:37.546]                 }
[08:27:37.546]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.546]                 "immediateCondition"))) {
[08:27:37.546]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.546]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.546]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.546]                   if (TRUE && !signal) {
[08:27:37.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.546]                     {
[08:27:37.546]                       inherits <- base::inherits
[08:27:37.546]                       invokeRestart <- base::invokeRestart
[08:27:37.546]                       is.null <- base::is.null
[08:27:37.546]                       muffled <- FALSE
[08:27:37.546]                       if (inherits(cond, "message")) {
[08:27:37.546]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.546]                         if (muffled) 
[08:27:37.546]                           invokeRestart("muffleMessage")
[08:27:37.546]                       }
[08:27:37.546]                       else if (inherits(cond, "warning")) {
[08:27:37.546]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.546]                         if (muffled) 
[08:27:37.546]                           invokeRestart("muffleWarning")
[08:27:37.546]                       }
[08:27:37.546]                       else if (inherits(cond, "condition")) {
[08:27:37.546]                         if (!is.null(pattern)) {
[08:27:37.546]                           computeRestarts <- base::computeRestarts
[08:27:37.546]                           grepl <- base::grepl
[08:27:37.546]                           restarts <- computeRestarts(cond)
[08:27:37.546]                           for (restart in restarts) {
[08:27:37.546]                             name <- restart$name
[08:27:37.546]                             if (is.null(name)) 
[08:27:37.546]                               next
[08:27:37.546]                             if (!grepl(pattern, name)) 
[08:27:37.546]                               next
[08:27:37.546]                             invokeRestart(restart)
[08:27:37.546]                             muffled <- TRUE
[08:27:37.546]                             break
[08:27:37.546]                           }
[08:27:37.546]                         }
[08:27:37.546]                       }
[08:27:37.546]                       invisible(muffled)
[08:27:37.546]                     }
[08:27:37.546]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.546]                   }
[08:27:37.546]                 }
[08:27:37.546]                 else {
[08:27:37.546]                   if (TRUE) {
[08:27:37.546]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.546]                     {
[08:27:37.546]                       inherits <- base::inherits
[08:27:37.546]                       invokeRestart <- base::invokeRestart
[08:27:37.546]                       is.null <- base::is.null
[08:27:37.546]                       muffled <- FALSE
[08:27:37.546]                       if (inherits(cond, "message")) {
[08:27:37.546]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.546]                         if (muffled) 
[08:27:37.546]                           invokeRestart("muffleMessage")
[08:27:37.546]                       }
[08:27:37.546]                       else if (inherits(cond, "warning")) {
[08:27:37.546]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.546]                         if (muffled) 
[08:27:37.546]                           invokeRestart("muffleWarning")
[08:27:37.546]                       }
[08:27:37.546]                       else if (inherits(cond, "condition")) {
[08:27:37.546]                         if (!is.null(pattern)) {
[08:27:37.546]                           computeRestarts <- base::computeRestarts
[08:27:37.546]                           grepl <- base::grepl
[08:27:37.546]                           restarts <- computeRestarts(cond)
[08:27:37.546]                           for (restart in restarts) {
[08:27:37.546]                             name <- restart$name
[08:27:37.546]                             if (is.null(name)) 
[08:27:37.546]                               next
[08:27:37.546]                             if (!grepl(pattern, name)) 
[08:27:37.546]                               next
[08:27:37.546]                             invokeRestart(restart)
[08:27:37.546]                             muffled <- TRUE
[08:27:37.546]                             break
[08:27:37.546]                           }
[08:27:37.546]                         }
[08:27:37.546]                       }
[08:27:37.546]                       invisible(muffled)
[08:27:37.546]                     }
[08:27:37.546]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.546]                   }
[08:27:37.546]                 }
[08:27:37.546]             }
[08:27:37.546]         }))
[08:27:37.546]     }, error = function(ex) {
[08:27:37.546]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.546]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.546]                 ...future.rng), started = ...future.startTime, 
[08:27:37.546]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.546]             version = "1.8"), class = "FutureResult")
[08:27:37.546]     }, finally = {
[08:27:37.546]         if (!identical(...future.workdir, getwd())) 
[08:27:37.546]             setwd(...future.workdir)
[08:27:37.546]         {
[08:27:37.546]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.546]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.546]             }
[08:27:37.546]             base::options(...future.oldOptions)
[08:27:37.546]             if (.Platform$OS.type == "windows") {
[08:27:37.546]                 old_names <- names(...future.oldEnvVars)
[08:27:37.546]                 envs <- base::Sys.getenv()
[08:27:37.546]                 names <- names(envs)
[08:27:37.546]                 common <- intersect(names, old_names)
[08:27:37.546]                 added <- setdiff(names, old_names)
[08:27:37.546]                 removed <- setdiff(old_names, names)
[08:27:37.546]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.546]                   envs[common]]
[08:27:37.546]                 NAMES <- toupper(changed)
[08:27:37.546]                 args <- list()
[08:27:37.546]                 for (kk in seq_along(NAMES)) {
[08:27:37.546]                   name <- changed[[kk]]
[08:27:37.546]                   NAME <- NAMES[[kk]]
[08:27:37.546]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.546]                     next
[08:27:37.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.546]                 }
[08:27:37.546]                 NAMES <- toupper(added)
[08:27:37.546]                 for (kk in seq_along(NAMES)) {
[08:27:37.546]                   name <- added[[kk]]
[08:27:37.546]                   NAME <- NAMES[[kk]]
[08:27:37.546]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.546]                     next
[08:27:37.546]                   args[[name]] <- ""
[08:27:37.546]                 }
[08:27:37.546]                 NAMES <- toupper(removed)
[08:27:37.546]                 for (kk in seq_along(NAMES)) {
[08:27:37.546]                   name <- removed[[kk]]
[08:27:37.546]                   NAME <- NAMES[[kk]]
[08:27:37.546]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.546]                     next
[08:27:37.546]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.546]                 }
[08:27:37.546]                 if (length(args) > 0) 
[08:27:37.546]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.546]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.546]             }
[08:27:37.546]             else {
[08:27:37.546]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.546]             }
[08:27:37.546]             {
[08:27:37.546]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.546]                   0L) {
[08:27:37.546]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.546]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.546]                   base::options(opts)
[08:27:37.546]                 }
[08:27:37.546]                 {
[08:27:37.546]                   {
[08:27:37.546]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:37.546]                     NULL
[08:27:37.546]                   }
[08:27:37.546]                   options(future.plan = NULL)
[08:27:37.546]                   if (is.na(NA_character_)) 
[08:27:37.546]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.546]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.546]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.546]                     .init = FALSE)
[08:27:37.546]                 }
[08:27:37.546]             }
[08:27:37.546]         }
[08:27:37.546]     })
[08:27:37.546]     if (TRUE) {
[08:27:37.546]         base::sink(type = "output", split = FALSE)
[08:27:37.546]         if (TRUE) {
[08:27:37.546]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.546]         }
[08:27:37.546]         else {
[08:27:37.546]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.546]         }
[08:27:37.546]         base::close(...future.stdout)
[08:27:37.546]         ...future.stdout <- NULL
[08:27:37.546]     }
[08:27:37.546]     ...future.result$conditions <- ...future.conditions
[08:27:37.546]     ...future.result$finished <- base::Sys.time()
[08:27:37.546]     ...future.result
[08:27:37.546] }
[08:27:37.548] requestCore(): workers = 2
[08:27:37.550] MulticoreFuture started
[08:27:37.551] - Launch lazy future ... done
[08:27:37.551] run() for ‘MulticoreFuture’ ... done
MulticoreFuture:
Label: ‘strategy = multicore’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
[08:27:37.551] plan(): Setting new future strategy stack:
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:27:37.551] List of future strategies:
[08:27:37.551] 1. sequential:
[08:27:37.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.551]    - tweaked: FALSE
[08:27:37.551]    - call: NULL
[08:27:37.552] plan(): nbrOfWorkers() = 1
[08:27:37.554] plan(): Setting new future strategy stack:
[08:27:37.554] List of future strategies:
[08:27:37.554] 1. multicore:
[08:27:37.554]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:37.554]    - tweaked: FALSE
[08:27:37.554]    - call: plan(strategy)
[08:27:37.557] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.558] result() for MulticoreFuture ...
[08:27:37.559] result() for MulticoreFuture ...
[08:27:37.559] result() for MulticoreFuture ... done
[08:27:37.559] result() for MulticoreFuture ... done
[08:27:37.559] result() for MulticoreFuture ...
[08:27:37.560] result() for MulticoreFuture ... done
[08:27:37.560] getGlobalsAndPackages() ...
[08:27:37.560] Searching for globals...
[08:27:37.561] - globals found: [1] ‘{’
[08:27:37.561] Searching for globals ... DONE
[08:27:37.561] Resolving globals: FALSE
[08:27:37.562] 
[08:27:37.562] 
[08:27:37.562] getGlobalsAndPackages() ... DONE
[08:27:37.562] run() for ‘Future’ ...
[08:27:37.565] - state: ‘created’
[08:27:37.565] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:37.567] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.568] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:37.568]   - Field: ‘label’
[08:27:37.568]   - Field: ‘local’
[08:27:37.568]   - Field: ‘owner’
[08:27:37.568]   - Field: ‘envir’
[08:27:37.568]   - Field: ‘workers’
[08:27:37.568]   - Field: ‘packages’
[08:27:37.568]   - Field: ‘gc’
[08:27:37.569]   - Field: ‘job’
[08:27:37.569]   - Field: ‘conditions’
[08:27:37.569]   - Field: ‘expr’
[08:27:37.569]   - Field: ‘uuid’
[08:27:37.569]   - Field: ‘seed’
[08:27:37.569]   - Field: ‘version’
[08:27:37.569]   - Field: ‘result’
[08:27:37.569]   - Field: ‘asynchronous’
[08:27:37.569]   - Field: ‘calls’
[08:27:37.570]   - Field: ‘globals’
[08:27:37.570]   - Field: ‘stdout’
[08:27:37.570]   - Field: ‘earlySignal’
[08:27:37.570]   - Field: ‘lazy’
[08:27:37.570]   - Field: ‘state’
[08:27:37.570] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:37.570] - Launch lazy future ...
[08:27:37.571] Packages needed by the future expression (n = 0): <none>
[08:27:37.571] Packages needed by future strategies (n = 0): <none>
[08:27:37.571] {
[08:27:37.571]     {
[08:27:37.571]         {
[08:27:37.571]             ...future.startTime <- base::Sys.time()
[08:27:37.571]             {
[08:27:37.571]                 {
[08:27:37.571]                   {
[08:27:37.571]                     {
[08:27:37.571]                       base::local({
[08:27:37.571]                         has_future <- base::requireNamespace("future", 
[08:27:37.571]                           quietly = TRUE)
[08:27:37.571]                         if (has_future) {
[08:27:37.571]                           ns <- base::getNamespace("future")
[08:27:37.571]                           version <- ns[[".package"]][["version"]]
[08:27:37.571]                           if (is.null(version)) 
[08:27:37.571]                             version <- utils::packageVersion("future")
[08:27:37.571]                         }
[08:27:37.571]                         else {
[08:27:37.571]                           version <- NULL
[08:27:37.571]                         }
[08:27:37.571]                         if (!has_future || version < "1.8.0") {
[08:27:37.571]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:37.571]                             "", base::R.version$version.string), 
[08:27:37.571]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:37.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:37.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:37.571]                               "release", "version")], collapse = " "), 
[08:27:37.571]                             hostname = base::Sys.info()[["nodename"]])
[08:27:37.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:37.571]                             info)
[08:27:37.571]                           info <- base::paste(info, collapse = "; ")
[08:27:37.571]                           if (!has_future) {
[08:27:37.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:37.571]                               info)
[08:27:37.571]                           }
[08:27:37.571]                           else {
[08:27:37.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:37.571]                               info, version)
[08:27:37.571]                           }
[08:27:37.571]                           base::stop(msg)
[08:27:37.571]                         }
[08:27:37.571]                       })
[08:27:37.571]                     }
[08:27:37.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:37.571]                     base::options(mc.cores = 1L)
[08:27:37.571]                   }
[08:27:37.571]                   ...future.strategy.old <- future::plan("list")
[08:27:37.571]                   options(future.plan = NULL)
[08:27:37.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:37.571]                 }
[08:27:37.571]                 ...future.workdir <- getwd()
[08:27:37.571]             }
[08:27:37.571]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:37.571]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:37.571]         }
[08:27:37.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:37.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:37.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:37.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:37.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:37.571]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:37.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:37.571]             base::names(...future.oldOptions))
[08:27:37.571]     }
[08:27:37.571]     if (FALSE) {
[08:27:37.571]     }
[08:27:37.571]     else {
[08:27:37.571]         if (TRUE) {
[08:27:37.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:37.571]                 open = "w")
[08:27:37.571]         }
[08:27:37.571]         else {
[08:27:37.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:37.571]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:37.571]         }
[08:27:37.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:37.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:37.571]             base::sink(type = "output", split = FALSE)
[08:27:37.571]             base::close(...future.stdout)
[08:27:37.571]         }, add = TRUE)
[08:27:37.571]     }
[08:27:37.571]     ...future.frame <- base::sys.nframe()
[08:27:37.571]     ...future.conditions <- base::list()
[08:27:37.571]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:37.571]     if (FALSE) {
[08:27:37.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:37.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:37.571]     }
[08:27:37.571]     ...future.result <- base::tryCatch({
[08:27:37.571]         base::withCallingHandlers({
[08:27:37.571]             ...future.value <- base::withVisible(base::local({
[08:27:37.571]                 withCallingHandlers({
[08:27:37.571]                   {
[08:27:37.571]                     42
[08:27:37.571]                   }
[08:27:37.571]                 }, immediateCondition = function(cond) {
[08:27:37.571]                   save_rds <- function (object, pathname, ...) 
[08:27:37.571]                   {
[08:27:37.571]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:37.571]                     if (file_test("-f", pathname_tmp)) {
[08:27:37.571]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.571]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:37.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.571]                         fi_tmp[["mtime"]])
[08:27:37.571]                     }
[08:27:37.571]                     tryCatch({
[08:27:37.571]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:37.571]                     }, error = function(ex) {
[08:27:37.571]                       msg <- conditionMessage(ex)
[08:27:37.571]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.571]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:37.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.571]                         fi_tmp[["mtime"]], msg)
[08:27:37.571]                       ex$message <- msg
[08:27:37.571]                       stop(ex)
[08:27:37.571]                     })
[08:27:37.571]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:37.571]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:37.571]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:37.571]                       fi_tmp <- file.info(pathname_tmp)
[08:27:37.571]                       fi <- file.info(pathname)
[08:27:37.571]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:37.571]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:37.571]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:37.571]                         fi[["size"]], fi[["mtime"]])
[08:27:37.571]                       stop(msg)
[08:27:37.571]                     }
[08:27:37.571]                     invisible(pathname)
[08:27:37.571]                   }
[08:27:37.571]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:37.571]                     rootPath = tempdir()) 
[08:27:37.571]                   {
[08:27:37.571]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:37.571]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:37.571]                       tmpdir = path, fileext = ".rds")
[08:27:37.571]                     save_rds(obj, file)
[08:27:37.571]                   }
[08:27:37.571]                   saveImmediateCondition(cond, path = "/tmp/Rtmp36ZR1r/.future/immediateConditions")
[08:27:37.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.571]                   {
[08:27:37.571]                     inherits <- base::inherits
[08:27:37.571]                     invokeRestart <- base::invokeRestart
[08:27:37.571]                     is.null <- base::is.null
[08:27:37.571]                     muffled <- FALSE
[08:27:37.571]                     if (inherits(cond, "message")) {
[08:27:37.571]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:37.571]                       if (muffled) 
[08:27:37.571]                         invokeRestart("muffleMessage")
[08:27:37.571]                     }
[08:27:37.571]                     else if (inherits(cond, "warning")) {
[08:27:37.571]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:37.571]                       if (muffled) 
[08:27:37.571]                         invokeRestart("muffleWarning")
[08:27:37.571]                     }
[08:27:37.571]                     else if (inherits(cond, "condition")) {
[08:27:37.571]                       if (!is.null(pattern)) {
[08:27:37.571]                         computeRestarts <- base::computeRestarts
[08:27:37.571]                         grepl <- base::grepl
[08:27:37.571]                         restarts <- computeRestarts(cond)
[08:27:37.571]                         for (restart in restarts) {
[08:27:37.571]                           name <- restart$name
[08:27:37.571]                           if (is.null(name)) 
[08:27:37.571]                             next
[08:27:37.571]                           if (!grepl(pattern, name)) 
[08:27:37.571]                             next
[08:27:37.571]                           invokeRestart(restart)
[08:27:37.571]                           muffled <- TRUE
[08:27:37.571]                           break
[08:27:37.571]                         }
[08:27:37.571]                       }
[08:27:37.571]                     }
[08:27:37.571]                     invisible(muffled)
[08:27:37.571]                   }
[08:27:37.571]                   muffleCondition(cond)
[08:27:37.571]                 })
[08:27:37.571]             }))
[08:27:37.571]             future::FutureResult(value = ...future.value$value, 
[08:27:37.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.571]                   ...future.rng), globalenv = if (FALSE) 
[08:27:37.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:37.571]                     ...future.globalenv.names))
[08:27:37.571]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:37.571]         }, condition = base::local({
[08:27:37.571]             c <- base::c
[08:27:37.571]             inherits <- base::inherits
[08:27:37.571]             invokeRestart <- base::invokeRestart
[08:27:37.571]             length <- base::length
[08:27:37.571]             list <- base::list
[08:27:37.571]             seq.int <- base::seq.int
[08:27:37.571]             signalCondition <- base::signalCondition
[08:27:37.571]             sys.calls <- base::sys.calls
[08:27:37.571]             `[[` <- base::`[[`
[08:27:37.571]             `+` <- base::`+`
[08:27:37.571]             `<<-` <- base::`<<-`
[08:27:37.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:37.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:37.571]                   3L)]
[08:27:37.571]             }
[08:27:37.571]             function(cond) {
[08:27:37.571]                 is_error <- inherits(cond, "error")
[08:27:37.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:37.571]                   NULL)
[08:27:37.571]                 if (is_error) {
[08:27:37.571]                   sessionInformation <- function() {
[08:27:37.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:37.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:37.571]                       search = base::search(), system = base::Sys.info())
[08:27:37.571]                   }
[08:27:37.571]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:37.571]                     cond$call), session = sessionInformation(), 
[08:27:37.571]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:37.571]                   signalCondition(cond)
[08:27:37.571]                 }
[08:27:37.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:37.571]                 "immediateCondition"))) {
[08:27:37.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:37.571]                   ...future.conditions[[length(...future.conditions) + 
[08:27:37.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:37.571]                   if (TRUE && !signal) {
[08:27:37.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.571]                     {
[08:27:37.571]                       inherits <- base::inherits
[08:27:37.571]                       invokeRestart <- base::invokeRestart
[08:27:37.571]                       is.null <- base::is.null
[08:27:37.571]                       muffled <- FALSE
[08:27:37.571]                       if (inherits(cond, "message")) {
[08:27:37.571]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.571]                         if (muffled) 
[08:27:37.571]                           invokeRestart("muffleMessage")
[08:27:37.571]                       }
[08:27:37.571]                       else if (inherits(cond, "warning")) {
[08:27:37.571]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.571]                         if (muffled) 
[08:27:37.571]                           invokeRestart("muffleWarning")
[08:27:37.571]                       }
[08:27:37.571]                       else if (inherits(cond, "condition")) {
[08:27:37.571]                         if (!is.null(pattern)) {
[08:27:37.571]                           computeRestarts <- base::computeRestarts
[08:27:37.571]                           grepl <- base::grepl
[08:27:37.571]                           restarts <- computeRestarts(cond)
[08:27:37.571]                           for (restart in restarts) {
[08:27:37.571]                             name <- restart$name
[08:27:37.571]                             if (is.null(name)) 
[08:27:37.571]                               next
[08:27:37.571]                             if (!grepl(pattern, name)) 
[08:27:37.571]                               next
[08:27:37.571]                             invokeRestart(restart)
[08:27:37.571]                             muffled <- TRUE
[08:27:37.571]                             break
[08:27:37.571]                           }
[08:27:37.571]                         }
[08:27:37.571]                       }
[08:27:37.571]                       invisible(muffled)
[08:27:37.571]                     }
[08:27:37.571]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.571]                   }
[08:27:37.571]                 }
[08:27:37.571]                 else {
[08:27:37.571]                   if (TRUE) {
[08:27:37.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:37.571]                     {
[08:27:37.571]                       inherits <- base::inherits
[08:27:37.571]                       invokeRestart <- base::invokeRestart
[08:27:37.571]                       is.null <- base::is.null
[08:27:37.571]                       muffled <- FALSE
[08:27:37.571]                       if (inherits(cond, "message")) {
[08:27:37.571]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:37.571]                         if (muffled) 
[08:27:37.571]                           invokeRestart("muffleMessage")
[08:27:37.571]                       }
[08:27:37.571]                       else if (inherits(cond, "warning")) {
[08:27:37.571]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:37.571]                         if (muffled) 
[08:27:37.571]                           invokeRestart("muffleWarning")
[08:27:37.571]                       }
[08:27:37.571]                       else if (inherits(cond, "condition")) {
[08:27:37.571]                         if (!is.null(pattern)) {
[08:27:37.571]                           computeRestarts <- base::computeRestarts
[08:27:37.571]                           grepl <- base::grepl
[08:27:37.571]                           restarts <- computeRestarts(cond)
[08:27:37.571]                           for (restart in restarts) {
[08:27:37.571]                             name <- restart$name
[08:27:37.571]                             if (is.null(name)) 
[08:27:37.571]                               next
[08:27:37.571]                             if (!grepl(pattern, name)) 
[08:27:37.571]                               next
[08:27:37.571]                             invokeRestart(restart)
[08:27:37.571]                             muffled <- TRUE
[08:27:37.571]                             break
[08:27:37.571]                           }
[08:27:37.571]                         }
[08:27:37.571]                       }
[08:27:37.571]                       invisible(muffled)
[08:27:37.571]                     }
[08:27:37.571]                     muffleCondition(cond, pattern = "^muffle")
[08:27:37.571]                   }
[08:27:37.571]                 }
[08:27:37.571]             }
[08:27:37.571]         }))
[08:27:37.571]     }, error = function(ex) {
[08:27:37.571]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:37.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:37.571]                 ...future.rng), started = ...future.startTime, 
[08:27:37.571]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:37.571]             version = "1.8"), class = "FutureResult")
[08:27:37.571]     }, finally = {
[08:27:37.571]         if (!identical(...future.workdir, getwd())) 
[08:27:37.571]             setwd(...future.workdir)
[08:27:37.571]         {
[08:27:37.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:37.571]                 ...future.oldOptions$nwarnings <- NULL
[08:27:37.571]             }
[08:27:37.571]             base::options(...future.oldOptions)
[08:27:37.571]             if (.Platform$OS.type == "windows") {
[08:27:37.571]                 old_names <- names(...future.oldEnvVars)
[08:27:37.571]                 envs <- base::Sys.getenv()
[08:27:37.571]                 names <- names(envs)
[08:27:37.571]                 common <- intersect(names, old_names)
[08:27:37.571]                 added <- setdiff(names, old_names)
[08:27:37.571]                 removed <- setdiff(old_names, names)
[08:27:37.571]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:37.571]                   envs[common]]
[08:27:37.571]                 NAMES <- toupper(changed)
[08:27:37.571]                 args <- list()
[08:27:37.571]                 for (kk in seq_along(NAMES)) {
[08:27:37.571]                   name <- changed[[kk]]
[08:27:37.571]                   NAME <- NAMES[[kk]]
[08:27:37.571]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.571]                     next
[08:27:37.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.571]                 }
[08:27:37.571]                 NAMES <- toupper(added)
[08:27:37.571]                 for (kk in seq_along(NAMES)) {
[08:27:37.571]                   name <- added[[kk]]
[08:27:37.571]                   NAME <- NAMES[[kk]]
[08:27:37.571]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.571]                     next
[08:27:37.571]                   args[[name]] <- ""
[08:27:37.571]                 }
[08:27:37.571]                 NAMES <- toupper(removed)
[08:27:37.571]                 for (kk in seq_along(NAMES)) {
[08:27:37.571]                   name <- removed[[kk]]
[08:27:37.571]                   NAME <- NAMES[[kk]]
[08:27:37.571]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:37.571]                     next
[08:27:37.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:37.571]                 }
[08:27:37.571]                 if (length(args) > 0) 
[08:27:37.571]                   base::do.call(base::Sys.setenv, args = args)
[08:27:37.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:37.571]             }
[08:27:37.571]             else {
[08:27:37.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:37.571]             }
[08:27:37.571]             {
[08:27:37.571]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:37.571]                   0L) {
[08:27:37.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:37.571]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:37.571]                   base::options(opts)
[08:27:37.571]                 }
[08:27:37.571]                 {
[08:27:37.571]                   {
[08:27:37.571]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:37.571]                     NULL
[08:27:37.571]                   }
[08:27:37.571]                   options(future.plan = NULL)
[08:27:37.571]                   if (is.na(NA_character_)) 
[08:27:37.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:37.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:37.571]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:37.571]                     .init = FALSE)
[08:27:37.571]                 }
[08:27:37.571]             }
[08:27:37.571]         }
[08:27:37.571]     })
[08:27:37.571]     if (TRUE) {
[08:27:37.571]         base::sink(type = "output", split = FALSE)
[08:27:37.571]         if (TRUE) {
[08:27:37.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:37.571]         }
[08:27:37.571]         else {
[08:27:37.571]             ...future.result["stdout"] <- base::list(NULL)
[08:27:37.571]         }
[08:27:37.571]         base::close(...future.stdout)
[08:27:37.571]         ...future.stdout <- NULL
[08:27:37.571]     }
[08:27:37.571]     ...future.result$conditions <- ...future.conditions
[08:27:37.571]     ...future.result$finished <- base::Sys.time()
[08:27:37.571]     ...future.result
[08:27:37.571] }
[08:27:37.574] requestCore(): workers = 2
[08:27:37.576] MulticoreFuture started
[08:27:37.576] - Launch lazy future ... done
[08:27:37.576] run() for ‘MulticoreFuture’ ... done
[08:27:37.577] plan(): Setting new future strategy stack:
MulticoreFuture:
Label: ‘strategy = multicore’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[08:27:37.577] List of future strategies:
[08:27:37.577] 1. sequential:
[08:27:37.577]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:37.577]    - tweaked: FALSE
[08:27:37.577]    - call: NULL
[08:27:37.578] plan(): nbrOfWorkers() = 1
[08:27:37.580] plan(): Setting new future strategy stack:
[08:27:37.580] List of future strategies:
[08:27:37.580] 1. multicore:
[08:27:37.580]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:37.580]    - tweaked: FALSE
[08:27:37.580]    - call: plan(strategy)
[08:27:37.583] plan(): nbrOfWorkers() = 2
Resolved: TRUE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:37.584] result() for MulticoreFuture ...
[08:27:37.585] result() for MulticoreFuture ...
[08:27:37.585] result() for MulticoreFuture ... done
[08:27:37.585] result() for MulticoreFuture ... done
[08:27:37.585] result() for MulticoreFuture ...
[08:27:37.586] result() for MulticoreFuture ... done
- plan('multicore') ... DONE
- plan('multisession') ...
[08:27:37.586] plan(): Setting new future strategy stack:
[08:27:37.586] List of future strategies:
[08:27:37.586] 1. multisession:
[08:27:37.586]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:37.586]    - tweaked: FALSE
[08:27:37.586]    - call: plan(strategy)
[08:27:37.587] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:27:37.587] multisession:
[08:27:37.587] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:37.587] - tweaked: FALSE
[08:27:37.587] - call: plan(strategy)
[08:27:37.592] getGlobalsAndPackages() ...
[08:27:37.592] Not searching for globals
[08:27:37.592] - globals: [0] <none>
[08:27:37.592] getGlobalsAndPackages() ... DONE
[08:27:38.088] Packages needed by the future expression (n = 0): <none>
[08:27:38.088] Packages needed by future strategies (n = 0): <none>
[08:27:38.089] {
[08:27:38.089]     {
[08:27:38.089]         {
[08:27:38.089]             ...future.startTime <- base::Sys.time()
[08:27:38.089]             {
[08:27:38.089]                 {
[08:27:38.089]                   {
[08:27:38.089]                     {
[08:27:38.089]                       base::local({
[08:27:38.089]                         has_future <- base::requireNamespace("future", 
[08:27:38.089]                           quietly = TRUE)
[08:27:38.089]                         if (has_future) {
[08:27:38.089]                           ns <- base::getNamespace("future")
[08:27:38.089]                           version <- ns[[".package"]][["version"]]
[08:27:38.089]                           if (is.null(version)) 
[08:27:38.089]                             version <- utils::packageVersion("future")
[08:27:38.089]                         }
[08:27:38.089]                         else {
[08:27:38.089]                           version <- NULL
[08:27:38.089]                         }
[08:27:38.089]                         if (!has_future || version < "1.8.0") {
[08:27:38.089]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:38.089]                             "", base::R.version$version.string), 
[08:27:38.089]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:38.089]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:38.089]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:38.089]                               "release", "version")], collapse = " "), 
[08:27:38.089]                             hostname = base::Sys.info()[["nodename"]])
[08:27:38.089]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:38.089]                             info)
[08:27:38.089]                           info <- base::paste(info, collapse = "; ")
[08:27:38.089]                           if (!has_future) {
[08:27:38.089]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:38.089]                               info)
[08:27:38.089]                           }
[08:27:38.089]                           else {
[08:27:38.089]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:38.089]                               info, version)
[08:27:38.089]                           }
[08:27:38.089]                           base::stop(msg)
[08:27:38.089]                         }
[08:27:38.089]                       })
[08:27:38.089]                     }
[08:27:38.089]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:38.089]                     base::options(mc.cores = 1L)
[08:27:38.089]                   }
[08:27:38.089]                   ...future.strategy.old <- future::plan("list")
[08:27:38.089]                   options(future.plan = NULL)
[08:27:38.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:38.089]                 }
[08:27:38.089]                 ...future.workdir <- getwd()
[08:27:38.089]             }
[08:27:38.089]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:38.089]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:38.089]         }
[08:27:38.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:38.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:38.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:38.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:38.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:38.089]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:38.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:38.089]             base::names(...future.oldOptions))
[08:27:38.089]     }
[08:27:38.089]     if (FALSE) {
[08:27:38.089]     }
[08:27:38.089]     else {
[08:27:38.089]         if (TRUE) {
[08:27:38.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:38.089]                 open = "w")
[08:27:38.089]         }
[08:27:38.089]         else {
[08:27:38.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:38.089]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:38.089]         }
[08:27:38.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:38.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:38.089]             base::sink(type = "output", split = FALSE)
[08:27:38.089]             base::close(...future.stdout)
[08:27:38.089]         }, add = TRUE)
[08:27:38.089]     }
[08:27:38.089]     ...future.frame <- base::sys.nframe()
[08:27:38.089]     ...future.conditions <- base::list()
[08:27:38.089]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:38.089]     if (FALSE) {
[08:27:38.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:38.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:38.089]     }
[08:27:38.089]     ...future.result <- base::tryCatch({
[08:27:38.089]         base::withCallingHandlers({
[08:27:38.089]             ...future.value <- base::withVisible(base::local({
[08:27:38.089]                 ...future.makeSendCondition <- base::local({
[08:27:38.089]                   sendCondition <- NULL
[08:27:38.089]                   function(frame = 1L) {
[08:27:38.089]                     if (is.function(sendCondition)) 
[08:27:38.089]                       return(sendCondition)
[08:27:38.089]                     ns <- getNamespace("parallel")
[08:27:38.089]                     if (exists("sendData", mode = "function", 
[08:27:38.089]                       envir = ns)) {
[08:27:38.089]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:38.089]                         envir = ns)
[08:27:38.089]                       envir <- sys.frame(frame)
[08:27:38.089]                       master <- NULL
[08:27:38.089]                       while (!identical(envir, .GlobalEnv) && 
[08:27:38.089]                         !identical(envir, emptyenv())) {
[08:27:38.089]                         if (exists("master", mode = "list", envir = envir, 
[08:27:38.089]                           inherits = FALSE)) {
[08:27:38.089]                           master <- get("master", mode = "list", 
[08:27:38.089]                             envir = envir, inherits = FALSE)
[08:27:38.089]                           if (inherits(master, c("SOCKnode", 
[08:27:38.089]                             "SOCK0node"))) {
[08:27:38.089]                             sendCondition <<- function(cond) {
[08:27:38.089]                               data <- list(type = "VALUE", value = cond, 
[08:27:38.089]                                 success = TRUE)
[08:27:38.089]                               parallel_sendData(master, data)
[08:27:38.089]                             }
[08:27:38.089]                             return(sendCondition)
[08:27:38.089]                           }
[08:27:38.089]                         }
[08:27:38.089]                         frame <- frame + 1L
[08:27:38.089]                         envir <- sys.frame(frame)
[08:27:38.089]                       }
[08:27:38.089]                     }
[08:27:38.089]                     sendCondition <<- function(cond) NULL
[08:27:38.089]                   }
[08:27:38.089]                 })
[08:27:38.089]                 withCallingHandlers({
[08:27:38.089]                   NA
[08:27:38.089]                 }, immediateCondition = function(cond) {
[08:27:38.089]                   sendCondition <- ...future.makeSendCondition()
[08:27:38.089]                   sendCondition(cond)
[08:27:38.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.089]                   {
[08:27:38.089]                     inherits <- base::inherits
[08:27:38.089]                     invokeRestart <- base::invokeRestart
[08:27:38.089]                     is.null <- base::is.null
[08:27:38.089]                     muffled <- FALSE
[08:27:38.089]                     if (inherits(cond, "message")) {
[08:27:38.089]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:38.089]                       if (muffled) 
[08:27:38.089]                         invokeRestart("muffleMessage")
[08:27:38.089]                     }
[08:27:38.089]                     else if (inherits(cond, "warning")) {
[08:27:38.089]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:38.089]                       if (muffled) 
[08:27:38.089]                         invokeRestart("muffleWarning")
[08:27:38.089]                     }
[08:27:38.089]                     else if (inherits(cond, "condition")) {
[08:27:38.089]                       if (!is.null(pattern)) {
[08:27:38.089]                         computeRestarts <- base::computeRestarts
[08:27:38.089]                         grepl <- base::grepl
[08:27:38.089]                         restarts <- computeRestarts(cond)
[08:27:38.089]                         for (restart in restarts) {
[08:27:38.089]                           name <- restart$name
[08:27:38.089]                           if (is.null(name)) 
[08:27:38.089]                             next
[08:27:38.089]                           if (!grepl(pattern, name)) 
[08:27:38.089]                             next
[08:27:38.089]                           invokeRestart(restart)
[08:27:38.089]                           muffled <- TRUE
[08:27:38.089]                           break
[08:27:38.089]                         }
[08:27:38.089]                       }
[08:27:38.089]                     }
[08:27:38.089]                     invisible(muffled)
[08:27:38.089]                   }
[08:27:38.089]                   muffleCondition(cond)
[08:27:38.089]                 })
[08:27:38.089]             }))
[08:27:38.089]             future::FutureResult(value = ...future.value$value, 
[08:27:38.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.089]                   ...future.rng), globalenv = if (FALSE) 
[08:27:38.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:38.089]                     ...future.globalenv.names))
[08:27:38.089]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:38.089]         }, condition = base::local({
[08:27:38.089]             c <- base::c
[08:27:38.089]             inherits <- base::inherits
[08:27:38.089]             invokeRestart <- base::invokeRestart
[08:27:38.089]             length <- base::length
[08:27:38.089]             list <- base::list
[08:27:38.089]             seq.int <- base::seq.int
[08:27:38.089]             signalCondition <- base::signalCondition
[08:27:38.089]             sys.calls <- base::sys.calls
[08:27:38.089]             `[[` <- base::`[[`
[08:27:38.089]             `+` <- base::`+`
[08:27:38.089]             `<<-` <- base::`<<-`
[08:27:38.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:38.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:38.089]                   3L)]
[08:27:38.089]             }
[08:27:38.089]             function(cond) {
[08:27:38.089]                 is_error <- inherits(cond, "error")
[08:27:38.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:38.089]                   NULL)
[08:27:38.089]                 if (is_error) {
[08:27:38.089]                   sessionInformation <- function() {
[08:27:38.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:38.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:38.089]                       search = base::search(), system = base::Sys.info())
[08:27:38.089]                   }
[08:27:38.089]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:38.089]                     cond$call), session = sessionInformation(), 
[08:27:38.089]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:38.089]                   signalCondition(cond)
[08:27:38.089]                 }
[08:27:38.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:38.089]                 "immediateCondition"))) {
[08:27:38.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:38.089]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:38.089]                   if (TRUE && !signal) {
[08:27:38.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.089]                     {
[08:27:38.089]                       inherits <- base::inherits
[08:27:38.089]                       invokeRestart <- base::invokeRestart
[08:27:38.089]                       is.null <- base::is.null
[08:27:38.089]                       muffled <- FALSE
[08:27:38.089]                       if (inherits(cond, "message")) {
[08:27:38.089]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.089]                         if (muffled) 
[08:27:38.089]                           invokeRestart("muffleMessage")
[08:27:38.089]                       }
[08:27:38.089]                       else if (inherits(cond, "warning")) {
[08:27:38.089]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.089]                         if (muffled) 
[08:27:38.089]                           invokeRestart("muffleWarning")
[08:27:38.089]                       }
[08:27:38.089]                       else if (inherits(cond, "condition")) {
[08:27:38.089]                         if (!is.null(pattern)) {
[08:27:38.089]                           computeRestarts <- base::computeRestarts
[08:27:38.089]                           grepl <- base::grepl
[08:27:38.089]                           restarts <- computeRestarts(cond)
[08:27:38.089]                           for (restart in restarts) {
[08:27:38.089]                             name <- restart$name
[08:27:38.089]                             if (is.null(name)) 
[08:27:38.089]                               next
[08:27:38.089]                             if (!grepl(pattern, name)) 
[08:27:38.089]                               next
[08:27:38.089]                             invokeRestart(restart)
[08:27:38.089]                             muffled <- TRUE
[08:27:38.089]                             break
[08:27:38.089]                           }
[08:27:38.089]                         }
[08:27:38.089]                       }
[08:27:38.089]                       invisible(muffled)
[08:27:38.089]                     }
[08:27:38.089]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.089]                   }
[08:27:38.089]                 }
[08:27:38.089]                 else {
[08:27:38.089]                   if (TRUE) {
[08:27:38.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.089]                     {
[08:27:38.089]                       inherits <- base::inherits
[08:27:38.089]                       invokeRestart <- base::invokeRestart
[08:27:38.089]                       is.null <- base::is.null
[08:27:38.089]                       muffled <- FALSE
[08:27:38.089]                       if (inherits(cond, "message")) {
[08:27:38.089]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.089]                         if (muffled) 
[08:27:38.089]                           invokeRestart("muffleMessage")
[08:27:38.089]                       }
[08:27:38.089]                       else if (inherits(cond, "warning")) {
[08:27:38.089]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.089]                         if (muffled) 
[08:27:38.089]                           invokeRestart("muffleWarning")
[08:27:38.089]                       }
[08:27:38.089]                       else if (inherits(cond, "condition")) {
[08:27:38.089]                         if (!is.null(pattern)) {
[08:27:38.089]                           computeRestarts <- base::computeRestarts
[08:27:38.089]                           grepl <- base::grepl
[08:27:38.089]                           restarts <- computeRestarts(cond)
[08:27:38.089]                           for (restart in restarts) {
[08:27:38.089]                             name <- restart$name
[08:27:38.089]                             if (is.null(name)) 
[08:27:38.089]                               next
[08:27:38.089]                             if (!grepl(pattern, name)) 
[08:27:38.089]                               next
[08:27:38.089]                             invokeRestart(restart)
[08:27:38.089]                             muffled <- TRUE
[08:27:38.089]                             break
[08:27:38.089]                           }
[08:27:38.089]                         }
[08:27:38.089]                       }
[08:27:38.089]                       invisible(muffled)
[08:27:38.089]                     }
[08:27:38.089]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.089]                   }
[08:27:38.089]                 }
[08:27:38.089]             }
[08:27:38.089]         }))
[08:27:38.089]     }, error = function(ex) {
[08:27:38.089]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:38.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.089]                 ...future.rng), started = ...future.startTime, 
[08:27:38.089]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:38.089]             version = "1.8"), class = "FutureResult")
[08:27:38.089]     }, finally = {
[08:27:38.089]         if (!identical(...future.workdir, getwd())) 
[08:27:38.089]             setwd(...future.workdir)
[08:27:38.089]         {
[08:27:38.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:38.089]                 ...future.oldOptions$nwarnings <- NULL
[08:27:38.089]             }
[08:27:38.089]             base::options(...future.oldOptions)
[08:27:38.089]             if (.Platform$OS.type == "windows") {
[08:27:38.089]                 old_names <- names(...future.oldEnvVars)
[08:27:38.089]                 envs <- base::Sys.getenv()
[08:27:38.089]                 names <- names(envs)
[08:27:38.089]                 common <- intersect(names, old_names)
[08:27:38.089]                 added <- setdiff(names, old_names)
[08:27:38.089]                 removed <- setdiff(old_names, names)
[08:27:38.089]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:38.089]                   envs[common]]
[08:27:38.089]                 NAMES <- toupper(changed)
[08:27:38.089]                 args <- list()
[08:27:38.089]                 for (kk in seq_along(NAMES)) {
[08:27:38.089]                   name <- changed[[kk]]
[08:27:38.089]                   NAME <- NAMES[[kk]]
[08:27:38.089]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.089]                     next
[08:27:38.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.089]                 }
[08:27:38.089]                 NAMES <- toupper(added)
[08:27:38.089]                 for (kk in seq_along(NAMES)) {
[08:27:38.089]                   name <- added[[kk]]
[08:27:38.089]                   NAME <- NAMES[[kk]]
[08:27:38.089]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.089]                     next
[08:27:38.089]                   args[[name]] <- ""
[08:27:38.089]                 }
[08:27:38.089]                 NAMES <- toupper(removed)
[08:27:38.089]                 for (kk in seq_along(NAMES)) {
[08:27:38.089]                   name <- removed[[kk]]
[08:27:38.089]                   NAME <- NAMES[[kk]]
[08:27:38.089]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.089]                     next
[08:27:38.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.089]                 }
[08:27:38.089]                 if (length(args) > 0) 
[08:27:38.089]                   base::do.call(base::Sys.setenv, args = args)
[08:27:38.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:38.089]             }
[08:27:38.089]             else {
[08:27:38.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:38.089]             }
[08:27:38.089]             {
[08:27:38.089]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:38.089]                   0L) {
[08:27:38.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:38.089]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:38.089]                   base::options(opts)
[08:27:38.089]                 }
[08:27:38.089]                 {
[08:27:38.089]                   {
[08:27:38.089]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:38.089]                     NULL
[08:27:38.089]                   }
[08:27:38.089]                   options(future.plan = NULL)
[08:27:38.089]                   if (is.na(NA_character_)) 
[08:27:38.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:38.089]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:38.089]                     .init = FALSE)
[08:27:38.089]                 }
[08:27:38.089]             }
[08:27:38.089]         }
[08:27:38.089]     })
[08:27:38.089]     if (TRUE) {
[08:27:38.089]         base::sink(type = "output", split = FALSE)
[08:27:38.089]         if (TRUE) {
[08:27:38.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:38.089]         }
[08:27:38.089]         else {
[08:27:38.089]             ...future.result["stdout"] <- base::list(NULL)
[08:27:38.089]         }
[08:27:38.089]         base::close(...future.stdout)
[08:27:38.089]         ...future.stdout <- NULL
[08:27:38.089]     }
[08:27:38.089]     ...future.result$conditions <- ...future.conditions
[08:27:38.089]     ...future.result$finished <- base::Sys.time()
[08:27:38.089]     ...future.result
[08:27:38.089] }
[08:27:38.143] MultisessionFuture started
[08:27:38.143] result() for ClusterFuture ...
[08:27:38.144] receiveMessageFromWorker() for ClusterFuture ...
[08:27:38.144] - Validating connection of MultisessionFuture
[08:27:38.176] - received message: FutureResult
[08:27:38.177] - Received FutureResult
[08:27:38.177] - Erased future from FutureRegistry
[08:27:38.177] result() for ClusterFuture ...
[08:27:38.177] - result already collected: FutureResult
[08:27:38.177] result() for ClusterFuture ... done
[08:27:38.177] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:38.177] result() for ClusterFuture ... done
[08:27:38.177] result() for ClusterFuture ...
[08:27:38.177] - result already collected: FutureResult
[08:27:38.177] result() for ClusterFuture ... done
[08:27:38.178] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:27:38.179] plan(): nbrOfWorkers() = 2
[08:27:38.181] getGlobalsAndPackages() ...
[08:27:38.181] 
[08:27:38.181] - globals: [0] <none>
[08:27:38.181] getGlobalsAndPackages() ... DONE
[08:27:38.194] Packages needed by the future expression (n = 0): <none>
[08:27:38.194] Packages needed by future strategies (n = 0): <none>
[08:27:38.194] {
[08:27:38.194]     {
[08:27:38.194]         {
[08:27:38.194]             ...future.startTime <- base::Sys.time()
[08:27:38.194]             {
[08:27:38.194]                 {
[08:27:38.194]                   {
[08:27:38.194]                     {
[08:27:38.194]                       base::local({
[08:27:38.194]                         has_future <- base::requireNamespace("future", 
[08:27:38.194]                           quietly = TRUE)
[08:27:38.194]                         if (has_future) {
[08:27:38.194]                           ns <- base::getNamespace("future")
[08:27:38.194]                           version <- ns[[".package"]][["version"]]
[08:27:38.194]                           if (is.null(version)) 
[08:27:38.194]                             version <- utils::packageVersion("future")
[08:27:38.194]                         }
[08:27:38.194]                         else {
[08:27:38.194]                           version <- NULL
[08:27:38.194]                         }
[08:27:38.194]                         if (!has_future || version < "1.8.0") {
[08:27:38.194]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:38.194]                             "", base::R.version$version.string), 
[08:27:38.194]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:38.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:38.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:38.194]                               "release", "version")], collapse = " "), 
[08:27:38.194]                             hostname = base::Sys.info()[["nodename"]])
[08:27:38.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:38.194]                             info)
[08:27:38.194]                           info <- base::paste(info, collapse = "; ")
[08:27:38.194]                           if (!has_future) {
[08:27:38.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:38.194]                               info)
[08:27:38.194]                           }
[08:27:38.194]                           else {
[08:27:38.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:38.194]                               info, version)
[08:27:38.194]                           }
[08:27:38.194]                           base::stop(msg)
[08:27:38.194]                         }
[08:27:38.194]                       })
[08:27:38.194]                     }
[08:27:38.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:38.194]                     base::options(mc.cores = 1L)
[08:27:38.194]                   }
[08:27:38.194]                   ...future.strategy.old <- future::plan("list")
[08:27:38.194]                   options(future.plan = NULL)
[08:27:38.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:38.194]                 }
[08:27:38.194]                 ...future.workdir <- getwd()
[08:27:38.194]             }
[08:27:38.194]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:38.194]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:38.194]         }
[08:27:38.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:38.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:38.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:38.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:38.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:38.194]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:38.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:38.194]             base::names(...future.oldOptions))
[08:27:38.194]     }
[08:27:38.194]     if (FALSE) {
[08:27:38.194]     }
[08:27:38.194]     else {
[08:27:38.194]         if (TRUE) {
[08:27:38.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:38.194]                 open = "w")
[08:27:38.194]         }
[08:27:38.194]         else {
[08:27:38.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:38.194]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:38.194]         }
[08:27:38.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:38.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:38.194]             base::sink(type = "output", split = FALSE)
[08:27:38.194]             base::close(...future.stdout)
[08:27:38.194]         }, add = TRUE)
[08:27:38.194]     }
[08:27:38.194]     ...future.frame <- base::sys.nframe()
[08:27:38.194]     ...future.conditions <- base::list()
[08:27:38.194]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:38.194]     if (FALSE) {
[08:27:38.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:38.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:38.194]     }
[08:27:38.194]     ...future.result <- base::tryCatch({
[08:27:38.194]         base::withCallingHandlers({
[08:27:38.194]             ...future.value <- base::withVisible(base::local({
[08:27:38.194]                 ...future.makeSendCondition <- base::local({
[08:27:38.194]                   sendCondition <- NULL
[08:27:38.194]                   function(frame = 1L) {
[08:27:38.194]                     if (is.function(sendCondition)) 
[08:27:38.194]                       return(sendCondition)
[08:27:38.194]                     ns <- getNamespace("parallel")
[08:27:38.194]                     if (exists("sendData", mode = "function", 
[08:27:38.194]                       envir = ns)) {
[08:27:38.194]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:38.194]                         envir = ns)
[08:27:38.194]                       envir <- sys.frame(frame)
[08:27:38.194]                       master <- NULL
[08:27:38.194]                       while (!identical(envir, .GlobalEnv) && 
[08:27:38.194]                         !identical(envir, emptyenv())) {
[08:27:38.194]                         if (exists("master", mode = "list", envir = envir, 
[08:27:38.194]                           inherits = FALSE)) {
[08:27:38.194]                           master <- get("master", mode = "list", 
[08:27:38.194]                             envir = envir, inherits = FALSE)
[08:27:38.194]                           if (inherits(master, c("SOCKnode", 
[08:27:38.194]                             "SOCK0node"))) {
[08:27:38.194]                             sendCondition <<- function(cond) {
[08:27:38.194]                               data <- list(type = "VALUE", value = cond, 
[08:27:38.194]                                 success = TRUE)
[08:27:38.194]                               parallel_sendData(master, data)
[08:27:38.194]                             }
[08:27:38.194]                             return(sendCondition)
[08:27:38.194]                           }
[08:27:38.194]                         }
[08:27:38.194]                         frame <- frame + 1L
[08:27:38.194]                         envir <- sys.frame(frame)
[08:27:38.194]                       }
[08:27:38.194]                     }
[08:27:38.194]                     sendCondition <<- function(cond) NULL
[08:27:38.194]                   }
[08:27:38.194]                 })
[08:27:38.194]                 withCallingHandlers({
[08:27:38.194]                   42
[08:27:38.194]                 }, immediateCondition = function(cond) {
[08:27:38.194]                   sendCondition <- ...future.makeSendCondition()
[08:27:38.194]                   sendCondition(cond)
[08:27:38.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.194]                   {
[08:27:38.194]                     inherits <- base::inherits
[08:27:38.194]                     invokeRestart <- base::invokeRestart
[08:27:38.194]                     is.null <- base::is.null
[08:27:38.194]                     muffled <- FALSE
[08:27:38.194]                     if (inherits(cond, "message")) {
[08:27:38.194]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:38.194]                       if (muffled) 
[08:27:38.194]                         invokeRestart("muffleMessage")
[08:27:38.194]                     }
[08:27:38.194]                     else if (inherits(cond, "warning")) {
[08:27:38.194]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:38.194]                       if (muffled) 
[08:27:38.194]                         invokeRestart("muffleWarning")
[08:27:38.194]                     }
[08:27:38.194]                     else if (inherits(cond, "condition")) {
[08:27:38.194]                       if (!is.null(pattern)) {
[08:27:38.194]                         computeRestarts <- base::computeRestarts
[08:27:38.194]                         grepl <- base::grepl
[08:27:38.194]                         restarts <- computeRestarts(cond)
[08:27:38.194]                         for (restart in restarts) {
[08:27:38.194]                           name <- restart$name
[08:27:38.194]                           if (is.null(name)) 
[08:27:38.194]                             next
[08:27:38.194]                           if (!grepl(pattern, name)) 
[08:27:38.194]                             next
[08:27:38.194]                           invokeRestart(restart)
[08:27:38.194]                           muffled <- TRUE
[08:27:38.194]                           break
[08:27:38.194]                         }
[08:27:38.194]                       }
[08:27:38.194]                     }
[08:27:38.194]                     invisible(muffled)
[08:27:38.194]                   }
[08:27:38.194]                   muffleCondition(cond)
[08:27:38.194]                 })
[08:27:38.194]             }))
[08:27:38.194]             future::FutureResult(value = ...future.value$value, 
[08:27:38.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.194]                   ...future.rng), globalenv = if (FALSE) 
[08:27:38.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:38.194]                     ...future.globalenv.names))
[08:27:38.194]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:38.194]         }, condition = base::local({
[08:27:38.194]             c <- base::c
[08:27:38.194]             inherits <- base::inherits
[08:27:38.194]             invokeRestart <- base::invokeRestart
[08:27:38.194]             length <- base::length
[08:27:38.194]             list <- base::list
[08:27:38.194]             seq.int <- base::seq.int
[08:27:38.194]             signalCondition <- base::signalCondition
[08:27:38.194]             sys.calls <- base::sys.calls
[08:27:38.194]             `[[` <- base::`[[`
[08:27:38.194]             `+` <- base::`+`
[08:27:38.194]             `<<-` <- base::`<<-`
[08:27:38.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:38.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:38.194]                   3L)]
[08:27:38.194]             }
[08:27:38.194]             function(cond) {
[08:27:38.194]                 is_error <- inherits(cond, "error")
[08:27:38.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:38.194]                   NULL)
[08:27:38.194]                 if (is_error) {
[08:27:38.194]                   sessionInformation <- function() {
[08:27:38.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:38.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:38.194]                       search = base::search(), system = base::Sys.info())
[08:27:38.194]                   }
[08:27:38.194]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:38.194]                     cond$call), session = sessionInformation(), 
[08:27:38.194]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:38.194]                   signalCondition(cond)
[08:27:38.194]                 }
[08:27:38.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:38.194]                 "immediateCondition"))) {
[08:27:38.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:38.194]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:38.194]                   if (TRUE && !signal) {
[08:27:38.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.194]                     {
[08:27:38.194]                       inherits <- base::inherits
[08:27:38.194]                       invokeRestart <- base::invokeRestart
[08:27:38.194]                       is.null <- base::is.null
[08:27:38.194]                       muffled <- FALSE
[08:27:38.194]                       if (inherits(cond, "message")) {
[08:27:38.194]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.194]                         if (muffled) 
[08:27:38.194]                           invokeRestart("muffleMessage")
[08:27:38.194]                       }
[08:27:38.194]                       else if (inherits(cond, "warning")) {
[08:27:38.194]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.194]                         if (muffled) 
[08:27:38.194]                           invokeRestart("muffleWarning")
[08:27:38.194]                       }
[08:27:38.194]                       else if (inherits(cond, "condition")) {
[08:27:38.194]                         if (!is.null(pattern)) {
[08:27:38.194]                           computeRestarts <- base::computeRestarts
[08:27:38.194]                           grepl <- base::grepl
[08:27:38.194]                           restarts <- computeRestarts(cond)
[08:27:38.194]                           for (restart in restarts) {
[08:27:38.194]                             name <- restart$name
[08:27:38.194]                             if (is.null(name)) 
[08:27:38.194]                               next
[08:27:38.194]                             if (!grepl(pattern, name)) 
[08:27:38.194]                               next
[08:27:38.194]                             invokeRestart(restart)
[08:27:38.194]                             muffled <- TRUE
[08:27:38.194]                             break
[08:27:38.194]                           }
[08:27:38.194]                         }
[08:27:38.194]                       }
[08:27:38.194]                       invisible(muffled)
[08:27:38.194]                     }
[08:27:38.194]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.194]                   }
[08:27:38.194]                 }
[08:27:38.194]                 else {
[08:27:38.194]                   if (TRUE) {
[08:27:38.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.194]                     {
[08:27:38.194]                       inherits <- base::inherits
[08:27:38.194]                       invokeRestart <- base::invokeRestart
[08:27:38.194]                       is.null <- base::is.null
[08:27:38.194]                       muffled <- FALSE
[08:27:38.194]                       if (inherits(cond, "message")) {
[08:27:38.194]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.194]                         if (muffled) 
[08:27:38.194]                           invokeRestart("muffleMessage")
[08:27:38.194]                       }
[08:27:38.194]                       else if (inherits(cond, "warning")) {
[08:27:38.194]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.194]                         if (muffled) 
[08:27:38.194]                           invokeRestart("muffleWarning")
[08:27:38.194]                       }
[08:27:38.194]                       else if (inherits(cond, "condition")) {
[08:27:38.194]                         if (!is.null(pattern)) {
[08:27:38.194]                           computeRestarts <- base::computeRestarts
[08:27:38.194]                           grepl <- base::grepl
[08:27:38.194]                           restarts <- computeRestarts(cond)
[08:27:38.194]                           for (restart in restarts) {
[08:27:38.194]                             name <- restart$name
[08:27:38.194]                             if (is.null(name)) 
[08:27:38.194]                               next
[08:27:38.194]                             if (!grepl(pattern, name)) 
[08:27:38.194]                               next
[08:27:38.194]                             invokeRestart(restart)
[08:27:38.194]                             muffled <- TRUE
[08:27:38.194]                             break
[08:27:38.194]                           }
[08:27:38.194]                         }
[08:27:38.194]                       }
[08:27:38.194]                       invisible(muffled)
[08:27:38.194]                     }
[08:27:38.194]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.194]                   }
[08:27:38.194]                 }
[08:27:38.194]             }
[08:27:38.194]         }))
[08:27:38.194]     }, error = function(ex) {
[08:27:38.194]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:38.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.194]                 ...future.rng), started = ...future.startTime, 
[08:27:38.194]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:38.194]             version = "1.8"), class = "FutureResult")
[08:27:38.194]     }, finally = {
[08:27:38.194]         if (!identical(...future.workdir, getwd())) 
[08:27:38.194]             setwd(...future.workdir)
[08:27:38.194]         {
[08:27:38.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:38.194]                 ...future.oldOptions$nwarnings <- NULL
[08:27:38.194]             }
[08:27:38.194]             base::options(...future.oldOptions)
[08:27:38.194]             if (.Platform$OS.type == "windows") {
[08:27:38.194]                 old_names <- names(...future.oldEnvVars)
[08:27:38.194]                 envs <- base::Sys.getenv()
[08:27:38.194]                 names <- names(envs)
[08:27:38.194]                 common <- intersect(names, old_names)
[08:27:38.194]                 added <- setdiff(names, old_names)
[08:27:38.194]                 removed <- setdiff(old_names, names)
[08:27:38.194]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:38.194]                   envs[common]]
[08:27:38.194]                 NAMES <- toupper(changed)
[08:27:38.194]                 args <- list()
[08:27:38.194]                 for (kk in seq_along(NAMES)) {
[08:27:38.194]                   name <- changed[[kk]]
[08:27:38.194]                   NAME <- NAMES[[kk]]
[08:27:38.194]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.194]                     next
[08:27:38.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.194]                 }
[08:27:38.194]                 NAMES <- toupper(added)
[08:27:38.194]                 for (kk in seq_along(NAMES)) {
[08:27:38.194]                   name <- added[[kk]]
[08:27:38.194]                   NAME <- NAMES[[kk]]
[08:27:38.194]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.194]                     next
[08:27:38.194]                   args[[name]] <- ""
[08:27:38.194]                 }
[08:27:38.194]                 NAMES <- toupper(removed)
[08:27:38.194]                 for (kk in seq_along(NAMES)) {
[08:27:38.194]                   name <- removed[[kk]]
[08:27:38.194]                   NAME <- NAMES[[kk]]
[08:27:38.194]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.194]                     next
[08:27:38.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.194]                 }
[08:27:38.194]                 if (length(args) > 0) 
[08:27:38.194]                   base::do.call(base::Sys.setenv, args = args)
[08:27:38.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:38.194]             }
[08:27:38.194]             else {
[08:27:38.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:38.194]             }
[08:27:38.194]             {
[08:27:38.194]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:38.194]                   0L) {
[08:27:38.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:38.194]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:38.194]                   base::options(opts)
[08:27:38.194]                 }
[08:27:38.194]                 {
[08:27:38.194]                   {
[08:27:38.194]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:38.194]                     NULL
[08:27:38.194]                   }
[08:27:38.194]                   options(future.plan = NULL)
[08:27:38.194]                   if (is.na(NA_character_)) 
[08:27:38.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:38.194]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:38.194]                     .init = FALSE)
[08:27:38.194]                 }
[08:27:38.194]             }
[08:27:38.194]         }
[08:27:38.194]     })
[08:27:38.194]     if (TRUE) {
[08:27:38.194]         base::sink(type = "output", split = FALSE)
[08:27:38.194]         if (TRUE) {
[08:27:38.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:38.194]         }
[08:27:38.194]         else {
[08:27:38.194]             ...future.result["stdout"] <- base::list(NULL)
[08:27:38.194]         }
[08:27:38.194]         base::close(...future.stdout)
[08:27:38.194]         ...future.stdout <- NULL
[08:27:38.194]     }
[08:27:38.194]     ...future.result$conditions <- ...future.conditions
[08:27:38.194]     ...future.result$finished <- base::Sys.time()
[08:27:38.194]     ...future.result
[08:27:38.194] }
[08:27:38.198] MultisessionFuture started
MultisessionFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.209] result() for ClusterFuture ...
[08:27:38.209] receiveMessageFromWorker() for ClusterFuture ...
[08:27:38.209] - Validating connection of MultisessionFuture
[08:27:38.240] - received message: FutureResult
[08:27:38.240] - Received FutureResult
[08:27:38.241] - Erased future from FutureRegistry
[08:27:38.241] result() for ClusterFuture ...
[08:27:38.241] - result already collected: FutureResult
[08:27:38.241] result() for ClusterFuture ... done
[08:27:38.241] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:38.241] result() for ClusterFuture ... done
[08:27:38.241] result() for ClusterFuture ...
[08:27:38.241] - result already collected: FutureResult
[08:27:38.241] result() for ClusterFuture ... done
[08:27:38.241] getGlobalsAndPackages() ...
[08:27:38.241] Searching for globals...
[08:27:38.242] 
[08:27:38.242] Searching for globals ... DONE
[08:27:38.242] - globals: [0] <none>
[08:27:38.242] getGlobalsAndPackages() ... DONE
[08:27:38.242] run() for ‘Future’ ...
[08:27:38.242] - state: ‘created’
[08:27:38.243] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:38.257] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.257] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:38.257]   - Field: ‘node’
[08:27:38.257]   - Field: ‘label’
[08:27:38.257]   - Field: ‘local’
[08:27:38.257]   - Field: ‘owner’
[08:27:38.257]   - Field: ‘envir’
[08:27:38.258]   - Field: ‘workers’
[08:27:38.258]   - Field: ‘packages’
[08:27:38.258]   - Field: ‘gc’
[08:27:38.258]   - Field: ‘conditions’
[08:27:38.258]   - Field: ‘persistent’
[08:27:38.258]   - Field: ‘expr’
[08:27:38.258]   - Field: ‘uuid’
[08:27:38.258]   - Field: ‘seed’
[08:27:38.258]   - Field: ‘version’
[08:27:38.258]   - Field: ‘result’
[08:27:38.258]   - Field: ‘asynchronous’
[08:27:38.258]   - Field: ‘calls’
[08:27:38.259]   - Field: ‘globals’
[08:27:38.259]   - Field: ‘stdout’
[08:27:38.259]   - Field: ‘earlySignal’
[08:27:38.259]   - Field: ‘lazy’
[08:27:38.259]   - Field: ‘state’
[08:27:38.259] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:38.259] - Launch lazy future ...
[08:27:38.259] Packages needed by the future expression (n = 0): <none>
[08:27:38.259] Packages needed by future strategies (n = 0): <none>
[08:27:38.260] {
[08:27:38.260]     {
[08:27:38.260]         {
[08:27:38.260]             ...future.startTime <- base::Sys.time()
[08:27:38.260]             {
[08:27:38.260]                 {
[08:27:38.260]                   {
[08:27:38.260]                     {
[08:27:38.260]                       base::local({
[08:27:38.260]                         has_future <- base::requireNamespace("future", 
[08:27:38.260]                           quietly = TRUE)
[08:27:38.260]                         if (has_future) {
[08:27:38.260]                           ns <- base::getNamespace("future")
[08:27:38.260]                           version <- ns[[".package"]][["version"]]
[08:27:38.260]                           if (is.null(version)) 
[08:27:38.260]                             version <- utils::packageVersion("future")
[08:27:38.260]                         }
[08:27:38.260]                         else {
[08:27:38.260]                           version <- NULL
[08:27:38.260]                         }
[08:27:38.260]                         if (!has_future || version < "1.8.0") {
[08:27:38.260]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:38.260]                             "", base::R.version$version.string), 
[08:27:38.260]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:38.260]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:38.260]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:38.260]                               "release", "version")], collapse = " "), 
[08:27:38.260]                             hostname = base::Sys.info()[["nodename"]])
[08:27:38.260]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:38.260]                             info)
[08:27:38.260]                           info <- base::paste(info, collapse = "; ")
[08:27:38.260]                           if (!has_future) {
[08:27:38.260]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:38.260]                               info)
[08:27:38.260]                           }
[08:27:38.260]                           else {
[08:27:38.260]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:38.260]                               info, version)
[08:27:38.260]                           }
[08:27:38.260]                           base::stop(msg)
[08:27:38.260]                         }
[08:27:38.260]                       })
[08:27:38.260]                     }
[08:27:38.260]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:38.260]                     base::options(mc.cores = 1L)
[08:27:38.260]                   }
[08:27:38.260]                   ...future.strategy.old <- future::plan("list")
[08:27:38.260]                   options(future.plan = NULL)
[08:27:38.260]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.260]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:38.260]                 }
[08:27:38.260]                 ...future.workdir <- getwd()
[08:27:38.260]             }
[08:27:38.260]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:38.260]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:38.260]         }
[08:27:38.260]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:38.260]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:38.260]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:38.260]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:38.260]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:38.260]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:38.260]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:38.260]             base::names(...future.oldOptions))
[08:27:38.260]     }
[08:27:38.260]     if (FALSE) {
[08:27:38.260]     }
[08:27:38.260]     else {
[08:27:38.260]         if (TRUE) {
[08:27:38.260]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:38.260]                 open = "w")
[08:27:38.260]         }
[08:27:38.260]         else {
[08:27:38.260]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:38.260]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:38.260]         }
[08:27:38.260]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:38.260]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:38.260]             base::sink(type = "output", split = FALSE)
[08:27:38.260]             base::close(...future.stdout)
[08:27:38.260]         }, add = TRUE)
[08:27:38.260]     }
[08:27:38.260]     ...future.frame <- base::sys.nframe()
[08:27:38.260]     ...future.conditions <- base::list()
[08:27:38.260]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:38.260]     if (FALSE) {
[08:27:38.260]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:38.260]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:38.260]     }
[08:27:38.260]     ...future.result <- base::tryCatch({
[08:27:38.260]         base::withCallingHandlers({
[08:27:38.260]             ...future.value <- base::withVisible(base::local({
[08:27:38.260]                 ...future.makeSendCondition <- base::local({
[08:27:38.260]                   sendCondition <- NULL
[08:27:38.260]                   function(frame = 1L) {
[08:27:38.260]                     if (is.function(sendCondition)) 
[08:27:38.260]                       return(sendCondition)
[08:27:38.260]                     ns <- getNamespace("parallel")
[08:27:38.260]                     if (exists("sendData", mode = "function", 
[08:27:38.260]                       envir = ns)) {
[08:27:38.260]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:38.260]                         envir = ns)
[08:27:38.260]                       envir <- sys.frame(frame)
[08:27:38.260]                       master <- NULL
[08:27:38.260]                       while (!identical(envir, .GlobalEnv) && 
[08:27:38.260]                         !identical(envir, emptyenv())) {
[08:27:38.260]                         if (exists("master", mode = "list", envir = envir, 
[08:27:38.260]                           inherits = FALSE)) {
[08:27:38.260]                           master <- get("master", mode = "list", 
[08:27:38.260]                             envir = envir, inherits = FALSE)
[08:27:38.260]                           if (inherits(master, c("SOCKnode", 
[08:27:38.260]                             "SOCK0node"))) {
[08:27:38.260]                             sendCondition <<- function(cond) {
[08:27:38.260]                               data <- list(type = "VALUE", value = cond, 
[08:27:38.260]                                 success = TRUE)
[08:27:38.260]                               parallel_sendData(master, data)
[08:27:38.260]                             }
[08:27:38.260]                             return(sendCondition)
[08:27:38.260]                           }
[08:27:38.260]                         }
[08:27:38.260]                         frame <- frame + 1L
[08:27:38.260]                         envir <- sys.frame(frame)
[08:27:38.260]                       }
[08:27:38.260]                     }
[08:27:38.260]                     sendCondition <<- function(cond) NULL
[08:27:38.260]                   }
[08:27:38.260]                 })
[08:27:38.260]                 withCallingHandlers({
[08:27:38.260]                   42
[08:27:38.260]                 }, immediateCondition = function(cond) {
[08:27:38.260]                   sendCondition <- ...future.makeSendCondition()
[08:27:38.260]                   sendCondition(cond)
[08:27:38.260]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.260]                   {
[08:27:38.260]                     inherits <- base::inherits
[08:27:38.260]                     invokeRestart <- base::invokeRestart
[08:27:38.260]                     is.null <- base::is.null
[08:27:38.260]                     muffled <- FALSE
[08:27:38.260]                     if (inherits(cond, "message")) {
[08:27:38.260]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:38.260]                       if (muffled) 
[08:27:38.260]                         invokeRestart("muffleMessage")
[08:27:38.260]                     }
[08:27:38.260]                     else if (inherits(cond, "warning")) {
[08:27:38.260]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:38.260]                       if (muffled) 
[08:27:38.260]                         invokeRestart("muffleWarning")
[08:27:38.260]                     }
[08:27:38.260]                     else if (inherits(cond, "condition")) {
[08:27:38.260]                       if (!is.null(pattern)) {
[08:27:38.260]                         computeRestarts <- base::computeRestarts
[08:27:38.260]                         grepl <- base::grepl
[08:27:38.260]                         restarts <- computeRestarts(cond)
[08:27:38.260]                         for (restart in restarts) {
[08:27:38.260]                           name <- restart$name
[08:27:38.260]                           if (is.null(name)) 
[08:27:38.260]                             next
[08:27:38.260]                           if (!grepl(pattern, name)) 
[08:27:38.260]                             next
[08:27:38.260]                           invokeRestart(restart)
[08:27:38.260]                           muffled <- TRUE
[08:27:38.260]                           break
[08:27:38.260]                         }
[08:27:38.260]                       }
[08:27:38.260]                     }
[08:27:38.260]                     invisible(muffled)
[08:27:38.260]                   }
[08:27:38.260]                   muffleCondition(cond)
[08:27:38.260]                 })
[08:27:38.260]             }))
[08:27:38.260]             future::FutureResult(value = ...future.value$value, 
[08:27:38.260]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.260]                   ...future.rng), globalenv = if (FALSE) 
[08:27:38.260]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:38.260]                     ...future.globalenv.names))
[08:27:38.260]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:38.260]         }, condition = base::local({
[08:27:38.260]             c <- base::c
[08:27:38.260]             inherits <- base::inherits
[08:27:38.260]             invokeRestart <- base::invokeRestart
[08:27:38.260]             length <- base::length
[08:27:38.260]             list <- base::list
[08:27:38.260]             seq.int <- base::seq.int
[08:27:38.260]             signalCondition <- base::signalCondition
[08:27:38.260]             sys.calls <- base::sys.calls
[08:27:38.260]             `[[` <- base::`[[`
[08:27:38.260]             `+` <- base::`+`
[08:27:38.260]             `<<-` <- base::`<<-`
[08:27:38.260]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:38.260]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:38.260]                   3L)]
[08:27:38.260]             }
[08:27:38.260]             function(cond) {
[08:27:38.260]                 is_error <- inherits(cond, "error")
[08:27:38.260]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:38.260]                   NULL)
[08:27:38.260]                 if (is_error) {
[08:27:38.260]                   sessionInformation <- function() {
[08:27:38.260]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:38.260]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:38.260]                       search = base::search(), system = base::Sys.info())
[08:27:38.260]                   }
[08:27:38.260]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.260]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:38.260]                     cond$call), session = sessionInformation(), 
[08:27:38.260]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:38.260]                   signalCondition(cond)
[08:27:38.260]                 }
[08:27:38.260]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:38.260]                 "immediateCondition"))) {
[08:27:38.260]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:38.260]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.260]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:38.260]                   if (TRUE && !signal) {
[08:27:38.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.260]                     {
[08:27:38.260]                       inherits <- base::inherits
[08:27:38.260]                       invokeRestart <- base::invokeRestart
[08:27:38.260]                       is.null <- base::is.null
[08:27:38.260]                       muffled <- FALSE
[08:27:38.260]                       if (inherits(cond, "message")) {
[08:27:38.260]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.260]                         if (muffled) 
[08:27:38.260]                           invokeRestart("muffleMessage")
[08:27:38.260]                       }
[08:27:38.260]                       else if (inherits(cond, "warning")) {
[08:27:38.260]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.260]                         if (muffled) 
[08:27:38.260]                           invokeRestart("muffleWarning")
[08:27:38.260]                       }
[08:27:38.260]                       else if (inherits(cond, "condition")) {
[08:27:38.260]                         if (!is.null(pattern)) {
[08:27:38.260]                           computeRestarts <- base::computeRestarts
[08:27:38.260]                           grepl <- base::grepl
[08:27:38.260]                           restarts <- computeRestarts(cond)
[08:27:38.260]                           for (restart in restarts) {
[08:27:38.260]                             name <- restart$name
[08:27:38.260]                             if (is.null(name)) 
[08:27:38.260]                               next
[08:27:38.260]                             if (!grepl(pattern, name)) 
[08:27:38.260]                               next
[08:27:38.260]                             invokeRestart(restart)
[08:27:38.260]                             muffled <- TRUE
[08:27:38.260]                             break
[08:27:38.260]                           }
[08:27:38.260]                         }
[08:27:38.260]                       }
[08:27:38.260]                       invisible(muffled)
[08:27:38.260]                     }
[08:27:38.260]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.260]                   }
[08:27:38.260]                 }
[08:27:38.260]                 else {
[08:27:38.260]                   if (TRUE) {
[08:27:38.260]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.260]                     {
[08:27:38.260]                       inherits <- base::inherits
[08:27:38.260]                       invokeRestart <- base::invokeRestart
[08:27:38.260]                       is.null <- base::is.null
[08:27:38.260]                       muffled <- FALSE
[08:27:38.260]                       if (inherits(cond, "message")) {
[08:27:38.260]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.260]                         if (muffled) 
[08:27:38.260]                           invokeRestart("muffleMessage")
[08:27:38.260]                       }
[08:27:38.260]                       else if (inherits(cond, "warning")) {
[08:27:38.260]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.260]                         if (muffled) 
[08:27:38.260]                           invokeRestart("muffleWarning")
[08:27:38.260]                       }
[08:27:38.260]                       else if (inherits(cond, "condition")) {
[08:27:38.260]                         if (!is.null(pattern)) {
[08:27:38.260]                           computeRestarts <- base::computeRestarts
[08:27:38.260]                           grepl <- base::grepl
[08:27:38.260]                           restarts <- computeRestarts(cond)
[08:27:38.260]                           for (restart in restarts) {
[08:27:38.260]                             name <- restart$name
[08:27:38.260]                             if (is.null(name)) 
[08:27:38.260]                               next
[08:27:38.260]                             if (!grepl(pattern, name)) 
[08:27:38.260]                               next
[08:27:38.260]                             invokeRestart(restart)
[08:27:38.260]                             muffled <- TRUE
[08:27:38.260]                             break
[08:27:38.260]                           }
[08:27:38.260]                         }
[08:27:38.260]                       }
[08:27:38.260]                       invisible(muffled)
[08:27:38.260]                     }
[08:27:38.260]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.260]                   }
[08:27:38.260]                 }
[08:27:38.260]             }
[08:27:38.260]         }))
[08:27:38.260]     }, error = function(ex) {
[08:27:38.260]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:38.260]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.260]                 ...future.rng), started = ...future.startTime, 
[08:27:38.260]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:38.260]             version = "1.8"), class = "FutureResult")
[08:27:38.260]     }, finally = {
[08:27:38.260]         if (!identical(...future.workdir, getwd())) 
[08:27:38.260]             setwd(...future.workdir)
[08:27:38.260]         {
[08:27:38.260]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:38.260]                 ...future.oldOptions$nwarnings <- NULL
[08:27:38.260]             }
[08:27:38.260]             base::options(...future.oldOptions)
[08:27:38.260]             if (.Platform$OS.type == "windows") {
[08:27:38.260]                 old_names <- names(...future.oldEnvVars)
[08:27:38.260]                 envs <- base::Sys.getenv()
[08:27:38.260]                 names <- names(envs)
[08:27:38.260]                 common <- intersect(names, old_names)
[08:27:38.260]                 added <- setdiff(names, old_names)
[08:27:38.260]                 removed <- setdiff(old_names, names)
[08:27:38.260]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:38.260]                   envs[common]]
[08:27:38.260]                 NAMES <- toupper(changed)
[08:27:38.260]                 args <- list()
[08:27:38.260]                 for (kk in seq_along(NAMES)) {
[08:27:38.260]                   name <- changed[[kk]]
[08:27:38.260]                   NAME <- NAMES[[kk]]
[08:27:38.260]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.260]                     next
[08:27:38.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.260]                 }
[08:27:38.260]                 NAMES <- toupper(added)
[08:27:38.260]                 for (kk in seq_along(NAMES)) {
[08:27:38.260]                   name <- added[[kk]]
[08:27:38.260]                   NAME <- NAMES[[kk]]
[08:27:38.260]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.260]                     next
[08:27:38.260]                   args[[name]] <- ""
[08:27:38.260]                 }
[08:27:38.260]                 NAMES <- toupper(removed)
[08:27:38.260]                 for (kk in seq_along(NAMES)) {
[08:27:38.260]                   name <- removed[[kk]]
[08:27:38.260]                   NAME <- NAMES[[kk]]
[08:27:38.260]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.260]                     next
[08:27:38.260]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.260]                 }
[08:27:38.260]                 if (length(args) > 0) 
[08:27:38.260]                   base::do.call(base::Sys.setenv, args = args)
[08:27:38.260]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:38.260]             }
[08:27:38.260]             else {
[08:27:38.260]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:38.260]             }
[08:27:38.260]             {
[08:27:38.260]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:38.260]                   0L) {
[08:27:38.260]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:38.260]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:38.260]                   base::options(opts)
[08:27:38.260]                 }
[08:27:38.260]                 {
[08:27:38.260]                   {
[08:27:38.260]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:38.260]                     NULL
[08:27:38.260]                   }
[08:27:38.260]                   options(future.plan = NULL)
[08:27:38.260]                   if (is.na(NA_character_)) 
[08:27:38.260]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.260]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:38.260]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:38.260]                     .init = FALSE)
[08:27:38.260]                 }
[08:27:38.260]             }
[08:27:38.260]         }
[08:27:38.260]     })
[08:27:38.260]     if (TRUE) {
[08:27:38.260]         base::sink(type = "output", split = FALSE)
[08:27:38.260]         if (TRUE) {
[08:27:38.260]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:38.260]         }
[08:27:38.260]         else {
[08:27:38.260]             ...future.result["stdout"] <- base::list(NULL)
[08:27:38.260]         }
[08:27:38.260]         base::close(...future.stdout)
[08:27:38.260]         ...future.stdout <- NULL
[08:27:38.260]     }
[08:27:38.260]     ...future.result$conditions <- ...future.conditions
[08:27:38.260]     ...future.result$finished <- base::Sys.time()
[08:27:38.260]     ...future.result
[08:27:38.260] }
[08:27:38.263] MultisessionFuture started
[08:27:38.263] - Launch lazy future ... done
[08:27:38.264] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘<none>’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.275] result() for ClusterFuture ...
[08:27:38.275] receiveMessageFromWorker() for ClusterFuture ...
[08:27:38.275] - Validating connection of MultisessionFuture
[08:27:38.305] - received message: FutureResult
[08:27:38.306] - Received FutureResult
[08:27:38.306] - Erased future from FutureRegistry
[08:27:38.306] result() for ClusterFuture ...
[08:27:38.306] - result already collected: FutureResult
[08:27:38.306] result() for ClusterFuture ... done
[08:27:38.306] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:38.306] result() for ClusterFuture ... done
[08:27:38.306] result() for ClusterFuture ...
[08:27:38.306] - result already collected: FutureResult
[08:27:38.306] result() for ClusterFuture ... done
[08:27:38.307] getGlobalsAndPackages() ...
[08:27:38.307] Searching for globals...
[08:27:38.308] - globals found: [1] ‘{’
[08:27:38.308] Searching for globals ... DONE
[08:27:38.308] Resolving globals: FALSE
[08:27:38.308] 
[08:27:38.308] 
[08:27:38.308] getGlobalsAndPackages() ... DONE
[08:27:38.309] run() for ‘Future’ ...
[08:27:38.309] - state: ‘created’
[08:27:38.309] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:38.323] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.324] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:38.324]   - Field: ‘node’
[08:27:38.324]   - Field: ‘label’
[08:27:38.324]   - Field: ‘local’
[08:27:38.324]   - Field: ‘owner’
[08:27:38.324]   - Field: ‘envir’
[08:27:38.324]   - Field: ‘workers’
[08:27:38.324]   - Field: ‘packages’
[08:27:38.324]   - Field: ‘gc’
[08:27:38.324]   - Field: ‘conditions’
[08:27:38.324]   - Field: ‘persistent’
[08:27:38.325]   - Field: ‘expr’
[08:27:38.325]   - Field: ‘uuid’
[08:27:38.325]   - Field: ‘seed’
[08:27:38.325]   - Field: ‘version’
[08:27:38.325]   - Field: ‘result’
[08:27:38.325]   - Field: ‘asynchronous’
[08:27:38.325]   - Field: ‘calls’
[08:27:38.325]   - Field: ‘globals’
[08:27:38.325]   - Field: ‘stdout’
[08:27:38.326]   - Field: ‘earlySignal’
[08:27:38.326]   - Field: ‘lazy’
[08:27:38.326]   - Field: ‘state’
[08:27:38.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:38.326] - Launch lazy future ...
[08:27:38.326] Packages needed by the future expression (n = 0): <none>
[08:27:38.326] Packages needed by future strategies (n = 0): <none>
[08:27:38.327] {
[08:27:38.327]     {
[08:27:38.327]         {
[08:27:38.327]             ...future.startTime <- base::Sys.time()
[08:27:38.327]             {
[08:27:38.327]                 {
[08:27:38.327]                   {
[08:27:38.327]                     {
[08:27:38.327]                       base::local({
[08:27:38.327]                         has_future <- base::requireNamespace("future", 
[08:27:38.327]                           quietly = TRUE)
[08:27:38.327]                         if (has_future) {
[08:27:38.327]                           ns <- base::getNamespace("future")
[08:27:38.327]                           version <- ns[[".package"]][["version"]]
[08:27:38.327]                           if (is.null(version)) 
[08:27:38.327]                             version <- utils::packageVersion("future")
[08:27:38.327]                         }
[08:27:38.327]                         else {
[08:27:38.327]                           version <- NULL
[08:27:38.327]                         }
[08:27:38.327]                         if (!has_future || version < "1.8.0") {
[08:27:38.327]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:38.327]                             "", base::R.version$version.string), 
[08:27:38.327]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:38.327]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:38.327]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:38.327]                               "release", "version")], collapse = " "), 
[08:27:38.327]                             hostname = base::Sys.info()[["nodename"]])
[08:27:38.327]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:38.327]                             info)
[08:27:38.327]                           info <- base::paste(info, collapse = "; ")
[08:27:38.327]                           if (!has_future) {
[08:27:38.327]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:38.327]                               info)
[08:27:38.327]                           }
[08:27:38.327]                           else {
[08:27:38.327]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:38.327]                               info, version)
[08:27:38.327]                           }
[08:27:38.327]                           base::stop(msg)
[08:27:38.327]                         }
[08:27:38.327]                       })
[08:27:38.327]                     }
[08:27:38.327]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:38.327]                     base::options(mc.cores = 1L)
[08:27:38.327]                   }
[08:27:38.327]                   ...future.strategy.old <- future::plan("list")
[08:27:38.327]                   options(future.plan = NULL)
[08:27:38.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:38.327]                 }
[08:27:38.327]                 ...future.workdir <- getwd()
[08:27:38.327]             }
[08:27:38.327]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:38.327]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:38.327]         }
[08:27:38.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:38.327]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:38.327]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:38.327]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:38.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:38.327]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:38.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:38.327]             base::names(...future.oldOptions))
[08:27:38.327]     }
[08:27:38.327]     if (FALSE) {
[08:27:38.327]     }
[08:27:38.327]     else {
[08:27:38.327]         if (TRUE) {
[08:27:38.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:38.327]                 open = "w")
[08:27:38.327]         }
[08:27:38.327]         else {
[08:27:38.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:38.327]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:38.327]         }
[08:27:38.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:38.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:38.327]             base::sink(type = "output", split = FALSE)
[08:27:38.327]             base::close(...future.stdout)
[08:27:38.327]         }, add = TRUE)
[08:27:38.327]     }
[08:27:38.327]     ...future.frame <- base::sys.nframe()
[08:27:38.327]     ...future.conditions <- base::list()
[08:27:38.327]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:38.327]     if (FALSE) {
[08:27:38.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:38.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:38.327]     }
[08:27:38.327]     ...future.result <- base::tryCatch({
[08:27:38.327]         base::withCallingHandlers({
[08:27:38.327]             ...future.value <- base::withVisible(base::local({
[08:27:38.327]                 ...future.makeSendCondition <- base::local({
[08:27:38.327]                   sendCondition <- NULL
[08:27:38.327]                   function(frame = 1L) {
[08:27:38.327]                     if (is.function(sendCondition)) 
[08:27:38.327]                       return(sendCondition)
[08:27:38.327]                     ns <- getNamespace("parallel")
[08:27:38.327]                     if (exists("sendData", mode = "function", 
[08:27:38.327]                       envir = ns)) {
[08:27:38.327]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:38.327]                         envir = ns)
[08:27:38.327]                       envir <- sys.frame(frame)
[08:27:38.327]                       master <- NULL
[08:27:38.327]                       while (!identical(envir, .GlobalEnv) && 
[08:27:38.327]                         !identical(envir, emptyenv())) {
[08:27:38.327]                         if (exists("master", mode = "list", envir = envir, 
[08:27:38.327]                           inherits = FALSE)) {
[08:27:38.327]                           master <- get("master", mode = "list", 
[08:27:38.327]                             envir = envir, inherits = FALSE)
[08:27:38.327]                           if (inherits(master, c("SOCKnode", 
[08:27:38.327]                             "SOCK0node"))) {
[08:27:38.327]                             sendCondition <<- function(cond) {
[08:27:38.327]                               data <- list(type = "VALUE", value = cond, 
[08:27:38.327]                                 success = TRUE)
[08:27:38.327]                               parallel_sendData(master, data)
[08:27:38.327]                             }
[08:27:38.327]                             return(sendCondition)
[08:27:38.327]                           }
[08:27:38.327]                         }
[08:27:38.327]                         frame <- frame + 1L
[08:27:38.327]                         envir <- sys.frame(frame)
[08:27:38.327]                       }
[08:27:38.327]                     }
[08:27:38.327]                     sendCondition <<- function(cond) NULL
[08:27:38.327]                   }
[08:27:38.327]                 })
[08:27:38.327]                 withCallingHandlers({
[08:27:38.327]                   {
[08:27:38.327]                     42
[08:27:38.327]                   }
[08:27:38.327]                 }, immediateCondition = function(cond) {
[08:27:38.327]                   sendCondition <- ...future.makeSendCondition()
[08:27:38.327]                   sendCondition(cond)
[08:27:38.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.327]                   {
[08:27:38.327]                     inherits <- base::inherits
[08:27:38.327]                     invokeRestart <- base::invokeRestart
[08:27:38.327]                     is.null <- base::is.null
[08:27:38.327]                     muffled <- FALSE
[08:27:38.327]                     if (inherits(cond, "message")) {
[08:27:38.327]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:38.327]                       if (muffled) 
[08:27:38.327]                         invokeRestart("muffleMessage")
[08:27:38.327]                     }
[08:27:38.327]                     else if (inherits(cond, "warning")) {
[08:27:38.327]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:38.327]                       if (muffled) 
[08:27:38.327]                         invokeRestart("muffleWarning")
[08:27:38.327]                     }
[08:27:38.327]                     else if (inherits(cond, "condition")) {
[08:27:38.327]                       if (!is.null(pattern)) {
[08:27:38.327]                         computeRestarts <- base::computeRestarts
[08:27:38.327]                         grepl <- base::grepl
[08:27:38.327]                         restarts <- computeRestarts(cond)
[08:27:38.327]                         for (restart in restarts) {
[08:27:38.327]                           name <- restart$name
[08:27:38.327]                           if (is.null(name)) 
[08:27:38.327]                             next
[08:27:38.327]                           if (!grepl(pattern, name)) 
[08:27:38.327]                             next
[08:27:38.327]                           invokeRestart(restart)
[08:27:38.327]                           muffled <- TRUE
[08:27:38.327]                           break
[08:27:38.327]                         }
[08:27:38.327]                       }
[08:27:38.327]                     }
[08:27:38.327]                     invisible(muffled)
[08:27:38.327]                   }
[08:27:38.327]                   muffleCondition(cond)
[08:27:38.327]                 })
[08:27:38.327]             }))
[08:27:38.327]             future::FutureResult(value = ...future.value$value, 
[08:27:38.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.327]                   ...future.rng), globalenv = if (FALSE) 
[08:27:38.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:38.327]                     ...future.globalenv.names))
[08:27:38.327]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:38.327]         }, condition = base::local({
[08:27:38.327]             c <- base::c
[08:27:38.327]             inherits <- base::inherits
[08:27:38.327]             invokeRestart <- base::invokeRestart
[08:27:38.327]             length <- base::length
[08:27:38.327]             list <- base::list
[08:27:38.327]             seq.int <- base::seq.int
[08:27:38.327]             signalCondition <- base::signalCondition
[08:27:38.327]             sys.calls <- base::sys.calls
[08:27:38.327]             `[[` <- base::`[[`
[08:27:38.327]             `+` <- base::`+`
[08:27:38.327]             `<<-` <- base::`<<-`
[08:27:38.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:38.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:38.327]                   3L)]
[08:27:38.327]             }
[08:27:38.327]             function(cond) {
[08:27:38.327]                 is_error <- inherits(cond, "error")
[08:27:38.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:38.327]                   NULL)
[08:27:38.327]                 if (is_error) {
[08:27:38.327]                   sessionInformation <- function() {
[08:27:38.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:38.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:38.327]                       search = base::search(), system = base::Sys.info())
[08:27:38.327]                   }
[08:27:38.327]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:38.327]                     cond$call), session = sessionInformation(), 
[08:27:38.327]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:38.327]                   signalCondition(cond)
[08:27:38.327]                 }
[08:27:38.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:38.327]                 "immediateCondition"))) {
[08:27:38.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:38.327]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:38.327]                   if (TRUE && !signal) {
[08:27:38.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.327]                     {
[08:27:38.327]                       inherits <- base::inherits
[08:27:38.327]                       invokeRestart <- base::invokeRestart
[08:27:38.327]                       is.null <- base::is.null
[08:27:38.327]                       muffled <- FALSE
[08:27:38.327]                       if (inherits(cond, "message")) {
[08:27:38.327]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.327]                         if (muffled) 
[08:27:38.327]                           invokeRestart("muffleMessage")
[08:27:38.327]                       }
[08:27:38.327]                       else if (inherits(cond, "warning")) {
[08:27:38.327]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.327]                         if (muffled) 
[08:27:38.327]                           invokeRestart("muffleWarning")
[08:27:38.327]                       }
[08:27:38.327]                       else if (inherits(cond, "condition")) {
[08:27:38.327]                         if (!is.null(pattern)) {
[08:27:38.327]                           computeRestarts <- base::computeRestarts
[08:27:38.327]                           grepl <- base::grepl
[08:27:38.327]                           restarts <- computeRestarts(cond)
[08:27:38.327]                           for (restart in restarts) {
[08:27:38.327]                             name <- restart$name
[08:27:38.327]                             if (is.null(name)) 
[08:27:38.327]                               next
[08:27:38.327]                             if (!grepl(pattern, name)) 
[08:27:38.327]                               next
[08:27:38.327]                             invokeRestart(restart)
[08:27:38.327]                             muffled <- TRUE
[08:27:38.327]                             break
[08:27:38.327]                           }
[08:27:38.327]                         }
[08:27:38.327]                       }
[08:27:38.327]                       invisible(muffled)
[08:27:38.327]                     }
[08:27:38.327]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.327]                   }
[08:27:38.327]                 }
[08:27:38.327]                 else {
[08:27:38.327]                   if (TRUE) {
[08:27:38.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.327]                     {
[08:27:38.327]                       inherits <- base::inherits
[08:27:38.327]                       invokeRestart <- base::invokeRestart
[08:27:38.327]                       is.null <- base::is.null
[08:27:38.327]                       muffled <- FALSE
[08:27:38.327]                       if (inherits(cond, "message")) {
[08:27:38.327]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.327]                         if (muffled) 
[08:27:38.327]                           invokeRestart("muffleMessage")
[08:27:38.327]                       }
[08:27:38.327]                       else if (inherits(cond, "warning")) {
[08:27:38.327]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.327]                         if (muffled) 
[08:27:38.327]                           invokeRestart("muffleWarning")
[08:27:38.327]                       }
[08:27:38.327]                       else if (inherits(cond, "condition")) {
[08:27:38.327]                         if (!is.null(pattern)) {
[08:27:38.327]                           computeRestarts <- base::computeRestarts
[08:27:38.327]                           grepl <- base::grepl
[08:27:38.327]                           restarts <- computeRestarts(cond)
[08:27:38.327]                           for (restart in restarts) {
[08:27:38.327]                             name <- restart$name
[08:27:38.327]                             if (is.null(name)) 
[08:27:38.327]                               next
[08:27:38.327]                             if (!grepl(pattern, name)) 
[08:27:38.327]                               next
[08:27:38.327]                             invokeRestart(restart)
[08:27:38.327]                             muffled <- TRUE
[08:27:38.327]                             break
[08:27:38.327]                           }
[08:27:38.327]                         }
[08:27:38.327]                       }
[08:27:38.327]                       invisible(muffled)
[08:27:38.327]                     }
[08:27:38.327]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.327]                   }
[08:27:38.327]                 }
[08:27:38.327]             }
[08:27:38.327]         }))
[08:27:38.327]     }, error = function(ex) {
[08:27:38.327]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:38.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.327]                 ...future.rng), started = ...future.startTime, 
[08:27:38.327]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:38.327]             version = "1.8"), class = "FutureResult")
[08:27:38.327]     }, finally = {
[08:27:38.327]         if (!identical(...future.workdir, getwd())) 
[08:27:38.327]             setwd(...future.workdir)
[08:27:38.327]         {
[08:27:38.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:38.327]                 ...future.oldOptions$nwarnings <- NULL
[08:27:38.327]             }
[08:27:38.327]             base::options(...future.oldOptions)
[08:27:38.327]             if (.Platform$OS.type == "windows") {
[08:27:38.327]                 old_names <- names(...future.oldEnvVars)
[08:27:38.327]                 envs <- base::Sys.getenv()
[08:27:38.327]                 names <- names(envs)
[08:27:38.327]                 common <- intersect(names, old_names)
[08:27:38.327]                 added <- setdiff(names, old_names)
[08:27:38.327]                 removed <- setdiff(old_names, names)
[08:27:38.327]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:38.327]                   envs[common]]
[08:27:38.327]                 NAMES <- toupper(changed)
[08:27:38.327]                 args <- list()
[08:27:38.327]                 for (kk in seq_along(NAMES)) {
[08:27:38.327]                   name <- changed[[kk]]
[08:27:38.327]                   NAME <- NAMES[[kk]]
[08:27:38.327]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.327]                     next
[08:27:38.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.327]                 }
[08:27:38.327]                 NAMES <- toupper(added)
[08:27:38.327]                 for (kk in seq_along(NAMES)) {
[08:27:38.327]                   name <- added[[kk]]
[08:27:38.327]                   NAME <- NAMES[[kk]]
[08:27:38.327]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.327]                     next
[08:27:38.327]                   args[[name]] <- ""
[08:27:38.327]                 }
[08:27:38.327]                 NAMES <- toupper(removed)
[08:27:38.327]                 for (kk in seq_along(NAMES)) {
[08:27:38.327]                   name <- removed[[kk]]
[08:27:38.327]                   NAME <- NAMES[[kk]]
[08:27:38.327]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.327]                     next
[08:27:38.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.327]                 }
[08:27:38.327]                 if (length(args) > 0) 
[08:27:38.327]                   base::do.call(base::Sys.setenv, args = args)
[08:27:38.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:38.327]             }
[08:27:38.327]             else {
[08:27:38.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:38.327]             }
[08:27:38.327]             {
[08:27:38.327]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:38.327]                   0L) {
[08:27:38.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:38.327]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:38.327]                   base::options(opts)
[08:27:38.327]                 }
[08:27:38.327]                 {
[08:27:38.327]                   {
[08:27:38.327]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:38.327]                     NULL
[08:27:38.327]                   }
[08:27:38.327]                   options(future.plan = NULL)
[08:27:38.327]                   if (is.na(NA_character_)) 
[08:27:38.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:38.327]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:38.327]                     .init = FALSE)
[08:27:38.327]                 }
[08:27:38.327]             }
[08:27:38.327]         }
[08:27:38.327]     })
[08:27:38.327]     if (TRUE) {
[08:27:38.327]         base::sink(type = "output", split = FALSE)
[08:27:38.327]         if (TRUE) {
[08:27:38.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:38.327]         }
[08:27:38.327]         else {
[08:27:38.327]             ...future.result["stdout"] <- base::list(NULL)
[08:27:38.327]         }
[08:27:38.327]         base::close(...future.stdout)
[08:27:38.327]         ...future.stdout <- NULL
[08:27:38.327]     }
[08:27:38.327]     ...future.result$conditions <- ...future.conditions
[08:27:38.327]     ...future.result$finished <- base::Sys.time()
[08:27:38.327]     ...future.result
[08:27:38.327] }
[08:27:38.331] MultisessionFuture started
[08:27:38.331] - Launch lazy future ... done
[08:27:38.331] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘<none>’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.342] result() for ClusterFuture ...
[08:27:38.342] receiveMessageFromWorker() for ClusterFuture ...
[08:27:38.343] - Validating connection of MultisessionFuture
[08:27:38.373] - received message: FutureResult
[08:27:38.373] - Received FutureResult
[08:27:38.374] - Erased future from FutureRegistry
[08:27:38.374] result() for ClusterFuture ...
[08:27:38.374] - result already collected: FutureResult
[08:27:38.374] result() for ClusterFuture ... done
[08:27:38.374] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:38.374] result() for ClusterFuture ... done
[08:27:38.374] result() for ClusterFuture ...
[08:27:38.375] - result already collected: FutureResult
[08:27:38.375] result() for ClusterFuture ... done
[08:27:38.377] getGlobalsAndPackages() ...
[08:27:38.377] 
[08:27:38.377] - globals: [0] <none>
[08:27:38.377] getGlobalsAndPackages() ... DONE
[08:27:38.390] Packages needed by the future expression (n = 0): <none>
[08:27:38.391] Packages needed by future strategies (n = 0): <none>
[08:27:38.391] {
[08:27:38.391]     {
[08:27:38.391]         {
[08:27:38.391]             ...future.startTime <- base::Sys.time()
[08:27:38.391]             {
[08:27:38.391]                 {
[08:27:38.391]                   {
[08:27:38.391]                     {
[08:27:38.391]                       base::local({
[08:27:38.391]                         has_future <- base::requireNamespace("future", 
[08:27:38.391]                           quietly = TRUE)
[08:27:38.391]                         if (has_future) {
[08:27:38.391]                           ns <- base::getNamespace("future")
[08:27:38.391]                           version <- ns[[".package"]][["version"]]
[08:27:38.391]                           if (is.null(version)) 
[08:27:38.391]                             version <- utils::packageVersion("future")
[08:27:38.391]                         }
[08:27:38.391]                         else {
[08:27:38.391]                           version <- NULL
[08:27:38.391]                         }
[08:27:38.391]                         if (!has_future || version < "1.8.0") {
[08:27:38.391]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:38.391]                             "", base::R.version$version.string), 
[08:27:38.391]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:38.391]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:38.391]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:38.391]                               "release", "version")], collapse = " "), 
[08:27:38.391]                             hostname = base::Sys.info()[["nodename"]])
[08:27:38.391]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:38.391]                             info)
[08:27:38.391]                           info <- base::paste(info, collapse = "; ")
[08:27:38.391]                           if (!has_future) {
[08:27:38.391]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:38.391]                               info)
[08:27:38.391]                           }
[08:27:38.391]                           else {
[08:27:38.391]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:38.391]                               info, version)
[08:27:38.391]                           }
[08:27:38.391]                           base::stop(msg)
[08:27:38.391]                         }
[08:27:38.391]                       })
[08:27:38.391]                     }
[08:27:38.391]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:38.391]                     base::options(mc.cores = 1L)
[08:27:38.391]                   }
[08:27:38.391]                   ...future.strategy.old <- future::plan("list")
[08:27:38.391]                   options(future.plan = NULL)
[08:27:38.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:38.391]                 }
[08:27:38.391]                 ...future.workdir <- getwd()
[08:27:38.391]             }
[08:27:38.391]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:38.391]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:38.391]         }
[08:27:38.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:38.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:38.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:38.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:38.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:38.391]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:38.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:38.391]             base::names(...future.oldOptions))
[08:27:38.391]     }
[08:27:38.391]     if (FALSE) {
[08:27:38.391]     }
[08:27:38.391]     else {
[08:27:38.391]         if (TRUE) {
[08:27:38.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:38.391]                 open = "w")
[08:27:38.391]         }
[08:27:38.391]         else {
[08:27:38.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:38.391]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:38.391]         }
[08:27:38.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:38.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:38.391]             base::sink(type = "output", split = FALSE)
[08:27:38.391]             base::close(...future.stdout)
[08:27:38.391]         }, add = TRUE)
[08:27:38.391]     }
[08:27:38.391]     ...future.frame <- base::sys.nframe()
[08:27:38.391]     ...future.conditions <- base::list()
[08:27:38.391]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:38.391]     if (FALSE) {
[08:27:38.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:38.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:38.391]     }
[08:27:38.391]     ...future.result <- base::tryCatch({
[08:27:38.391]         base::withCallingHandlers({
[08:27:38.391]             ...future.value <- base::withVisible(base::local({
[08:27:38.391]                 ...future.makeSendCondition <- base::local({
[08:27:38.391]                   sendCondition <- NULL
[08:27:38.391]                   function(frame = 1L) {
[08:27:38.391]                     if (is.function(sendCondition)) 
[08:27:38.391]                       return(sendCondition)
[08:27:38.391]                     ns <- getNamespace("parallel")
[08:27:38.391]                     if (exists("sendData", mode = "function", 
[08:27:38.391]                       envir = ns)) {
[08:27:38.391]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:38.391]                         envir = ns)
[08:27:38.391]                       envir <- sys.frame(frame)
[08:27:38.391]                       master <- NULL
[08:27:38.391]                       while (!identical(envir, .GlobalEnv) && 
[08:27:38.391]                         !identical(envir, emptyenv())) {
[08:27:38.391]                         if (exists("master", mode = "list", envir = envir, 
[08:27:38.391]                           inherits = FALSE)) {
[08:27:38.391]                           master <- get("master", mode = "list", 
[08:27:38.391]                             envir = envir, inherits = FALSE)
[08:27:38.391]                           if (inherits(master, c("SOCKnode", 
[08:27:38.391]                             "SOCK0node"))) {
[08:27:38.391]                             sendCondition <<- function(cond) {
[08:27:38.391]                               data <- list(type = "VALUE", value = cond, 
[08:27:38.391]                                 success = TRUE)
[08:27:38.391]                               parallel_sendData(master, data)
[08:27:38.391]                             }
[08:27:38.391]                             return(sendCondition)
[08:27:38.391]                           }
[08:27:38.391]                         }
[08:27:38.391]                         frame <- frame + 1L
[08:27:38.391]                         envir <- sys.frame(frame)
[08:27:38.391]                       }
[08:27:38.391]                     }
[08:27:38.391]                     sendCondition <<- function(cond) NULL
[08:27:38.391]                   }
[08:27:38.391]                 })
[08:27:38.391]                 withCallingHandlers({
[08:27:38.391]                   42
[08:27:38.391]                 }, immediateCondition = function(cond) {
[08:27:38.391]                   sendCondition <- ...future.makeSendCondition()
[08:27:38.391]                   sendCondition(cond)
[08:27:38.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.391]                   {
[08:27:38.391]                     inherits <- base::inherits
[08:27:38.391]                     invokeRestart <- base::invokeRestart
[08:27:38.391]                     is.null <- base::is.null
[08:27:38.391]                     muffled <- FALSE
[08:27:38.391]                     if (inherits(cond, "message")) {
[08:27:38.391]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:38.391]                       if (muffled) 
[08:27:38.391]                         invokeRestart("muffleMessage")
[08:27:38.391]                     }
[08:27:38.391]                     else if (inherits(cond, "warning")) {
[08:27:38.391]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:38.391]                       if (muffled) 
[08:27:38.391]                         invokeRestart("muffleWarning")
[08:27:38.391]                     }
[08:27:38.391]                     else if (inherits(cond, "condition")) {
[08:27:38.391]                       if (!is.null(pattern)) {
[08:27:38.391]                         computeRestarts <- base::computeRestarts
[08:27:38.391]                         grepl <- base::grepl
[08:27:38.391]                         restarts <- computeRestarts(cond)
[08:27:38.391]                         for (restart in restarts) {
[08:27:38.391]                           name <- restart$name
[08:27:38.391]                           if (is.null(name)) 
[08:27:38.391]                             next
[08:27:38.391]                           if (!grepl(pattern, name)) 
[08:27:38.391]                             next
[08:27:38.391]                           invokeRestart(restart)
[08:27:38.391]                           muffled <- TRUE
[08:27:38.391]                           break
[08:27:38.391]                         }
[08:27:38.391]                       }
[08:27:38.391]                     }
[08:27:38.391]                     invisible(muffled)
[08:27:38.391]                   }
[08:27:38.391]                   muffleCondition(cond)
[08:27:38.391]                 })
[08:27:38.391]             }))
[08:27:38.391]             future::FutureResult(value = ...future.value$value, 
[08:27:38.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.391]                   ...future.rng), globalenv = if (FALSE) 
[08:27:38.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:38.391]                     ...future.globalenv.names))
[08:27:38.391]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:38.391]         }, condition = base::local({
[08:27:38.391]             c <- base::c
[08:27:38.391]             inherits <- base::inherits
[08:27:38.391]             invokeRestart <- base::invokeRestart
[08:27:38.391]             length <- base::length
[08:27:38.391]             list <- base::list
[08:27:38.391]             seq.int <- base::seq.int
[08:27:38.391]             signalCondition <- base::signalCondition
[08:27:38.391]             sys.calls <- base::sys.calls
[08:27:38.391]             `[[` <- base::`[[`
[08:27:38.391]             `+` <- base::`+`
[08:27:38.391]             `<<-` <- base::`<<-`
[08:27:38.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:38.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:38.391]                   3L)]
[08:27:38.391]             }
[08:27:38.391]             function(cond) {
[08:27:38.391]                 is_error <- inherits(cond, "error")
[08:27:38.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:38.391]                   NULL)
[08:27:38.391]                 if (is_error) {
[08:27:38.391]                   sessionInformation <- function() {
[08:27:38.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:38.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:38.391]                       search = base::search(), system = base::Sys.info())
[08:27:38.391]                   }
[08:27:38.391]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:38.391]                     cond$call), session = sessionInformation(), 
[08:27:38.391]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:38.391]                   signalCondition(cond)
[08:27:38.391]                 }
[08:27:38.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:38.391]                 "immediateCondition"))) {
[08:27:38.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:38.391]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:38.391]                   if (TRUE && !signal) {
[08:27:38.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.391]                     {
[08:27:38.391]                       inherits <- base::inherits
[08:27:38.391]                       invokeRestart <- base::invokeRestart
[08:27:38.391]                       is.null <- base::is.null
[08:27:38.391]                       muffled <- FALSE
[08:27:38.391]                       if (inherits(cond, "message")) {
[08:27:38.391]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.391]                         if (muffled) 
[08:27:38.391]                           invokeRestart("muffleMessage")
[08:27:38.391]                       }
[08:27:38.391]                       else if (inherits(cond, "warning")) {
[08:27:38.391]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.391]                         if (muffled) 
[08:27:38.391]                           invokeRestart("muffleWarning")
[08:27:38.391]                       }
[08:27:38.391]                       else if (inherits(cond, "condition")) {
[08:27:38.391]                         if (!is.null(pattern)) {
[08:27:38.391]                           computeRestarts <- base::computeRestarts
[08:27:38.391]                           grepl <- base::grepl
[08:27:38.391]                           restarts <- computeRestarts(cond)
[08:27:38.391]                           for (restart in restarts) {
[08:27:38.391]                             name <- restart$name
[08:27:38.391]                             if (is.null(name)) 
[08:27:38.391]                               next
[08:27:38.391]                             if (!grepl(pattern, name)) 
[08:27:38.391]                               next
[08:27:38.391]                             invokeRestart(restart)
[08:27:38.391]                             muffled <- TRUE
[08:27:38.391]                             break
[08:27:38.391]                           }
[08:27:38.391]                         }
[08:27:38.391]                       }
[08:27:38.391]                       invisible(muffled)
[08:27:38.391]                     }
[08:27:38.391]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.391]                   }
[08:27:38.391]                 }
[08:27:38.391]                 else {
[08:27:38.391]                   if (TRUE) {
[08:27:38.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.391]                     {
[08:27:38.391]                       inherits <- base::inherits
[08:27:38.391]                       invokeRestart <- base::invokeRestart
[08:27:38.391]                       is.null <- base::is.null
[08:27:38.391]                       muffled <- FALSE
[08:27:38.391]                       if (inherits(cond, "message")) {
[08:27:38.391]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.391]                         if (muffled) 
[08:27:38.391]                           invokeRestart("muffleMessage")
[08:27:38.391]                       }
[08:27:38.391]                       else if (inherits(cond, "warning")) {
[08:27:38.391]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.391]                         if (muffled) 
[08:27:38.391]                           invokeRestart("muffleWarning")
[08:27:38.391]                       }
[08:27:38.391]                       else if (inherits(cond, "condition")) {
[08:27:38.391]                         if (!is.null(pattern)) {
[08:27:38.391]                           computeRestarts <- base::computeRestarts
[08:27:38.391]                           grepl <- base::grepl
[08:27:38.391]                           restarts <- computeRestarts(cond)
[08:27:38.391]                           for (restart in restarts) {
[08:27:38.391]                             name <- restart$name
[08:27:38.391]                             if (is.null(name)) 
[08:27:38.391]                               next
[08:27:38.391]                             if (!grepl(pattern, name)) 
[08:27:38.391]                               next
[08:27:38.391]                             invokeRestart(restart)
[08:27:38.391]                             muffled <- TRUE
[08:27:38.391]                             break
[08:27:38.391]                           }
[08:27:38.391]                         }
[08:27:38.391]                       }
[08:27:38.391]                       invisible(muffled)
[08:27:38.391]                     }
[08:27:38.391]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.391]                   }
[08:27:38.391]                 }
[08:27:38.391]             }
[08:27:38.391]         }))
[08:27:38.391]     }, error = function(ex) {
[08:27:38.391]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:38.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.391]                 ...future.rng), started = ...future.startTime, 
[08:27:38.391]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:38.391]             version = "1.8"), class = "FutureResult")
[08:27:38.391]     }, finally = {
[08:27:38.391]         if (!identical(...future.workdir, getwd())) 
[08:27:38.391]             setwd(...future.workdir)
[08:27:38.391]         {
[08:27:38.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:38.391]                 ...future.oldOptions$nwarnings <- NULL
[08:27:38.391]             }
[08:27:38.391]             base::options(...future.oldOptions)
[08:27:38.391]             if (.Platform$OS.type == "windows") {
[08:27:38.391]                 old_names <- names(...future.oldEnvVars)
[08:27:38.391]                 envs <- base::Sys.getenv()
[08:27:38.391]                 names <- names(envs)
[08:27:38.391]                 common <- intersect(names, old_names)
[08:27:38.391]                 added <- setdiff(names, old_names)
[08:27:38.391]                 removed <- setdiff(old_names, names)
[08:27:38.391]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:38.391]                   envs[common]]
[08:27:38.391]                 NAMES <- toupper(changed)
[08:27:38.391]                 args <- list()
[08:27:38.391]                 for (kk in seq_along(NAMES)) {
[08:27:38.391]                   name <- changed[[kk]]
[08:27:38.391]                   NAME <- NAMES[[kk]]
[08:27:38.391]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.391]                     next
[08:27:38.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.391]                 }
[08:27:38.391]                 NAMES <- toupper(added)
[08:27:38.391]                 for (kk in seq_along(NAMES)) {
[08:27:38.391]                   name <- added[[kk]]
[08:27:38.391]                   NAME <- NAMES[[kk]]
[08:27:38.391]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.391]                     next
[08:27:38.391]                   args[[name]] <- ""
[08:27:38.391]                 }
[08:27:38.391]                 NAMES <- toupper(removed)
[08:27:38.391]                 for (kk in seq_along(NAMES)) {
[08:27:38.391]                   name <- removed[[kk]]
[08:27:38.391]                   NAME <- NAMES[[kk]]
[08:27:38.391]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.391]                     next
[08:27:38.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.391]                 }
[08:27:38.391]                 if (length(args) > 0) 
[08:27:38.391]                   base::do.call(base::Sys.setenv, args = args)
[08:27:38.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:38.391]             }
[08:27:38.391]             else {
[08:27:38.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:38.391]             }
[08:27:38.391]             {
[08:27:38.391]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:38.391]                   0L) {
[08:27:38.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:38.391]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:38.391]                   base::options(opts)
[08:27:38.391]                 }
[08:27:38.391]                 {
[08:27:38.391]                   {
[08:27:38.391]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:38.391]                     NULL
[08:27:38.391]                   }
[08:27:38.391]                   options(future.plan = NULL)
[08:27:38.391]                   if (is.na(NA_character_)) 
[08:27:38.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:38.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:38.391]                     .init = FALSE)
[08:27:38.391]                 }
[08:27:38.391]             }
[08:27:38.391]         }
[08:27:38.391]     })
[08:27:38.391]     if (TRUE) {
[08:27:38.391]         base::sink(type = "output", split = FALSE)
[08:27:38.391]         if (TRUE) {
[08:27:38.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:38.391]         }
[08:27:38.391]         else {
[08:27:38.391]             ...future.result["stdout"] <- base::list(NULL)
[08:27:38.391]         }
[08:27:38.391]         base::close(...future.stdout)
[08:27:38.391]         ...future.stdout <- NULL
[08:27:38.391]     }
[08:27:38.391]     ...future.result$conditions <- ...future.conditions
[08:27:38.391]     ...future.result$finished <- base::Sys.time()
[08:27:38.391]     ...future.result
[08:27:38.391] }
[08:27:38.394] MultisessionFuture started
MultisessionFuture:
Label: ‘strategy = multisession’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.406] result() for ClusterFuture ...
[08:27:38.406] receiveMessageFromWorker() for ClusterFuture ...
[08:27:38.406] - Validating connection of MultisessionFuture
[08:27:38.436] - received message: FutureResult
[08:27:38.436] - Received FutureResult
[08:27:38.437] - Erased future from FutureRegistry
[08:27:38.437] result() for ClusterFuture ...
[08:27:38.437] - result already collected: FutureResult
[08:27:38.437] result() for ClusterFuture ... done
[08:27:38.437] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:38.437] result() for ClusterFuture ... done
[08:27:38.437] result() for ClusterFuture ...
[08:27:38.438] - result already collected: FutureResult
[08:27:38.438] result() for ClusterFuture ... done
[08:27:38.438] getGlobalsAndPackages() ...
[08:27:38.438] Searching for globals...
[08:27:38.438] 
[08:27:38.439] Searching for globals ... DONE
[08:27:38.439] - globals: [0] <none>
[08:27:38.439] getGlobalsAndPackages() ... DONE
[08:27:38.439] run() for ‘Future’ ...
[08:27:38.439] - state: ‘created’
[08:27:38.439] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:38.454] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:38.455]   - Field: ‘node’
[08:27:38.455]   - Field: ‘label’
[08:27:38.455]   - Field: ‘local’
[08:27:38.455]   - Field: ‘owner’
[08:27:38.455]   - Field: ‘envir’
[08:27:38.455]   - Field: ‘workers’
[08:27:38.455]   - Field: ‘packages’
[08:27:38.455]   - Field: ‘gc’
[08:27:38.455]   - Field: ‘conditions’
[08:27:38.455]   - Field: ‘persistent’
[08:27:38.455]   - Field: ‘expr’
[08:27:38.456]   - Field: ‘uuid’
[08:27:38.456]   - Field: ‘seed’
[08:27:38.456]   - Field: ‘version’
[08:27:38.456]   - Field: ‘result’
[08:27:38.456]   - Field: ‘asynchronous’
[08:27:38.456]   - Field: ‘calls’
[08:27:38.456]   - Field: ‘globals’
[08:27:38.456]   - Field: ‘stdout’
[08:27:38.456]   - Field: ‘earlySignal’
[08:27:38.457]   - Field: ‘lazy’
[08:27:38.457]   - Field: ‘state’
[08:27:38.457] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:38.457] - Launch lazy future ...
[08:27:38.457] Packages needed by the future expression (n = 0): <none>
[08:27:38.457] Packages needed by future strategies (n = 0): <none>
[08:27:38.458] {
[08:27:38.458]     {
[08:27:38.458]         {
[08:27:38.458]             ...future.startTime <- base::Sys.time()
[08:27:38.458]             {
[08:27:38.458]                 {
[08:27:38.458]                   {
[08:27:38.458]                     {
[08:27:38.458]                       base::local({
[08:27:38.458]                         has_future <- base::requireNamespace("future", 
[08:27:38.458]                           quietly = TRUE)
[08:27:38.458]                         if (has_future) {
[08:27:38.458]                           ns <- base::getNamespace("future")
[08:27:38.458]                           version <- ns[[".package"]][["version"]]
[08:27:38.458]                           if (is.null(version)) 
[08:27:38.458]                             version <- utils::packageVersion("future")
[08:27:38.458]                         }
[08:27:38.458]                         else {
[08:27:38.458]                           version <- NULL
[08:27:38.458]                         }
[08:27:38.458]                         if (!has_future || version < "1.8.0") {
[08:27:38.458]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:38.458]                             "", base::R.version$version.string), 
[08:27:38.458]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:38.458]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:38.458]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:38.458]                               "release", "version")], collapse = " "), 
[08:27:38.458]                             hostname = base::Sys.info()[["nodename"]])
[08:27:38.458]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:38.458]                             info)
[08:27:38.458]                           info <- base::paste(info, collapse = "; ")
[08:27:38.458]                           if (!has_future) {
[08:27:38.458]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:38.458]                               info)
[08:27:38.458]                           }
[08:27:38.458]                           else {
[08:27:38.458]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:38.458]                               info, version)
[08:27:38.458]                           }
[08:27:38.458]                           base::stop(msg)
[08:27:38.458]                         }
[08:27:38.458]                       })
[08:27:38.458]                     }
[08:27:38.458]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:38.458]                     base::options(mc.cores = 1L)
[08:27:38.458]                   }
[08:27:38.458]                   ...future.strategy.old <- future::plan("list")
[08:27:38.458]                   options(future.plan = NULL)
[08:27:38.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:38.458]                 }
[08:27:38.458]                 ...future.workdir <- getwd()
[08:27:38.458]             }
[08:27:38.458]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:38.458]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:38.458]         }
[08:27:38.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:38.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:38.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:38.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:38.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:38.458]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:38.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:38.458]             base::names(...future.oldOptions))
[08:27:38.458]     }
[08:27:38.458]     if (FALSE) {
[08:27:38.458]     }
[08:27:38.458]     else {
[08:27:38.458]         if (TRUE) {
[08:27:38.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:38.458]                 open = "w")
[08:27:38.458]         }
[08:27:38.458]         else {
[08:27:38.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:38.458]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:38.458]         }
[08:27:38.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:38.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:38.458]             base::sink(type = "output", split = FALSE)
[08:27:38.458]             base::close(...future.stdout)
[08:27:38.458]         }, add = TRUE)
[08:27:38.458]     }
[08:27:38.458]     ...future.frame <- base::sys.nframe()
[08:27:38.458]     ...future.conditions <- base::list()
[08:27:38.458]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:38.458]     if (FALSE) {
[08:27:38.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:38.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:38.458]     }
[08:27:38.458]     ...future.result <- base::tryCatch({
[08:27:38.458]         base::withCallingHandlers({
[08:27:38.458]             ...future.value <- base::withVisible(base::local({
[08:27:38.458]                 ...future.makeSendCondition <- base::local({
[08:27:38.458]                   sendCondition <- NULL
[08:27:38.458]                   function(frame = 1L) {
[08:27:38.458]                     if (is.function(sendCondition)) 
[08:27:38.458]                       return(sendCondition)
[08:27:38.458]                     ns <- getNamespace("parallel")
[08:27:38.458]                     if (exists("sendData", mode = "function", 
[08:27:38.458]                       envir = ns)) {
[08:27:38.458]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:38.458]                         envir = ns)
[08:27:38.458]                       envir <- sys.frame(frame)
[08:27:38.458]                       master <- NULL
[08:27:38.458]                       while (!identical(envir, .GlobalEnv) && 
[08:27:38.458]                         !identical(envir, emptyenv())) {
[08:27:38.458]                         if (exists("master", mode = "list", envir = envir, 
[08:27:38.458]                           inherits = FALSE)) {
[08:27:38.458]                           master <- get("master", mode = "list", 
[08:27:38.458]                             envir = envir, inherits = FALSE)
[08:27:38.458]                           if (inherits(master, c("SOCKnode", 
[08:27:38.458]                             "SOCK0node"))) {
[08:27:38.458]                             sendCondition <<- function(cond) {
[08:27:38.458]                               data <- list(type = "VALUE", value = cond, 
[08:27:38.458]                                 success = TRUE)
[08:27:38.458]                               parallel_sendData(master, data)
[08:27:38.458]                             }
[08:27:38.458]                             return(sendCondition)
[08:27:38.458]                           }
[08:27:38.458]                         }
[08:27:38.458]                         frame <- frame + 1L
[08:27:38.458]                         envir <- sys.frame(frame)
[08:27:38.458]                       }
[08:27:38.458]                     }
[08:27:38.458]                     sendCondition <<- function(cond) NULL
[08:27:38.458]                   }
[08:27:38.458]                 })
[08:27:38.458]                 withCallingHandlers({
[08:27:38.458]                   42
[08:27:38.458]                 }, immediateCondition = function(cond) {
[08:27:38.458]                   sendCondition <- ...future.makeSendCondition()
[08:27:38.458]                   sendCondition(cond)
[08:27:38.458]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.458]                   {
[08:27:38.458]                     inherits <- base::inherits
[08:27:38.458]                     invokeRestart <- base::invokeRestart
[08:27:38.458]                     is.null <- base::is.null
[08:27:38.458]                     muffled <- FALSE
[08:27:38.458]                     if (inherits(cond, "message")) {
[08:27:38.458]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:38.458]                       if (muffled) 
[08:27:38.458]                         invokeRestart("muffleMessage")
[08:27:38.458]                     }
[08:27:38.458]                     else if (inherits(cond, "warning")) {
[08:27:38.458]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:38.458]                       if (muffled) 
[08:27:38.458]                         invokeRestart("muffleWarning")
[08:27:38.458]                     }
[08:27:38.458]                     else if (inherits(cond, "condition")) {
[08:27:38.458]                       if (!is.null(pattern)) {
[08:27:38.458]                         computeRestarts <- base::computeRestarts
[08:27:38.458]                         grepl <- base::grepl
[08:27:38.458]                         restarts <- computeRestarts(cond)
[08:27:38.458]                         for (restart in restarts) {
[08:27:38.458]                           name <- restart$name
[08:27:38.458]                           if (is.null(name)) 
[08:27:38.458]                             next
[08:27:38.458]                           if (!grepl(pattern, name)) 
[08:27:38.458]                             next
[08:27:38.458]                           invokeRestart(restart)
[08:27:38.458]                           muffled <- TRUE
[08:27:38.458]                           break
[08:27:38.458]                         }
[08:27:38.458]                       }
[08:27:38.458]                     }
[08:27:38.458]                     invisible(muffled)
[08:27:38.458]                   }
[08:27:38.458]                   muffleCondition(cond)
[08:27:38.458]                 })
[08:27:38.458]             }))
[08:27:38.458]             future::FutureResult(value = ...future.value$value, 
[08:27:38.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.458]                   ...future.rng), globalenv = if (FALSE) 
[08:27:38.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:38.458]                     ...future.globalenv.names))
[08:27:38.458]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:38.458]         }, condition = base::local({
[08:27:38.458]             c <- base::c
[08:27:38.458]             inherits <- base::inherits
[08:27:38.458]             invokeRestart <- base::invokeRestart
[08:27:38.458]             length <- base::length
[08:27:38.458]             list <- base::list
[08:27:38.458]             seq.int <- base::seq.int
[08:27:38.458]             signalCondition <- base::signalCondition
[08:27:38.458]             sys.calls <- base::sys.calls
[08:27:38.458]             `[[` <- base::`[[`
[08:27:38.458]             `+` <- base::`+`
[08:27:38.458]             `<<-` <- base::`<<-`
[08:27:38.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:38.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:38.458]                   3L)]
[08:27:38.458]             }
[08:27:38.458]             function(cond) {
[08:27:38.458]                 is_error <- inherits(cond, "error")
[08:27:38.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:38.458]                   NULL)
[08:27:38.458]                 if (is_error) {
[08:27:38.458]                   sessionInformation <- function() {
[08:27:38.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:38.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:38.458]                       search = base::search(), system = base::Sys.info())
[08:27:38.458]                   }
[08:27:38.458]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:38.458]                     cond$call), session = sessionInformation(), 
[08:27:38.458]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:38.458]                   signalCondition(cond)
[08:27:38.458]                 }
[08:27:38.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:38.458]                 "immediateCondition"))) {
[08:27:38.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:38.458]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:38.458]                   if (TRUE && !signal) {
[08:27:38.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.458]                     {
[08:27:38.458]                       inherits <- base::inherits
[08:27:38.458]                       invokeRestart <- base::invokeRestart
[08:27:38.458]                       is.null <- base::is.null
[08:27:38.458]                       muffled <- FALSE
[08:27:38.458]                       if (inherits(cond, "message")) {
[08:27:38.458]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.458]                         if (muffled) 
[08:27:38.458]                           invokeRestart("muffleMessage")
[08:27:38.458]                       }
[08:27:38.458]                       else if (inherits(cond, "warning")) {
[08:27:38.458]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.458]                         if (muffled) 
[08:27:38.458]                           invokeRestart("muffleWarning")
[08:27:38.458]                       }
[08:27:38.458]                       else if (inherits(cond, "condition")) {
[08:27:38.458]                         if (!is.null(pattern)) {
[08:27:38.458]                           computeRestarts <- base::computeRestarts
[08:27:38.458]                           grepl <- base::grepl
[08:27:38.458]                           restarts <- computeRestarts(cond)
[08:27:38.458]                           for (restart in restarts) {
[08:27:38.458]                             name <- restart$name
[08:27:38.458]                             if (is.null(name)) 
[08:27:38.458]                               next
[08:27:38.458]                             if (!grepl(pattern, name)) 
[08:27:38.458]                               next
[08:27:38.458]                             invokeRestart(restart)
[08:27:38.458]                             muffled <- TRUE
[08:27:38.458]                             break
[08:27:38.458]                           }
[08:27:38.458]                         }
[08:27:38.458]                       }
[08:27:38.458]                       invisible(muffled)
[08:27:38.458]                     }
[08:27:38.458]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.458]                   }
[08:27:38.458]                 }
[08:27:38.458]                 else {
[08:27:38.458]                   if (TRUE) {
[08:27:38.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.458]                     {
[08:27:38.458]                       inherits <- base::inherits
[08:27:38.458]                       invokeRestart <- base::invokeRestart
[08:27:38.458]                       is.null <- base::is.null
[08:27:38.458]                       muffled <- FALSE
[08:27:38.458]                       if (inherits(cond, "message")) {
[08:27:38.458]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.458]                         if (muffled) 
[08:27:38.458]                           invokeRestart("muffleMessage")
[08:27:38.458]                       }
[08:27:38.458]                       else if (inherits(cond, "warning")) {
[08:27:38.458]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.458]                         if (muffled) 
[08:27:38.458]                           invokeRestart("muffleWarning")
[08:27:38.458]                       }
[08:27:38.458]                       else if (inherits(cond, "condition")) {
[08:27:38.458]                         if (!is.null(pattern)) {
[08:27:38.458]                           computeRestarts <- base::computeRestarts
[08:27:38.458]                           grepl <- base::grepl
[08:27:38.458]                           restarts <- computeRestarts(cond)
[08:27:38.458]                           for (restart in restarts) {
[08:27:38.458]                             name <- restart$name
[08:27:38.458]                             if (is.null(name)) 
[08:27:38.458]                               next
[08:27:38.458]                             if (!grepl(pattern, name)) 
[08:27:38.458]                               next
[08:27:38.458]                             invokeRestart(restart)
[08:27:38.458]                             muffled <- TRUE
[08:27:38.458]                             break
[08:27:38.458]                           }
[08:27:38.458]                         }
[08:27:38.458]                       }
[08:27:38.458]                       invisible(muffled)
[08:27:38.458]                     }
[08:27:38.458]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.458]                   }
[08:27:38.458]                 }
[08:27:38.458]             }
[08:27:38.458]         }))
[08:27:38.458]     }, error = function(ex) {
[08:27:38.458]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:38.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.458]                 ...future.rng), started = ...future.startTime, 
[08:27:38.458]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:38.458]             version = "1.8"), class = "FutureResult")
[08:27:38.458]     }, finally = {
[08:27:38.458]         if (!identical(...future.workdir, getwd())) 
[08:27:38.458]             setwd(...future.workdir)
[08:27:38.458]         {
[08:27:38.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:38.458]                 ...future.oldOptions$nwarnings <- NULL
[08:27:38.458]             }
[08:27:38.458]             base::options(...future.oldOptions)
[08:27:38.458]             if (.Platform$OS.type == "windows") {
[08:27:38.458]                 old_names <- names(...future.oldEnvVars)
[08:27:38.458]                 envs <- base::Sys.getenv()
[08:27:38.458]                 names <- names(envs)
[08:27:38.458]                 common <- intersect(names, old_names)
[08:27:38.458]                 added <- setdiff(names, old_names)
[08:27:38.458]                 removed <- setdiff(old_names, names)
[08:27:38.458]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:38.458]                   envs[common]]
[08:27:38.458]                 NAMES <- toupper(changed)
[08:27:38.458]                 args <- list()
[08:27:38.458]                 for (kk in seq_along(NAMES)) {
[08:27:38.458]                   name <- changed[[kk]]
[08:27:38.458]                   NAME <- NAMES[[kk]]
[08:27:38.458]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.458]                     next
[08:27:38.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.458]                 }
[08:27:38.458]                 NAMES <- toupper(added)
[08:27:38.458]                 for (kk in seq_along(NAMES)) {
[08:27:38.458]                   name <- added[[kk]]
[08:27:38.458]                   NAME <- NAMES[[kk]]
[08:27:38.458]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.458]                     next
[08:27:38.458]                   args[[name]] <- ""
[08:27:38.458]                 }
[08:27:38.458]                 NAMES <- toupper(removed)
[08:27:38.458]                 for (kk in seq_along(NAMES)) {
[08:27:38.458]                   name <- removed[[kk]]
[08:27:38.458]                   NAME <- NAMES[[kk]]
[08:27:38.458]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.458]                     next
[08:27:38.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.458]                 }
[08:27:38.458]                 if (length(args) > 0) 
[08:27:38.458]                   base::do.call(base::Sys.setenv, args = args)
[08:27:38.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:38.458]             }
[08:27:38.458]             else {
[08:27:38.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:38.458]             }
[08:27:38.458]             {
[08:27:38.458]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:38.458]                   0L) {
[08:27:38.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:38.458]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:38.458]                   base::options(opts)
[08:27:38.458]                 }
[08:27:38.458]                 {
[08:27:38.458]                   {
[08:27:38.458]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:38.458]                     NULL
[08:27:38.458]                   }
[08:27:38.458]                   options(future.plan = NULL)
[08:27:38.458]                   if (is.na(NA_character_)) 
[08:27:38.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:38.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:38.458]                     .init = FALSE)
[08:27:38.458]                 }
[08:27:38.458]             }
[08:27:38.458]         }
[08:27:38.458]     })
[08:27:38.458]     if (TRUE) {
[08:27:38.458]         base::sink(type = "output", split = FALSE)
[08:27:38.458]         if (TRUE) {
[08:27:38.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:38.458]         }
[08:27:38.458]         else {
[08:27:38.458]             ...future.result["stdout"] <- base::list(NULL)
[08:27:38.458]         }
[08:27:38.458]         base::close(...future.stdout)
[08:27:38.458]         ...future.stdout <- NULL
[08:27:38.458]     }
[08:27:38.458]     ...future.result$conditions <- ...future.conditions
[08:27:38.458]     ...future.result$finished <- base::Sys.time()
[08:27:38.458]     ...future.result
[08:27:38.458] }
[08:27:38.461] MultisessionFuture started
[08:27:38.462] - Launch lazy future ... done
[08:27:38.462] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘strategy = multisession’
Expression:
[1] 42
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.473] result() for ClusterFuture ...
[08:27:38.473] receiveMessageFromWorker() for ClusterFuture ...
[08:27:38.473] - Validating connection of MultisessionFuture
[08:27:38.503] - received message: FutureResult
[08:27:38.503] - Received FutureResult
[08:27:38.504] - Erased future from FutureRegistry
[08:27:38.504] result() for ClusterFuture ...
[08:27:38.504] - result already collected: FutureResult
[08:27:38.504] result() for ClusterFuture ... done
[08:27:38.504] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:38.504] result() for ClusterFuture ... done
[08:27:38.504] result() for ClusterFuture ...
[08:27:38.504] - result already collected: FutureResult
[08:27:38.505] result() for ClusterFuture ... done
[08:27:38.505] getGlobalsAndPackages() ...
[08:27:38.505] Searching for globals...
[08:27:38.506] - globals found: [1] ‘{’
[08:27:38.506] Searching for globals ... DONE
[08:27:38.506] Resolving globals: FALSE
[08:27:38.507] 
[08:27:38.507] 
[08:27:38.507] getGlobalsAndPackages() ... DONE
[08:27:38.507] run() for ‘Future’ ...
[08:27:38.507] - state: ‘created’
[08:27:38.507] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:38.522] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:38.523]   - Field: ‘node’
[08:27:38.523]   - Field: ‘label’
[08:27:38.523]   - Field: ‘local’
[08:27:38.523]   - Field: ‘owner’
[08:27:38.523]   - Field: ‘envir’
[08:27:38.523]   - Field: ‘workers’
[08:27:38.523]   - Field: ‘packages’
[08:27:38.523]   - Field: ‘gc’
[08:27:38.523]   - Field: ‘conditions’
[08:27:38.523]   - Field: ‘persistent’
[08:27:38.524]   - Field: ‘expr’
[08:27:38.524]   - Field: ‘uuid’
[08:27:38.524]   - Field: ‘seed’
[08:27:38.524]   - Field: ‘version’
[08:27:38.524]   - Field: ‘result’
[08:27:38.524]   - Field: ‘asynchronous’
[08:27:38.524]   - Field: ‘calls’
[08:27:38.524]   - Field: ‘globals’
[08:27:38.525]   - Field: ‘stdout’
[08:27:38.525]   - Field: ‘earlySignal’
[08:27:38.525]   - Field: ‘lazy’
[08:27:38.525]   - Field: ‘state’
[08:27:38.525] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:38.525] - Launch lazy future ...
[08:27:38.525] Packages needed by the future expression (n = 0): <none>
[08:27:38.526] Packages needed by future strategies (n = 0): <none>
[08:27:38.526] {
[08:27:38.526]     {
[08:27:38.526]         {
[08:27:38.526]             ...future.startTime <- base::Sys.time()
[08:27:38.526]             {
[08:27:38.526]                 {
[08:27:38.526]                   {
[08:27:38.526]                     {
[08:27:38.526]                       base::local({
[08:27:38.526]                         has_future <- base::requireNamespace("future", 
[08:27:38.526]                           quietly = TRUE)
[08:27:38.526]                         if (has_future) {
[08:27:38.526]                           ns <- base::getNamespace("future")
[08:27:38.526]                           version <- ns[[".package"]][["version"]]
[08:27:38.526]                           if (is.null(version)) 
[08:27:38.526]                             version <- utils::packageVersion("future")
[08:27:38.526]                         }
[08:27:38.526]                         else {
[08:27:38.526]                           version <- NULL
[08:27:38.526]                         }
[08:27:38.526]                         if (!has_future || version < "1.8.0") {
[08:27:38.526]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:38.526]                             "", base::R.version$version.string), 
[08:27:38.526]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:38.526]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:38.526]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:38.526]                               "release", "version")], collapse = " "), 
[08:27:38.526]                             hostname = base::Sys.info()[["nodename"]])
[08:27:38.526]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:38.526]                             info)
[08:27:38.526]                           info <- base::paste(info, collapse = "; ")
[08:27:38.526]                           if (!has_future) {
[08:27:38.526]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:38.526]                               info)
[08:27:38.526]                           }
[08:27:38.526]                           else {
[08:27:38.526]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:38.526]                               info, version)
[08:27:38.526]                           }
[08:27:38.526]                           base::stop(msg)
[08:27:38.526]                         }
[08:27:38.526]                       })
[08:27:38.526]                     }
[08:27:38.526]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:38.526]                     base::options(mc.cores = 1L)
[08:27:38.526]                   }
[08:27:38.526]                   ...future.strategy.old <- future::plan("list")
[08:27:38.526]                   options(future.plan = NULL)
[08:27:38.526]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.526]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:38.526]                 }
[08:27:38.526]                 ...future.workdir <- getwd()
[08:27:38.526]             }
[08:27:38.526]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:38.526]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:38.526]         }
[08:27:38.526]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:38.526]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:38.526]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:38.526]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:38.526]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:38.526]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:38.526]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:38.526]             base::names(...future.oldOptions))
[08:27:38.526]     }
[08:27:38.526]     if (FALSE) {
[08:27:38.526]     }
[08:27:38.526]     else {
[08:27:38.526]         if (TRUE) {
[08:27:38.526]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:38.526]                 open = "w")
[08:27:38.526]         }
[08:27:38.526]         else {
[08:27:38.526]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:38.526]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:38.526]         }
[08:27:38.526]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:38.526]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:38.526]             base::sink(type = "output", split = FALSE)
[08:27:38.526]             base::close(...future.stdout)
[08:27:38.526]         }, add = TRUE)
[08:27:38.526]     }
[08:27:38.526]     ...future.frame <- base::sys.nframe()
[08:27:38.526]     ...future.conditions <- base::list()
[08:27:38.526]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:38.526]     if (FALSE) {
[08:27:38.526]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:38.526]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:38.526]     }
[08:27:38.526]     ...future.result <- base::tryCatch({
[08:27:38.526]         base::withCallingHandlers({
[08:27:38.526]             ...future.value <- base::withVisible(base::local({
[08:27:38.526]                 ...future.makeSendCondition <- base::local({
[08:27:38.526]                   sendCondition <- NULL
[08:27:38.526]                   function(frame = 1L) {
[08:27:38.526]                     if (is.function(sendCondition)) 
[08:27:38.526]                       return(sendCondition)
[08:27:38.526]                     ns <- getNamespace("parallel")
[08:27:38.526]                     if (exists("sendData", mode = "function", 
[08:27:38.526]                       envir = ns)) {
[08:27:38.526]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:38.526]                         envir = ns)
[08:27:38.526]                       envir <- sys.frame(frame)
[08:27:38.526]                       master <- NULL
[08:27:38.526]                       while (!identical(envir, .GlobalEnv) && 
[08:27:38.526]                         !identical(envir, emptyenv())) {
[08:27:38.526]                         if (exists("master", mode = "list", envir = envir, 
[08:27:38.526]                           inherits = FALSE)) {
[08:27:38.526]                           master <- get("master", mode = "list", 
[08:27:38.526]                             envir = envir, inherits = FALSE)
[08:27:38.526]                           if (inherits(master, c("SOCKnode", 
[08:27:38.526]                             "SOCK0node"))) {
[08:27:38.526]                             sendCondition <<- function(cond) {
[08:27:38.526]                               data <- list(type = "VALUE", value = cond, 
[08:27:38.526]                                 success = TRUE)
[08:27:38.526]                               parallel_sendData(master, data)
[08:27:38.526]                             }
[08:27:38.526]                             return(sendCondition)
[08:27:38.526]                           }
[08:27:38.526]                         }
[08:27:38.526]                         frame <- frame + 1L
[08:27:38.526]                         envir <- sys.frame(frame)
[08:27:38.526]                       }
[08:27:38.526]                     }
[08:27:38.526]                     sendCondition <<- function(cond) NULL
[08:27:38.526]                   }
[08:27:38.526]                 })
[08:27:38.526]                 withCallingHandlers({
[08:27:38.526]                   {
[08:27:38.526]                     42
[08:27:38.526]                   }
[08:27:38.526]                 }, immediateCondition = function(cond) {
[08:27:38.526]                   sendCondition <- ...future.makeSendCondition()
[08:27:38.526]                   sendCondition(cond)
[08:27:38.526]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.526]                   {
[08:27:38.526]                     inherits <- base::inherits
[08:27:38.526]                     invokeRestart <- base::invokeRestart
[08:27:38.526]                     is.null <- base::is.null
[08:27:38.526]                     muffled <- FALSE
[08:27:38.526]                     if (inherits(cond, "message")) {
[08:27:38.526]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:38.526]                       if (muffled) 
[08:27:38.526]                         invokeRestart("muffleMessage")
[08:27:38.526]                     }
[08:27:38.526]                     else if (inherits(cond, "warning")) {
[08:27:38.526]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:38.526]                       if (muffled) 
[08:27:38.526]                         invokeRestart("muffleWarning")
[08:27:38.526]                     }
[08:27:38.526]                     else if (inherits(cond, "condition")) {
[08:27:38.526]                       if (!is.null(pattern)) {
[08:27:38.526]                         computeRestarts <- base::computeRestarts
[08:27:38.526]                         grepl <- base::grepl
[08:27:38.526]                         restarts <- computeRestarts(cond)
[08:27:38.526]                         for (restart in restarts) {
[08:27:38.526]                           name <- restart$name
[08:27:38.526]                           if (is.null(name)) 
[08:27:38.526]                             next
[08:27:38.526]                           if (!grepl(pattern, name)) 
[08:27:38.526]                             next
[08:27:38.526]                           invokeRestart(restart)
[08:27:38.526]                           muffled <- TRUE
[08:27:38.526]                           break
[08:27:38.526]                         }
[08:27:38.526]                       }
[08:27:38.526]                     }
[08:27:38.526]                     invisible(muffled)
[08:27:38.526]                   }
[08:27:38.526]                   muffleCondition(cond)
[08:27:38.526]                 })
[08:27:38.526]             }))
[08:27:38.526]             future::FutureResult(value = ...future.value$value, 
[08:27:38.526]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.526]                   ...future.rng), globalenv = if (FALSE) 
[08:27:38.526]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:38.526]                     ...future.globalenv.names))
[08:27:38.526]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:38.526]         }, condition = base::local({
[08:27:38.526]             c <- base::c
[08:27:38.526]             inherits <- base::inherits
[08:27:38.526]             invokeRestart <- base::invokeRestart
[08:27:38.526]             length <- base::length
[08:27:38.526]             list <- base::list
[08:27:38.526]             seq.int <- base::seq.int
[08:27:38.526]             signalCondition <- base::signalCondition
[08:27:38.526]             sys.calls <- base::sys.calls
[08:27:38.526]             `[[` <- base::`[[`
[08:27:38.526]             `+` <- base::`+`
[08:27:38.526]             `<<-` <- base::`<<-`
[08:27:38.526]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:38.526]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:38.526]                   3L)]
[08:27:38.526]             }
[08:27:38.526]             function(cond) {
[08:27:38.526]                 is_error <- inherits(cond, "error")
[08:27:38.526]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:38.526]                   NULL)
[08:27:38.526]                 if (is_error) {
[08:27:38.526]                   sessionInformation <- function() {
[08:27:38.526]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:38.526]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:38.526]                       search = base::search(), system = base::Sys.info())
[08:27:38.526]                   }
[08:27:38.526]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.526]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:38.526]                     cond$call), session = sessionInformation(), 
[08:27:38.526]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:38.526]                   signalCondition(cond)
[08:27:38.526]                 }
[08:27:38.526]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:38.526]                 "immediateCondition"))) {
[08:27:38.526]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:38.526]                   ...future.conditions[[length(...future.conditions) + 
[08:27:38.526]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:38.526]                   if (TRUE && !signal) {
[08:27:38.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.526]                     {
[08:27:38.526]                       inherits <- base::inherits
[08:27:38.526]                       invokeRestart <- base::invokeRestart
[08:27:38.526]                       is.null <- base::is.null
[08:27:38.526]                       muffled <- FALSE
[08:27:38.526]                       if (inherits(cond, "message")) {
[08:27:38.526]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.526]                         if (muffled) 
[08:27:38.526]                           invokeRestart("muffleMessage")
[08:27:38.526]                       }
[08:27:38.526]                       else if (inherits(cond, "warning")) {
[08:27:38.526]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.526]                         if (muffled) 
[08:27:38.526]                           invokeRestart("muffleWarning")
[08:27:38.526]                       }
[08:27:38.526]                       else if (inherits(cond, "condition")) {
[08:27:38.526]                         if (!is.null(pattern)) {
[08:27:38.526]                           computeRestarts <- base::computeRestarts
[08:27:38.526]                           grepl <- base::grepl
[08:27:38.526]                           restarts <- computeRestarts(cond)
[08:27:38.526]                           for (restart in restarts) {
[08:27:38.526]                             name <- restart$name
[08:27:38.526]                             if (is.null(name)) 
[08:27:38.526]                               next
[08:27:38.526]                             if (!grepl(pattern, name)) 
[08:27:38.526]                               next
[08:27:38.526]                             invokeRestart(restart)
[08:27:38.526]                             muffled <- TRUE
[08:27:38.526]                             break
[08:27:38.526]                           }
[08:27:38.526]                         }
[08:27:38.526]                       }
[08:27:38.526]                       invisible(muffled)
[08:27:38.526]                     }
[08:27:38.526]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.526]                   }
[08:27:38.526]                 }
[08:27:38.526]                 else {
[08:27:38.526]                   if (TRUE) {
[08:27:38.526]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:38.526]                     {
[08:27:38.526]                       inherits <- base::inherits
[08:27:38.526]                       invokeRestart <- base::invokeRestart
[08:27:38.526]                       is.null <- base::is.null
[08:27:38.526]                       muffled <- FALSE
[08:27:38.526]                       if (inherits(cond, "message")) {
[08:27:38.526]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:38.526]                         if (muffled) 
[08:27:38.526]                           invokeRestart("muffleMessage")
[08:27:38.526]                       }
[08:27:38.526]                       else if (inherits(cond, "warning")) {
[08:27:38.526]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:38.526]                         if (muffled) 
[08:27:38.526]                           invokeRestart("muffleWarning")
[08:27:38.526]                       }
[08:27:38.526]                       else if (inherits(cond, "condition")) {
[08:27:38.526]                         if (!is.null(pattern)) {
[08:27:38.526]                           computeRestarts <- base::computeRestarts
[08:27:38.526]                           grepl <- base::grepl
[08:27:38.526]                           restarts <- computeRestarts(cond)
[08:27:38.526]                           for (restart in restarts) {
[08:27:38.526]                             name <- restart$name
[08:27:38.526]                             if (is.null(name)) 
[08:27:38.526]                               next
[08:27:38.526]                             if (!grepl(pattern, name)) 
[08:27:38.526]                               next
[08:27:38.526]                             invokeRestart(restart)
[08:27:38.526]                             muffled <- TRUE
[08:27:38.526]                             break
[08:27:38.526]                           }
[08:27:38.526]                         }
[08:27:38.526]                       }
[08:27:38.526]                       invisible(muffled)
[08:27:38.526]                     }
[08:27:38.526]                     muffleCondition(cond, pattern = "^muffle")
[08:27:38.526]                   }
[08:27:38.526]                 }
[08:27:38.526]             }
[08:27:38.526]         }))
[08:27:38.526]     }, error = function(ex) {
[08:27:38.526]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:38.526]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:38.526]                 ...future.rng), started = ...future.startTime, 
[08:27:38.526]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:38.526]             version = "1.8"), class = "FutureResult")
[08:27:38.526]     }, finally = {
[08:27:38.526]         if (!identical(...future.workdir, getwd())) 
[08:27:38.526]             setwd(...future.workdir)
[08:27:38.526]         {
[08:27:38.526]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:38.526]                 ...future.oldOptions$nwarnings <- NULL
[08:27:38.526]             }
[08:27:38.526]             base::options(...future.oldOptions)
[08:27:38.526]             if (.Platform$OS.type == "windows") {
[08:27:38.526]                 old_names <- names(...future.oldEnvVars)
[08:27:38.526]                 envs <- base::Sys.getenv()
[08:27:38.526]                 names <- names(envs)
[08:27:38.526]                 common <- intersect(names, old_names)
[08:27:38.526]                 added <- setdiff(names, old_names)
[08:27:38.526]                 removed <- setdiff(old_names, names)
[08:27:38.526]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:38.526]                   envs[common]]
[08:27:38.526]                 NAMES <- toupper(changed)
[08:27:38.526]                 args <- list()
[08:27:38.526]                 for (kk in seq_along(NAMES)) {
[08:27:38.526]                   name <- changed[[kk]]
[08:27:38.526]                   NAME <- NAMES[[kk]]
[08:27:38.526]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.526]                     next
[08:27:38.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.526]                 }
[08:27:38.526]                 NAMES <- toupper(added)
[08:27:38.526]                 for (kk in seq_along(NAMES)) {
[08:27:38.526]                   name <- added[[kk]]
[08:27:38.526]                   NAME <- NAMES[[kk]]
[08:27:38.526]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.526]                     next
[08:27:38.526]                   args[[name]] <- ""
[08:27:38.526]                 }
[08:27:38.526]                 NAMES <- toupper(removed)
[08:27:38.526]                 for (kk in seq_along(NAMES)) {
[08:27:38.526]                   name <- removed[[kk]]
[08:27:38.526]                   NAME <- NAMES[[kk]]
[08:27:38.526]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:38.526]                     next
[08:27:38.526]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:38.526]                 }
[08:27:38.526]                 if (length(args) > 0) 
[08:27:38.526]                   base::do.call(base::Sys.setenv, args = args)
[08:27:38.526]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:38.526]             }
[08:27:38.526]             else {
[08:27:38.526]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:38.526]             }
[08:27:38.526]             {
[08:27:38.526]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:38.526]                   0L) {
[08:27:38.526]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:38.526]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:38.526]                   base::options(opts)
[08:27:38.526]                 }
[08:27:38.526]                 {
[08:27:38.526]                   {
[08:27:38.526]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:38.526]                     NULL
[08:27:38.526]                   }
[08:27:38.526]                   options(future.plan = NULL)
[08:27:38.526]                   if (is.na(NA_character_)) 
[08:27:38.526]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:38.526]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:38.526]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:38.526]                     .init = FALSE)
[08:27:38.526]                 }
[08:27:38.526]             }
[08:27:38.526]         }
[08:27:38.526]     })
[08:27:38.526]     if (TRUE) {
[08:27:38.526]         base::sink(type = "output", split = FALSE)
[08:27:38.526]         if (TRUE) {
[08:27:38.526]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:38.526]         }
[08:27:38.526]         else {
[08:27:38.526]             ...future.result["stdout"] <- base::list(NULL)
[08:27:38.526]         }
[08:27:38.526]         base::close(...future.stdout)
[08:27:38.526]         ...future.stdout <- NULL
[08:27:38.526]     }
[08:27:38.526]     ...future.result$conditions <- ...future.conditions
[08:27:38.526]     ...future.result$finished <- base::Sys.time()
[08:27:38.526]     ...future.result
[08:27:38.526] }
[08:27:38.530] MultisessionFuture started
[08:27:38.530] - Launch lazy future ... done
[08:27:38.530] run() for ‘MultisessionFuture’ ... done
MultisessionFuture:
Label: ‘strategy = multisession’
Expression:
{
    42
}
Lazy evaluation: FALSE
Asynchronous evaluation: TRUE
Local evaluation: TRUE
Environment: R_GlobalEnv
Capture standard output: TRUE
Capture condition classes: ‘condition’ (excluding ‘nothing’)
Globals: <none>
Packages: <none>
L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
Resolved: FALSE
Value: <not collected>
Conditions captured: <none>
Early signaling: FALSE
Owner process: d53fcf5c-3679-679d-f904-e4436b85b904
Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:38.542] result() for ClusterFuture ...
[08:27:38.542] receiveMessageFromWorker() for ClusterFuture ...
[08:27:38.542] - Validating connection of MultisessionFuture
[08:27:38.572] - received message: FutureResult
[08:27:38.573] - Received FutureResult
[08:27:38.573] - Erased future from FutureRegistry
[08:27:38.573] result() for ClusterFuture ...
[08:27:38.573] - result already collected: FutureResult
[08:27:38.573] result() for ClusterFuture ... done
[08:27:38.573] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:38.574] result() for ClusterFuture ... done
[08:27:38.574] result() for ClusterFuture ...
[08:27:38.574] - result already collected: FutureResult
[08:27:38.574] result() for ClusterFuture ... done
- plan('multisession') ... DONE
> 
> message("*** Futures - labels ... DONE")
*** Futures - labels ... DONE
> 
> source("incl/end.R")
[08:27:38.575] plan(): Setting new future strategy stack:
[08:27:38.575] List of future strategies:
[08:27:38.575] 1. FutureStrategy:
[08:27:38.575]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:38.575]    - tweaked: FALSE
[08:27:38.575]    - call: future::plan(oplan)
[08:27:38.576] plan(): nbrOfWorkers() = 1
> 
