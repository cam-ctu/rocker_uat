
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:03:24.894] plan(): Setting new future strategy stack:
[11:03:24.894] List of future strategies:
[11:03:24.894] 1. sequential:
[11:03:24.894]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:24.894]    - tweaked: FALSE
[11:03:24.894]    - call: future::plan("sequential")
[11:03:24.907] plan(): nbrOfWorkers() = 1
> 
> message("*** Standard output ...")
*** Standard output ...
> 
> truth_rows <- utils::capture.output({
+   print(1:50)
+   str(1:50)
+   cat(letters, sep = "-")
+   cat(1:6, collapse = "\n")
+   write.table(datasets::iris[1:10,], sep = "\t")
+ })
> truth <- paste0(paste(truth_rows, collapse = "\n"), "\n")
> print(truth)
[1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\na-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 \n\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\"\n\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\"\n\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\"\n\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\"\n\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\"\n\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\"\n\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\"\n\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\"\n\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\"\n\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\"\n\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\"\n"
> 
> for (cores in seq_len(min(2L, availCores))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("%s ...", strategy))
+     plan(strategy)
+ 
+     for (stdout in c(TRUE, FALSE, NA)) {
+       message(sprintf("- stdout = %s", stdout))
+ 
+       f <- future({
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       }, stdout = stdout)
+       r <- result(f)
+       str(r)
+       stopifnot(value(f) == 42L)
+       if (is.na(stdout)) {
+         stopifnot(is.null(r$stdout) || r$stdout == "")
+       } else if (stdout) {
+         print(r)
+         stopifnot(identical(r$stdout, truth))
+       } else {
+         stopifnot(is.null(r$stdout))
+       }
+ 
+       v %<-% {
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       } %stdout% stdout
+       out <- utils::capture.output(y <- v)
+       stopifnot(y == 42L)
+       if (is.na(stdout)) {
+         ## Single-core multisession => sequential
+         if (cores > 1L || strategy != "multisession") {
+           stopifnot(out == "")
+         }
+       } else if (stdout) {
+         print(out)
+         stopifnot(identical(out, truth_rows))
+       } else {
+         stopifnot(out == "")
+       }
+ 
+       message("- stdout = structure(TRUE, drop = TRUE)")
+       f <- future(print(42), stdout = structure(TRUE, drop = TRUE))
+       r <- result(f)
+       stopifnot(inherits(r$stdout, "character"))
+       v <- value(f)
+       r <- result(f)
+       stopifnot(is.null(r$stdout))
+     } ## for (stdout ...)
+ 
+     message(sprintf("%s ... done", strategy))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... done", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
sequential ...
[11:03:24.957] plan(): Setting new future strategy stack:
[11:03:24.957] List of future strategies:
[11:03:24.957] 1. sequential:
[11:03:24.957]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:24.957]    - tweaked: FALSE
[11:03:24.957]    - call: plan(strategy)
[11:03:24.968] plan(): nbrOfWorkers() = 1
- stdout = TRUE
[11:03:24.968] getGlobalsAndPackages() ...
[11:03:24.968] Searching for globals...
[11:03:24.977] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:24.977] Searching for globals ... DONE
[11:03:24.977] Resolving globals: FALSE
[11:03:24.978] 
[11:03:24.978] - packages: [1] ‘utils’
[11:03:24.978] getGlobalsAndPackages() ... DONE
[11:03:24.979] run() for ‘Future’ ...
[11:03:24.979] - state: ‘created’
[11:03:24.979] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:03:24.979] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:03:24.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:03:24.979]   - Field: ‘label’
[11:03:24.979]   - Field: ‘local’
[11:03:24.980]   - Field: ‘owner’
[11:03:24.980]   - Field: ‘envir’
[11:03:24.980]   - Field: ‘packages’
[11:03:24.980]   - Field: ‘gc’
[11:03:24.980]   - Field: ‘conditions’
[11:03:24.980]   - Field: ‘expr’
[11:03:24.980]   - Field: ‘uuid’
[11:03:24.980]   - Field: ‘seed’
[11:03:24.980]   - Field: ‘version’
[11:03:24.980]   - Field: ‘result’
[11:03:24.980]   - Field: ‘asynchronous’
[11:03:24.980]   - Field: ‘calls’
[11:03:24.981]   - Field: ‘globals’
[11:03:24.981]   - Field: ‘stdout’
[11:03:24.981]   - Field: ‘earlySignal’
[11:03:24.981]   - Field: ‘lazy’
[11:03:24.981]   - Field: ‘state’
[11:03:24.981] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:03:24.981] - Launch lazy future ...
[11:03:24.982] Packages needed by the future expression (n = 1): ‘utils’
[11:03:24.982] Packages needed by future strategies (n = 0): <none>
[11:03:24.982] {
[11:03:24.982]     {
[11:03:24.982]         {
[11:03:24.982]             ...future.startTime <- base::Sys.time()
[11:03:24.982]             {
[11:03:24.982]                 {
[11:03:24.982]                   {
[11:03:24.982]                     {
[11:03:24.982]                       base::local({
[11:03:24.982]                         has_future <- base::requireNamespace("future", 
[11:03:24.982]                           quietly = TRUE)
[11:03:24.982]                         if (has_future) {
[11:03:24.982]                           ns <- base::getNamespace("future")
[11:03:24.982]                           version <- ns[[".package"]][["version"]]
[11:03:24.982]                           if (is.null(version)) 
[11:03:24.982]                             version <- utils::packageVersion("future")
[11:03:24.982]                         }
[11:03:24.982]                         else {
[11:03:24.982]                           version <- NULL
[11:03:24.982]                         }
[11:03:24.982]                         if (!has_future || version < "1.8.0") {
[11:03:24.982]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:24.982]                             "", base::R.version$version.string), 
[11:03:24.982]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:24.982]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:24.982]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:24.982]                               "release", "version")], collapse = " "), 
[11:03:24.982]                             hostname = base::Sys.info()[["nodename"]])
[11:03:24.982]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:24.982]                             info)
[11:03:24.982]                           info <- base::paste(info, collapse = "; ")
[11:03:24.982]                           if (!has_future) {
[11:03:24.982]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:24.982]                               info)
[11:03:24.982]                           }
[11:03:24.982]                           else {
[11:03:24.982]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:24.982]                               info, version)
[11:03:24.982]                           }
[11:03:24.982]                           base::stop(msg)
[11:03:24.982]                         }
[11:03:24.982]                       })
[11:03:24.982]                     }
[11:03:24.982]                     base::local({
[11:03:24.982]                       for (pkg in "utils") {
[11:03:24.982]                         base::loadNamespace(pkg)
[11:03:24.982]                         base::library(pkg, character.only = TRUE)
[11:03:24.982]                       }
[11:03:24.982]                     })
[11:03:24.982]                   }
[11:03:24.982]                   ...future.strategy.old <- future::plan("list")
[11:03:24.982]                   options(future.plan = NULL)
[11:03:24.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:24.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:24.982]                 }
[11:03:24.982]                 ...future.workdir <- getwd()
[11:03:24.982]             }
[11:03:24.982]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:24.982]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:24.982]         }
[11:03:24.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:24.982]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:24.982]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:24.982]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:24.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:24.982]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:24.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:24.982]             base::names(...future.oldOptions))
[11:03:24.982]     }
[11:03:24.982]     if (FALSE) {
[11:03:24.982]     }
[11:03:24.982]     else {
[11:03:24.982]         if (TRUE) {
[11:03:24.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:24.982]                 open = "w")
[11:03:24.982]         }
[11:03:24.982]         else {
[11:03:24.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:24.982]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:24.982]         }
[11:03:24.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:24.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:24.982]             base::sink(type = "output", split = FALSE)
[11:03:24.982]             base::close(...future.stdout)
[11:03:24.982]         }, add = TRUE)
[11:03:24.982]     }
[11:03:24.982]     ...future.frame <- base::sys.nframe()
[11:03:24.982]     ...future.conditions <- base::list()
[11:03:24.982]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:24.982]     if (FALSE) {
[11:03:24.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:24.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:24.982]     }
[11:03:24.982]     ...future.result <- base::tryCatch({
[11:03:24.982]         base::withCallingHandlers({
[11:03:24.982]             ...future.value <- base::withVisible(base::local({
[11:03:24.982]                 print(1:50)
[11:03:24.982]                 str(1:50)
[11:03:24.982]                 cat(letters, sep = "-")
[11:03:24.982]                 cat(1:6, collapse = "\n")
[11:03:24.982]                 write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:24.982]                 42L
[11:03:24.982]             }))
[11:03:24.982]             future::FutureResult(value = ...future.value$value, 
[11:03:24.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:24.982]                   ...future.rng), globalenv = if (FALSE) 
[11:03:24.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:24.982]                     ...future.globalenv.names))
[11:03:24.982]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:24.982]         }, condition = base::local({
[11:03:24.982]             c <- base::c
[11:03:24.982]             inherits <- base::inherits
[11:03:24.982]             invokeRestart <- base::invokeRestart
[11:03:24.982]             length <- base::length
[11:03:24.982]             list <- base::list
[11:03:24.982]             seq.int <- base::seq.int
[11:03:24.982]             signalCondition <- base::signalCondition
[11:03:24.982]             sys.calls <- base::sys.calls
[11:03:24.982]             `[[` <- base::`[[`
[11:03:24.982]             `+` <- base::`+`
[11:03:24.982]             `<<-` <- base::`<<-`
[11:03:24.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:24.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:24.982]                   3L)]
[11:03:24.982]             }
[11:03:24.982]             function(cond) {
[11:03:24.982]                 is_error <- inherits(cond, "error")
[11:03:24.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:24.982]                   NULL)
[11:03:24.982]                 if (is_error) {
[11:03:24.982]                   sessionInformation <- function() {
[11:03:24.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:24.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:24.982]                       search = base::search(), system = base::Sys.info())
[11:03:24.982]                   }
[11:03:24.982]                   ...future.conditions[[length(...future.conditions) + 
[11:03:24.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:24.982]                     cond$call), session = sessionInformation(), 
[11:03:24.982]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:24.982]                   signalCondition(cond)
[11:03:24.982]                 }
[11:03:24.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:24.982]                 "immediateCondition"))) {
[11:03:24.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:24.982]                   ...future.conditions[[length(...future.conditions) + 
[11:03:24.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:24.982]                   if (TRUE && !signal) {
[11:03:24.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:24.982]                     {
[11:03:24.982]                       inherits <- base::inherits
[11:03:24.982]                       invokeRestart <- base::invokeRestart
[11:03:24.982]                       is.null <- base::is.null
[11:03:24.982]                       muffled <- FALSE
[11:03:24.982]                       if (inherits(cond, "message")) {
[11:03:24.982]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:24.982]                         if (muffled) 
[11:03:24.982]                           invokeRestart("muffleMessage")
[11:03:24.982]                       }
[11:03:24.982]                       else if (inherits(cond, "warning")) {
[11:03:24.982]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:24.982]                         if (muffled) 
[11:03:24.982]                           invokeRestart("muffleWarning")
[11:03:24.982]                       }
[11:03:24.982]                       else if (inherits(cond, "condition")) {
[11:03:24.982]                         if (!is.null(pattern)) {
[11:03:24.982]                           computeRestarts <- base::computeRestarts
[11:03:24.982]                           grepl <- base::grepl
[11:03:24.982]                           restarts <- computeRestarts(cond)
[11:03:24.982]                           for (restart in restarts) {
[11:03:24.982]                             name <- restart$name
[11:03:24.982]                             if (is.null(name)) 
[11:03:24.982]                               next
[11:03:24.982]                             if (!grepl(pattern, name)) 
[11:03:24.982]                               next
[11:03:24.982]                             invokeRestart(restart)
[11:03:24.982]                             muffled <- TRUE
[11:03:24.982]                             break
[11:03:24.982]                           }
[11:03:24.982]                         }
[11:03:24.982]                       }
[11:03:24.982]                       invisible(muffled)
[11:03:24.982]                     }
[11:03:24.982]                     muffleCondition(cond, pattern = "^muffle")
[11:03:24.982]                   }
[11:03:24.982]                 }
[11:03:24.982]                 else {
[11:03:24.982]                   if (TRUE) {
[11:03:24.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:24.982]                     {
[11:03:24.982]                       inherits <- base::inherits
[11:03:24.982]                       invokeRestart <- base::invokeRestart
[11:03:24.982]                       is.null <- base::is.null
[11:03:24.982]                       muffled <- FALSE
[11:03:24.982]                       if (inherits(cond, "message")) {
[11:03:24.982]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:24.982]                         if (muffled) 
[11:03:24.982]                           invokeRestart("muffleMessage")
[11:03:24.982]                       }
[11:03:24.982]                       else if (inherits(cond, "warning")) {
[11:03:24.982]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:24.982]                         if (muffled) 
[11:03:24.982]                           invokeRestart("muffleWarning")
[11:03:24.982]                       }
[11:03:24.982]                       else if (inherits(cond, "condition")) {
[11:03:24.982]                         if (!is.null(pattern)) {
[11:03:24.982]                           computeRestarts <- base::computeRestarts
[11:03:24.982]                           grepl <- base::grepl
[11:03:24.982]                           restarts <- computeRestarts(cond)
[11:03:24.982]                           for (restart in restarts) {
[11:03:24.982]                             name <- restart$name
[11:03:24.982]                             if (is.null(name)) 
[11:03:24.982]                               next
[11:03:24.982]                             if (!grepl(pattern, name)) 
[11:03:24.982]                               next
[11:03:24.982]                             invokeRestart(restart)
[11:03:24.982]                             muffled <- TRUE
[11:03:24.982]                             break
[11:03:24.982]                           }
[11:03:24.982]                         }
[11:03:24.982]                       }
[11:03:24.982]                       invisible(muffled)
[11:03:24.982]                     }
[11:03:24.982]                     muffleCondition(cond, pattern = "^muffle")
[11:03:24.982]                   }
[11:03:24.982]                 }
[11:03:24.982]             }
[11:03:24.982]         }))
[11:03:24.982]     }, error = function(ex) {
[11:03:24.982]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:24.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:24.982]                 ...future.rng), started = ...future.startTime, 
[11:03:24.982]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:24.982]             version = "1.8"), class = "FutureResult")
[11:03:24.982]     }, finally = {
[11:03:24.982]         if (!identical(...future.workdir, getwd())) 
[11:03:24.982]             setwd(...future.workdir)
[11:03:24.982]         {
[11:03:24.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:24.982]                 ...future.oldOptions$nwarnings <- NULL
[11:03:24.982]             }
[11:03:24.982]             base::options(...future.oldOptions)
[11:03:24.982]             if (.Platform$OS.type == "windows") {
[11:03:24.982]                 old_names <- names(...future.oldEnvVars)
[11:03:24.982]                 envs <- base::Sys.getenv()
[11:03:24.982]                 names <- names(envs)
[11:03:24.982]                 common <- intersect(names, old_names)
[11:03:24.982]                 added <- setdiff(names, old_names)
[11:03:24.982]                 removed <- setdiff(old_names, names)
[11:03:24.982]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:24.982]                   envs[common]]
[11:03:24.982]                 NAMES <- toupper(changed)
[11:03:24.982]                 args <- list()
[11:03:24.982]                 for (kk in seq_along(NAMES)) {
[11:03:24.982]                   name <- changed[[kk]]
[11:03:24.982]                   NAME <- NAMES[[kk]]
[11:03:24.982]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:24.982]                     next
[11:03:24.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:24.982]                 }
[11:03:24.982]                 NAMES <- toupper(added)
[11:03:24.982]                 for (kk in seq_along(NAMES)) {
[11:03:24.982]                   name <- added[[kk]]
[11:03:24.982]                   NAME <- NAMES[[kk]]
[11:03:24.982]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:24.982]                     next
[11:03:24.982]                   args[[name]] <- ""
[11:03:24.982]                 }
[11:03:24.982]                 NAMES <- toupper(removed)
[11:03:24.982]                 for (kk in seq_along(NAMES)) {
[11:03:24.982]                   name <- removed[[kk]]
[11:03:24.982]                   NAME <- NAMES[[kk]]
[11:03:24.982]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:24.982]                     next
[11:03:24.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:24.982]                 }
[11:03:24.982]                 if (length(args) > 0) 
[11:03:24.982]                   base::do.call(base::Sys.setenv, args = args)
[11:03:24.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:24.982]             }
[11:03:24.982]             else {
[11:03:24.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:24.982]             }
[11:03:24.982]             {
[11:03:24.982]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:24.982]                   0L) {
[11:03:24.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:24.982]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:24.982]                   base::options(opts)
[11:03:24.982]                 }
[11:03:24.982]                 {
[11:03:24.982]                   {
[11:03:24.982]                     NULL
[11:03:24.982]                     RNGkind("Mersenne-Twister")
[11:03:24.982]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:03:24.982]                       inherits = FALSE)
[11:03:24.982]                   }
[11:03:24.982]                   options(future.plan = NULL)
[11:03:24.982]                   if (is.na(NA_character_)) 
[11:03:24.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:24.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:24.982]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:24.982]                     .init = FALSE)
[11:03:24.982]                 }
[11:03:24.982]             }
[11:03:24.982]         }
[11:03:24.982]     })
[11:03:24.982]     if (TRUE) {
[11:03:24.982]         base::sink(type = "output", split = FALSE)
[11:03:24.982]         if (TRUE) {
[11:03:24.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:24.982]         }
[11:03:24.982]         else {
[11:03:24.982]             ...future.result["stdout"] <- base::list(NULL)
[11:03:24.982]         }
[11:03:24.982]         base::close(...future.stdout)
[11:03:24.982]         ...future.stdout <- NULL
[11:03:24.982]     }
[11:03:24.982]     ...future.result$conditions <- ...future.conditions
[11:03:24.982]     ...future.result$finished <- base::Sys.time()
[11:03:24.982]     ...future.result
[11:03:24.982] }
[11:03:24.985] plan(): Setting new future strategy stack:
[11:03:24.985] List of future strategies:
[11:03:24.985] 1. sequential:
[11:03:24.985]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:24.985]    - tweaked: FALSE
[11:03:24.985]    - call: NULL
[11:03:24.985] plan(): nbrOfWorkers() = 1
[11:03:24.987] plan(): Setting new future strategy stack:
[11:03:24.987] List of future strategies:
[11:03:24.987] 1. sequential:
[11:03:24.987]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:24.987]    - tweaked: FALSE
[11:03:24.987]    - call: plan(strategy)
[11:03:24.987] plan(): nbrOfWorkers() = 1
[11:03:24.987] SequentialFuture started (and completed)
[11:03:24.988] - Launch lazy future ... done
[11:03:24.988] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-05-06 11:03:24"
 $ finished    : POSIXct[1:1], format: "2025-05-06 11:03:24"
 $ session_uuid: chr "861151cf-a595-47bd-b6ac-be12af3eb978"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "173ee284ba16"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 84989
  .. ..$ time  : POSIXct[1:1], format: "2025-05-06 11:03:24"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.003110409 secs (started 2025-05-06 11:03:24.984725)
version: 1.8
[11:03:24.996] getGlobalsAndPackages() ...
[11:03:24.997] Searching for globals...
[11:03:25.001] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.001] Searching for globals ... DONE
[11:03:25.001] Resolving globals: FALSE
[11:03:25.001] 
[11:03:25.001] - packages: [1] ‘utils’
[11:03:25.002] getGlobalsAndPackages() ... DONE
[11:03:25.002] run() for ‘Future’ ...
[11:03:25.002] - state: ‘created’
[11:03:25.002] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:03:25.002] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:03:25.002] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:03:25.002]   - Field: ‘label’
[11:03:25.003]   - Field: ‘local’
[11:03:25.003]   - Field: ‘owner’
[11:03:25.003]   - Field: ‘envir’
[11:03:25.003]   - Field: ‘packages’
[11:03:25.003]   - Field: ‘gc’
[11:03:25.003]   - Field: ‘conditions’
[11:03:25.003]   - Field: ‘expr’
[11:03:25.003]   - Field: ‘uuid’
[11:03:25.003]   - Field: ‘seed’
[11:03:25.003]   - Field: ‘version’
[11:03:25.003]   - Field: ‘result’
[11:03:25.003]   - Field: ‘asynchronous’
[11:03:25.003]   - Field: ‘calls’
[11:03:25.004]   - Field: ‘globals’
[11:03:25.004]   - Field: ‘stdout’
[11:03:25.004]   - Field: ‘earlySignal’
[11:03:25.004]   - Field: ‘lazy’
[11:03:25.004]   - Field: ‘state’
[11:03:25.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:03:25.004] - Launch lazy future ...
[11:03:25.004] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.004] Packages needed by future strategies (n = 0): <none>
[11:03:25.005] {
[11:03:25.005]     {
[11:03:25.005]         {
[11:03:25.005]             ...future.startTime <- base::Sys.time()
[11:03:25.005]             {
[11:03:25.005]                 {
[11:03:25.005]                   {
[11:03:25.005]                     {
[11:03:25.005]                       base::local({
[11:03:25.005]                         has_future <- base::requireNamespace("future", 
[11:03:25.005]                           quietly = TRUE)
[11:03:25.005]                         if (has_future) {
[11:03:25.005]                           ns <- base::getNamespace("future")
[11:03:25.005]                           version <- ns[[".package"]][["version"]]
[11:03:25.005]                           if (is.null(version)) 
[11:03:25.005]                             version <- utils::packageVersion("future")
[11:03:25.005]                         }
[11:03:25.005]                         else {
[11:03:25.005]                           version <- NULL
[11:03:25.005]                         }
[11:03:25.005]                         if (!has_future || version < "1.8.0") {
[11:03:25.005]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.005]                             "", base::R.version$version.string), 
[11:03:25.005]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:25.005]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.005]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.005]                               "release", "version")], collapse = " "), 
[11:03:25.005]                             hostname = base::Sys.info()[["nodename"]])
[11:03:25.005]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.005]                             info)
[11:03:25.005]                           info <- base::paste(info, collapse = "; ")
[11:03:25.005]                           if (!has_future) {
[11:03:25.005]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.005]                               info)
[11:03:25.005]                           }
[11:03:25.005]                           else {
[11:03:25.005]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.005]                               info, version)
[11:03:25.005]                           }
[11:03:25.005]                           base::stop(msg)
[11:03:25.005]                         }
[11:03:25.005]                       })
[11:03:25.005]                     }
[11:03:25.005]                     base::local({
[11:03:25.005]                       for (pkg in "utils") {
[11:03:25.005]                         base::loadNamespace(pkg)
[11:03:25.005]                         base::library(pkg, character.only = TRUE)
[11:03:25.005]                       }
[11:03:25.005]                     })
[11:03:25.005]                   }
[11:03:25.005]                   ...future.strategy.old <- future::plan("list")
[11:03:25.005]                   options(future.plan = NULL)
[11:03:25.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.005]                 }
[11:03:25.005]                 ...future.workdir <- getwd()
[11:03:25.005]             }
[11:03:25.005]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.005]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.005]         }
[11:03:25.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.005]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.005]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.005]             base::names(...future.oldOptions))
[11:03:25.005]     }
[11:03:25.005]     if (FALSE) {
[11:03:25.005]     }
[11:03:25.005]     else {
[11:03:25.005]         if (TRUE) {
[11:03:25.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.005]                 open = "w")
[11:03:25.005]         }
[11:03:25.005]         else {
[11:03:25.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.005]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.005]         }
[11:03:25.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.005]             base::sink(type = "output", split = FALSE)
[11:03:25.005]             base::close(...future.stdout)
[11:03:25.005]         }, add = TRUE)
[11:03:25.005]     }
[11:03:25.005]     ...future.frame <- base::sys.nframe()
[11:03:25.005]     ...future.conditions <- base::list()
[11:03:25.005]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.005]     if (FALSE) {
[11:03:25.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.005]     }
[11:03:25.005]     ...future.result <- base::tryCatch({
[11:03:25.005]         base::withCallingHandlers({
[11:03:25.005]             ...future.value <- base::withVisible(base::local({
[11:03:25.005]                 print(1:50)
[11:03:25.005]                 str(1:50)
[11:03:25.005]                 cat(letters, sep = "-")
[11:03:25.005]                 cat(1:6, collapse = "\n")
[11:03:25.005]                 write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.005]                 42L
[11:03:25.005]             }))
[11:03:25.005]             future::FutureResult(value = ...future.value$value, 
[11:03:25.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.005]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.005]                     ...future.globalenv.names))
[11:03:25.005]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.005]         }, condition = base::local({
[11:03:25.005]             c <- base::c
[11:03:25.005]             inherits <- base::inherits
[11:03:25.005]             invokeRestart <- base::invokeRestart
[11:03:25.005]             length <- base::length
[11:03:25.005]             list <- base::list
[11:03:25.005]             seq.int <- base::seq.int
[11:03:25.005]             signalCondition <- base::signalCondition
[11:03:25.005]             sys.calls <- base::sys.calls
[11:03:25.005]             `[[` <- base::`[[`
[11:03:25.005]             `+` <- base::`+`
[11:03:25.005]             `<<-` <- base::`<<-`
[11:03:25.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.005]                   3L)]
[11:03:25.005]             }
[11:03:25.005]             function(cond) {
[11:03:25.005]                 is_error <- inherits(cond, "error")
[11:03:25.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.005]                   NULL)
[11:03:25.005]                 if (is_error) {
[11:03:25.005]                   sessionInformation <- function() {
[11:03:25.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.005]                       search = base::search(), system = base::Sys.info())
[11:03:25.005]                   }
[11:03:25.005]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.005]                     cond$call), session = sessionInformation(), 
[11:03:25.005]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.005]                   signalCondition(cond)
[11:03:25.005]                 }
[11:03:25.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.005]                 "immediateCondition"))) {
[11:03:25.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.005]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.005]                   if (TRUE && !signal) {
[11:03:25.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.005]                     {
[11:03:25.005]                       inherits <- base::inherits
[11:03:25.005]                       invokeRestart <- base::invokeRestart
[11:03:25.005]                       is.null <- base::is.null
[11:03:25.005]                       muffled <- FALSE
[11:03:25.005]                       if (inherits(cond, "message")) {
[11:03:25.005]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.005]                         if (muffled) 
[11:03:25.005]                           invokeRestart("muffleMessage")
[11:03:25.005]                       }
[11:03:25.005]                       else if (inherits(cond, "warning")) {
[11:03:25.005]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.005]                         if (muffled) 
[11:03:25.005]                           invokeRestart("muffleWarning")
[11:03:25.005]                       }
[11:03:25.005]                       else if (inherits(cond, "condition")) {
[11:03:25.005]                         if (!is.null(pattern)) {
[11:03:25.005]                           computeRestarts <- base::computeRestarts
[11:03:25.005]                           grepl <- base::grepl
[11:03:25.005]                           restarts <- computeRestarts(cond)
[11:03:25.005]                           for (restart in restarts) {
[11:03:25.005]                             name <- restart$name
[11:03:25.005]                             if (is.null(name)) 
[11:03:25.005]                               next
[11:03:25.005]                             if (!grepl(pattern, name)) 
[11:03:25.005]                               next
[11:03:25.005]                             invokeRestart(restart)
[11:03:25.005]                             muffled <- TRUE
[11:03:25.005]                             break
[11:03:25.005]                           }
[11:03:25.005]                         }
[11:03:25.005]                       }
[11:03:25.005]                       invisible(muffled)
[11:03:25.005]                     }
[11:03:25.005]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.005]                   }
[11:03:25.005]                 }
[11:03:25.005]                 else {
[11:03:25.005]                   if (TRUE) {
[11:03:25.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.005]                     {
[11:03:25.005]                       inherits <- base::inherits
[11:03:25.005]                       invokeRestart <- base::invokeRestart
[11:03:25.005]                       is.null <- base::is.null
[11:03:25.005]                       muffled <- FALSE
[11:03:25.005]                       if (inherits(cond, "message")) {
[11:03:25.005]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.005]                         if (muffled) 
[11:03:25.005]                           invokeRestart("muffleMessage")
[11:03:25.005]                       }
[11:03:25.005]                       else if (inherits(cond, "warning")) {
[11:03:25.005]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.005]                         if (muffled) 
[11:03:25.005]                           invokeRestart("muffleWarning")
[11:03:25.005]                       }
[11:03:25.005]                       else if (inherits(cond, "condition")) {
[11:03:25.005]                         if (!is.null(pattern)) {
[11:03:25.005]                           computeRestarts <- base::computeRestarts
[11:03:25.005]                           grepl <- base::grepl
[11:03:25.005]                           restarts <- computeRestarts(cond)
[11:03:25.005]                           for (restart in restarts) {
[11:03:25.005]                             name <- restart$name
[11:03:25.005]                             if (is.null(name)) 
[11:03:25.005]                               next
[11:03:25.005]                             if (!grepl(pattern, name)) 
[11:03:25.005]                               next
[11:03:25.005]                             invokeRestart(restart)
[11:03:25.005]                             muffled <- TRUE
[11:03:25.005]                             break
[11:03:25.005]                           }
[11:03:25.005]                         }
[11:03:25.005]                       }
[11:03:25.005]                       invisible(muffled)
[11:03:25.005]                     }
[11:03:25.005]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.005]                   }
[11:03:25.005]                 }
[11:03:25.005]             }
[11:03:25.005]         }))
[11:03:25.005]     }, error = function(ex) {
[11:03:25.005]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.005]                 ...future.rng), started = ...future.startTime, 
[11:03:25.005]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.005]             version = "1.8"), class = "FutureResult")
[11:03:25.005]     }, finally = {
[11:03:25.005]         if (!identical(...future.workdir, getwd())) 
[11:03:25.005]             setwd(...future.workdir)
[11:03:25.005]         {
[11:03:25.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.005]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.005]             }
[11:03:25.005]             base::options(...future.oldOptions)
[11:03:25.005]             if (.Platform$OS.type == "windows") {
[11:03:25.005]                 old_names <- names(...future.oldEnvVars)
[11:03:25.005]                 envs <- base::Sys.getenv()
[11:03:25.005]                 names <- names(envs)
[11:03:25.005]                 common <- intersect(names, old_names)
[11:03:25.005]                 added <- setdiff(names, old_names)
[11:03:25.005]                 removed <- setdiff(old_names, names)
[11:03:25.005]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.005]                   envs[common]]
[11:03:25.005]                 NAMES <- toupper(changed)
[11:03:25.005]                 args <- list()
[11:03:25.005]                 for (kk in seq_along(NAMES)) {
[11:03:25.005]                   name <- changed[[kk]]
[11:03:25.005]                   NAME <- NAMES[[kk]]
[11:03:25.005]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.005]                     next
[11:03:25.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.005]                 }
[11:03:25.005]                 NAMES <- toupper(added)
[11:03:25.005]                 for (kk in seq_along(NAMES)) {
[11:03:25.005]                   name <- added[[kk]]
[11:03:25.005]                   NAME <- NAMES[[kk]]
[11:03:25.005]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.005]                     next
[11:03:25.005]                   args[[name]] <- ""
[11:03:25.005]                 }
[11:03:25.005]                 NAMES <- toupper(removed)
[11:03:25.005]                 for (kk in seq_along(NAMES)) {
[11:03:25.005]                   name <- removed[[kk]]
[11:03:25.005]                   NAME <- NAMES[[kk]]
[11:03:25.005]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.005]                     next
[11:03:25.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.005]                 }
[11:03:25.005]                 if (length(args) > 0) 
[11:03:25.005]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.005]             }
[11:03:25.005]             else {
[11:03:25.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.005]             }
[11:03:25.005]             {
[11:03:25.005]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.005]                   0L) {
[11:03:25.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.005]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.005]                   base::options(opts)
[11:03:25.005]                 }
[11:03:25.005]                 {
[11:03:25.005]                   {
[11:03:25.005]                     NULL
[11:03:25.005]                     RNGkind("Mersenne-Twister")
[11:03:25.005]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:03:25.005]                       inherits = FALSE)
[11:03:25.005]                   }
[11:03:25.005]                   options(future.plan = NULL)
[11:03:25.005]                   if (is.na(NA_character_)) 
[11:03:25.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.005]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.005]                     .init = FALSE)
[11:03:25.005]                 }
[11:03:25.005]             }
[11:03:25.005]         }
[11:03:25.005]     })
[11:03:25.005]     if (TRUE) {
[11:03:25.005]         base::sink(type = "output", split = FALSE)
[11:03:25.005]         if (TRUE) {
[11:03:25.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.005]         }
[11:03:25.005]         else {
[11:03:25.005]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.005]         }
[11:03:25.005]         base::close(...future.stdout)
[11:03:25.005]         ...future.stdout <- NULL
[11:03:25.005]     }
[11:03:25.005]     ...future.result$conditions <- ...future.conditions
[11:03:25.005]     ...future.result$finished <- base::Sys.time()
[11:03:25.005]     ...future.result
[11:03:25.005] }
[11:03:25.007] plan(): Setting new future strategy stack:
[11:03:25.007] List of future strategies:
[11:03:25.007] 1. sequential:
[11:03:25.007]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.007]    - tweaked: FALSE
[11:03:25.007]    - call: NULL
[11:03:25.007] plan(): nbrOfWorkers() = 1
[11:03:25.008] plan(): Setting new future strategy stack:
[11:03:25.008] List of future strategies:
[11:03:25.008] 1. sequential:
[11:03:25.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.008]    - tweaked: FALSE
[11:03:25.008]    - call: plan(strategy)
[11:03:25.009] plan(): nbrOfWorkers() = 1
[11:03:25.009] SequentialFuture started (and completed)
[11:03:25.009] - Launch lazy future ... done
[11:03:25.009] run() for ‘SequentialFuture’ ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[11:03:25.010] getGlobalsAndPackages() ...
[11:03:25.010] Searching for globals...
[11:03:25.010] - globals found: [1] ‘print’
[11:03:25.010] Searching for globals ... DONE
[11:03:25.010] Resolving globals: FALSE
[11:03:25.011] 
[11:03:25.011] 
[11:03:25.011] getGlobalsAndPackages() ... DONE
[11:03:25.011] run() for ‘Future’ ...
[11:03:25.011] - state: ‘created’
[11:03:25.011] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:03:25.011] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:03:25.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:03:25.012]   - Field: ‘label’
[11:03:25.012]   - Field: ‘local’
[11:03:25.012]   - Field: ‘owner’
[11:03:25.012]   - Field: ‘envir’
[11:03:25.012]   - Field: ‘packages’
[11:03:25.012]   - Field: ‘gc’
[11:03:25.012]   - Field: ‘conditions’
[11:03:25.012]   - Field: ‘expr’
[11:03:25.012]   - Field: ‘uuid’
[11:03:25.012]   - Field: ‘seed’
[11:03:25.013]   - Field: ‘version’
[11:03:25.013]   - Field: ‘result’
[11:03:25.013]   - Field: ‘asynchronous’
[11:03:25.013]   - Field: ‘calls’
[11:03:25.013]   - Field: ‘globals’
[11:03:25.013]   - Field: ‘stdout’
[11:03:25.013]   - Field: ‘earlySignal’
[11:03:25.013]   - Field: ‘lazy’
[11:03:25.013]   - Field: ‘state’
[11:03:25.013] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:03:25.013] - Launch lazy future ...
[11:03:25.013] Packages needed by the future expression (n = 0): <none>
[11:03:25.014] Packages needed by future strategies (n = 0): <none>
[11:03:25.014] {
[11:03:25.014]     {
[11:03:25.014]         {
[11:03:25.014]             ...future.startTime <- base::Sys.time()
[11:03:25.014]             {
[11:03:25.014]                 {
[11:03:25.014]                   {
[11:03:25.014]                     base::local({
[11:03:25.014]                       has_future <- base::requireNamespace("future", 
[11:03:25.014]                         quietly = TRUE)
[11:03:25.014]                       if (has_future) {
[11:03:25.014]                         ns <- base::getNamespace("future")
[11:03:25.014]                         version <- ns[[".package"]][["version"]]
[11:03:25.014]                         if (is.null(version)) 
[11:03:25.014]                           version <- utils::packageVersion("future")
[11:03:25.014]                       }
[11:03:25.014]                       else {
[11:03:25.014]                         version <- NULL
[11:03:25.014]                       }
[11:03:25.014]                       if (!has_future || version < "1.8.0") {
[11:03:25.014]                         info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.014]                           "", base::R.version$version.string), 
[11:03:25.014]                           platform = base::sprintf("%s (%s-bit)", 
[11:03:25.014]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.014]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.014]                             "release", "version")], collapse = " "), 
[11:03:25.014]                           hostname = base::Sys.info()[["nodename"]])
[11:03:25.014]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.014]                           info)
[11:03:25.014]                         info <- base::paste(info, collapse = "; ")
[11:03:25.014]                         if (!has_future) {
[11:03:25.014]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.014]                             info)
[11:03:25.014]                         }
[11:03:25.014]                         else {
[11:03:25.014]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.014]                             info, version)
[11:03:25.014]                         }
[11:03:25.014]                         base::stop(msg)
[11:03:25.014]                       }
[11:03:25.014]                     })
[11:03:25.014]                   }
[11:03:25.014]                   ...future.strategy.old <- future::plan("list")
[11:03:25.014]                   options(future.plan = NULL)
[11:03:25.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.014]                 }
[11:03:25.014]                 ...future.workdir <- getwd()
[11:03:25.014]             }
[11:03:25.014]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.014]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.014]         }
[11:03:25.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.014]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.014]             base::names(...future.oldOptions))
[11:03:25.014]     }
[11:03:25.014]     if (FALSE) {
[11:03:25.014]     }
[11:03:25.014]     else {
[11:03:25.014]         if (TRUE) {
[11:03:25.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.014]                 open = "w")
[11:03:25.014]         }
[11:03:25.014]         else {
[11:03:25.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.014]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.014]         }
[11:03:25.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.014]             base::sink(type = "output", split = FALSE)
[11:03:25.014]             base::close(...future.stdout)
[11:03:25.014]         }, add = TRUE)
[11:03:25.014]     }
[11:03:25.014]     ...future.frame <- base::sys.nframe()
[11:03:25.014]     ...future.conditions <- base::list()
[11:03:25.014]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.014]     if (FALSE) {
[11:03:25.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.014]     }
[11:03:25.014]     ...future.result <- base::tryCatch({
[11:03:25.014]         base::withCallingHandlers({
[11:03:25.014]             ...future.value <- base::withVisible(base::local(print(42)))
[11:03:25.014]             future::FutureResult(value = ...future.value$value, 
[11:03:25.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.014]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.014]                     ...future.globalenv.names))
[11:03:25.014]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.014]         }, condition = base::local({
[11:03:25.014]             c <- base::c
[11:03:25.014]             inherits <- base::inherits
[11:03:25.014]             invokeRestart <- base::invokeRestart
[11:03:25.014]             length <- base::length
[11:03:25.014]             list <- base::list
[11:03:25.014]             seq.int <- base::seq.int
[11:03:25.014]             signalCondition <- base::signalCondition
[11:03:25.014]             sys.calls <- base::sys.calls
[11:03:25.014]             `[[` <- base::`[[`
[11:03:25.014]             `+` <- base::`+`
[11:03:25.014]             `<<-` <- base::`<<-`
[11:03:25.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.014]                   3L)]
[11:03:25.014]             }
[11:03:25.014]             function(cond) {
[11:03:25.014]                 is_error <- inherits(cond, "error")
[11:03:25.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.014]                   NULL)
[11:03:25.014]                 if (is_error) {
[11:03:25.014]                   sessionInformation <- function() {
[11:03:25.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.014]                       search = base::search(), system = base::Sys.info())
[11:03:25.014]                   }
[11:03:25.014]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.014]                     cond$call), session = sessionInformation(), 
[11:03:25.014]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.014]                   signalCondition(cond)
[11:03:25.014]                 }
[11:03:25.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.014]                 "immediateCondition"))) {
[11:03:25.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.014]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.014]                   if (TRUE && !signal) {
[11:03:25.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.014]                     {
[11:03:25.014]                       inherits <- base::inherits
[11:03:25.014]                       invokeRestart <- base::invokeRestart
[11:03:25.014]                       is.null <- base::is.null
[11:03:25.014]                       muffled <- FALSE
[11:03:25.014]                       if (inherits(cond, "message")) {
[11:03:25.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.014]                         if (muffled) 
[11:03:25.014]                           invokeRestart("muffleMessage")
[11:03:25.014]                       }
[11:03:25.014]                       else if (inherits(cond, "warning")) {
[11:03:25.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.014]                         if (muffled) 
[11:03:25.014]                           invokeRestart("muffleWarning")
[11:03:25.014]                       }
[11:03:25.014]                       else if (inherits(cond, "condition")) {
[11:03:25.014]                         if (!is.null(pattern)) {
[11:03:25.014]                           computeRestarts <- base::computeRestarts
[11:03:25.014]                           grepl <- base::grepl
[11:03:25.014]                           restarts <- computeRestarts(cond)
[11:03:25.014]                           for (restart in restarts) {
[11:03:25.014]                             name <- restart$name
[11:03:25.014]                             if (is.null(name)) 
[11:03:25.014]                               next
[11:03:25.014]                             if (!grepl(pattern, name)) 
[11:03:25.014]                               next
[11:03:25.014]                             invokeRestart(restart)
[11:03:25.014]                             muffled <- TRUE
[11:03:25.014]                             break
[11:03:25.014]                           }
[11:03:25.014]                         }
[11:03:25.014]                       }
[11:03:25.014]                       invisible(muffled)
[11:03:25.014]                     }
[11:03:25.014]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.014]                   }
[11:03:25.014]                 }
[11:03:25.014]                 else {
[11:03:25.014]                   if (TRUE) {
[11:03:25.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.014]                     {
[11:03:25.014]                       inherits <- base::inherits
[11:03:25.014]                       invokeRestart <- base::invokeRestart
[11:03:25.014]                       is.null <- base::is.null
[11:03:25.014]                       muffled <- FALSE
[11:03:25.014]                       if (inherits(cond, "message")) {
[11:03:25.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.014]                         if (muffled) 
[11:03:25.014]                           invokeRestart("muffleMessage")
[11:03:25.014]                       }
[11:03:25.014]                       else if (inherits(cond, "warning")) {
[11:03:25.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.014]                         if (muffled) 
[11:03:25.014]                           invokeRestart("muffleWarning")
[11:03:25.014]                       }
[11:03:25.014]                       else if (inherits(cond, "condition")) {
[11:03:25.014]                         if (!is.null(pattern)) {
[11:03:25.014]                           computeRestarts <- base::computeRestarts
[11:03:25.014]                           grepl <- base::grepl
[11:03:25.014]                           restarts <- computeRestarts(cond)
[11:03:25.014]                           for (restart in restarts) {
[11:03:25.014]                             name <- restart$name
[11:03:25.014]                             if (is.null(name)) 
[11:03:25.014]                               next
[11:03:25.014]                             if (!grepl(pattern, name)) 
[11:03:25.014]                               next
[11:03:25.014]                             invokeRestart(restart)
[11:03:25.014]                             muffled <- TRUE
[11:03:25.014]                             break
[11:03:25.014]                           }
[11:03:25.014]                         }
[11:03:25.014]                       }
[11:03:25.014]                       invisible(muffled)
[11:03:25.014]                     }
[11:03:25.014]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.014]                   }
[11:03:25.014]                 }
[11:03:25.014]             }
[11:03:25.014]         }))
[11:03:25.014]     }, error = function(ex) {
[11:03:25.014]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.014]                 ...future.rng), started = ...future.startTime, 
[11:03:25.014]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.014]             version = "1.8"), class = "FutureResult")
[11:03:25.014]     }, finally = {
[11:03:25.014]         if (!identical(...future.workdir, getwd())) 
[11:03:25.014]             setwd(...future.workdir)
[11:03:25.014]         {
[11:03:25.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.014]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.014]             }
[11:03:25.014]             base::options(...future.oldOptions)
[11:03:25.014]             if (.Platform$OS.type == "windows") {
[11:03:25.014]                 old_names <- names(...future.oldEnvVars)
[11:03:25.014]                 envs <- base::Sys.getenv()
[11:03:25.014]                 names <- names(envs)
[11:03:25.014]                 common <- intersect(names, old_names)
[11:03:25.014]                 added <- setdiff(names, old_names)
[11:03:25.014]                 removed <- setdiff(old_names, names)
[11:03:25.014]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.014]                   envs[common]]
[11:03:25.014]                 NAMES <- toupper(changed)
[11:03:25.014]                 args <- list()
[11:03:25.014]                 for (kk in seq_along(NAMES)) {
[11:03:25.014]                   name <- changed[[kk]]
[11:03:25.014]                   NAME <- NAMES[[kk]]
[11:03:25.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.014]                     next
[11:03:25.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.014]                 }
[11:03:25.014]                 NAMES <- toupper(added)
[11:03:25.014]                 for (kk in seq_along(NAMES)) {
[11:03:25.014]                   name <- added[[kk]]
[11:03:25.014]                   NAME <- NAMES[[kk]]
[11:03:25.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.014]                     next
[11:03:25.014]                   args[[name]] <- ""
[11:03:25.014]                 }
[11:03:25.014]                 NAMES <- toupper(removed)
[11:03:25.014]                 for (kk in seq_along(NAMES)) {
[11:03:25.014]                   name <- removed[[kk]]
[11:03:25.014]                   NAME <- NAMES[[kk]]
[11:03:25.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.014]                     next
[11:03:25.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.014]                 }
[11:03:25.014]                 if (length(args) > 0) 
[11:03:25.014]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.014]             }
[11:03:25.014]             else {
[11:03:25.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.014]             }
[11:03:25.014]             {
[11:03:25.014]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.014]                   0L) {
[11:03:25.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.014]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.014]                   base::options(opts)
[11:03:25.014]                 }
[11:03:25.014]                 {
[11:03:25.014]                   {
[11:03:25.014]                     NULL
[11:03:25.014]                     RNGkind("Mersenne-Twister")
[11:03:25.014]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:03:25.014]                       inherits = FALSE)
[11:03:25.014]                   }
[11:03:25.014]                   options(future.plan = NULL)
[11:03:25.014]                   if (is.na(NA_character_)) 
[11:03:25.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.014]                     .init = FALSE)
[11:03:25.014]                 }
[11:03:25.014]             }
[11:03:25.014]         }
[11:03:25.014]     })
[11:03:25.014]     if (TRUE) {
[11:03:25.014]         base::sink(type = "output", split = FALSE)
[11:03:25.014]         if (TRUE) {
[11:03:25.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.014]         }
[11:03:25.014]         else {
[11:03:25.014]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.014]         }
[11:03:25.014]         base::close(...future.stdout)
[11:03:25.014]         ...future.stdout <- NULL
[11:03:25.014]     }
[11:03:25.014]     ...future.result$conditions <- ...future.conditions
[11:03:25.014]     ...future.result$finished <- base::Sys.time()
[11:03:25.014]     ...future.result
[11:03:25.014] }
[11:03:25.016] plan(): Setting new future strategy stack:
[11:03:25.016] List of future strategies:
[11:03:25.016] 1. sequential:
[11:03:25.016]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.016]    - tweaked: FALSE
[11:03:25.016]    - call: NULL
[11:03:25.016] plan(): nbrOfWorkers() = 1
[11:03:25.017] plan(): Setting new future strategy stack:
[11:03:25.017] List of future strategies:
[11:03:25.017] 1. sequential:
[11:03:25.017]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.017]    - tweaked: FALSE
[11:03:25.017]    - call: plan(strategy)
[11:03:25.017] plan(): nbrOfWorkers() = 1
[11:03:25.017] SequentialFuture started (and completed)
[11:03:25.018] - Launch lazy future ... done
[11:03:25.018] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = FALSE
[11:03:25.018] getGlobalsAndPackages() ...
[11:03:25.018] Searching for globals...
[11:03:25.020] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.021] Searching for globals ... DONE
[11:03:25.021] Resolving globals: FALSE
[11:03:25.021] 
[11:03:25.021] - packages: [1] ‘utils’
[11:03:25.021] getGlobalsAndPackages() ... DONE
[11:03:25.022] run() for ‘Future’ ...
[11:03:25.022] - state: ‘created’
[11:03:25.022] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:03:25.022] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:03:25.022] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:03:25.022]   - Field: ‘label’
[11:03:25.022]   - Field: ‘local’
[11:03:25.022]   - Field: ‘owner’
[11:03:25.022]   - Field: ‘envir’
[11:03:25.023]   - Field: ‘packages’
[11:03:25.023]   - Field: ‘gc’
[11:03:25.023]   - Field: ‘conditions’
[11:03:25.023]   - Field: ‘expr’
[11:03:25.023]   - Field: ‘uuid’
[11:03:25.023]   - Field: ‘seed’
[11:03:25.023]   - Field: ‘version’
[11:03:25.023]   - Field: ‘result’
[11:03:25.023]   - Field: ‘asynchronous’
[11:03:25.023]   - Field: ‘calls’
[11:03:25.023]   - Field: ‘globals’
[11:03:25.023]   - Field: ‘stdout’
[11:03:25.023]   - Field: ‘earlySignal’
[11:03:25.024]   - Field: ‘lazy’
[11:03:25.024]   - Field: ‘state’
[11:03:25.024] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:03:25.024] - Launch lazy future ...
[11:03:25.024] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.024] Packages needed by future strategies (n = 0): <none>
[11:03:25.025] {
[11:03:25.025]     {
[11:03:25.025]         {
[11:03:25.025]             ...future.startTime <- base::Sys.time()
[11:03:25.025]             {
[11:03:25.025]                 {
[11:03:25.025]                   {
[11:03:25.025]                     {
[11:03:25.025]                       base::local({
[11:03:25.025]                         has_future <- base::requireNamespace("future", 
[11:03:25.025]                           quietly = TRUE)
[11:03:25.025]                         if (has_future) {
[11:03:25.025]                           ns <- base::getNamespace("future")
[11:03:25.025]                           version <- ns[[".package"]][["version"]]
[11:03:25.025]                           if (is.null(version)) 
[11:03:25.025]                             version <- utils::packageVersion("future")
[11:03:25.025]                         }
[11:03:25.025]                         else {
[11:03:25.025]                           version <- NULL
[11:03:25.025]                         }
[11:03:25.025]                         if (!has_future || version < "1.8.0") {
[11:03:25.025]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.025]                             "", base::R.version$version.string), 
[11:03:25.025]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:25.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.025]                               "release", "version")], collapse = " "), 
[11:03:25.025]                             hostname = base::Sys.info()[["nodename"]])
[11:03:25.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.025]                             info)
[11:03:25.025]                           info <- base::paste(info, collapse = "; ")
[11:03:25.025]                           if (!has_future) {
[11:03:25.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.025]                               info)
[11:03:25.025]                           }
[11:03:25.025]                           else {
[11:03:25.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.025]                               info, version)
[11:03:25.025]                           }
[11:03:25.025]                           base::stop(msg)
[11:03:25.025]                         }
[11:03:25.025]                       })
[11:03:25.025]                     }
[11:03:25.025]                     base::local({
[11:03:25.025]                       for (pkg in "utils") {
[11:03:25.025]                         base::loadNamespace(pkg)
[11:03:25.025]                         base::library(pkg, character.only = TRUE)
[11:03:25.025]                       }
[11:03:25.025]                     })
[11:03:25.025]                   }
[11:03:25.025]                   ...future.strategy.old <- future::plan("list")
[11:03:25.025]                   options(future.plan = NULL)
[11:03:25.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.025]                 }
[11:03:25.025]                 ...future.workdir <- getwd()
[11:03:25.025]             }
[11:03:25.025]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.025]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.025]         }
[11:03:25.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.025]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.025]             base::names(...future.oldOptions))
[11:03:25.025]     }
[11:03:25.025]     if (FALSE) {
[11:03:25.025]     }
[11:03:25.025]     else {
[11:03:25.025]         if (FALSE) {
[11:03:25.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.025]                 open = "w")
[11:03:25.025]         }
[11:03:25.025]         else {
[11:03:25.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.025]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.025]         }
[11:03:25.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.025]             base::sink(type = "output", split = FALSE)
[11:03:25.025]             base::close(...future.stdout)
[11:03:25.025]         }, add = TRUE)
[11:03:25.025]     }
[11:03:25.025]     ...future.frame <- base::sys.nframe()
[11:03:25.025]     ...future.conditions <- base::list()
[11:03:25.025]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.025]     if (FALSE) {
[11:03:25.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.025]     }
[11:03:25.025]     ...future.result <- base::tryCatch({
[11:03:25.025]         base::withCallingHandlers({
[11:03:25.025]             ...future.value <- base::withVisible(base::local({
[11:03:25.025]                 print(1:50)
[11:03:25.025]                 str(1:50)
[11:03:25.025]                 cat(letters, sep = "-")
[11:03:25.025]                 cat(1:6, collapse = "\n")
[11:03:25.025]                 write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.025]                 42L
[11:03:25.025]             }))
[11:03:25.025]             future::FutureResult(value = ...future.value$value, 
[11:03:25.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.025]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.025]                     ...future.globalenv.names))
[11:03:25.025]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.025]         }, condition = base::local({
[11:03:25.025]             c <- base::c
[11:03:25.025]             inherits <- base::inherits
[11:03:25.025]             invokeRestart <- base::invokeRestart
[11:03:25.025]             length <- base::length
[11:03:25.025]             list <- base::list
[11:03:25.025]             seq.int <- base::seq.int
[11:03:25.025]             signalCondition <- base::signalCondition
[11:03:25.025]             sys.calls <- base::sys.calls
[11:03:25.025]             `[[` <- base::`[[`
[11:03:25.025]             `+` <- base::`+`
[11:03:25.025]             `<<-` <- base::`<<-`
[11:03:25.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.025]                   3L)]
[11:03:25.025]             }
[11:03:25.025]             function(cond) {
[11:03:25.025]                 is_error <- inherits(cond, "error")
[11:03:25.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.025]                   NULL)
[11:03:25.025]                 if (is_error) {
[11:03:25.025]                   sessionInformation <- function() {
[11:03:25.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.025]                       search = base::search(), system = base::Sys.info())
[11:03:25.025]                   }
[11:03:25.025]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.025]                     cond$call), session = sessionInformation(), 
[11:03:25.025]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.025]                   signalCondition(cond)
[11:03:25.025]                 }
[11:03:25.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.025]                 "immediateCondition"))) {
[11:03:25.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.025]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.025]                   if (TRUE && !signal) {
[11:03:25.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.025]                     {
[11:03:25.025]                       inherits <- base::inherits
[11:03:25.025]                       invokeRestart <- base::invokeRestart
[11:03:25.025]                       is.null <- base::is.null
[11:03:25.025]                       muffled <- FALSE
[11:03:25.025]                       if (inherits(cond, "message")) {
[11:03:25.025]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.025]                         if (muffled) 
[11:03:25.025]                           invokeRestart("muffleMessage")
[11:03:25.025]                       }
[11:03:25.025]                       else if (inherits(cond, "warning")) {
[11:03:25.025]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.025]                         if (muffled) 
[11:03:25.025]                           invokeRestart("muffleWarning")
[11:03:25.025]                       }
[11:03:25.025]                       else if (inherits(cond, "condition")) {
[11:03:25.025]                         if (!is.null(pattern)) {
[11:03:25.025]                           computeRestarts <- base::computeRestarts
[11:03:25.025]                           grepl <- base::grepl
[11:03:25.025]                           restarts <- computeRestarts(cond)
[11:03:25.025]                           for (restart in restarts) {
[11:03:25.025]                             name <- restart$name
[11:03:25.025]                             if (is.null(name)) 
[11:03:25.025]                               next
[11:03:25.025]                             if (!grepl(pattern, name)) 
[11:03:25.025]                               next
[11:03:25.025]                             invokeRestart(restart)
[11:03:25.025]                             muffled <- TRUE
[11:03:25.025]                             break
[11:03:25.025]                           }
[11:03:25.025]                         }
[11:03:25.025]                       }
[11:03:25.025]                       invisible(muffled)
[11:03:25.025]                     }
[11:03:25.025]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.025]                   }
[11:03:25.025]                 }
[11:03:25.025]                 else {
[11:03:25.025]                   if (TRUE) {
[11:03:25.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.025]                     {
[11:03:25.025]                       inherits <- base::inherits
[11:03:25.025]                       invokeRestart <- base::invokeRestart
[11:03:25.025]                       is.null <- base::is.null
[11:03:25.025]                       muffled <- FALSE
[11:03:25.025]                       if (inherits(cond, "message")) {
[11:03:25.025]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.025]                         if (muffled) 
[11:03:25.025]                           invokeRestart("muffleMessage")
[11:03:25.025]                       }
[11:03:25.025]                       else if (inherits(cond, "warning")) {
[11:03:25.025]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.025]                         if (muffled) 
[11:03:25.025]                           invokeRestart("muffleWarning")
[11:03:25.025]                       }
[11:03:25.025]                       else if (inherits(cond, "condition")) {
[11:03:25.025]                         if (!is.null(pattern)) {
[11:03:25.025]                           computeRestarts <- base::computeRestarts
[11:03:25.025]                           grepl <- base::grepl
[11:03:25.025]                           restarts <- computeRestarts(cond)
[11:03:25.025]                           for (restart in restarts) {
[11:03:25.025]                             name <- restart$name
[11:03:25.025]                             if (is.null(name)) 
[11:03:25.025]                               next
[11:03:25.025]                             if (!grepl(pattern, name)) 
[11:03:25.025]                               next
[11:03:25.025]                             invokeRestart(restart)
[11:03:25.025]                             muffled <- TRUE
[11:03:25.025]                             break
[11:03:25.025]                           }
[11:03:25.025]                         }
[11:03:25.025]                       }
[11:03:25.025]                       invisible(muffled)
[11:03:25.025]                     }
[11:03:25.025]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.025]                   }
[11:03:25.025]                 }
[11:03:25.025]             }
[11:03:25.025]         }))
[11:03:25.025]     }, error = function(ex) {
[11:03:25.025]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.025]                 ...future.rng), started = ...future.startTime, 
[11:03:25.025]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.025]             version = "1.8"), class = "FutureResult")
[11:03:25.025]     }, finally = {
[11:03:25.025]         if (!identical(...future.workdir, getwd())) 
[11:03:25.025]             setwd(...future.workdir)
[11:03:25.025]         {
[11:03:25.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.025]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.025]             }
[11:03:25.025]             base::options(...future.oldOptions)
[11:03:25.025]             if (.Platform$OS.type == "windows") {
[11:03:25.025]                 old_names <- names(...future.oldEnvVars)
[11:03:25.025]                 envs <- base::Sys.getenv()
[11:03:25.025]                 names <- names(envs)
[11:03:25.025]                 common <- intersect(names, old_names)
[11:03:25.025]                 added <- setdiff(names, old_names)
[11:03:25.025]                 removed <- setdiff(old_names, names)
[11:03:25.025]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.025]                   envs[common]]
[11:03:25.025]                 NAMES <- toupper(changed)
[11:03:25.025]                 args <- list()
[11:03:25.025]                 for (kk in seq_along(NAMES)) {
[11:03:25.025]                   name <- changed[[kk]]
[11:03:25.025]                   NAME <- NAMES[[kk]]
[11:03:25.025]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.025]                     next
[11:03:25.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.025]                 }
[11:03:25.025]                 NAMES <- toupper(added)
[11:03:25.025]                 for (kk in seq_along(NAMES)) {
[11:03:25.025]                   name <- added[[kk]]
[11:03:25.025]                   NAME <- NAMES[[kk]]
[11:03:25.025]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.025]                     next
[11:03:25.025]                   args[[name]] <- ""
[11:03:25.025]                 }
[11:03:25.025]                 NAMES <- toupper(removed)
[11:03:25.025]                 for (kk in seq_along(NAMES)) {
[11:03:25.025]                   name <- removed[[kk]]
[11:03:25.025]                   NAME <- NAMES[[kk]]
[11:03:25.025]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.025]                     next
[11:03:25.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.025]                 }
[11:03:25.025]                 if (length(args) > 0) 
[11:03:25.025]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.025]             }
[11:03:25.025]             else {
[11:03:25.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.025]             }
[11:03:25.025]             {
[11:03:25.025]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.025]                   0L) {
[11:03:25.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.025]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.025]                   base::options(opts)
[11:03:25.025]                 }
[11:03:25.025]                 {
[11:03:25.025]                   {
[11:03:25.025]                     NULL
[11:03:25.025]                     RNGkind("Mersenne-Twister")
[11:03:25.025]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:03:25.025]                       inherits = FALSE)
[11:03:25.025]                   }
[11:03:25.025]                   options(future.plan = NULL)
[11:03:25.025]                   if (is.na(NA_character_)) 
[11:03:25.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.025]                     .init = FALSE)
[11:03:25.025]                 }
[11:03:25.025]             }
[11:03:25.025]         }
[11:03:25.025]     })
[11:03:25.025]     if (TRUE) {
[11:03:25.025]         base::sink(type = "output", split = FALSE)
[11:03:25.025]         if (FALSE) {
[11:03:25.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.025]         }
[11:03:25.025]         else {
[11:03:25.025]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.025]         }
[11:03:25.025]         base::close(...future.stdout)
[11:03:25.025]         ...future.stdout <- NULL
[11:03:25.025]     }
[11:03:25.025]     ...future.result$conditions <- ...future.conditions
[11:03:25.025]     ...future.result$finished <- base::Sys.time()
[11:03:25.025]     ...future.result
[11:03:25.025] }
[11:03:25.027] plan(): Setting new future strategy stack:
[11:03:25.027] List of future strategies:
[11:03:25.027] 1. sequential:
[11:03:25.027]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.027]    - tweaked: FALSE
[11:03:25.027]    - call: NULL
[11:03:25.028] plan(): nbrOfWorkers() = 1
[11:03:25.029] plan(): Setting new future strategy stack:
[11:03:25.029] List of future strategies:
[11:03:25.029] 1. sequential:
[11:03:25.029]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.029]    - tweaked: FALSE
[11:03:25.029]    - call: plan(strategy)
[11:03:25.030] plan(): nbrOfWorkers() = 1
[11:03:25.030] SequentialFuture started (and completed)
[11:03:25.030] - Launch lazy future ... done
[11:03:25.030] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ finished    : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ session_uuid: chr "861151cf-a595-47bd-b6ac-be12af3eb978"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "173ee284ba16"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 84989
  .. ..$ time  : POSIXct[1:1], format: "2025-05-06 11:03:24"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[11:03:25.037] getGlobalsAndPackages() ...
[11:03:25.037] Searching for globals...
[11:03:25.039] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.040] Searching for globals ... DONE
[11:03:25.040] Resolving globals: FALSE
[11:03:25.040] 
[11:03:25.040] - packages: [1] ‘utils’
[11:03:25.040] getGlobalsAndPackages() ... DONE
[11:03:25.040] run() for ‘Future’ ...
[11:03:25.041] - state: ‘created’
[11:03:25.041] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:03:25.041] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:03:25.041] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:03:25.041]   - Field: ‘label’
[11:03:25.041]   - Field: ‘local’
[11:03:25.041]   - Field: ‘owner’
[11:03:25.041]   - Field: ‘envir’
[11:03:25.041]   - Field: ‘packages’
[11:03:25.041]   - Field: ‘gc’
[11:03:25.042]   - Field: ‘conditions’
[11:03:25.042]   - Field: ‘expr’
[11:03:25.042]   - Field: ‘uuid’
[11:03:25.042]   - Field: ‘seed’
[11:03:25.042]   - Field: ‘version’
[11:03:25.042]   - Field: ‘result’
[11:03:25.042]   - Field: ‘asynchronous’
[11:03:25.042]   - Field: ‘calls’
[11:03:25.042]   - Field: ‘globals’
[11:03:25.042]   - Field: ‘stdout’
[11:03:25.042]   - Field: ‘earlySignal’
[11:03:25.042]   - Field: ‘lazy’
[11:03:25.043]   - Field: ‘state’
[11:03:25.043] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:03:25.043] - Launch lazy future ...
[11:03:25.043] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.043] Packages needed by future strategies (n = 0): <none>
[11:03:25.043] {
[11:03:25.043]     {
[11:03:25.043]         {
[11:03:25.043]             ...future.startTime <- base::Sys.time()
[11:03:25.043]             {
[11:03:25.043]                 {
[11:03:25.043]                   {
[11:03:25.043]                     {
[11:03:25.043]                       base::local({
[11:03:25.043]                         has_future <- base::requireNamespace("future", 
[11:03:25.043]                           quietly = TRUE)
[11:03:25.043]                         if (has_future) {
[11:03:25.043]                           ns <- base::getNamespace("future")
[11:03:25.043]                           version <- ns[[".package"]][["version"]]
[11:03:25.043]                           if (is.null(version)) 
[11:03:25.043]                             version <- utils::packageVersion("future")
[11:03:25.043]                         }
[11:03:25.043]                         else {
[11:03:25.043]                           version <- NULL
[11:03:25.043]                         }
[11:03:25.043]                         if (!has_future || version < "1.8.0") {
[11:03:25.043]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.043]                             "", base::R.version$version.string), 
[11:03:25.043]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:25.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.043]                               "release", "version")], collapse = " "), 
[11:03:25.043]                             hostname = base::Sys.info()[["nodename"]])
[11:03:25.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.043]                             info)
[11:03:25.043]                           info <- base::paste(info, collapse = "; ")
[11:03:25.043]                           if (!has_future) {
[11:03:25.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.043]                               info)
[11:03:25.043]                           }
[11:03:25.043]                           else {
[11:03:25.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.043]                               info, version)
[11:03:25.043]                           }
[11:03:25.043]                           base::stop(msg)
[11:03:25.043]                         }
[11:03:25.043]                       })
[11:03:25.043]                     }
[11:03:25.043]                     base::local({
[11:03:25.043]                       for (pkg in "utils") {
[11:03:25.043]                         base::loadNamespace(pkg)
[11:03:25.043]                         base::library(pkg, character.only = TRUE)
[11:03:25.043]                       }
[11:03:25.043]                     })
[11:03:25.043]                   }
[11:03:25.043]                   ...future.strategy.old <- future::plan("list")
[11:03:25.043]                   options(future.plan = NULL)
[11:03:25.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.043]                 }
[11:03:25.043]                 ...future.workdir <- getwd()
[11:03:25.043]             }
[11:03:25.043]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.043]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.043]         }
[11:03:25.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.043]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.043]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.043]             base::names(...future.oldOptions))
[11:03:25.043]     }
[11:03:25.043]     if (FALSE) {
[11:03:25.043]     }
[11:03:25.043]     else {
[11:03:25.043]         if (FALSE) {
[11:03:25.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.043]                 open = "w")
[11:03:25.043]         }
[11:03:25.043]         else {
[11:03:25.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.043]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.043]         }
[11:03:25.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.043]             base::sink(type = "output", split = FALSE)
[11:03:25.043]             base::close(...future.stdout)
[11:03:25.043]         }, add = TRUE)
[11:03:25.043]     }
[11:03:25.043]     ...future.frame <- base::sys.nframe()
[11:03:25.043]     ...future.conditions <- base::list()
[11:03:25.043]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.043]     if (FALSE) {
[11:03:25.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.043]     }
[11:03:25.043]     ...future.result <- base::tryCatch({
[11:03:25.043]         base::withCallingHandlers({
[11:03:25.043]             ...future.value <- base::withVisible(base::local({
[11:03:25.043]                 print(1:50)
[11:03:25.043]                 str(1:50)
[11:03:25.043]                 cat(letters, sep = "-")
[11:03:25.043]                 cat(1:6, collapse = "\n")
[11:03:25.043]                 write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.043]                 42L
[11:03:25.043]             }))
[11:03:25.043]             future::FutureResult(value = ...future.value$value, 
[11:03:25.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.043]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.043]                     ...future.globalenv.names))
[11:03:25.043]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.043]         }, condition = base::local({
[11:03:25.043]             c <- base::c
[11:03:25.043]             inherits <- base::inherits
[11:03:25.043]             invokeRestart <- base::invokeRestart
[11:03:25.043]             length <- base::length
[11:03:25.043]             list <- base::list
[11:03:25.043]             seq.int <- base::seq.int
[11:03:25.043]             signalCondition <- base::signalCondition
[11:03:25.043]             sys.calls <- base::sys.calls
[11:03:25.043]             `[[` <- base::`[[`
[11:03:25.043]             `+` <- base::`+`
[11:03:25.043]             `<<-` <- base::`<<-`
[11:03:25.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.043]                   3L)]
[11:03:25.043]             }
[11:03:25.043]             function(cond) {
[11:03:25.043]                 is_error <- inherits(cond, "error")
[11:03:25.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.043]                   NULL)
[11:03:25.043]                 if (is_error) {
[11:03:25.043]                   sessionInformation <- function() {
[11:03:25.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.043]                       search = base::search(), system = base::Sys.info())
[11:03:25.043]                   }
[11:03:25.043]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.043]                     cond$call), session = sessionInformation(), 
[11:03:25.043]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.043]                   signalCondition(cond)
[11:03:25.043]                 }
[11:03:25.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.043]                 "immediateCondition"))) {
[11:03:25.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.043]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.043]                   if (TRUE && !signal) {
[11:03:25.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.043]                     {
[11:03:25.043]                       inherits <- base::inherits
[11:03:25.043]                       invokeRestart <- base::invokeRestart
[11:03:25.043]                       is.null <- base::is.null
[11:03:25.043]                       muffled <- FALSE
[11:03:25.043]                       if (inherits(cond, "message")) {
[11:03:25.043]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.043]                         if (muffled) 
[11:03:25.043]                           invokeRestart("muffleMessage")
[11:03:25.043]                       }
[11:03:25.043]                       else if (inherits(cond, "warning")) {
[11:03:25.043]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.043]                         if (muffled) 
[11:03:25.043]                           invokeRestart("muffleWarning")
[11:03:25.043]                       }
[11:03:25.043]                       else if (inherits(cond, "condition")) {
[11:03:25.043]                         if (!is.null(pattern)) {
[11:03:25.043]                           computeRestarts <- base::computeRestarts
[11:03:25.043]                           grepl <- base::grepl
[11:03:25.043]                           restarts <- computeRestarts(cond)
[11:03:25.043]                           for (restart in restarts) {
[11:03:25.043]                             name <- restart$name
[11:03:25.043]                             if (is.null(name)) 
[11:03:25.043]                               next
[11:03:25.043]                             if (!grepl(pattern, name)) 
[11:03:25.043]                               next
[11:03:25.043]                             invokeRestart(restart)
[11:03:25.043]                             muffled <- TRUE
[11:03:25.043]                             break
[11:03:25.043]                           }
[11:03:25.043]                         }
[11:03:25.043]                       }
[11:03:25.043]                       invisible(muffled)
[11:03:25.043]                     }
[11:03:25.043]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.043]                   }
[11:03:25.043]                 }
[11:03:25.043]                 else {
[11:03:25.043]                   if (TRUE) {
[11:03:25.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.043]                     {
[11:03:25.043]                       inherits <- base::inherits
[11:03:25.043]                       invokeRestart <- base::invokeRestart
[11:03:25.043]                       is.null <- base::is.null
[11:03:25.043]                       muffled <- FALSE
[11:03:25.043]                       if (inherits(cond, "message")) {
[11:03:25.043]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.043]                         if (muffled) 
[11:03:25.043]                           invokeRestart("muffleMessage")
[11:03:25.043]                       }
[11:03:25.043]                       else if (inherits(cond, "warning")) {
[11:03:25.043]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.043]                         if (muffled) 
[11:03:25.043]                           invokeRestart("muffleWarning")
[11:03:25.043]                       }
[11:03:25.043]                       else if (inherits(cond, "condition")) {
[11:03:25.043]                         if (!is.null(pattern)) {
[11:03:25.043]                           computeRestarts <- base::computeRestarts
[11:03:25.043]                           grepl <- base::grepl
[11:03:25.043]                           restarts <- computeRestarts(cond)
[11:03:25.043]                           for (restart in restarts) {
[11:03:25.043]                             name <- restart$name
[11:03:25.043]                             if (is.null(name)) 
[11:03:25.043]                               next
[11:03:25.043]                             if (!grepl(pattern, name)) 
[11:03:25.043]                               next
[11:03:25.043]                             invokeRestart(restart)
[11:03:25.043]                             muffled <- TRUE
[11:03:25.043]                             break
[11:03:25.043]                           }
[11:03:25.043]                         }
[11:03:25.043]                       }
[11:03:25.043]                       invisible(muffled)
[11:03:25.043]                     }
[11:03:25.043]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.043]                   }
[11:03:25.043]                 }
[11:03:25.043]             }
[11:03:25.043]         }))
[11:03:25.043]     }, error = function(ex) {
[11:03:25.043]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.043]                 ...future.rng), started = ...future.startTime, 
[11:03:25.043]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.043]             version = "1.8"), class = "FutureResult")
[11:03:25.043]     }, finally = {
[11:03:25.043]         if (!identical(...future.workdir, getwd())) 
[11:03:25.043]             setwd(...future.workdir)
[11:03:25.043]         {
[11:03:25.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.043]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.043]             }
[11:03:25.043]             base::options(...future.oldOptions)
[11:03:25.043]             if (.Platform$OS.type == "windows") {
[11:03:25.043]                 old_names <- names(...future.oldEnvVars)
[11:03:25.043]                 envs <- base::Sys.getenv()
[11:03:25.043]                 names <- names(envs)
[11:03:25.043]                 common <- intersect(names, old_names)
[11:03:25.043]                 added <- setdiff(names, old_names)
[11:03:25.043]                 removed <- setdiff(old_names, names)
[11:03:25.043]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.043]                   envs[common]]
[11:03:25.043]                 NAMES <- toupper(changed)
[11:03:25.043]                 args <- list()
[11:03:25.043]                 for (kk in seq_along(NAMES)) {
[11:03:25.043]                   name <- changed[[kk]]
[11:03:25.043]                   NAME <- NAMES[[kk]]
[11:03:25.043]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.043]                     next
[11:03:25.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.043]                 }
[11:03:25.043]                 NAMES <- toupper(added)
[11:03:25.043]                 for (kk in seq_along(NAMES)) {
[11:03:25.043]                   name <- added[[kk]]
[11:03:25.043]                   NAME <- NAMES[[kk]]
[11:03:25.043]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.043]                     next
[11:03:25.043]                   args[[name]] <- ""
[11:03:25.043]                 }
[11:03:25.043]                 NAMES <- toupper(removed)
[11:03:25.043]                 for (kk in seq_along(NAMES)) {
[11:03:25.043]                   name <- removed[[kk]]
[11:03:25.043]                   NAME <- NAMES[[kk]]
[11:03:25.043]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.043]                     next
[11:03:25.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.043]                 }
[11:03:25.043]                 if (length(args) > 0) 
[11:03:25.043]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.043]             }
[11:03:25.043]             else {
[11:03:25.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.043]             }
[11:03:25.043]             {
[11:03:25.043]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.043]                   0L) {
[11:03:25.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.043]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.043]                   base::options(opts)
[11:03:25.043]                 }
[11:03:25.043]                 {
[11:03:25.043]                   {
[11:03:25.043]                     NULL
[11:03:25.043]                     RNGkind("Mersenne-Twister")
[11:03:25.043]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:03:25.043]                       inherits = FALSE)
[11:03:25.043]                   }
[11:03:25.043]                   options(future.plan = NULL)
[11:03:25.043]                   if (is.na(NA_character_)) 
[11:03:25.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.043]                     .init = FALSE)
[11:03:25.043]                 }
[11:03:25.043]             }
[11:03:25.043]         }
[11:03:25.043]     })
[11:03:25.043]     if (TRUE) {
[11:03:25.043]         base::sink(type = "output", split = FALSE)
[11:03:25.043]         if (FALSE) {
[11:03:25.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.043]         }
[11:03:25.043]         else {
[11:03:25.043]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.043]         }
[11:03:25.043]         base::close(...future.stdout)
[11:03:25.043]         ...future.stdout <- NULL
[11:03:25.043]     }
[11:03:25.043]     ...future.result$conditions <- ...future.conditions
[11:03:25.043]     ...future.result$finished <- base::Sys.time()
[11:03:25.043]     ...future.result
[11:03:25.043] }
[11:03:25.045] plan(): Setting new future strategy stack:
[11:03:25.045] List of future strategies:
[11:03:25.045] 1. sequential:
[11:03:25.045]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.045]    - tweaked: FALSE
[11:03:25.045]    - call: NULL
[11:03:25.046] plan(): nbrOfWorkers() = 1
[11:03:25.047] plan(): Setting new future strategy stack:
[11:03:25.047] List of future strategies:
[11:03:25.047] 1. sequential:
[11:03:25.047]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.047]    - tweaked: FALSE
[11:03:25.047]    - call: plan(strategy)
[11:03:25.048] plan(): nbrOfWorkers() = 1
[11:03:25.048] SequentialFuture started (and completed)
[11:03:25.048] - Launch lazy future ... done
[11:03:25.048] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[11:03:25.048] getGlobalsAndPackages() ...
[11:03:25.048] Searching for globals...
[11:03:25.049] - globals found: [1] ‘print’
[11:03:25.049] Searching for globals ... DONE
[11:03:25.049] Resolving globals: FALSE
[11:03:25.049] 
[11:03:25.049] 
[11:03:25.049] getGlobalsAndPackages() ... DONE
[11:03:25.049] run() for ‘Future’ ...
[11:03:25.050] - state: ‘created’
[11:03:25.050] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:03:25.050] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:03:25.051] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:03:25.051]   - Field: ‘label’
[11:03:25.051]   - Field: ‘local’
[11:03:25.051]   - Field: ‘owner’
[11:03:25.051]   - Field: ‘envir’
[11:03:25.051]   - Field: ‘packages’
[11:03:25.051]   - Field: ‘gc’
[11:03:25.051]   - Field: ‘conditions’
[11:03:25.052]   - Field: ‘expr’
[11:03:25.052]   - Field: ‘uuid’
[11:03:25.052]   - Field: ‘seed’
[11:03:25.052]   - Field: ‘version’
[11:03:25.052]   - Field: ‘result’
[11:03:25.052]   - Field: ‘asynchronous’
[11:03:25.052]   - Field: ‘calls’
[11:03:25.052]   - Field: ‘globals’
[11:03:25.052]   - Field: ‘stdout’
[11:03:25.052]   - Field: ‘earlySignal’
[11:03:25.052]   - Field: ‘lazy’
[11:03:25.052]   - Field: ‘state’
[11:03:25.052] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:03:25.053] - Launch lazy future ...
[11:03:25.053] Packages needed by the future expression (n = 0): <none>
[11:03:25.053] Packages needed by future strategies (n = 0): <none>
[11:03:25.053] {
[11:03:25.053]     {
[11:03:25.053]         {
[11:03:25.053]             ...future.startTime <- base::Sys.time()
[11:03:25.053]             {
[11:03:25.053]                 {
[11:03:25.053]                   {
[11:03:25.053]                     base::local({
[11:03:25.053]                       has_future <- base::requireNamespace("future", 
[11:03:25.053]                         quietly = TRUE)
[11:03:25.053]                       if (has_future) {
[11:03:25.053]                         ns <- base::getNamespace("future")
[11:03:25.053]                         version <- ns[[".package"]][["version"]]
[11:03:25.053]                         if (is.null(version)) 
[11:03:25.053]                           version <- utils::packageVersion("future")
[11:03:25.053]                       }
[11:03:25.053]                       else {
[11:03:25.053]                         version <- NULL
[11:03:25.053]                       }
[11:03:25.053]                       if (!has_future || version < "1.8.0") {
[11:03:25.053]                         info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.053]                           "", base::R.version$version.string), 
[11:03:25.053]                           platform = base::sprintf("%s (%s-bit)", 
[11:03:25.053]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.053]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.053]                             "release", "version")], collapse = " "), 
[11:03:25.053]                           hostname = base::Sys.info()[["nodename"]])
[11:03:25.053]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.053]                           info)
[11:03:25.053]                         info <- base::paste(info, collapse = "; ")
[11:03:25.053]                         if (!has_future) {
[11:03:25.053]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.053]                             info)
[11:03:25.053]                         }
[11:03:25.053]                         else {
[11:03:25.053]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.053]                             info, version)
[11:03:25.053]                         }
[11:03:25.053]                         base::stop(msg)
[11:03:25.053]                       }
[11:03:25.053]                     })
[11:03:25.053]                   }
[11:03:25.053]                   ...future.strategy.old <- future::plan("list")
[11:03:25.053]                   options(future.plan = NULL)
[11:03:25.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.053]                 }
[11:03:25.053]                 ...future.workdir <- getwd()
[11:03:25.053]             }
[11:03:25.053]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.053]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.053]         }
[11:03:25.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.053]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.053]             base::names(...future.oldOptions))
[11:03:25.053]     }
[11:03:25.053]     if (FALSE) {
[11:03:25.053]     }
[11:03:25.053]     else {
[11:03:25.053]         if (TRUE) {
[11:03:25.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.053]                 open = "w")
[11:03:25.053]         }
[11:03:25.053]         else {
[11:03:25.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.053]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.053]         }
[11:03:25.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.053]             base::sink(type = "output", split = FALSE)
[11:03:25.053]             base::close(...future.stdout)
[11:03:25.053]         }, add = TRUE)
[11:03:25.053]     }
[11:03:25.053]     ...future.frame <- base::sys.nframe()
[11:03:25.053]     ...future.conditions <- base::list()
[11:03:25.053]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.053]     if (FALSE) {
[11:03:25.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.053]     }
[11:03:25.053]     ...future.result <- base::tryCatch({
[11:03:25.053]         base::withCallingHandlers({
[11:03:25.053]             ...future.value <- base::withVisible(base::local(print(42)))
[11:03:25.053]             future::FutureResult(value = ...future.value$value, 
[11:03:25.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.053]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.053]                     ...future.globalenv.names))
[11:03:25.053]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.053]         }, condition = base::local({
[11:03:25.053]             c <- base::c
[11:03:25.053]             inherits <- base::inherits
[11:03:25.053]             invokeRestart <- base::invokeRestart
[11:03:25.053]             length <- base::length
[11:03:25.053]             list <- base::list
[11:03:25.053]             seq.int <- base::seq.int
[11:03:25.053]             signalCondition <- base::signalCondition
[11:03:25.053]             sys.calls <- base::sys.calls
[11:03:25.053]             `[[` <- base::`[[`
[11:03:25.053]             `+` <- base::`+`
[11:03:25.053]             `<<-` <- base::`<<-`
[11:03:25.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.053]                   3L)]
[11:03:25.053]             }
[11:03:25.053]             function(cond) {
[11:03:25.053]                 is_error <- inherits(cond, "error")
[11:03:25.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.053]                   NULL)
[11:03:25.053]                 if (is_error) {
[11:03:25.053]                   sessionInformation <- function() {
[11:03:25.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.053]                       search = base::search(), system = base::Sys.info())
[11:03:25.053]                   }
[11:03:25.053]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.053]                     cond$call), session = sessionInformation(), 
[11:03:25.053]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.053]                   signalCondition(cond)
[11:03:25.053]                 }
[11:03:25.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.053]                 "immediateCondition"))) {
[11:03:25.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.053]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.053]                   if (TRUE && !signal) {
[11:03:25.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.053]                     {
[11:03:25.053]                       inherits <- base::inherits
[11:03:25.053]                       invokeRestart <- base::invokeRestart
[11:03:25.053]                       is.null <- base::is.null
[11:03:25.053]                       muffled <- FALSE
[11:03:25.053]                       if (inherits(cond, "message")) {
[11:03:25.053]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.053]                         if (muffled) 
[11:03:25.053]                           invokeRestart("muffleMessage")
[11:03:25.053]                       }
[11:03:25.053]                       else if (inherits(cond, "warning")) {
[11:03:25.053]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.053]                         if (muffled) 
[11:03:25.053]                           invokeRestart("muffleWarning")
[11:03:25.053]                       }
[11:03:25.053]                       else if (inherits(cond, "condition")) {
[11:03:25.053]                         if (!is.null(pattern)) {
[11:03:25.053]                           computeRestarts <- base::computeRestarts
[11:03:25.053]                           grepl <- base::grepl
[11:03:25.053]                           restarts <- computeRestarts(cond)
[11:03:25.053]                           for (restart in restarts) {
[11:03:25.053]                             name <- restart$name
[11:03:25.053]                             if (is.null(name)) 
[11:03:25.053]                               next
[11:03:25.053]                             if (!grepl(pattern, name)) 
[11:03:25.053]                               next
[11:03:25.053]                             invokeRestart(restart)
[11:03:25.053]                             muffled <- TRUE
[11:03:25.053]                             break
[11:03:25.053]                           }
[11:03:25.053]                         }
[11:03:25.053]                       }
[11:03:25.053]                       invisible(muffled)
[11:03:25.053]                     }
[11:03:25.053]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.053]                   }
[11:03:25.053]                 }
[11:03:25.053]                 else {
[11:03:25.053]                   if (TRUE) {
[11:03:25.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.053]                     {
[11:03:25.053]                       inherits <- base::inherits
[11:03:25.053]                       invokeRestart <- base::invokeRestart
[11:03:25.053]                       is.null <- base::is.null
[11:03:25.053]                       muffled <- FALSE
[11:03:25.053]                       if (inherits(cond, "message")) {
[11:03:25.053]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.053]                         if (muffled) 
[11:03:25.053]                           invokeRestart("muffleMessage")
[11:03:25.053]                       }
[11:03:25.053]                       else if (inherits(cond, "warning")) {
[11:03:25.053]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.053]                         if (muffled) 
[11:03:25.053]                           invokeRestart("muffleWarning")
[11:03:25.053]                       }
[11:03:25.053]                       else if (inherits(cond, "condition")) {
[11:03:25.053]                         if (!is.null(pattern)) {
[11:03:25.053]                           computeRestarts <- base::computeRestarts
[11:03:25.053]                           grepl <- base::grepl
[11:03:25.053]                           restarts <- computeRestarts(cond)
[11:03:25.053]                           for (restart in restarts) {
[11:03:25.053]                             name <- restart$name
[11:03:25.053]                             if (is.null(name)) 
[11:03:25.053]                               next
[11:03:25.053]                             if (!grepl(pattern, name)) 
[11:03:25.053]                               next
[11:03:25.053]                             invokeRestart(restart)
[11:03:25.053]                             muffled <- TRUE
[11:03:25.053]                             break
[11:03:25.053]                           }
[11:03:25.053]                         }
[11:03:25.053]                       }
[11:03:25.053]                       invisible(muffled)
[11:03:25.053]                     }
[11:03:25.053]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.053]                   }
[11:03:25.053]                 }
[11:03:25.053]             }
[11:03:25.053]         }))
[11:03:25.053]     }, error = function(ex) {
[11:03:25.053]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.053]                 ...future.rng), started = ...future.startTime, 
[11:03:25.053]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.053]             version = "1.8"), class = "FutureResult")
[11:03:25.053]     }, finally = {
[11:03:25.053]         if (!identical(...future.workdir, getwd())) 
[11:03:25.053]             setwd(...future.workdir)
[11:03:25.053]         {
[11:03:25.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.053]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.053]             }
[11:03:25.053]             base::options(...future.oldOptions)
[11:03:25.053]             if (.Platform$OS.type == "windows") {
[11:03:25.053]                 old_names <- names(...future.oldEnvVars)
[11:03:25.053]                 envs <- base::Sys.getenv()
[11:03:25.053]                 names <- names(envs)
[11:03:25.053]                 common <- intersect(names, old_names)
[11:03:25.053]                 added <- setdiff(names, old_names)
[11:03:25.053]                 removed <- setdiff(old_names, names)
[11:03:25.053]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.053]                   envs[common]]
[11:03:25.053]                 NAMES <- toupper(changed)
[11:03:25.053]                 args <- list()
[11:03:25.053]                 for (kk in seq_along(NAMES)) {
[11:03:25.053]                   name <- changed[[kk]]
[11:03:25.053]                   NAME <- NAMES[[kk]]
[11:03:25.053]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.053]                     next
[11:03:25.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.053]                 }
[11:03:25.053]                 NAMES <- toupper(added)
[11:03:25.053]                 for (kk in seq_along(NAMES)) {
[11:03:25.053]                   name <- added[[kk]]
[11:03:25.053]                   NAME <- NAMES[[kk]]
[11:03:25.053]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.053]                     next
[11:03:25.053]                   args[[name]] <- ""
[11:03:25.053]                 }
[11:03:25.053]                 NAMES <- toupper(removed)
[11:03:25.053]                 for (kk in seq_along(NAMES)) {
[11:03:25.053]                   name <- removed[[kk]]
[11:03:25.053]                   NAME <- NAMES[[kk]]
[11:03:25.053]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.053]                     next
[11:03:25.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.053]                 }
[11:03:25.053]                 if (length(args) > 0) 
[11:03:25.053]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.053]             }
[11:03:25.053]             else {
[11:03:25.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.053]             }
[11:03:25.053]             {
[11:03:25.053]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.053]                   0L) {
[11:03:25.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.053]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.053]                   base::options(opts)
[11:03:25.053]                 }
[11:03:25.053]                 {
[11:03:25.053]                   {
[11:03:25.053]                     NULL
[11:03:25.053]                     RNGkind("Mersenne-Twister")
[11:03:25.053]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:03:25.053]                       inherits = FALSE)
[11:03:25.053]                   }
[11:03:25.053]                   options(future.plan = NULL)
[11:03:25.053]                   if (is.na(NA_character_)) 
[11:03:25.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.053]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.053]                     .init = FALSE)
[11:03:25.053]                 }
[11:03:25.053]             }
[11:03:25.053]         }
[11:03:25.053]     })
[11:03:25.053]     if (TRUE) {
[11:03:25.053]         base::sink(type = "output", split = FALSE)
[11:03:25.053]         if (TRUE) {
[11:03:25.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.053]         }
[11:03:25.053]         else {
[11:03:25.053]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.053]         }
[11:03:25.053]         base::close(...future.stdout)
[11:03:25.053]         ...future.stdout <- NULL
[11:03:25.053]     }
[11:03:25.053]     ...future.result$conditions <- ...future.conditions
[11:03:25.053]     ...future.result$finished <- base::Sys.time()
[11:03:25.053]     ...future.result
[11:03:25.053] }
[11:03:25.055] plan(): Setting new future strategy stack:
[11:03:25.055] List of future strategies:
[11:03:25.055] 1. sequential:
[11:03:25.055]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.055]    - tweaked: FALSE
[11:03:25.055]    - call: NULL
[11:03:25.055] plan(): nbrOfWorkers() = 1
[11:03:25.056] plan(): Setting new future strategy stack:
[11:03:25.056] List of future strategies:
[11:03:25.056] 1. sequential:
[11:03:25.056]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.056]    - tweaked: FALSE
[11:03:25.056]    - call: plan(strategy)
[11:03:25.057] plan(): nbrOfWorkers() = 1
[11:03:25.057] SequentialFuture started (and completed)
[11:03:25.057] - Launch lazy future ... done
[11:03:25.057] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = NA
[11:03:25.057] getGlobalsAndPackages() ...
[11:03:25.057] Searching for globals...
[11:03:25.060] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.060] Searching for globals ... DONE
[11:03:25.060] Resolving globals: FALSE
[11:03:25.061] 
[11:03:25.061] - packages: [1] ‘utils’
[11:03:25.061] getGlobalsAndPackages() ... DONE
[11:03:25.061] run() for ‘Future’ ...
[11:03:25.061] - state: ‘created’
[11:03:25.061] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:03:25.061] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:03:25.062] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:03:25.062]   - Field: ‘label’
[11:03:25.062]   - Field: ‘local’
[11:03:25.062]   - Field: ‘owner’
[11:03:25.062]   - Field: ‘envir’
[11:03:25.062]   - Field: ‘packages’
[11:03:25.062]   - Field: ‘gc’
[11:03:25.062]   - Field: ‘conditions’
[11:03:25.062]   - Field: ‘expr’
[11:03:25.062]   - Field: ‘uuid’
[11:03:25.062]   - Field: ‘seed’
[11:03:25.062]   - Field: ‘version’
[11:03:25.063]   - Field: ‘result’
[11:03:25.063]   - Field: ‘asynchronous’
[11:03:25.063]   - Field: ‘calls’
[11:03:25.063]   - Field: ‘globals’
[11:03:25.063]   - Field: ‘stdout’
[11:03:25.063]   - Field: ‘earlySignal’
[11:03:25.063]   - Field: ‘lazy’
[11:03:25.063]   - Field: ‘state’
[11:03:25.063] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:03:25.063] - Launch lazy future ...
[11:03:25.063] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.064] Packages needed by future strategies (n = 0): <none>
[11:03:25.064] {
[11:03:25.064]     {
[11:03:25.064]         {
[11:03:25.064]             ...future.startTime <- base::Sys.time()
[11:03:25.064]             {
[11:03:25.064]                 {
[11:03:25.064]                   {
[11:03:25.064]                     {
[11:03:25.064]                       base::local({
[11:03:25.064]                         has_future <- base::requireNamespace("future", 
[11:03:25.064]                           quietly = TRUE)
[11:03:25.064]                         if (has_future) {
[11:03:25.064]                           ns <- base::getNamespace("future")
[11:03:25.064]                           version <- ns[[".package"]][["version"]]
[11:03:25.064]                           if (is.null(version)) 
[11:03:25.064]                             version <- utils::packageVersion("future")
[11:03:25.064]                         }
[11:03:25.064]                         else {
[11:03:25.064]                           version <- NULL
[11:03:25.064]                         }
[11:03:25.064]                         if (!has_future || version < "1.8.0") {
[11:03:25.064]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.064]                             "", base::R.version$version.string), 
[11:03:25.064]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:25.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.064]                               "release", "version")], collapse = " "), 
[11:03:25.064]                             hostname = base::Sys.info()[["nodename"]])
[11:03:25.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.064]                             info)
[11:03:25.064]                           info <- base::paste(info, collapse = "; ")
[11:03:25.064]                           if (!has_future) {
[11:03:25.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.064]                               info)
[11:03:25.064]                           }
[11:03:25.064]                           else {
[11:03:25.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.064]                               info, version)
[11:03:25.064]                           }
[11:03:25.064]                           base::stop(msg)
[11:03:25.064]                         }
[11:03:25.064]                       })
[11:03:25.064]                     }
[11:03:25.064]                     base::local({
[11:03:25.064]                       for (pkg in "utils") {
[11:03:25.064]                         base::loadNamespace(pkg)
[11:03:25.064]                         base::library(pkg, character.only = TRUE)
[11:03:25.064]                       }
[11:03:25.064]                     })
[11:03:25.064]                   }
[11:03:25.064]                   ...future.strategy.old <- future::plan("list")
[11:03:25.064]                   options(future.plan = NULL)
[11:03:25.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.064]                 }
[11:03:25.064]                 ...future.workdir <- getwd()
[11:03:25.064]             }
[11:03:25.064]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.064]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.064]         }
[11:03:25.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.064]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.064]             base::names(...future.oldOptions))
[11:03:25.064]     }
[11:03:25.064]     if (TRUE) {
[11:03:25.064]     }
[11:03:25.064]     else {
[11:03:25.064]         if (NA) {
[11:03:25.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.064]                 open = "w")
[11:03:25.064]         }
[11:03:25.064]         else {
[11:03:25.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.064]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.064]         }
[11:03:25.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.064]             base::sink(type = "output", split = FALSE)
[11:03:25.064]             base::close(...future.stdout)
[11:03:25.064]         }, add = TRUE)
[11:03:25.064]     }
[11:03:25.064]     ...future.frame <- base::sys.nframe()
[11:03:25.064]     ...future.conditions <- base::list()
[11:03:25.064]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.064]     if (FALSE) {
[11:03:25.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.064]     }
[11:03:25.064]     ...future.result <- base::tryCatch({
[11:03:25.064]         base::withCallingHandlers({
[11:03:25.064]             ...future.value <- base::withVisible(base::local({
[11:03:25.064]                 print(1:50)
[11:03:25.064]                 str(1:50)
[11:03:25.064]                 cat(letters, sep = "-")
[11:03:25.064]                 cat(1:6, collapse = "\n")
[11:03:25.064]                 write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.064]                 42L
[11:03:25.064]             }))
[11:03:25.064]             future::FutureResult(value = ...future.value$value, 
[11:03:25.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.064]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.064]                     ...future.globalenv.names))
[11:03:25.064]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.064]         }, condition = base::local({
[11:03:25.064]             c <- base::c
[11:03:25.064]             inherits <- base::inherits
[11:03:25.064]             invokeRestart <- base::invokeRestart
[11:03:25.064]             length <- base::length
[11:03:25.064]             list <- base::list
[11:03:25.064]             seq.int <- base::seq.int
[11:03:25.064]             signalCondition <- base::signalCondition
[11:03:25.064]             sys.calls <- base::sys.calls
[11:03:25.064]             `[[` <- base::`[[`
[11:03:25.064]             `+` <- base::`+`
[11:03:25.064]             `<<-` <- base::`<<-`
[11:03:25.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.064]                   3L)]
[11:03:25.064]             }
[11:03:25.064]             function(cond) {
[11:03:25.064]                 is_error <- inherits(cond, "error")
[11:03:25.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.064]                   NULL)
[11:03:25.064]                 if (is_error) {
[11:03:25.064]                   sessionInformation <- function() {
[11:03:25.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.064]                       search = base::search(), system = base::Sys.info())
[11:03:25.064]                   }
[11:03:25.064]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.064]                     cond$call), session = sessionInformation(), 
[11:03:25.064]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.064]                   signalCondition(cond)
[11:03:25.064]                 }
[11:03:25.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.064]                 "immediateCondition"))) {
[11:03:25.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.064]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.064]                   if (TRUE && !signal) {
[11:03:25.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.064]                     {
[11:03:25.064]                       inherits <- base::inherits
[11:03:25.064]                       invokeRestart <- base::invokeRestart
[11:03:25.064]                       is.null <- base::is.null
[11:03:25.064]                       muffled <- FALSE
[11:03:25.064]                       if (inherits(cond, "message")) {
[11:03:25.064]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.064]                         if (muffled) 
[11:03:25.064]                           invokeRestart("muffleMessage")
[11:03:25.064]                       }
[11:03:25.064]                       else if (inherits(cond, "warning")) {
[11:03:25.064]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.064]                         if (muffled) 
[11:03:25.064]                           invokeRestart("muffleWarning")
[11:03:25.064]                       }
[11:03:25.064]                       else if (inherits(cond, "condition")) {
[11:03:25.064]                         if (!is.null(pattern)) {
[11:03:25.064]                           computeRestarts <- base::computeRestarts
[11:03:25.064]                           grepl <- base::grepl
[11:03:25.064]                           restarts <- computeRestarts(cond)
[11:03:25.064]                           for (restart in restarts) {
[11:03:25.064]                             name <- restart$name
[11:03:25.064]                             if (is.null(name)) 
[11:03:25.064]                               next
[11:03:25.064]                             if (!grepl(pattern, name)) 
[11:03:25.064]                               next
[11:03:25.064]                             invokeRestart(restart)
[11:03:25.064]                             muffled <- TRUE
[11:03:25.064]                             break
[11:03:25.064]                           }
[11:03:25.064]                         }
[11:03:25.064]                       }
[11:03:25.064]                       invisible(muffled)
[11:03:25.064]                     }
[11:03:25.064]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.064]                   }
[11:03:25.064]                 }
[11:03:25.064]                 else {
[11:03:25.064]                   if (TRUE) {
[11:03:25.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.064]                     {
[11:03:25.064]                       inherits <- base::inherits
[11:03:25.064]                       invokeRestart <- base::invokeRestart
[11:03:25.064]                       is.null <- base::is.null
[11:03:25.064]                       muffled <- FALSE
[11:03:25.064]                       if (inherits(cond, "message")) {
[11:03:25.064]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.064]                         if (muffled) 
[11:03:25.064]                           invokeRestart("muffleMessage")
[11:03:25.064]                       }
[11:03:25.064]                       else if (inherits(cond, "warning")) {
[11:03:25.064]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.064]                         if (muffled) 
[11:03:25.064]                           invokeRestart("muffleWarning")
[11:03:25.064]                       }
[11:03:25.064]                       else if (inherits(cond, "condition")) {
[11:03:25.064]                         if (!is.null(pattern)) {
[11:03:25.064]                           computeRestarts <- base::computeRestarts
[11:03:25.064]                           grepl <- base::grepl
[11:03:25.064]                           restarts <- computeRestarts(cond)
[11:03:25.064]                           for (restart in restarts) {
[11:03:25.064]                             name <- restart$name
[11:03:25.064]                             if (is.null(name)) 
[11:03:25.064]                               next
[11:03:25.064]                             if (!grepl(pattern, name)) 
[11:03:25.064]                               next
[11:03:25.064]                             invokeRestart(restart)
[11:03:25.064]                             muffled <- TRUE
[11:03:25.064]                             break
[11:03:25.064]                           }
[11:03:25.064]                         }
[11:03:25.064]                       }
[11:03:25.064]                       invisible(muffled)
[11:03:25.064]                     }
[11:03:25.064]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.064]                   }
[11:03:25.064]                 }
[11:03:25.064]             }
[11:03:25.064]         }))
[11:03:25.064]     }, error = function(ex) {
[11:03:25.064]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.064]                 ...future.rng), started = ...future.startTime, 
[11:03:25.064]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.064]             version = "1.8"), class = "FutureResult")
[11:03:25.064]     }, finally = {
[11:03:25.064]         if (!identical(...future.workdir, getwd())) 
[11:03:25.064]             setwd(...future.workdir)
[11:03:25.064]         {
[11:03:25.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.064]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.064]             }
[11:03:25.064]             base::options(...future.oldOptions)
[11:03:25.064]             if (.Platform$OS.type == "windows") {
[11:03:25.064]                 old_names <- names(...future.oldEnvVars)
[11:03:25.064]                 envs <- base::Sys.getenv()
[11:03:25.064]                 names <- names(envs)
[11:03:25.064]                 common <- intersect(names, old_names)
[11:03:25.064]                 added <- setdiff(names, old_names)
[11:03:25.064]                 removed <- setdiff(old_names, names)
[11:03:25.064]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.064]                   envs[common]]
[11:03:25.064]                 NAMES <- toupper(changed)
[11:03:25.064]                 args <- list()
[11:03:25.064]                 for (kk in seq_along(NAMES)) {
[11:03:25.064]                   name <- changed[[kk]]
[11:03:25.064]                   NAME <- NAMES[[kk]]
[11:03:25.064]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.064]                     next
[11:03:25.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.064]                 }
[11:03:25.064]                 NAMES <- toupper(added)
[11:03:25.064]                 for (kk in seq_along(NAMES)) {
[11:03:25.064]                   name <- added[[kk]]
[11:03:25.064]                   NAME <- NAMES[[kk]]
[11:03:25.064]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.064]                     next
[11:03:25.064]                   args[[name]] <- ""
[11:03:25.064]                 }
[11:03:25.064]                 NAMES <- toupper(removed)
[11:03:25.064]                 for (kk in seq_along(NAMES)) {
[11:03:25.064]                   name <- removed[[kk]]
[11:03:25.064]                   NAME <- NAMES[[kk]]
[11:03:25.064]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.064]                     next
[11:03:25.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.064]                 }
[11:03:25.064]                 if (length(args) > 0) 
[11:03:25.064]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.064]             }
[11:03:25.064]             else {
[11:03:25.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.064]             }
[11:03:25.064]             {
[11:03:25.064]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.064]                   0L) {
[11:03:25.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.064]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.064]                   base::options(opts)
[11:03:25.064]                 }
[11:03:25.064]                 {
[11:03:25.064]                   {
[11:03:25.064]                     NULL
[11:03:25.064]                     RNGkind("Mersenne-Twister")
[11:03:25.064]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:03:25.064]                       inherits = FALSE)
[11:03:25.064]                   }
[11:03:25.064]                   options(future.plan = NULL)
[11:03:25.064]                   if (is.na(NA_character_)) 
[11:03:25.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.064]                     .init = FALSE)
[11:03:25.064]                 }
[11:03:25.064]             }
[11:03:25.064]         }
[11:03:25.064]     })
[11:03:25.064]     if (FALSE) {
[11:03:25.064]         base::sink(type = "output", split = FALSE)
[11:03:25.064]         if (NA) {
[11:03:25.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.064]         }
[11:03:25.064]         else {
[11:03:25.064]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.064]         }
[11:03:25.064]         base::close(...future.stdout)
[11:03:25.064]         ...future.stdout <- NULL
[11:03:25.064]     }
[11:03:25.064]     ...future.result$conditions <- ...future.conditions
[11:03:25.064]     ...future.result$finished <- base::Sys.time()
[11:03:25.064]     ...future.result
[11:03:25.064] }
[11:03:25.066] plan(): Setting new future strategy stack:
[11:03:25.066] List of future strategies:
[11:03:25.066] 1. sequential:
[11:03:25.066]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.066]    - tweaked: FALSE
[11:03:25.066]    - call: NULL
[11:03:25.066] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[11:03:25.068] plan(): Setting new future strategy stack:
[11:03:25.068] List of future strategies:
[11:03:25.068] 1. sequential:
[11:03:25.068]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.068]    - tweaked: FALSE
[11:03:25.068]    - call: plan(strategy)
[11:03:25.068] plan(): nbrOfWorkers() = 1
[11:03:25.068] SequentialFuture started (and completed)
[11:03:25.068] - Launch lazy future ... done
[11:03:25.068] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ finished    : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ session_uuid: chr "861151cf-a595-47bd-b6ac-be12af3eb978"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "173ee284ba16"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 84989
  .. ..$ time  : POSIXct[1:1], format: "2025-05-06 11:03:24"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[11:03:25.076] getGlobalsAndPackages() ...
[11:03:25.076] Searching for globals...
[11:03:25.079] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.079] Searching for globals ... DONE
[11:03:25.079] Resolving globals: FALSE
[11:03:25.080] 
[11:03:25.080] - packages: [1] ‘utils’
[11:03:25.080] getGlobalsAndPackages() ... DONE
[11:03:25.080] run() for ‘Future’ ...
[11:03:25.080] - state: ‘created’
[11:03:25.080] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:03:25.081] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:03:25.081] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:03:25.081]   - Field: ‘label’
[11:03:25.081]   - Field: ‘local’
[11:03:25.081]   - Field: ‘owner’
[11:03:25.081]   - Field: ‘envir’
[11:03:25.081]   - Field: ‘packages’
[11:03:25.081]   - Field: ‘gc’
[11:03:25.081]   - Field: ‘conditions’
[11:03:25.081]   - Field: ‘expr’
[11:03:25.081]   - Field: ‘uuid’
[11:03:25.081]   - Field: ‘seed’
[11:03:25.082]   - Field: ‘version’
[11:03:25.082]   - Field: ‘result’
[11:03:25.082]   - Field: ‘asynchronous’
[11:03:25.082]   - Field: ‘calls’
[11:03:25.082]   - Field: ‘globals’
[11:03:25.082]   - Field: ‘stdout’
[11:03:25.082]   - Field: ‘earlySignal’
[11:03:25.082]   - Field: ‘lazy’
[11:03:25.082]   - Field: ‘state’
[11:03:25.082] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:03:25.082] - Launch lazy future ...
[11:03:25.083] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.083] Packages needed by future strategies (n = 0): <none>
[11:03:25.083] {
[11:03:25.083]     {
[11:03:25.083]         {
[11:03:25.083]             ...future.startTime <- base::Sys.time()
[11:03:25.083]             {
[11:03:25.083]                 {
[11:03:25.083]                   {
[11:03:25.083]                     {
[11:03:25.083]                       base::local({
[11:03:25.083]                         has_future <- base::requireNamespace("future", 
[11:03:25.083]                           quietly = TRUE)
[11:03:25.083]                         if (has_future) {
[11:03:25.083]                           ns <- base::getNamespace("future")
[11:03:25.083]                           version <- ns[[".package"]][["version"]]
[11:03:25.083]                           if (is.null(version)) 
[11:03:25.083]                             version <- utils::packageVersion("future")
[11:03:25.083]                         }
[11:03:25.083]                         else {
[11:03:25.083]                           version <- NULL
[11:03:25.083]                         }
[11:03:25.083]                         if (!has_future || version < "1.8.0") {
[11:03:25.083]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.083]                             "", base::R.version$version.string), 
[11:03:25.083]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:25.083]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.083]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.083]                               "release", "version")], collapse = " "), 
[11:03:25.083]                             hostname = base::Sys.info()[["nodename"]])
[11:03:25.083]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.083]                             info)
[11:03:25.083]                           info <- base::paste(info, collapse = "; ")
[11:03:25.083]                           if (!has_future) {
[11:03:25.083]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.083]                               info)
[11:03:25.083]                           }
[11:03:25.083]                           else {
[11:03:25.083]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.083]                               info, version)
[11:03:25.083]                           }
[11:03:25.083]                           base::stop(msg)
[11:03:25.083]                         }
[11:03:25.083]                       })
[11:03:25.083]                     }
[11:03:25.083]                     base::local({
[11:03:25.083]                       for (pkg in "utils") {
[11:03:25.083]                         base::loadNamespace(pkg)
[11:03:25.083]                         base::library(pkg, character.only = TRUE)
[11:03:25.083]                       }
[11:03:25.083]                     })
[11:03:25.083]                   }
[11:03:25.083]                   ...future.strategy.old <- future::plan("list")
[11:03:25.083]                   options(future.plan = NULL)
[11:03:25.083]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.083]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.083]                 }
[11:03:25.083]                 ...future.workdir <- getwd()
[11:03:25.083]             }
[11:03:25.083]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.083]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.083]         }
[11:03:25.083]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.083]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.083]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.083]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.083]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.083]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.083]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.083]             base::names(...future.oldOptions))
[11:03:25.083]     }
[11:03:25.083]     if (TRUE) {
[11:03:25.083]     }
[11:03:25.083]     else {
[11:03:25.083]         if (NA) {
[11:03:25.083]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.083]                 open = "w")
[11:03:25.083]         }
[11:03:25.083]         else {
[11:03:25.083]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.083]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.083]         }
[11:03:25.083]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.083]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.083]             base::sink(type = "output", split = FALSE)
[11:03:25.083]             base::close(...future.stdout)
[11:03:25.083]         }, add = TRUE)
[11:03:25.083]     }
[11:03:25.083]     ...future.frame <- base::sys.nframe()
[11:03:25.083]     ...future.conditions <- base::list()
[11:03:25.083]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.083]     if (FALSE) {
[11:03:25.083]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.083]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.083]     }
[11:03:25.083]     ...future.result <- base::tryCatch({
[11:03:25.083]         base::withCallingHandlers({
[11:03:25.083]             ...future.value <- base::withVisible(base::local({
[11:03:25.083]                 print(1:50)
[11:03:25.083]                 str(1:50)
[11:03:25.083]                 cat(letters, sep = "-")
[11:03:25.083]                 cat(1:6, collapse = "\n")
[11:03:25.083]                 write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.083]                 42L
[11:03:25.083]             }))
[11:03:25.083]             future::FutureResult(value = ...future.value$value, 
[11:03:25.083]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.083]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.083]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.083]                     ...future.globalenv.names))
[11:03:25.083]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.083]         }, condition = base::local({
[11:03:25.083]             c <- base::c
[11:03:25.083]             inherits <- base::inherits
[11:03:25.083]             invokeRestart <- base::invokeRestart
[11:03:25.083]             length <- base::length
[11:03:25.083]             list <- base::list
[11:03:25.083]             seq.int <- base::seq.int
[11:03:25.083]             signalCondition <- base::signalCondition
[11:03:25.083]             sys.calls <- base::sys.calls
[11:03:25.083]             `[[` <- base::`[[`
[11:03:25.083]             `+` <- base::`+`
[11:03:25.083]             `<<-` <- base::`<<-`
[11:03:25.083]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.083]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.083]                   3L)]
[11:03:25.083]             }
[11:03:25.083]             function(cond) {
[11:03:25.083]                 is_error <- inherits(cond, "error")
[11:03:25.083]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.083]                   NULL)
[11:03:25.083]                 if (is_error) {
[11:03:25.083]                   sessionInformation <- function() {
[11:03:25.083]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.083]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.083]                       search = base::search(), system = base::Sys.info())
[11:03:25.083]                   }
[11:03:25.083]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.083]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.083]                     cond$call), session = sessionInformation(), 
[11:03:25.083]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.083]                   signalCondition(cond)
[11:03:25.083]                 }
[11:03:25.083]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.083]                 "immediateCondition"))) {
[11:03:25.083]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.083]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.083]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.083]                   if (TRUE && !signal) {
[11:03:25.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.083]                     {
[11:03:25.083]                       inherits <- base::inherits
[11:03:25.083]                       invokeRestart <- base::invokeRestart
[11:03:25.083]                       is.null <- base::is.null
[11:03:25.083]                       muffled <- FALSE
[11:03:25.083]                       if (inherits(cond, "message")) {
[11:03:25.083]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.083]                         if (muffled) 
[11:03:25.083]                           invokeRestart("muffleMessage")
[11:03:25.083]                       }
[11:03:25.083]                       else if (inherits(cond, "warning")) {
[11:03:25.083]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.083]                         if (muffled) 
[11:03:25.083]                           invokeRestart("muffleWarning")
[11:03:25.083]                       }
[11:03:25.083]                       else if (inherits(cond, "condition")) {
[11:03:25.083]                         if (!is.null(pattern)) {
[11:03:25.083]                           computeRestarts <- base::computeRestarts
[11:03:25.083]                           grepl <- base::grepl
[11:03:25.083]                           restarts <- computeRestarts(cond)
[11:03:25.083]                           for (restart in restarts) {
[11:03:25.083]                             name <- restart$name
[11:03:25.083]                             if (is.null(name)) 
[11:03:25.083]                               next
[11:03:25.083]                             if (!grepl(pattern, name)) 
[11:03:25.083]                               next
[11:03:25.083]                             invokeRestart(restart)
[11:03:25.083]                             muffled <- TRUE
[11:03:25.083]                             break
[11:03:25.083]                           }
[11:03:25.083]                         }
[11:03:25.083]                       }
[11:03:25.083]                       invisible(muffled)
[11:03:25.083]                     }
[11:03:25.083]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.083]                   }
[11:03:25.083]                 }
[11:03:25.083]                 else {
[11:03:25.083]                   if (TRUE) {
[11:03:25.083]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.083]                     {
[11:03:25.083]                       inherits <- base::inherits
[11:03:25.083]                       invokeRestart <- base::invokeRestart
[11:03:25.083]                       is.null <- base::is.null
[11:03:25.083]                       muffled <- FALSE
[11:03:25.083]                       if (inherits(cond, "message")) {
[11:03:25.083]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.083]                         if (muffled) 
[11:03:25.083]                           invokeRestart("muffleMessage")
[11:03:25.083]                       }
[11:03:25.083]                       else if (inherits(cond, "warning")) {
[11:03:25.083]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.083]                         if (muffled) 
[11:03:25.083]                           invokeRestart("muffleWarning")
[11:03:25.083]                       }
[11:03:25.083]                       else if (inherits(cond, "condition")) {
[11:03:25.083]                         if (!is.null(pattern)) {
[11:03:25.083]                           computeRestarts <- base::computeRestarts
[11:03:25.083]                           grepl <- base::grepl
[11:03:25.083]                           restarts <- computeRestarts(cond)
[11:03:25.083]                           for (restart in restarts) {
[11:03:25.083]                             name <- restart$name
[11:03:25.083]                             if (is.null(name)) 
[11:03:25.083]                               next
[11:03:25.083]                             if (!grepl(pattern, name)) 
[11:03:25.083]                               next
[11:03:25.083]                             invokeRestart(restart)
[11:03:25.083]                             muffled <- TRUE
[11:03:25.083]                             break
[11:03:25.083]                           }
[11:03:25.083]                         }
[11:03:25.083]                       }
[11:03:25.083]                       invisible(muffled)
[11:03:25.083]                     }
[11:03:25.083]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.083]                   }
[11:03:25.083]                 }
[11:03:25.083]             }
[11:03:25.083]         }))
[11:03:25.083]     }, error = function(ex) {
[11:03:25.083]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.083]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.083]                 ...future.rng), started = ...future.startTime, 
[11:03:25.083]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.083]             version = "1.8"), class = "FutureResult")
[11:03:25.083]     }, finally = {
[11:03:25.083]         if (!identical(...future.workdir, getwd())) 
[11:03:25.083]             setwd(...future.workdir)
[11:03:25.083]         {
[11:03:25.083]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.083]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.083]             }
[11:03:25.083]             base::options(...future.oldOptions)
[11:03:25.083]             if (.Platform$OS.type == "windows") {
[11:03:25.083]                 old_names <- names(...future.oldEnvVars)
[11:03:25.083]                 envs <- base::Sys.getenv()
[11:03:25.083]                 names <- names(envs)
[11:03:25.083]                 common <- intersect(names, old_names)
[11:03:25.083]                 added <- setdiff(names, old_names)
[11:03:25.083]                 removed <- setdiff(old_names, names)
[11:03:25.083]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.083]                   envs[common]]
[11:03:25.083]                 NAMES <- toupper(changed)
[11:03:25.083]                 args <- list()
[11:03:25.083]                 for (kk in seq_along(NAMES)) {
[11:03:25.083]                   name <- changed[[kk]]
[11:03:25.083]                   NAME <- NAMES[[kk]]
[11:03:25.083]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.083]                     next
[11:03:25.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.083]                 }
[11:03:25.083]                 NAMES <- toupper(added)
[11:03:25.083]                 for (kk in seq_along(NAMES)) {
[11:03:25.083]                   name <- added[[kk]]
[11:03:25.083]                   NAME <- NAMES[[kk]]
[11:03:25.083]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.083]                     next
[11:03:25.083]                   args[[name]] <- ""
[11:03:25.083]                 }
[11:03:25.083]                 NAMES <- toupper(removed)
[11:03:25.083]                 for (kk in seq_along(NAMES)) {
[11:03:25.083]                   name <- removed[[kk]]
[11:03:25.083]                   NAME <- NAMES[[kk]]
[11:03:25.083]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.083]                     next
[11:03:25.083]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.083]                 }
[11:03:25.083]                 if (length(args) > 0) 
[11:03:25.083]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.083]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.083]             }
[11:03:25.083]             else {
[11:03:25.083]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.083]             }
[11:03:25.083]             {
[11:03:25.083]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.083]                   0L) {
[11:03:25.083]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.083]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.083]                   base::options(opts)
[11:03:25.083]                 }
[11:03:25.083]                 {
[11:03:25.083]                   {
[11:03:25.083]                     NULL
[11:03:25.083]                     RNGkind("Mersenne-Twister")
[11:03:25.083]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:03:25.083]                       inherits = FALSE)
[11:03:25.083]                   }
[11:03:25.083]                   options(future.plan = NULL)
[11:03:25.083]                   if (is.na(NA_character_)) 
[11:03:25.083]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.083]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.083]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.083]                     .init = FALSE)
[11:03:25.083]                 }
[11:03:25.083]             }
[11:03:25.083]         }
[11:03:25.083]     })
[11:03:25.083]     if (FALSE) {
[11:03:25.083]         base::sink(type = "output", split = FALSE)
[11:03:25.083]         if (NA) {
[11:03:25.083]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.083]         }
[11:03:25.083]         else {
[11:03:25.083]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.083]         }
[11:03:25.083]         base::close(...future.stdout)
[11:03:25.083]         ...future.stdout <- NULL
[11:03:25.083]     }
[11:03:25.083]     ...future.result$conditions <- ...future.conditions
[11:03:25.083]     ...future.result$finished <- base::Sys.time()
[11:03:25.083]     ...future.result
[11:03:25.083] }
[11:03:25.085] plan(): Setting new future strategy stack:
[11:03:25.085] List of future strategies:
[11:03:25.085] 1. sequential:
[11:03:25.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.085]    - tweaked: FALSE
[11:03:25.085]    - call: NULL
[11:03:25.085] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[11:03:25.087] plan(): Setting new future strategy stack:
[11:03:25.087] List of future strategies:
[11:03:25.087] 1. sequential:
[11:03:25.087]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.087]    - tweaked: FALSE
[11:03:25.087]    - call: plan(strategy)
[11:03:25.087] plan(): nbrOfWorkers() = 1
[11:03:25.087] SequentialFuture started (and completed)
[11:03:25.087] - Launch lazy future ... done
[11:03:25.088] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[11:03:25.088] getGlobalsAndPackages() ...
[11:03:25.088] Searching for globals...
[11:03:25.088] - globals found: [1] ‘print’
[11:03:25.089] Searching for globals ... DONE
[11:03:25.089] Resolving globals: FALSE
[11:03:25.089] 
[11:03:25.089] 
[11:03:25.089] getGlobalsAndPackages() ... DONE
[11:03:25.089] run() for ‘Future’ ...
[11:03:25.089] - state: ‘created’
[11:03:25.089] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:03:25.090] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:03:25.090] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:03:25.090]   - Field: ‘label’
[11:03:25.090]   - Field: ‘local’
[11:03:25.090]   - Field: ‘owner’
[11:03:25.090]   - Field: ‘envir’
[11:03:25.090]   - Field: ‘packages’
[11:03:25.090]   - Field: ‘gc’
[11:03:25.090]   - Field: ‘conditions’
[11:03:25.090]   - Field: ‘expr’
[11:03:25.091]   - Field: ‘uuid’
[11:03:25.091]   - Field: ‘seed’
[11:03:25.091]   - Field: ‘version’
[11:03:25.091]   - Field: ‘result’
[11:03:25.091]   - Field: ‘asynchronous’
[11:03:25.091]   - Field: ‘calls’
[11:03:25.091]   - Field: ‘globals’
[11:03:25.091]   - Field: ‘stdout’
[11:03:25.091]   - Field: ‘earlySignal’
[11:03:25.091]   - Field: ‘lazy’
[11:03:25.091]   - Field: ‘state’
[11:03:25.091] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:03:25.091] - Launch lazy future ...
[11:03:25.092] Packages needed by the future expression (n = 0): <none>
[11:03:25.092] Packages needed by future strategies (n = 0): <none>
[11:03:25.092] {
[11:03:25.092]     {
[11:03:25.092]         {
[11:03:25.092]             ...future.startTime <- base::Sys.time()
[11:03:25.092]             {
[11:03:25.092]                 {
[11:03:25.092]                   {
[11:03:25.092]                     base::local({
[11:03:25.092]                       has_future <- base::requireNamespace("future", 
[11:03:25.092]                         quietly = TRUE)
[11:03:25.092]                       if (has_future) {
[11:03:25.092]                         ns <- base::getNamespace("future")
[11:03:25.092]                         version <- ns[[".package"]][["version"]]
[11:03:25.092]                         if (is.null(version)) 
[11:03:25.092]                           version <- utils::packageVersion("future")
[11:03:25.092]                       }
[11:03:25.092]                       else {
[11:03:25.092]                         version <- NULL
[11:03:25.092]                       }
[11:03:25.092]                       if (!has_future || version < "1.8.0") {
[11:03:25.092]                         info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.092]                           "", base::R.version$version.string), 
[11:03:25.092]                           platform = base::sprintf("%s (%s-bit)", 
[11:03:25.092]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.092]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.092]                             "release", "version")], collapse = " "), 
[11:03:25.092]                           hostname = base::Sys.info()[["nodename"]])
[11:03:25.092]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.092]                           info)
[11:03:25.092]                         info <- base::paste(info, collapse = "; ")
[11:03:25.092]                         if (!has_future) {
[11:03:25.092]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.092]                             info)
[11:03:25.092]                         }
[11:03:25.092]                         else {
[11:03:25.092]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.092]                             info, version)
[11:03:25.092]                         }
[11:03:25.092]                         base::stop(msg)
[11:03:25.092]                       }
[11:03:25.092]                     })
[11:03:25.092]                   }
[11:03:25.092]                   ...future.strategy.old <- future::plan("list")
[11:03:25.092]                   options(future.plan = NULL)
[11:03:25.092]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.092]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.092]                 }
[11:03:25.092]                 ...future.workdir <- getwd()
[11:03:25.092]             }
[11:03:25.092]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.092]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.092]         }
[11:03:25.092]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.092]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.092]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.092]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.092]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.092]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.092]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.092]             base::names(...future.oldOptions))
[11:03:25.092]     }
[11:03:25.092]     if (FALSE) {
[11:03:25.092]     }
[11:03:25.092]     else {
[11:03:25.092]         if (TRUE) {
[11:03:25.092]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.092]                 open = "w")
[11:03:25.092]         }
[11:03:25.092]         else {
[11:03:25.092]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.092]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.092]         }
[11:03:25.092]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.092]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.092]             base::sink(type = "output", split = FALSE)
[11:03:25.092]             base::close(...future.stdout)
[11:03:25.092]         }, add = TRUE)
[11:03:25.092]     }
[11:03:25.092]     ...future.frame <- base::sys.nframe()
[11:03:25.092]     ...future.conditions <- base::list()
[11:03:25.092]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.092]     if (FALSE) {
[11:03:25.092]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.092]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.092]     }
[11:03:25.092]     ...future.result <- base::tryCatch({
[11:03:25.092]         base::withCallingHandlers({
[11:03:25.092]             ...future.value <- base::withVisible(base::local(print(42)))
[11:03:25.092]             future::FutureResult(value = ...future.value$value, 
[11:03:25.092]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.092]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.092]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.092]                     ...future.globalenv.names))
[11:03:25.092]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.092]         }, condition = base::local({
[11:03:25.092]             c <- base::c
[11:03:25.092]             inherits <- base::inherits
[11:03:25.092]             invokeRestart <- base::invokeRestart
[11:03:25.092]             length <- base::length
[11:03:25.092]             list <- base::list
[11:03:25.092]             seq.int <- base::seq.int
[11:03:25.092]             signalCondition <- base::signalCondition
[11:03:25.092]             sys.calls <- base::sys.calls
[11:03:25.092]             `[[` <- base::`[[`
[11:03:25.092]             `+` <- base::`+`
[11:03:25.092]             `<<-` <- base::`<<-`
[11:03:25.092]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.092]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.092]                   3L)]
[11:03:25.092]             }
[11:03:25.092]             function(cond) {
[11:03:25.092]                 is_error <- inherits(cond, "error")
[11:03:25.092]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.092]                   NULL)
[11:03:25.092]                 if (is_error) {
[11:03:25.092]                   sessionInformation <- function() {
[11:03:25.092]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.092]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.092]                       search = base::search(), system = base::Sys.info())
[11:03:25.092]                   }
[11:03:25.092]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.092]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.092]                     cond$call), session = sessionInformation(), 
[11:03:25.092]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.092]                   signalCondition(cond)
[11:03:25.092]                 }
[11:03:25.092]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.092]                 "immediateCondition"))) {
[11:03:25.092]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.092]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.092]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.092]                   if (TRUE && !signal) {
[11:03:25.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.092]                     {
[11:03:25.092]                       inherits <- base::inherits
[11:03:25.092]                       invokeRestart <- base::invokeRestart
[11:03:25.092]                       is.null <- base::is.null
[11:03:25.092]                       muffled <- FALSE
[11:03:25.092]                       if (inherits(cond, "message")) {
[11:03:25.092]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.092]                         if (muffled) 
[11:03:25.092]                           invokeRestart("muffleMessage")
[11:03:25.092]                       }
[11:03:25.092]                       else if (inherits(cond, "warning")) {
[11:03:25.092]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.092]                         if (muffled) 
[11:03:25.092]                           invokeRestart("muffleWarning")
[11:03:25.092]                       }
[11:03:25.092]                       else if (inherits(cond, "condition")) {
[11:03:25.092]                         if (!is.null(pattern)) {
[11:03:25.092]                           computeRestarts <- base::computeRestarts
[11:03:25.092]                           grepl <- base::grepl
[11:03:25.092]                           restarts <- computeRestarts(cond)
[11:03:25.092]                           for (restart in restarts) {
[11:03:25.092]                             name <- restart$name
[11:03:25.092]                             if (is.null(name)) 
[11:03:25.092]                               next
[11:03:25.092]                             if (!grepl(pattern, name)) 
[11:03:25.092]                               next
[11:03:25.092]                             invokeRestart(restart)
[11:03:25.092]                             muffled <- TRUE
[11:03:25.092]                             break
[11:03:25.092]                           }
[11:03:25.092]                         }
[11:03:25.092]                       }
[11:03:25.092]                       invisible(muffled)
[11:03:25.092]                     }
[11:03:25.092]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.092]                   }
[11:03:25.092]                 }
[11:03:25.092]                 else {
[11:03:25.092]                   if (TRUE) {
[11:03:25.092]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.092]                     {
[11:03:25.092]                       inherits <- base::inherits
[11:03:25.092]                       invokeRestart <- base::invokeRestart
[11:03:25.092]                       is.null <- base::is.null
[11:03:25.092]                       muffled <- FALSE
[11:03:25.092]                       if (inherits(cond, "message")) {
[11:03:25.092]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.092]                         if (muffled) 
[11:03:25.092]                           invokeRestart("muffleMessage")
[11:03:25.092]                       }
[11:03:25.092]                       else if (inherits(cond, "warning")) {
[11:03:25.092]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.092]                         if (muffled) 
[11:03:25.092]                           invokeRestart("muffleWarning")
[11:03:25.092]                       }
[11:03:25.092]                       else if (inherits(cond, "condition")) {
[11:03:25.092]                         if (!is.null(pattern)) {
[11:03:25.092]                           computeRestarts <- base::computeRestarts
[11:03:25.092]                           grepl <- base::grepl
[11:03:25.092]                           restarts <- computeRestarts(cond)
[11:03:25.092]                           for (restart in restarts) {
[11:03:25.092]                             name <- restart$name
[11:03:25.092]                             if (is.null(name)) 
[11:03:25.092]                               next
[11:03:25.092]                             if (!grepl(pattern, name)) 
[11:03:25.092]                               next
[11:03:25.092]                             invokeRestart(restart)
[11:03:25.092]                             muffled <- TRUE
[11:03:25.092]                             break
[11:03:25.092]                           }
[11:03:25.092]                         }
[11:03:25.092]                       }
[11:03:25.092]                       invisible(muffled)
[11:03:25.092]                     }
[11:03:25.092]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.092]                   }
[11:03:25.092]                 }
[11:03:25.092]             }
[11:03:25.092]         }))
[11:03:25.092]     }, error = function(ex) {
[11:03:25.092]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.092]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.092]                 ...future.rng), started = ...future.startTime, 
[11:03:25.092]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.092]             version = "1.8"), class = "FutureResult")
[11:03:25.092]     }, finally = {
[11:03:25.092]         if (!identical(...future.workdir, getwd())) 
[11:03:25.092]             setwd(...future.workdir)
[11:03:25.092]         {
[11:03:25.092]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.092]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.092]             }
[11:03:25.092]             base::options(...future.oldOptions)
[11:03:25.092]             if (.Platform$OS.type == "windows") {
[11:03:25.092]                 old_names <- names(...future.oldEnvVars)
[11:03:25.092]                 envs <- base::Sys.getenv()
[11:03:25.092]                 names <- names(envs)
[11:03:25.092]                 common <- intersect(names, old_names)
[11:03:25.092]                 added <- setdiff(names, old_names)
[11:03:25.092]                 removed <- setdiff(old_names, names)
[11:03:25.092]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.092]                   envs[common]]
[11:03:25.092]                 NAMES <- toupper(changed)
[11:03:25.092]                 args <- list()
[11:03:25.092]                 for (kk in seq_along(NAMES)) {
[11:03:25.092]                   name <- changed[[kk]]
[11:03:25.092]                   NAME <- NAMES[[kk]]
[11:03:25.092]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.092]                     next
[11:03:25.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.092]                 }
[11:03:25.092]                 NAMES <- toupper(added)
[11:03:25.092]                 for (kk in seq_along(NAMES)) {
[11:03:25.092]                   name <- added[[kk]]
[11:03:25.092]                   NAME <- NAMES[[kk]]
[11:03:25.092]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.092]                     next
[11:03:25.092]                   args[[name]] <- ""
[11:03:25.092]                 }
[11:03:25.092]                 NAMES <- toupper(removed)
[11:03:25.092]                 for (kk in seq_along(NAMES)) {
[11:03:25.092]                   name <- removed[[kk]]
[11:03:25.092]                   NAME <- NAMES[[kk]]
[11:03:25.092]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.092]                     next
[11:03:25.092]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.092]                 }
[11:03:25.092]                 if (length(args) > 0) 
[11:03:25.092]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.092]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.092]             }
[11:03:25.092]             else {
[11:03:25.092]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.092]             }
[11:03:25.092]             {
[11:03:25.092]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.092]                   0L) {
[11:03:25.092]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.092]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.092]                   base::options(opts)
[11:03:25.092]                 }
[11:03:25.092]                 {
[11:03:25.092]                   {
[11:03:25.092]                     NULL
[11:03:25.092]                     RNGkind("Mersenne-Twister")
[11:03:25.092]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:03:25.092]                       inherits = FALSE)
[11:03:25.092]                   }
[11:03:25.092]                   options(future.plan = NULL)
[11:03:25.092]                   if (is.na(NA_character_)) 
[11:03:25.092]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.092]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.092]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.092]                     .init = FALSE)
[11:03:25.092]                 }
[11:03:25.092]             }
[11:03:25.092]         }
[11:03:25.092]     })
[11:03:25.092]     if (TRUE) {
[11:03:25.092]         base::sink(type = "output", split = FALSE)
[11:03:25.092]         if (TRUE) {
[11:03:25.092]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.092]         }
[11:03:25.092]         else {
[11:03:25.092]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.092]         }
[11:03:25.092]         base::close(...future.stdout)
[11:03:25.092]         ...future.stdout <- NULL
[11:03:25.092]     }
[11:03:25.092]     ...future.result$conditions <- ...future.conditions
[11:03:25.092]     ...future.result$finished <- base::Sys.time()
[11:03:25.092]     ...future.result
[11:03:25.092] }
[11:03:25.094] plan(): Setting new future strategy stack:
[11:03:25.094] List of future strategies:
[11:03:25.094] 1. sequential:
[11:03:25.094]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.094]    - tweaked: FALSE
[11:03:25.094]    - call: NULL
[11:03:25.094] plan(): nbrOfWorkers() = 1
[11:03:25.095] plan(): Setting new future strategy stack:
[11:03:25.095] List of future strategies:
[11:03:25.095] 1. sequential:
[11:03:25.095]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.095]    - tweaked: FALSE
[11:03:25.095]    - call: plan(strategy)
[11:03:25.095] plan(): nbrOfWorkers() = 1
[11:03:25.096] SequentialFuture started (and completed)
[11:03:25.096] - Launch lazy future ... done
[11:03:25.096] run() for ‘SequentialFuture’ ... done
[1] 42
sequential ... done
Testing with 1 cores ... done
Testing with 2 cores ...
multicore ...
[11:03:25.102] plan(): Setting new future strategy stack:
[11:03:25.102] List of future strategies:
[11:03:25.102] 1. multicore:
[11:03:25.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.102]    - tweaked: FALSE
[11:03:25.102]    - call: plan(strategy)
[11:03:25.103] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[11:03:25.104] getGlobalsAndPackages() ...
[11:03:25.104] Searching for globals...
[11:03:25.106] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.106] Searching for globals ... DONE
[11:03:25.106] Resolving globals: FALSE
[11:03:25.107] 
[11:03:25.107] - packages: [1] ‘utils’
[11:03:25.107] getGlobalsAndPackages() ... DONE
[11:03:25.107] run() for ‘Future’ ...
[11:03:25.107] - state: ‘created’
[11:03:25.107] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.109] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.109] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:03:25.109]   - Field: ‘label’
[11:03:25.109]   - Field: ‘local’
[11:03:25.109]   - Field: ‘owner’
[11:03:25.109]   - Field: ‘envir’
[11:03:25.110]   - Field: ‘workers’
[11:03:25.110]   - Field: ‘packages’
[11:03:25.110]   - Field: ‘gc’
[11:03:25.110]   - Field: ‘job’
[11:03:25.110]   - Field: ‘conditions’
[11:03:25.110]   - Field: ‘expr’
[11:03:25.110]   - Field: ‘uuid’
[11:03:25.110]   - Field: ‘seed’
[11:03:25.110]   - Field: ‘version’
[11:03:25.110]   - Field: ‘result’
[11:03:25.110]   - Field: ‘asynchronous’
[11:03:25.110]   - Field: ‘calls’
[11:03:25.110]   - Field: ‘globals’
[11:03:25.111]   - Field: ‘stdout’
[11:03:25.111]   - Field: ‘earlySignal’
[11:03:25.111]   - Field: ‘lazy’
[11:03:25.111]   - Field: ‘state’
[11:03:25.111] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:03:25.111] - Launch lazy future ...
[11:03:25.112] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.112] Packages needed by future strategies (n = 0): <none>
[11:03:25.112] {
[11:03:25.112]     {
[11:03:25.112]         {
[11:03:25.112]             ...future.startTime <- base::Sys.time()
[11:03:25.112]             {
[11:03:25.112]                 {
[11:03:25.112]                   {
[11:03:25.112]                     {
[11:03:25.112]                       {
[11:03:25.112]                         base::local({
[11:03:25.112]                           has_future <- base::requireNamespace("future", 
[11:03:25.112]                             quietly = TRUE)
[11:03:25.112]                           if (has_future) {
[11:03:25.112]                             ns <- base::getNamespace("future")
[11:03:25.112]                             version <- ns[[".package"]][["version"]]
[11:03:25.112]                             if (is.null(version)) 
[11:03:25.112]                               version <- utils::packageVersion("future")
[11:03:25.112]                           }
[11:03:25.112]                           else {
[11:03:25.112]                             version <- NULL
[11:03:25.112]                           }
[11:03:25.112]                           if (!has_future || version < "1.8.0") {
[11:03:25.112]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.112]                               "", base::R.version$version.string), 
[11:03:25.112]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:25.112]                                 base::R.version$platform, 8 * 
[11:03:25.112]                                   base::.Machine$sizeof.pointer), 
[11:03:25.112]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.112]                                 "release", "version")], collapse = " "), 
[11:03:25.112]                               hostname = base::Sys.info()[["nodename"]])
[11:03:25.112]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.112]                               info)
[11:03:25.112]                             info <- base::paste(info, collapse = "; ")
[11:03:25.112]                             if (!has_future) {
[11:03:25.112]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.112]                                 info)
[11:03:25.112]                             }
[11:03:25.112]                             else {
[11:03:25.112]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.112]                                 info, version)
[11:03:25.112]                             }
[11:03:25.112]                             base::stop(msg)
[11:03:25.112]                           }
[11:03:25.112]                         })
[11:03:25.112]                       }
[11:03:25.112]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.112]                       base::options(mc.cores = 1L)
[11:03:25.112]                     }
[11:03:25.112]                     base::local({
[11:03:25.112]                       for (pkg in "utils") {
[11:03:25.112]                         base::loadNamespace(pkg)
[11:03:25.112]                         base::library(pkg, character.only = TRUE)
[11:03:25.112]                       }
[11:03:25.112]                     })
[11:03:25.112]                   }
[11:03:25.112]                   ...future.strategy.old <- future::plan("list")
[11:03:25.112]                   options(future.plan = NULL)
[11:03:25.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.112]                 }
[11:03:25.112]                 ...future.workdir <- getwd()
[11:03:25.112]             }
[11:03:25.112]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.112]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.112]         }
[11:03:25.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.112]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.112]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.112]             base::names(...future.oldOptions))
[11:03:25.112]     }
[11:03:25.112]     if (FALSE) {
[11:03:25.112]     }
[11:03:25.112]     else {
[11:03:25.112]         if (TRUE) {
[11:03:25.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.112]                 open = "w")
[11:03:25.112]         }
[11:03:25.112]         else {
[11:03:25.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.112]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.112]         }
[11:03:25.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.112]             base::sink(type = "output", split = FALSE)
[11:03:25.112]             base::close(...future.stdout)
[11:03:25.112]         }, add = TRUE)
[11:03:25.112]     }
[11:03:25.112]     ...future.frame <- base::sys.nframe()
[11:03:25.112]     ...future.conditions <- base::list()
[11:03:25.112]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.112]     if (FALSE) {
[11:03:25.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.112]     }
[11:03:25.112]     ...future.result <- base::tryCatch({
[11:03:25.112]         base::withCallingHandlers({
[11:03:25.112]             ...future.value <- base::withVisible(base::local({
[11:03:25.112]                 withCallingHandlers({
[11:03:25.112]                   {
[11:03:25.112]                     print(1:50)
[11:03:25.112]                     str(1:50)
[11:03:25.112]                     cat(letters, sep = "-")
[11:03:25.112]                     cat(1:6, collapse = "\n")
[11:03:25.112]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.112]                     42L
[11:03:25.112]                   }
[11:03:25.112]                 }, immediateCondition = function(cond) {
[11:03:25.112]                   save_rds <- function (object, pathname, ...) 
[11:03:25.112]                   {
[11:03:25.112]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:03:25.112]                     if (file_test("-f", pathname_tmp)) {
[11:03:25.112]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.112]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:03:25.112]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.112]                         fi_tmp[["mtime"]])
[11:03:25.112]                     }
[11:03:25.112]                     tryCatch({
[11:03:25.112]                       saveRDS(object, file = pathname_tmp, ...)
[11:03:25.112]                     }, error = function(ex) {
[11:03:25.112]                       msg <- conditionMessage(ex)
[11:03:25.112]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.112]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:03:25.112]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.112]                         fi_tmp[["mtime"]], msg)
[11:03:25.112]                       ex$message <- msg
[11:03:25.112]                       stop(ex)
[11:03:25.112]                     })
[11:03:25.112]                     stopifnot(file_test("-f", pathname_tmp))
[11:03:25.112]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:03:25.112]                     if (!res || file_test("-f", pathname_tmp)) {
[11:03:25.112]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.112]                       fi <- file.info(pathname)
[11:03:25.112]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:03:25.112]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.112]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:03:25.112]                         fi[["size"]], fi[["mtime"]])
[11:03:25.112]                       stop(msg)
[11:03:25.112]                     }
[11:03:25.112]                     invisible(pathname)
[11:03:25.112]                   }
[11:03:25.112]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:03:25.112]                     rootPath = tempdir()) 
[11:03:25.112]                   {
[11:03:25.112]                     obj <- list(time = Sys.time(), condition = cond)
[11:03:25.112]                     file <- tempfile(pattern = class(cond)[1], 
[11:03:25.112]                       tmpdir = path, fileext = ".rds")
[11:03:25.112]                     save_rds(obj, file)
[11:03:25.112]                   }
[11:03:25.112]                   saveImmediateCondition(cond, path = "/tmp/RtmpjFuTgt/.future/immediateConditions")
[11:03:25.112]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.112]                   {
[11:03:25.112]                     inherits <- base::inherits
[11:03:25.112]                     invokeRestart <- base::invokeRestart
[11:03:25.112]                     is.null <- base::is.null
[11:03:25.112]                     muffled <- FALSE
[11:03:25.112]                     if (inherits(cond, "message")) {
[11:03:25.112]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.112]                       if (muffled) 
[11:03:25.112]                         invokeRestart("muffleMessage")
[11:03:25.112]                     }
[11:03:25.112]                     else if (inherits(cond, "warning")) {
[11:03:25.112]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.112]                       if (muffled) 
[11:03:25.112]                         invokeRestart("muffleWarning")
[11:03:25.112]                     }
[11:03:25.112]                     else if (inherits(cond, "condition")) {
[11:03:25.112]                       if (!is.null(pattern)) {
[11:03:25.112]                         computeRestarts <- base::computeRestarts
[11:03:25.112]                         grepl <- base::grepl
[11:03:25.112]                         restarts <- computeRestarts(cond)
[11:03:25.112]                         for (restart in restarts) {
[11:03:25.112]                           name <- restart$name
[11:03:25.112]                           if (is.null(name)) 
[11:03:25.112]                             next
[11:03:25.112]                           if (!grepl(pattern, name)) 
[11:03:25.112]                             next
[11:03:25.112]                           invokeRestart(restart)
[11:03:25.112]                           muffled <- TRUE
[11:03:25.112]                           break
[11:03:25.112]                         }
[11:03:25.112]                       }
[11:03:25.112]                     }
[11:03:25.112]                     invisible(muffled)
[11:03:25.112]                   }
[11:03:25.112]                   muffleCondition(cond)
[11:03:25.112]                 })
[11:03:25.112]             }))
[11:03:25.112]             future::FutureResult(value = ...future.value$value, 
[11:03:25.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.112]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.112]                     ...future.globalenv.names))
[11:03:25.112]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.112]         }, condition = base::local({
[11:03:25.112]             c <- base::c
[11:03:25.112]             inherits <- base::inherits
[11:03:25.112]             invokeRestart <- base::invokeRestart
[11:03:25.112]             length <- base::length
[11:03:25.112]             list <- base::list
[11:03:25.112]             seq.int <- base::seq.int
[11:03:25.112]             signalCondition <- base::signalCondition
[11:03:25.112]             sys.calls <- base::sys.calls
[11:03:25.112]             `[[` <- base::`[[`
[11:03:25.112]             `+` <- base::`+`
[11:03:25.112]             `<<-` <- base::`<<-`
[11:03:25.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.112]                   3L)]
[11:03:25.112]             }
[11:03:25.112]             function(cond) {
[11:03:25.112]                 is_error <- inherits(cond, "error")
[11:03:25.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.112]                   NULL)
[11:03:25.112]                 if (is_error) {
[11:03:25.112]                   sessionInformation <- function() {
[11:03:25.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.112]                       search = base::search(), system = base::Sys.info())
[11:03:25.112]                   }
[11:03:25.112]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.112]                     cond$call), session = sessionInformation(), 
[11:03:25.112]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.112]                   signalCondition(cond)
[11:03:25.112]                 }
[11:03:25.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.112]                 "immediateCondition"))) {
[11:03:25.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.112]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.112]                   if (TRUE && !signal) {
[11:03:25.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.112]                     {
[11:03:25.112]                       inherits <- base::inherits
[11:03:25.112]                       invokeRestart <- base::invokeRestart
[11:03:25.112]                       is.null <- base::is.null
[11:03:25.112]                       muffled <- FALSE
[11:03:25.112]                       if (inherits(cond, "message")) {
[11:03:25.112]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.112]                         if (muffled) 
[11:03:25.112]                           invokeRestart("muffleMessage")
[11:03:25.112]                       }
[11:03:25.112]                       else if (inherits(cond, "warning")) {
[11:03:25.112]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.112]                         if (muffled) 
[11:03:25.112]                           invokeRestart("muffleWarning")
[11:03:25.112]                       }
[11:03:25.112]                       else if (inherits(cond, "condition")) {
[11:03:25.112]                         if (!is.null(pattern)) {
[11:03:25.112]                           computeRestarts <- base::computeRestarts
[11:03:25.112]                           grepl <- base::grepl
[11:03:25.112]                           restarts <- computeRestarts(cond)
[11:03:25.112]                           for (restart in restarts) {
[11:03:25.112]                             name <- restart$name
[11:03:25.112]                             if (is.null(name)) 
[11:03:25.112]                               next
[11:03:25.112]                             if (!grepl(pattern, name)) 
[11:03:25.112]                               next
[11:03:25.112]                             invokeRestart(restart)
[11:03:25.112]                             muffled <- TRUE
[11:03:25.112]                             break
[11:03:25.112]                           }
[11:03:25.112]                         }
[11:03:25.112]                       }
[11:03:25.112]                       invisible(muffled)
[11:03:25.112]                     }
[11:03:25.112]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.112]                   }
[11:03:25.112]                 }
[11:03:25.112]                 else {
[11:03:25.112]                   if (TRUE) {
[11:03:25.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.112]                     {
[11:03:25.112]                       inherits <- base::inherits
[11:03:25.112]                       invokeRestart <- base::invokeRestart
[11:03:25.112]                       is.null <- base::is.null
[11:03:25.112]                       muffled <- FALSE
[11:03:25.112]                       if (inherits(cond, "message")) {
[11:03:25.112]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.112]                         if (muffled) 
[11:03:25.112]                           invokeRestart("muffleMessage")
[11:03:25.112]                       }
[11:03:25.112]                       else if (inherits(cond, "warning")) {
[11:03:25.112]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.112]                         if (muffled) 
[11:03:25.112]                           invokeRestart("muffleWarning")
[11:03:25.112]                       }
[11:03:25.112]                       else if (inherits(cond, "condition")) {
[11:03:25.112]                         if (!is.null(pattern)) {
[11:03:25.112]                           computeRestarts <- base::computeRestarts
[11:03:25.112]                           grepl <- base::grepl
[11:03:25.112]                           restarts <- computeRestarts(cond)
[11:03:25.112]                           for (restart in restarts) {
[11:03:25.112]                             name <- restart$name
[11:03:25.112]                             if (is.null(name)) 
[11:03:25.112]                               next
[11:03:25.112]                             if (!grepl(pattern, name)) 
[11:03:25.112]                               next
[11:03:25.112]                             invokeRestart(restart)
[11:03:25.112]                             muffled <- TRUE
[11:03:25.112]                             break
[11:03:25.112]                           }
[11:03:25.112]                         }
[11:03:25.112]                       }
[11:03:25.112]                       invisible(muffled)
[11:03:25.112]                     }
[11:03:25.112]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.112]                   }
[11:03:25.112]                 }
[11:03:25.112]             }
[11:03:25.112]         }))
[11:03:25.112]     }, error = function(ex) {
[11:03:25.112]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.112]                 ...future.rng), started = ...future.startTime, 
[11:03:25.112]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.112]             version = "1.8"), class = "FutureResult")
[11:03:25.112]     }, finally = {
[11:03:25.112]         if (!identical(...future.workdir, getwd())) 
[11:03:25.112]             setwd(...future.workdir)
[11:03:25.112]         {
[11:03:25.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.112]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.112]             }
[11:03:25.112]             base::options(...future.oldOptions)
[11:03:25.112]             if (.Platform$OS.type == "windows") {
[11:03:25.112]                 old_names <- names(...future.oldEnvVars)
[11:03:25.112]                 envs <- base::Sys.getenv()
[11:03:25.112]                 names <- names(envs)
[11:03:25.112]                 common <- intersect(names, old_names)
[11:03:25.112]                 added <- setdiff(names, old_names)
[11:03:25.112]                 removed <- setdiff(old_names, names)
[11:03:25.112]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.112]                   envs[common]]
[11:03:25.112]                 NAMES <- toupper(changed)
[11:03:25.112]                 args <- list()
[11:03:25.112]                 for (kk in seq_along(NAMES)) {
[11:03:25.112]                   name <- changed[[kk]]
[11:03:25.112]                   NAME <- NAMES[[kk]]
[11:03:25.112]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.112]                     next
[11:03:25.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.112]                 }
[11:03:25.112]                 NAMES <- toupper(added)
[11:03:25.112]                 for (kk in seq_along(NAMES)) {
[11:03:25.112]                   name <- added[[kk]]
[11:03:25.112]                   NAME <- NAMES[[kk]]
[11:03:25.112]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.112]                     next
[11:03:25.112]                   args[[name]] <- ""
[11:03:25.112]                 }
[11:03:25.112]                 NAMES <- toupper(removed)
[11:03:25.112]                 for (kk in seq_along(NAMES)) {
[11:03:25.112]                   name <- removed[[kk]]
[11:03:25.112]                   NAME <- NAMES[[kk]]
[11:03:25.112]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.112]                     next
[11:03:25.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.112]                 }
[11:03:25.112]                 if (length(args) > 0) 
[11:03:25.112]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.112]             }
[11:03:25.112]             else {
[11:03:25.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.112]             }
[11:03:25.112]             {
[11:03:25.112]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.112]                   0L) {
[11:03:25.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.112]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.112]                   base::options(opts)
[11:03:25.112]                 }
[11:03:25.112]                 {
[11:03:25.112]                   {
[11:03:25.112]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.112]                     NULL
[11:03:25.112]                   }
[11:03:25.112]                   options(future.plan = NULL)
[11:03:25.112]                   if (is.na(NA_character_)) 
[11:03:25.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.112]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.112]                     .init = FALSE)
[11:03:25.112]                 }
[11:03:25.112]             }
[11:03:25.112]         }
[11:03:25.112]     })
[11:03:25.112]     if (TRUE) {
[11:03:25.112]         base::sink(type = "output", split = FALSE)
[11:03:25.112]         if (TRUE) {
[11:03:25.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.112]         }
[11:03:25.112]         else {
[11:03:25.112]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.112]         }
[11:03:25.112]         base::close(...future.stdout)
[11:03:25.112]         ...future.stdout <- NULL
[11:03:25.112]     }
[11:03:25.112]     ...future.result$conditions <- ...future.conditions
[11:03:25.112]     ...future.result$finished <- base::Sys.time()
[11:03:25.112]     ...future.result
[11:03:25.112] }
[11:03:25.115] requestCore(): workers = 2
[11:03:25.117] MulticoreFuture started
[11:03:25.118] - Launch lazy future ... done
[11:03:25.118] run() for ‘MulticoreFuture’ ... done
[11:03:25.118] plan(): Setting new future strategy stack:
[11:03:25.119] result() for MulticoreFuture ...
[11:03:25.118] List of future strategies:
[11:03:25.118] 1. sequential:
[11:03:25.118]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.118]    - tweaked: FALSE
[11:03:25.118]    - call: NULL
[11:03:25.119] plan(): nbrOfWorkers() = 1
[11:03:25.123] plan(): Setting new future strategy stack:
[11:03:25.123] List of future strategies:
[11:03:25.123] 1. multicore:
[11:03:25.123]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.123]    - tweaked: FALSE
[11:03:25.123]    - call: plan(strategy)
[11:03:25.126] plan(): nbrOfWorkers() = 2
[11:03:25.130] result() for MulticoreFuture ...
[11:03:25.130] result() for MulticoreFuture ... done
[11:03:25.130] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ finished    : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ session_uuid: chr "62501264-7e21-2605-4a88-6d2a851ec82c"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "173ee284ba16"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 85011
  .. ..$ time  : POSIXct[1:1], format: "2025-05-06 11:03:25"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[11:03:25.142] result() for MulticoreFuture ...
[11:03:25.142] result() for MulticoreFuture ... done
[11:03:25.142] result() for MulticoreFuture ...
[11:03:25.142] result() for MulticoreFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.008592129 secs (started 2025-05-06 11:03:25.117812)
version: 1.8
[11:03:25.143] getGlobalsAndPackages() ...
[11:03:25.143] Searching for globals...
[11:03:25.147] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.147] Searching for globals ... DONE
[11:03:25.147] Resolving globals: FALSE
[11:03:25.148] 
[11:03:25.148] - packages: [1] ‘utils’
[11:03:25.148] getGlobalsAndPackages() ... DONE
[11:03:25.148] run() for ‘Future’ ...
[11:03:25.148] - state: ‘created’
[11:03:25.149] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.150] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.151] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:03:25.151]   - Field: ‘label’
[11:03:25.151]   - Field: ‘local’
[11:03:25.151]   - Field: ‘owner’
[11:03:25.151]   - Field: ‘envir’
[11:03:25.151]   - Field: ‘workers’
[11:03:25.151]   - Field: ‘packages’
[11:03:25.151]   - Field: ‘gc’
[11:03:25.151]   - Field: ‘job’
[11:03:25.152]   - Field: ‘conditions’
[11:03:25.152]   - Field: ‘expr’
[11:03:25.152]   - Field: ‘uuid’
[11:03:25.152]   - Field: ‘seed’
[11:03:25.152]   - Field: ‘version’
[11:03:25.152]   - Field: ‘result’
[11:03:25.152]   - Field: ‘asynchronous’
[11:03:25.152]   - Field: ‘calls’
[11:03:25.152]   - Field: ‘globals’
[11:03:25.153]   - Field: ‘stdout’
[11:03:25.153]   - Field: ‘earlySignal’
[11:03:25.153]   - Field: ‘lazy’
[11:03:25.153]   - Field: ‘state’
[11:03:25.153] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:03:25.153] - Launch lazy future ...
[11:03:25.153] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.154] Packages needed by future strategies (n = 0): <none>
[11:03:25.154] {
[11:03:25.154]     {
[11:03:25.154]         {
[11:03:25.154]             ...future.startTime <- base::Sys.time()
[11:03:25.154]             {
[11:03:25.154]                 {
[11:03:25.154]                   {
[11:03:25.154]                     {
[11:03:25.154]                       {
[11:03:25.154]                         base::local({
[11:03:25.154]                           has_future <- base::requireNamespace("future", 
[11:03:25.154]                             quietly = TRUE)
[11:03:25.154]                           if (has_future) {
[11:03:25.154]                             ns <- base::getNamespace("future")
[11:03:25.154]                             version <- ns[[".package"]][["version"]]
[11:03:25.154]                             if (is.null(version)) 
[11:03:25.154]                               version <- utils::packageVersion("future")
[11:03:25.154]                           }
[11:03:25.154]                           else {
[11:03:25.154]                             version <- NULL
[11:03:25.154]                           }
[11:03:25.154]                           if (!has_future || version < "1.8.0") {
[11:03:25.154]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.154]                               "", base::R.version$version.string), 
[11:03:25.154]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:25.154]                                 base::R.version$platform, 8 * 
[11:03:25.154]                                   base::.Machine$sizeof.pointer), 
[11:03:25.154]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.154]                                 "release", "version")], collapse = " "), 
[11:03:25.154]                               hostname = base::Sys.info()[["nodename"]])
[11:03:25.154]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.154]                               info)
[11:03:25.154]                             info <- base::paste(info, collapse = "; ")
[11:03:25.154]                             if (!has_future) {
[11:03:25.154]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.154]                                 info)
[11:03:25.154]                             }
[11:03:25.154]                             else {
[11:03:25.154]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.154]                                 info, version)
[11:03:25.154]                             }
[11:03:25.154]                             base::stop(msg)
[11:03:25.154]                           }
[11:03:25.154]                         })
[11:03:25.154]                       }
[11:03:25.154]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.154]                       base::options(mc.cores = 1L)
[11:03:25.154]                     }
[11:03:25.154]                     base::local({
[11:03:25.154]                       for (pkg in "utils") {
[11:03:25.154]                         base::loadNamespace(pkg)
[11:03:25.154]                         base::library(pkg, character.only = TRUE)
[11:03:25.154]                       }
[11:03:25.154]                     })
[11:03:25.154]                   }
[11:03:25.154]                   ...future.strategy.old <- future::plan("list")
[11:03:25.154]                   options(future.plan = NULL)
[11:03:25.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.154]                 }
[11:03:25.154]                 ...future.workdir <- getwd()
[11:03:25.154]             }
[11:03:25.154]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.154]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.154]         }
[11:03:25.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.154]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.154]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.154]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.154]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.154]             base::names(...future.oldOptions))
[11:03:25.154]     }
[11:03:25.154]     if (FALSE) {
[11:03:25.154]     }
[11:03:25.154]     else {
[11:03:25.154]         if (TRUE) {
[11:03:25.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.154]                 open = "w")
[11:03:25.154]         }
[11:03:25.154]         else {
[11:03:25.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.154]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.154]         }
[11:03:25.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.154]             base::sink(type = "output", split = FALSE)
[11:03:25.154]             base::close(...future.stdout)
[11:03:25.154]         }, add = TRUE)
[11:03:25.154]     }
[11:03:25.154]     ...future.frame <- base::sys.nframe()
[11:03:25.154]     ...future.conditions <- base::list()
[11:03:25.154]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.154]     if (FALSE) {
[11:03:25.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.154]     }
[11:03:25.154]     ...future.result <- base::tryCatch({
[11:03:25.154]         base::withCallingHandlers({
[11:03:25.154]             ...future.value <- base::withVisible(base::local({
[11:03:25.154]                 withCallingHandlers({
[11:03:25.154]                   {
[11:03:25.154]                     print(1:50)
[11:03:25.154]                     str(1:50)
[11:03:25.154]                     cat(letters, sep = "-")
[11:03:25.154]                     cat(1:6, collapse = "\n")
[11:03:25.154]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.154]                     42L
[11:03:25.154]                   }
[11:03:25.154]                 }, immediateCondition = function(cond) {
[11:03:25.154]                   save_rds <- function (object, pathname, ...) 
[11:03:25.154]                   {
[11:03:25.154]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:03:25.154]                     if (file_test("-f", pathname_tmp)) {
[11:03:25.154]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.154]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:03:25.154]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.154]                         fi_tmp[["mtime"]])
[11:03:25.154]                     }
[11:03:25.154]                     tryCatch({
[11:03:25.154]                       saveRDS(object, file = pathname_tmp, ...)
[11:03:25.154]                     }, error = function(ex) {
[11:03:25.154]                       msg <- conditionMessage(ex)
[11:03:25.154]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.154]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:03:25.154]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.154]                         fi_tmp[["mtime"]], msg)
[11:03:25.154]                       ex$message <- msg
[11:03:25.154]                       stop(ex)
[11:03:25.154]                     })
[11:03:25.154]                     stopifnot(file_test("-f", pathname_tmp))
[11:03:25.154]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:03:25.154]                     if (!res || file_test("-f", pathname_tmp)) {
[11:03:25.154]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.154]                       fi <- file.info(pathname)
[11:03:25.154]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:03:25.154]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.154]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:03:25.154]                         fi[["size"]], fi[["mtime"]])
[11:03:25.154]                       stop(msg)
[11:03:25.154]                     }
[11:03:25.154]                     invisible(pathname)
[11:03:25.154]                   }
[11:03:25.154]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:03:25.154]                     rootPath = tempdir()) 
[11:03:25.154]                   {
[11:03:25.154]                     obj <- list(time = Sys.time(), condition = cond)
[11:03:25.154]                     file <- tempfile(pattern = class(cond)[1], 
[11:03:25.154]                       tmpdir = path, fileext = ".rds")
[11:03:25.154]                     save_rds(obj, file)
[11:03:25.154]                   }
[11:03:25.154]                   saveImmediateCondition(cond, path = "/tmp/RtmpjFuTgt/.future/immediateConditions")
[11:03:25.154]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.154]                   {
[11:03:25.154]                     inherits <- base::inherits
[11:03:25.154]                     invokeRestart <- base::invokeRestart
[11:03:25.154]                     is.null <- base::is.null
[11:03:25.154]                     muffled <- FALSE
[11:03:25.154]                     if (inherits(cond, "message")) {
[11:03:25.154]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.154]                       if (muffled) 
[11:03:25.154]                         invokeRestart("muffleMessage")
[11:03:25.154]                     }
[11:03:25.154]                     else if (inherits(cond, "warning")) {
[11:03:25.154]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.154]                       if (muffled) 
[11:03:25.154]                         invokeRestart("muffleWarning")
[11:03:25.154]                     }
[11:03:25.154]                     else if (inherits(cond, "condition")) {
[11:03:25.154]                       if (!is.null(pattern)) {
[11:03:25.154]                         computeRestarts <- base::computeRestarts
[11:03:25.154]                         grepl <- base::grepl
[11:03:25.154]                         restarts <- computeRestarts(cond)
[11:03:25.154]                         for (restart in restarts) {
[11:03:25.154]                           name <- restart$name
[11:03:25.154]                           if (is.null(name)) 
[11:03:25.154]                             next
[11:03:25.154]                           if (!grepl(pattern, name)) 
[11:03:25.154]                             next
[11:03:25.154]                           invokeRestart(restart)
[11:03:25.154]                           muffled <- TRUE
[11:03:25.154]                           break
[11:03:25.154]                         }
[11:03:25.154]                       }
[11:03:25.154]                     }
[11:03:25.154]                     invisible(muffled)
[11:03:25.154]                   }
[11:03:25.154]                   muffleCondition(cond)
[11:03:25.154]                 })
[11:03:25.154]             }))
[11:03:25.154]             future::FutureResult(value = ...future.value$value, 
[11:03:25.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.154]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.154]                     ...future.globalenv.names))
[11:03:25.154]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.154]         }, condition = base::local({
[11:03:25.154]             c <- base::c
[11:03:25.154]             inherits <- base::inherits
[11:03:25.154]             invokeRestart <- base::invokeRestart
[11:03:25.154]             length <- base::length
[11:03:25.154]             list <- base::list
[11:03:25.154]             seq.int <- base::seq.int
[11:03:25.154]             signalCondition <- base::signalCondition
[11:03:25.154]             sys.calls <- base::sys.calls
[11:03:25.154]             `[[` <- base::`[[`
[11:03:25.154]             `+` <- base::`+`
[11:03:25.154]             `<<-` <- base::`<<-`
[11:03:25.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.154]                   3L)]
[11:03:25.154]             }
[11:03:25.154]             function(cond) {
[11:03:25.154]                 is_error <- inherits(cond, "error")
[11:03:25.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.154]                   NULL)
[11:03:25.154]                 if (is_error) {
[11:03:25.154]                   sessionInformation <- function() {
[11:03:25.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.154]                       search = base::search(), system = base::Sys.info())
[11:03:25.154]                   }
[11:03:25.154]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.154]                     cond$call), session = sessionInformation(), 
[11:03:25.154]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.154]                   signalCondition(cond)
[11:03:25.154]                 }
[11:03:25.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.154]                 "immediateCondition"))) {
[11:03:25.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.154]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.154]                   if (TRUE && !signal) {
[11:03:25.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.154]                     {
[11:03:25.154]                       inherits <- base::inherits
[11:03:25.154]                       invokeRestart <- base::invokeRestart
[11:03:25.154]                       is.null <- base::is.null
[11:03:25.154]                       muffled <- FALSE
[11:03:25.154]                       if (inherits(cond, "message")) {
[11:03:25.154]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.154]                         if (muffled) 
[11:03:25.154]                           invokeRestart("muffleMessage")
[11:03:25.154]                       }
[11:03:25.154]                       else if (inherits(cond, "warning")) {
[11:03:25.154]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.154]                         if (muffled) 
[11:03:25.154]                           invokeRestart("muffleWarning")
[11:03:25.154]                       }
[11:03:25.154]                       else if (inherits(cond, "condition")) {
[11:03:25.154]                         if (!is.null(pattern)) {
[11:03:25.154]                           computeRestarts <- base::computeRestarts
[11:03:25.154]                           grepl <- base::grepl
[11:03:25.154]                           restarts <- computeRestarts(cond)
[11:03:25.154]                           for (restart in restarts) {
[11:03:25.154]                             name <- restart$name
[11:03:25.154]                             if (is.null(name)) 
[11:03:25.154]                               next
[11:03:25.154]                             if (!grepl(pattern, name)) 
[11:03:25.154]                               next
[11:03:25.154]                             invokeRestart(restart)
[11:03:25.154]                             muffled <- TRUE
[11:03:25.154]                             break
[11:03:25.154]                           }
[11:03:25.154]                         }
[11:03:25.154]                       }
[11:03:25.154]                       invisible(muffled)
[11:03:25.154]                     }
[11:03:25.154]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.154]                   }
[11:03:25.154]                 }
[11:03:25.154]                 else {
[11:03:25.154]                   if (TRUE) {
[11:03:25.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.154]                     {
[11:03:25.154]                       inherits <- base::inherits
[11:03:25.154]                       invokeRestart <- base::invokeRestart
[11:03:25.154]                       is.null <- base::is.null
[11:03:25.154]                       muffled <- FALSE
[11:03:25.154]                       if (inherits(cond, "message")) {
[11:03:25.154]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.154]                         if (muffled) 
[11:03:25.154]                           invokeRestart("muffleMessage")
[11:03:25.154]                       }
[11:03:25.154]                       else if (inherits(cond, "warning")) {
[11:03:25.154]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.154]                         if (muffled) 
[11:03:25.154]                           invokeRestart("muffleWarning")
[11:03:25.154]                       }
[11:03:25.154]                       else if (inherits(cond, "condition")) {
[11:03:25.154]                         if (!is.null(pattern)) {
[11:03:25.154]                           computeRestarts <- base::computeRestarts
[11:03:25.154]                           grepl <- base::grepl
[11:03:25.154]                           restarts <- computeRestarts(cond)
[11:03:25.154]                           for (restart in restarts) {
[11:03:25.154]                             name <- restart$name
[11:03:25.154]                             if (is.null(name)) 
[11:03:25.154]                               next
[11:03:25.154]                             if (!grepl(pattern, name)) 
[11:03:25.154]                               next
[11:03:25.154]                             invokeRestart(restart)
[11:03:25.154]                             muffled <- TRUE
[11:03:25.154]                             break
[11:03:25.154]                           }
[11:03:25.154]                         }
[11:03:25.154]                       }
[11:03:25.154]                       invisible(muffled)
[11:03:25.154]                     }
[11:03:25.154]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.154]                   }
[11:03:25.154]                 }
[11:03:25.154]             }
[11:03:25.154]         }))
[11:03:25.154]     }, error = function(ex) {
[11:03:25.154]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.154]                 ...future.rng), started = ...future.startTime, 
[11:03:25.154]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.154]             version = "1.8"), class = "FutureResult")
[11:03:25.154]     }, finally = {
[11:03:25.154]         if (!identical(...future.workdir, getwd())) 
[11:03:25.154]             setwd(...future.workdir)
[11:03:25.154]         {
[11:03:25.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.154]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.154]             }
[11:03:25.154]             base::options(...future.oldOptions)
[11:03:25.154]             if (.Platform$OS.type == "windows") {
[11:03:25.154]                 old_names <- names(...future.oldEnvVars)
[11:03:25.154]                 envs <- base::Sys.getenv()
[11:03:25.154]                 names <- names(envs)
[11:03:25.154]                 common <- intersect(names, old_names)
[11:03:25.154]                 added <- setdiff(names, old_names)
[11:03:25.154]                 removed <- setdiff(old_names, names)
[11:03:25.154]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.154]                   envs[common]]
[11:03:25.154]                 NAMES <- toupper(changed)
[11:03:25.154]                 args <- list()
[11:03:25.154]                 for (kk in seq_along(NAMES)) {
[11:03:25.154]                   name <- changed[[kk]]
[11:03:25.154]                   NAME <- NAMES[[kk]]
[11:03:25.154]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.154]                     next
[11:03:25.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.154]                 }
[11:03:25.154]                 NAMES <- toupper(added)
[11:03:25.154]                 for (kk in seq_along(NAMES)) {
[11:03:25.154]                   name <- added[[kk]]
[11:03:25.154]                   NAME <- NAMES[[kk]]
[11:03:25.154]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.154]                     next
[11:03:25.154]                   args[[name]] <- ""
[11:03:25.154]                 }
[11:03:25.154]                 NAMES <- toupper(removed)
[11:03:25.154]                 for (kk in seq_along(NAMES)) {
[11:03:25.154]                   name <- removed[[kk]]
[11:03:25.154]                   NAME <- NAMES[[kk]]
[11:03:25.154]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.154]                     next
[11:03:25.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.154]                 }
[11:03:25.154]                 if (length(args) > 0) 
[11:03:25.154]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.154]             }
[11:03:25.154]             else {
[11:03:25.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.154]             }
[11:03:25.154]             {
[11:03:25.154]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.154]                   0L) {
[11:03:25.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.154]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.154]                   base::options(opts)
[11:03:25.154]                 }
[11:03:25.154]                 {
[11:03:25.154]                   {
[11:03:25.154]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.154]                     NULL
[11:03:25.154]                   }
[11:03:25.154]                   options(future.plan = NULL)
[11:03:25.154]                   if (is.na(NA_character_)) 
[11:03:25.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.154]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.154]                     .init = FALSE)
[11:03:25.154]                 }
[11:03:25.154]             }
[11:03:25.154]         }
[11:03:25.154]     })
[11:03:25.154]     if (TRUE) {
[11:03:25.154]         base::sink(type = "output", split = FALSE)
[11:03:25.154]         if (TRUE) {
[11:03:25.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.154]         }
[11:03:25.154]         else {
[11:03:25.154]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.154]         }
[11:03:25.154]         base::close(...future.stdout)
[11:03:25.154]         ...future.stdout <- NULL
[11:03:25.154]     }
[11:03:25.154]     ...future.result$conditions <- ...future.conditions
[11:03:25.154]     ...future.result$finished <- base::Sys.time()
[11:03:25.154]     ...future.result
[11:03:25.154] }
[11:03:25.156] requestCore(): workers = 2
[11:03:25.158] MulticoreFuture started
[11:03:25.158] - Launch lazy future ... done
[11:03:25.159] run() for ‘MulticoreFuture’ ... done
[11:03:25.159] result() for MulticoreFuture ...
[11:03:25.159] plan(): Setting new future strategy stack:
[11:03:25.160] List of future strategies:
[11:03:25.160] 1. sequential:
[11:03:25.160]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.160]    - tweaked: FALSE
[11:03:25.160]    - call: NULL
[11:03:25.161] plan(): nbrOfWorkers() = 1
[11:03:25.164] plan(): Setting new future strategy stack:
[11:03:25.164] List of future strategies:
[11:03:25.164] 1. multicore:
[11:03:25.164]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.164]    - tweaked: FALSE
[11:03:25.164]    - call: plan(strategy)
[11:03:25.167] plan(): nbrOfWorkers() = 2
[11:03:25.168] result() for MulticoreFuture ...
[11:03:25.168] result() for MulticoreFuture ... done
[11:03:25.168] result() for MulticoreFuture ... done
[11:03:25.168] result() for MulticoreFuture ...
[11:03:25.168] result() for MulticoreFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[11:03:25.169] getGlobalsAndPackages() ...
[11:03:25.169] Searching for globals...
[11:03:25.170] - globals found: [1] ‘print’
[11:03:25.170] Searching for globals ... DONE
[11:03:25.170] Resolving globals: FALSE
[11:03:25.170] 
[11:03:25.170] 
[11:03:25.170] getGlobalsAndPackages() ... DONE
[11:03:25.171] run() for ‘Future’ ...
[11:03:25.171] - state: ‘created’
[11:03:25.171] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.173] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:03:25.173]   - Field: ‘label’
[11:03:25.173]   - Field: ‘local’
[11:03:25.174]   - Field: ‘owner’
[11:03:25.174]   - Field: ‘envir’
[11:03:25.174]   - Field: ‘workers’
[11:03:25.174]   - Field: ‘packages’
[11:03:25.174]   - Field: ‘gc’
[11:03:25.174]   - Field: ‘job’
[11:03:25.174]   - Field: ‘conditions’
[11:03:25.174]   - Field: ‘expr’
[11:03:25.174]   - Field: ‘uuid’
[11:03:25.175]   - Field: ‘seed’
[11:03:25.175]   - Field: ‘version’
[11:03:25.175]   - Field: ‘result’
[11:03:25.175]   - Field: ‘asynchronous’
[11:03:25.175]   - Field: ‘calls’
[11:03:25.175]   - Field: ‘globals’
[11:03:25.175]   - Field: ‘stdout’
[11:03:25.175]   - Field: ‘earlySignal’
[11:03:25.175]   - Field: ‘lazy’
[11:03:25.175]   - Field: ‘state’
[11:03:25.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:03:25.176] - Launch lazy future ...
[11:03:25.176] Packages needed by the future expression (n = 0): <none>
[11:03:25.176] Packages needed by future strategies (n = 0): <none>
[11:03:25.177] {
[11:03:25.177]     {
[11:03:25.177]         {
[11:03:25.177]             ...future.startTime <- base::Sys.time()
[11:03:25.177]             {
[11:03:25.177]                 {
[11:03:25.177]                   {
[11:03:25.177]                     {
[11:03:25.177]                       base::local({
[11:03:25.177]                         has_future <- base::requireNamespace("future", 
[11:03:25.177]                           quietly = TRUE)
[11:03:25.177]                         if (has_future) {
[11:03:25.177]                           ns <- base::getNamespace("future")
[11:03:25.177]                           version <- ns[[".package"]][["version"]]
[11:03:25.177]                           if (is.null(version)) 
[11:03:25.177]                             version <- utils::packageVersion("future")
[11:03:25.177]                         }
[11:03:25.177]                         else {
[11:03:25.177]                           version <- NULL
[11:03:25.177]                         }
[11:03:25.177]                         if (!has_future || version < "1.8.0") {
[11:03:25.177]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.177]                             "", base::R.version$version.string), 
[11:03:25.177]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:25.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.177]                               "release", "version")], collapse = " "), 
[11:03:25.177]                             hostname = base::Sys.info()[["nodename"]])
[11:03:25.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.177]                             info)
[11:03:25.177]                           info <- base::paste(info, collapse = "; ")
[11:03:25.177]                           if (!has_future) {
[11:03:25.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.177]                               info)
[11:03:25.177]                           }
[11:03:25.177]                           else {
[11:03:25.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.177]                               info, version)
[11:03:25.177]                           }
[11:03:25.177]                           base::stop(msg)
[11:03:25.177]                         }
[11:03:25.177]                       })
[11:03:25.177]                     }
[11:03:25.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.177]                     base::options(mc.cores = 1L)
[11:03:25.177]                   }
[11:03:25.177]                   ...future.strategy.old <- future::plan("list")
[11:03:25.177]                   options(future.plan = NULL)
[11:03:25.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.177]                 }
[11:03:25.177]                 ...future.workdir <- getwd()
[11:03:25.177]             }
[11:03:25.177]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.177]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.177]         }
[11:03:25.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.177]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.177]             base::names(...future.oldOptions))
[11:03:25.177]     }
[11:03:25.177]     if (FALSE) {
[11:03:25.177]     }
[11:03:25.177]     else {
[11:03:25.177]         if (TRUE) {
[11:03:25.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.177]                 open = "w")
[11:03:25.177]         }
[11:03:25.177]         else {
[11:03:25.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.177]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.177]         }
[11:03:25.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.177]             base::sink(type = "output", split = FALSE)
[11:03:25.177]             base::close(...future.stdout)
[11:03:25.177]         }, add = TRUE)
[11:03:25.177]     }
[11:03:25.177]     ...future.frame <- base::sys.nframe()
[11:03:25.177]     ...future.conditions <- base::list()
[11:03:25.177]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.177]     if (FALSE) {
[11:03:25.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.177]     }
[11:03:25.177]     ...future.result <- base::tryCatch({
[11:03:25.177]         base::withCallingHandlers({
[11:03:25.177]             ...future.value <- base::withVisible(base::local({
[11:03:25.177]                 withCallingHandlers({
[11:03:25.177]                   print(42)
[11:03:25.177]                 }, immediateCondition = function(cond) {
[11:03:25.177]                   save_rds <- function (object, pathname, ...) 
[11:03:25.177]                   {
[11:03:25.177]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:03:25.177]                     if (file_test("-f", pathname_tmp)) {
[11:03:25.177]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.177]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:03:25.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.177]                         fi_tmp[["mtime"]])
[11:03:25.177]                     }
[11:03:25.177]                     tryCatch({
[11:03:25.177]                       saveRDS(object, file = pathname_tmp, ...)
[11:03:25.177]                     }, error = function(ex) {
[11:03:25.177]                       msg <- conditionMessage(ex)
[11:03:25.177]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.177]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:03:25.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.177]                         fi_tmp[["mtime"]], msg)
[11:03:25.177]                       ex$message <- msg
[11:03:25.177]                       stop(ex)
[11:03:25.177]                     })
[11:03:25.177]                     stopifnot(file_test("-f", pathname_tmp))
[11:03:25.177]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:03:25.177]                     if (!res || file_test("-f", pathname_tmp)) {
[11:03:25.177]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.177]                       fi <- file.info(pathname)
[11:03:25.177]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:03:25.177]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.177]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:03:25.177]                         fi[["size"]], fi[["mtime"]])
[11:03:25.177]                       stop(msg)
[11:03:25.177]                     }
[11:03:25.177]                     invisible(pathname)
[11:03:25.177]                   }
[11:03:25.177]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:03:25.177]                     rootPath = tempdir()) 
[11:03:25.177]                   {
[11:03:25.177]                     obj <- list(time = Sys.time(), condition = cond)
[11:03:25.177]                     file <- tempfile(pattern = class(cond)[1], 
[11:03:25.177]                       tmpdir = path, fileext = ".rds")
[11:03:25.177]                     save_rds(obj, file)
[11:03:25.177]                   }
[11:03:25.177]                   saveImmediateCondition(cond, path = "/tmp/RtmpjFuTgt/.future/immediateConditions")
[11:03:25.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.177]                   {
[11:03:25.177]                     inherits <- base::inherits
[11:03:25.177]                     invokeRestart <- base::invokeRestart
[11:03:25.177]                     is.null <- base::is.null
[11:03:25.177]                     muffled <- FALSE
[11:03:25.177]                     if (inherits(cond, "message")) {
[11:03:25.177]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.177]                       if (muffled) 
[11:03:25.177]                         invokeRestart("muffleMessage")
[11:03:25.177]                     }
[11:03:25.177]                     else if (inherits(cond, "warning")) {
[11:03:25.177]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.177]                       if (muffled) 
[11:03:25.177]                         invokeRestart("muffleWarning")
[11:03:25.177]                     }
[11:03:25.177]                     else if (inherits(cond, "condition")) {
[11:03:25.177]                       if (!is.null(pattern)) {
[11:03:25.177]                         computeRestarts <- base::computeRestarts
[11:03:25.177]                         grepl <- base::grepl
[11:03:25.177]                         restarts <- computeRestarts(cond)
[11:03:25.177]                         for (restart in restarts) {
[11:03:25.177]                           name <- restart$name
[11:03:25.177]                           if (is.null(name)) 
[11:03:25.177]                             next
[11:03:25.177]                           if (!grepl(pattern, name)) 
[11:03:25.177]                             next
[11:03:25.177]                           invokeRestart(restart)
[11:03:25.177]                           muffled <- TRUE
[11:03:25.177]                           break
[11:03:25.177]                         }
[11:03:25.177]                       }
[11:03:25.177]                     }
[11:03:25.177]                     invisible(muffled)
[11:03:25.177]                   }
[11:03:25.177]                   muffleCondition(cond)
[11:03:25.177]                 })
[11:03:25.177]             }))
[11:03:25.177]             future::FutureResult(value = ...future.value$value, 
[11:03:25.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.177]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.177]                     ...future.globalenv.names))
[11:03:25.177]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.177]         }, condition = base::local({
[11:03:25.177]             c <- base::c
[11:03:25.177]             inherits <- base::inherits
[11:03:25.177]             invokeRestart <- base::invokeRestart
[11:03:25.177]             length <- base::length
[11:03:25.177]             list <- base::list
[11:03:25.177]             seq.int <- base::seq.int
[11:03:25.177]             signalCondition <- base::signalCondition
[11:03:25.177]             sys.calls <- base::sys.calls
[11:03:25.177]             `[[` <- base::`[[`
[11:03:25.177]             `+` <- base::`+`
[11:03:25.177]             `<<-` <- base::`<<-`
[11:03:25.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.177]                   3L)]
[11:03:25.177]             }
[11:03:25.177]             function(cond) {
[11:03:25.177]                 is_error <- inherits(cond, "error")
[11:03:25.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.177]                   NULL)
[11:03:25.177]                 if (is_error) {
[11:03:25.177]                   sessionInformation <- function() {
[11:03:25.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.177]                       search = base::search(), system = base::Sys.info())
[11:03:25.177]                   }
[11:03:25.177]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.177]                     cond$call), session = sessionInformation(), 
[11:03:25.177]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.177]                   signalCondition(cond)
[11:03:25.177]                 }
[11:03:25.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.177]                 "immediateCondition"))) {
[11:03:25.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.177]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.177]                   if (TRUE && !signal) {
[11:03:25.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.177]                     {
[11:03:25.177]                       inherits <- base::inherits
[11:03:25.177]                       invokeRestart <- base::invokeRestart
[11:03:25.177]                       is.null <- base::is.null
[11:03:25.177]                       muffled <- FALSE
[11:03:25.177]                       if (inherits(cond, "message")) {
[11:03:25.177]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.177]                         if (muffled) 
[11:03:25.177]                           invokeRestart("muffleMessage")
[11:03:25.177]                       }
[11:03:25.177]                       else if (inherits(cond, "warning")) {
[11:03:25.177]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.177]                         if (muffled) 
[11:03:25.177]                           invokeRestart("muffleWarning")
[11:03:25.177]                       }
[11:03:25.177]                       else if (inherits(cond, "condition")) {
[11:03:25.177]                         if (!is.null(pattern)) {
[11:03:25.177]                           computeRestarts <- base::computeRestarts
[11:03:25.177]                           grepl <- base::grepl
[11:03:25.177]                           restarts <- computeRestarts(cond)
[11:03:25.177]                           for (restart in restarts) {
[11:03:25.177]                             name <- restart$name
[11:03:25.177]                             if (is.null(name)) 
[11:03:25.177]                               next
[11:03:25.177]                             if (!grepl(pattern, name)) 
[11:03:25.177]                               next
[11:03:25.177]                             invokeRestart(restart)
[11:03:25.177]                             muffled <- TRUE
[11:03:25.177]                             break
[11:03:25.177]                           }
[11:03:25.177]                         }
[11:03:25.177]                       }
[11:03:25.177]                       invisible(muffled)
[11:03:25.177]                     }
[11:03:25.177]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.177]                   }
[11:03:25.177]                 }
[11:03:25.177]                 else {
[11:03:25.177]                   if (TRUE) {
[11:03:25.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.177]                     {
[11:03:25.177]                       inherits <- base::inherits
[11:03:25.177]                       invokeRestart <- base::invokeRestart
[11:03:25.177]                       is.null <- base::is.null
[11:03:25.177]                       muffled <- FALSE
[11:03:25.177]                       if (inherits(cond, "message")) {
[11:03:25.177]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.177]                         if (muffled) 
[11:03:25.177]                           invokeRestart("muffleMessage")
[11:03:25.177]                       }
[11:03:25.177]                       else if (inherits(cond, "warning")) {
[11:03:25.177]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.177]                         if (muffled) 
[11:03:25.177]                           invokeRestart("muffleWarning")
[11:03:25.177]                       }
[11:03:25.177]                       else if (inherits(cond, "condition")) {
[11:03:25.177]                         if (!is.null(pattern)) {
[11:03:25.177]                           computeRestarts <- base::computeRestarts
[11:03:25.177]                           grepl <- base::grepl
[11:03:25.177]                           restarts <- computeRestarts(cond)
[11:03:25.177]                           for (restart in restarts) {
[11:03:25.177]                             name <- restart$name
[11:03:25.177]                             if (is.null(name)) 
[11:03:25.177]                               next
[11:03:25.177]                             if (!grepl(pattern, name)) 
[11:03:25.177]                               next
[11:03:25.177]                             invokeRestart(restart)
[11:03:25.177]                             muffled <- TRUE
[11:03:25.177]                             break
[11:03:25.177]                           }
[11:03:25.177]                         }
[11:03:25.177]                       }
[11:03:25.177]                       invisible(muffled)
[11:03:25.177]                     }
[11:03:25.177]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.177]                   }
[11:03:25.177]                 }
[11:03:25.177]             }
[11:03:25.177]         }))
[11:03:25.177]     }, error = function(ex) {
[11:03:25.177]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.177]                 ...future.rng), started = ...future.startTime, 
[11:03:25.177]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.177]             version = "1.8"), class = "FutureResult")
[11:03:25.177]     }, finally = {
[11:03:25.177]         if (!identical(...future.workdir, getwd())) 
[11:03:25.177]             setwd(...future.workdir)
[11:03:25.177]         {
[11:03:25.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.177]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.177]             }
[11:03:25.177]             base::options(...future.oldOptions)
[11:03:25.177]             if (.Platform$OS.type == "windows") {
[11:03:25.177]                 old_names <- names(...future.oldEnvVars)
[11:03:25.177]                 envs <- base::Sys.getenv()
[11:03:25.177]                 names <- names(envs)
[11:03:25.177]                 common <- intersect(names, old_names)
[11:03:25.177]                 added <- setdiff(names, old_names)
[11:03:25.177]                 removed <- setdiff(old_names, names)
[11:03:25.177]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.177]                   envs[common]]
[11:03:25.177]                 NAMES <- toupper(changed)
[11:03:25.177]                 args <- list()
[11:03:25.177]                 for (kk in seq_along(NAMES)) {
[11:03:25.177]                   name <- changed[[kk]]
[11:03:25.177]                   NAME <- NAMES[[kk]]
[11:03:25.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.177]                     next
[11:03:25.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.177]                 }
[11:03:25.177]                 NAMES <- toupper(added)
[11:03:25.177]                 for (kk in seq_along(NAMES)) {
[11:03:25.177]                   name <- added[[kk]]
[11:03:25.177]                   NAME <- NAMES[[kk]]
[11:03:25.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.177]                     next
[11:03:25.177]                   args[[name]] <- ""
[11:03:25.177]                 }
[11:03:25.177]                 NAMES <- toupper(removed)
[11:03:25.177]                 for (kk in seq_along(NAMES)) {
[11:03:25.177]                   name <- removed[[kk]]
[11:03:25.177]                   NAME <- NAMES[[kk]]
[11:03:25.177]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.177]                     next
[11:03:25.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.177]                 }
[11:03:25.177]                 if (length(args) > 0) 
[11:03:25.177]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.177]             }
[11:03:25.177]             else {
[11:03:25.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.177]             }
[11:03:25.177]             {
[11:03:25.177]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.177]                   0L) {
[11:03:25.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.177]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.177]                   base::options(opts)
[11:03:25.177]                 }
[11:03:25.177]                 {
[11:03:25.177]                   {
[11:03:25.177]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.177]                     NULL
[11:03:25.177]                   }
[11:03:25.177]                   options(future.plan = NULL)
[11:03:25.177]                   if (is.na(NA_character_)) 
[11:03:25.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.177]                     .init = FALSE)
[11:03:25.177]                 }
[11:03:25.177]             }
[11:03:25.177]         }
[11:03:25.177]     })
[11:03:25.177]     if (TRUE) {
[11:03:25.177]         base::sink(type = "output", split = FALSE)
[11:03:25.177]         if (TRUE) {
[11:03:25.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.177]         }
[11:03:25.177]         else {
[11:03:25.177]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.177]         }
[11:03:25.177]         base::close(...future.stdout)
[11:03:25.177]         ...future.stdout <- NULL
[11:03:25.177]     }
[11:03:25.177]     ...future.result$conditions <- ...future.conditions
[11:03:25.177]     ...future.result$finished <- base::Sys.time()
[11:03:25.177]     ...future.result
[11:03:25.177] }
[11:03:25.179] requestCore(): workers = 2
[11:03:25.181] MulticoreFuture started
[11:03:25.181] - Launch lazy future ... done
[11:03:25.181] run() for ‘MulticoreFuture’ ... done
[11:03:25.182] result() for MulticoreFuture ...
[11:03:25.182] plan(): Setting new future strategy stack:
[11:03:25.182] List of future strategies:
[11:03:25.182] 1. sequential:
[11:03:25.182]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.182]    - tweaked: FALSE
[11:03:25.182]    - call: NULL
[11:03:25.183] plan(): nbrOfWorkers() = 1
[11:03:25.185] plan(): Setting new future strategy stack:
[11:03:25.185] List of future strategies:
[11:03:25.185] 1. multicore:
[11:03:25.185]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.185]    - tweaked: FALSE
[11:03:25.185]    - call: plan(strategy)
[11:03:25.188] plan(): nbrOfWorkers() = 2
[11:03:25.188] result() for MulticoreFuture ...
[11:03:25.189] result() for MulticoreFuture ... done
[11:03:25.189] result() for MulticoreFuture ... done
[11:03:25.189] result() for MulticoreFuture ...
[11:03:25.189] result() for MulticoreFuture ... done
[11:03:25.189] result() for MulticoreFuture ...
[11:03:25.189] result() for MulticoreFuture ... done
[1] 42
[11:03:25.189] result() for MulticoreFuture ...
[11:03:25.190] result() for MulticoreFuture ... done
- stdout = FALSE
[11:03:25.190] getGlobalsAndPackages() ...
[11:03:25.190] Searching for globals...
[11:03:25.196] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.196] Searching for globals ... DONE
[11:03:25.197] Resolving globals: FALSE
[11:03:25.197] 
[11:03:25.197] - packages: [1] ‘utils’
[11:03:25.197] getGlobalsAndPackages() ... DONE
[11:03:25.198] run() for ‘Future’ ...
[11:03:25.198] - state: ‘created’
[11:03:25.198] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.200] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:03:25.200]   - Field: ‘label’
[11:03:25.200]   - Field: ‘local’
[11:03:25.201]   - Field: ‘owner’
[11:03:25.201]   - Field: ‘envir’
[11:03:25.201]   - Field: ‘workers’
[11:03:25.201]   - Field: ‘packages’
[11:03:25.201]   - Field: ‘gc’
[11:03:25.201]   - Field: ‘job’
[11:03:25.201]   - Field: ‘conditions’
[11:03:25.201]   - Field: ‘expr’
[11:03:25.201]   - Field: ‘uuid’
[11:03:25.202]   - Field: ‘seed’
[11:03:25.202]   - Field: ‘version’
[11:03:25.202]   - Field: ‘result’
[11:03:25.202]   - Field: ‘asynchronous’
[11:03:25.202]   - Field: ‘calls’
[11:03:25.202]   - Field: ‘globals’
[11:03:25.202]   - Field: ‘stdout’
[11:03:25.202]   - Field: ‘earlySignal’
[11:03:25.202]   - Field: ‘lazy’
[11:03:25.202]   - Field: ‘state’
[11:03:25.203] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:03:25.203] - Launch lazy future ...
[11:03:25.203] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.203] Packages needed by future strategies (n = 0): <none>
[11:03:25.204] {
[11:03:25.204]     {
[11:03:25.204]         {
[11:03:25.204]             ...future.startTime <- base::Sys.time()
[11:03:25.204]             {
[11:03:25.204]                 {
[11:03:25.204]                   {
[11:03:25.204]                     {
[11:03:25.204]                       {
[11:03:25.204]                         base::local({
[11:03:25.204]                           has_future <- base::requireNamespace("future", 
[11:03:25.204]                             quietly = TRUE)
[11:03:25.204]                           if (has_future) {
[11:03:25.204]                             ns <- base::getNamespace("future")
[11:03:25.204]                             version <- ns[[".package"]][["version"]]
[11:03:25.204]                             if (is.null(version)) 
[11:03:25.204]                               version <- utils::packageVersion("future")
[11:03:25.204]                           }
[11:03:25.204]                           else {
[11:03:25.204]                             version <- NULL
[11:03:25.204]                           }
[11:03:25.204]                           if (!has_future || version < "1.8.0") {
[11:03:25.204]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.204]                               "", base::R.version$version.string), 
[11:03:25.204]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:25.204]                                 base::R.version$platform, 8 * 
[11:03:25.204]                                   base::.Machine$sizeof.pointer), 
[11:03:25.204]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.204]                                 "release", "version")], collapse = " "), 
[11:03:25.204]                               hostname = base::Sys.info()[["nodename"]])
[11:03:25.204]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.204]                               info)
[11:03:25.204]                             info <- base::paste(info, collapse = "; ")
[11:03:25.204]                             if (!has_future) {
[11:03:25.204]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.204]                                 info)
[11:03:25.204]                             }
[11:03:25.204]                             else {
[11:03:25.204]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.204]                                 info, version)
[11:03:25.204]                             }
[11:03:25.204]                             base::stop(msg)
[11:03:25.204]                           }
[11:03:25.204]                         })
[11:03:25.204]                       }
[11:03:25.204]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.204]                       base::options(mc.cores = 1L)
[11:03:25.204]                     }
[11:03:25.204]                     base::local({
[11:03:25.204]                       for (pkg in "utils") {
[11:03:25.204]                         base::loadNamespace(pkg)
[11:03:25.204]                         base::library(pkg, character.only = TRUE)
[11:03:25.204]                       }
[11:03:25.204]                     })
[11:03:25.204]                   }
[11:03:25.204]                   ...future.strategy.old <- future::plan("list")
[11:03:25.204]                   options(future.plan = NULL)
[11:03:25.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.204]                 }
[11:03:25.204]                 ...future.workdir <- getwd()
[11:03:25.204]             }
[11:03:25.204]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.204]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.204]         }
[11:03:25.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.204]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.204]             base::names(...future.oldOptions))
[11:03:25.204]     }
[11:03:25.204]     if (FALSE) {
[11:03:25.204]     }
[11:03:25.204]     else {
[11:03:25.204]         if (FALSE) {
[11:03:25.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.204]                 open = "w")
[11:03:25.204]         }
[11:03:25.204]         else {
[11:03:25.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.204]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.204]         }
[11:03:25.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.204]             base::sink(type = "output", split = FALSE)
[11:03:25.204]             base::close(...future.stdout)
[11:03:25.204]         }, add = TRUE)
[11:03:25.204]     }
[11:03:25.204]     ...future.frame <- base::sys.nframe()
[11:03:25.204]     ...future.conditions <- base::list()
[11:03:25.204]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.204]     if (FALSE) {
[11:03:25.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.204]     }
[11:03:25.204]     ...future.result <- base::tryCatch({
[11:03:25.204]         base::withCallingHandlers({
[11:03:25.204]             ...future.value <- base::withVisible(base::local({
[11:03:25.204]                 withCallingHandlers({
[11:03:25.204]                   {
[11:03:25.204]                     print(1:50)
[11:03:25.204]                     str(1:50)
[11:03:25.204]                     cat(letters, sep = "-")
[11:03:25.204]                     cat(1:6, collapse = "\n")
[11:03:25.204]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.204]                     42L
[11:03:25.204]                   }
[11:03:25.204]                 }, immediateCondition = function(cond) {
[11:03:25.204]                   save_rds <- function (object, pathname, ...) 
[11:03:25.204]                   {
[11:03:25.204]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:03:25.204]                     if (file_test("-f", pathname_tmp)) {
[11:03:25.204]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.204]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:03:25.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.204]                         fi_tmp[["mtime"]])
[11:03:25.204]                     }
[11:03:25.204]                     tryCatch({
[11:03:25.204]                       saveRDS(object, file = pathname_tmp, ...)
[11:03:25.204]                     }, error = function(ex) {
[11:03:25.204]                       msg <- conditionMessage(ex)
[11:03:25.204]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.204]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:03:25.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.204]                         fi_tmp[["mtime"]], msg)
[11:03:25.204]                       ex$message <- msg
[11:03:25.204]                       stop(ex)
[11:03:25.204]                     })
[11:03:25.204]                     stopifnot(file_test("-f", pathname_tmp))
[11:03:25.204]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:03:25.204]                     if (!res || file_test("-f", pathname_tmp)) {
[11:03:25.204]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.204]                       fi <- file.info(pathname)
[11:03:25.204]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:03:25.204]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.204]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:03:25.204]                         fi[["size"]], fi[["mtime"]])
[11:03:25.204]                       stop(msg)
[11:03:25.204]                     }
[11:03:25.204]                     invisible(pathname)
[11:03:25.204]                   }
[11:03:25.204]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:03:25.204]                     rootPath = tempdir()) 
[11:03:25.204]                   {
[11:03:25.204]                     obj <- list(time = Sys.time(), condition = cond)
[11:03:25.204]                     file <- tempfile(pattern = class(cond)[1], 
[11:03:25.204]                       tmpdir = path, fileext = ".rds")
[11:03:25.204]                     save_rds(obj, file)
[11:03:25.204]                   }
[11:03:25.204]                   saveImmediateCondition(cond, path = "/tmp/RtmpjFuTgt/.future/immediateConditions")
[11:03:25.204]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.204]                   {
[11:03:25.204]                     inherits <- base::inherits
[11:03:25.204]                     invokeRestart <- base::invokeRestart
[11:03:25.204]                     is.null <- base::is.null
[11:03:25.204]                     muffled <- FALSE
[11:03:25.204]                     if (inherits(cond, "message")) {
[11:03:25.204]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.204]                       if (muffled) 
[11:03:25.204]                         invokeRestart("muffleMessage")
[11:03:25.204]                     }
[11:03:25.204]                     else if (inherits(cond, "warning")) {
[11:03:25.204]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.204]                       if (muffled) 
[11:03:25.204]                         invokeRestart("muffleWarning")
[11:03:25.204]                     }
[11:03:25.204]                     else if (inherits(cond, "condition")) {
[11:03:25.204]                       if (!is.null(pattern)) {
[11:03:25.204]                         computeRestarts <- base::computeRestarts
[11:03:25.204]                         grepl <- base::grepl
[11:03:25.204]                         restarts <- computeRestarts(cond)
[11:03:25.204]                         for (restart in restarts) {
[11:03:25.204]                           name <- restart$name
[11:03:25.204]                           if (is.null(name)) 
[11:03:25.204]                             next
[11:03:25.204]                           if (!grepl(pattern, name)) 
[11:03:25.204]                             next
[11:03:25.204]                           invokeRestart(restart)
[11:03:25.204]                           muffled <- TRUE
[11:03:25.204]                           break
[11:03:25.204]                         }
[11:03:25.204]                       }
[11:03:25.204]                     }
[11:03:25.204]                     invisible(muffled)
[11:03:25.204]                   }
[11:03:25.204]                   muffleCondition(cond)
[11:03:25.204]                 })
[11:03:25.204]             }))
[11:03:25.204]             future::FutureResult(value = ...future.value$value, 
[11:03:25.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.204]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.204]                     ...future.globalenv.names))
[11:03:25.204]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.204]         }, condition = base::local({
[11:03:25.204]             c <- base::c
[11:03:25.204]             inherits <- base::inherits
[11:03:25.204]             invokeRestart <- base::invokeRestart
[11:03:25.204]             length <- base::length
[11:03:25.204]             list <- base::list
[11:03:25.204]             seq.int <- base::seq.int
[11:03:25.204]             signalCondition <- base::signalCondition
[11:03:25.204]             sys.calls <- base::sys.calls
[11:03:25.204]             `[[` <- base::`[[`
[11:03:25.204]             `+` <- base::`+`
[11:03:25.204]             `<<-` <- base::`<<-`
[11:03:25.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.204]                   3L)]
[11:03:25.204]             }
[11:03:25.204]             function(cond) {
[11:03:25.204]                 is_error <- inherits(cond, "error")
[11:03:25.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.204]                   NULL)
[11:03:25.204]                 if (is_error) {
[11:03:25.204]                   sessionInformation <- function() {
[11:03:25.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.204]                       search = base::search(), system = base::Sys.info())
[11:03:25.204]                   }
[11:03:25.204]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.204]                     cond$call), session = sessionInformation(), 
[11:03:25.204]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.204]                   signalCondition(cond)
[11:03:25.204]                 }
[11:03:25.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.204]                 "immediateCondition"))) {
[11:03:25.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.204]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.204]                   if (TRUE && !signal) {
[11:03:25.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.204]                     {
[11:03:25.204]                       inherits <- base::inherits
[11:03:25.204]                       invokeRestart <- base::invokeRestart
[11:03:25.204]                       is.null <- base::is.null
[11:03:25.204]                       muffled <- FALSE
[11:03:25.204]                       if (inherits(cond, "message")) {
[11:03:25.204]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.204]                         if (muffled) 
[11:03:25.204]                           invokeRestart("muffleMessage")
[11:03:25.204]                       }
[11:03:25.204]                       else if (inherits(cond, "warning")) {
[11:03:25.204]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.204]                         if (muffled) 
[11:03:25.204]                           invokeRestart("muffleWarning")
[11:03:25.204]                       }
[11:03:25.204]                       else if (inherits(cond, "condition")) {
[11:03:25.204]                         if (!is.null(pattern)) {
[11:03:25.204]                           computeRestarts <- base::computeRestarts
[11:03:25.204]                           grepl <- base::grepl
[11:03:25.204]                           restarts <- computeRestarts(cond)
[11:03:25.204]                           for (restart in restarts) {
[11:03:25.204]                             name <- restart$name
[11:03:25.204]                             if (is.null(name)) 
[11:03:25.204]                               next
[11:03:25.204]                             if (!grepl(pattern, name)) 
[11:03:25.204]                               next
[11:03:25.204]                             invokeRestart(restart)
[11:03:25.204]                             muffled <- TRUE
[11:03:25.204]                             break
[11:03:25.204]                           }
[11:03:25.204]                         }
[11:03:25.204]                       }
[11:03:25.204]                       invisible(muffled)
[11:03:25.204]                     }
[11:03:25.204]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.204]                   }
[11:03:25.204]                 }
[11:03:25.204]                 else {
[11:03:25.204]                   if (TRUE) {
[11:03:25.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.204]                     {
[11:03:25.204]                       inherits <- base::inherits
[11:03:25.204]                       invokeRestart <- base::invokeRestart
[11:03:25.204]                       is.null <- base::is.null
[11:03:25.204]                       muffled <- FALSE
[11:03:25.204]                       if (inherits(cond, "message")) {
[11:03:25.204]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.204]                         if (muffled) 
[11:03:25.204]                           invokeRestart("muffleMessage")
[11:03:25.204]                       }
[11:03:25.204]                       else if (inherits(cond, "warning")) {
[11:03:25.204]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.204]                         if (muffled) 
[11:03:25.204]                           invokeRestart("muffleWarning")
[11:03:25.204]                       }
[11:03:25.204]                       else if (inherits(cond, "condition")) {
[11:03:25.204]                         if (!is.null(pattern)) {
[11:03:25.204]                           computeRestarts <- base::computeRestarts
[11:03:25.204]                           grepl <- base::grepl
[11:03:25.204]                           restarts <- computeRestarts(cond)
[11:03:25.204]                           for (restart in restarts) {
[11:03:25.204]                             name <- restart$name
[11:03:25.204]                             if (is.null(name)) 
[11:03:25.204]                               next
[11:03:25.204]                             if (!grepl(pattern, name)) 
[11:03:25.204]                               next
[11:03:25.204]                             invokeRestart(restart)
[11:03:25.204]                             muffled <- TRUE
[11:03:25.204]                             break
[11:03:25.204]                           }
[11:03:25.204]                         }
[11:03:25.204]                       }
[11:03:25.204]                       invisible(muffled)
[11:03:25.204]                     }
[11:03:25.204]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.204]                   }
[11:03:25.204]                 }
[11:03:25.204]             }
[11:03:25.204]         }))
[11:03:25.204]     }, error = function(ex) {
[11:03:25.204]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.204]                 ...future.rng), started = ...future.startTime, 
[11:03:25.204]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.204]             version = "1.8"), class = "FutureResult")
[11:03:25.204]     }, finally = {
[11:03:25.204]         if (!identical(...future.workdir, getwd())) 
[11:03:25.204]             setwd(...future.workdir)
[11:03:25.204]         {
[11:03:25.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.204]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.204]             }
[11:03:25.204]             base::options(...future.oldOptions)
[11:03:25.204]             if (.Platform$OS.type == "windows") {
[11:03:25.204]                 old_names <- names(...future.oldEnvVars)
[11:03:25.204]                 envs <- base::Sys.getenv()
[11:03:25.204]                 names <- names(envs)
[11:03:25.204]                 common <- intersect(names, old_names)
[11:03:25.204]                 added <- setdiff(names, old_names)
[11:03:25.204]                 removed <- setdiff(old_names, names)
[11:03:25.204]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.204]                   envs[common]]
[11:03:25.204]                 NAMES <- toupper(changed)
[11:03:25.204]                 args <- list()
[11:03:25.204]                 for (kk in seq_along(NAMES)) {
[11:03:25.204]                   name <- changed[[kk]]
[11:03:25.204]                   NAME <- NAMES[[kk]]
[11:03:25.204]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.204]                     next
[11:03:25.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.204]                 }
[11:03:25.204]                 NAMES <- toupper(added)
[11:03:25.204]                 for (kk in seq_along(NAMES)) {
[11:03:25.204]                   name <- added[[kk]]
[11:03:25.204]                   NAME <- NAMES[[kk]]
[11:03:25.204]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.204]                     next
[11:03:25.204]                   args[[name]] <- ""
[11:03:25.204]                 }
[11:03:25.204]                 NAMES <- toupper(removed)
[11:03:25.204]                 for (kk in seq_along(NAMES)) {
[11:03:25.204]                   name <- removed[[kk]]
[11:03:25.204]                   NAME <- NAMES[[kk]]
[11:03:25.204]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.204]                     next
[11:03:25.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.204]                 }
[11:03:25.204]                 if (length(args) > 0) 
[11:03:25.204]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.204]             }
[11:03:25.204]             else {
[11:03:25.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.204]             }
[11:03:25.204]             {
[11:03:25.204]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.204]                   0L) {
[11:03:25.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.204]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.204]                   base::options(opts)
[11:03:25.204]                 }
[11:03:25.204]                 {
[11:03:25.204]                   {
[11:03:25.204]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.204]                     NULL
[11:03:25.204]                   }
[11:03:25.204]                   options(future.plan = NULL)
[11:03:25.204]                   if (is.na(NA_character_)) 
[11:03:25.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.204]                     .init = FALSE)
[11:03:25.204]                 }
[11:03:25.204]             }
[11:03:25.204]         }
[11:03:25.204]     })
[11:03:25.204]     if (TRUE) {
[11:03:25.204]         base::sink(type = "output", split = FALSE)
[11:03:25.204]         if (FALSE) {
[11:03:25.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.204]         }
[11:03:25.204]         else {
[11:03:25.204]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.204]         }
[11:03:25.204]         base::close(...future.stdout)
[11:03:25.204]         ...future.stdout <- NULL
[11:03:25.204]     }
[11:03:25.204]     ...future.result$conditions <- ...future.conditions
[11:03:25.204]     ...future.result$finished <- base::Sys.time()
[11:03:25.204]     ...future.result
[11:03:25.204] }
[11:03:25.206] requestCore(): workers = 2
[11:03:25.208] MulticoreFuture started
[11:03:25.208] - Launch lazy future ... done
[11:03:25.208] run() for ‘MulticoreFuture’ ... done
[11:03:25.209] result() for MulticoreFuture ...
[11:03:25.209] plan(): Setting new future strategy stack:
[11:03:25.209] List of future strategies:
[11:03:25.209] 1. sequential:
[11:03:25.209]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.209]    - tweaked: FALSE
[11:03:25.209]    - call: NULL
[11:03:25.210] plan(): nbrOfWorkers() = 1
[11:03:25.213] plan(): Setting new future strategy stack:
[11:03:25.214] List of future strategies:
[11:03:25.214] 1. multicore:
[11:03:25.214]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.214]    - tweaked: FALSE
[11:03:25.214]    - call: plan(strategy)
[11:03:25.216] plan(): nbrOfWorkers() = 2
[11:03:25.217] result() for MulticoreFuture ...
[11:03:25.217] result() for MulticoreFuture ... done
[11:03:25.218] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ finished    : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ session_uuid: chr "9c73d7e6-c53f-f6da-0097-2e53624df2bb"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "173ee284ba16"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 85014
  .. ..$ time  : POSIXct[1:1], format: "2025-05-06 11:03:25"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[11:03:25.227] result() for MulticoreFuture ...
[11:03:25.227] result() for MulticoreFuture ... done
[11:03:25.227] result() for MulticoreFuture ...
[11:03:25.227] result() for MulticoreFuture ... done
[11:03:25.227] getGlobalsAndPackages() ...
[11:03:25.228] Searching for globals...
[11:03:25.231] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.231] Searching for globals ... DONE
[11:03:25.231] Resolving globals: FALSE
[11:03:25.232] 
[11:03:25.234] - packages: [1] ‘utils’
[11:03:25.234] getGlobalsAndPackages() ... DONE
[11:03:25.234] run() for ‘Future’ ...
[11:03:25.234] - state: ‘created’
[11:03:25.235] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.237] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.237] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:03:25.237]   - Field: ‘label’
[11:03:25.237]   - Field: ‘local’
[11:03:25.237]   - Field: ‘owner’
[11:03:25.238]   - Field: ‘envir’
[11:03:25.238]   - Field: ‘workers’
[11:03:25.238]   - Field: ‘packages’
[11:03:25.238]   - Field: ‘gc’
[11:03:25.238]   - Field: ‘job’
[11:03:25.238]   - Field: ‘conditions’
[11:03:25.238]   - Field: ‘expr’
[11:03:25.238]   - Field: ‘uuid’
[11:03:25.238]   - Field: ‘seed’
[11:03:25.238]   - Field: ‘version’
[11:03:25.239]   - Field: ‘result’
[11:03:25.239]   - Field: ‘asynchronous’
[11:03:25.239]   - Field: ‘calls’
[11:03:25.239]   - Field: ‘globals’
[11:03:25.239]   - Field: ‘stdout’
[11:03:25.239]   - Field: ‘earlySignal’
[11:03:25.239]   - Field: ‘lazy’
[11:03:25.239]   - Field: ‘state’
[11:03:25.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:03:25.240] - Launch lazy future ...
[11:03:25.240] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.240] Packages needed by future strategies (n = 0): <none>
[11:03:25.241] {
[11:03:25.241]     {
[11:03:25.241]         {
[11:03:25.241]             ...future.startTime <- base::Sys.time()
[11:03:25.241]             {
[11:03:25.241]                 {
[11:03:25.241]                   {
[11:03:25.241]                     {
[11:03:25.241]                       {
[11:03:25.241]                         base::local({
[11:03:25.241]                           has_future <- base::requireNamespace("future", 
[11:03:25.241]                             quietly = TRUE)
[11:03:25.241]                           if (has_future) {
[11:03:25.241]                             ns <- base::getNamespace("future")
[11:03:25.241]                             version <- ns[[".package"]][["version"]]
[11:03:25.241]                             if (is.null(version)) 
[11:03:25.241]                               version <- utils::packageVersion("future")
[11:03:25.241]                           }
[11:03:25.241]                           else {
[11:03:25.241]                             version <- NULL
[11:03:25.241]                           }
[11:03:25.241]                           if (!has_future || version < "1.8.0") {
[11:03:25.241]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.241]                               "", base::R.version$version.string), 
[11:03:25.241]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:25.241]                                 base::R.version$platform, 8 * 
[11:03:25.241]                                   base::.Machine$sizeof.pointer), 
[11:03:25.241]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.241]                                 "release", "version")], collapse = " "), 
[11:03:25.241]                               hostname = base::Sys.info()[["nodename"]])
[11:03:25.241]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.241]                               info)
[11:03:25.241]                             info <- base::paste(info, collapse = "; ")
[11:03:25.241]                             if (!has_future) {
[11:03:25.241]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.241]                                 info)
[11:03:25.241]                             }
[11:03:25.241]                             else {
[11:03:25.241]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.241]                                 info, version)
[11:03:25.241]                             }
[11:03:25.241]                             base::stop(msg)
[11:03:25.241]                           }
[11:03:25.241]                         })
[11:03:25.241]                       }
[11:03:25.241]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.241]                       base::options(mc.cores = 1L)
[11:03:25.241]                     }
[11:03:25.241]                     base::local({
[11:03:25.241]                       for (pkg in "utils") {
[11:03:25.241]                         base::loadNamespace(pkg)
[11:03:25.241]                         base::library(pkg, character.only = TRUE)
[11:03:25.241]                       }
[11:03:25.241]                     })
[11:03:25.241]                   }
[11:03:25.241]                   ...future.strategy.old <- future::plan("list")
[11:03:25.241]                   options(future.plan = NULL)
[11:03:25.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.241]                 }
[11:03:25.241]                 ...future.workdir <- getwd()
[11:03:25.241]             }
[11:03:25.241]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.241]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.241]         }
[11:03:25.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.241]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.241]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.241]             base::names(...future.oldOptions))
[11:03:25.241]     }
[11:03:25.241]     if (FALSE) {
[11:03:25.241]     }
[11:03:25.241]     else {
[11:03:25.241]         if (FALSE) {
[11:03:25.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.241]                 open = "w")
[11:03:25.241]         }
[11:03:25.241]         else {
[11:03:25.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.241]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.241]         }
[11:03:25.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.241]             base::sink(type = "output", split = FALSE)
[11:03:25.241]             base::close(...future.stdout)
[11:03:25.241]         }, add = TRUE)
[11:03:25.241]     }
[11:03:25.241]     ...future.frame <- base::sys.nframe()
[11:03:25.241]     ...future.conditions <- base::list()
[11:03:25.241]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.241]     if (FALSE) {
[11:03:25.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.241]     }
[11:03:25.241]     ...future.result <- base::tryCatch({
[11:03:25.241]         base::withCallingHandlers({
[11:03:25.241]             ...future.value <- base::withVisible(base::local({
[11:03:25.241]                 withCallingHandlers({
[11:03:25.241]                   {
[11:03:25.241]                     print(1:50)
[11:03:25.241]                     str(1:50)
[11:03:25.241]                     cat(letters, sep = "-")
[11:03:25.241]                     cat(1:6, collapse = "\n")
[11:03:25.241]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.241]                     42L
[11:03:25.241]                   }
[11:03:25.241]                 }, immediateCondition = function(cond) {
[11:03:25.241]                   save_rds <- function (object, pathname, ...) 
[11:03:25.241]                   {
[11:03:25.241]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:03:25.241]                     if (file_test("-f", pathname_tmp)) {
[11:03:25.241]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.241]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:03:25.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.241]                         fi_tmp[["mtime"]])
[11:03:25.241]                     }
[11:03:25.241]                     tryCatch({
[11:03:25.241]                       saveRDS(object, file = pathname_tmp, ...)
[11:03:25.241]                     }, error = function(ex) {
[11:03:25.241]                       msg <- conditionMessage(ex)
[11:03:25.241]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.241]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:03:25.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.241]                         fi_tmp[["mtime"]], msg)
[11:03:25.241]                       ex$message <- msg
[11:03:25.241]                       stop(ex)
[11:03:25.241]                     })
[11:03:25.241]                     stopifnot(file_test("-f", pathname_tmp))
[11:03:25.241]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:03:25.241]                     if (!res || file_test("-f", pathname_tmp)) {
[11:03:25.241]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.241]                       fi <- file.info(pathname)
[11:03:25.241]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:03:25.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.241]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:03:25.241]                         fi[["size"]], fi[["mtime"]])
[11:03:25.241]                       stop(msg)
[11:03:25.241]                     }
[11:03:25.241]                     invisible(pathname)
[11:03:25.241]                   }
[11:03:25.241]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:03:25.241]                     rootPath = tempdir()) 
[11:03:25.241]                   {
[11:03:25.241]                     obj <- list(time = Sys.time(), condition = cond)
[11:03:25.241]                     file <- tempfile(pattern = class(cond)[1], 
[11:03:25.241]                       tmpdir = path, fileext = ".rds")
[11:03:25.241]                     save_rds(obj, file)
[11:03:25.241]                   }
[11:03:25.241]                   saveImmediateCondition(cond, path = "/tmp/RtmpjFuTgt/.future/immediateConditions")
[11:03:25.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.241]                   {
[11:03:25.241]                     inherits <- base::inherits
[11:03:25.241]                     invokeRestart <- base::invokeRestart
[11:03:25.241]                     is.null <- base::is.null
[11:03:25.241]                     muffled <- FALSE
[11:03:25.241]                     if (inherits(cond, "message")) {
[11:03:25.241]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.241]                       if (muffled) 
[11:03:25.241]                         invokeRestart("muffleMessage")
[11:03:25.241]                     }
[11:03:25.241]                     else if (inherits(cond, "warning")) {
[11:03:25.241]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.241]                       if (muffled) 
[11:03:25.241]                         invokeRestart("muffleWarning")
[11:03:25.241]                     }
[11:03:25.241]                     else if (inherits(cond, "condition")) {
[11:03:25.241]                       if (!is.null(pattern)) {
[11:03:25.241]                         computeRestarts <- base::computeRestarts
[11:03:25.241]                         grepl <- base::grepl
[11:03:25.241]                         restarts <- computeRestarts(cond)
[11:03:25.241]                         for (restart in restarts) {
[11:03:25.241]                           name <- restart$name
[11:03:25.241]                           if (is.null(name)) 
[11:03:25.241]                             next
[11:03:25.241]                           if (!grepl(pattern, name)) 
[11:03:25.241]                             next
[11:03:25.241]                           invokeRestart(restart)
[11:03:25.241]                           muffled <- TRUE
[11:03:25.241]                           break
[11:03:25.241]                         }
[11:03:25.241]                       }
[11:03:25.241]                     }
[11:03:25.241]                     invisible(muffled)
[11:03:25.241]                   }
[11:03:25.241]                   muffleCondition(cond)
[11:03:25.241]                 })
[11:03:25.241]             }))
[11:03:25.241]             future::FutureResult(value = ...future.value$value, 
[11:03:25.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.241]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.241]                     ...future.globalenv.names))
[11:03:25.241]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.241]         }, condition = base::local({
[11:03:25.241]             c <- base::c
[11:03:25.241]             inherits <- base::inherits
[11:03:25.241]             invokeRestart <- base::invokeRestart
[11:03:25.241]             length <- base::length
[11:03:25.241]             list <- base::list
[11:03:25.241]             seq.int <- base::seq.int
[11:03:25.241]             signalCondition <- base::signalCondition
[11:03:25.241]             sys.calls <- base::sys.calls
[11:03:25.241]             `[[` <- base::`[[`
[11:03:25.241]             `+` <- base::`+`
[11:03:25.241]             `<<-` <- base::`<<-`
[11:03:25.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.241]                   3L)]
[11:03:25.241]             }
[11:03:25.241]             function(cond) {
[11:03:25.241]                 is_error <- inherits(cond, "error")
[11:03:25.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.241]                   NULL)
[11:03:25.241]                 if (is_error) {
[11:03:25.241]                   sessionInformation <- function() {
[11:03:25.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.241]                       search = base::search(), system = base::Sys.info())
[11:03:25.241]                   }
[11:03:25.241]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.241]                     cond$call), session = sessionInformation(), 
[11:03:25.241]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.241]                   signalCondition(cond)
[11:03:25.241]                 }
[11:03:25.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.241]                 "immediateCondition"))) {
[11:03:25.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.241]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.241]                   if (TRUE && !signal) {
[11:03:25.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.241]                     {
[11:03:25.241]                       inherits <- base::inherits
[11:03:25.241]                       invokeRestart <- base::invokeRestart
[11:03:25.241]                       is.null <- base::is.null
[11:03:25.241]                       muffled <- FALSE
[11:03:25.241]                       if (inherits(cond, "message")) {
[11:03:25.241]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.241]                         if (muffled) 
[11:03:25.241]                           invokeRestart("muffleMessage")
[11:03:25.241]                       }
[11:03:25.241]                       else if (inherits(cond, "warning")) {
[11:03:25.241]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.241]                         if (muffled) 
[11:03:25.241]                           invokeRestart("muffleWarning")
[11:03:25.241]                       }
[11:03:25.241]                       else if (inherits(cond, "condition")) {
[11:03:25.241]                         if (!is.null(pattern)) {
[11:03:25.241]                           computeRestarts <- base::computeRestarts
[11:03:25.241]                           grepl <- base::grepl
[11:03:25.241]                           restarts <- computeRestarts(cond)
[11:03:25.241]                           for (restart in restarts) {
[11:03:25.241]                             name <- restart$name
[11:03:25.241]                             if (is.null(name)) 
[11:03:25.241]                               next
[11:03:25.241]                             if (!grepl(pattern, name)) 
[11:03:25.241]                               next
[11:03:25.241]                             invokeRestart(restart)
[11:03:25.241]                             muffled <- TRUE
[11:03:25.241]                             break
[11:03:25.241]                           }
[11:03:25.241]                         }
[11:03:25.241]                       }
[11:03:25.241]                       invisible(muffled)
[11:03:25.241]                     }
[11:03:25.241]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.241]                   }
[11:03:25.241]                 }
[11:03:25.241]                 else {
[11:03:25.241]                   if (TRUE) {
[11:03:25.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.241]                     {
[11:03:25.241]                       inherits <- base::inherits
[11:03:25.241]                       invokeRestart <- base::invokeRestart
[11:03:25.241]                       is.null <- base::is.null
[11:03:25.241]                       muffled <- FALSE
[11:03:25.241]                       if (inherits(cond, "message")) {
[11:03:25.241]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.241]                         if (muffled) 
[11:03:25.241]                           invokeRestart("muffleMessage")
[11:03:25.241]                       }
[11:03:25.241]                       else if (inherits(cond, "warning")) {
[11:03:25.241]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.241]                         if (muffled) 
[11:03:25.241]                           invokeRestart("muffleWarning")
[11:03:25.241]                       }
[11:03:25.241]                       else if (inherits(cond, "condition")) {
[11:03:25.241]                         if (!is.null(pattern)) {
[11:03:25.241]                           computeRestarts <- base::computeRestarts
[11:03:25.241]                           grepl <- base::grepl
[11:03:25.241]                           restarts <- computeRestarts(cond)
[11:03:25.241]                           for (restart in restarts) {
[11:03:25.241]                             name <- restart$name
[11:03:25.241]                             if (is.null(name)) 
[11:03:25.241]                               next
[11:03:25.241]                             if (!grepl(pattern, name)) 
[11:03:25.241]                               next
[11:03:25.241]                             invokeRestart(restart)
[11:03:25.241]                             muffled <- TRUE
[11:03:25.241]                             break
[11:03:25.241]                           }
[11:03:25.241]                         }
[11:03:25.241]                       }
[11:03:25.241]                       invisible(muffled)
[11:03:25.241]                     }
[11:03:25.241]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.241]                   }
[11:03:25.241]                 }
[11:03:25.241]             }
[11:03:25.241]         }))
[11:03:25.241]     }, error = function(ex) {
[11:03:25.241]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.241]                 ...future.rng), started = ...future.startTime, 
[11:03:25.241]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.241]             version = "1.8"), class = "FutureResult")
[11:03:25.241]     }, finally = {
[11:03:25.241]         if (!identical(...future.workdir, getwd())) 
[11:03:25.241]             setwd(...future.workdir)
[11:03:25.241]         {
[11:03:25.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.241]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.241]             }
[11:03:25.241]             base::options(...future.oldOptions)
[11:03:25.241]             if (.Platform$OS.type == "windows") {
[11:03:25.241]                 old_names <- names(...future.oldEnvVars)
[11:03:25.241]                 envs <- base::Sys.getenv()
[11:03:25.241]                 names <- names(envs)
[11:03:25.241]                 common <- intersect(names, old_names)
[11:03:25.241]                 added <- setdiff(names, old_names)
[11:03:25.241]                 removed <- setdiff(old_names, names)
[11:03:25.241]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.241]                   envs[common]]
[11:03:25.241]                 NAMES <- toupper(changed)
[11:03:25.241]                 args <- list()
[11:03:25.241]                 for (kk in seq_along(NAMES)) {
[11:03:25.241]                   name <- changed[[kk]]
[11:03:25.241]                   NAME <- NAMES[[kk]]
[11:03:25.241]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.241]                     next
[11:03:25.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.241]                 }
[11:03:25.241]                 NAMES <- toupper(added)
[11:03:25.241]                 for (kk in seq_along(NAMES)) {
[11:03:25.241]                   name <- added[[kk]]
[11:03:25.241]                   NAME <- NAMES[[kk]]
[11:03:25.241]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.241]                     next
[11:03:25.241]                   args[[name]] <- ""
[11:03:25.241]                 }
[11:03:25.241]                 NAMES <- toupper(removed)
[11:03:25.241]                 for (kk in seq_along(NAMES)) {
[11:03:25.241]                   name <- removed[[kk]]
[11:03:25.241]                   NAME <- NAMES[[kk]]
[11:03:25.241]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.241]                     next
[11:03:25.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.241]                 }
[11:03:25.241]                 if (length(args) > 0) 
[11:03:25.241]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.241]             }
[11:03:25.241]             else {
[11:03:25.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.241]             }
[11:03:25.241]             {
[11:03:25.241]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.241]                   0L) {
[11:03:25.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.241]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.241]                   base::options(opts)
[11:03:25.241]                 }
[11:03:25.241]                 {
[11:03:25.241]                   {
[11:03:25.241]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.241]                     NULL
[11:03:25.241]                   }
[11:03:25.241]                   options(future.plan = NULL)
[11:03:25.241]                   if (is.na(NA_character_)) 
[11:03:25.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.241]                     .init = FALSE)
[11:03:25.241]                 }
[11:03:25.241]             }
[11:03:25.241]         }
[11:03:25.241]     })
[11:03:25.241]     if (TRUE) {
[11:03:25.241]         base::sink(type = "output", split = FALSE)
[11:03:25.241]         if (FALSE) {
[11:03:25.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.241]         }
[11:03:25.241]         else {
[11:03:25.241]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.241]         }
[11:03:25.241]         base::close(...future.stdout)
[11:03:25.241]         ...future.stdout <- NULL
[11:03:25.241]     }
[11:03:25.241]     ...future.result$conditions <- ...future.conditions
[11:03:25.241]     ...future.result$finished <- base::Sys.time()
[11:03:25.241]     ...future.result
[11:03:25.241] }
[11:03:25.243] requestCore(): workers = 2
[11:03:25.245] MulticoreFuture started
[11:03:25.245] - Launch lazy future ... done
[11:03:25.245] run() for ‘MulticoreFuture’ ... done
[11:03:25.246] result() for MulticoreFuture ...
[11:03:25.246] plan(): Setting new future strategy stack:
[11:03:25.246] List of future strategies:
[11:03:25.246] 1. sequential:
[11:03:25.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.246]    - tweaked: FALSE
[11:03:25.246]    - call: NULL
[11:03:25.247] plan(): nbrOfWorkers() = 1
[11:03:25.250] plan(): Setting new future strategy stack:
[11:03:25.250] List of future strategies:
[11:03:25.250] 1. multicore:
[11:03:25.250]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.250]    - tweaked: FALSE
[11:03:25.250]    - call: plan(strategy)
[11:03:25.253] plan(): nbrOfWorkers() = 2
[11:03:25.254] result() for MulticoreFuture ...
[11:03:25.254] result() for MulticoreFuture ... done
[11:03:25.254] result() for MulticoreFuture ... done
[11:03:25.254] result() for MulticoreFuture ...
[11:03:25.255] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[11:03:25.255] getGlobalsAndPackages() ...
[11:03:25.255] Searching for globals...
[11:03:25.256] - globals found: [1] ‘print’
[11:03:25.256] Searching for globals ... DONE
[11:03:25.256] Resolving globals: FALSE
[11:03:25.257] 
[11:03:25.257] 
[11:03:25.257] getGlobalsAndPackages() ... DONE
[11:03:25.257] run() for ‘Future’ ...
[11:03:25.257] - state: ‘created’
[11:03:25.257] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.259] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.260] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:03:25.260]   - Field: ‘label’
[11:03:25.260]   - Field: ‘local’
[11:03:25.260]   - Field: ‘owner’
[11:03:25.260]   - Field: ‘envir’
[11:03:25.260]   - Field: ‘workers’
[11:03:25.260]   - Field: ‘packages’
[11:03:25.260]   - Field: ‘gc’
[11:03:25.260]   - Field: ‘job’
[11:03:25.261]   - Field: ‘conditions’
[11:03:25.261]   - Field: ‘expr’
[11:03:25.261]   - Field: ‘uuid’
[11:03:25.261]   - Field: ‘seed’
[11:03:25.261]   - Field: ‘version’
[11:03:25.261]   - Field: ‘result’
[11:03:25.261]   - Field: ‘asynchronous’
[11:03:25.261]   - Field: ‘calls’
[11:03:25.261]   - Field: ‘globals’
[11:03:25.261]   - Field: ‘stdout’
[11:03:25.262]   - Field: ‘earlySignal’
[11:03:25.262]   - Field: ‘lazy’
[11:03:25.262]   - Field: ‘state’
[11:03:25.262] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:03:25.262] - Launch lazy future ...
[11:03:25.262] Packages needed by the future expression (n = 0): <none>
[11:03:25.263] Packages needed by future strategies (n = 0): <none>
[11:03:25.263] {
[11:03:25.263]     {
[11:03:25.263]         {
[11:03:25.263]             ...future.startTime <- base::Sys.time()
[11:03:25.263]             {
[11:03:25.263]                 {
[11:03:25.263]                   {
[11:03:25.263]                     {
[11:03:25.263]                       base::local({
[11:03:25.263]                         has_future <- base::requireNamespace("future", 
[11:03:25.263]                           quietly = TRUE)
[11:03:25.263]                         if (has_future) {
[11:03:25.263]                           ns <- base::getNamespace("future")
[11:03:25.263]                           version <- ns[[".package"]][["version"]]
[11:03:25.263]                           if (is.null(version)) 
[11:03:25.263]                             version <- utils::packageVersion("future")
[11:03:25.263]                         }
[11:03:25.263]                         else {
[11:03:25.263]                           version <- NULL
[11:03:25.263]                         }
[11:03:25.263]                         if (!has_future || version < "1.8.0") {
[11:03:25.263]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.263]                             "", base::R.version$version.string), 
[11:03:25.263]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:25.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.263]                               "release", "version")], collapse = " "), 
[11:03:25.263]                             hostname = base::Sys.info()[["nodename"]])
[11:03:25.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.263]                             info)
[11:03:25.263]                           info <- base::paste(info, collapse = "; ")
[11:03:25.263]                           if (!has_future) {
[11:03:25.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.263]                               info)
[11:03:25.263]                           }
[11:03:25.263]                           else {
[11:03:25.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.263]                               info, version)
[11:03:25.263]                           }
[11:03:25.263]                           base::stop(msg)
[11:03:25.263]                         }
[11:03:25.263]                       })
[11:03:25.263]                     }
[11:03:25.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.263]                     base::options(mc.cores = 1L)
[11:03:25.263]                   }
[11:03:25.263]                   ...future.strategy.old <- future::plan("list")
[11:03:25.263]                   options(future.plan = NULL)
[11:03:25.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.263]                 }
[11:03:25.263]                 ...future.workdir <- getwd()
[11:03:25.263]             }
[11:03:25.263]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.263]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.263]         }
[11:03:25.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.263]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.263]             base::names(...future.oldOptions))
[11:03:25.263]     }
[11:03:25.263]     if (FALSE) {
[11:03:25.263]     }
[11:03:25.263]     else {
[11:03:25.263]         if (TRUE) {
[11:03:25.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.263]                 open = "w")
[11:03:25.263]         }
[11:03:25.263]         else {
[11:03:25.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.263]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.263]         }
[11:03:25.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.263]             base::sink(type = "output", split = FALSE)
[11:03:25.263]             base::close(...future.stdout)
[11:03:25.263]         }, add = TRUE)
[11:03:25.263]     }
[11:03:25.263]     ...future.frame <- base::sys.nframe()
[11:03:25.263]     ...future.conditions <- base::list()
[11:03:25.263]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.263]     if (FALSE) {
[11:03:25.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.263]     }
[11:03:25.263]     ...future.result <- base::tryCatch({
[11:03:25.263]         base::withCallingHandlers({
[11:03:25.263]             ...future.value <- base::withVisible(base::local({
[11:03:25.263]                 withCallingHandlers({
[11:03:25.263]                   print(42)
[11:03:25.263]                 }, immediateCondition = function(cond) {
[11:03:25.263]                   save_rds <- function (object, pathname, ...) 
[11:03:25.263]                   {
[11:03:25.263]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:03:25.263]                     if (file_test("-f", pathname_tmp)) {
[11:03:25.263]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.263]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:03:25.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.263]                         fi_tmp[["mtime"]])
[11:03:25.263]                     }
[11:03:25.263]                     tryCatch({
[11:03:25.263]                       saveRDS(object, file = pathname_tmp, ...)
[11:03:25.263]                     }, error = function(ex) {
[11:03:25.263]                       msg <- conditionMessage(ex)
[11:03:25.263]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.263]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:03:25.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.263]                         fi_tmp[["mtime"]], msg)
[11:03:25.263]                       ex$message <- msg
[11:03:25.263]                       stop(ex)
[11:03:25.263]                     })
[11:03:25.263]                     stopifnot(file_test("-f", pathname_tmp))
[11:03:25.263]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:03:25.263]                     if (!res || file_test("-f", pathname_tmp)) {
[11:03:25.263]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.263]                       fi <- file.info(pathname)
[11:03:25.263]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:03:25.263]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.263]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:03:25.263]                         fi[["size"]], fi[["mtime"]])
[11:03:25.263]                       stop(msg)
[11:03:25.263]                     }
[11:03:25.263]                     invisible(pathname)
[11:03:25.263]                   }
[11:03:25.263]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:03:25.263]                     rootPath = tempdir()) 
[11:03:25.263]                   {
[11:03:25.263]                     obj <- list(time = Sys.time(), condition = cond)
[11:03:25.263]                     file <- tempfile(pattern = class(cond)[1], 
[11:03:25.263]                       tmpdir = path, fileext = ".rds")
[11:03:25.263]                     save_rds(obj, file)
[11:03:25.263]                   }
[11:03:25.263]                   saveImmediateCondition(cond, path = "/tmp/RtmpjFuTgt/.future/immediateConditions")
[11:03:25.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.263]                   {
[11:03:25.263]                     inherits <- base::inherits
[11:03:25.263]                     invokeRestart <- base::invokeRestart
[11:03:25.263]                     is.null <- base::is.null
[11:03:25.263]                     muffled <- FALSE
[11:03:25.263]                     if (inherits(cond, "message")) {
[11:03:25.263]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.263]                       if (muffled) 
[11:03:25.263]                         invokeRestart("muffleMessage")
[11:03:25.263]                     }
[11:03:25.263]                     else if (inherits(cond, "warning")) {
[11:03:25.263]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.263]                       if (muffled) 
[11:03:25.263]                         invokeRestart("muffleWarning")
[11:03:25.263]                     }
[11:03:25.263]                     else if (inherits(cond, "condition")) {
[11:03:25.263]                       if (!is.null(pattern)) {
[11:03:25.263]                         computeRestarts <- base::computeRestarts
[11:03:25.263]                         grepl <- base::grepl
[11:03:25.263]                         restarts <- computeRestarts(cond)
[11:03:25.263]                         for (restart in restarts) {
[11:03:25.263]                           name <- restart$name
[11:03:25.263]                           if (is.null(name)) 
[11:03:25.263]                             next
[11:03:25.263]                           if (!grepl(pattern, name)) 
[11:03:25.263]                             next
[11:03:25.263]                           invokeRestart(restart)
[11:03:25.263]                           muffled <- TRUE
[11:03:25.263]                           break
[11:03:25.263]                         }
[11:03:25.263]                       }
[11:03:25.263]                     }
[11:03:25.263]                     invisible(muffled)
[11:03:25.263]                   }
[11:03:25.263]                   muffleCondition(cond)
[11:03:25.263]                 })
[11:03:25.263]             }))
[11:03:25.263]             future::FutureResult(value = ...future.value$value, 
[11:03:25.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.263]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.263]                     ...future.globalenv.names))
[11:03:25.263]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.263]         }, condition = base::local({
[11:03:25.263]             c <- base::c
[11:03:25.263]             inherits <- base::inherits
[11:03:25.263]             invokeRestart <- base::invokeRestart
[11:03:25.263]             length <- base::length
[11:03:25.263]             list <- base::list
[11:03:25.263]             seq.int <- base::seq.int
[11:03:25.263]             signalCondition <- base::signalCondition
[11:03:25.263]             sys.calls <- base::sys.calls
[11:03:25.263]             `[[` <- base::`[[`
[11:03:25.263]             `+` <- base::`+`
[11:03:25.263]             `<<-` <- base::`<<-`
[11:03:25.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.263]                   3L)]
[11:03:25.263]             }
[11:03:25.263]             function(cond) {
[11:03:25.263]                 is_error <- inherits(cond, "error")
[11:03:25.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.263]                   NULL)
[11:03:25.263]                 if (is_error) {
[11:03:25.263]                   sessionInformation <- function() {
[11:03:25.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.263]                       search = base::search(), system = base::Sys.info())
[11:03:25.263]                   }
[11:03:25.263]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.263]                     cond$call), session = sessionInformation(), 
[11:03:25.263]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.263]                   signalCondition(cond)
[11:03:25.263]                 }
[11:03:25.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.263]                 "immediateCondition"))) {
[11:03:25.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.263]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.263]                   if (TRUE && !signal) {
[11:03:25.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.263]                     {
[11:03:25.263]                       inherits <- base::inherits
[11:03:25.263]                       invokeRestart <- base::invokeRestart
[11:03:25.263]                       is.null <- base::is.null
[11:03:25.263]                       muffled <- FALSE
[11:03:25.263]                       if (inherits(cond, "message")) {
[11:03:25.263]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.263]                         if (muffled) 
[11:03:25.263]                           invokeRestart("muffleMessage")
[11:03:25.263]                       }
[11:03:25.263]                       else if (inherits(cond, "warning")) {
[11:03:25.263]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.263]                         if (muffled) 
[11:03:25.263]                           invokeRestart("muffleWarning")
[11:03:25.263]                       }
[11:03:25.263]                       else if (inherits(cond, "condition")) {
[11:03:25.263]                         if (!is.null(pattern)) {
[11:03:25.263]                           computeRestarts <- base::computeRestarts
[11:03:25.263]                           grepl <- base::grepl
[11:03:25.263]                           restarts <- computeRestarts(cond)
[11:03:25.263]                           for (restart in restarts) {
[11:03:25.263]                             name <- restart$name
[11:03:25.263]                             if (is.null(name)) 
[11:03:25.263]                               next
[11:03:25.263]                             if (!grepl(pattern, name)) 
[11:03:25.263]                               next
[11:03:25.263]                             invokeRestart(restart)
[11:03:25.263]                             muffled <- TRUE
[11:03:25.263]                             break
[11:03:25.263]                           }
[11:03:25.263]                         }
[11:03:25.263]                       }
[11:03:25.263]                       invisible(muffled)
[11:03:25.263]                     }
[11:03:25.263]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.263]                   }
[11:03:25.263]                 }
[11:03:25.263]                 else {
[11:03:25.263]                   if (TRUE) {
[11:03:25.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.263]                     {
[11:03:25.263]                       inherits <- base::inherits
[11:03:25.263]                       invokeRestart <- base::invokeRestart
[11:03:25.263]                       is.null <- base::is.null
[11:03:25.263]                       muffled <- FALSE
[11:03:25.263]                       if (inherits(cond, "message")) {
[11:03:25.263]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.263]                         if (muffled) 
[11:03:25.263]                           invokeRestart("muffleMessage")
[11:03:25.263]                       }
[11:03:25.263]                       else if (inherits(cond, "warning")) {
[11:03:25.263]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.263]                         if (muffled) 
[11:03:25.263]                           invokeRestart("muffleWarning")
[11:03:25.263]                       }
[11:03:25.263]                       else if (inherits(cond, "condition")) {
[11:03:25.263]                         if (!is.null(pattern)) {
[11:03:25.263]                           computeRestarts <- base::computeRestarts
[11:03:25.263]                           grepl <- base::grepl
[11:03:25.263]                           restarts <- computeRestarts(cond)
[11:03:25.263]                           for (restart in restarts) {
[11:03:25.263]                             name <- restart$name
[11:03:25.263]                             if (is.null(name)) 
[11:03:25.263]                               next
[11:03:25.263]                             if (!grepl(pattern, name)) 
[11:03:25.263]                               next
[11:03:25.263]                             invokeRestart(restart)
[11:03:25.263]                             muffled <- TRUE
[11:03:25.263]                             break
[11:03:25.263]                           }
[11:03:25.263]                         }
[11:03:25.263]                       }
[11:03:25.263]                       invisible(muffled)
[11:03:25.263]                     }
[11:03:25.263]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.263]                   }
[11:03:25.263]                 }
[11:03:25.263]             }
[11:03:25.263]         }))
[11:03:25.263]     }, error = function(ex) {
[11:03:25.263]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.263]                 ...future.rng), started = ...future.startTime, 
[11:03:25.263]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.263]             version = "1.8"), class = "FutureResult")
[11:03:25.263]     }, finally = {
[11:03:25.263]         if (!identical(...future.workdir, getwd())) 
[11:03:25.263]             setwd(...future.workdir)
[11:03:25.263]         {
[11:03:25.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.263]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.263]             }
[11:03:25.263]             base::options(...future.oldOptions)
[11:03:25.263]             if (.Platform$OS.type == "windows") {
[11:03:25.263]                 old_names <- names(...future.oldEnvVars)
[11:03:25.263]                 envs <- base::Sys.getenv()
[11:03:25.263]                 names <- names(envs)
[11:03:25.263]                 common <- intersect(names, old_names)
[11:03:25.263]                 added <- setdiff(names, old_names)
[11:03:25.263]                 removed <- setdiff(old_names, names)
[11:03:25.263]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.263]                   envs[common]]
[11:03:25.263]                 NAMES <- toupper(changed)
[11:03:25.263]                 args <- list()
[11:03:25.263]                 for (kk in seq_along(NAMES)) {
[11:03:25.263]                   name <- changed[[kk]]
[11:03:25.263]                   NAME <- NAMES[[kk]]
[11:03:25.263]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.263]                     next
[11:03:25.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.263]                 }
[11:03:25.263]                 NAMES <- toupper(added)
[11:03:25.263]                 for (kk in seq_along(NAMES)) {
[11:03:25.263]                   name <- added[[kk]]
[11:03:25.263]                   NAME <- NAMES[[kk]]
[11:03:25.263]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.263]                     next
[11:03:25.263]                   args[[name]] <- ""
[11:03:25.263]                 }
[11:03:25.263]                 NAMES <- toupper(removed)
[11:03:25.263]                 for (kk in seq_along(NAMES)) {
[11:03:25.263]                   name <- removed[[kk]]
[11:03:25.263]                   NAME <- NAMES[[kk]]
[11:03:25.263]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.263]                     next
[11:03:25.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.263]                 }
[11:03:25.263]                 if (length(args) > 0) 
[11:03:25.263]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.263]             }
[11:03:25.263]             else {
[11:03:25.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.263]             }
[11:03:25.263]             {
[11:03:25.263]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.263]                   0L) {
[11:03:25.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.263]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.263]                   base::options(opts)
[11:03:25.263]                 }
[11:03:25.263]                 {
[11:03:25.263]                   {
[11:03:25.263]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.263]                     NULL
[11:03:25.263]                   }
[11:03:25.263]                   options(future.plan = NULL)
[11:03:25.263]                   if (is.na(NA_character_)) 
[11:03:25.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.263]                     .init = FALSE)
[11:03:25.263]                 }
[11:03:25.263]             }
[11:03:25.263]         }
[11:03:25.263]     })
[11:03:25.263]     if (TRUE) {
[11:03:25.263]         base::sink(type = "output", split = FALSE)
[11:03:25.263]         if (TRUE) {
[11:03:25.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.263]         }
[11:03:25.263]         else {
[11:03:25.263]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.263]         }
[11:03:25.263]         base::close(...future.stdout)
[11:03:25.263]         ...future.stdout <- NULL
[11:03:25.263]     }
[11:03:25.263]     ...future.result$conditions <- ...future.conditions
[11:03:25.263]     ...future.result$finished <- base::Sys.time()
[11:03:25.263]     ...future.result
[11:03:25.263] }
[11:03:25.266] requestCore(): workers = 2
[11:03:25.267] MulticoreFuture started
[11:03:25.268] - Launch lazy future ... done
[11:03:25.268] run() for ‘MulticoreFuture’ ... done
[11:03:25.268] result() for MulticoreFuture ...
[11:03:25.268] plan(): Setting new future strategy stack:
[11:03:25.268] List of future strategies:
[11:03:25.268] 1. sequential:
[11:03:25.268]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.268]    - tweaked: FALSE
[11:03:25.268]    - call: NULL
[11:03:25.269] plan(): nbrOfWorkers() = 1
[11:03:25.271] plan(): Setting new future strategy stack:
[11:03:25.271] List of future strategies:
[11:03:25.271] 1. multicore:
[11:03:25.271]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.271]    - tweaked: FALSE
[11:03:25.271]    - call: plan(strategy)
[11:03:25.274] plan(): nbrOfWorkers() = 2
[11:03:25.275] result() for MulticoreFuture ...
[11:03:25.275] result() for MulticoreFuture ... done
[11:03:25.275] result() for MulticoreFuture ... done
[11:03:25.275] result() for MulticoreFuture ...
[11:03:25.275] result() for MulticoreFuture ... done
[11:03:25.276] result() for MulticoreFuture ...
[11:03:25.276] result() for MulticoreFuture ... done
[1] 42
[11:03:25.276] result() for MulticoreFuture ...
[11:03:25.276] result() for MulticoreFuture ... done
- stdout = NA
[11:03:25.276] getGlobalsAndPackages() ...
[11:03:25.276] Searching for globals...
[11:03:25.280] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.280] Searching for globals ... DONE
[11:03:25.280] Resolving globals: FALSE
[11:03:25.281] 
[11:03:25.281] - packages: [1] ‘utils’
[11:03:25.281] getGlobalsAndPackages() ... DONE
[11:03:25.282] run() for ‘Future’ ...
[11:03:25.282] - state: ‘created’
[11:03:25.282] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.284] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:03:25.284]   - Field: ‘label’
[11:03:25.284]   - Field: ‘local’
[11:03:25.284]   - Field: ‘owner’
[11:03:25.284]   - Field: ‘envir’
[11:03:25.285]   - Field: ‘workers’
[11:03:25.285]   - Field: ‘packages’
[11:03:25.285]   - Field: ‘gc’
[11:03:25.285]   - Field: ‘job’
[11:03:25.285]   - Field: ‘conditions’
[11:03:25.285]   - Field: ‘expr’
[11:03:25.285]   - Field: ‘uuid’
[11:03:25.285]   - Field: ‘seed’
[11:03:25.285]   - Field: ‘version’
[11:03:25.285]   - Field: ‘result’
[11:03:25.288]   - Field: ‘asynchronous’
[11:03:25.288]   - Field: ‘calls’
[11:03:25.288]   - Field: ‘globals’
[11:03:25.288]   - Field: ‘stdout’
[11:03:25.288]   - Field: ‘earlySignal’
[11:03:25.288]   - Field: ‘lazy’
[11:03:25.288]   - Field: ‘state’
[11:03:25.289] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:03:25.289] - Launch lazy future ...
[11:03:25.289] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.289] Packages needed by future strategies (n = 0): <none>
[11:03:25.290] {
[11:03:25.290]     {
[11:03:25.290]         {
[11:03:25.290]             ...future.startTime <- base::Sys.time()
[11:03:25.290]             {
[11:03:25.290]                 {
[11:03:25.290]                   {
[11:03:25.290]                     {
[11:03:25.290]                       {
[11:03:25.290]                         base::local({
[11:03:25.290]                           has_future <- base::requireNamespace("future", 
[11:03:25.290]                             quietly = TRUE)
[11:03:25.290]                           if (has_future) {
[11:03:25.290]                             ns <- base::getNamespace("future")
[11:03:25.290]                             version <- ns[[".package"]][["version"]]
[11:03:25.290]                             if (is.null(version)) 
[11:03:25.290]                               version <- utils::packageVersion("future")
[11:03:25.290]                           }
[11:03:25.290]                           else {
[11:03:25.290]                             version <- NULL
[11:03:25.290]                           }
[11:03:25.290]                           if (!has_future || version < "1.8.0") {
[11:03:25.290]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.290]                               "", base::R.version$version.string), 
[11:03:25.290]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:25.290]                                 base::R.version$platform, 8 * 
[11:03:25.290]                                   base::.Machine$sizeof.pointer), 
[11:03:25.290]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.290]                                 "release", "version")], collapse = " "), 
[11:03:25.290]                               hostname = base::Sys.info()[["nodename"]])
[11:03:25.290]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.290]                               info)
[11:03:25.290]                             info <- base::paste(info, collapse = "; ")
[11:03:25.290]                             if (!has_future) {
[11:03:25.290]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.290]                                 info)
[11:03:25.290]                             }
[11:03:25.290]                             else {
[11:03:25.290]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.290]                                 info, version)
[11:03:25.290]                             }
[11:03:25.290]                             base::stop(msg)
[11:03:25.290]                           }
[11:03:25.290]                         })
[11:03:25.290]                       }
[11:03:25.290]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.290]                       base::options(mc.cores = 1L)
[11:03:25.290]                     }
[11:03:25.290]                     base::local({
[11:03:25.290]                       for (pkg in "utils") {
[11:03:25.290]                         base::loadNamespace(pkg)
[11:03:25.290]                         base::library(pkg, character.only = TRUE)
[11:03:25.290]                       }
[11:03:25.290]                     })
[11:03:25.290]                   }
[11:03:25.290]                   ...future.strategy.old <- future::plan("list")
[11:03:25.290]                   options(future.plan = NULL)
[11:03:25.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.290]                 }
[11:03:25.290]                 ...future.workdir <- getwd()
[11:03:25.290]             }
[11:03:25.290]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.290]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.290]         }
[11:03:25.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.290]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.290]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.290]             base::names(...future.oldOptions))
[11:03:25.290]     }
[11:03:25.290]     if (TRUE) {
[11:03:25.290]     }
[11:03:25.290]     else {
[11:03:25.290]         if (NA) {
[11:03:25.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.290]                 open = "w")
[11:03:25.290]         }
[11:03:25.290]         else {
[11:03:25.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.290]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.290]         }
[11:03:25.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.290]             base::sink(type = "output", split = FALSE)
[11:03:25.290]             base::close(...future.stdout)
[11:03:25.290]         }, add = TRUE)
[11:03:25.290]     }
[11:03:25.290]     ...future.frame <- base::sys.nframe()
[11:03:25.290]     ...future.conditions <- base::list()
[11:03:25.290]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.290]     if (FALSE) {
[11:03:25.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.290]     }
[11:03:25.290]     ...future.result <- base::tryCatch({
[11:03:25.290]         base::withCallingHandlers({
[11:03:25.290]             ...future.value <- base::withVisible(base::local({
[11:03:25.290]                 withCallingHandlers({
[11:03:25.290]                   {
[11:03:25.290]                     print(1:50)
[11:03:25.290]                     str(1:50)
[11:03:25.290]                     cat(letters, sep = "-")
[11:03:25.290]                     cat(1:6, collapse = "\n")
[11:03:25.290]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.290]                     42L
[11:03:25.290]                   }
[11:03:25.290]                 }, immediateCondition = function(cond) {
[11:03:25.290]                   save_rds <- function (object, pathname, ...) 
[11:03:25.290]                   {
[11:03:25.290]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:03:25.290]                     if (file_test("-f", pathname_tmp)) {
[11:03:25.290]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.290]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:03:25.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.290]                         fi_tmp[["mtime"]])
[11:03:25.290]                     }
[11:03:25.290]                     tryCatch({
[11:03:25.290]                       saveRDS(object, file = pathname_tmp, ...)
[11:03:25.290]                     }, error = function(ex) {
[11:03:25.290]                       msg <- conditionMessage(ex)
[11:03:25.290]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.290]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:03:25.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.290]                         fi_tmp[["mtime"]], msg)
[11:03:25.290]                       ex$message <- msg
[11:03:25.290]                       stop(ex)
[11:03:25.290]                     })
[11:03:25.290]                     stopifnot(file_test("-f", pathname_tmp))
[11:03:25.290]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:03:25.290]                     if (!res || file_test("-f", pathname_tmp)) {
[11:03:25.290]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.290]                       fi <- file.info(pathname)
[11:03:25.290]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:03:25.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.290]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:03:25.290]                         fi[["size"]], fi[["mtime"]])
[11:03:25.290]                       stop(msg)
[11:03:25.290]                     }
[11:03:25.290]                     invisible(pathname)
[11:03:25.290]                   }
[11:03:25.290]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:03:25.290]                     rootPath = tempdir()) 
[11:03:25.290]                   {
[11:03:25.290]                     obj <- list(time = Sys.time(), condition = cond)
[11:03:25.290]                     file <- tempfile(pattern = class(cond)[1], 
[11:03:25.290]                       tmpdir = path, fileext = ".rds")
[11:03:25.290]                     save_rds(obj, file)
[11:03:25.290]                   }
[11:03:25.290]                   saveImmediateCondition(cond, path = "/tmp/RtmpjFuTgt/.future/immediateConditions")
[11:03:25.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.290]                   {
[11:03:25.290]                     inherits <- base::inherits
[11:03:25.290]                     invokeRestart <- base::invokeRestart
[11:03:25.290]                     is.null <- base::is.null
[11:03:25.290]                     muffled <- FALSE
[11:03:25.290]                     if (inherits(cond, "message")) {
[11:03:25.290]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.290]                       if (muffled) 
[11:03:25.290]                         invokeRestart("muffleMessage")
[11:03:25.290]                     }
[11:03:25.290]                     else if (inherits(cond, "warning")) {
[11:03:25.290]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.290]                       if (muffled) 
[11:03:25.290]                         invokeRestart("muffleWarning")
[11:03:25.290]                     }
[11:03:25.290]                     else if (inherits(cond, "condition")) {
[11:03:25.290]                       if (!is.null(pattern)) {
[11:03:25.290]                         computeRestarts <- base::computeRestarts
[11:03:25.290]                         grepl <- base::grepl
[11:03:25.290]                         restarts <- computeRestarts(cond)
[11:03:25.290]                         for (restart in restarts) {
[11:03:25.290]                           name <- restart$name
[11:03:25.290]                           if (is.null(name)) 
[11:03:25.290]                             next
[11:03:25.290]                           if (!grepl(pattern, name)) 
[11:03:25.290]                             next
[11:03:25.290]                           invokeRestart(restart)
[11:03:25.290]                           muffled <- TRUE
[11:03:25.290]                           break
[11:03:25.290]                         }
[11:03:25.290]                       }
[11:03:25.290]                     }
[11:03:25.290]                     invisible(muffled)
[11:03:25.290]                   }
[11:03:25.290]                   muffleCondition(cond)
[11:03:25.290]                 })
[11:03:25.290]             }))
[11:03:25.290]             future::FutureResult(value = ...future.value$value, 
[11:03:25.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.290]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.290]                     ...future.globalenv.names))
[11:03:25.290]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.290]         }, condition = base::local({
[11:03:25.290]             c <- base::c
[11:03:25.290]             inherits <- base::inherits
[11:03:25.290]             invokeRestart <- base::invokeRestart
[11:03:25.290]             length <- base::length
[11:03:25.290]             list <- base::list
[11:03:25.290]             seq.int <- base::seq.int
[11:03:25.290]             signalCondition <- base::signalCondition
[11:03:25.290]             sys.calls <- base::sys.calls
[11:03:25.290]             `[[` <- base::`[[`
[11:03:25.290]             `+` <- base::`+`
[11:03:25.290]             `<<-` <- base::`<<-`
[11:03:25.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.290]                   3L)]
[11:03:25.290]             }
[11:03:25.290]             function(cond) {
[11:03:25.290]                 is_error <- inherits(cond, "error")
[11:03:25.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.290]                   NULL)
[11:03:25.290]                 if (is_error) {
[11:03:25.290]                   sessionInformation <- function() {
[11:03:25.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.290]                       search = base::search(), system = base::Sys.info())
[11:03:25.290]                   }
[11:03:25.290]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.290]                     cond$call), session = sessionInformation(), 
[11:03:25.290]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.290]                   signalCondition(cond)
[11:03:25.290]                 }
[11:03:25.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.290]                 "immediateCondition"))) {
[11:03:25.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.290]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.290]                   if (TRUE && !signal) {
[11:03:25.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.290]                     {
[11:03:25.290]                       inherits <- base::inherits
[11:03:25.290]                       invokeRestart <- base::invokeRestart
[11:03:25.290]                       is.null <- base::is.null
[11:03:25.290]                       muffled <- FALSE
[11:03:25.290]                       if (inherits(cond, "message")) {
[11:03:25.290]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.290]                         if (muffled) 
[11:03:25.290]                           invokeRestart("muffleMessage")
[11:03:25.290]                       }
[11:03:25.290]                       else if (inherits(cond, "warning")) {
[11:03:25.290]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.290]                         if (muffled) 
[11:03:25.290]                           invokeRestart("muffleWarning")
[11:03:25.290]                       }
[11:03:25.290]                       else if (inherits(cond, "condition")) {
[11:03:25.290]                         if (!is.null(pattern)) {
[11:03:25.290]                           computeRestarts <- base::computeRestarts
[11:03:25.290]                           grepl <- base::grepl
[11:03:25.290]                           restarts <- computeRestarts(cond)
[11:03:25.290]                           for (restart in restarts) {
[11:03:25.290]                             name <- restart$name
[11:03:25.290]                             if (is.null(name)) 
[11:03:25.290]                               next
[11:03:25.290]                             if (!grepl(pattern, name)) 
[11:03:25.290]                               next
[11:03:25.290]                             invokeRestart(restart)
[11:03:25.290]                             muffled <- TRUE
[11:03:25.290]                             break
[11:03:25.290]                           }
[11:03:25.290]                         }
[11:03:25.290]                       }
[11:03:25.290]                       invisible(muffled)
[11:03:25.290]                     }
[11:03:25.290]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.290]                   }
[11:03:25.290]                 }
[11:03:25.290]                 else {
[11:03:25.290]                   if (TRUE) {
[11:03:25.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.290]                     {
[11:03:25.290]                       inherits <- base::inherits
[11:03:25.290]                       invokeRestart <- base::invokeRestart
[11:03:25.290]                       is.null <- base::is.null
[11:03:25.290]                       muffled <- FALSE
[11:03:25.290]                       if (inherits(cond, "message")) {
[11:03:25.290]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.290]                         if (muffled) 
[11:03:25.290]                           invokeRestart("muffleMessage")
[11:03:25.290]                       }
[11:03:25.290]                       else if (inherits(cond, "warning")) {
[11:03:25.290]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.290]                         if (muffled) 
[11:03:25.290]                           invokeRestart("muffleWarning")
[11:03:25.290]                       }
[11:03:25.290]                       else if (inherits(cond, "condition")) {
[11:03:25.290]                         if (!is.null(pattern)) {
[11:03:25.290]                           computeRestarts <- base::computeRestarts
[11:03:25.290]                           grepl <- base::grepl
[11:03:25.290]                           restarts <- computeRestarts(cond)
[11:03:25.290]                           for (restart in restarts) {
[11:03:25.290]                             name <- restart$name
[11:03:25.290]                             if (is.null(name)) 
[11:03:25.290]                               next
[11:03:25.290]                             if (!grepl(pattern, name)) 
[11:03:25.290]                               next
[11:03:25.290]                             invokeRestart(restart)
[11:03:25.290]                             muffled <- TRUE
[11:03:25.290]                             break
[11:03:25.290]                           }
[11:03:25.290]                         }
[11:03:25.290]                       }
[11:03:25.290]                       invisible(muffled)
[11:03:25.290]                     }
[11:03:25.290]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.290]                   }
[11:03:25.290]                 }
[11:03:25.290]             }
[11:03:25.290]         }))
[11:03:25.290]     }, error = function(ex) {
[11:03:25.290]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.290]                 ...future.rng), started = ...future.startTime, 
[11:03:25.290]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.290]             version = "1.8"), class = "FutureResult")
[11:03:25.290]     }, finally = {
[11:03:25.290]         if (!identical(...future.workdir, getwd())) 
[11:03:25.290]             setwd(...future.workdir)
[11:03:25.290]         {
[11:03:25.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.290]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.290]             }
[11:03:25.290]             base::options(...future.oldOptions)
[11:03:25.290]             if (.Platform$OS.type == "windows") {
[11:03:25.290]                 old_names <- names(...future.oldEnvVars)
[11:03:25.290]                 envs <- base::Sys.getenv()
[11:03:25.290]                 names <- names(envs)
[11:03:25.290]                 common <- intersect(names, old_names)
[11:03:25.290]                 added <- setdiff(names, old_names)
[11:03:25.290]                 removed <- setdiff(old_names, names)
[11:03:25.290]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.290]                   envs[common]]
[11:03:25.290]                 NAMES <- toupper(changed)
[11:03:25.290]                 args <- list()
[11:03:25.290]                 for (kk in seq_along(NAMES)) {
[11:03:25.290]                   name <- changed[[kk]]
[11:03:25.290]                   NAME <- NAMES[[kk]]
[11:03:25.290]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.290]                     next
[11:03:25.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.290]                 }
[11:03:25.290]                 NAMES <- toupper(added)
[11:03:25.290]                 for (kk in seq_along(NAMES)) {
[11:03:25.290]                   name <- added[[kk]]
[11:03:25.290]                   NAME <- NAMES[[kk]]
[11:03:25.290]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.290]                     next
[11:03:25.290]                   args[[name]] <- ""
[11:03:25.290]                 }
[11:03:25.290]                 NAMES <- toupper(removed)
[11:03:25.290]                 for (kk in seq_along(NAMES)) {
[11:03:25.290]                   name <- removed[[kk]]
[11:03:25.290]                   NAME <- NAMES[[kk]]
[11:03:25.290]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.290]                     next
[11:03:25.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.290]                 }
[11:03:25.290]                 if (length(args) > 0) 
[11:03:25.290]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.290]             }
[11:03:25.290]             else {
[11:03:25.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.290]             }
[11:03:25.290]             {
[11:03:25.290]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.290]                   0L) {
[11:03:25.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.290]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.290]                   base::options(opts)
[11:03:25.290]                 }
[11:03:25.290]                 {
[11:03:25.290]                   {
[11:03:25.290]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.290]                     NULL
[11:03:25.290]                   }
[11:03:25.290]                   options(future.plan = NULL)
[11:03:25.290]                   if (is.na(NA_character_)) 
[11:03:25.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.290]                     .init = FALSE)
[11:03:25.290]                 }
[11:03:25.290]             }
[11:03:25.290]         }
[11:03:25.290]     })
[11:03:25.290]     if (FALSE) {
[11:03:25.290]         base::sink(type = "output", split = FALSE)
[11:03:25.290]         if (NA) {
[11:03:25.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.290]         }
[11:03:25.290]         else {
[11:03:25.290]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.290]         }
[11:03:25.290]         base::close(...future.stdout)
[11:03:25.290]         ...future.stdout <- NULL
[11:03:25.290]     }
[11:03:25.290]     ...future.result$conditions <- ...future.conditions
[11:03:25.290]     ...future.result$finished <- base::Sys.time()
[11:03:25.290]     ...future.result
[11:03:25.290] }
[11:03:25.292] requestCore(): workers = 2
[11:03:25.294] MulticoreFuture started
[11:03:25.294] - Launch lazy future ... done
[11:03:25.295] run() for ‘MulticoreFuture’ ... done
[11:03:25.295] result() for MulticoreFuture ...
[11:03:25.295] plan(): Setting new future strategy stack:
[11:03:25.295] List of future strategies:
[11:03:25.295] 1. sequential:
[11:03:25.295]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.295]    - tweaked: FALSE
[11:03:25.295]    - call: NULL
[11:03:25.296] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[11:03:25.300] plan(): Setting new future strategy stack:
[11:03:25.300] List of future strategies:
[11:03:25.300] 1. multicore:
[11:03:25.300]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.300]    - tweaked: FALSE
[11:03:25.300]    - call: plan(strategy)
[11:03:25.303] plan(): nbrOfWorkers() = 2
[11:03:25.303] result() for MulticoreFuture ...
[11:03:25.304] result() for MulticoreFuture ... done
[11:03:25.304] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ finished    : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ session_uuid: chr "458240a6-aea0-e8f3-96f9-be71a1d75d2b"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "173ee284ba16"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 85017
  .. ..$ time  : POSIXct[1:1], format: "2025-05-06 11:03:25"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[11:03:25.313] result() for MulticoreFuture ...
[11:03:25.313] result() for MulticoreFuture ... done
[11:03:25.313] result() for MulticoreFuture ...
[11:03:25.313] result() for MulticoreFuture ... done
[11:03:25.313] getGlobalsAndPackages() ...
[11:03:25.314] Searching for globals...
[11:03:25.317] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.317] Searching for globals ... DONE
[11:03:25.318] Resolving globals: FALSE
[11:03:25.318] 
[11:03:25.318] - packages: [1] ‘utils’
[11:03:25.318] getGlobalsAndPackages() ... DONE
[11:03:25.319] run() for ‘Future’ ...
[11:03:25.319] - state: ‘created’
[11:03:25.319] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.321] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.321] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:03:25.321]   - Field: ‘label’
[11:03:25.321]   - Field: ‘local’
[11:03:25.321]   - Field: ‘owner’
[11:03:25.321]   - Field: ‘envir’
[11:03:25.322]   - Field: ‘workers’
[11:03:25.322]   - Field: ‘packages’
[11:03:25.322]   - Field: ‘gc’
[11:03:25.322]   - Field: ‘job’
[11:03:25.322]   - Field: ‘conditions’
[11:03:25.322]   - Field: ‘expr’
[11:03:25.322]   - Field: ‘uuid’
[11:03:25.322]   - Field: ‘seed’
[11:03:25.322]   - Field: ‘version’
[11:03:25.322]   - Field: ‘result’
[11:03:25.323]   - Field: ‘asynchronous’
[11:03:25.323]   - Field: ‘calls’
[11:03:25.323]   - Field: ‘globals’
[11:03:25.323]   - Field: ‘stdout’
[11:03:25.323]   - Field: ‘earlySignal’
[11:03:25.323]   - Field: ‘lazy’
[11:03:25.323]   - Field: ‘state’
[11:03:25.323] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:03:25.323] - Launch lazy future ...
[11:03:25.324] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.324] Packages needed by future strategies (n = 0): <none>
[11:03:25.324] {
[11:03:25.324]     {
[11:03:25.324]         {
[11:03:25.324]             ...future.startTime <- base::Sys.time()
[11:03:25.324]             {
[11:03:25.324]                 {
[11:03:25.324]                   {
[11:03:25.324]                     {
[11:03:25.324]                       {
[11:03:25.324]                         base::local({
[11:03:25.324]                           has_future <- base::requireNamespace("future", 
[11:03:25.324]                             quietly = TRUE)
[11:03:25.324]                           if (has_future) {
[11:03:25.324]                             ns <- base::getNamespace("future")
[11:03:25.324]                             version <- ns[[".package"]][["version"]]
[11:03:25.324]                             if (is.null(version)) 
[11:03:25.324]                               version <- utils::packageVersion("future")
[11:03:25.324]                           }
[11:03:25.324]                           else {
[11:03:25.324]                             version <- NULL
[11:03:25.324]                           }
[11:03:25.324]                           if (!has_future || version < "1.8.0") {
[11:03:25.324]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.324]                               "", base::R.version$version.string), 
[11:03:25.324]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:25.324]                                 base::R.version$platform, 8 * 
[11:03:25.324]                                   base::.Machine$sizeof.pointer), 
[11:03:25.324]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.324]                                 "release", "version")], collapse = " "), 
[11:03:25.324]                               hostname = base::Sys.info()[["nodename"]])
[11:03:25.324]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.324]                               info)
[11:03:25.324]                             info <- base::paste(info, collapse = "; ")
[11:03:25.324]                             if (!has_future) {
[11:03:25.324]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.324]                                 info)
[11:03:25.324]                             }
[11:03:25.324]                             else {
[11:03:25.324]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.324]                                 info, version)
[11:03:25.324]                             }
[11:03:25.324]                             base::stop(msg)
[11:03:25.324]                           }
[11:03:25.324]                         })
[11:03:25.324]                       }
[11:03:25.324]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.324]                       base::options(mc.cores = 1L)
[11:03:25.324]                     }
[11:03:25.324]                     base::local({
[11:03:25.324]                       for (pkg in "utils") {
[11:03:25.324]                         base::loadNamespace(pkg)
[11:03:25.324]                         base::library(pkg, character.only = TRUE)
[11:03:25.324]                       }
[11:03:25.324]                     })
[11:03:25.324]                   }
[11:03:25.324]                   ...future.strategy.old <- future::plan("list")
[11:03:25.324]                   options(future.plan = NULL)
[11:03:25.324]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.324]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.324]                 }
[11:03:25.324]                 ...future.workdir <- getwd()
[11:03:25.324]             }
[11:03:25.324]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.324]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.324]         }
[11:03:25.324]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.324]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.324]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.324]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.324]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.324]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.324]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.324]             base::names(...future.oldOptions))
[11:03:25.324]     }
[11:03:25.324]     if (TRUE) {
[11:03:25.324]     }
[11:03:25.324]     else {
[11:03:25.324]         if (NA) {
[11:03:25.324]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.324]                 open = "w")
[11:03:25.324]         }
[11:03:25.324]         else {
[11:03:25.324]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.324]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.324]         }
[11:03:25.324]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.324]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.324]             base::sink(type = "output", split = FALSE)
[11:03:25.324]             base::close(...future.stdout)
[11:03:25.324]         }, add = TRUE)
[11:03:25.324]     }
[11:03:25.324]     ...future.frame <- base::sys.nframe()
[11:03:25.324]     ...future.conditions <- base::list()
[11:03:25.324]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.324]     if (FALSE) {
[11:03:25.324]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.324]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.324]     }
[11:03:25.324]     ...future.result <- base::tryCatch({
[11:03:25.324]         base::withCallingHandlers({
[11:03:25.324]             ...future.value <- base::withVisible(base::local({
[11:03:25.324]                 withCallingHandlers({
[11:03:25.324]                   {
[11:03:25.324]                     print(1:50)
[11:03:25.324]                     str(1:50)
[11:03:25.324]                     cat(letters, sep = "-")
[11:03:25.324]                     cat(1:6, collapse = "\n")
[11:03:25.324]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.324]                     42L
[11:03:25.324]                   }
[11:03:25.324]                 }, immediateCondition = function(cond) {
[11:03:25.324]                   save_rds <- function (object, pathname, ...) 
[11:03:25.324]                   {
[11:03:25.324]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:03:25.324]                     if (file_test("-f", pathname_tmp)) {
[11:03:25.324]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.324]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:03:25.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.324]                         fi_tmp[["mtime"]])
[11:03:25.324]                     }
[11:03:25.324]                     tryCatch({
[11:03:25.324]                       saveRDS(object, file = pathname_tmp, ...)
[11:03:25.324]                     }, error = function(ex) {
[11:03:25.324]                       msg <- conditionMessage(ex)
[11:03:25.324]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.324]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:03:25.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.324]                         fi_tmp[["mtime"]], msg)
[11:03:25.324]                       ex$message <- msg
[11:03:25.324]                       stop(ex)
[11:03:25.324]                     })
[11:03:25.324]                     stopifnot(file_test("-f", pathname_tmp))
[11:03:25.324]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:03:25.324]                     if (!res || file_test("-f", pathname_tmp)) {
[11:03:25.324]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.324]                       fi <- file.info(pathname)
[11:03:25.324]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:03:25.324]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.324]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:03:25.324]                         fi[["size"]], fi[["mtime"]])
[11:03:25.324]                       stop(msg)
[11:03:25.324]                     }
[11:03:25.324]                     invisible(pathname)
[11:03:25.324]                   }
[11:03:25.324]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:03:25.324]                     rootPath = tempdir()) 
[11:03:25.324]                   {
[11:03:25.324]                     obj <- list(time = Sys.time(), condition = cond)
[11:03:25.324]                     file <- tempfile(pattern = class(cond)[1], 
[11:03:25.324]                       tmpdir = path, fileext = ".rds")
[11:03:25.324]                     save_rds(obj, file)
[11:03:25.324]                   }
[11:03:25.324]                   saveImmediateCondition(cond, path = "/tmp/RtmpjFuTgt/.future/immediateConditions")
[11:03:25.324]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.324]                   {
[11:03:25.324]                     inherits <- base::inherits
[11:03:25.324]                     invokeRestart <- base::invokeRestart
[11:03:25.324]                     is.null <- base::is.null
[11:03:25.324]                     muffled <- FALSE
[11:03:25.324]                     if (inherits(cond, "message")) {
[11:03:25.324]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.324]                       if (muffled) 
[11:03:25.324]                         invokeRestart("muffleMessage")
[11:03:25.324]                     }
[11:03:25.324]                     else if (inherits(cond, "warning")) {
[11:03:25.324]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.324]                       if (muffled) 
[11:03:25.324]                         invokeRestart("muffleWarning")
[11:03:25.324]                     }
[11:03:25.324]                     else if (inherits(cond, "condition")) {
[11:03:25.324]                       if (!is.null(pattern)) {
[11:03:25.324]                         computeRestarts <- base::computeRestarts
[11:03:25.324]                         grepl <- base::grepl
[11:03:25.324]                         restarts <- computeRestarts(cond)
[11:03:25.324]                         for (restart in restarts) {
[11:03:25.324]                           name <- restart$name
[11:03:25.324]                           if (is.null(name)) 
[11:03:25.324]                             next
[11:03:25.324]                           if (!grepl(pattern, name)) 
[11:03:25.324]                             next
[11:03:25.324]                           invokeRestart(restart)
[11:03:25.324]                           muffled <- TRUE
[11:03:25.324]                           break
[11:03:25.324]                         }
[11:03:25.324]                       }
[11:03:25.324]                     }
[11:03:25.324]                     invisible(muffled)
[11:03:25.324]                   }
[11:03:25.324]                   muffleCondition(cond)
[11:03:25.324]                 })
[11:03:25.324]             }))
[11:03:25.324]             future::FutureResult(value = ...future.value$value, 
[11:03:25.324]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.324]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.324]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.324]                     ...future.globalenv.names))
[11:03:25.324]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.324]         }, condition = base::local({
[11:03:25.324]             c <- base::c
[11:03:25.324]             inherits <- base::inherits
[11:03:25.324]             invokeRestart <- base::invokeRestart
[11:03:25.324]             length <- base::length
[11:03:25.324]             list <- base::list
[11:03:25.324]             seq.int <- base::seq.int
[11:03:25.324]             signalCondition <- base::signalCondition
[11:03:25.324]             sys.calls <- base::sys.calls
[11:03:25.324]             `[[` <- base::`[[`
[11:03:25.324]             `+` <- base::`+`
[11:03:25.324]             `<<-` <- base::`<<-`
[11:03:25.324]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.324]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.324]                   3L)]
[11:03:25.324]             }
[11:03:25.324]             function(cond) {
[11:03:25.324]                 is_error <- inherits(cond, "error")
[11:03:25.324]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.324]                   NULL)
[11:03:25.324]                 if (is_error) {
[11:03:25.324]                   sessionInformation <- function() {
[11:03:25.324]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.324]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.324]                       search = base::search(), system = base::Sys.info())
[11:03:25.324]                   }
[11:03:25.324]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.324]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.324]                     cond$call), session = sessionInformation(), 
[11:03:25.324]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.324]                   signalCondition(cond)
[11:03:25.324]                 }
[11:03:25.324]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.324]                 "immediateCondition"))) {
[11:03:25.324]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.324]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.324]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.324]                   if (TRUE && !signal) {
[11:03:25.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.324]                     {
[11:03:25.324]                       inherits <- base::inherits
[11:03:25.324]                       invokeRestart <- base::invokeRestart
[11:03:25.324]                       is.null <- base::is.null
[11:03:25.324]                       muffled <- FALSE
[11:03:25.324]                       if (inherits(cond, "message")) {
[11:03:25.324]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.324]                         if (muffled) 
[11:03:25.324]                           invokeRestart("muffleMessage")
[11:03:25.324]                       }
[11:03:25.324]                       else if (inherits(cond, "warning")) {
[11:03:25.324]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.324]                         if (muffled) 
[11:03:25.324]                           invokeRestart("muffleWarning")
[11:03:25.324]                       }
[11:03:25.324]                       else if (inherits(cond, "condition")) {
[11:03:25.324]                         if (!is.null(pattern)) {
[11:03:25.324]                           computeRestarts <- base::computeRestarts
[11:03:25.324]                           grepl <- base::grepl
[11:03:25.324]                           restarts <- computeRestarts(cond)
[11:03:25.324]                           for (restart in restarts) {
[11:03:25.324]                             name <- restart$name
[11:03:25.324]                             if (is.null(name)) 
[11:03:25.324]                               next
[11:03:25.324]                             if (!grepl(pattern, name)) 
[11:03:25.324]                               next
[11:03:25.324]                             invokeRestart(restart)
[11:03:25.324]                             muffled <- TRUE
[11:03:25.324]                             break
[11:03:25.324]                           }
[11:03:25.324]                         }
[11:03:25.324]                       }
[11:03:25.324]                       invisible(muffled)
[11:03:25.324]                     }
[11:03:25.324]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.324]                   }
[11:03:25.324]                 }
[11:03:25.324]                 else {
[11:03:25.324]                   if (TRUE) {
[11:03:25.324]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.324]                     {
[11:03:25.324]                       inherits <- base::inherits
[11:03:25.324]                       invokeRestart <- base::invokeRestart
[11:03:25.324]                       is.null <- base::is.null
[11:03:25.324]                       muffled <- FALSE
[11:03:25.324]                       if (inherits(cond, "message")) {
[11:03:25.324]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.324]                         if (muffled) 
[11:03:25.324]                           invokeRestart("muffleMessage")
[11:03:25.324]                       }
[11:03:25.324]                       else if (inherits(cond, "warning")) {
[11:03:25.324]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.324]                         if (muffled) 
[11:03:25.324]                           invokeRestart("muffleWarning")
[11:03:25.324]                       }
[11:03:25.324]                       else if (inherits(cond, "condition")) {
[11:03:25.324]                         if (!is.null(pattern)) {
[11:03:25.324]                           computeRestarts <- base::computeRestarts
[11:03:25.324]                           grepl <- base::grepl
[11:03:25.324]                           restarts <- computeRestarts(cond)
[11:03:25.324]                           for (restart in restarts) {
[11:03:25.324]                             name <- restart$name
[11:03:25.324]                             if (is.null(name)) 
[11:03:25.324]                               next
[11:03:25.324]                             if (!grepl(pattern, name)) 
[11:03:25.324]                               next
[11:03:25.324]                             invokeRestart(restart)
[11:03:25.324]                             muffled <- TRUE
[11:03:25.324]                             break
[11:03:25.324]                           }
[11:03:25.324]                         }
[11:03:25.324]                       }
[11:03:25.324]                       invisible(muffled)
[11:03:25.324]                     }
[11:03:25.324]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.324]                   }
[11:03:25.324]                 }
[11:03:25.324]             }
[11:03:25.324]         }))
[11:03:25.324]     }, error = function(ex) {
[11:03:25.324]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.324]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.324]                 ...future.rng), started = ...future.startTime, 
[11:03:25.324]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.324]             version = "1.8"), class = "FutureResult")
[11:03:25.324]     }, finally = {
[11:03:25.324]         if (!identical(...future.workdir, getwd())) 
[11:03:25.324]             setwd(...future.workdir)
[11:03:25.324]         {
[11:03:25.324]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.324]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.324]             }
[11:03:25.324]             base::options(...future.oldOptions)
[11:03:25.324]             if (.Platform$OS.type == "windows") {
[11:03:25.324]                 old_names <- names(...future.oldEnvVars)
[11:03:25.324]                 envs <- base::Sys.getenv()
[11:03:25.324]                 names <- names(envs)
[11:03:25.324]                 common <- intersect(names, old_names)
[11:03:25.324]                 added <- setdiff(names, old_names)
[11:03:25.324]                 removed <- setdiff(old_names, names)
[11:03:25.324]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.324]                   envs[common]]
[11:03:25.324]                 NAMES <- toupper(changed)
[11:03:25.324]                 args <- list()
[11:03:25.324]                 for (kk in seq_along(NAMES)) {
[11:03:25.324]                   name <- changed[[kk]]
[11:03:25.324]                   NAME <- NAMES[[kk]]
[11:03:25.324]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.324]                     next
[11:03:25.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.324]                 }
[11:03:25.324]                 NAMES <- toupper(added)
[11:03:25.324]                 for (kk in seq_along(NAMES)) {
[11:03:25.324]                   name <- added[[kk]]
[11:03:25.324]                   NAME <- NAMES[[kk]]
[11:03:25.324]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.324]                     next
[11:03:25.324]                   args[[name]] <- ""
[11:03:25.324]                 }
[11:03:25.324]                 NAMES <- toupper(removed)
[11:03:25.324]                 for (kk in seq_along(NAMES)) {
[11:03:25.324]                   name <- removed[[kk]]
[11:03:25.324]                   NAME <- NAMES[[kk]]
[11:03:25.324]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.324]                     next
[11:03:25.324]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.324]                 }
[11:03:25.324]                 if (length(args) > 0) 
[11:03:25.324]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.324]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.324]             }
[11:03:25.324]             else {
[11:03:25.324]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.324]             }
[11:03:25.324]             {
[11:03:25.324]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.324]                   0L) {
[11:03:25.324]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.324]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.324]                   base::options(opts)
[11:03:25.324]                 }
[11:03:25.324]                 {
[11:03:25.324]                   {
[11:03:25.324]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.324]                     NULL
[11:03:25.324]                   }
[11:03:25.324]                   options(future.plan = NULL)
[11:03:25.324]                   if (is.na(NA_character_)) 
[11:03:25.324]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.324]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.324]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.324]                     .init = FALSE)
[11:03:25.324]                 }
[11:03:25.324]             }
[11:03:25.324]         }
[11:03:25.324]     })
[11:03:25.324]     if (FALSE) {
[11:03:25.324]         base::sink(type = "output", split = FALSE)
[11:03:25.324]         if (NA) {
[11:03:25.324]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.324]         }
[11:03:25.324]         else {
[11:03:25.324]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.324]         }
[11:03:25.324]         base::close(...future.stdout)
[11:03:25.324]         ...future.stdout <- NULL
[11:03:25.324]     }
[11:03:25.324]     ...future.result$conditions <- ...future.conditions
[11:03:25.324]     ...future.result$finished <- base::Sys.time()
[11:03:25.324]     ...future.result
[11:03:25.324] }
[11:03:25.327] requestCore(): workers = 2
[11:03:25.329] MulticoreFuture started
[11:03:25.329] - Launch lazy future ... done
[11:03:25.329] run() for ‘MulticoreFuture’ ... done
[11:03:25.330] result() for MulticoreFuture ...
[11:03:25.330] plan(): Setting new future strategy stack:
[11:03:25.330] List of future strategies:
[11:03:25.330] 1. sequential:
[11:03:25.330]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.330]    - tweaked: FALSE
[11:03:25.330]    - call: NULL
[11:03:25.331] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[11:03:25.338] plan(): Setting new future strategy stack:
[11:03:25.339] List of future strategies:
[11:03:25.339] 1. multicore:
[11:03:25.339]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.339]    - tweaked: FALSE
[11:03:25.339]    - call: plan(strategy)
[11:03:25.342] plan(): nbrOfWorkers() = 2
[11:03:25.342] result() for MulticoreFuture ...
[11:03:25.342] result() for MulticoreFuture ... done
[11:03:25.343] result() for MulticoreFuture ... done
[11:03:25.343] result() for MulticoreFuture ...
[11:03:25.343] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[11:03:25.345] getGlobalsAndPackages() ...
[11:03:25.345] Searching for globals...
[11:03:25.346] - globals found: [1] ‘print’
[11:03:25.346] Searching for globals ... DONE
[11:03:25.347] Resolving globals: FALSE
[11:03:25.347] 
[11:03:25.347] 
[11:03:25.347] getGlobalsAndPackages() ... DONE
[11:03:25.348] run() for ‘Future’ ...
[11:03:25.348] - state: ‘created’
[11:03:25.348] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.350] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:03:25.350]   - Field: ‘label’
[11:03:25.350]   - Field: ‘local’
[11:03:25.350]   - Field: ‘owner’
[11:03:25.350]   - Field: ‘envir’
[11:03:25.351]   - Field: ‘workers’
[11:03:25.351]   - Field: ‘packages’
[11:03:25.351]   - Field: ‘gc’
[11:03:25.351]   - Field: ‘job’
[11:03:25.351]   - Field: ‘conditions’
[11:03:25.351]   - Field: ‘expr’
[11:03:25.351]   - Field: ‘uuid’
[11:03:25.351]   - Field: ‘seed’
[11:03:25.351]   - Field: ‘version’
[11:03:25.352]   - Field: ‘result’
[11:03:25.352]   - Field: ‘asynchronous’
[11:03:25.352]   - Field: ‘calls’
[11:03:25.352]   - Field: ‘globals’
[11:03:25.352]   - Field: ‘stdout’
[11:03:25.352]   - Field: ‘earlySignal’
[11:03:25.352]   - Field: ‘lazy’
[11:03:25.352]   - Field: ‘state’
[11:03:25.352] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:03:25.352] - Launch lazy future ...
[11:03:25.353] Packages needed by the future expression (n = 0): <none>
[11:03:25.353] Packages needed by future strategies (n = 0): <none>
[11:03:25.353] {
[11:03:25.353]     {
[11:03:25.353]         {
[11:03:25.353]             ...future.startTime <- base::Sys.time()
[11:03:25.353]             {
[11:03:25.353]                 {
[11:03:25.353]                   {
[11:03:25.353]                     {
[11:03:25.353]                       base::local({
[11:03:25.353]                         has_future <- base::requireNamespace("future", 
[11:03:25.353]                           quietly = TRUE)
[11:03:25.353]                         if (has_future) {
[11:03:25.353]                           ns <- base::getNamespace("future")
[11:03:25.353]                           version <- ns[[".package"]][["version"]]
[11:03:25.353]                           if (is.null(version)) 
[11:03:25.353]                             version <- utils::packageVersion("future")
[11:03:25.353]                         }
[11:03:25.353]                         else {
[11:03:25.353]                           version <- NULL
[11:03:25.353]                         }
[11:03:25.353]                         if (!has_future || version < "1.8.0") {
[11:03:25.353]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.353]                             "", base::R.version$version.string), 
[11:03:25.353]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:25.353]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.353]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.353]                               "release", "version")], collapse = " "), 
[11:03:25.353]                             hostname = base::Sys.info()[["nodename"]])
[11:03:25.353]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.353]                             info)
[11:03:25.353]                           info <- base::paste(info, collapse = "; ")
[11:03:25.353]                           if (!has_future) {
[11:03:25.353]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.353]                               info)
[11:03:25.353]                           }
[11:03:25.353]                           else {
[11:03:25.353]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.353]                               info, version)
[11:03:25.353]                           }
[11:03:25.353]                           base::stop(msg)
[11:03:25.353]                         }
[11:03:25.353]                       })
[11:03:25.353]                     }
[11:03:25.353]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.353]                     base::options(mc.cores = 1L)
[11:03:25.353]                   }
[11:03:25.353]                   ...future.strategy.old <- future::plan("list")
[11:03:25.353]                   options(future.plan = NULL)
[11:03:25.353]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.353]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.353]                 }
[11:03:25.353]                 ...future.workdir <- getwd()
[11:03:25.353]             }
[11:03:25.353]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.353]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.353]         }
[11:03:25.353]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.353]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.353]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.353]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.353]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.353]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.353]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.353]             base::names(...future.oldOptions))
[11:03:25.353]     }
[11:03:25.353]     if (FALSE) {
[11:03:25.353]     }
[11:03:25.353]     else {
[11:03:25.353]         if (TRUE) {
[11:03:25.353]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.353]                 open = "w")
[11:03:25.353]         }
[11:03:25.353]         else {
[11:03:25.353]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.353]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.353]         }
[11:03:25.353]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.353]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.353]             base::sink(type = "output", split = FALSE)
[11:03:25.353]             base::close(...future.stdout)
[11:03:25.353]         }, add = TRUE)
[11:03:25.353]     }
[11:03:25.353]     ...future.frame <- base::sys.nframe()
[11:03:25.353]     ...future.conditions <- base::list()
[11:03:25.353]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.353]     if (FALSE) {
[11:03:25.353]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.353]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.353]     }
[11:03:25.353]     ...future.result <- base::tryCatch({
[11:03:25.353]         base::withCallingHandlers({
[11:03:25.353]             ...future.value <- base::withVisible(base::local({
[11:03:25.353]                 withCallingHandlers({
[11:03:25.353]                   print(42)
[11:03:25.353]                 }, immediateCondition = function(cond) {
[11:03:25.353]                   save_rds <- function (object, pathname, ...) 
[11:03:25.353]                   {
[11:03:25.353]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:03:25.353]                     if (file_test("-f", pathname_tmp)) {
[11:03:25.353]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.353]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:03:25.353]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.353]                         fi_tmp[["mtime"]])
[11:03:25.353]                     }
[11:03:25.353]                     tryCatch({
[11:03:25.353]                       saveRDS(object, file = pathname_tmp, ...)
[11:03:25.353]                     }, error = function(ex) {
[11:03:25.353]                       msg <- conditionMessage(ex)
[11:03:25.353]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.353]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:03:25.353]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.353]                         fi_tmp[["mtime"]], msg)
[11:03:25.353]                       ex$message <- msg
[11:03:25.353]                       stop(ex)
[11:03:25.353]                     })
[11:03:25.353]                     stopifnot(file_test("-f", pathname_tmp))
[11:03:25.353]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:03:25.353]                     if (!res || file_test("-f", pathname_tmp)) {
[11:03:25.353]                       fi_tmp <- file.info(pathname_tmp)
[11:03:25.353]                       fi <- file.info(pathname)
[11:03:25.353]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:03:25.353]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:03:25.353]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:03:25.353]                         fi[["size"]], fi[["mtime"]])
[11:03:25.353]                       stop(msg)
[11:03:25.353]                     }
[11:03:25.353]                     invisible(pathname)
[11:03:25.353]                   }
[11:03:25.353]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:03:25.353]                     rootPath = tempdir()) 
[11:03:25.353]                   {
[11:03:25.353]                     obj <- list(time = Sys.time(), condition = cond)
[11:03:25.353]                     file <- tempfile(pattern = class(cond)[1], 
[11:03:25.353]                       tmpdir = path, fileext = ".rds")
[11:03:25.353]                     save_rds(obj, file)
[11:03:25.353]                   }
[11:03:25.353]                   saveImmediateCondition(cond, path = "/tmp/RtmpjFuTgt/.future/immediateConditions")
[11:03:25.353]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.353]                   {
[11:03:25.353]                     inherits <- base::inherits
[11:03:25.353]                     invokeRestart <- base::invokeRestart
[11:03:25.353]                     is.null <- base::is.null
[11:03:25.353]                     muffled <- FALSE
[11:03:25.353]                     if (inherits(cond, "message")) {
[11:03:25.353]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.353]                       if (muffled) 
[11:03:25.353]                         invokeRestart("muffleMessage")
[11:03:25.353]                     }
[11:03:25.353]                     else if (inherits(cond, "warning")) {
[11:03:25.353]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.353]                       if (muffled) 
[11:03:25.353]                         invokeRestart("muffleWarning")
[11:03:25.353]                     }
[11:03:25.353]                     else if (inherits(cond, "condition")) {
[11:03:25.353]                       if (!is.null(pattern)) {
[11:03:25.353]                         computeRestarts <- base::computeRestarts
[11:03:25.353]                         grepl <- base::grepl
[11:03:25.353]                         restarts <- computeRestarts(cond)
[11:03:25.353]                         for (restart in restarts) {
[11:03:25.353]                           name <- restart$name
[11:03:25.353]                           if (is.null(name)) 
[11:03:25.353]                             next
[11:03:25.353]                           if (!grepl(pattern, name)) 
[11:03:25.353]                             next
[11:03:25.353]                           invokeRestart(restart)
[11:03:25.353]                           muffled <- TRUE
[11:03:25.353]                           break
[11:03:25.353]                         }
[11:03:25.353]                       }
[11:03:25.353]                     }
[11:03:25.353]                     invisible(muffled)
[11:03:25.353]                   }
[11:03:25.353]                   muffleCondition(cond)
[11:03:25.353]                 })
[11:03:25.353]             }))
[11:03:25.353]             future::FutureResult(value = ...future.value$value, 
[11:03:25.353]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.353]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.353]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.353]                     ...future.globalenv.names))
[11:03:25.353]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.353]         }, condition = base::local({
[11:03:25.353]             c <- base::c
[11:03:25.353]             inherits <- base::inherits
[11:03:25.353]             invokeRestart <- base::invokeRestart
[11:03:25.353]             length <- base::length
[11:03:25.353]             list <- base::list
[11:03:25.353]             seq.int <- base::seq.int
[11:03:25.353]             signalCondition <- base::signalCondition
[11:03:25.353]             sys.calls <- base::sys.calls
[11:03:25.353]             `[[` <- base::`[[`
[11:03:25.353]             `+` <- base::`+`
[11:03:25.353]             `<<-` <- base::`<<-`
[11:03:25.353]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.353]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.353]                   3L)]
[11:03:25.353]             }
[11:03:25.353]             function(cond) {
[11:03:25.353]                 is_error <- inherits(cond, "error")
[11:03:25.353]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.353]                   NULL)
[11:03:25.353]                 if (is_error) {
[11:03:25.353]                   sessionInformation <- function() {
[11:03:25.353]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.353]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.353]                       search = base::search(), system = base::Sys.info())
[11:03:25.353]                   }
[11:03:25.353]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.353]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.353]                     cond$call), session = sessionInformation(), 
[11:03:25.353]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.353]                   signalCondition(cond)
[11:03:25.353]                 }
[11:03:25.353]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.353]                 "immediateCondition"))) {
[11:03:25.353]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.353]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.353]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.353]                   if (TRUE && !signal) {
[11:03:25.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.353]                     {
[11:03:25.353]                       inherits <- base::inherits
[11:03:25.353]                       invokeRestart <- base::invokeRestart
[11:03:25.353]                       is.null <- base::is.null
[11:03:25.353]                       muffled <- FALSE
[11:03:25.353]                       if (inherits(cond, "message")) {
[11:03:25.353]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.353]                         if (muffled) 
[11:03:25.353]                           invokeRestart("muffleMessage")
[11:03:25.353]                       }
[11:03:25.353]                       else if (inherits(cond, "warning")) {
[11:03:25.353]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.353]                         if (muffled) 
[11:03:25.353]                           invokeRestart("muffleWarning")
[11:03:25.353]                       }
[11:03:25.353]                       else if (inherits(cond, "condition")) {
[11:03:25.353]                         if (!is.null(pattern)) {
[11:03:25.353]                           computeRestarts <- base::computeRestarts
[11:03:25.353]                           grepl <- base::grepl
[11:03:25.353]                           restarts <- computeRestarts(cond)
[11:03:25.353]                           for (restart in restarts) {
[11:03:25.353]                             name <- restart$name
[11:03:25.353]                             if (is.null(name)) 
[11:03:25.353]                               next
[11:03:25.353]                             if (!grepl(pattern, name)) 
[11:03:25.353]                               next
[11:03:25.353]                             invokeRestart(restart)
[11:03:25.353]                             muffled <- TRUE
[11:03:25.353]                             break
[11:03:25.353]                           }
[11:03:25.353]                         }
[11:03:25.353]                       }
[11:03:25.353]                       invisible(muffled)
[11:03:25.353]                     }
[11:03:25.353]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.353]                   }
[11:03:25.353]                 }
[11:03:25.353]                 else {
[11:03:25.353]                   if (TRUE) {
[11:03:25.353]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.353]                     {
[11:03:25.353]                       inherits <- base::inherits
[11:03:25.353]                       invokeRestart <- base::invokeRestart
[11:03:25.353]                       is.null <- base::is.null
[11:03:25.353]                       muffled <- FALSE
[11:03:25.353]                       if (inherits(cond, "message")) {
[11:03:25.353]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.353]                         if (muffled) 
[11:03:25.353]                           invokeRestart("muffleMessage")
[11:03:25.353]                       }
[11:03:25.353]                       else if (inherits(cond, "warning")) {
[11:03:25.353]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.353]                         if (muffled) 
[11:03:25.353]                           invokeRestart("muffleWarning")
[11:03:25.353]                       }
[11:03:25.353]                       else if (inherits(cond, "condition")) {
[11:03:25.353]                         if (!is.null(pattern)) {
[11:03:25.353]                           computeRestarts <- base::computeRestarts
[11:03:25.353]                           grepl <- base::grepl
[11:03:25.353]                           restarts <- computeRestarts(cond)
[11:03:25.353]                           for (restart in restarts) {
[11:03:25.353]                             name <- restart$name
[11:03:25.353]                             if (is.null(name)) 
[11:03:25.353]                               next
[11:03:25.353]                             if (!grepl(pattern, name)) 
[11:03:25.353]                               next
[11:03:25.353]                             invokeRestart(restart)
[11:03:25.353]                             muffled <- TRUE
[11:03:25.353]                             break
[11:03:25.353]                           }
[11:03:25.353]                         }
[11:03:25.353]                       }
[11:03:25.353]                       invisible(muffled)
[11:03:25.353]                     }
[11:03:25.353]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.353]                   }
[11:03:25.353]                 }
[11:03:25.353]             }
[11:03:25.353]         }))
[11:03:25.353]     }, error = function(ex) {
[11:03:25.353]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.353]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.353]                 ...future.rng), started = ...future.startTime, 
[11:03:25.353]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.353]             version = "1.8"), class = "FutureResult")
[11:03:25.353]     }, finally = {
[11:03:25.353]         if (!identical(...future.workdir, getwd())) 
[11:03:25.353]             setwd(...future.workdir)
[11:03:25.353]         {
[11:03:25.353]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.353]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.353]             }
[11:03:25.353]             base::options(...future.oldOptions)
[11:03:25.353]             if (.Platform$OS.type == "windows") {
[11:03:25.353]                 old_names <- names(...future.oldEnvVars)
[11:03:25.353]                 envs <- base::Sys.getenv()
[11:03:25.353]                 names <- names(envs)
[11:03:25.353]                 common <- intersect(names, old_names)
[11:03:25.353]                 added <- setdiff(names, old_names)
[11:03:25.353]                 removed <- setdiff(old_names, names)
[11:03:25.353]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.353]                   envs[common]]
[11:03:25.353]                 NAMES <- toupper(changed)
[11:03:25.353]                 args <- list()
[11:03:25.353]                 for (kk in seq_along(NAMES)) {
[11:03:25.353]                   name <- changed[[kk]]
[11:03:25.353]                   NAME <- NAMES[[kk]]
[11:03:25.353]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.353]                     next
[11:03:25.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.353]                 }
[11:03:25.353]                 NAMES <- toupper(added)
[11:03:25.353]                 for (kk in seq_along(NAMES)) {
[11:03:25.353]                   name <- added[[kk]]
[11:03:25.353]                   NAME <- NAMES[[kk]]
[11:03:25.353]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.353]                     next
[11:03:25.353]                   args[[name]] <- ""
[11:03:25.353]                 }
[11:03:25.353]                 NAMES <- toupper(removed)
[11:03:25.353]                 for (kk in seq_along(NAMES)) {
[11:03:25.353]                   name <- removed[[kk]]
[11:03:25.353]                   NAME <- NAMES[[kk]]
[11:03:25.353]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.353]                     next
[11:03:25.353]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.353]                 }
[11:03:25.353]                 if (length(args) > 0) 
[11:03:25.353]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.353]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.353]             }
[11:03:25.353]             else {
[11:03:25.353]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.353]             }
[11:03:25.353]             {
[11:03:25.353]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.353]                   0L) {
[11:03:25.353]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.353]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.353]                   base::options(opts)
[11:03:25.353]                 }
[11:03:25.353]                 {
[11:03:25.353]                   {
[11:03:25.353]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.353]                     NULL
[11:03:25.353]                   }
[11:03:25.353]                   options(future.plan = NULL)
[11:03:25.353]                   if (is.na(NA_character_)) 
[11:03:25.353]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.353]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.353]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.353]                     .init = FALSE)
[11:03:25.353]                 }
[11:03:25.353]             }
[11:03:25.353]         }
[11:03:25.353]     })
[11:03:25.353]     if (TRUE) {
[11:03:25.353]         base::sink(type = "output", split = FALSE)
[11:03:25.353]         if (TRUE) {
[11:03:25.353]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.353]         }
[11:03:25.353]         else {
[11:03:25.353]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.353]         }
[11:03:25.353]         base::close(...future.stdout)
[11:03:25.353]         ...future.stdout <- NULL
[11:03:25.353]     }
[11:03:25.353]     ...future.result$conditions <- ...future.conditions
[11:03:25.353]     ...future.result$finished <- base::Sys.time()
[11:03:25.353]     ...future.result
[11:03:25.353] }
[11:03:25.356] requestCore(): workers = 2
[11:03:25.357] MulticoreFuture started
[11:03:25.358] - Launch lazy future ... done
[11:03:25.358] run() for ‘MulticoreFuture’ ... done
[11:03:25.358] result() for MulticoreFuture ...
[11:03:25.358] plan(): Setting new future strategy stack:
[11:03:25.358] List of future strategies:
[11:03:25.358] 1. sequential:
[11:03:25.358]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:25.358]    - tweaked: FALSE
[11:03:25.358]    - call: NULL
[11:03:25.359] plan(): nbrOfWorkers() = 1
[11:03:25.361] plan(): Setting new future strategy stack:
[11:03:25.361] List of future strategies:
[11:03:25.361] 1. multicore:
[11:03:25.361]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:03:25.361]    - tweaked: FALSE
[11:03:25.361]    - call: plan(strategy)
[11:03:25.364] plan(): nbrOfWorkers() = 2
[11:03:25.365] result() for MulticoreFuture ...
[11:03:25.365] result() for MulticoreFuture ... done
[11:03:25.365] result() for MulticoreFuture ... done
[11:03:25.366] result() for MulticoreFuture ...
[11:03:25.366] result() for MulticoreFuture ... done
[11:03:25.366] result() for MulticoreFuture ...
[11:03:25.366] result() for MulticoreFuture ... done
[1] 42
[11:03:25.366] result() for MulticoreFuture ...
[11:03:25.366] result() for MulticoreFuture ... done
multicore ... done
multisession ...
[11:03:25.367] plan(): Setting new future strategy stack:
[11:03:25.367] List of future strategies:
[11:03:25.367] 1. multisession:
[11:03:25.367]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:03:25.367]    - tweaked: FALSE
[11:03:25.367]    - call: plan(strategy)
[11:03:25.367] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:03:25.367] multisession:
[11:03:25.367] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:03:25.367] - tweaked: FALSE
[11:03:25.367] - call: plan(strategy)
[11:03:25.372] getGlobalsAndPackages() ...
[11:03:25.372] Not searching for globals
[11:03:25.372] - globals: [0] <none>
[11:03:25.373] getGlobalsAndPackages() ... DONE
[11:03:25.845] Packages needed by the future expression (n = 0): <none>
[11:03:25.845] Packages needed by future strategies (n = 0): <none>
[11:03:25.846] {
[11:03:25.846]     {
[11:03:25.846]         {
[11:03:25.846]             ...future.startTime <- base::Sys.time()
[11:03:25.846]             {
[11:03:25.846]                 {
[11:03:25.846]                   {
[11:03:25.846]                     {
[11:03:25.846]                       base::local({
[11:03:25.846]                         has_future <- base::requireNamespace("future", 
[11:03:25.846]                           quietly = TRUE)
[11:03:25.846]                         if (has_future) {
[11:03:25.846]                           ns <- base::getNamespace("future")
[11:03:25.846]                           version <- ns[[".package"]][["version"]]
[11:03:25.846]                           if (is.null(version)) 
[11:03:25.846]                             version <- utils::packageVersion("future")
[11:03:25.846]                         }
[11:03:25.846]                         else {
[11:03:25.846]                           version <- NULL
[11:03:25.846]                         }
[11:03:25.846]                         if (!has_future || version < "1.8.0") {
[11:03:25.846]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.846]                             "", base::R.version$version.string), 
[11:03:25.846]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:25.846]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:25.846]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.846]                               "release", "version")], collapse = " "), 
[11:03:25.846]                             hostname = base::Sys.info()[["nodename"]])
[11:03:25.846]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.846]                             info)
[11:03:25.846]                           info <- base::paste(info, collapse = "; ")
[11:03:25.846]                           if (!has_future) {
[11:03:25.846]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.846]                               info)
[11:03:25.846]                           }
[11:03:25.846]                           else {
[11:03:25.846]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.846]                               info, version)
[11:03:25.846]                           }
[11:03:25.846]                           base::stop(msg)
[11:03:25.846]                         }
[11:03:25.846]                       })
[11:03:25.846]                     }
[11:03:25.846]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.846]                     base::options(mc.cores = 1L)
[11:03:25.846]                   }
[11:03:25.846]                   ...future.strategy.old <- future::plan("list")
[11:03:25.846]                   options(future.plan = NULL)
[11:03:25.846]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.846]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.846]                 }
[11:03:25.846]                 ...future.workdir <- getwd()
[11:03:25.846]             }
[11:03:25.846]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.846]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.846]         }
[11:03:25.846]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.846]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.846]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.846]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.846]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.846]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.846]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.846]             base::names(...future.oldOptions))
[11:03:25.846]     }
[11:03:25.846]     if (FALSE) {
[11:03:25.846]     }
[11:03:25.846]     else {
[11:03:25.846]         if (TRUE) {
[11:03:25.846]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.846]                 open = "w")
[11:03:25.846]         }
[11:03:25.846]         else {
[11:03:25.846]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.846]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.846]         }
[11:03:25.846]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.846]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.846]             base::sink(type = "output", split = FALSE)
[11:03:25.846]             base::close(...future.stdout)
[11:03:25.846]         }, add = TRUE)
[11:03:25.846]     }
[11:03:25.846]     ...future.frame <- base::sys.nframe()
[11:03:25.846]     ...future.conditions <- base::list()
[11:03:25.846]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.846]     if (FALSE) {
[11:03:25.846]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.846]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.846]     }
[11:03:25.846]     ...future.result <- base::tryCatch({
[11:03:25.846]         base::withCallingHandlers({
[11:03:25.846]             ...future.value <- base::withVisible(base::local({
[11:03:25.846]                 ...future.makeSendCondition <- base::local({
[11:03:25.846]                   sendCondition <- NULL
[11:03:25.846]                   function(frame = 1L) {
[11:03:25.846]                     if (is.function(sendCondition)) 
[11:03:25.846]                       return(sendCondition)
[11:03:25.846]                     ns <- getNamespace("parallel")
[11:03:25.846]                     if (exists("sendData", mode = "function", 
[11:03:25.846]                       envir = ns)) {
[11:03:25.846]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:25.846]                         envir = ns)
[11:03:25.846]                       envir <- sys.frame(frame)
[11:03:25.846]                       master <- NULL
[11:03:25.846]                       while (!identical(envir, .GlobalEnv) && 
[11:03:25.846]                         !identical(envir, emptyenv())) {
[11:03:25.846]                         if (exists("master", mode = "list", envir = envir, 
[11:03:25.846]                           inherits = FALSE)) {
[11:03:25.846]                           master <- get("master", mode = "list", 
[11:03:25.846]                             envir = envir, inherits = FALSE)
[11:03:25.846]                           if (inherits(master, c("SOCKnode", 
[11:03:25.846]                             "SOCK0node"))) {
[11:03:25.846]                             sendCondition <<- function(cond) {
[11:03:25.846]                               data <- list(type = "VALUE", value = cond, 
[11:03:25.846]                                 success = TRUE)
[11:03:25.846]                               parallel_sendData(master, data)
[11:03:25.846]                             }
[11:03:25.846]                             return(sendCondition)
[11:03:25.846]                           }
[11:03:25.846]                         }
[11:03:25.846]                         frame <- frame + 1L
[11:03:25.846]                         envir <- sys.frame(frame)
[11:03:25.846]                       }
[11:03:25.846]                     }
[11:03:25.846]                     sendCondition <<- function(cond) NULL
[11:03:25.846]                   }
[11:03:25.846]                 })
[11:03:25.846]                 withCallingHandlers({
[11:03:25.846]                   NA
[11:03:25.846]                 }, immediateCondition = function(cond) {
[11:03:25.846]                   sendCondition <- ...future.makeSendCondition()
[11:03:25.846]                   sendCondition(cond)
[11:03:25.846]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.846]                   {
[11:03:25.846]                     inherits <- base::inherits
[11:03:25.846]                     invokeRestart <- base::invokeRestart
[11:03:25.846]                     is.null <- base::is.null
[11:03:25.846]                     muffled <- FALSE
[11:03:25.846]                     if (inherits(cond, "message")) {
[11:03:25.846]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.846]                       if (muffled) 
[11:03:25.846]                         invokeRestart("muffleMessage")
[11:03:25.846]                     }
[11:03:25.846]                     else if (inherits(cond, "warning")) {
[11:03:25.846]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.846]                       if (muffled) 
[11:03:25.846]                         invokeRestart("muffleWarning")
[11:03:25.846]                     }
[11:03:25.846]                     else if (inherits(cond, "condition")) {
[11:03:25.846]                       if (!is.null(pattern)) {
[11:03:25.846]                         computeRestarts <- base::computeRestarts
[11:03:25.846]                         grepl <- base::grepl
[11:03:25.846]                         restarts <- computeRestarts(cond)
[11:03:25.846]                         for (restart in restarts) {
[11:03:25.846]                           name <- restart$name
[11:03:25.846]                           if (is.null(name)) 
[11:03:25.846]                             next
[11:03:25.846]                           if (!grepl(pattern, name)) 
[11:03:25.846]                             next
[11:03:25.846]                           invokeRestart(restart)
[11:03:25.846]                           muffled <- TRUE
[11:03:25.846]                           break
[11:03:25.846]                         }
[11:03:25.846]                       }
[11:03:25.846]                     }
[11:03:25.846]                     invisible(muffled)
[11:03:25.846]                   }
[11:03:25.846]                   muffleCondition(cond)
[11:03:25.846]                 })
[11:03:25.846]             }))
[11:03:25.846]             future::FutureResult(value = ...future.value$value, 
[11:03:25.846]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.846]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.846]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.846]                     ...future.globalenv.names))
[11:03:25.846]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.846]         }, condition = base::local({
[11:03:25.846]             c <- base::c
[11:03:25.846]             inherits <- base::inherits
[11:03:25.846]             invokeRestart <- base::invokeRestart
[11:03:25.846]             length <- base::length
[11:03:25.846]             list <- base::list
[11:03:25.846]             seq.int <- base::seq.int
[11:03:25.846]             signalCondition <- base::signalCondition
[11:03:25.846]             sys.calls <- base::sys.calls
[11:03:25.846]             `[[` <- base::`[[`
[11:03:25.846]             `+` <- base::`+`
[11:03:25.846]             `<<-` <- base::`<<-`
[11:03:25.846]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.846]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.846]                   3L)]
[11:03:25.846]             }
[11:03:25.846]             function(cond) {
[11:03:25.846]                 is_error <- inherits(cond, "error")
[11:03:25.846]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.846]                   NULL)
[11:03:25.846]                 if (is_error) {
[11:03:25.846]                   sessionInformation <- function() {
[11:03:25.846]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.846]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.846]                       search = base::search(), system = base::Sys.info())
[11:03:25.846]                   }
[11:03:25.846]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.846]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.846]                     cond$call), session = sessionInformation(), 
[11:03:25.846]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.846]                   signalCondition(cond)
[11:03:25.846]                 }
[11:03:25.846]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.846]                 "immediateCondition"))) {
[11:03:25.846]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.846]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.846]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.846]                   if (TRUE && !signal) {
[11:03:25.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.846]                     {
[11:03:25.846]                       inherits <- base::inherits
[11:03:25.846]                       invokeRestart <- base::invokeRestart
[11:03:25.846]                       is.null <- base::is.null
[11:03:25.846]                       muffled <- FALSE
[11:03:25.846]                       if (inherits(cond, "message")) {
[11:03:25.846]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.846]                         if (muffled) 
[11:03:25.846]                           invokeRestart("muffleMessage")
[11:03:25.846]                       }
[11:03:25.846]                       else if (inherits(cond, "warning")) {
[11:03:25.846]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.846]                         if (muffled) 
[11:03:25.846]                           invokeRestart("muffleWarning")
[11:03:25.846]                       }
[11:03:25.846]                       else if (inherits(cond, "condition")) {
[11:03:25.846]                         if (!is.null(pattern)) {
[11:03:25.846]                           computeRestarts <- base::computeRestarts
[11:03:25.846]                           grepl <- base::grepl
[11:03:25.846]                           restarts <- computeRestarts(cond)
[11:03:25.846]                           for (restart in restarts) {
[11:03:25.846]                             name <- restart$name
[11:03:25.846]                             if (is.null(name)) 
[11:03:25.846]                               next
[11:03:25.846]                             if (!grepl(pattern, name)) 
[11:03:25.846]                               next
[11:03:25.846]                             invokeRestart(restart)
[11:03:25.846]                             muffled <- TRUE
[11:03:25.846]                             break
[11:03:25.846]                           }
[11:03:25.846]                         }
[11:03:25.846]                       }
[11:03:25.846]                       invisible(muffled)
[11:03:25.846]                     }
[11:03:25.846]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.846]                   }
[11:03:25.846]                 }
[11:03:25.846]                 else {
[11:03:25.846]                   if (TRUE) {
[11:03:25.846]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.846]                     {
[11:03:25.846]                       inherits <- base::inherits
[11:03:25.846]                       invokeRestart <- base::invokeRestart
[11:03:25.846]                       is.null <- base::is.null
[11:03:25.846]                       muffled <- FALSE
[11:03:25.846]                       if (inherits(cond, "message")) {
[11:03:25.846]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.846]                         if (muffled) 
[11:03:25.846]                           invokeRestart("muffleMessage")
[11:03:25.846]                       }
[11:03:25.846]                       else if (inherits(cond, "warning")) {
[11:03:25.846]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.846]                         if (muffled) 
[11:03:25.846]                           invokeRestart("muffleWarning")
[11:03:25.846]                       }
[11:03:25.846]                       else if (inherits(cond, "condition")) {
[11:03:25.846]                         if (!is.null(pattern)) {
[11:03:25.846]                           computeRestarts <- base::computeRestarts
[11:03:25.846]                           grepl <- base::grepl
[11:03:25.846]                           restarts <- computeRestarts(cond)
[11:03:25.846]                           for (restart in restarts) {
[11:03:25.846]                             name <- restart$name
[11:03:25.846]                             if (is.null(name)) 
[11:03:25.846]                               next
[11:03:25.846]                             if (!grepl(pattern, name)) 
[11:03:25.846]                               next
[11:03:25.846]                             invokeRestart(restart)
[11:03:25.846]                             muffled <- TRUE
[11:03:25.846]                             break
[11:03:25.846]                           }
[11:03:25.846]                         }
[11:03:25.846]                       }
[11:03:25.846]                       invisible(muffled)
[11:03:25.846]                     }
[11:03:25.846]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.846]                   }
[11:03:25.846]                 }
[11:03:25.846]             }
[11:03:25.846]         }))
[11:03:25.846]     }, error = function(ex) {
[11:03:25.846]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.846]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.846]                 ...future.rng), started = ...future.startTime, 
[11:03:25.846]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.846]             version = "1.8"), class = "FutureResult")
[11:03:25.846]     }, finally = {
[11:03:25.846]         if (!identical(...future.workdir, getwd())) 
[11:03:25.846]             setwd(...future.workdir)
[11:03:25.846]         {
[11:03:25.846]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.846]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.846]             }
[11:03:25.846]             base::options(...future.oldOptions)
[11:03:25.846]             if (.Platform$OS.type == "windows") {
[11:03:25.846]                 old_names <- names(...future.oldEnvVars)
[11:03:25.846]                 envs <- base::Sys.getenv()
[11:03:25.846]                 names <- names(envs)
[11:03:25.846]                 common <- intersect(names, old_names)
[11:03:25.846]                 added <- setdiff(names, old_names)
[11:03:25.846]                 removed <- setdiff(old_names, names)
[11:03:25.846]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.846]                   envs[common]]
[11:03:25.846]                 NAMES <- toupper(changed)
[11:03:25.846]                 args <- list()
[11:03:25.846]                 for (kk in seq_along(NAMES)) {
[11:03:25.846]                   name <- changed[[kk]]
[11:03:25.846]                   NAME <- NAMES[[kk]]
[11:03:25.846]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.846]                     next
[11:03:25.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.846]                 }
[11:03:25.846]                 NAMES <- toupper(added)
[11:03:25.846]                 for (kk in seq_along(NAMES)) {
[11:03:25.846]                   name <- added[[kk]]
[11:03:25.846]                   NAME <- NAMES[[kk]]
[11:03:25.846]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.846]                     next
[11:03:25.846]                   args[[name]] <- ""
[11:03:25.846]                 }
[11:03:25.846]                 NAMES <- toupper(removed)
[11:03:25.846]                 for (kk in seq_along(NAMES)) {
[11:03:25.846]                   name <- removed[[kk]]
[11:03:25.846]                   NAME <- NAMES[[kk]]
[11:03:25.846]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.846]                     next
[11:03:25.846]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.846]                 }
[11:03:25.846]                 if (length(args) > 0) 
[11:03:25.846]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.846]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.846]             }
[11:03:25.846]             else {
[11:03:25.846]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.846]             }
[11:03:25.846]             {
[11:03:25.846]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.846]                   0L) {
[11:03:25.846]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.846]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.846]                   base::options(opts)
[11:03:25.846]                 }
[11:03:25.846]                 {
[11:03:25.846]                   {
[11:03:25.846]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.846]                     NULL
[11:03:25.846]                   }
[11:03:25.846]                   options(future.plan = NULL)
[11:03:25.846]                   if (is.na(NA_character_)) 
[11:03:25.846]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.846]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.846]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.846]                     .init = FALSE)
[11:03:25.846]                 }
[11:03:25.846]             }
[11:03:25.846]         }
[11:03:25.846]     })
[11:03:25.846]     if (TRUE) {
[11:03:25.846]         base::sink(type = "output", split = FALSE)
[11:03:25.846]         if (TRUE) {
[11:03:25.846]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.846]         }
[11:03:25.846]         else {
[11:03:25.846]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.846]         }
[11:03:25.846]         base::close(...future.stdout)
[11:03:25.846]         ...future.stdout <- NULL
[11:03:25.846]     }
[11:03:25.846]     ...future.result$conditions <- ...future.conditions
[11:03:25.846]     ...future.result$finished <- base::Sys.time()
[11:03:25.846]     ...future.result
[11:03:25.846] }
[11:03:25.896] MultisessionFuture started
[11:03:25.897] result() for ClusterFuture ...
[11:03:25.897] receiveMessageFromWorker() for ClusterFuture ...
[11:03:25.898] - Validating connection of MultisessionFuture
[11:03:25.927] - received message: FutureResult
[11:03:25.927] - Received FutureResult
[11:03:25.928] - Erased future from FutureRegistry
[11:03:25.928] result() for ClusterFuture ...
[11:03:25.928] - result already collected: FutureResult
[11:03:25.928] result() for ClusterFuture ... done
[11:03:25.928] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:25.928] result() for ClusterFuture ... done
[11:03:25.928] result() for ClusterFuture ...
[11:03:25.928] - result already collected: FutureResult
[11:03:25.928] result() for ClusterFuture ... done
[11:03:25.928] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:03:25.930] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[11:03:25.930] getGlobalsAndPackages() ...
[11:03:25.930] Searching for globals...
[11:03:25.933] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:25.933] Searching for globals ... DONE
[11:03:25.933] Resolving globals: FALSE
[11:03:25.934] 
[11:03:25.934] - packages: [1] ‘utils’
[11:03:25.934] getGlobalsAndPackages() ... DONE
[11:03:25.934] run() for ‘Future’ ...
[11:03:25.934] - state: ‘created’
[11:03:25.934] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:03:25.948] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:25.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:03:25.949]   - Field: ‘node’
[11:03:25.949]   - Field: ‘label’
[11:03:25.949]   - Field: ‘local’
[11:03:25.949]   - Field: ‘owner’
[11:03:25.949]   - Field: ‘envir’
[11:03:25.949]   - Field: ‘workers’
[11:03:25.949]   - Field: ‘packages’
[11:03:25.949]   - Field: ‘gc’
[11:03:25.949]   - Field: ‘conditions’
[11:03:25.949]   - Field: ‘persistent’
[11:03:25.949]   - Field: ‘expr’
[11:03:25.949]   - Field: ‘uuid’
[11:03:25.950]   - Field: ‘seed’
[11:03:25.950]   - Field: ‘version’
[11:03:25.950]   - Field: ‘result’
[11:03:25.950]   - Field: ‘asynchronous’
[11:03:25.950]   - Field: ‘calls’
[11:03:25.950]   - Field: ‘globals’
[11:03:25.950]   - Field: ‘stdout’
[11:03:25.950]   - Field: ‘earlySignal’
[11:03:25.950]   - Field: ‘lazy’
[11:03:25.950]   - Field: ‘state’
[11:03:25.950] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:03:25.950] - Launch lazy future ...
[11:03:25.951] Packages needed by the future expression (n = 1): ‘utils’
[11:03:25.951] Packages needed by future strategies (n = 0): <none>
[11:03:25.951] {
[11:03:25.951]     {
[11:03:25.951]         {
[11:03:25.951]             ...future.startTime <- base::Sys.time()
[11:03:25.951]             {
[11:03:25.951]                 {
[11:03:25.951]                   {
[11:03:25.951]                     {
[11:03:25.951]                       {
[11:03:25.951]                         base::local({
[11:03:25.951]                           has_future <- base::requireNamespace("future", 
[11:03:25.951]                             quietly = TRUE)
[11:03:25.951]                           if (has_future) {
[11:03:25.951]                             ns <- base::getNamespace("future")
[11:03:25.951]                             version <- ns[[".package"]][["version"]]
[11:03:25.951]                             if (is.null(version)) 
[11:03:25.951]                               version <- utils::packageVersion("future")
[11:03:25.951]                           }
[11:03:25.951]                           else {
[11:03:25.951]                             version <- NULL
[11:03:25.951]                           }
[11:03:25.951]                           if (!has_future || version < "1.8.0") {
[11:03:25.951]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:25.951]                               "", base::R.version$version.string), 
[11:03:25.951]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:25.951]                                 base::R.version$platform, 8 * 
[11:03:25.951]                                   base::.Machine$sizeof.pointer), 
[11:03:25.951]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:25.951]                                 "release", "version")], collapse = " "), 
[11:03:25.951]                               hostname = base::Sys.info()[["nodename"]])
[11:03:25.951]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:25.951]                               info)
[11:03:25.951]                             info <- base::paste(info, collapse = "; ")
[11:03:25.951]                             if (!has_future) {
[11:03:25.951]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:25.951]                                 info)
[11:03:25.951]                             }
[11:03:25.951]                             else {
[11:03:25.951]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:25.951]                                 info, version)
[11:03:25.951]                             }
[11:03:25.951]                             base::stop(msg)
[11:03:25.951]                           }
[11:03:25.951]                         })
[11:03:25.951]                       }
[11:03:25.951]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:25.951]                       base::options(mc.cores = 1L)
[11:03:25.951]                     }
[11:03:25.951]                     base::local({
[11:03:25.951]                       for (pkg in "utils") {
[11:03:25.951]                         base::loadNamespace(pkg)
[11:03:25.951]                         base::library(pkg, character.only = TRUE)
[11:03:25.951]                       }
[11:03:25.951]                     })
[11:03:25.951]                   }
[11:03:25.951]                   ...future.strategy.old <- future::plan("list")
[11:03:25.951]                   options(future.plan = NULL)
[11:03:25.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:25.951]                 }
[11:03:25.951]                 ...future.workdir <- getwd()
[11:03:25.951]             }
[11:03:25.951]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:25.951]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:25.951]         }
[11:03:25.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:25.951]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:25.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:25.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:25.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:25.951]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:25.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:25.951]             base::names(...future.oldOptions))
[11:03:25.951]     }
[11:03:25.951]     if (FALSE) {
[11:03:25.951]     }
[11:03:25.951]     else {
[11:03:25.951]         if (TRUE) {
[11:03:25.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:25.951]                 open = "w")
[11:03:25.951]         }
[11:03:25.951]         else {
[11:03:25.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:25.951]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:25.951]         }
[11:03:25.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:25.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:25.951]             base::sink(type = "output", split = FALSE)
[11:03:25.951]             base::close(...future.stdout)
[11:03:25.951]         }, add = TRUE)
[11:03:25.951]     }
[11:03:25.951]     ...future.frame <- base::sys.nframe()
[11:03:25.951]     ...future.conditions <- base::list()
[11:03:25.951]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:25.951]     if (FALSE) {
[11:03:25.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:25.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:25.951]     }
[11:03:25.951]     ...future.result <- base::tryCatch({
[11:03:25.951]         base::withCallingHandlers({
[11:03:25.951]             ...future.value <- base::withVisible(base::local({
[11:03:25.951]                 ...future.makeSendCondition <- base::local({
[11:03:25.951]                   sendCondition <- NULL
[11:03:25.951]                   function(frame = 1L) {
[11:03:25.951]                     if (is.function(sendCondition)) 
[11:03:25.951]                       return(sendCondition)
[11:03:25.951]                     ns <- getNamespace("parallel")
[11:03:25.951]                     if (exists("sendData", mode = "function", 
[11:03:25.951]                       envir = ns)) {
[11:03:25.951]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:25.951]                         envir = ns)
[11:03:25.951]                       envir <- sys.frame(frame)
[11:03:25.951]                       master <- NULL
[11:03:25.951]                       while (!identical(envir, .GlobalEnv) && 
[11:03:25.951]                         !identical(envir, emptyenv())) {
[11:03:25.951]                         if (exists("master", mode = "list", envir = envir, 
[11:03:25.951]                           inherits = FALSE)) {
[11:03:25.951]                           master <- get("master", mode = "list", 
[11:03:25.951]                             envir = envir, inherits = FALSE)
[11:03:25.951]                           if (inherits(master, c("SOCKnode", 
[11:03:25.951]                             "SOCK0node"))) {
[11:03:25.951]                             sendCondition <<- function(cond) {
[11:03:25.951]                               data <- list(type = "VALUE", value = cond, 
[11:03:25.951]                                 success = TRUE)
[11:03:25.951]                               parallel_sendData(master, data)
[11:03:25.951]                             }
[11:03:25.951]                             return(sendCondition)
[11:03:25.951]                           }
[11:03:25.951]                         }
[11:03:25.951]                         frame <- frame + 1L
[11:03:25.951]                         envir <- sys.frame(frame)
[11:03:25.951]                       }
[11:03:25.951]                     }
[11:03:25.951]                     sendCondition <<- function(cond) NULL
[11:03:25.951]                   }
[11:03:25.951]                 })
[11:03:25.951]                 withCallingHandlers({
[11:03:25.951]                   {
[11:03:25.951]                     print(1:50)
[11:03:25.951]                     str(1:50)
[11:03:25.951]                     cat(letters, sep = "-")
[11:03:25.951]                     cat(1:6, collapse = "\n")
[11:03:25.951]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:25.951]                     42L
[11:03:25.951]                   }
[11:03:25.951]                 }, immediateCondition = function(cond) {
[11:03:25.951]                   sendCondition <- ...future.makeSendCondition()
[11:03:25.951]                   sendCondition(cond)
[11:03:25.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.951]                   {
[11:03:25.951]                     inherits <- base::inherits
[11:03:25.951]                     invokeRestart <- base::invokeRestart
[11:03:25.951]                     is.null <- base::is.null
[11:03:25.951]                     muffled <- FALSE
[11:03:25.951]                     if (inherits(cond, "message")) {
[11:03:25.951]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:25.951]                       if (muffled) 
[11:03:25.951]                         invokeRestart("muffleMessage")
[11:03:25.951]                     }
[11:03:25.951]                     else if (inherits(cond, "warning")) {
[11:03:25.951]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:25.951]                       if (muffled) 
[11:03:25.951]                         invokeRestart("muffleWarning")
[11:03:25.951]                     }
[11:03:25.951]                     else if (inherits(cond, "condition")) {
[11:03:25.951]                       if (!is.null(pattern)) {
[11:03:25.951]                         computeRestarts <- base::computeRestarts
[11:03:25.951]                         grepl <- base::grepl
[11:03:25.951]                         restarts <- computeRestarts(cond)
[11:03:25.951]                         for (restart in restarts) {
[11:03:25.951]                           name <- restart$name
[11:03:25.951]                           if (is.null(name)) 
[11:03:25.951]                             next
[11:03:25.951]                           if (!grepl(pattern, name)) 
[11:03:25.951]                             next
[11:03:25.951]                           invokeRestart(restart)
[11:03:25.951]                           muffled <- TRUE
[11:03:25.951]                           break
[11:03:25.951]                         }
[11:03:25.951]                       }
[11:03:25.951]                     }
[11:03:25.951]                     invisible(muffled)
[11:03:25.951]                   }
[11:03:25.951]                   muffleCondition(cond)
[11:03:25.951]                 })
[11:03:25.951]             }))
[11:03:25.951]             future::FutureResult(value = ...future.value$value, 
[11:03:25.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.951]                   ...future.rng), globalenv = if (FALSE) 
[11:03:25.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:25.951]                     ...future.globalenv.names))
[11:03:25.951]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:25.951]         }, condition = base::local({
[11:03:25.951]             c <- base::c
[11:03:25.951]             inherits <- base::inherits
[11:03:25.951]             invokeRestart <- base::invokeRestart
[11:03:25.951]             length <- base::length
[11:03:25.951]             list <- base::list
[11:03:25.951]             seq.int <- base::seq.int
[11:03:25.951]             signalCondition <- base::signalCondition
[11:03:25.951]             sys.calls <- base::sys.calls
[11:03:25.951]             `[[` <- base::`[[`
[11:03:25.951]             `+` <- base::`+`
[11:03:25.951]             `<<-` <- base::`<<-`
[11:03:25.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:25.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:25.951]                   3L)]
[11:03:25.951]             }
[11:03:25.951]             function(cond) {
[11:03:25.951]                 is_error <- inherits(cond, "error")
[11:03:25.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:25.951]                   NULL)
[11:03:25.951]                 if (is_error) {
[11:03:25.951]                   sessionInformation <- function() {
[11:03:25.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:25.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:25.951]                       search = base::search(), system = base::Sys.info())
[11:03:25.951]                   }
[11:03:25.951]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:25.951]                     cond$call), session = sessionInformation(), 
[11:03:25.951]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:25.951]                   signalCondition(cond)
[11:03:25.951]                 }
[11:03:25.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:25.951]                 "immediateCondition"))) {
[11:03:25.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:25.951]                   ...future.conditions[[length(...future.conditions) + 
[11:03:25.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:25.951]                   if (TRUE && !signal) {
[11:03:25.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.951]                     {
[11:03:25.951]                       inherits <- base::inherits
[11:03:25.951]                       invokeRestart <- base::invokeRestart
[11:03:25.951]                       is.null <- base::is.null
[11:03:25.951]                       muffled <- FALSE
[11:03:25.951]                       if (inherits(cond, "message")) {
[11:03:25.951]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.951]                         if (muffled) 
[11:03:25.951]                           invokeRestart("muffleMessage")
[11:03:25.951]                       }
[11:03:25.951]                       else if (inherits(cond, "warning")) {
[11:03:25.951]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.951]                         if (muffled) 
[11:03:25.951]                           invokeRestart("muffleWarning")
[11:03:25.951]                       }
[11:03:25.951]                       else if (inherits(cond, "condition")) {
[11:03:25.951]                         if (!is.null(pattern)) {
[11:03:25.951]                           computeRestarts <- base::computeRestarts
[11:03:25.951]                           grepl <- base::grepl
[11:03:25.951]                           restarts <- computeRestarts(cond)
[11:03:25.951]                           for (restart in restarts) {
[11:03:25.951]                             name <- restart$name
[11:03:25.951]                             if (is.null(name)) 
[11:03:25.951]                               next
[11:03:25.951]                             if (!grepl(pattern, name)) 
[11:03:25.951]                               next
[11:03:25.951]                             invokeRestart(restart)
[11:03:25.951]                             muffled <- TRUE
[11:03:25.951]                             break
[11:03:25.951]                           }
[11:03:25.951]                         }
[11:03:25.951]                       }
[11:03:25.951]                       invisible(muffled)
[11:03:25.951]                     }
[11:03:25.951]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.951]                   }
[11:03:25.951]                 }
[11:03:25.951]                 else {
[11:03:25.951]                   if (TRUE) {
[11:03:25.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:25.951]                     {
[11:03:25.951]                       inherits <- base::inherits
[11:03:25.951]                       invokeRestart <- base::invokeRestart
[11:03:25.951]                       is.null <- base::is.null
[11:03:25.951]                       muffled <- FALSE
[11:03:25.951]                       if (inherits(cond, "message")) {
[11:03:25.951]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:25.951]                         if (muffled) 
[11:03:25.951]                           invokeRestart("muffleMessage")
[11:03:25.951]                       }
[11:03:25.951]                       else if (inherits(cond, "warning")) {
[11:03:25.951]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:25.951]                         if (muffled) 
[11:03:25.951]                           invokeRestart("muffleWarning")
[11:03:25.951]                       }
[11:03:25.951]                       else if (inherits(cond, "condition")) {
[11:03:25.951]                         if (!is.null(pattern)) {
[11:03:25.951]                           computeRestarts <- base::computeRestarts
[11:03:25.951]                           grepl <- base::grepl
[11:03:25.951]                           restarts <- computeRestarts(cond)
[11:03:25.951]                           for (restart in restarts) {
[11:03:25.951]                             name <- restart$name
[11:03:25.951]                             if (is.null(name)) 
[11:03:25.951]                               next
[11:03:25.951]                             if (!grepl(pattern, name)) 
[11:03:25.951]                               next
[11:03:25.951]                             invokeRestart(restart)
[11:03:25.951]                             muffled <- TRUE
[11:03:25.951]                             break
[11:03:25.951]                           }
[11:03:25.951]                         }
[11:03:25.951]                       }
[11:03:25.951]                       invisible(muffled)
[11:03:25.951]                     }
[11:03:25.951]                     muffleCondition(cond, pattern = "^muffle")
[11:03:25.951]                   }
[11:03:25.951]                 }
[11:03:25.951]             }
[11:03:25.951]         }))
[11:03:25.951]     }, error = function(ex) {
[11:03:25.951]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:25.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:25.951]                 ...future.rng), started = ...future.startTime, 
[11:03:25.951]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:25.951]             version = "1.8"), class = "FutureResult")
[11:03:25.951]     }, finally = {
[11:03:25.951]         if (!identical(...future.workdir, getwd())) 
[11:03:25.951]             setwd(...future.workdir)
[11:03:25.951]         {
[11:03:25.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:25.951]                 ...future.oldOptions$nwarnings <- NULL
[11:03:25.951]             }
[11:03:25.951]             base::options(...future.oldOptions)
[11:03:25.951]             if (.Platform$OS.type == "windows") {
[11:03:25.951]                 old_names <- names(...future.oldEnvVars)
[11:03:25.951]                 envs <- base::Sys.getenv()
[11:03:25.951]                 names <- names(envs)
[11:03:25.951]                 common <- intersect(names, old_names)
[11:03:25.951]                 added <- setdiff(names, old_names)
[11:03:25.951]                 removed <- setdiff(old_names, names)
[11:03:25.951]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:25.951]                   envs[common]]
[11:03:25.951]                 NAMES <- toupper(changed)
[11:03:25.951]                 args <- list()
[11:03:25.951]                 for (kk in seq_along(NAMES)) {
[11:03:25.951]                   name <- changed[[kk]]
[11:03:25.951]                   NAME <- NAMES[[kk]]
[11:03:25.951]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.951]                     next
[11:03:25.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.951]                 }
[11:03:25.951]                 NAMES <- toupper(added)
[11:03:25.951]                 for (kk in seq_along(NAMES)) {
[11:03:25.951]                   name <- added[[kk]]
[11:03:25.951]                   NAME <- NAMES[[kk]]
[11:03:25.951]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.951]                     next
[11:03:25.951]                   args[[name]] <- ""
[11:03:25.951]                 }
[11:03:25.951]                 NAMES <- toupper(removed)
[11:03:25.951]                 for (kk in seq_along(NAMES)) {
[11:03:25.951]                   name <- removed[[kk]]
[11:03:25.951]                   NAME <- NAMES[[kk]]
[11:03:25.951]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:25.951]                     next
[11:03:25.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:25.951]                 }
[11:03:25.951]                 if (length(args) > 0) 
[11:03:25.951]                   base::do.call(base::Sys.setenv, args = args)
[11:03:25.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:25.951]             }
[11:03:25.951]             else {
[11:03:25.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:25.951]             }
[11:03:25.951]             {
[11:03:25.951]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:25.951]                   0L) {
[11:03:25.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:25.951]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:25.951]                   base::options(opts)
[11:03:25.951]                 }
[11:03:25.951]                 {
[11:03:25.951]                   {
[11:03:25.951]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:25.951]                     NULL
[11:03:25.951]                   }
[11:03:25.951]                   options(future.plan = NULL)
[11:03:25.951]                   if (is.na(NA_character_)) 
[11:03:25.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:25.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:25.951]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:25.951]                     .init = FALSE)
[11:03:25.951]                 }
[11:03:25.951]             }
[11:03:25.951]         }
[11:03:25.951]     })
[11:03:25.951]     if (TRUE) {
[11:03:25.951]         base::sink(type = "output", split = FALSE)
[11:03:25.951]         if (TRUE) {
[11:03:25.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:25.951]         }
[11:03:25.951]         else {
[11:03:25.951]             ...future.result["stdout"] <- base::list(NULL)
[11:03:25.951]         }
[11:03:25.951]         base::close(...future.stdout)
[11:03:25.951]         ...future.stdout <- NULL
[11:03:25.951]     }
[11:03:25.951]     ...future.result$conditions <- ...future.conditions
[11:03:25.951]     ...future.result$finished <- base::Sys.time()
[11:03:25.951]     ...future.result
[11:03:25.951] }
[11:03:25.955] MultisessionFuture started
[11:03:25.955] - Launch lazy future ... done
[11:03:25.955] run() for ‘MultisessionFuture’ ... done
[11:03:25.955] result() for ClusterFuture ...
[11:03:25.955] receiveMessageFromWorker() for ClusterFuture ...
[11:03:25.955] - Validating connection of MultisessionFuture
[11:03:26.002] - received message: FutureResult
[11:03:26.002] - Received FutureResult
[11:03:26.002] - Erased future from FutureRegistry
[11:03:26.003] result() for ClusterFuture ...
[11:03:26.003] - result already collected: FutureResult
[11:03:26.003] result() for ClusterFuture ... done
[11:03:26.003] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:26.003] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-05-06 11:03:25"
 $ finished    : POSIXct[1:1], format: "2025-05-06 11:03:26"
 $ session_uuid: chr "4a4d31bd-51d3-cce6-5621-e37e8478d31d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "173ee284ba16"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 85052
  .. ..$ time  : POSIXct[1:1], format: "2025-05-06 11:03:25"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[11:03:26.011] result() for ClusterFuture ...
[11:03:26.011] - result already collected: FutureResult
[11:03:26.011] result() for ClusterFuture ... done
[11:03:26.011] result() for ClusterFuture ...
[11:03:26.012] - result already collected: FutureResult
[11:03:26.012] result() for ClusterFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.007212162 secs (started 2025-05-06 11:03:25.995269)
version: 1.8
[11:03:26.012] getGlobalsAndPackages() ...
[11:03:26.013] Searching for globals...
[11:03:26.016] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:26.016] Searching for globals ... DONE
[11:03:26.016] Resolving globals: FALSE
[11:03:26.017] 
[11:03:26.017] - packages: [1] ‘utils’
[11:03:26.017] getGlobalsAndPackages() ... DONE
[11:03:26.018] run() for ‘Future’ ...
[11:03:26.018] - state: ‘created’
[11:03:26.018] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:03:26.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:26.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:03:26.033]   - Field: ‘node’
[11:03:26.033]   - Field: ‘label’
[11:03:26.033]   - Field: ‘local’
[11:03:26.033]   - Field: ‘owner’
[11:03:26.033]   - Field: ‘envir’
[11:03:26.033]   - Field: ‘workers’
[11:03:26.033]   - Field: ‘packages’
[11:03:26.033]   - Field: ‘gc’
[11:03:26.033]   - Field: ‘conditions’
[11:03:26.033]   - Field: ‘persistent’
[11:03:26.033]   - Field: ‘expr’
[11:03:26.034]   - Field: ‘uuid’
[11:03:26.034]   - Field: ‘seed’
[11:03:26.034]   - Field: ‘version’
[11:03:26.034]   - Field: ‘result’
[11:03:26.034]   - Field: ‘asynchronous’
[11:03:26.034]   - Field: ‘calls’
[11:03:26.034]   - Field: ‘globals’
[11:03:26.034]   - Field: ‘stdout’
[11:03:26.034]   - Field: ‘earlySignal’
[11:03:26.035]   - Field: ‘lazy’
[11:03:26.035]   - Field: ‘state’
[11:03:26.035] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:03:26.035] - Launch lazy future ...
[11:03:26.035] Packages needed by the future expression (n = 1): ‘utils’
[11:03:26.035] Packages needed by future strategies (n = 0): <none>
[11:03:26.036] {
[11:03:26.036]     {
[11:03:26.036]         {
[11:03:26.036]             ...future.startTime <- base::Sys.time()
[11:03:26.036]             {
[11:03:26.036]                 {
[11:03:26.036]                   {
[11:03:26.036]                     {
[11:03:26.036]                       {
[11:03:26.036]                         base::local({
[11:03:26.036]                           has_future <- base::requireNamespace("future", 
[11:03:26.036]                             quietly = TRUE)
[11:03:26.036]                           if (has_future) {
[11:03:26.036]                             ns <- base::getNamespace("future")
[11:03:26.036]                             version <- ns[[".package"]][["version"]]
[11:03:26.036]                             if (is.null(version)) 
[11:03:26.036]                               version <- utils::packageVersion("future")
[11:03:26.036]                           }
[11:03:26.036]                           else {
[11:03:26.036]                             version <- NULL
[11:03:26.036]                           }
[11:03:26.036]                           if (!has_future || version < "1.8.0") {
[11:03:26.036]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:26.036]                               "", base::R.version$version.string), 
[11:03:26.036]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:26.036]                                 base::R.version$platform, 8 * 
[11:03:26.036]                                   base::.Machine$sizeof.pointer), 
[11:03:26.036]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:26.036]                                 "release", "version")], collapse = " "), 
[11:03:26.036]                               hostname = base::Sys.info()[["nodename"]])
[11:03:26.036]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:26.036]                               info)
[11:03:26.036]                             info <- base::paste(info, collapse = "; ")
[11:03:26.036]                             if (!has_future) {
[11:03:26.036]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:26.036]                                 info)
[11:03:26.036]                             }
[11:03:26.036]                             else {
[11:03:26.036]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:26.036]                                 info, version)
[11:03:26.036]                             }
[11:03:26.036]                             base::stop(msg)
[11:03:26.036]                           }
[11:03:26.036]                         })
[11:03:26.036]                       }
[11:03:26.036]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:26.036]                       base::options(mc.cores = 1L)
[11:03:26.036]                     }
[11:03:26.036]                     base::local({
[11:03:26.036]                       for (pkg in "utils") {
[11:03:26.036]                         base::loadNamespace(pkg)
[11:03:26.036]                         base::library(pkg, character.only = TRUE)
[11:03:26.036]                       }
[11:03:26.036]                     })
[11:03:26.036]                   }
[11:03:26.036]                   ...future.strategy.old <- future::plan("list")
[11:03:26.036]                   options(future.plan = NULL)
[11:03:26.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:26.036]                 }
[11:03:26.036]                 ...future.workdir <- getwd()
[11:03:26.036]             }
[11:03:26.036]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:26.036]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:26.036]         }
[11:03:26.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:26.036]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:26.036]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:26.036]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:26.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:26.036]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:26.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:26.036]             base::names(...future.oldOptions))
[11:03:26.036]     }
[11:03:26.036]     if (FALSE) {
[11:03:26.036]     }
[11:03:26.036]     else {
[11:03:26.036]         if (TRUE) {
[11:03:26.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:26.036]                 open = "w")
[11:03:26.036]         }
[11:03:26.036]         else {
[11:03:26.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:26.036]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:26.036]         }
[11:03:26.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:26.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:26.036]             base::sink(type = "output", split = FALSE)
[11:03:26.036]             base::close(...future.stdout)
[11:03:26.036]         }, add = TRUE)
[11:03:26.036]     }
[11:03:26.036]     ...future.frame <- base::sys.nframe()
[11:03:26.036]     ...future.conditions <- base::list()
[11:03:26.036]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:26.036]     if (FALSE) {
[11:03:26.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:26.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:26.036]     }
[11:03:26.036]     ...future.result <- base::tryCatch({
[11:03:26.036]         base::withCallingHandlers({
[11:03:26.036]             ...future.value <- base::withVisible(base::local({
[11:03:26.036]                 ...future.makeSendCondition <- base::local({
[11:03:26.036]                   sendCondition <- NULL
[11:03:26.036]                   function(frame = 1L) {
[11:03:26.036]                     if (is.function(sendCondition)) 
[11:03:26.036]                       return(sendCondition)
[11:03:26.036]                     ns <- getNamespace("parallel")
[11:03:26.036]                     if (exists("sendData", mode = "function", 
[11:03:26.036]                       envir = ns)) {
[11:03:26.036]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:26.036]                         envir = ns)
[11:03:26.036]                       envir <- sys.frame(frame)
[11:03:26.036]                       master <- NULL
[11:03:26.036]                       while (!identical(envir, .GlobalEnv) && 
[11:03:26.036]                         !identical(envir, emptyenv())) {
[11:03:26.036]                         if (exists("master", mode = "list", envir = envir, 
[11:03:26.036]                           inherits = FALSE)) {
[11:03:26.036]                           master <- get("master", mode = "list", 
[11:03:26.036]                             envir = envir, inherits = FALSE)
[11:03:26.036]                           if (inherits(master, c("SOCKnode", 
[11:03:26.036]                             "SOCK0node"))) {
[11:03:26.036]                             sendCondition <<- function(cond) {
[11:03:26.036]                               data <- list(type = "VALUE", value = cond, 
[11:03:26.036]                                 success = TRUE)
[11:03:26.036]                               parallel_sendData(master, data)
[11:03:26.036]                             }
[11:03:26.036]                             return(sendCondition)
[11:03:26.036]                           }
[11:03:26.036]                         }
[11:03:26.036]                         frame <- frame + 1L
[11:03:26.036]                         envir <- sys.frame(frame)
[11:03:26.036]                       }
[11:03:26.036]                     }
[11:03:26.036]                     sendCondition <<- function(cond) NULL
[11:03:26.036]                   }
[11:03:26.036]                 })
[11:03:26.036]                 withCallingHandlers({
[11:03:26.036]                   {
[11:03:26.036]                     print(1:50)
[11:03:26.036]                     str(1:50)
[11:03:26.036]                     cat(letters, sep = "-")
[11:03:26.036]                     cat(1:6, collapse = "\n")
[11:03:26.036]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:26.036]                     42L
[11:03:26.036]                   }
[11:03:26.036]                 }, immediateCondition = function(cond) {
[11:03:26.036]                   sendCondition <- ...future.makeSendCondition()
[11:03:26.036]                   sendCondition(cond)
[11:03:26.036]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.036]                   {
[11:03:26.036]                     inherits <- base::inherits
[11:03:26.036]                     invokeRestart <- base::invokeRestart
[11:03:26.036]                     is.null <- base::is.null
[11:03:26.036]                     muffled <- FALSE
[11:03:26.036]                     if (inherits(cond, "message")) {
[11:03:26.036]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:26.036]                       if (muffled) 
[11:03:26.036]                         invokeRestart("muffleMessage")
[11:03:26.036]                     }
[11:03:26.036]                     else if (inherits(cond, "warning")) {
[11:03:26.036]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:26.036]                       if (muffled) 
[11:03:26.036]                         invokeRestart("muffleWarning")
[11:03:26.036]                     }
[11:03:26.036]                     else if (inherits(cond, "condition")) {
[11:03:26.036]                       if (!is.null(pattern)) {
[11:03:26.036]                         computeRestarts <- base::computeRestarts
[11:03:26.036]                         grepl <- base::grepl
[11:03:26.036]                         restarts <- computeRestarts(cond)
[11:03:26.036]                         for (restart in restarts) {
[11:03:26.036]                           name <- restart$name
[11:03:26.036]                           if (is.null(name)) 
[11:03:26.036]                             next
[11:03:26.036]                           if (!grepl(pattern, name)) 
[11:03:26.036]                             next
[11:03:26.036]                           invokeRestart(restart)
[11:03:26.036]                           muffled <- TRUE
[11:03:26.036]                           break
[11:03:26.036]                         }
[11:03:26.036]                       }
[11:03:26.036]                     }
[11:03:26.036]                     invisible(muffled)
[11:03:26.036]                   }
[11:03:26.036]                   muffleCondition(cond)
[11:03:26.036]                 })
[11:03:26.036]             }))
[11:03:26.036]             future::FutureResult(value = ...future.value$value, 
[11:03:26.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.036]                   ...future.rng), globalenv = if (FALSE) 
[11:03:26.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:26.036]                     ...future.globalenv.names))
[11:03:26.036]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:26.036]         }, condition = base::local({
[11:03:26.036]             c <- base::c
[11:03:26.036]             inherits <- base::inherits
[11:03:26.036]             invokeRestart <- base::invokeRestart
[11:03:26.036]             length <- base::length
[11:03:26.036]             list <- base::list
[11:03:26.036]             seq.int <- base::seq.int
[11:03:26.036]             signalCondition <- base::signalCondition
[11:03:26.036]             sys.calls <- base::sys.calls
[11:03:26.036]             `[[` <- base::`[[`
[11:03:26.036]             `+` <- base::`+`
[11:03:26.036]             `<<-` <- base::`<<-`
[11:03:26.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:26.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:26.036]                   3L)]
[11:03:26.036]             }
[11:03:26.036]             function(cond) {
[11:03:26.036]                 is_error <- inherits(cond, "error")
[11:03:26.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:26.036]                   NULL)
[11:03:26.036]                 if (is_error) {
[11:03:26.036]                   sessionInformation <- function() {
[11:03:26.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:26.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:26.036]                       search = base::search(), system = base::Sys.info())
[11:03:26.036]                   }
[11:03:26.036]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:26.036]                     cond$call), session = sessionInformation(), 
[11:03:26.036]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:26.036]                   signalCondition(cond)
[11:03:26.036]                 }
[11:03:26.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:26.036]                 "immediateCondition"))) {
[11:03:26.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:26.036]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:26.036]                   if (TRUE && !signal) {
[11:03:26.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.036]                     {
[11:03:26.036]                       inherits <- base::inherits
[11:03:26.036]                       invokeRestart <- base::invokeRestart
[11:03:26.036]                       is.null <- base::is.null
[11:03:26.036]                       muffled <- FALSE
[11:03:26.036]                       if (inherits(cond, "message")) {
[11:03:26.036]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.036]                         if (muffled) 
[11:03:26.036]                           invokeRestart("muffleMessage")
[11:03:26.036]                       }
[11:03:26.036]                       else if (inherits(cond, "warning")) {
[11:03:26.036]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.036]                         if (muffled) 
[11:03:26.036]                           invokeRestart("muffleWarning")
[11:03:26.036]                       }
[11:03:26.036]                       else if (inherits(cond, "condition")) {
[11:03:26.036]                         if (!is.null(pattern)) {
[11:03:26.036]                           computeRestarts <- base::computeRestarts
[11:03:26.036]                           grepl <- base::grepl
[11:03:26.036]                           restarts <- computeRestarts(cond)
[11:03:26.036]                           for (restart in restarts) {
[11:03:26.036]                             name <- restart$name
[11:03:26.036]                             if (is.null(name)) 
[11:03:26.036]                               next
[11:03:26.036]                             if (!grepl(pattern, name)) 
[11:03:26.036]                               next
[11:03:26.036]                             invokeRestart(restart)
[11:03:26.036]                             muffled <- TRUE
[11:03:26.036]                             break
[11:03:26.036]                           }
[11:03:26.036]                         }
[11:03:26.036]                       }
[11:03:26.036]                       invisible(muffled)
[11:03:26.036]                     }
[11:03:26.036]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.036]                   }
[11:03:26.036]                 }
[11:03:26.036]                 else {
[11:03:26.036]                   if (TRUE) {
[11:03:26.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.036]                     {
[11:03:26.036]                       inherits <- base::inherits
[11:03:26.036]                       invokeRestart <- base::invokeRestart
[11:03:26.036]                       is.null <- base::is.null
[11:03:26.036]                       muffled <- FALSE
[11:03:26.036]                       if (inherits(cond, "message")) {
[11:03:26.036]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.036]                         if (muffled) 
[11:03:26.036]                           invokeRestart("muffleMessage")
[11:03:26.036]                       }
[11:03:26.036]                       else if (inherits(cond, "warning")) {
[11:03:26.036]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.036]                         if (muffled) 
[11:03:26.036]                           invokeRestart("muffleWarning")
[11:03:26.036]                       }
[11:03:26.036]                       else if (inherits(cond, "condition")) {
[11:03:26.036]                         if (!is.null(pattern)) {
[11:03:26.036]                           computeRestarts <- base::computeRestarts
[11:03:26.036]                           grepl <- base::grepl
[11:03:26.036]                           restarts <- computeRestarts(cond)
[11:03:26.036]                           for (restart in restarts) {
[11:03:26.036]                             name <- restart$name
[11:03:26.036]                             if (is.null(name)) 
[11:03:26.036]                               next
[11:03:26.036]                             if (!grepl(pattern, name)) 
[11:03:26.036]                               next
[11:03:26.036]                             invokeRestart(restart)
[11:03:26.036]                             muffled <- TRUE
[11:03:26.036]                             break
[11:03:26.036]                           }
[11:03:26.036]                         }
[11:03:26.036]                       }
[11:03:26.036]                       invisible(muffled)
[11:03:26.036]                     }
[11:03:26.036]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.036]                   }
[11:03:26.036]                 }
[11:03:26.036]             }
[11:03:26.036]         }))
[11:03:26.036]     }, error = function(ex) {
[11:03:26.036]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:26.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.036]                 ...future.rng), started = ...future.startTime, 
[11:03:26.036]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:26.036]             version = "1.8"), class = "FutureResult")
[11:03:26.036]     }, finally = {
[11:03:26.036]         if (!identical(...future.workdir, getwd())) 
[11:03:26.036]             setwd(...future.workdir)
[11:03:26.036]         {
[11:03:26.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:26.036]                 ...future.oldOptions$nwarnings <- NULL
[11:03:26.036]             }
[11:03:26.036]             base::options(...future.oldOptions)
[11:03:26.036]             if (.Platform$OS.type == "windows") {
[11:03:26.036]                 old_names <- names(...future.oldEnvVars)
[11:03:26.036]                 envs <- base::Sys.getenv()
[11:03:26.036]                 names <- names(envs)
[11:03:26.036]                 common <- intersect(names, old_names)
[11:03:26.036]                 added <- setdiff(names, old_names)
[11:03:26.036]                 removed <- setdiff(old_names, names)
[11:03:26.036]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:26.036]                   envs[common]]
[11:03:26.036]                 NAMES <- toupper(changed)
[11:03:26.036]                 args <- list()
[11:03:26.036]                 for (kk in seq_along(NAMES)) {
[11:03:26.036]                   name <- changed[[kk]]
[11:03:26.036]                   NAME <- NAMES[[kk]]
[11:03:26.036]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.036]                     next
[11:03:26.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.036]                 }
[11:03:26.036]                 NAMES <- toupper(added)
[11:03:26.036]                 for (kk in seq_along(NAMES)) {
[11:03:26.036]                   name <- added[[kk]]
[11:03:26.036]                   NAME <- NAMES[[kk]]
[11:03:26.036]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.036]                     next
[11:03:26.036]                   args[[name]] <- ""
[11:03:26.036]                 }
[11:03:26.036]                 NAMES <- toupper(removed)
[11:03:26.036]                 for (kk in seq_along(NAMES)) {
[11:03:26.036]                   name <- removed[[kk]]
[11:03:26.036]                   NAME <- NAMES[[kk]]
[11:03:26.036]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.036]                     next
[11:03:26.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.036]                 }
[11:03:26.036]                 if (length(args) > 0) 
[11:03:26.036]                   base::do.call(base::Sys.setenv, args = args)
[11:03:26.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:26.036]             }
[11:03:26.036]             else {
[11:03:26.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:26.036]             }
[11:03:26.036]             {
[11:03:26.036]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:26.036]                   0L) {
[11:03:26.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:26.036]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:26.036]                   base::options(opts)
[11:03:26.036]                 }
[11:03:26.036]                 {
[11:03:26.036]                   {
[11:03:26.036]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:26.036]                     NULL
[11:03:26.036]                   }
[11:03:26.036]                   options(future.plan = NULL)
[11:03:26.036]                   if (is.na(NA_character_)) 
[11:03:26.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:26.036]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:26.036]                     .init = FALSE)
[11:03:26.036]                 }
[11:03:26.036]             }
[11:03:26.036]         }
[11:03:26.036]     })
[11:03:26.036]     if (TRUE) {
[11:03:26.036]         base::sink(type = "output", split = FALSE)
[11:03:26.036]         if (TRUE) {
[11:03:26.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:26.036]         }
[11:03:26.036]         else {
[11:03:26.036]             ...future.result["stdout"] <- base::list(NULL)
[11:03:26.036]         }
[11:03:26.036]         base::close(...future.stdout)
[11:03:26.036]         ...future.stdout <- NULL
[11:03:26.036]     }
[11:03:26.036]     ...future.result$conditions <- ...future.conditions
[11:03:26.036]     ...future.result$finished <- base::Sys.time()
[11:03:26.036]     ...future.result
[11:03:26.036] }
[11:03:26.039] MultisessionFuture started
[11:03:26.039] - Launch lazy future ... done
[11:03:26.040] run() for ‘MultisessionFuture’ ... done
[11:03:26.040] result() for ClusterFuture ...
[11:03:26.040] receiveMessageFromWorker() for ClusterFuture ...
[11:03:26.040] - Validating connection of MultisessionFuture
[11:03:26.082] - received message: FutureResult
[11:03:26.082] - Received FutureResult
[11:03:26.082] - Erased future from FutureRegistry
[11:03:26.082] result() for ClusterFuture ...
[11:03:26.082] - result already collected: FutureResult
[11:03:26.082] result() for ClusterFuture ... done
[11:03:26.083] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:26.083] result() for ClusterFuture ... done
[11:03:26.083] result() for ClusterFuture ...
[11:03:26.083] - result already collected: FutureResult
[11:03:26.083] result() for ClusterFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[11:03:26.083] getGlobalsAndPackages() ...
[11:03:26.083] Searching for globals...
[11:03:26.084] - globals found: [1] ‘print’
[11:03:26.084] Searching for globals ... DONE
[11:03:26.084] Resolving globals: FALSE
[11:03:26.085] 
[11:03:26.085] 
[11:03:26.085] getGlobalsAndPackages() ... DONE
[11:03:26.085] run() for ‘Future’ ...
[11:03:26.085] - state: ‘created’
[11:03:26.085] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:03:26.100] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:26.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:03:26.100]   - Field: ‘node’
[11:03:26.100]   - Field: ‘label’
[11:03:26.100]   - Field: ‘local’
[11:03:26.100]   - Field: ‘owner’
[11:03:26.100]   - Field: ‘envir’
[11:03:26.100]   - Field: ‘workers’
[11:03:26.101]   - Field: ‘packages’
[11:03:26.101]   - Field: ‘gc’
[11:03:26.101]   - Field: ‘conditions’
[11:03:26.101]   - Field: ‘persistent’
[11:03:26.101]   - Field: ‘expr’
[11:03:26.101]   - Field: ‘uuid’
[11:03:26.101]   - Field: ‘seed’
[11:03:26.101]   - Field: ‘version’
[11:03:26.101]   - Field: ‘result’
[11:03:26.102]   - Field: ‘asynchronous’
[11:03:26.102]   - Field: ‘calls’
[11:03:26.102]   - Field: ‘globals’
[11:03:26.102]   - Field: ‘stdout’
[11:03:26.102]   - Field: ‘earlySignal’
[11:03:26.102]   - Field: ‘lazy’
[11:03:26.102]   - Field: ‘state’
[11:03:26.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:03:26.102] - Launch lazy future ...
[11:03:26.103] Packages needed by the future expression (n = 0): <none>
[11:03:26.103] Packages needed by future strategies (n = 0): <none>
[11:03:26.103] {
[11:03:26.103]     {
[11:03:26.103]         {
[11:03:26.103]             ...future.startTime <- base::Sys.time()
[11:03:26.103]             {
[11:03:26.103]                 {
[11:03:26.103]                   {
[11:03:26.103]                     {
[11:03:26.103]                       base::local({
[11:03:26.103]                         has_future <- base::requireNamespace("future", 
[11:03:26.103]                           quietly = TRUE)
[11:03:26.103]                         if (has_future) {
[11:03:26.103]                           ns <- base::getNamespace("future")
[11:03:26.103]                           version <- ns[[".package"]][["version"]]
[11:03:26.103]                           if (is.null(version)) 
[11:03:26.103]                             version <- utils::packageVersion("future")
[11:03:26.103]                         }
[11:03:26.103]                         else {
[11:03:26.103]                           version <- NULL
[11:03:26.103]                         }
[11:03:26.103]                         if (!has_future || version < "1.8.0") {
[11:03:26.103]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:26.103]                             "", base::R.version$version.string), 
[11:03:26.103]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:26.103]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:26.103]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:26.103]                               "release", "version")], collapse = " "), 
[11:03:26.103]                             hostname = base::Sys.info()[["nodename"]])
[11:03:26.103]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:26.103]                             info)
[11:03:26.103]                           info <- base::paste(info, collapse = "; ")
[11:03:26.103]                           if (!has_future) {
[11:03:26.103]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:26.103]                               info)
[11:03:26.103]                           }
[11:03:26.103]                           else {
[11:03:26.103]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:26.103]                               info, version)
[11:03:26.103]                           }
[11:03:26.103]                           base::stop(msg)
[11:03:26.103]                         }
[11:03:26.103]                       })
[11:03:26.103]                     }
[11:03:26.103]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:26.103]                     base::options(mc.cores = 1L)
[11:03:26.103]                   }
[11:03:26.103]                   ...future.strategy.old <- future::plan("list")
[11:03:26.103]                   options(future.plan = NULL)
[11:03:26.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:26.103]                 }
[11:03:26.103]                 ...future.workdir <- getwd()
[11:03:26.103]             }
[11:03:26.103]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:26.103]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:26.103]         }
[11:03:26.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:26.103]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:26.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:26.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:26.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:26.103]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:26.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:26.103]             base::names(...future.oldOptions))
[11:03:26.103]     }
[11:03:26.103]     if (FALSE) {
[11:03:26.103]     }
[11:03:26.103]     else {
[11:03:26.103]         if (TRUE) {
[11:03:26.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:26.103]                 open = "w")
[11:03:26.103]         }
[11:03:26.103]         else {
[11:03:26.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:26.103]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:26.103]         }
[11:03:26.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:26.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:26.103]             base::sink(type = "output", split = FALSE)
[11:03:26.103]             base::close(...future.stdout)
[11:03:26.103]         }, add = TRUE)
[11:03:26.103]     }
[11:03:26.103]     ...future.frame <- base::sys.nframe()
[11:03:26.103]     ...future.conditions <- base::list()
[11:03:26.103]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:26.103]     if (FALSE) {
[11:03:26.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:26.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:26.103]     }
[11:03:26.103]     ...future.result <- base::tryCatch({
[11:03:26.103]         base::withCallingHandlers({
[11:03:26.103]             ...future.value <- base::withVisible(base::local({
[11:03:26.103]                 ...future.makeSendCondition <- base::local({
[11:03:26.103]                   sendCondition <- NULL
[11:03:26.103]                   function(frame = 1L) {
[11:03:26.103]                     if (is.function(sendCondition)) 
[11:03:26.103]                       return(sendCondition)
[11:03:26.103]                     ns <- getNamespace("parallel")
[11:03:26.103]                     if (exists("sendData", mode = "function", 
[11:03:26.103]                       envir = ns)) {
[11:03:26.103]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:26.103]                         envir = ns)
[11:03:26.103]                       envir <- sys.frame(frame)
[11:03:26.103]                       master <- NULL
[11:03:26.103]                       while (!identical(envir, .GlobalEnv) && 
[11:03:26.103]                         !identical(envir, emptyenv())) {
[11:03:26.103]                         if (exists("master", mode = "list", envir = envir, 
[11:03:26.103]                           inherits = FALSE)) {
[11:03:26.103]                           master <- get("master", mode = "list", 
[11:03:26.103]                             envir = envir, inherits = FALSE)
[11:03:26.103]                           if (inherits(master, c("SOCKnode", 
[11:03:26.103]                             "SOCK0node"))) {
[11:03:26.103]                             sendCondition <<- function(cond) {
[11:03:26.103]                               data <- list(type = "VALUE", value = cond, 
[11:03:26.103]                                 success = TRUE)
[11:03:26.103]                               parallel_sendData(master, data)
[11:03:26.103]                             }
[11:03:26.103]                             return(sendCondition)
[11:03:26.103]                           }
[11:03:26.103]                         }
[11:03:26.103]                         frame <- frame + 1L
[11:03:26.103]                         envir <- sys.frame(frame)
[11:03:26.103]                       }
[11:03:26.103]                     }
[11:03:26.103]                     sendCondition <<- function(cond) NULL
[11:03:26.103]                   }
[11:03:26.103]                 })
[11:03:26.103]                 withCallingHandlers({
[11:03:26.103]                   print(42)
[11:03:26.103]                 }, immediateCondition = function(cond) {
[11:03:26.103]                   sendCondition <- ...future.makeSendCondition()
[11:03:26.103]                   sendCondition(cond)
[11:03:26.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.103]                   {
[11:03:26.103]                     inherits <- base::inherits
[11:03:26.103]                     invokeRestart <- base::invokeRestart
[11:03:26.103]                     is.null <- base::is.null
[11:03:26.103]                     muffled <- FALSE
[11:03:26.103]                     if (inherits(cond, "message")) {
[11:03:26.103]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:26.103]                       if (muffled) 
[11:03:26.103]                         invokeRestart("muffleMessage")
[11:03:26.103]                     }
[11:03:26.103]                     else if (inherits(cond, "warning")) {
[11:03:26.103]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:26.103]                       if (muffled) 
[11:03:26.103]                         invokeRestart("muffleWarning")
[11:03:26.103]                     }
[11:03:26.103]                     else if (inherits(cond, "condition")) {
[11:03:26.103]                       if (!is.null(pattern)) {
[11:03:26.103]                         computeRestarts <- base::computeRestarts
[11:03:26.103]                         grepl <- base::grepl
[11:03:26.103]                         restarts <- computeRestarts(cond)
[11:03:26.103]                         for (restart in restarts) {
[11:03:26.103]                           name <- restart$name
[11:03:26.103]                           if (is.null(name)) 
[11:03:26.103]                             next
[11:03:26.103]                           if (!grepl(pattern, name)) 
[11:03:26.103]                             next
[11:03:26.103]                           invokeRestart(restart)
[11:03:26.103]                           muffled <- TRUE
[11:03:26.103]                           break
[11:03:26.103]                         }
[11:03:26.103]                       }
[11:03:26.103]                     }
[11:03:26.103]                     invisible(muffled)
[11:03:26.103]                   }
[11:03:26.103]                   muffleCondition(cond)
[11:03:26.103]                 })
[11:03:26.103]             }))
[11:03:26.103]             future::FutureResult(value = ...future.value$value, 
[11:03:26.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.103]                   ...future.rng), globalenv = if (FALSE) 
[11:03:26.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:26.103]                     ...future.globalenv.names))
[11:03:26.103]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:26.103]         }, condition = base::local({
[11:03:26.103]             c <- base::c
[11:03:26.103]             inherits <- base::inherits
[11:03:26.103]             invokeRestart <- base::invokeRestart
[11:03:26.103]             length <- base::length
[11:03:26.103]             list <- base::list
[11:03:26.103]             seq.int <- base::seq.int
[11:03:26.103]             signalCondition <- base::signalCondition
[11:03:26.103]             sys.calls <- base::sys.calls
[11:03:26.103]             `[[` <- base::`[[`
[11:03:26.103]             `+` <- base::`+`
[11:03:26.103]             `<<-` <- base::`<<-`
[11:03:26.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:26.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:26.103]                   3L)]
[11:03:26.103]             }
[11:03:26.103]             function(cond) {
[11:03:26.103]                 is_error <- inherits(cond, "error")
[11:03:26.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:26.103]                   NULL)
[11:03:26.103]                 if (is_error) {
[11:03:26.103]                   sessionInformation <- function() {
[11:03:26.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:26.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:26.103]                       search = base::search(), system = base::Sys.info())
[11:03:26.103]                   }
[11:03:26.103]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:26.103]                     cond$call), session = sessionInformation(), 
[11:03:26.103]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:26.103]                   signalCondition(cond)
[11:03:26.103]                 }
[11:03:26.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:26.103]                 "immediateCondition"))) {
[11:03:26.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:26.103]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:26.103]                   if (TRUE && !signal) {
[11:03:26.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.103]                     {
[11:03:26.103]                       inherits <- base::inherits
[11:03:26.103]                       invokeRestart <- base::invokeRestart
[11:03:26.103]                       is.null <- base::is.null
[11:03:26.103]                       muffled <- FALSE
[11:03:26.103]                       if (inherits(cond, "message")) {
[11:03:26.103]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.103]                         if (muffled) 
[11:03:26.103]                           invokeRestart("muffleMessage")
[11:03:26.103]                       }
[11:03:26.103]                       else if (inherits(cond, "warning")) {
[11:03:26.103]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.103]                         if (muffled) 
[11:03:26.103]                           invokeRestart("muffleWarning")
[11:03:26.103]                       }
[11:03:26.103]                       else if (inherits(cond, "condition")) {
[11:03:26.103]                         if (!is.null(pattern)) {
[11:03:26.103]                           computeRestarts <- base::computeRestarts
[11:03:26.103]                           grepl <- base::grepl
[11:03:26.103]                           restarts <- computeRestarts(cond)
[11:03:26.103]                           for (restart in restarts) {
[11:03:26.103]                             name <- restart$name
[11:03:26.103]                             if (is.null(name)) 
[11:03:26.103]                               next
[11:03:26.103]                             if (!grepl(pattern, name)) 
[11:03:26.103]                               next
[11:03:26.103]                             invokeRestart(restart)
[11:03:26.103]                             muffled <- TRUE
[11:03:26.103]                             break
[11:03:26.103]                           }
[11:03:26.103]                         }
[11:03:26.103]                       }
[11:03:26.103]                       invisible(muffled)
[11:03:26.103]                     }
[11:03:26.103]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.103]                   }
[11:03:26.103]                 }
[11:03:26.103]                 else {
[11:03:26.103]                   if (TRUE) {
[11:03:26.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.103]                     {
[11:03:26.103]                       inherits <- base::inherits
[11:03:26.103]                       invokeRestart <- base::invokeRestart
[11:03:26.103]                       is.null <- base::is.null
[11:03:26.103]                       muffled <- FALSE
[11:03:26.103]                       if (inherits(cond, "message")) {
[11:03:26.103]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.103]                         if (muffled) 
[11:03:26.103]                           invokeRestart("muffleMessage")
[11:03:26.103]                       }
[11:03:26.103]                       else if (inherits(cond, "warning")) {
[11:03:26.103]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.103]                         if (muffled) 
[11:03:26.103]                           invokeRestart("muffleWarning")
[11:03:26.103]                       }
[11:03:26.103]                       else if (inherits(cond, "condition")) {
[11:03:26.103]                         if (!is.null(pattern)) {
[11:03:26.103]                           computeRestarts <- base::computeRestarts
[11:03:26.103]                           grepl <- base::grepl
[11:03:26.103]                           restarts <- computeRestarts(cond)
[11:03:26.103]                           for (restart in restarts) {
[11:03:26.103]                             name <- restart$name
[11:03:26.103]                             if (is.null(name)) 
[11:03:26.103]                               next
[11:03:26.103]                             if (!grepl(pattern, name)) 
[11:03:26.103]                               next
[11:03:26.103]                             invokeRestart(restart)
[11:03:26.103]                             muffled <- TRUE
[11:03:26.103]                             break
[11:03:26.103]                           }
[11:03:26.103]                         }
[11:03:26.103]                       }
[11:03:26.103]                       invisible(muffled)
[11:03:26.103]                     }
[11:03:26.103]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.103]                   }
[11:03:26.103]                 }
[11:03:26.103]             }
[11:03:26.103]         }))
[11:03:26.103]     }, error = function(ex) {
[11:03:26.103]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:26.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.103]                 ...future.rng), started = ...future.startTime, 
[11:03:26.103]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:26.103]             version = "1.8"), class = "FutureResult")
[11:03:26.103]     }, finally = {
[11:03:26.103]         if (!identical(...future.workdir, getwd())) 
[11:03:26.103]             setwd(...future.workdir)
[11:03:26.103]         {
[11:03:26.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:26.103]                 ...future.oldOptions$nwarnings <- NULL
[11:03:26.103]             }
[11:03:26.103]             base::options(...future.oldOptions)
[11:03:26.103]             if (.Platform$OS.type == "windows") {
[11:03:26.103]                 old_names <- names(...future.oldEnvVars)
[11:03:26.103]                 envs <- base::Sys.getenv()
[11:03:26.103]                 names <- names(envs)
[11:03:26.103]                 common <- intersect(names, old_names)
[11:03:26.103]                 added <- setdiff(names, old_names)
[11:03:26.103]                 removed <- setdiff(old_names, names)
[11:03:26.103]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:26.103]                   envs[common]]
[11:03:26.103]                 NAMES <- toupper(changed)
[11:03:26.103]                 args <- list()
[11:03:26.103]                 for (kk in seq_along(NAMES)) {
[11:03:26.103]                   name <- changed[[kk]]
[11:03:26.103]                   NAME <- NAMES[[kk]]
[11:03:26.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.103]                     next
[11:03:26.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.103]                 }
[11:03:26.103]                 NAMES <- toupper(added)
[11:03:26.103]                 for (kk in seq_along(NAMES)) {
[11:03:26.103]                   name <- added[[kk]]
[11:03:26.103]                   NAME <- NAMES[[kk]]
[11:03:26.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.103]                     next
[11:03:26.103]                   args[[name]] <- ""
[11:03:26.103]                 }
[11:03:26.103]                 NAMES <- toupper(removed)
[11:03:26.103]                 for (kk in seq_along(NAMES)) {
[11:03:26.103]                   name <- removed[[kk]]
[11:03:26.103]                   NAME <- NAMES[[kk]]
[11:03:26.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.103]                     next
[11:03:26.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.103]                 }
[11:03:26.103]                 if (length(args) > 0) 
[11:03:26.103]                   base::do.call(base::Sys.setenv, args = args)
[11:03:26.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:26.103]             }
[11:03:26.103]             else {
[11:03:26.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:26.103]             }
[11:03:26.103]             {
[11:03:26.103]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:26.103]                   0L) {
[11:03:26.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:26.103]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:26.103]                   base::options(opts)
[11:03:26.103]                 }
[11:03:26.103]                 {
[11:03:26.103]                   {
[11:03:26.103]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:26.103]                     NULL
[11:03:26.103]                   }
[11:03:26.103]                   options(future.plan = NULL)
[11:03:26.103]                   if (is.na(NA_character_)) 
[11:03:26.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:26.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:26.103]                     .init = FALSE)
[11:03:26.103]                 }
[11:03:26.103]             }
[11:03:26.103]         }
[11:03:26.103]     })
[11:03:26.103]     if (TRUE) {
[11:03:26.103]         base::sink(type = "output", split = FALSE)
[11:03:26.103]         if (TRUE) {
[11:03:26.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:26.103]         }
[11:03:26.103]         else {
[11:03:26.103]             ...future.result["stdout"] <- base::list(NULL)
[11:03:26.103]         }
[11:03:26.103]         base::close(...future.stdout)
[11:03:26.103]         ...future.stdout <- NULL
[11:03:26.103]     }
[11:03:26.103]     ...future.result$conditions <- ...future.conditions
[11:03:26.103]     ...future.result$finished <- base::Sys.time()
[11:03:26.103]     ...future.result
[11:03:26.103] }
[11:03:26.107] MultisessionFuture started
[11:03:26.107] - Launch lazy future ... done
[11:03:26.107] run() for ‘MultisessionFuture’ ... done
[11:03:26.107] result() for ClusterFuture ...
[11:03:26.107] receiveMessageFromWorker() for ClusterFuture ...
[11:03:26.107] - Validating connection of MultisessionFuture
[11:03:26.148] - received message: FutureResult
[11:03:26.148] - Received FutureResult
[11:03:26.148] - Erased future from FutureRegistry
[11:03:26.148] result() for ClusterFuture ...
[11:03:26.148] - result already collected: FutureResult
[11:03:26.148] result() for ClusterFuture ... done
[11:03:26.149] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:26.149] result() for ClusterFuture ... done
[11:03:26.149] result() for ClusterFuture ...
[11:03:26.149] - result already collected: FutureResult
[11:03:26.149] result() for ClusterFuture ... done
[11:03:26.149] result() for ClusterFuture ...
[11:03:26.149] - result already collected: FutureResult
[11:03:26.149] result() for ClusterFuture ... done
[1] 42
[11:03:26.149] result() for ClusterFuture ...
[11:03:26.150] - result already collected: FutureResult
[11:03:26.150] result() for ClusterFuture ... done
- stdout = FALSE
[11:03:26.150] getGlobalsAndPackages() ...
[11:03:26.150] Searching for globals...
[11:03:26.154] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:26.154] Searching for globals ... DONE
[11:03:26.154] Resolving globals: FALSE
[11:03:26.154] 
[11:03:26.154] - packages: [1] ‘utils’
[11:03:26.155] getGlobalsAndPackages() ... DONE
[11:03:26.155] run() for ‘Future’ ...
[11:03:26.155] - state: ‘created’
[11:03:26.155] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:03:26.170] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:26.170] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:03:26.170]   - Field: ‘node’
[11:03:26.170]   - Field: ‘label’
[11:03:26.170]   - Field: ‘local’
[11:03:26.170]   - Field: ‘owner’
[11:03:26.170]   - Field: ‘envir’
[11:03:26.170]   - Field: ‘workers’
[11:03:26.170]   - Field: ‘packages’
[11:03:26.170]   - Field: ‘gc’
[11:03:26.171]   - Field: ‘conditions’
[11:03:26.171]   - Field: ‘persistent’
[11:03:26.171]   - Field: ‘expr’
[11:03:26.171]   - Field: ‘uuid’
[11:03:26.171]   - Field: ‘seed’
[11:03:26.171]   - Field: ‘version’
[11:03:26.171]   - Field: ‘result’
[11:03:26.171]   - Field: ‘asynchronous’
[11:03:26.171]   - Field: ‘calls’
[11:03:26.172]   - Field: ‘globals’
[11:03:26.172]   - Field: ‘stdout’
[11:03:26.172]   - Field: ‘earlySignal’
[11:03:26.172]   - Field: ‘lazy’
[11:03:26.172]   - Field: ‘state’
[11:03:26.172] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:03:26.172] - Launch lazy future ...
[11:03:26.172] Packages needed by the future expression (n = 1): ‘utils’
[11:03:26.173] Packages needed by future strategies (n = 0): <none>
[11:03:26.173] {
[11:03:26.173]     {
[11:03:26.173]         {
[11:03:26.173]             ...future.startTime <- base::Sys.time()
[11:03:26.173]             {
[11:03:26.173]                 {
[11:03:26.173]                   {
[11:03:26.173]                     {
[11:03:26.173]                       {
[11:03:26.173]                         base::local({
[11:03:26.173]                           has_future <- base::requireNamespace("future", 
[11:03:26.173]                             quietly = TRUE)
[11:03:26.173]                           if (has_future) {
[11:03:26.173]                             ns <- base::getNamespace("future")
[11:03:26.173]                             version <- ns[[".package"]][["version"]]
[11:03:26.173]                             if (is.null(version)) 
[11:03:26.173]                               version <- utils::packageVersion("future")
[11:03:26.173]                           }
[11:03:26.173]                           else {
[11:03:26.173]                             version <- NULL
[11:03:26.173]                           }
[11:03:26.173]                           if (!has_future || version < "1.8.0") {
[11:03:26.173]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:26.173]                               "", base::R.version$version.string), 
[11:03:26.173]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:26.173]                                 base::R.version$platform, 8 * 
[11:03:26.173]                                   base::.Machine$sizeof.pointer), 
[11:03:26.173]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:26.173]                                 "release", "version")], collapse = " "), 
[11:03:26.173]                               hostname = base::Sys.info()[["nodename"]])
[11:03:26.173]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:26.173]                               info)
[11:03:26.173]                             info <- base::paste(info, collapse = "; ")
[11:03:26.173]                             if (!has_future) {
[11:03:26.173]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:26.173]                                 info)
[11:03:26.173]                             }
[11:03:26.173]                             else {
[11:03:26.173]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:26.173]                                 info, version)
[11:03:26.173]                             }
[11:03:26.173]                             base::stop(msg)
[11:03:26.173]                           }
[11:03:26.173]                         })
[11:03:26.173]                       }
[11:03:26.173]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:26.173]                       base::options(mc.cores = 1L)
[11:03:26.173]                     }
[11:03:26.173]                     base::local({
[11:03:26.173]                       for (pkg in "utils") {
[11:03:26.173]                         base::loadNamespace(pkg)
[11:03:26.173]                         base::library(pkg, character.only = TRUE)
[11:03:26.173]                       }
[11:03:26.173]                     })
[11:03:26.173]                   }
[11:03:26.173]                   ...future.strategy.old <- future::plan("list")
[11:03:26.173]                   options(future.plan = NULL)
[11:03:26.173]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.173]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:26.173]                 }
[11:03:26.173]                 ...future.workdir <- getwd()
[11:03:26.173]             }
[11:03:26.173]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:26.173]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:26.173]         }
[11:03:26.173]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:26.173]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:26.173]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:26.173]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:26.173]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:26.173]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:26.173]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:26.173]             base::names(...future.oldOptions))
[11:03:26.173]     }
[11:03:26.173]     if (FALSE) {
[11:03:26.173]     }
[11:03:26.173]     else {
[11:03:26.173]         if (FALSE) {
[11:03:26.173]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:26.173]                 open = "w")
[11:03:26.173]         }
[11:03:26.173]         else {
[11:03:26.173]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:26.173]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:26.173]         }
[11:03:26.173]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:26.173]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:26.173]             base::sink(type = "output", split = FALSE)
[11:03:26.173]             base::close(...future.stdout)
[11:03:26.173]         }, add = TRUE)
[11:03:26.173]     }
[11:03:26.173]     ...future.frame <- base::sys.nframe()
[11:03:26.173]     ...future.conditions <- base::list()
[11:03:26.173]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:26.173]     if (FALSE) {
[11:03:26.173]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:26.173]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:26.173]     }
[11:03:26.173]     ...future.result <- base::tryCatch({
[11:03:26.173]         base::withCallingHandlers({
[11:03:26.173]             ...future.value <- base::withVisible(base::local({
[11:03:26.173]                 ...future.makeSendCondition <- base::local({
[11:03:26.173]                   sendCondition <- NULL
[11:03:26.173]                   function(frame = 1L) {
[11:03:26.173]                     if (is.function(sendCondition)) 
[11:03:26.173]                       return(sendCondition)
[11:03:26.173]                     ns <- getNamespace("parallel")
[11:03:26.173]                     if (exists("sendData", mode = "function", 
[11:03:26.173]                       envir = ns)) {
[11:03:26.173]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:26.173]                         envir = ns)
[11:03:26.173]                       envir <- sys.frame(frame)
[11:03:26.173]                       master <- NULL
[11:03:26.173]                       while (!identical(envir, .GlobalEnv) && 
[11:03:26.173]                         !identical(envir, emptyenv())) {
[11:03:26.173]                         if (exists("master", mode = "list", envir = envir, 
[11:03:26.173]                           inherits = FALSE)) {
[11:03:26.173]                           master <- get("master", mode = "list", 
[11:03:26.173]                             envir = envir, inherits = FALSE)
[11:03:26.173]                           if (inherits(master, c("SOCKnode", 
[11:03:26.173]                             "SOCK0node"))) {
[11:03:26.173]                             sendCondition <<- function(cond) {
[11:03:26.173]                               data <- list(type = "VALUE", value = cond, 
[11:03:26.173]                                 success = TRUE)
[11:03:26.173]                               parallel_sendData(master, data)
[11:03:26.173]                             }
[11:03:26.173]                             return(sendCondition)
[11:03:26.173]                           }
[11:03:26.173]                         }
[11:03:26.173]                         frame <- frame + 1L
[11:03:26.173]                         envir <- sys.frame(frame)
[11:03:26.173]                       }
[11:03:26.173]                     }
[11:03:26.173]                     sendCondition <<- function(cond) NULL
[11:03:26.173]                   }
[11:03:26.173]                 })
[11:03:26.173]                 withCallingHandlers({
[11:03:26.173]                   {
[11:03:26.173]                     print(1:50)
[11:03:26.173]                     str(1:50)
[11:03:26.173]                     cat(letters, sep = "-")
[11:03:26.173]                     cat(1:6, collapse = "\n")
[11:03:26.173]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:26.173]                     42L
[11:03:26.173]                   }
[11:03:26.173]                 }, immediateCondition = function(cond) {
[11:03:26.173]                   sendCondition <- ...future.makeSendCondition()
[11:03:26.173]                   sendCondition(cond)
[11:03:26.173]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.173]                   {
[11:03:26.173]                     inherits <- base::inherits
[11:03:26.173]                     invokeRestart <- base::invokeRestart
[11:03:26.173]                     is.null <- base::is.null
[11:03:26.173]                     muffled <- FALSE
[11:03:26.173]                     if (inherits(cond, "message")) {
[11:03:26.173]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:26.173]                       if (muffled) 
[11:03:26.173]                         invokeRestart("muffleMessage")
[11:03:26.173]                     }
[11:03:26.173]                     else if (inherits(cond, "warning")) {
[11:03:26.173]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:26.173]                       if (muffled) 
[11:03:26.173]                         invokeRestart("muffleWarning")
[11:03:26.173]                     }
[11:03:26.173]                     else if (inherits(cond, "condition")) {
[11:03:26.173]                       if (!is.null(pattern)) {
[11:03:26.173]                         computeRestarts <- base::computeRestarts
[11:03:26.173]                         grepl <- base::grepl
[11:03:26.173]                         restarts <- computeRestarts(cond)
[11:03:26.173]                         for (restart in restarts) {
[11:03:26.173]                           name <- restart$name
[11:03:26.173]                           if (is.null(name)) 
[11:03:26.173]                             next
[11:03:26.173]                           if (!grepl(pattern, name)) 
[11:03:26.173]                             next
[11:03:26.173]                           invokeRestart(restart)
[11:03:26.173]                           muffled <- TRUE
[11:03:26.173]                           break
[11:03:26.173]                         }
[11:03:26.173]                       }
[11:03:26.173]                     }
[11:03:26.173]                     invisible(muffled)
[11:03:26.173]                   }
[11:03:26.173]                   muffleCondition(cond)
[11:03:26.173]                 })
[11:03:26.173]             }))
[11:03:26.173]             future::FutureResult(value = ...future.value$value, 
[11:03:26.173]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.173]                   ...future.rng), globalenv = if (FALSE) 
[11:03:26.173]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:26.173]                     ...future.globalenv.names))
[11:03:26.173]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:26.173]         }, condition = base::local({
[11:03:26.173]             c <- base::c
[11:03:26.173]             inherits <- base::inherits
[11:03:26.173]             invokeRestart <- base::invokeRestart
[11:03:26.173]             length <- base::length
[11:03:26.173]             list <- base::list
[11:03:26.173]             seq.int <- base::seq.int
[11:03:26.173]             signalCondition <- base::signalCondition
[11:03:26.173]             sys.calls <- base::sys.calls
[11:03:26.173]             `[[` <- base::`[[`
[11:03:26.173]             `+` <- base::`+`
[11:03:26.173]             `<<-` <- base::`<<-`
[11:03:26.173]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:26.173]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:26.173]                   3L)]
[11:03:26.173]             }
[11:03:26.173]             function(cond) {
[11:03:26.173]                 is_error <- inherits(cond, "error")
[11:03:26.173]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:26.173]                   NULL)
[11:03:26.173]                 if (is_error) {
[11:03:26.173]                   sessionInformation <- function() {
[11:03:26.173]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:26.173]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:26.173]                       search = base::search(), system = base::Sys.info())
[11:03:26.173]                   }
[11:03:26.173]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.173]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:26.173]                     cond$call), session = sessionInformation(), 
[11:03:26.173]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:26.173]                   signalCondition(cond)
[11:03:26.173]                 }
[11:03:26.173]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:26.173]                 "immediateCondition"))) {
[11:03:26.173]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:26.173]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.173]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:26.173]                   if (TRUE && !signal) {
[11:03:26.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.173]                     {
[11:03:26.173]                       inherits <- base::inherits
[11:03:26.173]                       invokeRestart <- base::invokeRestart
[11:03:26.173]                       is.null <- base::is.null
[11:03:26.173]                       muffled <- FALSE
[11:03:26.173]                       if (inherits(cond, "message")) {
[11:03:26.173]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.173]                         if (muffled) 
[11:03:26.173]                           invokeRestart("muffleMessage")
[11:03:26.173]                       }
[11:03:26.173]                       else if (inherits(cond, "warning")) {
[11:03:26.173]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.173]                         if (muffled) 
[11:03:26.173]                           invokeRestart("muffleWarning")
[11:03:26.173]                       }
[11:03:26.173]                       else if (inherits(cond, "condition")) {
[11:03:26.173]                         if (!is.null(pattern)) {
[11:03:26.173]                           computeRestarts <- base::computeRestarts
[11:03:26.173]                           grepl <- base::grepl
[11:03:26.173]                           restarts <- computeRestarts(cond)
[11:03:26.173]                           for (restart in restarts) {
[11:03:26.173]                             name <- restart$name
[11:03:26.173]                             if (is.null(name)) 
[11:03:26.173]                               next
[11:03:26.173]                             if (!grepl(pattern, name)) 
[11:03:26.173]                               next
[11:03:26.173]                             invokeRestart(restart)
[11:03:26.173]                             muffled <- TRUE
[11:03:26.173]                             break
[11:03:26.173]                           }
[11:03:26.173]                         }
[11:03:26.173]                       }
[11:03:26.173]                       invisible(muffled)
[11:03:26.173]                     }
[11:03:26.173]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.173]                   }
[11:03:26.173]                 }
[11:03:26.173]                 else {
[11:03:26.173]                   if (TRUE) {
[11:03:26.173]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.173]                     {
[11:03:26.173]                       inherits <- base::inherits
[11:03:26.173]                       invokeRestart <- base::invokeRestart
[11:03:26.173]                       is.null <- base::is.null
[11:03:26.173]                       muffled <- FALSE
[11:03:26.173]                       if (inherits(cond, "message")) {
[11:03:26.173]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.173]                         if (muffled) 
[11:03:26.173]                           invokeRestart("muffleMessage")
[11:03:26.173]                       }
[11:03:26.173]                       else if (inherits(cond, "warning")) {
[11:03:26.173]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.173]                         if (muffled) 
[11:03:26.173]                           invokeRestart("muffleWarning")
[11:03:26.173]                       }
[11:03:26.173]                       else if (inherits(cond, "condition")) {
[11:03:26.173]                         if (!is.null(pattern)) {
[11:03:26.173]                           computeRestarts <- base::computeRestarts
[11:03:26.173]                           grepl <- base::grepl
[11:03:26.173]                           restarts <- computeRestarts(cond)
[11:03:26.173]                           for (restart in restarts) {
[11:03:26.173]                             name <- restart$name
[11:03:26.173]                             if (is.null(name)) 
[11:03:26.173]                               next
[11:03:26.173]                             if (!grepl(pattern, name)) 
[11:03:26.173]                               next
[11:03:26.173]                             invokeRestart(restart)
[11:03:26.173]                             muffled <- TRUE
[11:03:26.173]                             break
[11:03:26.173]                           }
[11:03:26.173]                         }
[11:03:26.173]                       }
[11:03:26.173]                       invisible(muffled)
[11:03:26.173]                     }
[11:03:26.173]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.173]                   }
[11:03:26.173]                 }
[11:03:26.173]             }
[11:03:26.173]         }))
[11:03:26.173]     }, error = function(ex) {
[11:03:26.173]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:26.173]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.173]                 ...future.rng), started = ...future.startTime, 
[11:03:26.173]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:26.173]             version = "1.8"), class = "FutureResult")
[11:03:26.173]     }, finally = {
[11:03:26.173]         if (!identical(...future.workdir, getwd())) 
[11:03:26.173]             setwd(...future.workdir)
[11:03:26.173]         {
[11:03:26.173]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:26.173]                 ...future.oldOptions$nwarnings <- NULL
[11:03:26.173]             }
[11:03:26.173]             base::options(...future.oldOptions)
[11:03:26.173]             if (.Platform$OS.type == "windows") {
[11:03:26.173]                 old_names <- names(...future.oldEnvVars)
[11:03:26.173]                 envs <- base::Sys.getenv()
[11:03:26.173]                 names <- names(envs)
[11:03:26.173]                 common <- intersect(names, old_names)
[11:03:26.173]                 added <- setdiff(names, old_names)
[11:03:26.173]                 removed <- setdiff(old_names, names)
[11:03:26.173]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:26.173]                   envs[common]]
[11:03:26.173]                 NAMES <- toupper(changed)
[11:03:26.173]                 args <- list()
[11:03:26.173]                 for (kk in seq_along(NAMES)) {
[11:03:26.173]                   name <- changed[[kk]]
[11:03:26.173]                   NAME <- NAMES[[kk]]
[11:03:26.173]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.173]                     next
[11:03:26.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.173]                 }
[11:03:26.173]                 NAMES <- toupper(added)
[11:03:26.173]                 for (kk in seq_along(NAMES)) {
[11:03:26.173]                   name <- added[[kk]]
[11:03:26.173]                   NAME <- NAMES[[kk]]
[11:03:26.173]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.173]                     next
[11:03:26.173]                   args[[name]] <- ""
[11:03:26.173]                 }
[11:03:26.173]                 NAMES <- toupper(removed)
[11:03:26.173]                 for (kk in seq_along(NAMES)) {
[11:03:26.173]                   name <- removed[[kk]]
[11:03:26.173]                   NAME <- NAMES[[kk]]
[11:03:26.173]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.173]                     next
[11:03:26.173]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.173]                 }
[11:03:26.173]                 if (length(args) > 0) 
[11:03:26.173]                   base::do.call(base::Sys.setenv, args = args)
[11:03:26.173]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:26.173]             }
[11:03:26.173]             else {
[11:03:26.173]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:26.173]             }
[11:03:26.173]             {
[11:03:26.173]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:26.173]                   0L) {
[11:03:26.173]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:26.173]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:26.173]                   base::options(opts)
[11:03:26.173]                 }
[11:03:26.173]                 {
[11:03:26.173]                   {
[11:03:26.173]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:26.173]                     NULL
[11:03:26.173]                   }
[11:03:26.173]                   options(future.plan = NULL)
[11:03:26.173]                   if (is.na(NA_character_)) 
[11:03:26.173]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.173]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:26.173]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:26.173]                     .init = FALSE)
[11:03:26.173]                 }
[11:03:26.173]             }
[11:03:26.173]         }
[11:03:26.173]     })
[11:03:26.173]     if (TRUE) {
[11:03:26.173]         base::sink(type = "output", split = FALSE)
[11:03:26.173]         if (FALSE) {
[11:03:26.173]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:26.173]         }
[11:03:26.173]         else {
[11:03:26.173]             ...future.result["stdout"] <- base::list(NULL)
[11:03:26.173]         }
[11:03:26.173]         base::close(...future.stdout)
[11:03:26.173]         ...future.stdout <- NULL
[11:03:26.173]     }
[11:03:26.173]     ...future.result$conditions <- ...future.conditions
[11:03:26.173]     ...future.result$finished <- base::Sys.time()
[11:03:26.173]     ...future.result
[11:03:26.173] }
[11:03:26.176] MultisessionFuture started
[11:03:26.177] - Launch lazy future ... done
[11:03:26.177] run() for ‘MultisessionFuture’ ... done
[11:03:26.177] result() for ClusterFuture ...
[11:03:26.177] receiveMessageFromWorker() for ClusterFuture ...
[11:03:26.177] - Validating connection of MultisessionFuture
[11:03:26.219] - received message: FutureResult
[11:03:26.219] - Received FutureResult
[11:03:26.219] - Erased future from FutureRegistry
[11:03:26.219] result() for ClusterFuture ...
[11:03:26.219] - result already collected: FutureResult
[11:03:26.219] result() for ClusterFuture ... done
[11:03:26.219] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:26.221] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-05-06 11:03:26"
 $ finished    : POSIXct[1:1], format: "2025-05-06 11:03:26"
 $ session_uuid: chr "4a4d31bd-51d3-cce6-5621-e37e8478d31d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "173ee284ba16"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 85052
  .. ..$ time  : POSIXct[1:1], format: "2025-05-06 11:03:25"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[11:03:26.228] result() for ClusterFuture ...
[11:03:26.228] - result already collected: FutureResult
[11:03:26.228] result() for ClusterFuture ... done
[11:03:26.228] result() for ClusterFuture ...
[11:03:26.229] - result already collected: FutureResult
[11:03:26.229] result() for ClusterFuture ... done
[11:03:26.229] getGlobalsAndPackages() ...
[11:03:26.229] Searching for globals...
[11:03:26.232] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:26.232] Searching for globals ... DONE
[11:03:26.232] Resolving globals: FALSE
[11:03:26.232] 
[11:03:26.232] - packages: [1] ‘utils’
[11:03:26.232] getGlobalsAndPackages() ... DONE
[11:03:26.233] run() for ‘Future’ ...
[11:03:26.233] - state: ‘created’
[11:03:26.233] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:03:26.246] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:26.246] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:03:26.246]   - Field: ‘node’
[11:03:26.247]   - Field: ‘label’
[11:03:26.247]   - Field: ‘local’
[11:03:26.247]   - Field: ‘owner’
[11:03:26.247]   - Field: ‘envir’
[11:03:26.247]   - Field: ‘workers’
[11:03:26.247]   - Field: ‘packages’
[11:03:26.247]   - Field: ‘gc’
[11:03:26.247]   - Field: ‘conditions’
[11:03:26.247]   - Field: ‘persistent’
[11:03:26.247]   - Field: ‘expr’
[11:03:26.247]   - Field: ‘uuid’
[11:03:26.247]   - Field: ‘seed’
[11:03:26.248]   - Field: ‘version’
[11:03:26.248]   - Field: ‘result’
[11:03:26.248]   - Field: ‘asynchronous’
[11:03:26.248]   - Field: ‘calls’
[11:03:26.248]   - Field: ‘globals’
[11:03:26.248]   - Field: ‘stdout’
[11:03:26.248]   - Field: ‘earlySignal’
[11:03:26.248]   - Field: ‘lazy’
[11:03:26.248]   - Field: ‘state’
[11:03:26.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:03:26.248] - Launch lazy future ...
[11:03:26.249] Packages needed by the future expression (n = 1): ‘utils’
[11:03:26.249] Packages needed by future strategies (n = 0): <none>
[11:03:26.249] {
[11:03:26.249]     {
[11:03:26.249]         {
[11:03:26.249]             ...future.startTime <- base::Sys.time()
[11:03:26.249]             {
[11:03:26.249]                 {
[11:03:26.249]                   {
[11:03:26.249]                     {
[11:03:26.249]                       {
[11:03:26.249]                         base::local({
[11:03:26.249]                           has_future <- base::requireNamespace("future", 
[11:03:26.249]                             quietly = TRUE)
[11:03:26.249]                           if (has_future) {
[11:03:26.249]                             ns <- base::getNamespace("future")
[11:03:26.249]                             version <- ns[[".package"]][["version"]]
[11:03:26.249]                             if (is.null(version)) 
[11:03:26.249]                               version <- utils::packageVersion("future")
[11:03:26.249]                           }
[11:03:26.249]                           else {
[11:03:26.249]                             version <- NULL
[11:03:26.249]                           }
[11:03:26.249]                           if (!has_future || version < "1.8.0") {
[11:03:26.249]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:26.249]                               "", base::R.version$version.string), 
[11:03:26.249]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:26.249]                                 base::R.version$platform, 8 * 
[11:03:26.249]                                   base::.Machine$sizeof.pointer), 
[11:03:26.249]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:26.249]                                 "release", "version")], collapse = " "), 
[11:03:26.249]                               hostname = base::Sys.info()[["nodename"]])
[11:03:26.249]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:26.249]                               info)
[11:03:26.249]                             info <- base::paste(info, collapse = "; ")
[11:03:26.249]                             if (!has_future) {
[11:03:26.249]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:26.249]                                 info)
[11:03:26.249]                             }
[11:03:26.249]                             else {
[11:03:26.249]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:26.249]                                 info, version)
[11:03:26.249]                             }
[11:03:26.249]                             base::stop(msg)
[11:03:26.249]                           }
[11:03:26.249]                         })
[11:03:26.249]                       }
[11:03:26.249]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:26.249]                       base::options(mc.cores = 1L)
[11:03:26.249]                     }
[11:03:26.249]                     base::local({
[11:03:26.249]                       for (pkg in "utils") {
[11:03:26.249]                         base::loadNamespace(pkg)
[11:03:26.249]                         base::library(pkg, character.only = TRUE)
[11:03:26.249]                       }
[11:03:26.249]                     })
[11:03:26.249]                   }
[11:03:26.249]                   ...future.strategy.old <- future::plan("list")
[11:03:26.249]                   options(future.plan = NULL)
[11:03:26.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:26.249]                 }
[11:03:26.249]                 ...future.workdir <- getwd()
[11:03:26.249]             }
[11:03:26.249]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:26.249]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:26.249]         }
[11:03:26.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:26.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:26.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:26.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:26.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:26.249]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:26.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:26.249]             base::names(...future.oldOptions))
[11:03:26.249]     }
[11:03:26.249]     if (FALSE) {
[11:03:26.249]     }
[11:03:26.249]     else {
[11:03:26.249]         if (FALSE) {
[11:03:26.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:26.249]                 open = "w")
[11:03:26.249]         }
[11:03:26.249]         else {
[11:03:26.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:26.249]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:26.249]         }
[11:03:26.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:26.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:26.249]             base::sink(type = "output", split = FALSE)
[11:03:26.249]             base::close(...future.stdout)
[11:03:26.249]         }, add = TRUE)
[11:03:26.249]     }
[11:03:26.249]     ...future.frame <- base::sys.nframe()
[11:03:26.249]     ...future.conditions <- base::list()
[11:03:26.249]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:26.249]     if (FALSE) {
[11:03:26.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:26.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:26.249]     }
[11:03:26.249]     ...future.result <- base::tryCatch({
[11:03:26.249]         base::withCallingHandlers({
[11:03:26.249]             ...future.value <- base::withVisible(base::local({
[11:03:26.249]                 ...future.makeSendCondition <- base::local({
[11:03:26.249]                   sendCondition <- NULL
[11:03:26.249]                   function(frame = 1L) {
[11:03:26.249]                     if (is.function(sendCondition)) 
[11:03:26.249]                       return(sendCondition)
[11:03:26.249]                     ns <- getNamespace("parallel")
[11:03:26.249]                     if (exists("sendData", mode = "function", 
[11:03:26.249]                       envir = ns)) {
[11:03:26.249]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:26.249]                         envir = ns)
[11:03:26.249]                       envir <- sys.frame(frame)
[11:03:26.249]                       master <- NULL
[11:03:26.249]                       while (!identical(envir, .GlobalEnv) && 
[11:03:26.249]                         !identical(envir, emptyenv())) {
[11:03:26.249]                         if (exists("master", mode = "list", envir = envir, 
[11:03:26.249]                           inherits = FALSE)) {
[11:03:26.249]                           master <- get("master", mode = "list", 
[11:03:26.249]                             envir = envir, inherits = FALSE)
[11:03:26.249]                           if (inherits(master, c("SOCKnode", 
[11:03:26.249]                             "SOCK0node"))) {
[11:03:26.249]                             sendCondition <<- function(cond) {
[11:03:26.249]                               data <- list(type = "VALUE", value = cond, 
[11:03:26.249]                                 success = TRUE)
[11:03:26.249]                               parallel_sendData(master, data)
[11:03:26.249]                             }
[11:03:26.249]                             return(sendCondition)
[11:03:26.249]                           }
[11:03:26.249]                         }
[11:03:26.249]                         frame <- frame + 1L
[11:03:26.249]                         envir <- sys.frame(frame)
[11:03:26.249]                       }
[11:03:26.249]                     }
[11:03:26.249]                     sendCondition <<- function(cond) NULL
[11:03:26.249]                   }
[11:03:26.249]                 })
[11:03:26.249]                 withCallingHandlers({
[11:03:26.249]                   {
[11:03:26.249]                     print(1:50)
[11:03:26.249]                     str(1:50)
[11:03:26.249]                     cat(letters, sep = "-")
[11:03:26.249]                     cat(1:6, collapse = "\n")
[11:03:26.249]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:26.249]                     42L
[11:03:26.249]                   }
[11:03:26.249]                 }, immediateCondition = function(cond) {
[11:03:26.249]                   sendCondition <- ...future.makeSendCondition()
[11:03:26.249]                   sendCondition(cond)
[11:03:26.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.249]                   {
[11:03:26.249]                     inherits <- base::inherits
[11:03:26.249]                     invokeRestart <- base::invokeRestart
[11:03:26.249]                     is.null <- base::is.null
[11:03:26.249]                     muffled <- FALSE
[11:03:26.249]                     if (inherits(cond, "message")) {
[11:03:26.249]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:26.249]                       if (muffled) 
[11:03:26.249]                         invokeRestart("muffleMessage")
[11:03:26.249]                     }
[11:03:26.249]                     else if (inherits(cond, "warning")) {
[11:03:26.249]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:26.249]                       if (muffled) 
[11:03:26.249]                         invokeRestart("muffleWarning")
[11:03:26.249]                     }
[11:03:26.249]                     else if (inherits(cond, "condition")) {
[11:03:26.249]                       if (!is.null(pattern)) {
[11:03:26.249]                         computeRestarts <- base::computeRestarts
[11:03:26.249]                         grepl <- base::grepl
[11:03:26.249]                         restarts <- computeRestarts(cond)
[11:03:26.249]                         for (restart in restarts) {
[11:03:26.249]                           name <- restart$name
[11:03:26.249]                           if (is.null(name)) 
[11:03:26.249]                             next
[11:03:26.249]                           if (!grepl(pattern, name)) 
[11:03:26.249]                             next
[11:03:26.249]                           invokeRestart(restart)
[11:03:26.249]                           muffled <- TRUE
[11:03:26.249]                           break
[11:03:26.249]                         }
[11:03:26.249]                       }
[11:03:26.249]                     }
[11:03:26.249]                     invisible(muffled)
[11:03:26.249]                   }
[11:03:26.249]                   muffleCondition(cond)
[11:03:26.249]                 })
[11:03:26.249]             }))
[11:03:26.249]             future::FutureResult(value = ...future.value$value, 
[11:03:26.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.249]                   ...future.rng), globalenv = if (FALSE) 
[11:03:26.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:26.249]                     ...future.globalenv.names))
[11:03:26.249]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:26.249]         }, condition = base::local({
[11:03:26.249]             c <- base::c
[11:03:26.249]             inherits <- base::inherits
[11:03:26.249]             invokeRestart <- base::invokeRestart
[11:03:26.249]             length <- base::length
[11:03:26.249]             list <- base::list
[11:03:26.249]             seq.int <- base::seq.int
[11:03:26.249]             signalCondition <- base::signalCondition
[11:03:26.249]             sys.calls <- base::sys.calls
[11:03:26.249]             `[[` <- base::`[[`
[11:03:26.249]             `+` <- base::`+`
[11:03:26.249]             `<<-` <- base::`<<-`
[11:03:26.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:26.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:26.249]                   3L)]
[11:03:26.249]             }
[11:03:26.249]             function(cond) {
[11:03:26.249]                 is_error <- inherits(cond, "error")
[11:03:26.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:26.249]                   NULL)
[11:03:26.249]                 if (is_error) {
[11:03:26.249]                   sessionInformation <- function() {
[11:03:26.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:26.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:26.249]                       search = base::search(), system = base::Sys.info())
[11:03:26.249]                   }
[11:03:26.249]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:26.249]                     cond$call), session = sessionInformation(), 
[11:03:26.249]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:26.249]                   signalCondition(cond)
[11:03:26.249]                 }
[11:03:26.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:26.249]                 "immediateCondition"))) {
[11:03:26.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:26.249]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:26.249]                   if (TRUE && !signal) {
[11:03:26.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.249]                     {
[11:03:26.249]                       inherits <- base::inherits
[11:03:26.249]                       invokeRestart <- base::invokeRestart
[11:03:26.249]                       is.null <- base::is.null
[11:03:26.249]                       muffled <- FALSE
[11:03:26.249]                       if (inherits(cond, "message")) {
[11:03:26.249]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.249]                         if (muffled) 
[11:03:26.249]                           invokeRestart("muffleMessage")
[11:03:26.249]                       }
[11:03:26.249]                       else if (inherits(cond, "warning")) {
[11:03:26.249]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.249]                         if (muffled) 
[11:03:26.249]                           invokeRestart("muffleWarning")
[11:03:26.249]                       }
[11:03:26.249]                       else if (inherits(cond, "condition")) {
[11:03:26.249]                         if (!is.null(pattern)) {
[11:03:26.249]                           computeRestarts <- base::computeRestarts
[11:03:26.249]                           grepl <- base::grepl
[11:03:26.249]                           restarts <- computeRestarts(cond)
[11:03:26.249]                           for (restart in restarts) {
[11:03:26.249]                             name <- restart$name
[11:03:26.249]                             if (is.null(name)) 
[11:03:26.249]                               next
[11:03:26.249]                             if (!grepl(pattern, name)) 
[11:03:26.249]                               next
[11:03:26.249]                             invokeRestart(restart)
[11:03:26.249]                             muffled <- TRUE
[11:03:26.249]                             break
[11:03:26.249]                           }
[11:03:26.249]                         }
[11:03:26.249]                       }
[11:03:26.249]                       invisible(muffled)
[11:03:26.249]                     }
[11:03:26.249]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.249]                   }
[11:03:26.249]                 }
[11:03:26.249]                 else {
[11:03:26.249]                   if (TRUE) {
[11:03:26.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.249]                     {
[11:03:26.249]                       inherits <- base::inherits
[11:03:26.249]                       invokeRestart <- base::invokeRestart
[11:03:26.249]                       is.null <- base::is.null
[11:03:26.249]                       muffled <- FALSE
[11:03:26.249]                       if (inherits(cond, "message")) {
[11:03:26.249]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.249]                         if (muffled) 
[11:03:26.249]                           invokeRestart("muffleMessage")
[11:03:26.249]                       }
[11:03:26.249]                       else if (inherits(cond, "warning")) {
[11:03:26.249]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.249]                         if (muffled) 
[11:03:26.249]                           invokeRestart("muffleWarning")
[11:03:26.249]                       }
[11:03:26.249]                       else if (inherits(cond, "condition")) {
[11:03:26.249]                         if (!is.null(pattern)) {
[11:03:26.249]                           computeRestarts <- base::computeRestarts
[11:03:26.249]                           grepl <- base::grepl
[11:03:26.249]                           restarts <- computeRestarts(cond)
[11:03:26.249]                           for (restart in restarts) {
[11:03:26.249]                             name <- restart$name
[11:03:26.249]                             if (is.null(name)) 
[11:03:26.249]                               next
[11:03:26.249]                             if (!grepl(pattern, name)) 
[11:03:26.249]                               next
[11:03:26.249]                             invokeRestart(restart)
[11:03:26.249]                             muffled <- TRUE
[11:03:26.249]                             break
[11:03:26.249]                           }
[11:03:26.249]                         }
[11:03:26.249]                       }
[11:03:26.249]                       invisible(muffled)
[11:03:26.249]                     }
[11:03:26.249]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.249]                   }
[11:03:26.249]                 }
[11:03:26.249]             }
[11:03:26.249]         }))
[11:03:26.249]     }, error = function(ex) {
[11:03:26.249]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:26.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.249]                 ...future.rng), started = ...future.startTime, 
[11:03:26.249]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:26.249]             version = "1.8"), class = "FutureResult")
[11:03:26.249]     }, finally = {
[11:03:26.249]         if (!identical(...future.workdir, getwd())) 
[11:03:26.249]             setwd(...future.workdir)
[11:03:26.249]         {
[11:03:26.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:26.249]                 ...future.oldOptions$nwarnings <- NULL
[11:03:26.249]             }
[11:03:26.249]             base::options(...future.oldOptions)
[11:03:26.249]             if (.Platform$OS.type == "windows") {
[11:03:26.249]                 old_names <- names(...future.oldEnvVars)
[11:03:26.249]                 envs <- base::Sys.getenv()
[11:03:26.249]                 names <- names(envs)
[11:03:26.249]                 common <- intersect(names, old_names)
[11:03:26.249]                 added <- setdiff(names, old_names)
[11:03:26.249]                 removed <- setdiff(old_names, names)
[11:03:26.249]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:26.249]                   envs[common]]
[11:03:26.249]                 NAMES <- toupper(changed)
[11:03:26.249]                 args <- list()
[11:03:26.249]                 for (kk in seq_along(NAMES)) {
[11:03:26.249]                   name <- changed[[kk]]
[11:03:26.249]                   NAME <- NAMES[[kk]]
[11:03:26.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.249]                     next
[11:03:26.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.249]                 }
[11:03:26.249]                 NAMES <- toupper(added)
[11:03:26.249]                 for (kk in seq_along(NAMES)) {
[11:03:26.249]                   name <- added[[kk]]
[11:03:26.249]                   NAME <- NAMES[[kk]]
[11:03:26.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.249]                     next
[11:03:26.249]                   args[[name]] <- ""
[11:03:26.249]                 }
[11:03:26.249]                 NAMES <- toupper(removed)
[11:03:26.249]                 for (kk in seq_along(NAMES)) {
[11:03:26.249]                   name <- removed[[kk]]
[11:03:26.249]                   NAME <- NAMES[[kk]]
[11:03:26.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.249]                     next
[11:03:26.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.249]                 }
[11:03:26.249]                 if (length(args) > 0) 
[11:03:26.249]                   base::do.call(base::Sys.setenv, args = args)
[11:03:26.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:26.249]             }
[11:03:26.249]             else {
[11:03:26.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:26.249]             }
[11:03:26.249]             {
[11:03:26.249]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:26.249]                   0L) {
[11:03:26.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:26.249]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:26.249]                   base::options(opts)
[11:03:26.249]                 }
[11:03:26.249]                 {
[11:03:26.249]                   {
[11:03:26.249]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:26.249]                     NULL
[11:03:26.249]                   }
[11:03:26.249]                   options(future.plan = NULL)
[11:03:26.249]                   if (is.na(NA_character_)) 
[11:03:26.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:26.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:26.249]                     .init = FALSE)
[11:03:26.249]                 }
[11:03:26.249]             }
[11:03:26.249]         }
[11:03:26.249]     })
[11:03:26.249]     if (TRUE) {
[11:03:26.249]         base::sink(type = "output", split = FALSE)
[11:03:26.249]         if (FALSE) {
[11:03:26.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:26.249]         }
[11:03:26.249]         else {
[11:03:26.249]             ...future.result["stdout"] <- base::list(NULL)
[11:03:26.249]         }
[11:03:26.249]         base::close(...future.stdout)
[11:03:26.249]         ...future.stdout <- NULL
[11:03:26.249]     }
[11:03:26.249]     ...future.result$conditions <- ...future.conditions
[11:03:26.249]     ...future.result$finished <- base::Sys.time()
[11:03:26.249]     ...future.result
[11:03:26.249] }
[11:03:26.252] MultisessionFuture started
[11:03:26.252] - Launch lazy future ... done
[11:03:26.252] run() for ‘MultisessionFuture’ ... done
[11:03:26.252] result() for ClusterFuture ...
[11:03:26.252] receiveMessageFromWorker() for ClusterFuture ...
[11:03:26.253] - Validating connection of MultisessionFuture
[11:03:26.295] - received message: FutureResult
[11:03:26.295] - Received FutureResult
[11:03:26.295] - Erased future from FutureRegistry
[11:03:26.295] result() for ClusterFuture ...
[11:03:26.295] - result already collected: FutureResult
[11:03:26.295] result() for ClusterFuture ... done
[11:03:26.295] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:26.295] result() for ClusterFuture ... done
[11:03:26.295] result() for ClusterFuture ...
[11:03:26.296] - result already collected: FutureResult
[11:03:26.296] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[11:03:26.296] getGlobalsAndPackages() ...
[11:03:26.296] Searching for globals...
[11:03:26.296] - globals found: [1] ‘print’
[11:03:26.296] Searching for globals ... DONE
[11:03:26.297] Resolving globals: FALSE
[11:03:26.297] 
[11:03:26.297] 
[11:03:26.297] getGlobalsAndPackages() ... DONE
[11:03:26.297] run() for ‘Future’ ...
[11:03:26.297] - state: ‘created’
[11:03:26.297] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:03:26.311] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:26.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:03:26.312]   - Field: ‘node’
[11:03:26.312]   - Field: ‘label’
[11:03:26.312]   - Field: ‘local’
[11:03:26.312]   - Field: ‘owner’
[11:03:26.312]   - Field: ‘envir’
[11:03:26.312]   - Field: ‘workers’
[11:03:26.312]   - Field: ‘packages’
[11:03:26.312]   - Field: ‘gc’
[11:03:26.312]   - Field: ‘conditions’
[11:03:26.312]   - Field: ‘persistent’
[11:03:26.313]   - Field: ‘expr’
[11:03:26.313]   - Field: ‘uuid’
[11:03:26.313]   - Field: ‘seed’
[11:03:26.313]   - Field: ‘version’
[11:03:26.313]   - Field: ‘result’
[11:03:26.313]   - Field: ‘asynchronous’
[11:03:26.313]   - Field: ‘calls’
[11:03:26.313]   - Field: ‘globals’
[11:03:26.313]   - Field: ‘stdout’
[11:03:26.313]   - Field: ‘earlySignal’
[11:03:26.313]   - Field: ‘lazy’
[11:03:26.313]   - Field: ‘state’
[11:03:26.314] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:03:26.314] - Launch lazy future ...
[11:03:26.314] Packages needed by the future expression (n = 0): <none>
[11:03:26.314] Packages needed by future strategies (n = 0): <none>
[11:03:26.314] {
[11:03:26.314]     {
[11:03:26.314]         {
[11:03:26.314]             ...future.startTime <- base::Sys.time()
[11:03:26.314]             {
[11:03:26.314]                 {
[11:03:26.314]                   {
[11:03:26.314]                     {
[11:03:26.314]                       base::local({
[11:03:26.314]                         has_future <- base::requireNamespace("future", 
[11:03:26.314]                           quietly = TRUE)
[11:03:26.314]                         if (has_future) {
[11:03:26.314]                           ns <- base::getNamespace("future")
[11:03:26.314]                           version <- ns[[".package"]][["version"]]
[11:03:26.314]                           if (is.null(version)) 
[11:03:26.314]                             version <- utils::packageVersion("future")
[11:03:26.314]                         }
[11:03:26.314]                         else {
[11:03:26.314]                           version <- NULL
[11:03:26.314]                         }
[11:03:26.314]                         if (!has_future || version < "1.8.0") {
[11:03:26.314]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:26.314]                             "", base::R.version$version.string), 
[11:03:26.314]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:26.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:26.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:26.314]                               "release", "version")], collapse = " "), 
[11:03:26.314]                             hostname = base::Sys.info()[["nodename"]])
[11:03:26.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:26.314]                             info)
[11:03:26.314]                           info <- base::paste(info, collapse = "; ")
[11:03:26.314]                           if (!has_future) {
[11:03:26.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:26.314]                               info)
[11:03:26.314]                           }
[11:03:26.314]                           else {
[11:03:26.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:26.314]                               info, version)
[11:03:26.314]                           }
[11:03:26.314]                           base::stop(msg)
[11:03:26.314]                         }
[11:03:26.314]                       })
[11:03:26.314]                     }
[11:03:26.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:26.314]                     base::options(mc.cores = 1L)
[11:03:26.314]                   }
[11:03:26.314]                   ...future.strategy.old <- future::plan("list")
[11:03:26.314]                   options(future.plan = NULL)
[11:03:26.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:26.314]                 }
[11:03:26.314]                 ...future.workdir <- getwd()
[11:03:26.314]             }
[11:03:26.314]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:26.314]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:26.314]         }
[11:03:26.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:26.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:26.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:26.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:26.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:26.314]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:26.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:26.314]             base::names(...future.oldOptions))
[11:03:26.314]     }
[11:03:26.314]     if (FALSE) {
[11:03:26.314]     }
[11:03:26.314]     else {
[11:03:26.314]         if (TRUE) {
[11:03:26.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:26.314]                 open = "w")
[11:03:26.314]         }
[11:03:26.314]         else {
[11:03:26.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:26.314]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:26.314]         }
[11:03:26.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:26.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:26.314]             base::sink(type = "output", split = FALSE)
[11:03:26.314]             base::close(...future.stdout)
[11:03:26.314]         }, add = TRUE)
[11:03:26.314]     }
[11:03:26.314]     ...future.frame <- base::sys.nframe()
[11:03:26.314]     ...future.conditions <- base::list()
[11:03:26.314]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:26.314]     if (FALSE) {
[11:03:26.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:26.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:26.314]     }
[11:03:26.314]     ...future.result <- base::tryCatch({
[11:03:26.314]         base::withCallingHandlers({
[11:03:26.314]             ...future.value <- base::withVisible(base::local({
[11:03:26.314]                 ...future.makeSendCondition <- base::local({
[11:03:26.314]                   sendCondition <- NULL
[11:03:26.314]                   function(frame = 1L) {
[11:03:26.314]                     if (is.function(sendCondition)) 
[11:03:26.314]                       return(sendCondition)
[11:03:26.314]                     ns <- getNamespace("parallel")
[11:03:26.314]                     if (exists("sendData", mode = "function", 
[11:03:26.314]                       envir = ns)) {
[11:03:26.314]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:26.314]                         envir = ns)
[11:03:26.314]                       envir <- sys.frame(frame)
[11:03:26.314]                       master <- NULL
[11:03:26.314]                       while (!identical(envir, .GlobalEnv) && 
[11:03:26.314]                         !identical(envir, emptyenv())) {
[11:03:26.314]                         if (exists("master", mode = "list", envir = envir, 
[11:03:26.314]                           inherits = FALSE)) {
[11:03:26.314]                           master <- get("master", mode = "list", 
[11:03:26.314]                             envir = envir, inherits = FALSE)
[11:03:26.314]                           if (inherits(master, c("SOCKnode", 
[11:03:26.314]                             "SOCK0node"))) {
[11:03:26.314]                             sendCondition <<- function(cond) {
[11:03:26.314]                               data <- list(type = "VALUE", value = cond, 
[11:03:26.314]                                 success = TRUE)
[11:03:26.314]                               parallel_sendData(master, data)
[11:03:26.314]                             }
[11:03:26.314]                             return(sendCondition)
[11:03:26.314]                           }
[11:03:26.314]                         }
[11:03:26.314]                         frame <- frame + 1L
[11:03:26.314]                         envir <- sys.frame(frame)
[11:03:26.314]                       }
[11:03:26.314]                     }
[11:03:26.314]                     sendCondition <<- function(cond) NULL
[11:03:26.314]                   }
[11:03:26.314]                 })
[11:03:26.314]                 withCallingHandlers({
[11:03:26.314]                   print(42)
[11:03:26.314]                 }, immediateCondition = function(cond) {
[11:03:26.314]                   sendCondition <- ...future.makeSendCondition()
[11:03:26.314]                   sendCondition(cond)
[11:03:26.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.314]                   {
[11:03:26.314]                     inherits <- base::inherits
[11:03:26.314]                     invokeRestart <- base::invokeRestart
[11:03:26.314]                     is.null <- base::is.null
[11:03:26.314]                     muffled <- FALSE
[11:03:26.314]                     if (inherits(cond, "message")) {
[11:03:26.314]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:26.314]                       if (muffled) 
[11:03:26.314]                         invokeRestart("muffleMessage")
[11:03:26.314]                     }
[11:03:26.314]                     else if (inherits(cond, "warning")) {
[11:03:26.314]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:26.314]                       if (muffled) 
[11:03:26.314]                         invokeRestart("muffleWarning")
[11:03:26.314]                     }
[11:03:26.314]                     else if (inherits(cond, "condition")) {
[11:03:26.314]                       if (!is.null(pattern)) {
[11:03:26.314]                         computeRestarts <- base::computeRestarts
[11:03:26.314]                         grepl <- base::grepl
[11:03:26.314]                         restarts <- computeRestarts(cond)
[11:03:26.314]                         for (restart in restarts) {
[11:03:26.314]                           name <- restart$name
[11:03:26.314]                           if (is.null(name)) 
[11:03:26.314]                             next
[11:03:26.314]                           if (!grepl(pattern, name)) 
[11:03:26.314]                             next
[11:03:26.314]                           invokeRestart(restart)
[11:03:26.314]                           muffled <- TRUE
[11:03:26.314]                           break
[11:03:26.314]                         }
[11:03:26.314]                       }
[11:03:26.314]                     }
[11:03:26.314]                     invisible(muffled)
[11:03:26.314]                   }
[11:03:26.314]                   muffleCondition(cond)
[11:03:26.314]                 })
[11:03:26.314]             }))
[11:03:26.314]             future::FutureResult(value = ...future.value$value, 
[11:03:26.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.314]                   ...future.rng), globalenv = if (FALSE) 
[11:03:26.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:26.314]                     ...future.globalenv.names))
[11:03:26.314]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:26.314]         }, condition = base::local({
[11:03:26.314]             c <- base::c
[11:03:26.314]             inherits <- base::inherits
[11:03:26.314]             invokeRestart <- base::invokeRestart
[11:03:26.314]             length <- base::length
[11:03:26.314]             list <- base::list
[11:03:26.314]             seq.int <- base::seq.int
[11:03:26.314]             signalCondition <- base::signalCondition
[11:03:26.314]             sys.calls <- base::sys.calls
[11:03:26.314]             `[[` <- base::`[[`
[11:03:26.314]             `+` <- base::`+`
[11:03:26.314]             `<<-` <- base::`<<-`
[11:03:26.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:26.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:26.314]                   3L)]
[11:03:26.314]             }
[11:03:26.314]             function(cond) {
[11:03:26.314]                 is_error <- inherits(cond, "error")
[11:03:26.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:26.314]                   NULL)
[11:03:26.314]                 if (is_error) {
[11:03:26.314]                   sessionInformation <- function() {
[11:03:26.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:26.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:26.314]                       search = base::search(), system = base::Sys.info())
[11:03:26.314]                   }
[11:03:26.314]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:26.314]                     cond$call), session = sessionInformation(), 
[11:03:26.314]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:26.314]                   signalCondition(cond)
[11:03:26.314]                 }
[11:03:26.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:26.314]                 "immediateCondition"))) {
[11:03:26.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:26.314]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:26.314]                   if (TRUE && !signal) {
[11:03:26.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.314]                     {
[11:03:26.314]                       inherits <- base::inherits
[11:03:26.314]                       invokeRestart <- base::invokeRestart
[11:03:26.314]                       is.null <- base::is.null
[11:03:26.314]                       muffled <- FALSE
[11:03:26.314]                       if (inherits(cond, "message")) {
[11:03:26.314]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.314]                         if (muffled) 
[11:03:26.314]                           invokeRestart("muffleMessage")
[11:03:26.314]                       }
[11:03:26.314]                       else if (inherits(cond, "warning")) {
[11:03:26.314]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.314]                         if (muffled) 
[11:03:26.314]                           invokeRestart("muffleWarning")
[11:03:26.314]                       }
[11:03:26.314]                       else if (inherits(cond, "condition")) {
[11:03:26.314]                         if (!is.null(pattern)) {
[11:03:26.314]                           computeRestarts <- base::computeRestarts
[11:03:26.314]                           grepl <- base::grepl
[11:03:26.314]                           restarts <- computeRestarts(cond)
[11:03:26.314]                           for (restart in restarts) {
[11:03:26.314]                             name <- restart$name
[11:03:26.314]                             if (is.null(name)) 
[11:03:26.314]                               next
[11:03:26.314]                             if (!grepl(pattern, name)) 
[11:03:26.314]                               next
[11:03:26.314]                             invokeRestart(restart)
[11:03:26.314]                             muffled <- TRUE
[11:03:26.314]                             break
[11:03:26.314]                           }
[11:03:26.314]                         }
[11:03:26.314]                       }
[11:03:26.314]                       invisible(muffled)
[11:03:26.314]                     }
[11:03:26.314]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.314]                   }
[11:03:26.314]                 }
[11:03:26.314]                 else {
[11:03:26.314]                   if (TRUE) {
[11:03:26.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.314]                     {
[11:03:26.314]                       inherits <- base::inherits
[11:03:26.314]                       invokeRestart <- base::invokeRestart
[11:03:26.314]                       is.null <- base::is.null
[11:03:26.314]                       muffled <- FALSE
[11:03:26.314]                       if (inherits(cond, "message")) {
[11:03:26.314]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.314]                         if (muffled) 
[11:03:26.314]                           invokeRestart("muffleMessage")
[11:03:26.314]                       }
[11:03:26.314]                       else if (inherits(cond, "warning")) {
[11:03:26.314]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.314]                         if (muffled) 
[11:03:26.314]                           invokeRestart("muffleWarning")
[11:03:26.314]                       }
[11:03:26.314]                       else if (inherits(cond, "condition")) {
[11:03:26.314]                         if (!is.null(pattern)) {
[11:03:26.314]                           computeRestarts <- base::computeRestarts
[11:03:26.314]                           grepl <- base::grepl
[11:03:26.314]                           restarts <- computeRestarts(cond)
[11:03:26.314]                           for (restart in restarts) {
[11:03:26.314]                             name <- restart$name
[11:03:26.314]                             if (is.null(name)) 
[11:03:26.314]                               next
[11:03:26.314]                             if (!grepl(pattern, name)) 
[11:03:26.314]                               next
[11:03:26.314]                             invokeRestart(restart)
[11:03:26.314]                             muffled <- TRUE
[11:03:26.314]                             break
[11:03:26.314]                           }
[11:03:26.314]                         }
[11:03:26.314]                       }
[11:03:26.314]                       invisible(muffled)
[11:03:26.314]                     }
[11:03:26.314]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.314]                   }
[11:03:26.314]                 }
[11:03:26.314]             }
[11:03:26.314]         }))
[11:03:26.314]     }, error = function(ex) {
[11:03:26.314]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:26.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.314]                 ...future.rng), started = ...future.startTime, 
[11:03:26.314]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:26.314]             version = "1.8"), class = "FutureResult")
[11:03:26.314]     }, finally = {
[11:03:26.314]         if (!identical(...future.workdir, getwd())) 
[11:03:26.314]             setwd(...future.workdir)
[11:03:26.314]         {
[11:03:26.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:26.314]                 ...future.oldOptions$nwarnings <- NULL
[11:03:26.314]             }
[11:03:26.314]             base::options(...future.oldOptions)
[11:03:26.314]             if (.Platform$OS.type == "windows") {
[11:03:26.314]                 old_names <- names(...future.oldEnvVars)
[11:03:26.314]                 envs <- base::Sys.getenv()
[11:03:26.314]                 names <- names(envs)
[11:03:26.314]                 common <- intersect(names, old_names)
[11:03:26.314]                 added <- setdiff(names, old_names)
[11:03:26.314]                 removed <- setdiff(old_names, names)
[11:03:26.314]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:26.314]                   envs[common]]
[11:03:26.314]                 NAMES <- toupper(changed)
[11:03:26.314]                 args <- list()
[11:03:26.314]                 for (kk in seq_along(NAMES)) {
[11:03:26.314]                   name <- changed[[kk]]
[11:03:26.314]                   NAME <- NAMES[[kk]]
[11:03:26.314]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.314]                     next
[11:03:26.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.314]                 }
[11:03:26.314]                 NAMES <- toupper(added)
[11:03:26.314]                 for (kk in seq_along(NAMES)) {
[11:03:26.314]                   name <- added[[kk]]
[11:03:26.314]                   NAME <- NAMES[[kk]]
[11:03:26.314]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.314]                     next
[11:03:26.314]                   args[[name]] <- ""
[11:03:26.314]                 }
[11:03:26.314]                 NAMES <- toupper(removed)
[11:03:26.314]                 for (kk in seq_along(NAMES)) {
[11:03:26.314]                   name <- removed[[kk]]
[11:03:26.314]                   NAME <- NAMES[[kk]]
[11:03:26.314]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.314]                     next
[11:03:26.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.314]                 }
[11:03:26.314]                 if (length(args) > 0) 
[11:03:26.314]                   base::do.call(base::Sys.setenv, args = args)
[11:03:26.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:26.314]             }
[11:03:26.314]             else {
[11:03:26.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:26.314]             }
[11:03:26.314]             {
[11:03:26.314]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:26.314]                   0L) {
[11:03:26.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:26.314]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:26.314]                   base::options(opts)
[11:03:26.314]                 }
[11:03:26.314]                 {
[11:03:26.314]                   {
[11:03:26.314]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:26.314]                     NULL
[11:03:26.314]                   }
[11:03:26.314]                   options(future.plan = NULL)
[11:03:26.314]                   if (is.na(NA_character_)) 
[11:03:26.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:26.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:26.314]                     .init = FALSE)
[11:03:26.314]                 }
[11:03:26.314]             }
[11:03:26.314]         }
[11:03:26.314]     })
[11:03:26.314]     if (TRUE) {
[11:03:26.314]         base::sink(type = "output", split = FALSE)
[11:03:26.314]         if (TRUE) {
[11:03:26.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:26.314]         }
[11:03:26.314]         else {
[11:03:26.314]             ...future.result["stdout"] <- base::list(NULL)
[11:03:26.314]         }
[11:03:26.314]         base::close(...future.stdout)
[11:03:26.314]         ...future.stdout <- NULL
[11:03:26.314]     }
[11:03:26.314]     ...future.result$conditions <- ...future.conditions
[11:03:26.314]     ...future.result$finished <- base::Sys.time()
[11:03:26.314]     ...future.result
[11:03:26.314] }
[11:03:26.317] MultisessionFuture started
[11:03:26.317] - Launch lazy future ... done
[11:03:26.317] run() for ‘MultisessionFuture’ ... done
[11:03:26.318] result() for ClusterFuture ...
[11:03:26.318] receiveMessageFromWorker() for ClusterFuture ...
[11:03:26.318] - Validating connection of MultisessionFuture
[11:03:26.359] - received message: FutureResult
[11:03:26.359] - Received FutureResult
[11:03:26.359] - Erased future from FutureRegistry
[11:03:26.359] result() for ClusterFuture ...
[11:03:26.359] - result already collected: FutureResult
[11:03:26.359] result() for ClusterFuture ... done
[11:03:26.359] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:26.360] result() for ClusterFuture ... done
[11:03:26.360] result() for ClusterFuture ...
[11:03:26.360] - result already collected: FutureResult
[11:03:26.360] result() for ClusterFuture ... done
[11:03:26.360] result() for ClusterFuture ...
[11:03:26.360] - result already collected: FutureResult
[11:03:26.360] result() for ClusterFuture ... done
[1] 42
[11:03:26.360] result() for ClusterFuture ...
[11:03:26.360] - result already collected: FutureResult
[11:03:26.360] result() for ClusterFuture ... done
- stdout = NA
[11:03:26.360] getGlobalsAndPackages() ...
[11:03:26.361] Searching for globals...
[11:03:26.363] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:26.363] Searching for globals ... DONE
[11:03:26.364] Resolving globals: FALSE
[11:03:26.364] 
[11:03:26.364] - packages: [1] ‘utils’
[11:03:26.364] getGlobalsAndPackages() ... DONE
[11:03:26.364] run() for ‘Future’ ...
[11:03:26.364] - state: ‘created’
[11:03:26.365] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:03:26.378] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:26.378] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:03:26.378]   - Field: ‘node’
[11:03:26.378]   - Field: ‘label’
[11:03:26.379]   - Field: ‘local’
[11:03:26.379]   - Field: ‘owner’
[11:03:26.379]   - Field: ‘envir’
[11:03:26.379]   - Field: ‘workers’
[11:03:26.379]   - Field: ‘packages’
[11:03:26.379]   - Field: ‘gc’
[11:03:26.379]   - Field: ‘conditions’
[11:03:26.379]   - Field: ‘persistent’
[11:03:26.379]   - Field: ‘expr’
[11:03:26.379]   - Field: ‘uuid’
[11:03:26.379]   - Field: ‘seed’
[11:03:26.379]   - Field: ‘version’
[11:03:26.380]   - Field: ‘result’
[11:03:26.380]   - Field: ‘asynchronous’
[11:03:26.380]   - Field: ‘calls’
[11:03:26.380]   - Field: ‘globals’
[11:03:26.380]   - Field: ‘stdout’
[11:03:26.380]   - Field: ‘earlySignal’
[11:03:26.380]   - Field: ‘lazy’
[11:03:26.380]   - Field: ‘state’
[11:03:26.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:03:26.380] - Launch lazy future ...
[11:03:26.381] Packages needed by the future expression (n = 1): ‘utils’
[11:03:26.381] Packages needed by future strategies (n = 0): <none>
[11:03:26.381] {
[11:03:26.381]     {
[11:03:26.381]         {
[11:03:26.381]             ...future.startTime <- base::Sys.time()
[11:03:26.381]             {
[11:03:26.381]                 {
[11:03:26.381]                   {
[11:03:26.381]                     {
[11:03:26.381]                       {
[11:03:26.381]                         base::local({
[11:03:26.381]                           has_future <- base::requireNamespace("future", 
[11:03:26.381]                             quietly = TRUE)
[11:03:26.381]                           if (has_future) {
[11:03:26.381]                             ns <- base::getNamespace("future")
[11:03:26.381]                             version <- ns[[".package"]][["version"]]
[11:03:26.381]                             if (is.null(version)) 
[11:03:26.381]                               version <- utils::packageVersion("future")
[11:03:26.381]                           }
[11:03:26.381]                           else {
[11:03:26.381]                             version <- NULL
[11:03:26.381]                           }
[11:03:26.381]                           if (!has_future || version < "1.8.0") {
[11:03:26.381]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:26.381]                               "", base::R.version$version.string), 
[11:03:26.381]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:26.381]                                 base::R.version$platform, 8 * 
[11:03:26.381]                                   base::.Machine$sizeof.pointer), 
[11:03:26.381]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:26.381]                                 "release", "version")], collapse = " "), 
[11:03:26.381]                               hostname = base::Sys.info()[["nodename"]])
[11:03:26.381]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:26.381]                               info)
[11:03:26.381]                             info <- base::paste(info, collapse = "; ")
[11:03:26.381]                             if (!has_future) {
[11:03:26.381]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:26.381]                                 info)
[11:03:26.381]                             }
[11:03:26.381]                             else {
[11:03:26.381]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:26.381]                                 info, version)
[11:03:26.381]                             }
[11:03:26.381]                             base::stop(msg)
[11:03:26.381]                           }
[11:03:26.381]                         })
[11:03:26.381]                       }
[11:03:26.381]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:26.381]                       base::options(mc.cores = 1L)
[11:03:26.381]                     }
[11:03:26.381]                     base::local({
[11:03:26.381]                       for (pkg in "utils") {
[11:03:26.381]                         base::loadNamespace(pkg)
[11:03:26.381]                         base::library(pkg, character.only = TRUE)
[11:03:26.381]                       }
[11:03:26.381]                     })
[11:03:26.381]                   }
[11:03:26.381]                   ...future.strategy.old <- future::plan("list")
[11:03:26.381]                   options(future.plan = NULL)
[11:03:26.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:26.381]                 }
[11:03:26.381]                 ...future.workdir <- getwd()
[11:03:26.381]             }
[11:03:26.381]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:26.381]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:26.381]         }
[11:03:26.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:26.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:26.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:26.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:26.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:26.381]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:26.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:26.381]             base::names(...future.oldOptions))
[11:03:26.381]     }
[11:03:26.381]     if (TRUE) {
[11:03:26.381]     }
[11:03:26.381]     else {
[11:03:26.381]         if (NA) {
[11:03:26.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:26.381]                 open = "w")
[11:03:26.381]         }
[11:03:26.381]         else {
[11:03:26.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:26.381]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:26.381]         }
[11:03:26.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:26.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:26.381]             base::sink(type = "output", split = FALSE)
[11:03:26.381]             base::close(...future.stdout)
[11:03:26.381]         }, add = TRUE)
[11:03:26.381]     }
[11:03:26.381]     ...future.frame <- base::sys.nframe()
[11:03:26.381]     ...future.conditions <- base::list()
[11:03:26.381]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:26.381]     if (FALSE) {
[11:03:26.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:26.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:26.381]     }
[11:03:26.381]     ...future.result <- base::tryCatch({
[11:03:26.381]         base::withCallingHandlers({
[11:03:26.381]             ...future.value <- base::withVisible(base::local({
[11:03:26.381]                 ...future.makeSendCondition <- base::local({
[11:03:26.381]                   sendCondition <- NULL
[11:03:26.381]                   function(frame = 1L) {
[11:03:26.381]                     if (is.function(sendCondition)) 
[11:03:26.381]                       return(sendCondition)
[11:03:26.381]                     ns <- getNamespace("parallel")
[11:03:26.381]                     if (exists("sendData", mode = "function", 
[11:03:26.381]                       envir = ns)) {
[11:03:26.381]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:26.381]                         envir = ns)
[11:03:26.381]                       envir <- sys.frame(frame)
[11:03:26.381]                       master <- NULL
[11:03:26.381]                       while (!identical(envir, .GlobalEnv) && 
[11:03:26.381]                         !identical(envir, emptyenv())) {
[11:03:26.381]                         if (exists("master", mode = "list", envir = envir, 
[11:03:26.381]                           inherits = FALSE)) {
[11:03:26.381]                           master <- get("master", mode = "list", 
[11:03:26.381]                             envir = envir, inherits = FALSE)
[11:03:26.381]                           if (inherits(master, c("SOCKnode", 
[11:03:26.381]                             "SOCK0node"))) {
[11:03:26.381]                             sendCondition <<- function(cond) {
[11:03:26.381]                               data <- list(type = "VALUE", value = cond, 
[11:03:26.381]                                 success = TRUE)
[11:03:26.381]                               parallel_sendData(master, data)
[11:03:26.381]                             }
[11:03:26.381]                             return(sendCondition)
[11:03:26.381]                           }
[11:03:26.381]                         }
[11:03:26.381]                         frame <- frame + 1L
[11:03:26.381]                         envir <- sys.frame(frame)
[11:03:26.381]                       }
[11:03:26.381]                     }
[11:03:26.381]                     sendCondition <<- function(cond) NULL
[11:03:26.381]                   }
[11:03:26.381]                 })
[11:03:26.381]                 withCallingHandlers({
[11:03:26.381]                   {
[11:03:26.381]                     print(1:50)
[11:03:26.381]                     str(1:50)
[11:03:26.381]                     cat(letters, sep = "-")
[11:03:26.381]                     cat(1:6, collapse = "\n")
[11:03:26.381]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:26.381]                     42L
[11:03:26.381]                   }
[11:03:26.381]                 }, immediateCondition = function(cond) {
[11:03:26.381]                   sendCondition <- ...future.makeSendCondition()
[11:03:26.381]                   sendCondition(cond)
[11:03:26.381]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.381]                   {
[11:03:26.381]                     inherits <- base::inherits
[11:03:26.381]                     invokeRestart <- base::invokeRestart
[11:03:26.381]                     is.null <- base::is.null
[11:03:26.381]                     muffled <- FALSE
[11:03:26.381]                     if (inherits(cond, "message")) {
[11:03:26.381]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:26.381]                       if (muffled) 
[11:03:26.381]                         invokeRestart("muffleMessage")
[11:03:26.381]                     }
[11:03:26.381]                     else if (inherits(cond, "warning")) {
[11:03:26.381]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:26.381]                       if (muffled) 
[11:03:26.381]                         invokeRestart("muffleWarning")
[11:03:26.381]                     }
[11:03:26.381]                     else if (inherits(cond, "condition")) {
[11:03:26.381]                       if (!is.null(pattern)) {
[11:03:26.381]                         computeRestarts <- base::computeRestarts
[11:03:26.381]                         grepl <- base::grepl
[11:03:26.381]                         restarts <- computeRestarts(cond)
[11:03:26.381]                         for (restart in restarts) {
[11:03:26.381]                           name <- restart$name
[11:03:26.381]                           if (is.null(name)) 
[11:03:26.381]                             next
[11:03:26.381]                           if (!grepl(pattern, name)) 
[11:03:26.381]                             next
[11:03:26.381]                           invokeRestart(restart)
[11:03:26.381]                           muffled <- TRUE
[11:03:26.381]                           break
[11:03:26.381]                         }
[11:03:26.381]                       }
[11:03:26.381]                     }
[11:03:26.381]                     invisible(muffled)
[11:03:26.381]                   }
[11:03:26.381]                   muffleCondition(cond)
[11:03:26.381]                 })
[11:03:26.381]             }))
[11:03:26.381]             future::FutureResult(value = ...future.value$value, 
[11:03:26.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.381]                   ...future.rng), globalenv = if (FALSE) 
[11:03:26.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:26.381]                     ...future.globalenv.names))
[11:03:26.381]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:26.381]         }, condition = base::local({
[11:03:26.381]             c <- base::c
[11:03:26.381]             inherits <- base::inherits
[11:03:26.381]             invokeRestart <- base::invokeRestart
[11:03:26.381]             length <- base::length
[11:03:26.381]             list <- base::list
[11:03:26.381]             seq.int <- base::seq.int
[11:03:26.381]             signalCondition <- base::signalCondition
[11:03:26.381]             sys.calls <- base::sys.calls
[11:03:26.381]             `[[` <- base::`[[`
[11:03:26.381]             `+` <- base::`+`
[11:03:26.381]             `<<-` <- base::`<<-`
[11:03:26.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:26.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:26.381]                   3L)]
[11:03:26.381]             }
[11:03:26.381]             function(cond) {
[11:03:26.381]                 is_error <- inherits(cond, "error")
[11:03:26.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:26.381]                   NULL)
[11:03:26.381]                 if (is_error) {
[11:03:26.381]                   sessionInformation <- function() {
[11:03:26.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:26.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:26.381]                       search = base::search(), system = base::Sys.info())
[11:03:26.381]                   }
[11:03:26.381]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:26.381]                     cond$call), session = sessionInformation(), 
[11:03:26.381]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:26.381]                   signalCondition(cond)
[11:03:26.381]                 }
[11:03:26.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:26.381]                 "immediateCondition"))) {
[11:03:26.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:26.381]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:26.381]                   if (TRUE && !signal) {
[11:03:26.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.381]                     {
[11:03:26.381]                       inherits <- base::inherits
[11:03:26.381]                       invokeRestart <- base::invokeRestart
[11:03:26.381]                       is.null <- base::is.null
[11:03:26.381]                       muffled <- FALSE
[11:03:26.381]                       if (inherits(cond, "message")) {
[11:03:26.381]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.381]                         if (muffled) 
[11:03:26.381]                           invokeRestart("muffleMessage")
[11:03:26.381]                       }
[11:03:26.381]                       else if (inherits(cond, "warning")) {
[11:03:26.381]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.381]                         if (muffled) 
[11:03:26.381]                           invokeRestart("muffleWarning")
[11:03:26.381]                       }
[11:03:26.381]                       else if (inherits(cond, "condition")) {
[11:03:26.381]                         if (!is.null(pattern)) {
[11:03:26.381]                           computeRestarts <- base::computeRestarts
[11:03:26.381]                           grepl <- base::grepl
[11:03:26.381]                           restarts <- computeRestarts(cond)
[11:03:26.381]                           for (restart in restarts) {
[11:03:26.381]                             name <- restart$name
[11:03:26.381]                             if (is.null(name)) 
[11:03:26.381]                               next
[11:03:26.381]                             if (!grepl(pattern, name)) 
[11:03:26.381]                               next
[11:03:26.381]                             invokeRestart(restart)
[11:03:26.381]                             muffled <- TRUE
[11:03:26.381]                             break
[11:03:26.381]                           }
[11:03:26.381]                         }
[11:03:26.381]                       }
[11:03:26.381]                       invisible(muffled)
[11:03:26.381]                     }
[11:03:26.381]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.381]                   }
[11:03:26.381]                 }
[11:03:26.381]                 else {
[11:03:26.381]                   if (TRUE) {
[11:03:26.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.381]                     {
[11:03:26.381]                       inherits <- base::inherits
[11:03:26.381]                       invokeRestart <- base::invokeRestart
[11:03:26.381]                       is.null <- base::is.null
[11:03:26.381]                       muffled <- FALSE
[11:03:26.381]                       if (inherits(cond, "message")) {
[11:03:26.381]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.381]                         if (muffled) 
[11:03:26.381]                           invokeRestart("muffleMessage")
[11:03:26.381]                       }
[11:03:26.381]                       else if (inherits(cond, "warning")) {
[11:03:26.381]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.381]                         if (muffled) 
[11:03:26.381]                           invokeRestart("muffleWarning")
[11:03:26.381]                       }
[11:03:26.381]                       else if (inherits(cond, "condition")) {
[11:03:26.381]                         if (!is.null(pattern)) {
[11:03:26.381]                           computeRestarts <- base::computeRestarts
[11:03:26.381]                           grepl <- base::grepl
[11:03:26.381]                           restarts <- computeRestarts(cond)
[11:03:26.381]                           for (restart in restarts) {
[11:03:26.381]                             name <- restart$name
[11:03:26.381]                             if (is.null(name)) 
[11:03:26.381]                               next
[11:03:26.381]                             if (!grepl(pattern, name)) 
[11:03:26.381]                               next
[11:03:26.381]                             invokeRestart(restart)
[11:03:26.381]                             muffled <- TRUE
[11:03:26.381]                             break
[11:03:26.381]                           }
[11:03:26.381]                         }
[11:03:26.381]                       }
[11:03:26.381]                       invisible(muffled)
[11:03:26.381]                     }
[11:03:26.381]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.381]                   }
[11:03:26.381]                 }
[11:03:26.381]             }
[11:03:26.381]         }))
[11:03:26.381]     }, error = function(ex) {
[11:03:26.381]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:26.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.381]                 ...future.rng), started = ...future.startTime, 
[11:03:26.381]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:26.381]             version = "1.8"), class = "FutureResult")
[11:03:26.381]     }, finally = {
[11:03:26.381]         if (!identical(...future.workdir, getwd())) 
[11:03:26.381]             setwd(...future.workdir)
[11:03:26.381]         {
[11:03:26.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:26.381]                 ...future.oldOptions$nwarnings <- NULL
[11:03:26.381]             }
[11:03:26.381]             base::options(...future.oldOptions)
[11:03:26.381]             if (.Platform$OS.type == "windows") {
[11:03:26.381]                 old_names <- names(...future.oldEnvVars)
[11:03:26.381]                 envs <- base::Sys.getenv()
[11:03:26.381]                 names <- names(envs)
[11:03:26.381]                 common <- intersect(names, old_names)
[11:03:26.381]                 added <- setdiff(names, old_names)
[11:03:26.381]                 removed <- setdiff(old_names, names)
[11:03:26.381]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:26.381]                   envs[common]]
[11:03:26.381]                 NAMES <- toupper(changed)
[11:03:26.381]                 args <- list()
[11:03:26.381]                 for (kk in seq_along(NAMES)) {
[11:03:26.381]                   name <- changed[[kk]]
[11:03:26.381]                   NAME <- NAMES[[kk]]
[11:03:26.381]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.381]                     next
[11:03:26.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.381]                 }
[11:03:26.381]                 NAMES <- toupper(added)
[11:03:26.381]                 for (kk in seq_along(NAMES)) {
[11:03:26.381]                   name <- added[[kk]]
[11:03:26.381]                   NAME <- NAMES[[kk]]
[11:03:26.381]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.381]                     next
[11:03:26.381]                   args[[name]] <- ""
[11:03:26.381]                 }
[11:03:26.381]                 NAMES <- toupper(removed)
[11:03:26.381]                 for (kk in seq_along(NAMES)) {
[11:03:26.381]                   name <- removed[[kk]]
[11:03:26.381]                   NAME <- NAMES[[kk]]
[11:03:26.381]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.381]                     next
[11:03:26.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.381]                 }
[11:03:26.381]                 if (length(args) > 0) 
[11:03:26.381]                   base::do.call(base::Sys.setenv, args = args)
[11:03:26.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:26.381]             }
[11:03:26.381]             else {
[11:03:26.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:26.381]             }
[11:03:26.381]             {
[11:03:26.381]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:26.381]                   0L) {
[11:03:26.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:26.381]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:26.381]                   base::options(opts)
[11:03:26.381]                 }
[11:03:26.381]                 {
[11:03:26.381]                   {
[11:03:26.381]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:26.381]                     NULL
[11:03:26.381]                   }
[11:03:26.381]                   options(future.plan = NULL)
[11:03:26.381]                   if (is.na(NA_character_)) 
[11:03:26.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:26.381]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:26.381]                     .init = FALSE)
[11:03:26.381]                 }
[11:03:26.381]             }
[11:03:26.381]         }
[11:03:26.381]     })
[11:03:26.381]     if (FALSE) {
[11:03:26.381]         base::sink(type = "output", split = FALSE)
[11:03:26.381]         if (NA) {
[11:03:26.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:26.381]         }
[11:03:26.381]         else {
[11:03:26.381]             ...future.result["stdout"] <- base::list(NULL)
[11:03:26.381]         }
[11:03:26.381]         base::close(...future.stdout)
[11:03:26.381]         ...future.stdout <- NULL
[11:03:26.381]     }
[11:03:26.381]     ...future.result$conditions <- ...future.conditions
[11:03:26.381]     ...future.result$finished <- base::Sys.time()
[11:03:26.381]     ...future.result
[11:03:26.381] }
[11:03:26.384] MultisessionFuture started
[11:03:26.384] - Launch lazy future ... done
[11:03:26.384] run() for ‘MultisessionFuture’ ... done
[11:03:26.384] result() for ClusterFuture ...
[11:03:26.384] receiveMessageFromWorker() for ClusterFuture ...
[11:03:26.384] - Validating connection of MultisessionFuture
[11:03:26.427] - received message: FutureResult
[11:03:26.427] - Received FutureResult
[11:03:26.427] - Erased future from FutureRegistry
[11:03:26.427] result() for ClusterFuture ...
[11:03:26.427] - result already collected: FutureResult
[11:03:26.427] result() for ClusterFuture ... done
[11:03:26.427] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:26.427] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-05-06 11:03:26"
 $ finished    : POSIXct[1:1], format: "2025-05-06 11:03:26"
 $ session_uuid: chr "4a4d31bd-51d3-cce6-5621-e37e8478d31d"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "173ee284ba16"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 85052
  .. ..$ time  : POSIXct[1:1], format: "2025-05-06 11:03:25"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[11:03:26.434] result() for ClusterFuture ...
[11:03:26.435] - result already collected: FutureResult
[11:03:26.435] result() for ClusterFuture ... done
[11:03:26.435] result() for ClusterFuture ...
[11:03:26.435] - result already collected: FutureResult
[11:03:26.435] result() for ClusterFuture ... done
[11:03:26.435] getGlobalsAndPackages() ...
[11:03:26.435] Searching for globals...
[11:03:26.438] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[11:03:26.438] Searching for globals ... DONE
[11:03:26.438] Resolving globals: FALSE
[11:03:26.439] 
[11:03:26.439] - packages: [1] ‘utils’
[11:03:26.439] getGlobalsAndPackages() ... DONE
[11:03:26.439] run() for ‘Future’ ...
[11:03:26.439] - state: ‘created’
[11:03:26.439] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:03:26.453] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:26.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:03:26.453]   - Field: ‘node’
[11:03:26.453]   - Field: ‘label’
[11:03:26.453]   - Field: ‘local’
[11:03:26.453]   - Field: ‘owner’
[11:03:26.453]   - Field: ‘envir’
[11:03:26.453]   - Field: ‘workers’
[11:03:26.453]   - Field: ‘packages’
[11:03:26.453]   - Field: ‘gc’
[11:03:26.454]   - Field: ‘conditions’
[11:03:26.454]   - Field: ‘persistent’
[11:03:26.454]   - Field: ‘expr’
[11:03:26.454]   - Field: ‘uuid’
[11:03:26.454]   - Field: ‘seed’
[11:03:26.454]   - Field: ‘version’
[11:03:26.454]   - Field: ‘result’
[11:03:26.454]   - Field: ‘asynchronous’
[11:03:26.454]   - Field: ‘calls’
[11:03:26.454]   - Field: ‘globals’
[11:03:26.454]   - Field: ‘stdout’
[11:03:26.454]   - Field: ‘earlySignal’
[11:03:26.455]   - Field: ‘lazy’
[11:03:26.455]   - Field: ‘state’
[11:03:26.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:03:26.455] - Launch lazy future ...
[11:03:26.455] Packages needed by the future expression (n = 1): ‘utils’
[11:03:26.455] Packages needed by future strategies (n = 0): <none>
[11:03:26.456] {
[11:03:26.456]     {
[11:03:26.456]         {
[11:03:26.456]             ...future.startTime <- base::Sys.time()
[11:03:26.456]             {
[11:03:26.456]                 {
[11:03:26.456]                   {
[11:03:26.456]                     {
[11:03:26.456]                       {
[11:03:26.456]                         base::local({
[11:03:26.456]                           has_future <- base::requireNamespace("future", 
[11:03:26.456]                             quietly = TRUE)
[11:03:26.456]                           if (has_future) {
[11:03:26.456]                             ns <- base::getNamespace("future")
[11:03:26.456]                             version <- ns[[".package"]][["version"]]
[11:03:26.456]                             if (is.null(version)) 
[11:03:26.456]                               version <- utils::packageVersion("future")
[11:03:26.456]                           }
[11:03:26.456]                           else {
[11:03:26.456]                             version <- NULL
[11:03:26.456]                           }
[11:03:26.456]                           if (!has_future || version < "1.8.0") {
[11:03:26.456]                             info <- base::c(r_version = base::gsub("R version ", 
[11:03:26.456]                               "", base::R.version$version.string), 
[11:03:26.456]                               platform = base::sprintf("%s (%s-bit)", 
[11:03:26.456]                                 base::R.version$platform, 8 * 
[11:03:26.456]                                   base::.Machine$sizeof.pointer), 
[11:03:26.456]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:26.456]                                 "release", "version")], collapse = " "), 
[11:03:26.456]                               hostname = base::Sys.info()[["nodename"]])
[11:03:26.456]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:03:26.456]                               info)
[11:03:26.456]                             info <- base::paste(info, collapse = "; ")
[11:03:26.456]                             if (!has_future) {
[11:03:26.456]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:26.456]                                 info)
[11:03:26.456]                             }
[11:03:26.456]                             else {
[11:03:26.456]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:26.456]                                 info, version)
[11:03:26.456]                             }
[11:03:26.456]                             base::stop(msg)
[11:03:26.456]                           }
[11:03:26.456]                         })
[11:03:26.456]                       }
[11:03:26.456]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:26.456]                       base::options(mc.cores = 1L)
[11:03:26.456]                     }
[11:03:26.456]                     base::local({
[11:03:26.456]                       for (pkg in "utils") {
[11:03:26.456]                         base::loadNamespace(pkg)
[11:03:26.456]                         base::library(pkg, character.only = TRUE)
[11:03:26.456]                       }
[11:03:26.456]                     })
[11:03:26.456]                   }
[11:03:26.456]                   ...future.strategy.old <- future::plan("list")
[11:03:26.456]                   options(future.plan = NULL)
[11:03:26.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:26.456]                 }
[11:03:26.456]                 ...future.workdir <- getwd()
[11:03:26.456]             }
[11:03:26.456]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:26.456]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:26.456]         }
[11:03:26.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:26.456]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:26.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:26.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:26.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:26.456]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:26.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:26.456]             base::names(...future.oldOptions))
[11:03:26.456]     }
[11:03:26.456]     if (TRUE) {
[11:03:26.456]     }
[11:03:26.456]     else {
[11:03:26.456]         if (NA) {
[11:03:26.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:26.456]                 open = "w")
[11:03:26.456]         }
[11:03:26.456]         else {
[11:03:26.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:26.456]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:26.456]         }
[11:03:26.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:26.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:26.456]             base::sink(type = "output", split = FALSE)
[11:03:26.456]             base::close(...future.stdout)
[11:03:26.456]         }, add = TRUE)
[11:03:26.456]     }
[11:03:26.456]     ...future.frame <- base::sys.nframe()
[11:03:26.456]     ...future.conditions <- base::list()
[11:03:26.456]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:26.456]     if (FALSE) {
[11:03:26.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:26.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:26.456]     }
[11:03:26.456]     ...future.result <- base::tryCatch({
[11:03:26.456]         base::withCallingHandlers({
[11:03:26.456]             ...future.value <- base::withVisible(base::local({
[11:03:26.456]                 ...future.makeSendCondition <- base::local({
[11:03:26.456]                   sendCondition <- NULL
[11:03:26.456]                   function(frame = 1L) {
[11:03:26.456]                     if (is.function(sendCondition)) 
[11:03:26.456]                       return(sendCondition)
[11:03:26.456]                     ns <- getNamespace("parallel")
[11:03:26.456]                     if (exists("sendData", mode = "function", 
[11:03:26.456]                       envir = ns)) {
[11:03:26.456]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:26.456]                         envir = ns)
[11:03:26.456]                       envir <- sys.frame(frame)
[11:03:26.456]                       master <- NULL
[11:03:26.456]                       while (!identical(envir, .GlobalEnv) && 
[11:03:26.456]                         !identical(envir, emptyenv())) {
[11:03:26.456]                         if (exists("master", mode = "list", envir = envir, 
[11:03:26.456]                           inherits = FALSE)) {
[11:03:26.456]                           master <- get("master", mode = "list", 
[11:03:26.456]                             envir = envir, inherits = FALSE)
[11:03:26.456]                           if (inherits(master, c("SOCKnode", 
[11:03:26.456]                             "SOCK0node"))) {
[11:03:26.456]                             sendCondition <<- function(cond) {
[11:03:26.456]                               data <- list(type = "VALUE", value = cond, 
[11:03:26.456]                                 success = TRUE)
[11:03:26.456]                               parallel_sendData(master, data)
[11:03:26.456]                             }
[11:03:26.456]                             return(sendCondition)
[11:03:26.456]                           }
[11:03:26.456]                         }
[11:03:26.456]                         frame <- frame + 1L
[11:03:26.456]                         envir <- sys.frame(frame)
[11:03:26.456]                       }
[11:03:26.456]                     }
[11:03:26.456]                     sendCondition <<- function(cond) NULL
[11:03:26.456]                   }
[11:03:26.456]                 })
[11:03:26.456]                 withCallingHandlers({
[11:03:26.456]                   {
[11:03:26.456]                     print(1:50)
[11:03:26.456]                     str(1:50)
[11:03:26.456]                     cat(letters, sep = "-")
[11:03:26.456]                     cat(1:6, collapse = "\n")
[11:03:26.456]                     write.table(datasets::iris[1:10, ], sep = "\t")
[11:03:26.456]                     42L
[11:03:26.456]                   }
[11:03:26.456]                 }, immediateCondition = function(cond) {
[11:03:26.456]                   sendCondition <- ...future.makeSendCondition()
[11:03:26.456]                   sendCondition(cond)
[11:03:26.456]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.456]                   {
[11:03:26.456]                     inherits <- base::inherits
[11:03:26.456]                     invokeRestart <- base::invokeRestart
[11:03:26.456]                     is.null <- base::is.null
[11:03:26.456]                     muffled <- FALSE
[11:03:26.456]                     if (inherits(cond, "message")) {
[11:03:26.456]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:26.456]                       if (muffled) 
[11:03:26.456]                         invokeRestart("muffleMessage")
[11:03:26.456]                     }
[11:03:26.456]                     else if (inherits(cond, "warning")) {
[11:03:26.456]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:26.456]                       if (muffled) 
[11:03:26.456]                         invokeRestart("muffleWarning")
[11:03:26.456]                     }
[11:03:26.456]                     else if (inherits(cond, "condition")) {
[11:03:26.456]                       if (!is.null(pattern)) {
[11:03:26.456]                         computeRestarts <- base::computeRestarts
[11:03:26.456]                         grepl <- base::grepl
[11:03:26.456]                         restarts <- computeRestarts(cond)
[11:03:26.456]                         for (restart in restarts) {
[11:03:26.456]                           name <- restart$name
[11:03:26.456]                           if (is.null(name)) 
[11:03:26.456]                             next
[11:03:26.456]                           if (!grepl(pattern, name)) 
[11:03:26.456]                             next
[11:03:26.456]                           invokeRestart(restart)
[11:03:26.456]                           muffled <- TRUE
[11:03:26.456]                           break
[11:03:26.456]                         }
[11:03:26.456]                       }
[11:03:26.456]                     }
[11:03:26.456]                     invisible(muffled)
[11:03:26.456]                   }
[11:03:26.456]                   muffleCondition(cond)
[11:03:26.456]                 })
[11:03:26.456]             }))
[11:03:26.456]             future::FutureResult(value = ...future.value$value, 
[11:03:26.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.456]                   ...future.rng), globalenv = if (FALSE) 
[11:03:26.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:26.456]                     ...future.globalenv.names))
[11:03:26.456]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:26.456]         }, condition = base::local({
[11:03:26.456]             c <- base::c
[11:03:26.456]             inherits <- base::inherits
[11:03:26.456]             invokeRestart <- base::invokeRestart
[11:03:26.456]             length <- base::length
[11:03:26.456]             list <- base::list
[11:03:26.456]             seq.int <- base::seq.int
[11:03:26.456]             signalCondition <- base::signalCondition
[11:03:26.456]             sys.calls <- base::sys.calls
[11:03:26.456]             `[[` <- base::`[[`
[11:03:26.456]             `+` <- base::`+`
[11:03:26.456]             `<<-` <- base::`<<-`
[11:03:26.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:26.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:26.456]                   3L)]
[11:03:26.456]             }
[11:03:26.456]             function(cond) {
[11:03:26.456]                 is_error <- inherits(cond, "error")
[11:03:26.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:26.456]                   NULL)
[11:03:26.456]                 if (is_error) {
[11:03:26.456]                   sessionInformation <- function() {
[11:03:26.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:26.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:26.456]                       search = base::search(), system = base::Sys.info())
[11:03:26.456]                   }
[11:03:26.456]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:26.456]                     cond$call), session = sessionInformation(), 
[11:03:26.456]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:26.456]                   signalCondition(cond)
[11:03:26.456]                 }
[11:03:26.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:26.456]                 "immediateCondition"))) {
[11:03:26.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:26.456]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:26.456]                   if (TRUE && !signal) {
[11:03:26.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.456]                     {
[11:03:26.456]                       inherits <- base::inherits
[11:03:26.456]                       invokeRestart <- base::invokeRestart
[11:03:26.456]                       is.null <- base::is.null
[11:03:26.456]                       muffled <- FALSE
[11:03:26.456]                       if (inherits(cond, "message")) {
[11:03:26.456]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.456]                         if (muffled) 
[11:03:26.456]                           invokeRestart("muffleMessage")
[11:03:26.456]                       }
[11:03:26.456]                       else if (inherits(cond, "warning")) {
[11:03:26.456]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.456]                         if (muffled) 
[11:03:26.456]                           invokeRestart("muffleWarning")
[11:03:26.456]                       }
[11:03:26.456]                       else if (inherits(cond, "condition")) {
[11:03:26.456]                         if (!is.null(pattern)) {
[11:03:26.456]                           computeRestarts <- base::computeRestarts
[11:03:26.456]                           grepl <- base::grepl
[11:03:26.456]                           restarts <- computeRestarts(cond)
[11:03:26.456]                           for (restart in restarts) {
[11:03:26.456]                             name <- restart$name
[11:03:26.456]                             if (is.null(name)) 
[11:03:26.456]                               next
[11:03:26.456]                             if (!grepl(pattern, name)) 
[11:03:26.456]                               next
[11:03:26.456]                             invokeRestart(restart)
[11:03:26.456]                             muffled <- TRUE
[11:03:26.456]                             break
[11:03:26.456]                           }
[11:03:26.456]                         }
[11:03:26.456]                       }
[11:03:26.456]                       invisible(muffled)
[11:03:26.456]                     }
[11:03:26.456]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.456]                   }
[11:03:26.456]                 }
[11:03:26.456]                 else {
[11:03:26.456]                   if (TRUE) {
[11:03:26.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.456]                     {
[11:03:26.456]                       inherits <- base::inherits
[11:03:26.456]                       invokeRestart <- base::invokeRestart
[11:03:26.456]                       is.null <- base::is.null
[11:03:26.456]                       muffled <- FALSE
[11:03:26.456]                       if (inherits(cond, "message")) {
[11:03:26.456]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.456]                         if (muffled) 
[11:03:26.456]                           invokeRestart("muffleMessage")
[11:03:26.456]                       }
[11:03:26.456]                       else if (inherits(cond, "warning")) {
[11:03:26.456]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.456]                         if (muffled) 
[11:03:26.456]                           invokeRestart("muffleWarning")
[11:03:26.456]                       }
[11:03:26.456]                       else if (inherits(cond, "condition")) {
[11:03:26.456]                         if (!is.null(pattern)) {
[11:03:26.456]                           computeRestarts <- base::computeRestarts
[11:03:26.456]                           grepl <- base::grepl
[11:03:26.456]                           restarts <- computeRestarts(cond)
[11:03:26.456]                           for (restart in restarts) {
[11:03:26.456]                             name <- restart$name
[11:03:26.456]                             if (is.null(name)) 
[11:03:26.456]                               next
[11:03:26.456]                             if (!grepl(pattern, name)) 
[11:03:26.456]                               next
[11:03:26.456]                             invokeRestart(restart)
[11:03:26.456]                             muffled <- TRUE
[11:03:26.456]                             break
[11:03:26.456]                           }
[11:03:26.456]                         }
[11:03:26.456]                       }
[11:03:26.456]                       invisible(muffled)
[11:03:26.456]                     }
[11:03:26.456]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.456]                   }
[11:03:26.456]                 }
[11:03:26.456]             }
[11:03:26.456]         }))
[11:03:26.456]     }, error = function(ex) {
[11:03:26.456]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:26.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.456]                 ...future.rng), started = ...future.startTime, 
[11:03:26.456]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:26.456]             version = "1.8"), class = "FutureResult")
[11:03:26.456]     }, finally = {
[11:03:26.456]         if (!identical(...future.workdir, getwd())) 
[11:03:26.456]             setwd(...future.workdir)
[11:03:26.456]         {
[11:03:26.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:26.456]                 ...future.oldOptions$nwarnings <- NULL
[11:03:26.456]             }
[11:03:26.456]             base::options(...future.oldOptions)
[11:03:26.456]             if (.Platform$OS.type == "windows") {
[11:03:26.456]                 old_names <- names(...future.oldEnvVars)
[11:03:26.456]                 envs <- base::Sys.getenv()
[11:03:26.456]                 names <- names(envs)
[11:03:26.456]                 common <- intersect(names, old_names)
[11:03:26.456]                 added <- setdiff(names, old_names)
[11:03:26.456]                 removed <- setdiff(old_names, names)
[11:03:26.456]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:26.456]                   envs[common]]
[11:03:26.456]                 NAMES <- toupper(changed)
[11:03:26.456]                 args <- list()
[11:03:26.456]                 for (kk in seq_along(NAMES)) {
[11:03:26.456]                   name <- changed[[kk]]
[11:03:26.456]                   NAME <- NAMES[[kk]]
[11:03:26.456]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.456]                     next
[11:03:26.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.456]                 }
[11:03:26.456]                 NAMES <- toupper(added)
[11:03:26.456]                 for (kk in seq_along(NAMES)) {
[11:03:26.456]                   name <- added[[kk]]
[11:03:26.456]                   NAME <- NAMES[[kk]]
[11:03:26.456]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.456]                     next
[11:03:26.456]                   args[[name]] <- ""
[11:03:26.456]                 }
[11:03:26.456]                 NAMES <- toupper(removed)
[11:03:26.456]                 for (kk in seq_along(NAMES)) {
[11:03:26.456]                   name <- removed[[kk]]
[11:03:26.456]                   NAME <- NAMES[[kk]]
[11:03:26.456]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.456]                     next
[11:03:26.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.456]                 }
[11:03:26.456]                 if (length(args) > 0) 
[11:03:26.456]                   base::do.call(base::Sys.setenv, args = args)
[11:03:26.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:26.456]             }
[11:03:26.456]             else {
[11:03:26.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:26.456]             }
[11:03:26.456]             {
[11:03:26.456]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:26.456]                   0L) {
[11:03:26.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:26.456]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:26.456]                   base::options(opts)
[11:03:26.456]                 }
[11:03:26.456]                 {
[11:03:26.456]                   {
[11:03:26.456]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:26.456]                     NULL
[11:03:26.456]                   }
[11:03:26.456]                   options(future.plan = NULL)
[11:03:26.456]                   if (is.na(NA_character_)) 
[11:03:26.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:26.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:26.456]                     .init = FALSE)
[11:03:26.456]                 }
[11:03:26.456]             }
[11:03:26.456]         }
[11:03:26.456]     })
[11:03:26.456]     if (FALSE) {
[11:03:26.456]         base::sink(type = "output", split = FALSE)
[11:03:26.456]         if (NA) {
[11:03:26.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:26.456]         }
[11:03:26.456]         else {
[11:03:26.456]             ...future.result["stdout"] <- base::list(NULL)
[11:03:26.456]         }
[11:03:26.456]         base::close(...future.stdout)
[11:03:26.456]         ...future.stdout <- NULL
[11:03:26.456]     }
[11:03:26.456]     ...future.result$conditions <- ...future.conditions
[11:03:26.456]     ...future.result$finished <- base::Sys.time()
[11:03:26.456]     ...future.result
[11:03:26.456] }
[11:03:26.458] MultisessionFuture started
[11:03:26.459] - Launch lazy future ... done
[11:03:26.459] run() for ‘MultisessionFuture’ ... done
[11:03:26.459] result() for ClusterFuture ...
[11:03:26.459] receiveMessageFromWorker() for ClusterFuture ...
[11:03:26.459] - Validating connection of MultisessionFuture
[11:03:26.501] - received message: FutureResult
[11:03:26.501] - Received FutureResult
[11:03:26.501] - Erased future from FutureRegistry
[11:03:26.501] result() for ClusterFuture ...
[11:03:26.501] - result already collected: FutureResult
[11:03:26.501] result() for ClusterFuture ... done
[11:03:26.501] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:26.501] result() for ClusterFuture ... done
[11:03:26.501] result() for ClusterFuture ...
[11:03:26.501] - result already collected: FutureResult
[11:03:26.502] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[11:03:26.502] getGlobalsAndPackages() ...
[11:03:26.502] Searching for globals...
[11:03:26.502] - globals found: [1] ‘print’
[11:03:26.502] Searching for globals ... DONE
[11:03:26.502] Resolving globals: FALSE
[11:03:26.503] 
[11:03:26.503] 
[11:03:26.504] getGlobalsAndPackages() ... DONE
[11:03:26.505] run() for ‘Future’ ...
[11:03:26.505] - state: ‘created’
[11:03:26.505] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:03:26.518] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:03:26.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:03:26.518]   - Field: ‘node’
[11:03:26.519]   - Field: ‘label’
[11:03:26.519]   - Field: ‘local’
[11:03:26.519]   - Field: ‘owner’
[11:03:26.519]   - Field: ‘envir’
[11:03:26.519]   - Field: ‘workers’
[11:03:26.519]   - Field: ‘packages’
[11:03:26.519]   - Field: ‘gc’
[11:03:26.519]   - Field: ‘conditions’
[11:03:26.519]   - Field: ‘persistent’
[11:03:26.519]   - Field: ‘expr’
[11:03:26.519]   - Field: ‘uuid’
[11:03:26.519]   - Field: ‘seed’
[11:03:26.520]   - Field: ‘version’
[11:03:26.520]   - Field: ‘result’
[11:03:26.520]   - Field: ‘asynchronous’
[11:03:26.520]   - Field: ‘calls’
[11:03:26.520]   - Field: ‘globals’
[11:03:26.520]   - Field: ‘stdout’
[11:03:26.520]   - Field: ‘earlySignal’
[11:03:26.520]   - Field: ‘lazy’
[11:03:26.520]   - Field: ‘state’
[11:03:26.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:03:26.520] - Launch lazy future ...
[11:03:26.521] Packages needed by the future expression (n = 0): <none>
[11:03:26.521] Packages needed by future strategies (n = 0): <none>
[11:03:26.521] {
[11:03:26.521]     {
[11:03:26.521]         {
[11:03:26.521]             ...future.startTime <- base::Sys.time()
[11:03:26.521]             {
[11:03:26.521]                 {
[11:03:26.521]                   {
[11:03:26.521]                     {
[11:03:26.521]                       base::local({
[11:03:26.521]                         has_future <- base::requireNamespace("future", 
[11:03:26.521]                           quietly = TRUE)
[11:03:26.521]                         if (has_future) {
[11:03:26.521]                           ns <- base::getNamespace("future")
[11:03:26.521]                           version <- ns[[".package"]][["version"]]
[11:03:26.521]                           if (is.null(version)) 
[11:03:26.521]                             version <- utils::packageVersion("future")
[11:03:26.521]                         }
[11:03:26.521]                         else {
[11:03:26.521]                           version <- NULL
[11:03:26.521]                         }
[11:03:26.521]                         if (!has_future || version < "1.8.0") {
[11:03:26.521]                           info <- base::c(r_version = base::gsub("R version ", 
[11:03:26.521]                             "", base::R.version$version.string), 
[11:03:26.521]                             platform = base::sprintf("%s (%s-bit)", 
[11:03:26.521]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:03:26.521]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:03:26.521]                               "release", "version")], collapse = " "), 
[11:03:26.521]                             hostname = base::Sys.info()[["nodename"]])
[11:03:26.521]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:03:26.521]                             info)
[11:03:26.521]                           info <- base::paste(info, collapse = "; ")
[11:03:26.521]                           if (!has_future) {
[11:03:26.521]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:03:26.521]                               info)
[11:03:26.521]                           }
[11:03:26.521]                           else {
[11:03:26.521]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:03:26.521]                               info, version)
[11:03:26.521]                           }
[11:03:26.521]                           base::stop(msg)
[11:03:26.521]                         }
[11:03:26.521]                       })
[11:03:26.521]                     }
[11:03:26.521]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:03:26.521]                     base::options(mc.cores = 1L)
[11:03:26.521]                   }
[11:03:26.521]                   ...future.strategy.old <- future::plan("list")
[11:03:26.521]                   options(future.plan = NULL)
[11:03:26.521]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.521]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:03:26.521]                 }
[11:03:26.521]                 ...future.workdir <- getwd()
[11:03:26.521]             }
[11:03:26.521]             ...future.oldOptions <- base::as.list(base::.Options)
[11:03:26.521]             ...future.oldEnvVars <- base::Sys.getenv()
[11:03:26.521]         }
[11:03:26.521]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:03:26.521]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:03:26.521]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:03:26.521]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:03:26.521]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:03:26.521]             future.stdout.windows.reencode = NULL, width = 80L)
[11:03:26.521]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:03:26.521]             base::names(...future.oldOptions))
[11:03:26.521]     }
[11:03:26.521]     if (FALSE) {
[11:03:26.521]     }
[11:03:26.521]     else {
[11:03:26.521]         if (TRUE) {
[11:03:26.521]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:03:26.521]                 open = "w")
[11:03:26.521]         }
[11:03:26.521]         else {
[11:03:26.521]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:03:26.521]                 windows = "NUL", "/dev/null"), open = "w")
[11:03:26.521]         }
[11:03:26.521]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:03:26.521]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:03:26.521]             base::sink(type = "output", split = FALSE)
[11:03:26.521]             base::close(...future.stdout)
[11:03:26.521]         }, add = TRUE)
[11:03:26.521]     }
[11:03:26.521]     ...future.frame <- base::sys.nframe()
[11:03:26.521]     ...future.conditions <- base::list()
[11:03:26.521]     ...future.rng <- base::globalenv()$.Random.seed
[11:03:26.521]     if (FALSE) {
[11:03:26.521]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:03:26.521]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:03:26.521]     }
[11:03:26.521]     ...future.result <- base::tryCatch({
[11:03:26.521]         base::withCallingHandlers({
[11:03:26.521]             ...future.value <- base::withVisible(base::local({
[11:03:26.521]                 ...future.makeSendCondition <- base::local({
[11:03:26.521]                   sendCondition <- NULL
[11:03:26.521]                   function(frame = 1L) {
[11:03:26.521]                     if (is.function(sendCondition)) 
[11:03:26.521]                       return(sendCondition)
[11:03:26.521]                     ns <- getNamespace("parallel")
[11:03:26.521]                     if (exists("sendData", mode = "function", 
[11:03:26.521]                       envir = ns)) {
[11:03:26.521]                       parallel_sendData <- get("sendData", mode = "function", 
[11:03:26.521]                         envir = ns)
[11:03:26.521]                       envir <- sys.frame(frame)
[11:03:26.521]                       master <- NULL
[11:03:26.521]                       while (!identical(envir, .GlobalEnv) && 
[11:03:26.521]                         !identical(envir, emptyenv())) {
[11:03:26.521]                         if (exists("master", mode = "list", envir = envir, 
[11:03:26.521]                           inherits = FALSE)) {
[11:03:26.521]                           master <- get("master", mode = "list", 
[11:03:26.521]                             envir = envir, inherits = FALSE)
[11:03:26.521]                           if (inherits(master, c("SOCKnode", 
[11:03:26.521]                             "SOCK0node"))) {
[11:03:26.521]                             sendCondition <<- function(cond) {
[11:03:26.521]                               data <- list(type = "VALUE", value = cond, 
[11:03:26.521]                                 success = TRUE)
[11:03:26.521]                               parallel_sendData(master, data)
[11:03:26.521]                             }
[11:03:26.521]                             return(sendCondition)
[11:03:26.521]                           }
[11:03:26.521]                         }
[11:03:26.521]                         frame <- frame + 1L
[11:03:26.521]                         envir <- sys.frame(frame)
[11:03:26.521]                       }
[11:03:26.521]                     }
[11:03:26.521]                     sendCondition <<- function(cond) NULL
[11:03:26.521]                   }
[11:03:26.521]                 })
[11:03:26.521]                 withCallingHandlers({
[11:03:26.521]                   print(42)
[11:03:26.521]                 }, immediateCondition = function(cond) {
[11:03:26.521]                   sendCondition <- ...future.makeSendCondition()
[11:03:26.521]                   sendCondition(cond)
[11:03:26.521]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.521]                   {
[11:03:26.521]                     inherits <- base::inherits
[11:03:26.521]                     invokeRestart <- base::invokeRestart
[11:03:26.521]                     is.null <- base::is.null
[11:03:26.521]                     muffled <- FALSE
[11:03:26.521]                     if (inherits(cond, "message")) {
[11:03:26.521]                       muffled <- grepl(pattern, "muffleMessage")
[11:03:26.521]                       if (muffled) 
[11:03:26.521]                         invokeRestart("muffleMessage")
[11:03:26.521]                     }
[11:03:26.521]                     else if (inherits(cond, "warning")) {
[11:03:26.521]                       muffled <- grepl(pattern, "muffleWarning")
[11:03:26.521]                       if (muffled) 
[11:03:26.521]                         invokeRestart("muffleWarning")
[11:03:26.521]                     }
[11:03:26.521]                     else if (inherits(cond, "condition")) {
[11:03:26.521]                       if (!is.null(pattern)) {
[11:03:26.521]                         computeRestarts <- base::computeRestarts
[11:03:26.521]                         grepl <- base::grepl
[11:03:26.521]                         restarts <- computeRestarts(cond)
[11:03:26.521]                         for (restart in restarts) {
[11:03:26.521]                           name <- restart$name
[11:03:26.521]                           if (is.null(name)) 
[11:03:26.521]                             next
[11:03:26.521]                           if (!grepl(pattern, name)) 
[11:03:26.521]                             next
[11:03:26.521]                           invokeRestart(restart)
[11:03:26.521]                           muffled <- TRUE
[11:03:26.521]                           break
[11:03:26.521]                         }
[11:03:26.521]                       }
[11:03:26.521]                     }
[11:03:26.521]                     invisible(muffled)
[11:03:26.521]                   }
[11:03:26.521]                   muffleCondition(cond)
[11:03:26.521]                 })
[11:03:26.521]             }))
[11:03:26.521]             future::FutureResult(value = ...future.value$value, 
[11:03:26.521]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.521]                   ...future.rng), globalenv = if (FALSE) 
[11:03:26.521]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:03:26.521]                     ...future.globalenv.names))
[11:03:26.521]                 else NULL, started = ...future.startTime, version = "1.8")
[11:03:26.521]         }, condition = base::local({
[11:03:26.521]             c <- base::c
[11:03:26.521]             inherits <- base::inherits
[11:03:26.521]             invokeRestart <- base::invokeRestart
[11:03:26.521]             length <- base::length
[11:03:26.521]             list <- base::list
[11:03:26.521]             seq.int <- base::seq.int
[11:03:26.521]             signalCondition <- base::signalCondition
[11:03:26.521]             sys.calls <- base::sys.calls
[11:03:26.521]             `[[` <- base::`[[`
[11:03:26.521]             `+` <- base::`+`
[11:03:26.521]             `<<-` <- base::`<<-`
[11:03:26.521]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:03:26.521]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:03:26.521]                   3L)]
[11:03:26.521]             }
[11:03:26.521]             function(cond) {
[11:03:26.521]                 is_error <- inherits(cond, "error")
[11:03:26.521]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:03:26.521]                   NULL)
[11:03:26.521]                 if (is_error) {
[11:03:26.521]                   sessionInformation <- function() {
[11:03:26.521]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:03:26.521]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:03:26.521]                       search = base::search(), system = base::Sys.info())
[11:03:26.521]                   }
[11:03:26.521]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.521]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:03:26.521]                     cond$call), session = sessionInformation(), 
[11:03:26.521]                     timestamp = base::Sys.time(), signaled = 0L)
[11:03:26.521]                   signalCondition(cond)
[11:03:26.521]                 }
[11:03:26.521]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:03:26.521]                 "immediateCondition"))) {
[11:03:26.521]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:03:26.521]                   ...future.conditions[[length(...future.conditions) + 
[11:03:26.521]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:03:26.521]                   if (TRUE && !signal) {
[11:03:26.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.521]                     {
[11:03:26.521]                       inherits <- base::inherits
[11:03:26.521]                       invokeRestart <- base::invokeRestart
[11:03:26.521]                       is.null <- base::is.null
[11:03:26.521]                       muffled <- FALSE
[11:03:26.521]                       if (inherits(cond, "message")) {
[11:03:26.521]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.521]                         if (muffled) 
[11:03:26.521]                           invokeRestart("muffleMessage")
[11:03:26.521]                       }
[11:03:26.521]                       else if (inherits(cond, "warning")) {
[11:03:26.521]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.521]                         if (muffled) 
[11:03:26.521]                           invokeRestart("muffleWarning")
[11:03:26.521]                       }
[11:03:26.521]                       else if (inherits(cond, "condition")) {
[11:03:26.521]                         if (!is.null(pattern)) {
[11:03:26.521]                           computeRestarts <- base::computeRestarts
[11:03:26.521]                           grepl <- base::grepl
[11:03:26.521]                           restarts <- computeRestarts(cond)
[11:03:26.521]                           for (restart in restarts) {
[11:03:26.521]                             name <- restart$name
[11:03:26.521]                             if (is.null(name)) 
[11:03:26.521]                               next
[11:03:26.521]                             if (!grepl(pattern, name)) 
[11:03:26.521]                               next
[11:03:26.521]                             invokeRestart(restart)
[11:03:26.521]                             muffled <- TRUE
[11:03:26.521]                             break
[11:03:26.521]                           }
[11:03:26.521]                         }
[11:03:26.521]                       }
[11:03:26.521]                       invisible(muffled)
[11:03:26.521]                     }
[11:03:26.521]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.521]                   }
[11:03:26.521]                 }
[11:03:26.521]                 else {
[11:03:26.521]                   if (TRUE) {
[11:03:26.521]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:03:26.521]                     {
[11:03:26.521]                       inherits <- base::inherits
[11:03:26.521]                       invokeRestart <- base::invokeRestart
[11:03:26.521]                       is.null <- base::is.null
[11:03:26.521]                       muffled <- FALSE
[11:03:26.521]                       if (inherits(cond, "message")) {
[11:03:26.521]                         muffled <- grepl(pattern, "muffleMessage")
[11:03:26.521]                         if (muffled) 
[11:03:26.521]                           invokeRestart("muffleMessage")
[11:03:26.521]                       }
[11:03:26.521]                       else if (inherits(cond, "warning")) {
[11:03:26.521]                         muffled <- grepl(pattern, "muffleWarning")
[11:03:26.521]                         if (muffled) 
[11:03:26.521]                           invokeRestart("muffleWarning")
[11:03:26.521]                       }
[11:03:26.521]                       else if (inherits(cond, "condition")) {
[11:03:26.521]                         if (!is.null(pattern)) {
[11:03:26.521]                           computeRestarts <- base::computeRestarts
[11:03:26.521]                           grepl <- base::grepl
[11:03:26.521]                           restarts <- computeRestarts(cond)
[11:03:26.521]                           for (restart in restarts) {
[11:03:26.521]                             name <- restart$name
[11:03:26.521]                             if (is.null(name)) 
[11:03:26.521]                               next
[11:03:26.521]                             if (!grepl(pattern, name)) 
[11:03:26.521]                               next
[11:03:26.521]                             invokeRestart(restart)
[11:03:26.521]                             muffled <- TRUE
[11:03:26.521]                             break
[11:03:26.521]                           }
[11:03:26.521]                         }
[11:03:26.521]                       }
[11:03:26.521]                       invisible(muffled)
[11:03:26.521]                     }
[11:03:26.521]                     muffleCondition(cond, pattern = "^muffle")
[11:03:26.521]                   }
[11:03:26.521]                 }
[11:03:26.521]             }
[11:03:26.521]         }))
[11:03:26.521]     }, error = function(ex) {
[11:03:26.521]         base::structure(base::list(value = NULL, visible = NULL, 
[11:03:26.521]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:03:26.521]                 ...future.rng), started = ...future.startTime, 
[11:03:26.521]             finished = Sys.time(), session_uuid = NA_character_, 
[11:03:26.521]             version = "1.8"), class = "FutureResult")
[11:03:26.521]     }, finally = {
[11:03:26.521]         if (!identical(...future.workdir, getwd())) 
[11:03:26.521]             setwd(...future.workdir)
[11:03:26.521]         {
[11:03:26.521]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:03:26.521]                 ...future.oldOptions$nwarnings <- NULL
[11:03:26.521]             }
[11:03:26.521]             base::options(...future.oldOptions)
[11:03:26.521]             if (.Platform$OS.type == "windows") {
[11:03:26.521]                 old_names <- names(...future.oldEnvVars)
[11:03:26.521]                 envs <- base::Sys.getenv()
[11:03:26.521]                 names <- names(envs)
[11:03:26.521]                 common <- intersect(names, old_names)
[11:03:26.521]                 added <- setdiff(names, old_names)
[11:03:26.521]                 removed <- setdiff(old_names, names)
[11:03:26.521]                 changed <- common[...future.oldEnvVars[common] != 
[11:03:26.521]                   envs[common]]
[11:03:26.521]                 NAMES <- toupper(changed)
[11:03:26.521]                 args <- list()
[11:03:26.521]                 for (kk in seq_along(NAMES)) {
[11:03:26.521]                   name <- changed[[kk]]
[11:03:26.521]                   NAME <- NAMES[[kk]]
[11:03:26.521]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.521]                     next
[11:03:26.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.521]                 }
[11:03:26.521]                 NAMES <- toupper(added)
[11:03:26.521]                 for (kk in seq_along(NAMES)) {
[11:03:26.521]                   name <- added[[kk]]
[11:03:26.521]                   NAME <- NAMES[[kk]]
[11:03:26.521]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.521]                     next
[11:03:26.521]                   args[[name]] <- ""
[11:03:26.521]                 }
[11:03:26.521]                 NAMES <- toupper(removed)
[11:03:26.521]                 for (kk in seq_along(NAMES)) {
[11:03:26.521]                   name <- removed[[kk]]
[11:03:26.521]                   NAME <- NAMES[[kk]]
[11:03:26.521]                   if (name != NAME && is.element(NAME, old_names)) 
[11:03:26.521]                     next
[11:03:26.521]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:03:26.521]                 }
[11:03:26.521]                 if (length(args) > 0) 
[11:03:26.521]                   base::do.call(base::Sys.setenv, args = args)
[11:03:26.521]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:03:26.521]             }
[11:03:26.521]             else {
[11:03:26.521]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:03:26.521]             }
[11:03:26.521]             {
[11:03:26.521]                 if (base::length(...future.futureOptionsAdded) > 
[11:03:26.521]                   0L) {
[11:03:26.521]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:03:26.521]                   base::names(opts) <- ...future.futureOptionsAdded
[11:03:26.521]                   base::options(opts)
[11:03:26.521]                 }
[11:03:26.521]                 {
[11:03:26.521]                   {
[11:03:26.521]                     base::options(mc.cores = ...future.mc.cores.old)
[11:03:26.521]                     NULL
[11:03:26.521]                   }
[11:03:26.521]                   options(future.plan = NULL)
[11:03:26.521]                   if (is.na(NA_character_)) 
[11:03:26.521]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:03:26.521]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:03:26.521]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:03:26.521]                     .init = FALSE)
[11:03:26.521]                 }
[11:03:26.521]             }
[11:03:26.521]         }
[11:03:26.521]     })
[11:03:26.521]     if (TRUE) {
[11:03:26.521]         base::sink(type = "output", split = FALSE)
[11:03:26.521]         if (TRUE) {
[11:03:26.521]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:03:26.521]         }
[11:03:26.521]         else {
[11:03:26.521]             ...future.result["stdout"] <- base::list(NULL)
[11:03:26.521]         }
[11:03:26.521]         base::close(...future.stdout)
[11:03:26.521]         ...future.stdout <- NULL
[11:03:26.521]     }
[11:03:26.521]     ...future.result$conditions <- ...future.conditions
[11:03:26.521]     ...future.result$finished <- base::Sys.time()
[11:03:26.521]     ...future.result
[11:03:26.521] }
[11:03:26.524] MultisessionFuture started
[11:03:26.524] - Launch lazy future ... done
[11:03:26.524] run() for ‘MultisessionFuture’ ... done
[11:03:26.524] result() for ClusterFuture ...
[11:03:26.524] receiveMessageFromWorker() for ClusterFuture ...
[11:03:26.524] - Validating connection of MultisessionFuture
[11:03:26.566] - received message: FutureResult
[11:03:26.566] - Received FutureResult
[11:03:26.566] - Erased future from FutureRegistry
[11:03:26.566] result() for ClusterFuture ...
[11:03:26.566] - result already collected: FutureResult
[11:03:26.566] result() for ClusterFuture ... done
[11:03:26.567] receiveMessageFromWorker() for ClusterFuture ... done
[11:03:26.567] result() for ClusterFuture ... done
[11:03:26.567] result() for ClusterFuture ...
[11:03:26.567] - result already collected: FutureResult
[11:03:26.567] result() for ClusterFuture ... done
[11:03:26.567] result() for ClusterFuture ...
[11:03:26.567] - result already collected: FutureResult
[11:03:26.567] result() for ClusterFuture ... done
[1] 42
[11:03:26.567] result() for ClusterFuture ...
[11:03:26.567] - result already collected: FutureResult
[11:03:26.567] result() for ClusterFuture ... done
multisession ... done
Testing with 2 cores ... done
> 
> message("*** Standard output ... DONE")
*** Standard output ... DONE
> 
> source("incl/end.R")
[11:03:26.568] plan(): Setting new future strategy stack:
[11:03:26.568] List of future strategies:
[11:03:26.568] 1. FutureStrategy:
[11:03:26.568]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:03:26.568]    - tweaked: FALSE
[11:03:26.568]    - call: future::plan(oplan)
[11:03:26.569] plan(): nbrOfWorkers() = 1
> 
