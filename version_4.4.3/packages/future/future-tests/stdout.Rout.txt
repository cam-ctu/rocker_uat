
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:23:16.929] plan(): Setting new future strategy stack:
[10:23:16.929] List of future strategies:
[10:23:16.929] 1. sequential:
[10:23:16.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:16.929]    - tweaked: FALSE
[10:23:16.929]    - call: future::plan("sequential")
[10:23:16.944] plan(): nbrOfWorkers() = 1
> 
> message("*** Standard output ...")
*** Standard output ...
> 
> truth_rows <- utils::capture.output({
+   print(1:50)
+   str(1:50)
+   cat(letters, sep = "-")
+   cat(1:6, collapse = "\n")
+   write.table(datasets::iris[1:10,], sep = "\t")
+ })
> truth <- paste0(paste(truth_rows, collapse = "\n"), "\n")
> print(truth)
[1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n int [1:50] 1 2 3 4 5 6 7 8 9 10 ...\na-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 \n\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\"\n\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\"\n\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\"\n\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\"\n\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\"\n\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\"\n\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\"\n\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\"\n\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\"\n\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\"\n\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\"\n"
> 
> for (cores in seq_len(min(2L, availCores))) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("%s ...", strategy))
+     plan(strategy)
+ 
+     for (stdout in c(TRUE, FALSE, NA)) {
+       message(sprintf("- stdout = %s", stdout))
+ 
+       f <- future({
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       }, stdout = stdout)
+       r <- result(f)
+       str(r)
+       stopifnot(value(f) == 42L)
+       if (is.na(stdout)) {
+         stopifnot(is.null(r$stdout) || r$stdout == "")
+       } else if (stdout) {
+         print(r)
+         stopifnot(identical(r$stdout, truth))
+       } else {
+         stopifnot(is.null(r$stdout))
+       }
+ 
+       v %<-% {
+         print(1:50)
+         str(1:50)
+         cat(letters, sep = "-")
+         cat(1:6, collapse = "\n")
+         write.table(datasets::iris[1:10,], sep = "\t")
+         42L
+       } %stdout% stdout
+       out <- utils::capture.output(y <- v)
+       stopifnot(y == 42L)
+       if (is.na(stdout)) {
+         ## Single-core multisession => sequential
+         if (cores > 1L || strategy != "multisession") {
+           stopifnot(out == "")
+         }
+       } else if (stdout) {
+         print(out)
+         stopifnot(identical(out, truth_rows))
+       } else {
+         stopifnot(out == "")
+       }
+ 
+       message("- stdout = structure(TRUE, drop = TRUE)")
+       f <- future(print(42), stdout = structure(TRUE, drop = TRUE))
+       r <- result(f)
+       stopifnot(inherits(r$stdout, "character"))
+       v <- value(f)
+       r <- result(f)
+       stopifnot(is.null(r$stdout))
+     } ## for (stdout ...)
+ 
+     message(sprintf("%s ... done", strategy))
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... done", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
sequential ...
[10:23:16.997] plan(): Setting new future strategy stack:
[10:23:16.998] List of future strategies:
[10:23:16.998] 1. sequential:
[10:23:16.998]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:16.998]    - tweaked: FALSE
[10:23:16.998]    - call: plan(strategy)
[10:23:17.009] plan(): nbrOfWorkers() = 1
- stdout = TRUE
[10:23:17.010] getGlobalsAndPackages() ...
[10:23:17.010] Searching for globals...
[10:23:17.019] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.019] Searching for globals ... DONE
[10:23:17.020] Resolving globals: FALSE
[10:23:17.020] 
[10:23:17.020] - packages: [1] ‘utils’
[10:23:17.021] getGlobalsAndPackages() ... DONE
[10:23:17.021] run() for ‘Future’ ...
[10:23:17.021] - state: ‘created’
[10:23:17.021] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:23:17.022] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:23:17.022] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:23:17.022]   - Field: ‘label’
[10:23:17.022]   - Field: ‘local’
[10:23:17.022]   - Field: ‘owner’
[10:23:17.022]   - Field: ‘envir’
[10:23:17.022]   - Field: ‘packages’
[10:23:17.022]   - Field: ‘gc’
[10:23:17.023]   - Field: ‘conditions’
[10:23:17.023]   - Field: ‘expr’
[10:23:17.023]   - Field: ‘uuid’
[10:23:17.023]   - Field: ‘seed’
[10:23:17.023]   - Field: ‘version’
[10:23:17.023]   - Field: ‘result’
[10:23:17.023]   - Field: ‘asynchronous’
[10:23:17.023]   - Field: ‘calls’
[10:23:17.023]   - Field: ‘globals’
[10:23:17.023]   - Field: ‘stdout’
[10:23:17.023]   - Field: ‘earlySignal’
[10:23:17.024]   - Field: ‘lazy’
[10:23:17.024]   - Field: ‘state’
[10:23:17.024] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:23:17.024] - Launch lazy future ...
[10:23:17.024] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.025] Packages needed by future strategies (n = 0): <none>
[10:23:17.025] {
[10:23:17.025]     {
[10:23:17.025]         {
[10:23:17.025]             ...future.startTime <- base::Sys.time()
[10:23:17.025]             {
[10:23:17.025]                 {
[10:23:17.025]                   {
[10:23:17.025]                     {
[10:23:17.025]                       base::local({
[10:23:17.025]                         has_future <- base::requireNamespace("future", 
[10:23:17.025]                           quietly = TRUE)
[10:23:17.025]                         if (has_future) {
[10:23:17.025]                           ns <- base::getNamespace("future")
[10:23:17.025]                           version <- ns[[".package"]][["version"]]
[10:23:17.025]                           if (is.null(version)) 
[10:23:17.025]                             version <- utils::packageVersion("future")
[10:23:17.025]                         }
[10:23:17.025]                         else {
[10:23:17.025]                           version <- NULL
[10:23:17.025]                         }
[10:23:17.025]                         if (!has_future || version < "1.8.0") {
[10:23:17.025]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.025]                             "", base::R.version$version.string), 
[10:23:17.025]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.025]                               "release", "version")], collapse = " "), 
[10:23:17.025]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.025]                             info)
[10:23:17.025]                           info <- base::paste(info, collapse = "; ")
[10:23:17.025]                           if (!has_future) {
[10:23:17.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.025]                               info)
[10:23:17.025]                           }
[10:23:17.025]                           else {
[10:23:17.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.025]                               info, version)
[10:23:17.025]                           }
[10:23:17.025]                           base::stop(msg)
[10:23:17.025]                         }
[10:23:17.025]                       })
[10:23:17.025]                     }
[10:23:17.025]                     base::local({
[10:23:17.025]                       for (pkg in "utils") {
[10:23:17.025]                         base::loadNamespace(pkg)
[10:23:17.025]                         base::library(pkg, character.only = TRUE)
[10:23:17.025]                       }
[10:23:17.025]                     })
[10:23:17.025]                   }
[10:23:17.025]                   ...future.strategy.old <- future::plan("list")
[10:23:17.025]                   options(future.plan = NULL)
[10:23:17.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.025]                 }
[10:23:17.025]                 ...future.workdir <- getwd()
[10:23:17.025]             }
[10:23:17.025]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.025]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.025]         }
[10:23:17.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.025]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.025]             base::names(...future.oldOptions))
[10:23:17.025]     }
[10:23:17.025]     if (FALSE) {
[10:23:17.025]     }
[10:23:17.025]     else {
[10:23:17.025]         if (TRUE) {
[10:23:17.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.025]                 open = "w")
[10:23:17.025]         }
[10:23:17.025]         else {
[10:23:17.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.025]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.025]         }
[10:23:17.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.025]             base::sink(type = "output", split = FALSE)
[10:23:17.025]             base::close(...future.stdout)
[10:23:17.025]         }, add = TRUE)
[10:23:17.025]     }
[10:23:17.025]     ...future.frame <- base::sys.nframe()
[10:23:17.025]     ...future.conditions <- base::list()
[10:23:17.025]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.025]     if (FALSE) {
[10:23:17.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.025]     }
[10:23:17.025]     ...future.result <- base::tryCatch({
[10:23:17.025]         base::withCallingHandlers({
[10:23:17.025]             ...future.value <- base::withVisible(base::local({
[10:23:17.025]                 print(1:50)
[10:23:17.025]                 str(1:50)
[10:23:17.025]                 cat(letters, sep = "-")
[10:23:17.025]                 cat(1:6, collapse = "\n")
[10:23:17.025]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.025]                 42L
[10:23:17.025]             }))
[10:23:17.025]             future::FutureResult(value = ...future.value$value, 
[10:23:17.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.025]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.025]                     ...future.globalenv.names))
[10:23:17.025]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.025]         }, condition = base::local({
[10:23:17.025]             c <- base::c
[10:23:17.025]             inherits <- base::inherits
[10:23:17.025]             invokeRestart <- base::invokeRestart
[10:23:17.025]             length <- base::length
[10:23:17.025]             list <- base::list
[10:23:17.025]             seq.int <- base::seq.int
[10:23:17.025]             signalCondition <- base::signalCondition
[10:23:17.025]             sys.calls <- base::sys.calls
[10:23:17.025]             `[[` <- base::`[[`
[10:23:17.025]             `+` <- base::`+`
[10:23:17.025]             `<<-` <- base::`<<-`
[10:23:17.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.025]                   3L)]
[10:23:17.025]             }
[10:23:17.025]             function(cond) {
[10:23:17.025]                 is_error <- inherits(cond, "error")
[10:23:17.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.025]                   NULL)
[10:23:17.025]                 if (is_error) {
[10:23:17.025]                   sessionInformation <- function() {
[10:23:17.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.025]                       search = base::search(), system = base::Sys.info())
[10:23:17.025]                   }
[10:23:17.025]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.025]                     cond$call), session = sessionInformation(), 
[10:23:17.025]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.025]                   signalCondition(cond)
[10:23:17.025]                 }
[10:23:17.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.025]                 "immediateCondition"))) {
[10:23:17.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.025]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.025]                   if (TRUE && !signal) {
[10:23:17.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.025]                     {
[10:23:17.025]                       inherits <- base::inherits
[10:23:17.025]                       invokeRestart <- base::invokeRestart
[10:23:17.025]                       is.null <- base::is.null
[10:23:17.025]                       muffled <- FALSE
[10:23:17.025]                       if (inherits(cond, "message")) {
[10:23:17.025]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.025]                         if (muffled) 
[10:23:17.025]                           invokeRestart("muffleMessage")
[10:23:17.025]                       }
[10:23:17.025]                       else if (inherits(cond, "warning")) {
[10:23:17.025]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.025]                         if (muffled) 
[10:23:17.025]                           invokeRestart("muffleWarning")
[10:23:17.025]                       }
[10:23:17.025]                       else if (inherits(cond, "condition")) {
[10:23:17.025]                         if (!is.null(pattern)) {
[10:23:17.025]                           computeRestarts <- base::computeRestarts
[10:23:17.025]                           grepl <- base::grepl
[10:23:17.025]                           restarts <- computeRestarts(cond)
[10:23:17.025]                           for (restart in restarts) {
[10:23:17.025]                             name <- restart$name
[10:23:17.025]                             if (is.null(name)) 
[10:23:17.025]                               next
[10:23:17.025]                             if (!grepl(pattern, name)) 
[10:23:17.025]                               next
[10:23:17.025]                             invokeRestart(restart)
[10:23:17.025]                             muffled <- TRUE
[10:23:17.025]                             break
[10:23:17.025]                           }
[10:23:17.025]                         }
[10:23:17.025]                       }
[10:23:17.025]                       invisible(muffled)
[10:23:17.025]                     }
[10:23:17.025]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.025]                   }
[10:23:17.025]                 }
[10:23:17.025]                 else {
[10:23:17.025]                   if (TRUE) {
[10:23:17.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.025]                     {
[10:23:17.025]                       inherits <- base::inherits
[10:23:17.025]                       invokeRestart <- base::invokeRestart
[10:23:17.025]                       is.null <- base::is.null
[10:23:17.025]                       muffled <- FALSE
[10:23:17.025]                       if (inherits(cond, "message")) {
[10:23:17.025]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.025]                         if (muffled) 
[10:23:17.025]                           invokeRestart("muffleMessage")
[10:23:17.025]                       }
[10:23:17.025]                       else if (inherits(cond, "warning")) {
[10:23:17.025]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.025]                         if (muffled) 
[10:23:17.025]                           invokeRestart("muffleWarning")
[10:23:17.025]                       }
[10:23:17.025]                       else if (inherits(cond, "condition")) {
[10:23:17.025]                         if (!is.null(pattern)) {
[10:23:17.025]                           computeRestarts <- base::computeRestarts
[10:23:17.025]                           grepl <- base::grepl
[10:23:17.025]                           restarts <- computeRestarts(cond)
[10:23:17.025]                           for (restart in restarts) {
[10:23:17.025]                             name <- restart$name
[10:23:17.025]                             if (is.null(name)) 
[10:23:17.025]                               next
[10:23:17.025]                             if (!grepl(pattern, name)) 
[10:23:17.025]                               next
[10:23:17.025]                             invokeRestart(restart)
[10:23:17.025]                             muffled <- TRUE
[10:23:17.025]                             break
[10:23:17.025]                           }
[10:23:17.025]                         }
[10:23:17.025]                       }
[10:23:17.025]                       invisible(muffled)
[10:23:17.025]                     }
[10:23:17.025]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.025]                   }
[10:23:17.025]                 }
[10:23:17.025]             }
[10:23:17.025]         }))
[10:23:17.025]     }, error = function(ex) {
[10:23:17.025]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.025]                 ...future.rng), started = ...future.startTime, 
[10:23:17.025]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.025]             version = "1.8"), class = "FutureResult")
[10:23:17.025]     }, finally = {
[10:23:17.025]         if (!identical(...future.workdir, getwd())) 
[10:23:17.025]             setwd(...future.workdir)
[10:23:17.025]         {
[10:23:17.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.025]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.025]             }
[10:23:17.025]             base::options(...future.oldOptions)
[10:23:17.025]             if (.Platform$OS.type == "windows") {
[10:23:17.025]                 old_names <- names(...future.oldEnvVars)
[10:23:17.025]                 envs <- base::Sys.getenv()
[10:23:17.025]                 names <- names(envs)
[10:23:17.025]                 common <- intersect(names, old_names)
[10:23:17.025]                 added <- setdiff(names, old_names)
[10:23:17.025]                 removed <- setdiff(old_names, names)
[10:23:17.025]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.025]                   envs[common]]
[10:23:17.025]                 NAMES <- toupper(changed)
[10:23:17.025]                 args <- list()
[10:23:17.025]                 for (kk in seq_along(NAMES)) {
[10:23:17.025]                   name <- changed[[kk]]
[10:23:17.025]                   NAME <- NAMES[[kk]]
[10:23:17.025]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.025]                     next
[10:23:17.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.025]                 }
[10:23:17.025]                 NAMES <- toupper(added)
[10:23:17.025]                 for (kk in seq_along(NAMES)) {
[10:23:17.025]                   name <- added[[kk]]
[10:23:17.025]                   NAME <- NAMES[[kk]]
[10:23:17.025]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.025]                     next
[10:23:17.025]                   args[[name]] <- ""
[10:23:17.025]                 }
[10:23:17.025]                 NAMES <- toupper(removed)
[10:23:17.025]                 for (kk in seq_along(NAMES)) {
[10:23:17.025]                   name <- removed[[kk]]
[10:23:17.025]                   NAME <- NAMES[[kk]]
[10:23:17.025]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.025]                     next
[10:23:17.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.025]                 }
[10:23:17.025]                 if (length(args) > 0) 
[10:23:17.025]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.025]             }
[10:23:17.025]             else {
[10:23:17.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.025]             }
[10:23:17.025]             {
[10:23:17.025]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.025]                   0L) {
[10:23:17.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.025]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.025]                   base::options(opts)
[10:23:17.025]                 }
[10:23:17.025]                 {
[10:23:17.025]                   {
[10:23:17.025]                     NULL
[10:23:17.025]                     RNGkind("Mersenne-Twister")
[10:23:17.025]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:23:17.025]                       inherits = FALSE)
[10:23:17.025]                   }
[10:23:17.025]                   options(future.plan = NULL)
[10:23:17.025]                   if (is.na(NA_character_)) 
[10:23:17.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.025]                     .init = FALSE)
[10:23:17.025]                 }
[10:23:17.025]             }
[10:23:17.025]         }
[10:23:17.025]     })
[10:23:17.025]     if (TRUE) {
[10:23:17.025]         base::sink(type = "output", split = FALSE)
[10:23:17.025]         if (TRUE) {
[10:23:17.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.025]         }
[10:23:17.025]         else {
[10:23:17.025]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.025]         }
[10:23:17.025]         base::close(...future.stdout)
[10:23:17.025]         ...future.stdout <- NULL
[10:23:17.025]     }
[10:23:17.025]     ...future.result$conditions <- ...future.conditions
[10:23:17.025]     ...future.result$finished <- base::Sys.time()
[10:23:17.025]     ...future.result
[10:23:17.025] }
[10:23:17.028] plan(): Setting new future strategy stack:
[10:23:17.028] List of future strategies:
[10:23:17.028] 1. sequential:
[10:23:17.028]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.028]    - tweaked: FALSE
[10:23:17.028]    - call: NULL
[10:23:17.028] plan(): nbrOfWorkers() = 1
[10:23:17.030] plan(): Setting new future strategy stack:
[10:23:17.030] List of future strategies:
[10:23:17.030] 1. sequential:
[10:23:17.030]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.030]    - tweaked: FALSE
[10:23:17.030]    - call: plan(strategy)
[10:23:17.031] plan(): nbrOfWorkers() = 1
[10:23:17.031] SequentialFuture started (and completed)
[10:23:17.031] - Launch lazy future ... done
[10:23:17.031] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ finished    : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ session_uuid: chr "31749e88-6a35-4195-8bd9-39b7274ed089"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "eec1919a6b51"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 86281
  .. ..$ time  : POSIXct[1:1], format: "2025-11-19 10:23:16"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.003441334 secs (started 2025-11-19 10:23:17.02776)
version: 1.8
[10:23:17.041] getGlobalsAndPackages() ...
[10:23:17.041] Searching for globals...
[10:23:17.046] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.046] Searching for globals ... DONE
[10:23:17.046] Resolving globals: FALSE
[10:23:17.047] 
[10:23:17.047] - packages: [1] ‘utils’
[10:23:17.047] getGlobalsAndPackages() ... DONE
[10:23:17.047] run() for ‘Future’ ...
[10:23:17.047] - state: ‘created’
[10:23:17.047] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:23:17.048] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:23:17.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:23:17.048]   - Field: ‘label’
[10:23:17.048]   - Field: ‘local’
[10:23:17.048]   - Field: ‘owner’
[10:23:17.048]   - Field: ‘envir’
[10:23:17.048]   - Field: ‘packages’
[10:23:17.048]   - Field: ‘gc’
[10:23:17.048]   - Field: ‘conditions’
[10:23:17.048]   - Field: ‘expr’
[10:23:17.048]   - Field: ‘uuid’
[10:23:17.049]   - Field: ‘seed’
[10:23:17.049]   - Field: ‘version’
[10:23:17.049]   - Field: ‘result’
[10:23:17.049]   - Field: ‘asynchronous’
[10:23:17.049]   - Field: ‘calls’
[10:23:17.049]   - Field: ‘globals’
[10:23:17.049]   - Field: ‘stdout’
[10:23:17.049]   - Field: ‘earlySignal’
[10:23:17.049]   - Field: ‘lazy’
[10:23:17.049]   - Field: ‘state’
[10:23:17.049] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:23:17.050] - Launch lazy future ...
[10:23:17.050] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.050] Packages needed by future strategies (n = 0): <none>
[10:23:17.050] {
[10:23:17.050]     {
[10:23:17.050]         {
[10:23:17.050]             ...future.startTime <- base::Sys.time()
[10:23:17.050]             {
[10:23:17.050]                 {
[10:23:17.050]                   {
[10:23:17.050]                     {
[10:23:17.050]                       base::local({
[10:23:17.050]                         has_future <- base::requireNamespace("future", 
[10:23:17.050]                           quietly = TRUE)
[10:23:17.050]                         if (has_future) {
[10:23:17.050]                           ns <- base::getNamespace("future")
[10:23:17.050]                           version <- ns[[".package"]][["version"]]
[10:23:17.050]                           if (is.null(version)) 
[10:23:17.050]                             version <- utils::packageVersion("future")
[10:23:17.050]                         }
[10:23:17.050]                         else {
[10:23:17.050]                           version <- NULL
[10:23:17.050]                         }
[10:23:17.050]                         if (!has_future || version < "1.8.0") {
[10:23:17.050]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.050]                             "", base::R.version$version.string), 
[10:23:17.050]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.050]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.050]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.050]                               "release", "version")], collapse = " "), 
[10:23:17.050]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.050]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.050]                             info)
[10:23:17.050]                           info <- base::paste(info, collapse = "; ")
[10:23:17.050]                           if (!has_future) {
[10:23:17.050]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.050]                               info)
[10:23:17.050]                           }
[10:23:17.050]                           else {
[10:23:17.050]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.050]                               info, version)
[10:23:17.050]                           }
[10:23:17.050]                           base::stop(msg)
[10:23:17.050]                         }
[10:23:17.050]                       })
[10:23:17.050]                     }
[10:23:17.050]                     base::local({
[10:23:17.050]                       for (pkg in "utils") {
[10:23:17.050]                         base::loadNamespace(pkg)
[10:23:17.050]                         base::library(pkg, character.only = TRUE)
[10:23:17.050]                       }
[10:23:17.050]                     })
[10:23:17.050]                   }
[10:23:17.050]                   ...future.strategy.old <- future::plan("list")
[10:23:17.050]                   options(future.plan = NULL)
[10:23:17.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.050]                 }
[10:23:17.050]                 ...future.workdir <- getwd()
[10:23:17.050]             }
[10:23:17.050]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.050]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.050]         }
[10:23:17.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.050]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.050]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.050]             base::names(...future.oldOptions))
[10:23:17.050]     }
[10:23:17.050]     if (FALSE) {
[10:23:17.050]     }
[10:23:17.050]     else {
[10:23:17.050]         if (TRUE) {
[10:23:17.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.050]                 open = "w")
[10:23:17.050]         }
[10:23:17.050]         else {
[10:23:17.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.050]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.050]         }
[10:23:17.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.050]             base::sink(type = "output", split = FALSE)
[10:23:17.050]             base::close(...future.stdout)
[10:23:17.050]         }, add = TRUE)
[10:23:17.050]     }
[10:23:17.050]     ...future.frame <- base::sys.nframe()
[10:23:17.050]     ...future.conditions <- base::list()
[10:23:17.050]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.050]     if (FALSE) {
[10:23:17.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.050]     }
[10:23:17.050]     ...future.result <- base::tryCatch({
[10:23:17.050]         base::withCallingHandlers({
[10:23:17.050]             ...future.value <- base::withVisible(base::local({
[10:23:17.050]                 print(1:50)
[10:23:17.050]                 str(1:50)
[10:23:17.050]                 cat(letters, sep = "-")
[10:23:17.050]                 cat(1:6, collapse = "\n")
[10:23:17.050]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.050]                 42L
[10:23:17.050]             }))
[10:23:17.050]             future::FutureResult(value = ...future.value$value, 
[10:23:17.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.050]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.050]                     ...future.globalenv.names))
[10:23:17.050]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.050]         }, condition = base::local({
[10:23:17.050]             c <- base::c
[10:23:17.050]             inherits <- base::inherits
[10:23:17.050]             invokeRestart <- base::invokeRestart
[10:23:17.050]             length <- base::length
[10:23:17.050]             list <- base::list
[10:23:17.050]             seq.int <- base::seq.int
[10:23:17.050]             signalCondition <- base::signalCondition
[10:23:17.050]             sys.calls <- base::sys.calls
[10:23:17.050]             `[[` <- base::`[[`
[10:23:17.050]             `+` <- base::`+`
[10:23:17.050]             `<<-` <- base::`<<-`
[10:23:17.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.050]                   3L)]
[10:23:17.050]             }
[10:23:17.050]             function(cond) {
[10:23:17.050]                 is_error <- inherits(cond, "error")
[10:23:17.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.050]                   NULL)
[10:23:17.050]                 if (is_error) {
[10:23:17.050]                   sessionInformation <- function() {
[10:23:17.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.050]                       search = base::search(), system = base::Sys.info())
[10:23:17.050]                   }
[10:23:17.050]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.050]                     cond$call), session = sessionInformation(), 
[10:23:17.050]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.050]                   signalCondition(cond)
[10:23:17.050]                 }
[10:23:17.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.050]                 "immediateCondition"))) {
[10:23:17.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.050]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.050]                   if (TRUE && !signal) {
[10:23:17.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.050]                     {
[10:23:17.050]                       inherits <- base::inherits
[10:23:17.050]                       invokeRestart <- base::invokeRestart
[10:23:17.050]                       is.null <- base::is.null
[10:23:17.050]                       muffled <- FALSE
[10:23:17.050]                       if (inherits(cond, "message")) {
[10:23:17.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.050]                         if (muffled) 
[10:23:17.050]                           invokeRestart("muffleMessage")
[10:23:17.050]                       }
[10:23:17.050]                       else if (inherits(cond, "warning")) {
[10:23:17.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.050]                         if (muffled) 
[10:23:17.050]                           invokeRestart("muffleWarning")
[10:23:17.050]                       }
[10:23:17.050]                       else if (inherits(cond, "condition")) {
[10:23:17.050]                         if (!is.null(pattern)) {
[10:23:17.050]                           computeRestarts <- base::computeRestarts
[10:23:17.050]                           grepl <- base::grepl
[10:23:17.050]                           restarts <- computeRestarts(cond)
[10:23:17.050]                           for (restart in restarts) {
[10:23:17.050]                             name <- restart$name
[10:23:17.050]                             if (is.null(name)) 
[10:23:17.050]                               next
[10:23:17.050]                             if (!grepl(pattern, name)) 
[10:23:17.050]                               next
[10:23:17.050]                             invokeRestart(restart)
[10:23:17.050]                             muffled <- TRUE
[10:23:17.050]                             break
[10:23:17.050]                           }
[10:23:17.050]                         }
[10:23:17.050]                       }
[10:23:17.050]                       invisible(muffled)
[10:23:17.050]                     }
[10:23:17.050]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.050]                   }
[10:23:17.050]                 }
[10:23:17.050]                 else {
[10:23:17.050]                   if (TRUE) {
[10:23:17.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.050]                     {
[10:23:17.050]                       inherits <- base::inherits
[10:23:17.050]                       invokeRestart <- base::invokeRestart
[10:23:17.050]                       is.null <- base::is.null
[10:23:17.050]                       muffled <- FALSE
[10:23:17.050]                       if (inherits(cond, "message")) {
[10:23:17.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.050]                         if (muffled) 
[10:23:17.050]                           invokeRestart("muffleMessage")
[10:23:17.050]                       }
[10:23:17.050]                       else if (inherits(cond, "warning")) {
[10:23:17.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.050]                         if (muffled) 
[10:23:17.050]                           invokeRestart("muffleWarning")
[10:23:17.050]                       }
[10:23:17.050]                       else if (inherits(cond, "condition")) {
[10:23:17.050]                         if (!is.null(pattern)) {
[10:23:17.050]                           computeRestarts <- base::computeRestarts
[10:23:17.050]                           grepl <- base::grepl
[10:23:17.050]                           restarts <- computeRestarts(cond)
[10:23:17.050]                           for (restart in restarts) {
[10:23:17.050]                             name <- restart$name
[10:23:17.050]                             if (is.null(name)) 
[10:23:17.050]                               next
[10:23:17.050]                             if (!grepl(pattern, name)) 
[10:23:17.050]                               next
[10:23:17.050]                             invokeRestart(restart)
[10:23:17.050]                             muffled <- TRUE
[10:23:17.050]                             break
[10:23:17.050]                           }
[10:23:17.050]                         }
[10:23:17.050]                       }
[10:23:17.050]                       invisible(muffled)
[10:23:17.050]                     }
[10:23:17.050]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.050]                   }
[10:23:17.050]                 }
[10:23:17.050]             }
[10:23:17.050]         }))
[10:23:17.050]     }, error = function(ex) {
[10:23:17.050]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.050]                 ...future.rng), started = ...future.startTime, 
[10:23:17.050]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.050]             version = "1.8"), class = "FutureResult")
[10:23:17.050]     }, finally = {
[10:23:17.050]         if (!identical(...future.workdir, getwd())) 
[10:23:17.050]             setwd(...future.workdir)
[10:23:17.050]         {
[10:23:17.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.050]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.050]             }
[10:23:17.050]             base::options(...future.oldOptions)
[10:23:17.050]             if (.Platform$OS.type == "windows") {
[10:23:17.050]                 old_names <- names(...future.oldEnvVars)
[10:23:17.050]                 envs <- base::Sys.getenv()
[10:23:17.050]                 names <- names(envs)
[10:23:17.050]                 common <- intersect(names, old_names)
[10:23:17.050]                 added <- setdiff(names, old_names)
[10:23:17.050]                 removed <- setdiff(old_names, names)
[10:23:17.050]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.050]                   envs[common]]
[10:23:17.050]                 NAMES <- toupper(changed)
[10:23:17.050]                 args <- list()
[10:23:17.050]                 for (kk in seq_along(NAMES)) {
[10:23:17.050]                   name <- changed[[kk]]
[10:23:17.050]                   NAME <- NAMES[[kk]]
[10:23:17.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.050]                     next
[10:23:17.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.050]                 }
[10:23:17.050]                 NAMES <- toupper(added)
[10:23:17.050]                 for (kk in seq_along(NAMES)) {
[10:23:17.050]                   name <- added[[kk]]
[10:23:17.050]                   NAME <- NAMES[[kk]]
[10:23:17.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.050]                     next
[10:23:17.050]                   args[[name]] <- ""
[10:23:17.050]                 }
[10:23:17.050]                 NAMES <- toupper(removed)
[10:23:17.050]                 for (kk in seq_along(NAMES)) {
[10:23:17.050]                   name <- removed[[kk]]
[10:23:17.050]                   NAME <- NAMES[[kk]]
[10:23:17.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.050]                     next
[10:23:17.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.050]                 }
[10:23:17.050]                 if (length(args) > 0) 
[10:23:17.050]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.050]             }
[10:23:17.050]             else {
[10:23:17.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.050]             }
[10:23:17.050]             {
[10:23:17.050]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.050]                   0L) {
[10:23:17.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.050]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.050]                   base::options(opts)
[10:23:17.050]                 }
[10:23:17.050]                 {
[10:23:17.050]                   {
[10:23:17.050]                     NULL
[10:23:17.050]                     RNGkind("Mersenne-Twister")
[10:23:17.050]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:23:17.050]                       inherits = FALSE)
[10:23:17.050]                   }
[10:23:17.050]                   options(future.plan = NULL)
[10:23:17.050]                   if (is.na(NA_character_)) 
[10:23:17.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.050]                     .init = FALSE)
[10:23:17.050]                 }
[10:23:17.050]             }
[10:23:17.050]         }
[10:23:17.050]     })
[10:23:17.050]     if (TRUE) {
[10:23:17.050]         base::sink(type = "output", split = FALSE)
[10:23:17.050]         if (TRUE) {
[10:23:17.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.050]         }
[10:23:17.050]         else {
[10:23:17.050]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.050]         }
[10:23:17.050]         base::close(...future.stdout)
[10:23:17.050]         ...future.stdout <- NULL
[10:23:17.050]     }
[10:23:17.050]     ...future.result$conditions <- ...future.conditions
[10:23:17.050]     ...future.result$finished <- base::Sys.time()
[10:23:17.050]     ...future.result
[10:23:17.050] }
[10:23:17.052] plan(): Setting new future strategy stack:
[10:23:17.052] List of future strategies:
[10:23:17.052] 1. sequential:
[10:23:17.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.052]    - tweaked: FALSE
[10:23:17.052]    - call: NULL
[10:23:17.053] plan(): nbrOfWorkers() = 1
[10:23:17.054] plan(): Setting new future strategy stack:
[10:23:17.054] List of future strategies:
[10:23:17.054] 1. sequential:
[10:23:17.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.054]    - tweaked: FALSE
[10:23:17.054]    - call: plan(strategy)
[10:23:17.055] plan(): nbrOfWorkers() = 1
[10:23:17.055] SequentialFuture started (and completed)
[10:23:17.055] - Launch lazy future ... done
[10:23:17.055] run() for ‘SequentialFuture’ ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[10:23:17.056] getGlobalsAndPackages() ...
[10:23:17.056] Searching for globals...
[10:23:17.056] - globals found: [1] ‘print’
[10:23:17.056] Searching for globals ... DONE
[10:23:17.056] Resolving globals: FALSE
[10:23:17.057] 
[10:23:17.057] 
[10:23:17.057] getGlobalsAndPackages() ... DONE
[10:23:17.057] run() for ‘Future’ ...
[10:23:17.057] - state: ‘created’
[10:23:17.057] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:23:17.058] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:23:17.058] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:23:17.058]   - Field: ‘label’
[10:23:17.058]   - Field: ‘local’
[10:23:17.058]   - Field: ‘owner’
[10:23:17.058]   - Field: ‘envir’
[10:23:17.058]   - Field: ‘packages’
[10:23:17.058]   - Field: ‘gc’
[10:23:17.058]   - Field: ‘conditions’
[10:23:17.058]   - Field: ‘expr’
[10:23:17.058]   - Field: ‘uuid’
[10:23:17.058]   - Field: ‘seed’
[10:23:17.059]   - Field: ‘version’
[10:23:17.059]   - Field: ‘result’
[10:23:17.059]   - Field: ‘asynchronous’
[10:23:17.059]   - Field: ‘calls’
[10:23:17.059]   - Field: ‘globals’
[10:23:17.059]   - Field: ‘stdout’
[10:23:17.059]   - Field: ‘earlySignal’
[10:23:17.059]   - Field: ‘lazy’
[10:23:17.059]   - Field: ‘state’
[10:23:17.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:23:17.059] - Launch lazy future ...
[10:23:17.060] Packages needed by the future expression (n = 0): <none>
[10:23:17.060] Packages needed by future strategies (n = 0): <none>
[10:23:17.060] {
[10:23:17.060]     {
[10:23:17.060]         {
[10:23:17.060]             ...future.startTime <- base::Sys.time()
[10:23:17.060]             {
[10:23:17.060]                 {
[10:23:17.060]                   {
[10:23:17.060]                     base::local({
[10:23:17.060]                       has_future <- base::requireNamespace("future", 
[10:23:17.060]                         quietly = TRUE)
[10:23:17.060]                       if (has_future) {
[10:23:17.060]                         ns <- base::getNamespace("future")
[10:23:17.060]                         version <- ns[[".package"]][["version"]]
[10:23:17.060]                         if (is.null(version)) 
[10:23:17.060]                           version <- utils::packageVersion("future")
[10:23:17.060]                       }
[10:23:17.060]                       else {
[10:23:17.060]                         version <- NULL
[10:23:17.060]                       }
[10:23:17.060]                       if (!has_future || version < "1.8.0") {
[10:23:17.060]                         info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.060]                           "", base::R.version$version.string), 
[10:23:17.060]                           platform = base::sprintf("%s (%s-bit)", 
[10:23:17.060]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.060]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.060]                             "release", "version")], collapse = " "), 
[10:23:17.060]                           hostname = base::Sys.info()[["nodename"]])
[10:23:17.060]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.060]                           info)
[10:23:17.060]                         info <- base::paste(info, collapse = "; ")
[10:23:17.060]                         if (!has_future) {
[10:23:17.060]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.060]                             info)
[10:23:17.060]                         }
[10:23:17.060]                         else {
[10:23:17.060]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.060]                             info, version)
[10:23:17.060]                         }
[10:23:17.060]                         base::stop(msg)
[10:23:17.060]                       }
[10:23:17.060]                     })
[10:23:17.060]                   }
[10:23:17.060]                   ...future.strategy.old <- future::plan("list")
[10:23:17.060]                   options(future.plan = NULL)
[10:23:17.060]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.060]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.060]                 }
[10:23:17.060]                 ...future.workdir <- getwd()
[10:23:17.060]             }
[10:23:17.060]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.060]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.060]         }
[10:23:17.060]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.060]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.060]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.060]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.060]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.060]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.060]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.060]             base::names(...future.oldOptions))
[10:23:17.060]     }
[10:23:17.060]     if (FALSE) {
[10:23:17.060]     }
[10:23:17.060]     else {
[10:23:17.060]         if (TRUE) {
[10:23:17.060]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.060]                 open = "w")
[10:23:17.060]         }
[10:23:17.060]         else {
[10:23:17.060]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.060]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.060]         }
[10:23:17.060]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.060]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.060]             base::sink(type = "output", split = FALSE)
[10:23:17.060]             base::close(...future.stdout)
[10:23:17.060]         }, add = TRUE)
[10:23:17.060]     }
[10:23:17.060]     ...future.frame <- base::sys.nframe()
[10:23:17.060]     ...future.conditions <- base::list()
[10:23:17.060]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.060]     if (FALSE) {
[10:23:17.060]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.060]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.060]     }
[10:23:17.060]     ...future.result <- base::tryCatch({
[10:23:17.060]         base::withCallingHandlers({
[10:23:17.060]             ...future.value <- base::withVisible(base::local(print(42)))
[10:23:17.060]             future::FutureResult(value = ...future.value$value, 
[10:23:17.060]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.060]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.060]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.060]                     ...future.globalenv.names))
[10:23:17.060]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.060]         }, condition = base::local({
[10:23:17.060]             c <- base::c
[10:23:17.060]             inherits <- base::inherits
[10:23:17.060]             invokeRestart <- base::invokeRestart
[10:23:17.060]             length <- base::length
[10:23:17.060]             list <- base::list
[10:23:17.060]             seq.int <- base::seq.int
[10:23:17.060]             signalCondition <- base::signalCondition
[10:23:17.060]             sys.calls <- base::sys.calls
[10:23:17.060]             `[[` <- base::`[[`
[10:23:17.060]             `+` <- base::`+`
[10:23:17.060]             `<<-` <- base::`<<-`
[10:23:17.060]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.060]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.060]                   3L)]
[10:23:17.060]             }
[10:23:17.060]             function(cond) {
[10:23:17.060]                 is_error <- inherits(cond, "error")
[10:23:17.060]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.060]                   NULL)
[10:23:17.060]                 if (is_error) {
[10:23:17.060]                   sessionInformation <- function() {
[10:23:17.060]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.060]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.060]                       search = base::search(), system = base::Sys.info())
[10:23:17.060]                   }
[10:23:17.060]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.060]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.060]                     cond$call), session = sessionInformation(), 
[10:23:17.060]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.060]                   signalCondition(cond)
[10:23:17.060]                 }
[10:23:17.060]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.060]                 "immediateCondition"))) {
[10:23:17.060]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.060]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.060]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.060]                   if (TRUE && !signal) {
[10:23:17.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.060]                     {
[10:23:17.060]                       inherits <- base::inherits
[10:23:17.060]                       invokeRestart <- base::invokeRestart
[10:23:17.060]                       is.null <- base::is.null
[10:23:17.060]                       muffled <- FALSE
[10:23:17.060]                       if (inherits(cond, "message")) {
[10:23:17.060]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.060]                         if (muffled) 
[10:23:17.060]                           invokeRestart("muffleMessage")
[10:23:17.060]                       }
[10:23:17.060]                       else if (inherits(cond, "warning")) {
[10:23:17.060]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.060]                         if (muffled) 
[10:23:17.060]                           invokeRestart("muffleWarning")
[10:23:17.060]                       }
[10:23:17.060]                       else if (inherits(cond, "condition")) {
[10:23:17.060]                         if (!is.null(pattern)) {
[10:23:17.060]                           computeRestarts <- base::computeRestarts
[10:23:17.060]                           grepl <- base::grepl
[10:23:17.060]                           restarts <- computeRestarts(cond)
[10:23:17.060]                           for (restart in restarts) {
[10:23:17.060]                             name <- restart$name
[10:23:17.060]                             if (is.null(name)) 
[10:23:17.060]                               next
[10:23:17.060]                             if (!grepl(pattern, name)) 
[10:23:17.060]                               next
[10:23:17.060]                             invokeRestart(restart)
[10:23:17.060]                             muffled <- TRUE
[10:23:17.060]                             break
[10:23:17.060]                           }
[10:23:17.060]                         }
[10:23:17.060]                       }
[10:23:17.060]                       invisible(muffled)
[10:23:17.060]                     }
[10:23:17.060]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.060]                   }
[10:23:17.060]                 }
[10:23:17.060]                 else {
[10:23:17.060]                   if (TRUE) {
[10:23:17.060]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.060]                     {
[10:23:17.060]                       inherits <- base::inherits
[10:23:17.060]                       invokeRestart <- base::invokeRestart
[10:23:17.060]                       is.null <- base::is.null
[10:23:17.060]                       muffled <- FALSE
[10:23:17.060]                       if (inherits(cond, "message")) {
[10:23:17.060]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.060]                         if (muffled) 
[10:23:17.060]                           invokeRestart("muffleMessage")
[10:23:17.060]                       }
[10:23:17.060]                       else if (inherits(cond, "warning")) {
[10:23:17.060]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.060]                         if (muffled) 
[10:23:17.060]                           invokeRestart("muffleWarning")
[10:23:17.060]                       }
[10:23:17.060]                       else if (inherits(cond, "condition")) {
[10:23:17.060]                         if (!is.null(pattern)) {
[10:23:17.060]                           computeRestarts <- base::computeRestarts
[10:23:17.060]                           grepl <- base::grepl
[10:23:17.060]                           restarts <- computeRestarts(cond)
[10:23:17.060]                           for (restart in restarts) {
[10:23:17.060]                             name <- restart$name
[10:23:17.060]                             if (is.null(name)) 
[10:23:17.060]                               next
[10:23:17.060]                             if (!grepl(pattern, name)) 
[10:23:17.060]                               next
[10:23:17.060]                             invokeRestart(restart)
[10:23:17.060]                             muffled <- TRUE
[10:23:17.060]                             break
[10:23:17.060]                           }
[10:23:17.060]                         }
[10:23:17.060]                       }
[10:23:17.060]                       invisible(muffled)
[10:23:17.060]                     }
[10:23:17.060]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.060]                   }
[10:23:17.060]                 }
[10:23:17.060]             }
[10:23:17.060]         }))
[10:23:17.060]     }, error = function(ex) {
[10:23:17.060]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.060]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.060]                 ...future.rng), started = ...future.startTime, 
[10:23:17.060]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.060]             version = "1.8"), class = "FutureResult")
[10:23:17.060]     }, finally = {
[10:23:17.060]         if (!identical(...future.workdir, getwd())) 
[10:23:17.060]             setwd(...future.workdir)
[10:23:17.060]         {
[10:23:17.060]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.060]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.060]             }
[10:23:17.060]             base::options(...future.oldOptions)
[10:23:17.060]             if (.Platform$OS.type == "windows") {
[10:23:17.060]                 old_names <- names(...future.oldEnvVars)
[10:23:17.060]                 envs <- base::Sys.getenv()
[10:23:17.060]                 names <- names(envs)
[10:23:17.060]                 common <- intersect(names, old_names)
[10:23:17.060]                 added <- setdiff(names, old_names)
[10:23:17.060]                 removed <- setdiff(old_names, names)
[10:23:17.060]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.060]                   envs[common]]
[10:23:17.060]                 NAMES <- toupper(changed)
[10:23:17.060]                 args <- list()
[10:23:17.060]                 for (kk in seq_along(NAMES)) {
[10:23:17.060]                   name <- changed[[kk]]
[10:23:17.060]                   NAME <- NAMES[[kk]]
[10:23:17.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.060]                     next
[10:23:17.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.060]                 }
[10:23:17.060]                 NAMES <- toupper(added)
[10:23:17.060]                 for (kk in seq_along(NAMES)) {
[10:23:17.060]                   name <- added[[kk]]
[10:23:17.060]                   NAME <- NAMES[[kk]]
[10:23:17.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.060]                     next
[10:23:17.060]                   args[[name]] <- ""
[10:23:17.060]                 }
[10:23:17.060]                 NAMES <- toupper(removed)
[10:23:17.060]                 for (kk in seq_along(NAMES)) {
[10:23:17.060]                   name <- removed[[kk]]
[10:23:17.060]                   NAME <- NAMES[[kk]]
[10:23:17.060]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.060]                     next
[10:23:17.060]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.060]                 }
[10:23:17.060]                 if (length(args) > 0) 
[10:23:17.060]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.060]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.060]             }
[10:23:17.060]             else {
[10:23:17.060]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.060]             }
[10:23:17.060]             {
[10:23:17.060]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.060]                   0L) {
[10:23:17.060]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.060]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.060]                   base::options(opts)
[10:23:17.060]                 }
[10:23:17.060]                 {
[10:23:17.060]                   {
[10:23:17.060]                     NULL
[10:23:17.060]                     RNGkind("Mersenne-Twister")
[10:23:17.060]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:23:17.060]                       inherits = FALSE)
[10:23:17.060]                   }
[10:23:17.060]                   options(future.plan = NULL)
[10:23:17.060]                   if (is.na(NA_character_)) 
[10:23:17.060]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.060]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.060]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.060]                     .init = FALSE)
[10:23:17.060]                 }
[10:23:17.060]             }
[10:23:17.060]         }
[10:23:17.060]     })
[10:23:17.060]     if (TRUE) {
[10:23:17.060]         base::sink(type = "output", split = FALSE)
[10:23:17.060]         if (TRUE) {
[10:23:17.060]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.060]         }
[10:23:17.060]         else {
[10:23:17.060]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.060]         }
[10:23:17.060]         base::close(...future.stdout)
[10:23:17.060]         ...future.stdout <- NULL
[10:23:17.060]     }
[10:23:17.060]     ...future.result$conditions <- ...future.conditions
[10:23:17.060]     ...future.result$finished <- base::Sys.time()
[10:23:17.060]     ...future.result
[10:23:17.060] }
[10:23:17.062] plan(): Setting new future strategy stack:
[10:23:17.062] List of future strategies:
[10:23:17.062] 1. sequential:
[10:23:17.062]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.062]    - tweaked: FALSE
[10:23:17.062]    - call: NULL
[10:23:17.062] plan(): nbrOfWorkers() = 1
[10:23:17.063] plan(): Setting new future strategy stack:
[10:23:17.063] List of future strategies:
[10:23:17.063] 1. sequential:
[10:23:17.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.063]    - tweaked: FALSE
[10:23:17.063]    - call: plan(strategy)
[10:23:17.064] plan(): nbrOfWorkers() = 1
[10:23:17.064] SequentialFuture started (and completed)
[10:23:17.064] - Launch lazy future ... done
[10:23:17.064] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = FALSE
[10:23:17.064] getGlobalsAndPackages() ...
[10:23:17.064] Searching for globals...
[10:23:17.067] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.067] Searching for globals ... DONE
[10:23:17.067] Resolving globals: FALSE
[10:23:17.068] 
[10:23:17.068] - packages: [1] ‘utils’
[10:23:17.068] getGlobalsAndPackages() ... DONE
[10:23:17.068] run() for ‘Future’ ...
[10:23:17.068] - state: ‘created’
[10:23:17.068] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:23:17.069] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:23:17.069] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:23:17.069]   - Field: ‘label’
[10:23:17.069]   - Field: ‘local’
[10:23:17.069]   - Field: ‘owner’
[10:23:17.069]   - Field: ‘envir’
[10:23:17.069]   - Field: ‘packages’
[10:23:17.069]   - Field: ‘gc’
[10:23:17.069]   - Field: ‘conditions’
[10:23:17.070]   - Field: ‘expr’
[10:23:17.070]   - Field: ‘uuid’
[10:23:17.070]   - Field: ‘seed’
[10:23:17.070]   - Field: ‘version’
[10:23:17.070]   - Field: ‘result’
[10:23:17.070]   - Field: ‘asynchronous’
[10:23:17.070]   - Field: ‘calls’
[10:23:17.070]   - Field: ‘globals’
[10:23:17.070]   - Field: ‘stdout’
[10:23:17.070]   - Field: ‘earlySignal’
[10:23:17.070]   - Field: ‘lazy’
[10:23:17.071]   - Field: ‘state’
[10:23:17.071] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:23:17.071] - Launch lazy future ...
[10:23:17.071] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.071] Packages needed by future strategies (n = 0): <none>
[10:23:17.073] {
[10:23:17.073]     {
[10:23:17.073]         {
[10:23:17.073]             ...future.startTime <- base::Sys.time()
[10:23:17.073]             {
[10:23:17.073]                 {
[10:23:17.073]                   {
[10:23:17.073]                     {
[10:23:17.073]                       base::local({
[10:23:17.073]                         has_future <- base::requireNamespace("future", 
[10:23:17.073]                           quietly = TRUE)
[10:23:17.073]                         if (has_future) {
[10:23:17.073]                           ns <- base::getNamespace("future")
[10:23:17.073]                           version <- ns[[".package"]][["version"]]
[10:23:17.073]                           if (is.null(version)) 
[10:23:17.073]                             version <- utils::packageVersion("future")
[10:23:17.073]                         }
[10:23:17.073]                         else {
[10:23:17.073]                           version <- NULL
[10:23:17.073]                         }
[10:23:17.073]                         if (!has_future || version < "1.8.0") {
[10:23:17.073]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.073]                             "", base::R.version$version.string), 
[10:23:17.073]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.073]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.073]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.073]                               "release", "version")], collapse = " "), 
[10:23:17.073]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.073]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.073]                             info)
[10:23:17.073]                           info <- base::paste(info, collapse = "; ")
[10:23:17.073]                           if (!has_future) {
[10:23:17.073]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.073]                               info)
[10:23:17.073]                           }
[10:23:17.073]                           else {
[10:23:17.073]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.073]                               info, version)
[10:23:17.073]                           }
[10:23:17.073]                           base::stop(msg)
[10:23:17.073]                         }
[10:23:17.073]                       })
[10:23:17.073]                     }
[10:23:17.073]                     base::local({
[10:23:17.073]                       for (pkg in "utils") {
[10:23:17.073]                         base::loadNamespace(pkg)
[10:23:17.073]                         base::library(pkg, character.only = TRUE)
[10:23:17.073]                       }
[10:23:17.073]                     })
[10:23:17.073]                   }
[10:23:17.073]                   ...future.strategy.old <- future::plan("list")
[10:23:17.073]                   options(future.plan = NULL)
[10:23:17.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.073]                 }
[10:23:17.073]                 ...future.workdir <- getwd()
[10:23:17.073]             }
[10:23:17.073]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.073]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.073]         }
[10:23:17.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.073]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.073]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.073]             base::names(...future.oldOptions))
[10:23:17.073]     }
[10:23:17.073]     if (FALSE) {
[10:23:17.073]     }
[10:23:17.073]     else {
[10:23:17.073]         if (FALSE) {
[10:23:17.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.073]                 open = "w")
[10:23:17.073]         }
[10:23:17.073]         else {
[10:23:17.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.073]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.073]         }
[10:23:17.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.073]             base::sink(type = "output", split = FALSE)
[10:23:17.073]             base::close(...future.stdout)
[10:23:17.073]         }, add = TRUE)
[10:23:17.073]     }
[10:23:17.073]     ...future.frame <- base::sys.nframe()
[10:23:17.073]     ...future.conditions <- base::list()
[10:23:17.073]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.073]     if (FALSE) {
[10:23:17.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.073]     }
[10:23:17.073]     ...future.result <- base::tryCatch({
[10:23:17.073]         base::withCallingHandlers({
[10:23:17.073]             ...future.value <- base::withVisible(base::local({
[10:23:17.073]                 print(1:50)
[10:23:17.073]                 str(1:50)
[10:23:17.073]                 cat(letters, sep = "-")
[10:23:17.073]                 cat(1:6, collapse = "\n")
[10:23:17.073]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.073]                 42L
[10:23:17.073]             }))
[10:23:17.073]             future::FutureResult(value = ...future.value$value, 
[10:23:17.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.073]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.073]                     ...future.globalenv.names))
[10:23:17.073]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.073]         }, condition = base::local({
[10:23:17.073]             c <- base::c
[10:23:17.073]             inherits <- base::inherits
[10:23:17.073]             invokeRestart <- base::invokeRestart
[10:23:17.073]             length <- base::length
[10:23:17.073]             list <- base::list
[10:23:17.073]             seq.int <- base::seq.int
[10:23:17.073]             signalCondition <- base::signalCondition
[10:23:17.073]             sys.calls <- base::sys.calls
[10:23:17.073]             `[[` <- base::`[[`
[10:23:17.073]             `+` <- base::`+`
[10:23:17.073]             `<<-` <- base::`<<-`
[10:23:17.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.073]                   3L)]
[10:23:17.073]             }
[10:23:17.073]             function(cond) {
[10:23:17.073]                 is_error <- inherits(cond, "error")
[10:23:17.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.073]                   NULL)
[10:23:17.073]                 if (is_error) {
[10:23:17.073]                   sessionInformation <- function() {
[10:23:17.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.073]                       search = base::search(), system = base::Sys.info())
[10:23:17.073]                   }
[10:23:17.073]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.073]                     cond$call), session = sessionInformation(), 
[10:23:17.073]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.073]                   signalCondition(cond)
[10:23:17.073]                 }
[10:23:17.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.073]                 "immediateCondition"))) {
[10:23:17.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.073]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.073]                   if (TRUE && !signal) {
[10:23:17.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.073]                     {
[10:23:17.073]                       inherits <- base::inherits
[10:23:17.073]                       invokeRestart <- base::invokeRestart
[10:23:17.073]                       is.null <- base::is.null
[10:23:17.073]                       muffled <- FALSE
[10:23:17.073]                       if (inherits(cond, "message")) {
[10:23:17.073]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.073]                         if (muffled) 
[10:23:17.073]                           invokeRestart("muffleMessage")
[10:23:17.073]                       }
[10:23:17.073]                       else if (inherits(cond, "warning")) {
[10:23:17.073]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.073]                         if (muffled) 
[10:23:17.073]                           invokeRestart("muffleWarning")
[10:23:17.073]                       }
[10:23:17.073]                       else if (inherits(cond, "condition")) {
[10:23:17.073]                         if (!is.null(pattern)) {
[10:23:17.073]                           computeRestarts <- base::computeRestarts
[10:23:17.073]                           grepl <- base::grepl
[10:23:17.073]                           restarts <- computeRestarts(cond)
[10:23:17.073]                           for (restart in restarts) {
[10:23:17.073]                             name <- restart$name
[10:23:17.073]                             if (is.null(name)) 
[10:23:17.073]                               next
[10:23:17.073]                             if (!grepl(pattern, name)) 
[10:23:17.073]                               next
[10:23:17.073]                             invokeRestart(restart)
[10:23:17.073]                             muffled <- TRUE
[10:23:17.073]                             break
[10:23:17.073]                           }
[10:23:17.073]                         }
[10:23:17.073]                       }
[10:23:17.073]                       invisible(muffled)
[10:23:17.073]                     }
[10:23:17.073]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.073]                   }
[10:23:17.073]                 }
[10:23:17.073]                 else {
[10:23:17.073]                   if (TRUE) {
[10:23:17.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.073]                     {
[10:23:17.073]                       inherits <- base::inherits
[10:23:17.073]                       invokeRestart <- base::invokeRestart
[10:23:17.073]                       is.null <- base::is.null
[10:23:17.073]                       muffled <- FALSE
[10:23:17.073]                       if (inherits(cond, "message")) {
[10:23:17.073]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.073]                         if (muffled) 
[10:23:17.073]                           invokeRestart("muffleMessage")
[10:23:17.073]                       }
[10:23:17.073]                       else if (inherits(cond, "warning")) {
[10:23:17.073]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.073]                         if (muffled) 
[10:23:17.073]                           invokeRestart("muffleWarning")
[10:23:17.073]                       }
[10:23:17.073]                       else if (inherits(cond, "condition")) {
[10:23:17.073]                         if (!is.null(pattern)) {
[10:23:17.073]                           computeRestarts <- base::computeRestarts
[10:23:17.073]                           grepl <- base::grepl
[10:23:17.073]                           restarts <- computeRestarts(cond)
[10:23:17.073]                           for (restart in restarts) {
[10:23:17.073]                             name <- restart$name
[10:23:17.073]                             if (is.null(name)) 
[10:23:17.073]                               next
[10:23:17.073]                             if (!grepl(pattern, name)) 
[10:23:17.073]                               next
[10:23:17.073]                             invokeRestart(restart)
[10:23:17.073]                             muffled <- TRUE
[10:23:17.073]                             break
[10:23:17.073]                           }
[10:23:17.073]                         }
[10:23:17.073]                       }
[10:23:17.073]                       invisible(muffled)
[10:23:17.073]                     }
[10:23:17.073]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.073]                   }
[10:23:17.073]                 }
[10:23:17.073]             }
[10:23:17.073]         }))
[10:23:17.073]     }, error = function(ex) {
[10:23:17.073]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.073]                 ...future.rng), started = ...future.startTime, 
[10:23:17.073]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.073]             version = "1.8"), class = "FutureResult")
[10:23:17.073]     }, finally = {
[10:23:17.073]         if (!identical(...future.workdir, getwd())) 
[10:23:17.073]             setwd(...future.workdir)
[10:23:17.073]         {
[10:23:17.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.073]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.073]             }
[10:23:17.073]             base::options(...future.oldOptions)
[10:23:17.073]             if (.Platform$OS.type == "windows") {
[10:23:17.073]                 old_names <- names(...future.oldEnvVars)
[10:23:17.073]                 envs <- base::Sys.getenv()
[10:23:17.073]                 names <- names(envs)
[10:23:17.073]                 common <- intersect(names, old_names)
[10:23:17.073]                 added <- setdiff(names, old_names)
[10:23:17.073]                 removed <- setdiff(old_names, names)
[10:23:17.073]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.073]                   envs[common]]
[10:23:17.073]                 NAMES <- toupper(changed)
[10:23:17.073]                 args <- list()
[10:23:17.073]                 for (kk in seq_along(NAMES)) {
[10:23:17.073]                   name <- changed[[kk]]
[10:23:17.073]                   NAME <- NAMES[[kk]]
[10:23:17.073]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.073]                     next
[10:23:17.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.073]                 }
[10:23:17.073]                 NAMES <- toupper(added)
[10:23:17.073]                 for (kk in seq_along(NAMES)) {
[10:23:17.073]                   name <- added[[kk]]
[10:23:17.073]                   NAME <- NAMES[[kk]]
[10:23:17.073]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.073]                     next
[10:23:17.073]                   args[[name]] <- ""
[10:23:17.073]                 }
[10:23:17.073]                 NAMES <- toupper(removed)
[10:23:17.073]                 for (kk in seq_along(NAMES)) {
[10:23:17.073]                   name <- removed[[kk]]
[10:23:17.073]                   NAME <- NAMES[[kk]]
[10:23:17.073]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.073]                     next
[10:23:17.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.073]                 }
[10:23:17.073]                 if (length(args) > 0) 
[10:23:17.073]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.073]             }
[10:23:17.073]             else {
[10:23:17.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.073]             }
[10:23:17.073]             {
[10:23:17.073]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.073]                   0L) {
[10:23:17.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.073]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.073]                   base::options(opts)
[10:23:17.073]                 }
[10:23:17.073]                 {
[10:23:17.073]                   {
[10:23:17.073]                     NULL
[10:23:17.073]                     RNGkind("Mersenne-Twister")
[10:23:17.073]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:23:17.073]                       inherits = FALSE)
[10:23:17.073]                   }
[10:23:17.073]                   options(future.plan = NULL)
[10:23:17.073]                   if (is.na(NA_character_)) 
[10:23:17.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.073]                     .init = FALSE)
[10:23:17.073]                 }
[10:23:17.073]             }
[10:23:17.073]         }
[10:23:17.073]     })
[10:23:17.073]     if (TRUE) {
[10:23:17.073]         base::sink(type = "output", split = FALSE)
[10:23:17.073]         if (FALSE) {
[10:23:17.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.073]         }
[10:23:17.073]         else {
[10:23:17.073]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.073]         }
[10:23:17.073]         base::close(...future.stdout)
[10:23:17.073]         ...future.stdout <- NULL
[10:23:17.073]     }
[10:23:17.073]     ...future.result$conditions <- ...future.conditions
[10:23:17.073]     ...future.result$finished <- base::Sys.time()
[10:23:17.073]     ...future.result
[10:23:17.073] }
[10:23:17.075] plan(): Setting new future strategy stack:
[10:23:17.075] List of future strategies:
[10:23:17.075] 1. sequential:
[10:23:17.075]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.075]    - tweaked: FALSE
[10:23:17.075]    - call: NULL
[10:23:17.075] plan(): nbrOfWorkers() = 1
[10:23:17.077] plan(): Setting new future strategy stack:
[10:23:17.077] List of future strategies:
[10:23:17.077] 1. sequential:
[10:23:17.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.077]    - tweaked: FALSE
[10:23:17.077]    - call: plan(strategy)
[10:23:17.077] plan(): nbrOfWorkers() = 1
[10:23:17.078] SequentialFuture started (and completed)
[10:23:17.078] - Launch lazy future ... done
[10:23:17.078] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ finished    : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ session_uuid: chr "31749e88-6a35-4195-8bd9-39b7274ed089"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "eec1919a6b51"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 86281
  .. ..$ time  : POSIXct[1:1], format: "2025-11-19 10:23:16"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:23:17.085] getGlobalsAndPackages() ...
[10:23:17.085] Searching for globals...
[10:23:17.088] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.088] Searching for globals ... DONE
[10:23:17.088] Resolving globals: FALSE
[10:23:17.089] 
[10:23:17.089] - packages: [1] ‘utils’
[10:23:17.089] getGlobalsAndPackages() ... DONE
[10:23:17.089] run() for ‘Future’ ...
[10:23:17.089] - state: ‘created’
[10:23:17.090] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:23:17.090] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:23:17.090] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:23:17.090]   - Field: ‘label’
[10:23:17.090]   - Field: ‘local’
[10:23:17.090]   - Field: ‘owner’
[10:23:17.090]   - Field: ‘envir’
[10:23:17.090]   - Field: ‘packages’
[10:23:17.090]   - Field: ‘gc’
[10:23:17.091]   - Field: ‘conditions’
[10:23:17.091]   - Field: ‘expr’
[10:23:17.091]   - Field: ‘uuid’
[10:23:17.091]   - Field: ‘seed’
[10:23:17.091]   - Field: ‘version’
[10:23:17.091]   - Field: ‘result’
[10:23:17.091]   - Field: ‘asynchronous’
[10:23:17.091]   - Field: ‘calls’
[10:23:17.091]   - Field: ‘globals’
[10:23:17.091]   - Field: ‘stdout’
[10:23:17.091]   - Field: ‘earlySignal’
[10:23:17.092]   - Field: ‘lazy’
[10:23:17.092]   - Field: ‘state’
[10:23:17.092] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:23:17.092] - Launch lazy future ...
[10:23:17.092] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.092] Packages needed by future strategies (n = 0): <none>
[10:23:17.093] {
[10:23:17.093]     {
[10:23:17.093]         {
[10:23:17.093]             ...future.startTime <- base::Sys.time()
[10:23:17.093]             {
[10:23:17.093]                 {
[10:23:17.093]                   {
[10:23:17.093]                     {
[10:23:17.093]                       base::local({
[10:23:17.093]                         has_future <- base::requireNamespace("future", 
[10:23:17.093]                           quietly = TRUE)
[10:23:17.093]                         if (has_future) {
[10:23:17.093]                           ns <- base::getNamespace("future")
[10:23:17.093]                           version <- ns[[".package"]][["version"]]
[10:23:17.093]                           if (is.null(version)) 
[10:23:17.093]                             version <- utils::packageVersion("future")
[10:23:17.093]                         }
[10:23:17.093]                         else {
[10:23:17.093]                           version <- NULL
[10:23:17.093]                         }
[10:23:17.093]                         if (!has_future || version < "1.8.0") {
[10:23:17.093]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.093]                             "", base::R.version$version.string), 
[10:23:17.093]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.093]                               "release", "version")], collapse = " "), 
[10:23:17.093]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.093]                             info)
[10:23:17.093]                           info <- base::paste(info, collapse = "; ")
[10:23:17.093]                           if (!has_future) {
[10:23:17.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.093]                               info)
[10:23:17.093]                           }
[10:23:17.093]                           else {
[10:23:17.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.093]                               info, version)
[10:23:17.093]                           }
[10:23:17.093]                           base::stop(msg)
[10:23:17.093]                         }
[10:23:17.093]                       })
[10:23:17.093]                     }
[10:23:17.093]                     base::local({
[10:23:17.093]                       for (pkg in "utils") {
[10:23:17.093]                         base::loadNamespace(pkg)
[10:23:17.093]                         base::library(pkg, character.only = TRUE)
[10:23:17.093]                       }
[10:23:17.093]                     })
[10:23:17.093]                   }
[10:23:17.093]                   ...future.strategy.old <- future::plan("list")
[10:23:17.093]                   options(future.plan = NULL)
[10:23:17.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.093]                 }
[10:23:17.093]                 ...future.workdir <- getwd()
[10:23:17.093]             }
[10:23:17.093]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.093]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.093]         }
[10:23:17.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.093]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.093]             base::names(...future.oldOptions))
[10:23:17.093]     }
[10:23:17.093]     if (FALSE) {
[10:23:17.093]     }
[10:23:17.093]     else {
[10:23:17.093]         if (FALSE) {
[10:23:17.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.093]                 open = "w")
[10:23:17.093]         }
[10:23:17.093]         else {
[10:23:17.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.093]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.093]         }
[10:23:17.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.093]             base::sink(type = "output", split = FALSE)
[10:23:17.093]             base::close(...future.stdout)
[10:23:17.093]         }, add = TRUE)
[10:23:17.093]     }
[10:23:17.093]     ...future.frame <- base::sys.nframe()
[10:23:17.093]     ...future.conditions <- base::list()
[10:23:17.093]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.093]     if (FALSE) {
[10:23:17.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.093]     }
[10:23:17.093]     ...future.result <- base::tryCatch({
[10:23:17.093]         base::withCallingHandlers({
[10:23:17.093]             ...future.value <- base::withVisible(base::local({
[10:23:17.093]                 print(1:50)
[10:23:17.093]                 str(1:50)
[10:23:17.093]                 cat(letters, sep = "-")
[10:23:17.093]                 cat(1:6, collapse = "\n")
[10:23:17.093]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.093]                 42L
[10:23:17.093]             }))
[10:23:17.093]             future::FutureResult(value = ...future.value$value, 
[10:23:17.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.093]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.093]                     ...future.globalenv.names))
[10:23:17.093]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.093]         }, condition = base::local({
[10:23:17.093]             c <- base::c
[10:23:17.093]             inherits <- base::inherits
[10:23:17.093]             invokeRestart <- base::invokeRestart
[10:23:17.093]             length <- base::length
[10:23:17.093]             list <- base::list
[10:23:17.093]             seq.int <- base::seq.int
[10:23:17.093]             signalCondition <- base::signalCondition
[10:23:17.093]             sys.calls <- base::sys.calls
[10:23:17.093]             `[[` <- base::`[[`
[10:23:17.093]             `+` <- base::`+`
[10:23:17.093]             `<<-` <- base::`<<-`
[10:23:17.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.093]                   3L)]
[10:23:17.093]             }
[10:23:17.093]             function(cond) {
[10:23:17.093]                 is_error <- inherits(cond, "error")
[10:23:17.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.093]                   NULL)
[10:23:17.093]                 if (is_error) {
[10:23:17.093]                   sessionInformation <- function() {
[10:23:17.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.093]                       search = base::search(), system = base::Sys.info())
[10:23:17.093]                   }
[10:23:17.093]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.093]                     cond$call), session = sessionInformation(), 
[10:23:17.093]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.093]                   signalCondition(cond)
[10:23:17.093]                 }
[10:23:17.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.093]                 "immediateCondition"))) {
[10:23:17.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.093]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.093]                   if (TRUE && !signal) {
[10:23:17.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.093]                     {
[10:23:17.093]                       inherits <- base::inherits
[10:23:17.093]                       invokeRestart <- base::invokeRestart
[10:23:17.093]                       is.null <- base::is.null
[10:23:17.093]                       muffled <- FALSE
[10:23:17.093]                       if (inherits(cond, "message")) {
[10:23:17.093]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.093]                         if (muffled) 
[10:23:17.093]                           invokeRestart("muffleMessage")
[10:23:17.093]                       }
[10:23:17.093]                       else if (inherits(cond, "warning")) {
[10:23:17.093]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.093]                         if (muffled) 
[10:23:17.093]                           invokeRestart("muffleWarning")
[10:23:17.093]                       }
[10:23:17.093]                       else if (inherits(cond, "condition")) {
[10:23:17.093]                         if (!is.null(pattern)) {
[10:23:17.093]                           computeRestarts <- base::computeRestarts
[10:23:17.093]                           grepl <- base::grepl
[10:23:17.093]                           restarts <- computeRestarts(cond)
[10:23:17.093]                           for (restart in restarts) {
[10:23:17.093]                             name <- restart$name
[10:23:17.093]                             if (is.null(name)) 
[10:23:17.093]                               next
[10:23:17.093]                             if (!grepl(pattern, name)) 
[10:23:17.093]                               next
[10:23:17.093]                             invokeRestart(restart)
[10:23:17.093]                             muffled <- TRUE
[10:23:17.093]                             break
[10:23:17.093]                           }
[10:23:17.093]                         }
[10:23:17.093]                       }
[10:23:17.093]                       invisible(muffled)
[10:23:17.093]                     }
[10:23:17.093]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.093]                   }
[10:23:17.093]                 }
[10:23:17.093]                 else {
[10:23:17.093]                   if (TRUE) {
[10:23:17.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.093]                     {
[10:23:17.093]                       inherits <- base::inherits
[10:23:17.093]                       invokeRestart <- base::invokeRestart
[10:23:17.093]                       is.null <- base::is.null
[10:23:17.093]                       muffled <- FALSE
[10:23:17.093]                       if (inherits(cond, "message")) {
[10:23:17.093]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.093]                         if (muffled) 
[10:23:17.093]                           invokeRestart("muffleMessage")
[10:23:17.093]                       }
[10:23:17.093]                       else if (inherits(cond, "warning")) {
[10:23:17.093]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.093]                         if (muffled) 
[10:23:17.093]                           invokeRestart("muffleWarning")
[10:23:17.093]                       }
[10:23:17.093]                       else if (inherits(cond, "condition")) {
[10:23:17.093]                         if (!is.null(pattern)) {
[10:23:17.093]                           computeRestarts <- base::computeRestarts
[10:23:17.093]                           grepl <- base::grepl
[10:23:17.093]                           restarts <- computeRestarts(cond)
[10:23:17.093]                           for (restart in restarts) {
[10:23:17.093]                             name <- restart$name
[10:23:17.093]                             if (is.null(name)) 
[10:23:17.093]                               next
[10:23:17.093]                             if (!grepl(pattern, name)) 
[10:23:17.093]                               next
[10:23:17.093]                             invokeRestart(restart)
[10:23:17.093]                             muffled <- TRUE
[10:23:17.093]                             break
[10:23:17.093]                           }
[10:23:17.093]                         }
[10:23:17.093]                       }
[10:23:17.093]                       invisible(muffled)
[10:23:17.093]                     }
[10:23:17.093]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.093]                   }
[10:23:17.093]                 }
[10:23:17.093]             }
[10:23:17.093]         }))
[10:23:17.093]     }, error = function(ex) {
[10:23:17.093]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.093]                 ...future.rng), started = ...future.startTime, 
[10:23:17.093]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.093]             version = "1.8"), class = "FutureResult")
[10:23:17.093]     }, finally = {
[10:23:17.093]         if (!identical(...future.workdir, getwd())) 
[10:23:17.093]             setwd(...future.workdir)
[10:23:17.093]         {
[10:23:17.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.093]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.093]             }
[10:23:17.093]             base::options(...future.oldOptions)
[10:23:17.093]             if (.Platform$OS.type == "windows") {
[10:23:17.093]                 old_names <- names(...future.oldEnvVars)
[10:23:17.093]                 envs <- base::Sys.getenv()
[10:23:17.093]                 names <- names(envs)
[10:23:17.093]                 common <- intersect(names, old_names)
[10:23:17.093]                 added <- setdiff(names, old_names)
[10:23:17.093]                 removed <- setdiff(old_names, names)
[10:23:17.093]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.093]                   envs[common]]
[10:23:17.093]                 NAMES <- toupper(changed)
[10:23:17.093]                 args <- list()
[10:23:17.093]                 for (kk in seq_along(NAMES)) {
[10:23:17.093]                   name <- changed[[kk]]
[10:23:17.093]                   NAME <- NAMES[[kk]]
[10:23:17.093]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.093]                     next
[10:23:17.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.093]                 }
[10:23:17.093]                 NAMES <- toupper(added)
[10:23:17.093]                 for (kk in seq_along(NAMES)) {
[10:23:17.093]                   name <- added[[kk]]
[10:23:17.093]                   NAME <- NAMES[[kk]]
[10:23:17.093]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.093]                     next
[10:23:17.093]                   args[[name]] <- ""
[10:23:17.093]                 }
[10:23:17.093]                 NAMES <- toupper(removed)
[10:23:17.093]                 for (kk in seq_along(NAMES)) {
[10:23:17.093]                   name <- removed[[kk]]
[10:23:17.093]                   NAME <- NAMES[[kk]]
[10:23:17.093]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.093]                     next
[10:23:17.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.093]                 }
[10:23:17.093]                 if (length(args) > 0) 
[10:23:17.093]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.093]             }
[10:23:17.093]             else {
[10:23:17.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.093]             }
[10:23:17.093]             {
[10:23:17.093]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.093]                   0L) {
[10:23:17.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.093]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.093]                   base::options(opts)
[10:23:17.093]                 }
[10:23:17.093]                 {
[10:23:17.093]                   {
[10:23:17.093]                     NULL
[10:23:17.093]                     RNGkind("Mersenne-Twister")
[10:23:17.093]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:23:17.093]                       inherits = FALSE)
[10:23:17.093]                   }
[10:23:17.093]                   options(future.plan = NULL)
[10:23:17.093]                   if (is.na(NA_character_)) 
[10:23:17.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.093]                     .init = FALSE)
[10:23:17.093]                 }
[10:23:17.093]             }
[10:23:17.093]         }
[10:23:17.093]     })
[10:23:17.093]     if (TRUE) {
[10:23:17.093]         base::sink(type = "output", split = FALSE)
[10:23:17.093]         if (FALSE) {
[10:23:17.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.093]         }
[10:23:17.093]         else {
[10:23:17.093]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.093]         }
[10:23:17.093]         base::close(...future.stdout)
[10:23:17.093]         ...future.stdout <- NULL
[10:23:17.093]     }
[10:23:17.093]     ...future.result$conditions <- ...future.conditions
[10:23:17.093]     ...future.result$finished <- base::Sys.time()
[10:23:17.093]     ...future.result
[10:23:17.093] }
[10:23:17.095] plan(): Setting new future strategy stack:
[10:23:17.095] List of future strategies:
[10:23:17.095] 1. sequential:
[10:23:17.095]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.095]    - tweaked: FALSE
[10:23:17.095]    - call: NULL
[10:23:17.095] plan(): nbrOfWorkers() = 1
[10:23:17.096] plan(): Setting new future strategy stack:
[10:23:17.097] List of future strategies:
[10:23:17.097] 1. sequential:
[10:23:17.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.097]    - tweaked: FALSE
[10:23:17.097]    - call: plan(strategy)
[10:23:17.097] plan(): nbrOfWorkers() = 1
[10:23:17.097] SequentialFuture started (and completed)
[10:23:17.097] - Launch lazy future ... done
[10:23:17.097] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[10:23:17.098] getGlobalsAndPackages() ...
[10:23:17.098] Searching for globals...
[10:23:17.098] - globals found: [1] ‘print’
[10:23:17.098] Searching for globals ... DONE
[10:23:17.099] Resolving globals: FALSE
[10:23:17.099] 
[10:23:17.099] 
[10:23:17.099] getGlobalsAndPackages() ... DONE
[10:23:17.099] run() for ‘Future’ ...
[10:23:17.099] - state: ‘created’
[10:23:17.099] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:23:17.100] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:23:17.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:23:17.101]   - Field: ‘label’
[10:23:17.102]   - Field: ‘local’
[10:23:17.102]   - Field: ‘owner’
[10:23:17.102]   - Field: ‘envir’
[10:23:17.102]   - Field: ‘packages’
[10:23:17.102]   - Field: ‘gc’
[10:23:17.102]   - Field: ‘conditions’
[10:23:17.102]   - Field: ‘expr’
[10:23:17.102]   - Field: ‘uuid’
[10:23:17.102]   - Field: ‘seed’
[10:23:17.102]   - Field: ‘version’
[10:23:17.102]   - Field: ‘result’
[10:23:17.103]   - Field: ‘asynchronous’
[10:23:17.103]   - Field: ‘calls’
[10:23:17.103]   - Field: ‘globals’
[10:23:17.103]   - Field: ‘stdout’
[10:23:17.103]   - Field: ‘earlySignal’
[10:23:17.103]   - Field: ‘lazy’
[10:23:17.103]   - Field: ‘state’
[10:23:17.103] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:23:17.103] - Launch lazy future ...
[10:23:17.103] Packages needed by the future expression (n = 0): <none>
[10:23:17.104] Packages needed by future strategies (n = 0): <none>
[10:23:17.104] {
[10:23:17.104]     {
[10:23:17.104]         {
[10:23:17.104]             ...future.startTime <- base::Sys.time()
[10:23:17.104]             {
[10:23:17.104]                 {
[10:23:17.104]                   {
[10:23:17.104]                     base::local({
[10:23:17.104]                       has_future <- base::requireNamespace("future", 
[10:23:17.104]                         quietly = TRUE)
[10:23:17.104]                       if (has_future) {
[10:23:17.104]                         ns <- base::getNamespace("future")
[10:23:17.104]                         version <- ns[[".package"]][["version"]]
[10:23:17.104]                         if (is.null(version)) 
[10:23:17.104]                           version <- utils::packageVersion("future")
[10:23:17.104]                       }
[10:23:17.104]                       else {
[10:23:17.104]                         version <- NULL
[10:23:17.104]                       }
[10:23:17.104]                       if (!has_future || version < "1.8.0") {
[10:23:17.104]                         info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.104]                           "", base::R.version$version.string), 
[10:23:17.104]                           platform = base::sprintf("%s (%s-bit)", 
[10:23:17.104]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.104]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.104]                             "release", "version")], collapse = " "), 
[10:23:17.104]                           hostname = base::Sys.info()[["nodename"]])
[10:23:17.104]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.104]                           info)
[10:23:17.104]                         info <- base::paste(info, collapse = "; ")
[10:23:17.104]                         if (!has_future) {
[10:23:17.104]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.104]                             info)
[10:23:17.104]                         }
[10:23:17.104]                         else {
[10:23:17.104]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.104]                             info, version)
[10:23:17.104]                         }
[10:23:17.104]                         base::stop(msg)
[10:23:17.104]                       }
[10:23:17.104]                     })
[10:23:17.104]                   }
[10:23:17.104]                   ...future.strategy.old <- future::plan("list")
[10:23:17.104]                   options(future.plan = NULL)
[10:23:17.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.104]                 }
[10:23:17.104]                 ...future.workdir <- getwd()
[10:23:17.104]             }
[10:23:17.104]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.104]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.104]         }
[10:23:17.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.104]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.104]             base::names(...future.oldOptions))
[10:23:17.104]     }
[10:23:17.104]     if (FALSE) {
[10:23:17.104]     }
[10:23:17.104]     else {
[10:23:17.104]         if (TRUE) {
[10:23:17.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.104]                 open = "w")
[10:23:17.104]         }
[10:23:17.104]         else {
[10:23:17.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.104]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.104]         }
[10:23:17.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.104]             base::sink(type = "output", split = FALSE)
[10:23:17.104]             base::close(...future.stdout)
[10:23:17.104]         }, add = TRUE)
[10:23:17.104]     }
[10:23:17.104]     ...future.frame <- base::sys.nframe()
[10:23:17.104]     ...future.conditions <- base::list()
[10:23:17.104]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.104]     if (FALSE) {
[10:23:17.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.104]     }
[10:23:17.104]     ...future.result <- base::tryCatch({
[10:23:17.104]         base::withCallingHandlers({
[10:23:17.104]             ...future.value <- base::withVisible(base::local(print(42)))
[10:23:17.104]             future::FutureResult(value = ...future.value$value, 
[10:23:17.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.104]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.104]                     ...future.globalenv.names))
[10:23:17.104]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.104]         }, condition = base::local({
[10:23:17.104]             c <- base::c
[10:23:17.104]             inherits <- base::inherits
[10:23:17.104]             invokeRestart <- base::invokeRestart
[10:23:17.104]             length <- base::length
[10:23:17.104]             list <- base::list
[10:23:17.104]             seq.int <- base::seq.int
[10:23:17.104]             signalCondition <- base::signalCondition
[10:23:17.104]             sys.calls <- base::sys.calls
[10:23:17.104]             `[[` <- base::`[[`
[10:23:17.104]             `+` <- base::`+`
[10:23:17.104]             `<<-` <- base::`<<-`
[10:23:17.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.104]                   3L)]
[10:23:17.104]             }
[10:23:17.104]             function(cond) {
[10:23:17.104]                 is_error <- inherits(cond, "error")
[10:23:17.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.104]                   NULL)
[10:23:17.104]                 if (is_error) {
[10:23:17.104]                   sessionInformation <- function() {
[10:23:17.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.104]                       search = base::search(), system = base::Sys.info())
[10:23:17.104]                   }
[10:23:17.104]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.104]                     cond$call), session = sessionInformation(), 
[10:23:17.104]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.104]                   signalCondition(cond)
[10:23:17.104]                 }
[10:23:17.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.104]                 "immediateCondition"))) {
[10:23:17.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.104]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.104]                   if (TRUE && !signal) {
[10:23:17.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.104]                     {
[10:23:17.104]                       inherits <- base::inherits
[10:23:17.104]                       invokeRestart <- base::invokeRestart
[10:23:17.104]                       is.null <- base::is.null
[10:23:17.104]                       muffled <- FALSE
[10:23:17.104]                       if (inherits(cond, "message")) {
[10:23:17.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.104]                         if (muffled) 
[10:23:17.104]                           invokeRestart("muffleMessage")
[10:23:17.104]                       }
[10:23:17.104]                       else if (inherits(cond, "warning")) {
[10:23:17.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.104]                         if (muffled) 
[10:23:17.104]                           invokeRestart("muffleWarning")
[10:23:17.104]                       }
[10:23:17.104]                       else if (inherits(cond, "condition")) {
[10:23:17.104]                         if (!is.null(pattern)) {
[10:23:17.104]                           computeRestarts <- base::computeRestarts
[10:23:17.104]                           grepl <- base::grepl
[10:23:17.104]                           restarts <- computeRestarts(cond)
[10:23:17.104]                           for (restart in restarts) {
[10:23:17.104]                             name <- restart$name
[10:23:17.104]                             if (is.null(name)) 
[10:23:17.104]                               next
[10:23:17.104]                             if (!grepl(pattern, name)) 
[10:23:17.104]                               next
[10:23:17.104]                             invokeRestart(restart)
[10:23:17.104]                             muffled <- TRUE
[10:23:17.104]                             break
[10:23:17.104]                           }
[10:23:17.104]                         }
[10:23:17.104]                       }
[10:23:17.104]                       invisible(muffled)
[10:23:17.104]                     }
[10:23:17.104]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.104]                   }
[10:23:17.104]                 }
[10:23:17.104]                 else {
[10:23:17.104]                   if (TRUE) {
[10:23:17.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.104]                     {
[10:23:17.104]                       inherits <- base::inherits
[10:23:17.104]                       invokeRestart <- base::invokeRestart
[10:23:17.104]                       is.null <- base::is.null
[10:23:17.104]                       muffled <- FALSE
[10:23:17.104]                       if (inherits(cond, "message")) {
[10:23:17.104]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.104]                         if (muffled) 
[10:23:17.104]                           invokeRestart("muffleMessage")
[10:23:17.104]                       }
[10:23:17.104]                       else if (inherits(cond, "warning")) {
[10:23:17.104]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.104]                         if (muffled) 
[10:23:17.104]                           invokeRestart("muffleWarning")
[10:23:17.104]                       }
[10:23:17.104]                       else if (inherits(cond, "condition")) {
[10:23:17.104]                         if (!is.null(pattern)) {
[10:23:17.104]                           computeRestarts <- base::computeRestarts
[10:23:17.104]                           grepl <- base::grepl
[10:23:17.104]                           restarts <- computeRestarts(cond)
[10:23:17.104]                           for (restart in restarts) {
[10:23:17.104]                             name <- restart$name
[10:23:17.104]                             if (is.null(name)) 
[10:23:17.104]                               next
[10:23:17.104]                             if (!grepl(pattern, name)) 
[10:23:17.104]                               next
[10:23:17.104]                             invokeRestart(restart)
[10:23:17.104]                             muffled <- TRUE
[10:23:17.104]                             break
[10:23:17.104]                           }
[10:23:17.104]                         }
[10:23:17.104]                       }
[10:23:17.104]                       invisible(muffled)
[10:23:17.104]                     }
[10:23:17.104]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.104]                   }
[10:23:17.104]                 }
[10:23:17.104]             }
[10:23:17.104]         }))
[10:23:17.104]     }, error = function(ex) {
[10:23:17.104]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.104]                 ...future.rng), started = ...future.startTime, 
[10:23:17.104]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.104]             version = "1.8"), class = "FutureResult")
[10:23:17.104]     }, finally = {
[10:23:17.104]         if (!identical(...future.workdir, getwd())) 
[10:23:17.104]             setwd(...future.workdir)
[10:23:17.104]         {
[10:23:17.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.104]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.104]             }
[10:23:17.104]             base::options(...future.oldOptions)
[10:23:17.104]             if (.Platform$OS.type == "windows") {
[10:23:17.104]                 old_names <- names(...future.oldEnvVars)
[10:23:17.104]                 envs <- base::Sys.getenv()
[10:23:17.104]                 names <- names(envs)
[10:23:17.104]                 common <- intersect(names, old_names)
[10:23:17.104]                 added <- setdiff(names, old_names)
[10:23:17.104]                 removed <- setdiff(old_names, names)
[10:23:17.104]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.104]                   envs[common]]
[10:23:17.104]                 NAMES <- toupper(changed)
[10:23:17.104]                 args <- list()
[10:23:17.104]                 for (kk in seq_along(NAMES)) {
[10:23:17.104]                   name <- changed[[kk]]
[10:23:17.104]                   NAME <- NAMES[[kk]]
[10:23:17.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.104]                     next
[10:23:17.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.104]                 }
[10:23:17.104]                 NAMES <- toupper(added)
[10:23:17.104]                 for (kk in seq_along(NAMES)) {
[10:23:17.104]                   name <- added[[kk]]
[10:23:17.104]                   NAME <- NAMES[[kk]]
[10:23:17.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.104]                     next
[10:23:17.104]                   args[[name]] <- ""
[10:23:17.104]                 }
[10:23:17.104]                 NAMES <- toupper(removed)
[10:23:17.104]                 for (kk in seq_along(NAMES)) {
[10:23:17.104]                   name <- removed[[kk]]
[10:23:17.104]                   NAME <- NAMES[[kk]]
[10:23:17.104]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.104]                     next
[10:23:17.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.104]                 }
[10:23:17.104]                 if (length(args) > 0) 
[10:23:17.104]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.104]             }
[10:23:17.104]             else {
[10:23:17.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.104]             }
[10:23:17.104]             {
[10:23:17.104]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.104]                   0L) {
[10:23:17.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.104]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.104]                   base::options(opts)
[10:23:17.104]                 }
[10:23:17.104]                 {
[10:23:17.104]                   {
[10:23:17.104]                     NULL
[10:23:17.104]                     RNGkind("Mersenne-Twister")
[10:23:17.104]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:23:17.104]                       inherits = FALSE)
[10:23:17.104]                   }
[10:23:17.104]                   options(future.plan = NULL)
[10:23:17.104]                   if (is.na(NA_character_)) 
[10:23:17.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.104]                     .init = FALSE)
[10:23:17.104]                 }
[10:23:17.104]             }
[10:23:17.104]         }
[10:23:17.104]     })
[10:23:17.104]     if (TRUE) {
[10:23:17.104]         base::sink(type = "output", split = FALSE)
[10:23:17.104]         if (TRUE) {
[10:23:17.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.104]         }
[10:23:17.104]         else {
[10:23:17.104]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.104]         }
[10:23:17.104]         base::close(...future.stdout)
[10:23:17.104]         ...future.stdout <- NULL
[10:23:17.104]     }
[10:23:17.104]     ...future.result$conditions <- ...future.conditions
[10:23:17.104]     ...future.result$finished <- base::Sys.time()
[10:23:17.104]     ...future.result
[10:23:17.104] }
[10:23:17.106] plan(): Setting new future strategy stack:
[10:23:17.106] List of future strategies:
[10:23:17.106] 1. sequential:
[10:23:17.106]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.106]    - tweaked: FALSE
[10:23:17.106]    - call: NULL
[10:23:17.106] plan(): nbrOfWorkers() = 1
[10:23:17.107] plan(): Setting new future strategy stack:
[10:23:17.107] List of future strategies:
[10:23:17.107] 1. sequential:
[10:23:17.107]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.107]    - tweaked: FALSE
[10:23:17.107]    - call: plan(strategy)
[10:23:17.108] plan(): nbrOfWorkers() = 1
[10:23:17.108] SequentialFuture started (and completed)
[10:23:17.108] - Launch lazy future ... done
[10:23:17.108] run() for ‘SequentialFuture’ ... done
[1] 42
- stdout = NA
[10:23:17.108] getGlobalsAndPackages() ...
[10:23:17.108] Searching for globals...
[10:23:17.111] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.111] Searching for globals ... DONE
[10:23:17.111] Resolving globals: FALSE
[10:23:17.112] 
[10:23:17.112] - packages: [1] ‘utils’
[10:23:17.112] getGlobalsAndPackages() ... DONE
[10:23:17.112] run() for ‘Future’ ...
[10:23:17.112] - state: ‘created’
[10:23:17.112] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:23:17.113] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:23:17.113] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:23:17.113]   - Field: ‘label’
[10:23:17.113]   - Field: ‘local’
[10:23:17.113]   - Field: ‘owner’
[10:23:17.113]   - Field: ‘envir’
[10:23:17.113]   - Field: ‘packages’
[10:23:17.113]   - Field: ‘gc’
[10:23:17.114]   - Field: ‘conditions’
[10:23:17.114]   - Field: ‘expr’
[10:23:17.114]   - Field: ‘uuid’
[10:23:17.114]   - Field: ‘seed’
[10:23:17.114]   - Field: ‘version’
[10:23:17.114]   - Field: ‘result’
[10:23:17.114]   - Field: ‘asynchronous’
[10:23:17.114]   - Field: ‘calls’
[10:23:17.114]   - Field: ‘globals’
[10:23:17.114]   - Field: ‘stdout’
[10:23:17.114]   - Field: ‘earlySignal’
[10:23:17.114]   - Field: ‘lazy’
[10:23:17.115]   - Field: ‘state’
[10:23:17.115] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:23:17.115] - Launch lazy future ...
[10:23:17.115] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.115] Packages needed by future strategies (n = 0): <none>
[10:23:17.115] {
[10:23:17.115]     {
[10:23:17.115]         {
[10:23:17.115]             ...future.startTime <- base::Sys.time()
[10:23:17.115]             {
[10:23:17.115]                 {
[10:23:17.115]                   {
[10:23:17.115]                     {
[10:23:17.115]                       base::local({
[10:23:17.115]                         has_future <- base::requireNamespace("future", 
[10:23:17.115]                           quietly = TRUE)
[10:23:17.115]                         if (has_future) {
[10:23:17.115]                           ns <- base::getNamespace("future")
[10:23:17.115]                           version <- ns[[".package"]][["version"]]
[10:23:17.115]                           if (is.null(version)) 
[10:23:17.115]                             version <- utils::packageVersion("future")
[10:23:17.115]                         }
[10:23:17.115]                         else {
[10:23:17.115]                           version <- NULL
[10:23:17.115]                         }
[10:23:17.115]                         if (!has_future || version < "1.8.0") {
[10:23:17.115]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.115]                             "", base::R.version$version.string), 
[10:23:17.115]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.115]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.115]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.115]                               "release", "version")], collapse = " "), 
[10:23:17.115]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.115]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.115]                             info)
[10:23:17.115]                           info <- base::paste(info, collapse = "; ")
[10:23:17.115]                           if (!has_future) {
[10:23:17.115]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.115]                               info)
[10:23:17.115]                           }
[10:23:17.115]                           else {
[10:23:17.115]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.115]                               info, version)
[10:23:17.115]                           }
[10:23:17.115]                           base::stop(msg)
[10:23:17.115]                         }
[10:23:17.115]                       })
[10:23:17.115]                     }
[10:23:17.115]                     base::local({
[10:23:17.115]                       for (pkg in "utils") {
[10:23:17.115]                         base::loadNamespace(pkg)
[10:23:17.115]                         base::library(pkg, character.only = TRUE)
[10:23:17.115]                       }
[10:23:17.115]                     })
[10:23:17.115]                   }
[10:23:17.115]                   ...future.strategy.old <- future::plan("list")
[10:23:17.115]                   options(future.plan = NULL)
[10:23:17.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.115]                 }
[10:23:17.115]                 ...future.workdir <- getwd()
[10:23:17.115]             }
[10:23:17.115]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.115]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.115]         }
[10:23:17.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.115]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.115]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.115]             base::names(...future.oldOptions))
[10:23:17.115]     }
[10:23:17.115]     if (TRUE) {
[10:23:17.115]     }
[10:23:17.115]     else {
[10:23:17.115]         if (NA) {
[10:23:17.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.115]                 open = "w")
[10:23:17.115]         }
[10:23:17.115]         else {
[10:23:17.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.115]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.115]         }
[10:23:17.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.115]             base::sink(type = "output", split = FALSE)
[10:23:17.115]             base::close(...future.stdout)
[10:23:17.115]         }, add = TRUE)
[10:23:17.115]     }
[10:23:17.115]     ...future.frame <- base::sys.nframe()
[10:23:17.115]     ...future.conditions <- base::list()
[10:23:17.115]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.115]     if (FALSE) {
[10:23:17.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.115]     }
[10:23:17.115]     ...future.result <- base::tryCatch({
[10:23:17.115]         base::withCallingHandlers({
[10:23:17.115]             ...future.value <- base::withVisible(base::local({
[10:23:17.115]                 print(1:50)
[10:23:17.115]                 str(1:50)
[10:23:17.115]                 cat(letters, sep = "-")
[10:23:17.115]                 cat(1:6, collapse = "\n")
[10:23:17.115]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.115]                 42L
[10:23:17.115]             }))
[10:23:17.115]             future::FutureResult(value = ...future.value$value, 
[10:23:17.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.115]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.115]                     ...future.globalenv.names))
[10:23:17.115]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.115]         }, condition = base::local({
[10:23:17.115]             c <- base::c
[10:23:17.115]             inherits <- base::inherits
[10:23:17.115]             invokeRestart <- base::invokeRestart
[10:23:17.115]             length <- base::length
[10:23:17.115]             list <- base::list
[10:23:17.115]             seq.int <- base::seq.int
[10:23:17.115]             signalCondition <- base::signalCondition
[10:23:17.115]             sys.calls <- base::sys.calls
[10:23:17.115]             `[[` <- base::`[[`
[10:23:17.115]             `+` <- base::`+`
[10:23:17.115]             `<<-` <- base::`<<-`
[10:23:17.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.115]                   3L)]
[10:23:17.115]             }
[10:23:17.115]             function(cond) {
[10:23:17.115]                 is_error <- inherits(cond, "error")
[10:23:17.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.115]                   NULL)
[10:23:17.115]                 if (is_error) {
[10:23:17.115]                   sessionInformation <- function() {
[10:23:17.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.115]                       search = base::search(), system = base::Sys.info())
[10:23:17.115]                   }
[10:23:17.115]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.115]                     cond$call), session = sessionInformation(), 
[10:23:17.115]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.115]                   signalCondition(cond)
[10:23:17.115]                 }
[10:23:17.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.115]                 "immediateCondition"))) {
[10:23:17.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.115]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.115]                   if (TRUE && !signal) {
[10:23:17.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.115]                     {
[10:23:17.115]                       inherits <- base::inherits
[10:23:17.115]                       invokeRestart <- base::invokeRestart
[10:23:17.115]                       is.null <- base::is.null
[10:23:17.115]                       muffled <- FALSE
[10:23:17.115]                       if (inherits(cond, "message")) {
[10:23:17.115]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.115]                         if (muffled) 
[10:23:17.115]                           invokeRestart("muffleMessage")
[10:23:17.115]                       }
[10:23:17.115]                       else if (inherits(cond, "warning")) {
[10:23:17.115]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.115]                         if (muffled) 
[10:23:17.115]                           invokeRestart("muffleWarning")
[10:23:17.115]                       }
[10:23:17.115]                       else if (inherits(cond, "condition")) {
[10:23:17.115]                         if (!is.null(pattern)) {
[10:23:17.115]                           computeRestarts <- base::computeRestarts
[10:23:17.115]                           grepl <- base::grepl
[10:23:17.115]                           restarts <- computeRestarts(cond)
[10:23:17.115]                           for (restart in restarts) {
[10:23:17.115]                             name <- restart$name
[10:23:17.115]                             if (is.null(name)) 
[10:23:17.115]                               next
[10:23:17.115]                             if (!grepl(pattern, name)) 
[10:23:17.115]                               next
[10:23:17.115]                             invokeRestart(restart)
[10:23:17.115]                             muffled <- TRUE
[10:23:17.115]                             break
[10:23:17.115]                           }
[10:23:17.115]                         }
[10:23:17.115]                       }
[10:23:17.115]                       invisible(muffled)
[10:23:17.115]                     }
[10:23:17.115]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.115]                   }
[10:23:17.115]                 }
[10:23:17.115]                 else {
[10:23:17.115]                   if (TRUE) {
[10:23:17.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.115]                     {
[10:23:17.115]                       inherits <- base::inherits
[10:23:17.115]                       invokeRestart <- base::invokeRestart
[10:23:17.115]                       is.null <- base::is.null
[10:23:17.115]                       muffled <- FALSE
[10:23:17.115]                       if (inherits(cond, "message")) {
[10:23:17.115]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.115]                         if (muffled) 
[10:23:17.115]                           invokeRestart("muffleMessage")
[10:23:17.115]                       }
[10:23:17.115]                       else if (inherits(cond, "warning")) {
[10:23:17.115]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.115]                         if (muffled) 
[10:23:17.115]                           invokeRestart("muffleWarning")
[10:23:17.115]                       }
[10:23:17.115]                       else if (inherits(cond, "condition")) {
[10:23:17.115]                         if (!is.null(pattern)) {
[10:23:17.115]                           computeRestarts <- base::computeRestarts
[10:23:17.115]                           grepl <- base::grepl
[10:23:17.115]                           restarts <- computeRestarts(cond)
[10:23:17.115]                           for (restart in restarts) {
[10:23:17.115]                             name <- restart$name
[10:23:17.115]                             if (is.null(name)) 
[10:23:17.115]                               next
[10:23:17.115]                             if (!grepl(pattern, name)) 
[10:23:17.115]                               next
[10:23:17.115]                             invokeRestart(restart)
[10:23:17.115]                             muffled <- TRUE
[10:23:17.115]                             break
[10:23:17.115]                           }
[10:23:17.115]                         }
[10:23:17.115]                       }
[10:23:17.115]                       invisible(muffled)
[10:23:17.115]                     }
[10:23:17.115]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.115]                   }
[10:23:17.115]                 }
[10:23:17.115]             }
[10:23:17.115]         }))
[10:23:17.115]     }, error = function(ex) {
[10:23:17.115]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.115]                 ...future.rng), started = ...future.startTime, 
[10:23:17.115]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.115]             version = "1.8"), class = "FutureResult")
[10:23:17.115]     }, finally = {
[10:23:17.115]         if (!identical(...future.workdir, getwd())) 
[10:23:17.115]             setwd(...future.workdir)
[10:23:17.115]         {
[10:23:17.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.115]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.115]             }
[10:23:17.115]             base::options(...future.oldOptions)
[10:23:17.115]             if (.Platform$OS.type == "windows") {
[10:23:17.115]                 old_names <- names(...future.oldEnvVars)
[10:23:17.115]                 envs <- base::Sys.getenv()
[10:23:17.115]                 names <- names(envs)
[10:23:17.115]                 common <- intersect(names, old_names)
[10:23:17.115]                 added <- setdiff(names, old_names)
[10:23:17.115]                 removed <- setdiff(old_names, names)
[10:23:17.115]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.115]                   envs[common]]
[10:23:17.115]                 NAMES <- toupper(changed)
[10:23:17.115]                 args <- list()
[10:23:17.115]                 for (kk in seq_along(NAMES)) {
[10:23:17.115]                   name <- changed[[kk]]
[10:23:17.115]                   NAME <- NAMES[[kk]]
[10:23:17.115]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.115]                     next
[10:23:17.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.115]                 }
[10:23:17.115]                 NAMES <- toupper(added)
[10:23:17.115]                 for (kk in seq_along(NAMES)) {
[10:23:17.115]                   name <- added[[kk]]
[10:23:17.115]                   NAME <- NAMES[[kk]]
[10:23:17.115]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.115]                     next
[10:23:17.115]                   args[[name]] <- ""
[10:23:17.115]                 }
[10:23:17.115]                 NAMES <- toupper(removed)
[10:23:17.115]                 for (kk in seq_along(NAMES)) {
[10:23:17.115]                   name <- removed[[kk]]
[10:23:17.115]                   NAME <- NAMES[[kk]]
[10:23:17.115]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.115]                     next
[10:23:17.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.115]                 }
[10:23:17.115]                 if (length(args) > 0) 
[10:23:17.115]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.115]             }
[10:23:17.115]             else {
[10:23:17.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.115]             }
[10:23:17.115]             {
[10:23:17.115]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.115]                   0L) {
[10:23:17.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.115]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.115]                   base::options(opts)
[10:23:17.115]                 }
[10:23:17.115]                 {
[10:23:17.115]                   {
[10:23:17.115]                     NULL
[10:23:17.115]                     RNGkind("Mersenne-Twister")
[10:23:17.115]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:23:17.115]                       inherits = FALSE)
[10:23:17.115]                   }
[10:23:17.115]                   options(future.plan = NULL)
[10:23:17.115]                   if (is.na(NA_character_)) 
[10:23:17.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.115]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.115]                     .init = FALSE)
[10:23:17.115]                 }
[10:23:17.115]             }
[10:23:17.115]         }
[10:23:17.115]     })
[10:23:17.115]     if (FALSE) {
[10:23:17.115]         base::sink(type = "output", split = FALSE)
[10:23:17.115]         if (NA) {
[10:23:17.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.115]         }
[10:23:17.115]         else {
[10:23:17.115]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.115]         }
[10:23:17.115]         base::close(...future.stdout)
[10:23:17.115]         ...future.stdout <- NULL
[10:23:17.115]     }
[10:23:17.115]     ...future.result$conditions <- ...future.conditions
[10:23:17.115]     ...future.result$finished <- base::Sys.time()
[10:23:17.115]     ...future.result
[10:23:17.115] }
[10:23:17.118] plan(): Setting new future strategy stack:
[10:23:17.118] List of future strategies:
[10:23:17.118] 1. sequential:
[10:23:17.118]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.118]    - tweaked: FALSE
[10:23:17.118]    - call: NULL
[10:23:17.118] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[10:23:17.120] plan(): Setting new future strategy stack:
[10:23:17.120] List of future strategies:
[10:23:17.120] 1. sequential:
[10:23:17.120]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.120]    - tweaked: FALSE
[10:23:17.120]    - call: plan(strategy)
[10:23:17.120] plan(): nbrOfWorkers() = 1
[10:23:17.120] SequentialFuture started (and completed)
[10:23:17.120] - Launch lazy future ... done
[10:23:17.120] run() for ‘SequentialFuture’ ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ finished    : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ session_uuid: chr "31749e88-6a35-4195-8bd9-39b7274ed089"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "eec1919a6b51"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 86281
  .. ..$ time  : POSIXct[1:1], format: "2025-11-19 10:23:16"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:23:17.130] getGlobalsAndPackages() ...
[10:23:17.130] Searching for globals...
[10:23:17.133] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.133] Searching for globals ... DONE
[10:23:17.133] Resolving globals: FALSE
[10:23:17.133] 
[10:23:17.134] - packages: [1] ‘utils’
[10:23:17.134] getGlobalsAndPackages() ... DONE
[10:23:17.134] run() for ‘Future’ ...
[10:23:17.134] - state: ‘created’
[10:23:17.134] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:23:17.134] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:23:17.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:23:17.135]   - Field: ‘label’
[10:23:17.135]   - Field: ‘local’
[10:23:17.135]   - Field: ‘owner’
[10:23:17.135]   - Field: ‘envir’
[10:23:17.135]   - Field: ‘packages’
[10:23:17.135]   - Field: ‘gc’
[10:23:17.135]   - Field: ‘conditions’
[10:23:17.135]   - Field: ‘expr’
[10:23:17.135]   - Field: ‘uuid’
[10:23:17.135]   - Field: ‘seed’
[10:23:17.136]   - Field: ‘version’
[10:23:17.136]   - Field: ‘result’
[10:23:17.136]   - Field: ‘asynchronous’
[10:23:17.136]   - Field: ‘calls’
[10:23:17.136]   - Field: ‘globals’
[10:23:17.136]   - Field: ‘stdout’
[10:23:17.136]   - Field: ‘earlySignal’
[10:23:17.136]   - Field: ‘lazy’
[10:23:17.136]   - Field: ‘state’
[10:23:17.136] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:23:17.136] - Launch lazy future ...
[10:23:17.137] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.137] Packages needed by future strategies (n = 0): <none>
[10:23:17.137] {
[10:23:17.137]     {
[10:23:17.137]         {
[10:23:17.137]             ...future.startTime <- base::Sys.time()
[10:23:17.137]             {
[10:23:17.137]                 {
[10:23:17.137]                   {
[10:23:17.137]                     {
[10:23:17.137]                       base::local({
[10:23:17.137]                         has_future <- base::requireNamespace("future", 
[10:23:17.137]                           quietly = TRUE)
[10:23:17.137]                         if (has_future) {
[10:23:17.137]                           ns <- base::getNamespace("future")
[10:23:17.137]                           version <- ns[[".package"]][["version"]]
[10:23:17.137]                           if (is.null(version)) 
[10:23:17.137]                             version <- utils::packageVersion("future")
[10:23:17.137]                         }
[10:23:17.137]                         else {
[10:23:17.137]                           version <- NULL
[10:23:17.137]                         }
[10:23:17.137]                         if (!has_future || version < "1.8.0") {
[10:23:17.137]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.137]                             "", base::R.version$version.string), 
[10:23:17.137]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.137]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.137]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.137]                               "release", "version")], collapse = " "), 
[10:23:17.137]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.137]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.137]                             info)
[10:23:17.137]                           info <- base::paste(info, collapse = "; ")
[10:23:17.137]                           if (!has_future) {
[10:23:17.137]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.137]                               info)
[10:23:17.137]                           }
[10:23:17.137]                           else {
[10:23:17.137]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.137]                               info, version)
[10:23:17.137]                           }
[10:23:17.137]                           base::stop(msg)
[10:23:17.137]                         }
[10:23:17.137]                       })
[10:23:17.137]                     }
[10:23:17.137]                     base::local({
[10:23:17.137]                       for (pkg in "utils") {
[10:23:17.137]                         base::loadNamespace(pkg)
[10:23:17.137]                         base::library(pkg, character.only = TRUE)
[10:23:17.137]                       }
[10:23:17.137]                     })
[10:23:17.137]                   }
[10:23:17.137]                   ...future.strategy.old <- future::plan("list")
[10:23:17.137]                   options(future.plan = NULL)
[10:23:17.137]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.137]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.137]                 }
[10:23:17.137]                 ...future.workdir <- getwd()
[10:23:17.137]             }
[10:23:17.137]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.137]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.137]         }
[10:23:17.137]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.137]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.137]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.137]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.137]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.137]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.137]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.137]             base::names(...future.oldOptions))
[10:23:17.137]     }
[10:23:17.137]     if (TRUE) {
[10:23:17.137]     }
[10:23:17.137]     else {
[10:23:17.137]         if (NA) {
[10:23:17.137]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.137]                 open = "w")
[10:23:17.137]         }
[10:23:17.137]         else {
[10:23:17.137]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.137]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.137]         }
[10:23:17.137]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.137]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.137]             base::sink(type = "output", split = FALSE)
[10:23:17.137]             base::close(...future.stdout)
[10:23:17.137]         }, add = TRUE)
[10:23:17.137]     }
[10:23:17.137]     ...future.frame <- base::sys.nframe()
[10:23:17.137]     ...future.conditions <- base::list()
[10:23:17.137]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.137]     if (FALSE) {
[10:23:17.137]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.137]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.137]     }
[10:23:17.137]     ...future.result <- base::tryCatch({
[10:23:17.137]         base::withCallingHandlers({
[10:23:17.137]             ...future.value <- base::withVisible(base::local({
[10:23:17.137]                 print(1:50)
[10:23:17.137]                 str(1:50)
[10:23:17.137]                 cat(letters, sep = "-")
[10:23:17.137]                 cat(1:6, collapse = "\n")
[10:23:17.137]                 write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.137]                 42L
[10:23:17.137]             }))
[10:23:17.137]             future::FutureResult(value = ...future.value$value, 
[10:23:17.137]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.137]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.137]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.137]                     ...future.globalenv.names))
[10:23:17.137]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.137]         }, condition = base::local({
[10:23:17.137]             c <- base::c
[10:23:17.137]             inherits <- base::inherits
[10:23:17.137]             invokeRestart <- base::invokeRestart
[10:23:17.137]             length <- base::length
[10:23:17.137]             list <- base::list
[10:23:17.137]             seq.int <- base::seq.int
[10:23:17.137]             signalCondition <- base::signalCondition
[10:23:17.137]             sys.calls <- base::sys.calls
[10:23:17.137]             `[[` <- base::`[[`
[10:23:17.137]             `+` <- base::`+`
[10:23:17.137]             `<<-` <- base::`<<-`
[10:23:17.137]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.137]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.137]                   3L)]
[10:23:17.137]             }
[10:23:17.137]             function(cond) {
[10:23:17.137]                 is_error <- inherits(cond, "error")
[10:23:17.137]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.137]                   NULL)
[10:23:17.137]                 if (is_error) {
[10:23:17.137]                   sessionInformation <- function() {
[10:23:17.137]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.137]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.137]                       search = base::search(), system = base::Sys.info())
[10:23:17.137]                   }
[10:23:17.137]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.137]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.137]                     cond$call), session = sessionInformation(), 
[10:23:17.137]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.137]                   signalCondition(cond)
[10:23:17.137]                 }
[10:23:17.137]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.137]                 "immediateCondition"))) {
[10:23:17.137]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.137]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.137]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.137]                   if (TRUE && !signal) {
[10:23:17.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.137]                     {
[10:23:17.137]                       inherits <- base::inherits
[10:23:17.137]                       invokeRestart <- base::invokeRestart
[10:23:17.137]                       is.null <- base::is.null
[10:23:17.137]                       muffled <- FALSE
[10:23:17.137]                       if (inherits(cond, "message")) {
[10:23:17.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.137]                         if (muffled) 
[10:23:17.137]                           invokeRestart("muffleMessage")
[10:23:17.137]                       }
[10:23:17.137]                       else if (inherits(cond, "warning")) {
[10:23:17.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.137]                         if (muffled) 
[10:23:17.137]                           invokeRestart("muffleWarning")
[10:23:17.137]                       }
[10:23:17.137]                       else if (inherits(cond, "condition")) {
[10:23:17.137]                         if (!is.null(pattern)) {
[10:23:17.137]                           computeRestarts <- base::computeRestarts
[10:23:17.137]                           grepl <- base::grepl
[10:23:17.137]                           restarts <- computeRestarts(cond)
[10:23:17.137]                           for (restart in restarts) {
[10:23:17.137]                             name <- restart$name
[10:23:17.137]                             if (is.null(name)) 
[10:23:17.137]                               next
[10:23:17.137]                             if (!grepl(pattern, name)) 
[10:23:17.137]                               next
[10:23:17.137]                             invokeRestart(restart)
[10:23:17.137]                             muffled <- TRUE
[10:23:17.137]                             break
[10:23:17.137]                           }
[10:23:17.137]                         }
[10:23:17.137]                       }
[10:23:17.137]                       invisible(muffled)
[10:23:17.137]                     }
[10:23:17.137]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.137]                   }
[10:23:17.137]                 }
[10:23:17.137]                 else {
[10:23:17.137]                   if (TRUE) {
[10:23:17.137]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.137]                     {
[10:23:17.137]                       inherits <- base::inherits
[10:23:17.137]                       invokeRestart <- base::invokeRestart
[10:23:17.137]                       is.null <- base::is.null
[10:23:17.137]                       muffled <- FALSE
[10:23:17.137]                       if (inherits(cond, "message")) {
[10:23:17.137]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.137]                         if (muffled) 
[10:23:17.137]                           invokeRestart("muffleMessage")
[10:23:17.137]                       }
[10:23:17.137]                       else if (inherits(cond, "warning")) {
[10:23:17.137]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.137]                         if (muffled) 
[10:23:17.137]                           invokeRestart("muffleWarning")
[10:23:17.137]                       }
[10:23:17.137]                       else if (inherits(cond, "condition")) {
[10:23:17.137]                         if (!is.null(pattern)) {
[10:23:17.137]                           computeRestarts <- base::computeRestarts
[10:23:17.137]                           grepl <- base::grepl
[10:23:17.137]                           restarts <- computeRestarts(cond)
[10:23:17.137]                           for (restart in restarts) {
[10:23:17.137]                             name <- restart$name
[10:23:17.137]                             if (is.null(name)) 
[10:23:17.137]                               next
[10:23:17.137]                             if (!grepl(pattern, name)) 
[10:23:17.137]                               next
[10:23:17.137]                             invokeRestart(restart)
[10:23:17.137]                             muffled <- TRUE
[10:23:17.137]                             break
[10:23:17.137]                           }
[10:23:17.137]                         }
[10:23:17.137]                       }
[10:23:17.137]                       invisible(muffled)
[10:23:17.137]                     }
[10:23:17.137]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.137]                   }
[10:23:17.137]                 }
[10:23:17.137]             }
[10:23:17.137]         }))
[10:23:17.137]     }, error = function(ex) {
[10:23:17.137]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.137]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.137]                 ...future.rng), started = ...future.startTime, 
[10:23:17.137]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.137]             version = "1.8"), class = "FutureResult")
[10:23:17.137]     }, finally = {
[10:23:17.137]         if (!identical(...future.workdir, getwd())) 
[10:23:17.137]             setwd(...future.workdir)
[10:23:17.137]         {
[10:23:17.137]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.137]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.137]             }
[10:23:17.137]             base::options(...future.oldOptions)
[10:23:17.137]             if (.Platform$OS.type == "windows") {
[10:23:17.137]                 old_names <- names(...future.oldEnvVars)
[10:23:17.137]                 envs <- base::Sys.getenv()
[10:23:17.137]                 names <- names(envs)
[10:23:17.137]                 common <- intersect(names, old_names)
[10:23:17.137]                 added <- setdiff(names, old_names)
[10:23:17.137]                 removed <- setdiff(old_names, names)
[10:23:17.137]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.137]                   envs[common]]
[10:23:17.137]                 NAMES <- toupper(changed)
[10:23:17.137]                 args <- list()
[10:23:17.137]                 for (kk in seq_along(NAMES)) {
[10:23:17.137]                   name <- changed[[kk]]
[10:23:17.137]                   NAME <- NAMES[[kk]]
[10:23:17.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.137]                     next
[10:23:17.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.137]                 }
[10:23:17.137]                 NAMES <- toupper(added)
[10:23:17.137]                 for (kk in seq_along(NAMES)) {
[10:23:17.137]                   name <- added[[kk]]
[10:23:17.137]                   NAME <- NAMES[[kk]]
[10:23:17.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.137]                     next
[10:23:17.137]                   args[[name]] <- ""
[10:23:17.137]                 }
[10:23:17.137]                 NAMES <- toupper(removed)
[10:23:17.137]                 for (kk in seq_along(NAMES)) {
[10:23:17.137]                   name <- removed[[kk]]
[10:23:17.137]                   NAME <- NAMES[[kk]]
[10:23:17.137]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.137]                     next
[10:23:17.137]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.137]                 }
[10:23:17.137]                 if (length(args) > 0) 
[10:23:17.137]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.137]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.137]             }
[10:23:17.137]             else {
[10:23:17.137]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.137]             }
[10:23:17.137]             {
[10:23:17.137]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.137]                   0L) {
[10:23:17.137]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.137]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.137]                   base::options(opts)
[10:23:17.137]                 }
[10:23:17.137]                 {
[10:23:17.137]                   {
[10:23:17.137]                     NULL
[10:23:17.137]                     RNGkind("Mersenne-Twister")
[10:23:17.137]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:23:17.137]                       inherits = FALSE)
[10:23:17.137]                   }
[10:23:17.137]                   options(future.plan = NULL)
[10:23:17.137]                   if (is.na(NA_character_)) 
[10:23:17.137]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.137]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.137]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.137]                     .init = FALSE)
[10:23:17.137]                 }
[10:23:17.137]             }
[10:23:17.137]         }
[10:23:17.137]     })
[10:23:17.137]     if (FALSE) {
[10:23:17.137]         base::sink(type = "output", split = FALSE)
[10:23:17.137]         if (NA) {
[10:23:17.137]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.137]         }
[10:23:17.137]         else {
[10:23:17.137]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.137]         }
[10:23:17.137]         base::close(...future.stdout)
[10:23:17.137]         ...future.stdout <- NULL
[10:23:17.137]     }
[10:23:17.137]     ...future.result$conditions <- ...future.conditions
[10:23:17.137]     ...future.result$finished <- base::Sys.time()
[10:23:17.137]     ...future.result
[10:23:17.137] }
[10:23:17.139] plan(): Setting new future strategy stack:
[10:23:17.139] List of future strategies:
[10:23:17.139] 1. sequential:
[10:23:17.139]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.139]    - tweaked: FALSE
[10:23:17.139]    - call: NULL
[10:23:17.140] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[10:23:17.141] plan(): Setting new future strategy stack:
[10:23:17.141] List of future strategies:
[10:23:17.141] 1. sequential:
[10:23:17.141]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.141]    - tweaked: FALSE
[10:23:17.141]    - call: plan(strategy)
[10:23:17.142] plan(): nbrOfWorkers() = 1
[10:23:17.142] SequentialFuture started (and completed)
[10:23:17.142] - Launch lazy future ... done
[10:23:17.142] run() for ‘SequentialFuture’ ... done
- stdout = structure(TRUE, drop = TRUE)
[10:23:17.142] getGlobalsAndPackages() ...
[10:23:17.143] Searching for globals...
[10:23:17.143] - globals found: [1] ‘print’
[10:23:17.143] Searching for globals ... DONE
[10:23:17.143] Resolving globals: FALSE
[10:23:17.143] 
[10:23:17.144] 
[10:23:17.144] getGlobalsAndPackages() ... DONE
[10:23:17.144] run() for ‘Future’ ...
[10:23:17.144] - state: ‘created’
[10:23:17.144] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:23:17.144] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:23:17.144] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:23:17.144]   - Field: ‘label’
[10:23:17.145]   - Field: ‘local’
[10:23:17.145]   - Field: ‘owner’
[10:23:17.145]   - Field: ‘envir’
[10:23:17.145]   - Field: ‘packages’
[10:23:17.145]   - Field: ‘gc’
[10:23:17.145]   - Field: ‘conditions’
[10:23:17.145]   - Field: ‘expr’
[10:23:17.145]   - Field: ‘uuid’
[10:23:17.145]   - Field: ‘seed’
[10:23:17.145]   - Field: ‘version’
[10:23:17.145]   - Field: ‘result’
[10:23:17.146]   - Field: ‘asynchronous’
[10:23:17.146]   - Field: ‘calls’
[10:23:17.146]   - Field: ‘globals’
[10:23:17.146]   - Field: ‘stdout’
[10:23:17.146]   - Field: ‘earlySignal’
[10:23:17.146]   - Field: ‘lazy’
[10:23:17.146]   - Field: ‘state’
[10:23:17.146] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:23:17.146] - Launch lazy future ...
[10:23:17.146] Packages needed by the future expression (n = 0): <none>
[10:23:17.147] Packages needed by future strategies (n = 0): <none>
[10:23:17.147] {
[10:23:17.147]     {
[10:23:17.147]         {
[10:23:17.147]             ...future.startTime <- base::Sys.time()
[10:23:17.147]             {
[10:23:17.147]                 {
[10:23:17.147]                   {
[10:23:17.147]                     base::local({
[10:23:17.147]                       has_future <- base::requireNamespace("future", 
[10:23:17.147]                         quietly = TRUE)
[10:23:17.147]                       if (has_future) {
[10:23:17.147]                         ns <- base::getNamespace("future")
[10:23:17.147]                         version <- ns[[".package"]][["version"]]
[10:23:17.147]                         if (is.null(version)) 
[10:23:17.147]                           version <- utils::packageVersion("future")
[10:23:17.147]                       }
[10:23:17.147]                       else {
[10:23:17.147]                         version <- NULL
[10:23:17.147]                       }
[10:23:17.147]                       if (!has_future || version < "1.8.0") {
[10:23:17.147]                         info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.147]                           "", base::R.version$version.string), 
[10:23:17.147]                           platform = base::sprintf("%s (%s-bit)", 
[10:23:17.147]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.147]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.147]                             "release", "version")], collapse = " "), 
[10:23:17.147]                           hostname = base::Sys.info()[["nodename"]])
[10:23:17.147]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.147]                           info)
[10:23:17.147]                         info <- base::paste(info, collapse = "; ")
[10:23:17.147]                         if (!has_future) {
[10:23:17.147]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.147]                             info)
[10:23:17.147]                         }
[10:23:17.147]                         else {
[10:23:17.147]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.147]                             info, version)
[10:23:17.147]                         }
[10:23:17.147]                         base::stop(msg)
[10:23:17.147]                       }
[10:23:17.147]                     })
[10:23:17.147]                   }
[10:23:17.147]                   ...future.strategy.old <- future::plan("list")
[10:23:17.147]                   options(future.plan = NULL)
[10:23:17.147]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.147]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.147]                 }
[10:23:17.147]                 ...future.workdir <- getwd()
[10:23:17.147]             }
[10:23:17.147]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.147]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.147]         }
[10:23:17.147]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.147]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.147]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.147]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.147]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.147]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.147]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.147]             base::names(...future.oldOptions))
[10:23:17.147]     }
[10:23:17.147]     if (FALSE) {
[10:23:17.147]     }
[10:23:17.147]     else {
[10:23:17.147]         if (TRUE) {
[10:23:17.147]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.147]                 open = "w")
[10:23:17.147]         }
[10:23:17.147]         else {
[10:23:17.147]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.147]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.147]         }
[10:23:17.147]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.147]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.147]             base::sink(type = "output", split = FALSE)
[10:23:17.147]             base::close(...future.stdout)
[10:23:17.147]         }, add = TRUE)
[10:23:17.147]     }
[10:23:17.147]     ...future.frame <- base::sys.nframe()
[10:23:17.147]     ...future.conditions <- base::list()
[10:23:17.147]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.147]     if (FALSE) {
[10:23:17.147]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.147]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.147]     }
[10:23:17.147]     ...future.result <- base::tryCatch({
[10:23:17.147]         base::withCallingHandlers({
[10:23:17.147]             ...future.value <- base::withVisible(base::local(print(42)))
[10:23:17.147]             future::FutureResult(value = ...future.value$value, 
[10:23:17.147]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.147]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.147]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.147]                     ...future.globalenv.names))
[10:23:17.147]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.147]         }, condition = base::local({
[10:23:17.147]             c <- base::c
[10:23:17.147]             inherits <- base::inherits
[10:23:17.147]             invokeRestart <- base::invokeRestart
[10:23:17.147]             length <- base::length
[10:23:17.147]             list <- base::list
[10:23:17.147]             seq.int <- base::seq.int
[10:23:17.147]             signalCondition <- base::signalCondition
[10:23:17.147]             sys.calls <- base::sys.calls
[10:23:17.147]             `[[` <- base::`[[`
[10:23:17.147]             `+` <- base::`+`
[10:23:17.147]             `<<-` <- base::`<<-`
[10:23:17.147]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.147]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.147]                   3L)]
[10:23:17.147]             }
[10:23:17.147]             function(cond) {
[10:23:17.147]                 is_error <- inherits(cond, "error")
[10:23:17.147]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.147]                   NULL)
[10:23:17.147]                 if (is_error) {
[10:23:17.147]                   sessionInformation <- function() {
[10:23:17.147]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.147]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.147]                       search = base::search(), system = base::Sys.info())
[10:23:17.147]                   }
[10:23:17.147]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.147]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.147]                     cond$call), session = sessionInformation(), 
[10:23:17.147]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.147]                   signalCondition(cond)
[10:23:17.147]                 }
[10:23:17.147]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.147]                 "immediateCondition"))) {
[10:23:17.147]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.147]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.147]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.147]                   if (TRUE && !signal) {
[10:23:17.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.147]                     {
[10:23:17.147]                       inherits <- base::inherits
[10:23:17.147]                       invokeRestart <- base::invokeRestart
[10:23:17.147]                       is.null <- base::is.null
[10:23:17.147]                       muffled <- FALSE
[10:23:17.147]                       if (inherits(cond, "message")) {
[10:23:17.147]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.147]                         if (muffled) 
[10:23:17.147]                           invokeRestart("muffleMessage")
[10:23:17.147]                       }
[10:23:17.147]                       else if (inherits(cond, "warning")) {
[10:23:17.147]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.147]                         if (muffled) 
[10:23:17.147]                           invokeRestart("muffleWarning")
[10:23:17.147]                       }
[10:23:17.147]                       else if (inherits(cond, "condition")) {
[10:23:17.147]                         if (!is.null(pattern)) {
[10:23:17.147]                           computeRestarts <- base::computeRestarts
[10:23:17.147]                           grepl <- base::grepl
[10:23:17.147]                           restarts <- computeRestarts(cond)
[10:23:17.147]                           for (restart in restarts) {
[10:23:17.147]                             name <- restart$name
[10:23:17.147]                             if (is.null(name)) 
[10:23:17.147]                               next
[10:23:17.147]                             if (!grepl(pattern, name)) 
[10:23:17.147]                               next
[10:23:17.147]                             invokeRestart(restart)
[10:23:17.147]                             muffled <- TRUE
[10:23:17.147]                             break
[10:23:17.147]                           }
[10:23:17.147]                         }
[10:23:17.147]                       }
[10:23:17.147]                       invisible(muffled)
[10:23:17.147]                     }
[10:23:17.147]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.147]                   }
[10:23:17.147]                 }
[10:23:17.147]                 else {
[10:23:17.147]                   if (TRUE) {
[10:23:17.147]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.147]                     {
[10:23:17.147]                       inherits <- base::inherits
[10:23:17.147]                       invokeRestart <- base::invokeRestart
[10:23:17.147]                       is.null <- base::is.null
[10:23:17.147]                       muffled <- FALSE
[10:23:17.147]                       if (inherits(cond, "message")) {
[10:23:17.147]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.147]                         if (muffled) 
[10:23:17.147]                           invokeRestart("muffleMessage")
[10:23:17.147]                       }
[10:23:17.147]                       else if (inherits(cond, "warning")) {
[10:23:17.147]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.147]                         if (muffled) 
[10:23:17.147]                           invokeRestart("muffleWarning")
[10:23:17.147]                       }
[10:23:17.147]                       else if (inherits(cond, "condition")) {
[10:23:17.147]                         if (!is.null(pattern)) {
[10:23:17.147]                           computeRestarts <- base::computeRestarts
[10:23:17.147]                           grepl <- base::grepl
[10:23:17.147]                           restarts <- computeRestarts(cond)
[10:23:17.147]                           for (restart in restarts) {
[10:23:17.147]                             name <- restart$name
[10:23:17.147]                             if (is.null(name)) 
[10:23:17.147]                               next
[10:23:17.147]                             if (!grepl(pattern, name)) 
[10:23:17.147]                               next
[10:23:17.147]                             invokeRestart(restart)
[10:23:17.147]                             muffled <- TRUE
[10:23:17.147]                             break
[10:23:17.147]                           }
[10:23:17.147]                         }
[10:23:17.147]                       }
[10:23:17.147]                       invisible(muffled)
[10:23:17.147]                     }
[10:23:17.147]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.147]                   }
[10:23:17.147]                 }
[10:23:17.147]             }
[10:23:17.147]         }))
[10:23:17.147]     }, error = function(ex) {
[10:23:17.147]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.147]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.147]                 ...future.rng), started = ...future.startTime, 
[10:23:17.147]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.147]             version = "1.8"), class = "FutureResult")
[10:23:17.147]     }, finally = {
[10:23:17.147]         if (!identical(...future.workdir, getwd())) 
[10:23:17.147]             setwd(...future.workdir)
[10:23:17.147]         {
[10:23:17.147]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.147]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.147]             }
[10:23:17.147]             base::options(...future.oldOptions)
[10:23:17.147]             if (.Platform$OS.type == "windows") {
[10:23:17.147]                 old_names <- names(...future.oldEnvVars)
[10:23:17.147]                 envs <- base::Sys.getenv()
[10:23:17.147]                 names <- names(envs)
[10:23:17.147]                 common <- intersect(names, old_names)
[10:23:17.147]                 added <- setdiff(names, old_names)
[10:23:17.147]                 removed <- setdiff(old_names, names)
[10:23:17.147]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.147]                   envs[common]]
[10:23:17.147]                 NAMES <- toupper(changed)
[10:23:17.147]                 args <- list()
[10:23:17.147]                 for (kk in seq_along(NAMES)) {
[10:23:17.147]                   name <- changed[[kk]]
[10:23:17.147]                   NAME <- NAMES[[kk]]
[10:23:17.147]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.147]                     next
[10:23:17.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.147]                 }
[10:23:17.147]                 NAMES <- toupper(added)
[10:23:17.147]                 for (kk in seq_along(NAMES)) {
[10:23:17.147]                   name <- added[[kk]]
[10:23:17.147]                   NAME <- NAMES[[kk]]
[10:23:17.147]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.147]                     next
[10:23:17.147]                   args[[name]] <- ""
[10:23:17.147]                 }
[10:23:17.147]                 NAMES <- toupper(removed)
[10:23:17.147]                 for (kk in seq_along(NAMES)) {
[10:23:17.147]                   name <- removed[[kk]]
[10:23:17.147]                   NAME <- NAMES[[kk]]
[10:23:17.147]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.147]                     next
[10:23:17.147]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.147]                 }
[10:23:17.147]                 if (length(args) > 0) 
[10:23:17.147]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.147]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.147]             }
[10:23:17.147]             else {
[10:23:17.147]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.147]             }
[10:23:17.147]             {
[10:23:17.147]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.147]                   0L) {
[10:23:17.147]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.147]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.147]                   base::options(opts)
[10:23:17.147]                 }
[10:23:17.147]                 {
[10:23:17.147]                   {
[10:23:17.147]                     NULL
[10:23:17.147]                     RNGkind("Mersenne-Twister")
[10:23:17.147]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:23:17.147]                       inherits = FALSE)
[10:23:17.147]                   }
[10:23:17.147]                   options(future.plan = NULL)
[10:23:17.147]                   if (is.na(NA_character_)) 
[10:23:17.147]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.147]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.147]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.147]                     .init = FALSE)
[10:23:17.147]                 }
[10:23:17.147]             }
[10:23:17.147]         }
[10:23:17.147]     })
[10:23:17.147]     if (TRUE) {
[10:23:17.147]         base::sink(type = "output", split = FALSE)
[10:23:17.147]         if (TRUE) {
[10:23:17.147]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.147]         }
[10:23:17.147]         else {
[10:23:17.147]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.147]         }
[10:23:17.147]         base::close(...future.stdout)
[10:23:17.147]         ...future.stdout <- NULL
[10:23:17.147]     }
[10:23:17.147]     ...future.result$conditions <- ...future.conditions
[10:23:17.147]     ...future.result$finished <- base::Sys.time()
[10:23:17.147]     ...future.result
[10:23:17.147] }
[10:23:17.149] plan(): Setting new future strategy stack:
[10:23:17.149] List of future strategies:
[10:23:17.149] 1. sequential:
[10:23:17.149]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.149]    - tweaked: FALSE
[10:23:17.149]    - call: NULL
[10:23:17.149] plan(): nbrOfWorkers() = 1
[10:23:17.150] plan(): Setting new future strategy stack:
[10:23:17.150] List of future strategies:
[10:23:17.150] 1. sequential:
[10:23:17.150]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.150]    - tweaked: FALSE
[10:23:17.150]    - call: plan(strategy)
[10:23:17.150] plan(): nbrOfWorkers() = 1
[10:23:17.151] SequentialFuture started (and completed)
[10:23:17.151] - Launch lazy future ... done
[10:23:17.151] run() for ‘SequentialFuture’ ... done
[1] 42
sequential ... done
Testing with 1 cores ... done
Testing with 2 cores ...
multicore ...
[10:23:17.158] plan(): Setting new future strategy stack:
[10:23:17.158] List of future strategies:
[10:23:17.158] 1. multicore:
[10:23:17.158]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.158]    - tweaked: FALSE
[10:23:17.158]    - call: plan(strategy)
[10:23:17.160] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[10:23:17.160] getGlobalsAndPackages() ...
[10:23:17.160] Searching for globals...
[10:23:17.163] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.163] Searching for globals ... DONE
[10:23:17.163] Resolving globals: FALSE
[10:23:17.164] 
[10:23:17.164] - packages: [1] ‘utils’
[10:23:17.164] getGlobalsAndPackages() ... DONE
[10:23:17.164] run() for ‘Future’ ...
[10:23:17.164] - state: ‘created’
[10:23:17.164] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:23:17.166] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:17.166] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:23:17.166]   - Field: ‘label’
[10:23:17.166]   - Field: ‘local’
[10:23:17.166]   - Field: ‘owner’
[10:23:17.166]   - Field: ‘envir’
[10:23:17.167]   - Field: ‘workers’
[10:23:17.167]   - Field: ‘packages’
[10:23:17.167]   - Field: ‘gc’
[10:23:17.167]   - Field: ‘job’
[10:23:17.167]   - Field: ‘conditions’
[10:23:17.167]   - Field: ‘expr’
[10:23:17.167]   - Field: ‘uuid’
[10:23:17.167]   - Field: ‘seed’
[10:23:17.167]   - Field: ‘version’
[10:23:17.167]   - Field: ‘result’
[10:23:17.167]   - Field: ‘asynchronous’
[10:23:17.168]   - Field: ‘calls’
[10:23:17.168]   - Field: ‘globals’
[10:23:17.168]   - Field: ‘stdout’
[10:23:17.168]   - Field: ‘earlySignal’
[10:23:17.168]   - Field: ‘lazy’
[10:23:17.168]   - Field: ‘state’
[10:23:17.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:23:17.168] - Launch lazy future ...
[10:23:17.169] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.169] Packages needed by future strategies (n = 0): <none>
[10:23:17.170] {
[10:23:17.170]     {
[10:23:17.170]         {
[10:23:17.170]             ...future.startTime <- base::Sys.time()
[10:23:17.170]             {
[10:23:17.170]                 {
[10:23:17.170]                   {
[10:23:17.170]                     {
[10:23:17.170]                       {
[10:23:17.170]                         base::local({
[10:23:17.170]                           has_future <- base::requireNamespace("future", 
[10:23:17.170]                             quietly = TRUE)
[10:23:17.170]                           if (has_future) {
[10:23:17.170]                             ns <- base::getNamespace("future")
[10:23:17.170]                             version <- ns[[".package"]][["version"]]
[10:23:17.170]                             if (is.null(version)) 
[10:23:17.170]                               version <- utils::packageVersion("future")
[10:23:17.170]                           }
[10:23:17.170]                           else {
[10:23:17.170]                             version <- NULL
[10:23:17.170]                           }
[10:23:17.170]                           if (!has_future || version < "1.8.0") {
[10:23:17.170]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.170]                               "", base::R.version$version.string), 
[10:23:17.170]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:17.170]                                 base::R.version$platform, 8 * 
[10:23:17.170]                                   base::.Machine$sizeof.pointer), 
[10:23:17.170]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.170]                                 "release", "version")], collapse = " "), 
[10:23:17.170]                               hostname = base::Sys.info()[["nodename"]])
[10:23:17.170]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.170]                               info)
[10:23:17.170]                             info <- base::paste(info, collapse = "; ")
[10:23:17.170]                             if (!has_future) {
[10:23:17.170]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.170]                                 info)
[10:23:17.170]                             }
[10:23:17.170]                             else {
[10:23:17.170]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.170]                                 info, version)
[10:23:17.170]                             }
[10:23:17.170]                             base::stop(msg)
[10:23:17.170]                           }
[10:23:17.170]                         })
[10:23:17.170]                       }
[10:23:17.170]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.170]                       base::options(mc.cores = 1L)
[10:23:17.170]                     }
[10:23:17.170]                     base::local({
[10:23:17.170]                       for (pkg in "utils") {
[10:23:17.170]                         base::loadNamespace(pkg)
[10:23:17.170]                         base::library(pkg, character.only = TRUE)
[10:23:17.170]                       }
[10:23:17.170]                     })
[10:23:17.170]                   }
[10:23:17.170]                   ...future.strategy.old <- future::plan("list")
[10:23:17.170]                   options(future.plan = NULL)
[10:23:17.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.170]                 }
[10:23:17.170]                 ...future.workdir <- getwd()
[10:23:17.170]             }
[10:23:17.170]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.170]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.170]         }
[10:23:17.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.170]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.170]             base::names(...future.oldOptions))
[10:23:17.170]     }
[10:23:17.170]     if (FALSE) {
[10:23:17.170]     }
[10:23:17.170]     else {
[10:23:17.170]         if (TRUE) {
[10:23:17.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.170]                 open = "w")
[10:23:17.170]         }
[10:23:17.170]         else {
[10:23:17.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.170]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.170]         }
[10:23:17.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.170]             base::sink(type = "output", split = FALSE)
[10:23:17.170]             base::close(...future.stdout)
[10:23:17.170]         }, add = TRUE)
[10:23:17.170]     }
[10:23:17.170]     ...future.frame <- base::sys.nframe()
[10:23:17.170]     ...future.conditions <- base::list()
[10:23:17.170]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.170]     if (FALSE) {
[10:23:17.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.170]     }
[10:23:17.170]     ...future.result <- base::tryCatch({
[10:23:17.170]         base::withCallingHandlers({
[10:23:17.170]             ...future.value <- base::withVisible(base::local({
[10:23:17.170]                 withCallingHandlers({
[10:23:17.170]                   {
[10:23:17.170]                     print(1:50)
[10:23:17.170]                     str(1:50)
[10:23:17.170]                     cat(letters, sep = "-")
[10:23:17.170]                     cat(1:6, collapse = "\n")
[10:23:17.170]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.170]                     42L
[10:23:17.170]                   }
[10:23:17.170]                 }, immediateCondition = function(cond) {
[10:23:17.170]                   save_rds <- function (object, pathname, ...) 
[10:23:17.170]                   {
[10:23:17.170]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:23:17.170]                     if (file_test("-f", pathname_tmp)) {
[10:23:17.170]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.170]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:23:17.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.170]                         fi_tmp[["mtime"]])
[10:23:17.170]                     }
[10:23:17.170]                     tryCatch({
[10:23:17.170]                       saveRDS(object, file = pathname_tmp, ...)
[10:23:17.170]                     }, error = function(ex) {
[10:23:17.170]                       msg <- conditionMessage(ex)
[10:23:17.170]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.170]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:23:17.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.170]                         fi_tmp[["mtime"]], msg)
[10:23:17.170]                       ex$message <- msg
[10:23:17.170]                       stop(ex)
[10:23:17.170]                     })
[10:23:17.170]                     stopifnot(file_test("-f", pathname_tmp))
[10:23:17.170]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:23:17.170]                     if (!res || file_test("-f", pathname_tmp)) {
[10:23:17.170]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.170]                       fi <- file.info(pathname)
[10:23:17.170]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:23:17.170]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.170]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:23:17.170]                         fi[["size"]], fi[["mtime"]])
[10:23:17.170]                       stop(msg)
[10:23:17.170]                     }
[10:23:17.170]                     invisible(pathname)
[10:23:17.170]                   }
[10:23:17.170]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:23:17.170]                     rootPath = tempdir()) 
[10:23:17.170]                   {
[10:23:17.170]                     obj <- list(time = Sys.time(), condition = cond)
[10:23:17.170]                     file <- tempfile(pattern = class(cond)[1], 
[10:23:17.170]                       tmpdir = path, fileext = ".rds")
[10:23:17.170]                     save_rds(obj, file)
[10:23:17.170]                   }
[10:23:17.170]                   saveImmediateCondition(cond, path = "/tmp/RtmpQSLptV/.future/immediateConditions")
[10:23:17.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.170]                   {
[10:23:17.170]                     inherits <- base::inherits
[10:23:17.170]                     invokeRestart <- base::invokeRestart
[10:23:17.170]                     is.null <- base::is.null
[10:23:17.170]                     muffled <- FALSE
[10:23:17.170]                     if (inherits(cond, "message")) {
[10:23:17.170]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.170]                       if (muffled) 
[10:23:17.170]                         invokeRestart("muffleMessage")
[10:23:17.170]                     }
[10:23:17.170]                     else if (inherits(cond, "warning")) {
[10:23:17.170]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.170]                       if (muffled) 
[10:23:17.170]                         invokeRestart("muffleWarning")
[10:23:17.170]                     }
[10:23:17.170]                     else if (inherits(cond, "condition")) {
[10:23:17.170]                       if (!is.null(pattern)) {
[10:23:17.170]                         computeRestarts <- base::computeRestarts
[10:23:17.170]                         grepl <- base::grepl
[10:23:17.170]                         restarts <- computeRestarts(cond)
[10:23:17.170]                         for (restart in restarts) {
[10:23:17.170]                           name <- restart$name
[10:23:17.170]                           if (is.null(name)) 
[10:23:17.170]                             next
[10:23:17.170]                           if (!grepl(pattern, name)) 
[10:23:17.170]                             next
[10:23:17.170]                           invokeRestart(restart)
[10:23:17.170]                           muffled <- TRUE
[10:23:17.170]                           break
[10:23:17.170]                         }
[10:23:17.170]                       }
[10:23:17.170]                     }
[10:23:17.170]                     invisible(muffled)
[10:23:17.170]                   }
[10:23:17.170]                   muffleCondition(cond)
[10:23:17.170]                 })
[10:23:17.170]             }))
[10:23:17.170]             future::FutureResult(value = ...future.value$value, 
[10:23:17.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.170]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.170]                     ...future.globalenv.names))
[10:23:17.170]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.170]         }, condition = base::local({
[10:23:17.170]             c <- base::c
[10:23:17.170]             inherits <- base::inherits
[10:23:17.170]             invokeRestart <- base::invokeRestart
[10:23:17.170]             length <- base::length
[10:23:17.170]             list <- base::list
[10:23:17.170]             seq.int <- base::seq.int
[10:23:17.170]             signalCondition <- base::signalCondition
[10:23:17.170]             sys.calls <- base::sys.calls
[10:23:17.170]             `[[` <- base::`[[`
[10:23:17.170]             `+` <- base::`+`
[10:23:17.170]             `<<-` <- base::`<<-`
[10:23:17.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.170]                   3L)]
[10:23:17.170]             }
[10:23:17.170]             function(cond) {
[10:23:17.170]                 is_error <- inherits(cond, "error")
[10:23:17.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.170]                   NULL)
[10:23:17.170]                 if (is_error) {
[10:23:17.170]                   sessionInformation <- function() {
[10:23:17.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.170]                       search = base::search(), system = base::Sys.info())
[10:23:17.170]                   }
[10:23:17.170]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.170]                     cond$call), session = sessionInformation(), 
[10:23:17.170]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.170]                   signalCondition(cond)
[10:23:17.170]                 }
[10:23:17.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.170]                 "immediateCondition"))) {
[10:23:17.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.170]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.170]                   if (TRUE && !signal) {
[10:23:17.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.170]                     {
[10:23:17.170]                       inherits <- base::inherits
[10:23:17.170]                       invokeRestart <- base::invokeRestart
[10:23:17.170]                       is.null <- base::is.null
[10:23:17.170]                       muffled <- FALSE
[10:23:17.170]                       if (inherits(cond, "message")) {
[10:23:17.170]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.170]                         if (muffled) 
[10:23:17.170]                           invokeRestart("muffleMessage")
[10:23:17.170]                       }
[10:23:17.170]                       else if (inherits(cond, "warning")) {
[10:23:17.170]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.170]                         if (muffled) 
[10:23:17.170]                           invokeRestart("muffleWarning")
[10:23:17.170]                       }
[10:23:17.170]                       else if (inherits(cond, "condition")) {
[10:23:17.170]                         if (!is.null(pattern)) {
[10:23:17.170]                           computeRestarts <- base::computeRestarts
[10:23:17.170]                           grepl <- base::grepl
[10:23:17.170]                           restarts <- computeRestarts(cond)
[10:23:17.170]                           for (restart in restarts) {
[10:23:17.170]                             name <- restart$name
[10:23:17.170]                             if (is.null(name)) 
[10:23:17.170]                               next
[10:23:17.170]                             if (!grepl(pattern, name)) 
[10:23:17.170]                               next
[10:23:17.170]                             invokeRestart(restart)
[10:23:17.170]                             muffled <- TRUE
[10:23:17.170]                             break
[10:23:17.170]                           }
[10:23:17.170]                         }
[10:23:17.170]                       }
[10:23:17.170]                       invisible(muffled)
[10:23:17.170]                     }
[10:23:17.170]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.170]                   }
[10:23:17.170]                 }
[10:23:17.170]                 else {
[10:23:17.170]                   if (TRUE) {
[10:23:17.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.170]                     {
[10:23:17.170]                       inherits <- base::inherits
[10:23:17.170]                       invokeRestart <- base::invokeRestart
[10:23:17.170]                       is.null <- base::is.null
[10:23:17.170]                       muffled <- FALSE
[10:23:17.170]                       if (inherits(cond, "message")) {
[10:23:17.170]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.170]                         if (muffled) 
[10:23:17.170]                           invokeRestart("muffleMessage")
[10:23:17.170]                       }
[10:23:17.170]                       else if (inherits(cond, "warning")) {
[10:23:17.170]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.170]                         if (muffled) 
[10:23:17.170]                           invokeRestart("muffleWarning")
[10:23:17.170]                       }
[10:23:17.170]                       else if (inherits(cond, "condition")) {
[10:23:17.170]                         if (!is.null(pattern)) {
[10:23:17.170]                           computeRestarts <- base::computeRestarts
[10:23:17.170]                           grepl <- base::grepl
[10:23:17.170]                           restarts <- computeRestarts(cond)
[10:23:17.170]                           for (restart in restarts) {
[10:23:17.170]                             name <- restart$name
[10:23:17.170]                             if (is.null(name)) 
[10:23:17.170]                               next
[10:23:17.170]                             if (!grepl(pattern, name)) 
[10:23:17.170]                               next
[10:23:17.170]                             invokeRestart(restart)
[10:23:17.170]                             muffled <- TRUE
[10:23:17.170]                             break
[10:23:17.170]                           }
[10:23:17.170]                         }
[10:23:17.170]                       }
[10:23:17.170]                       invisible(muffled)
[10:23:17.170]                     }
[10:23:17.170]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.170]                   }
[10:23:17.170]                 }
[10:23:17.170]             }
[10:23:17.170]         }))
[10:23:17.170]     }, error = function(ex) {
[10:23:17.170]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.170]                 ...future.rng), started = ...future.startTime, 
[10:23:17.170]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.170]             version = "1.8"), class = "FutureResult")
[10:23:17.170]     }, finally = {
[10:23:17.170]         if (!identical(...future.workdir, getwd())) 
[10:23:17.170]             setwd(...future.workdir)
[10:23:17.170]         {
[10:23:17.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.170]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.170]             }
[10:23:17.170]             base::options(...future.oldOptions)
[10:23:17.170]             if (.Platform$OS.type == "windows") {
[10:23:17.170]                 old_names <- names(...future.oldEnvVars)
[10:23:17.170]                 envs <- base::Sys.getenv()
[10:23:17.170]                 names <- names(envs)
[10:23:17.170]                 common <- intersect(names, old_names)
[10:23:17.170]                 added <- setdiff(names, old_names)
[10:23:17.170]                 removed <- setdiff(old_names, names)
[10:23:17.170]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.170]                   envs[common]]
[10:23:17.170]                 NAMES <- toupper(changed)
[10:23:17.170]                 args <- list()
[10:23:17.170]                 for (kk in seq_along(NAMES)) {
[10:23:17.170]                   name <- changed[[kk]]
[10:23:17.170]                   NAME <- NAMES[[kk]]
[10:23:17.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.170]                     next
[10:23:17.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.170]                 }
[10:23:17.170]                 NAMES <- toupper(added)
[10:23:17.170]                 for (kk in seq_along(NAMES)) {
[10:23:17.170]                   name <- added[[kk]]
[10:23:17.170]                   NAME <- NAMES[[kk]]
[10:23:17.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.170]                     next
[10:23:17.170]                   args[[name]] <- ""
[10:23:17.170]                 }
[10:23:17.170]                 NAMES <- toupper(removed)
[10:23:17.170]                 for (kk in seq_along(NAMES)) {
[10:23:17.170]                   name <- removed[[kk]]
[10:23:17.170]                   NAME <- NAMES[[kk]]
[10:23:17.170]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.170]                     next
[10:23:17.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.170]                 }
[10:23:17.170]                 if (length(args) > 0) 
[10:23:17.170]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.170]             }
[10:23:17.170]             else {
[10:23:17.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.170]             }
[10:23:17.170]             {
[10:23:17.170]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.170]                   0L) {
[10:23:17.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.170]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.170]                   base::options(opts)
[10:23:17.170]                 }
[10:23:17.170]                 {
[10:23:17.170]                   {
[10:23:17.170]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.170]                     NULL
[10:23:17.170]                   }
[10:23:17.170]                   options(future.plan = NULL)
[10:23:17.170]                   if (is.na(NA_character_)) 
[10:23:17.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.170]                     .init = FALSE)
[10:23:17.170]                 }
[10:23:17.170]             }
[10:23:17.170]         }
[10:23:17.170]     })
[10:23:17.170]     if (TRUE) {
[10:23:17.170]         base::sink(type = "output", split = FALSE)
[10:23:17.170]         if (TRUE) {
[10:23:17.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.170]         }
[10:23:17.170]         else {
[10:23:17.170]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.170]         }
[10:23:17.170]         base::close(...future.stdout)
[10:23:17.170]         ...future.stdout <- NULL
[10:23:17.170]     }
[10:23:17.170]     ...future.result$conditions <- ...future.conditions
[10:23:17.170]     ...future.result$finished <- base::Sys.time()
[10:23:17.170]     ...future.result
[10:23:17.170] }
[10:23:17.172] requestCore(): workers = 2
[10:23:17.175] MulticoreFuture started
[10:23:17.175] - Launch lazy future ... done
[10:23:17.176] run() for ‘MulticoreFuture’ ... done
[10:23:17.176] plan(): Setting new future strategy stack:
[10:23:17.177] result() for MulticoreFuture ...
[10:23:17.176] List of future strategies:
[10:23:17.176] 1. sequential:
[10:23:17.176]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.176]    - tweaked: FALSE
[10:23:17.176]    - call: NULL
[10:23:17.177] plan(): nbrOfWorkers() = 1
[10:23:17.181] plan(): Setting new future strategy stack:
[10:23:17.181] List of future strategies:
[10:23:17.181] 1. multicore:
[10:23:17.181]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.181]    - tweaked: FALSE
[10:23:17.181]    - call: plan(strategy)
[10:23:17.184] plan(): nbrOfWorkers() = 2
[10:23:17.189] result() for MulticoreFuture ...
[10:23:17.189] result() for MulticoreFuture ... done
[10:23:17.189] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ finished    : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ session_uuid: chr "4693938e-8257-0368-c9c6-1083dce94569"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "eec1919a6b51"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 86303
  .. ..$ time  : POSIXct[1:1], format: "2025-11-19 10:23:17"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:23:17.201] result() for MulticoreFuture ...
[10:23:17.201] result() for MulticoreFuture ... done
[10:23:17.201] result() for MulticoreFuture ...
[10:23:17.201] result() for MulticoreFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.009314537 secs (started 2025-11-19 10:23:17.17546)
version: 1.8
[10:23:17.202] getGlobalsAndPackages() ...
[10:23:17.202] Searching for globals...
[10:23:17.206] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.206] Searching for globals ... DONE
[10:23:17.207] Resolving globals: FALSE
[10:23:17.207] 
[10:23:17.207] - packages: [1] ‘utils’
[10:23:17.207] getGlobalsAndPackages() ... DONE
[10:23:17.208] run() for ‘Future’ ...
[10:23:17.208] - state: ‘created’
[10:23:17.208] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:23:17.210] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:17.210] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:23:17.210]   - Field: ‘label’
[10:23:17.210]   - Field: ‘local’
[10:23:17.211]   - Field: ‘owner’
[10:23:17.211]   - Field: ‘envir’
[10:23:17.211]   - Field: ‘workers’
[10:23:17.211]   - Field: ‘packages’
[10:23:17.211]   - Field: ‘gc’
[10:23:17.211]   - Field: ‘job’
[10:23:17.211]   - Field: ‘conditions’
[10:23:17.211]   - Field: ‘expr’
[10:23:17.211]   - Field: ‘uuid’
[10:23:17.212]   - Field: ‘seed’
[10:23:17.212]   - Field: ‘version’
[10:23:17.212]   - Field: ‘result’
[10:23:17.212]   - Field: ‘asynchronous’
[10:23:17.212]   - Field: ‘calls’
[10:23:17.212]   - Field: ‘globals’
[10:23:17.212]   - Field: ‘stdout’
[10:23:17.212]   - Field: ‘earlySignal’
[10:23:17.212]   - Field: ‘lazy’
[10:23:17.213]   - Field: ‘state’
[10:23:17.213] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:23:17.213] - Launch lazy future ...
[10:23:17.213] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.213] Packages needed by future strategies (n = 0): <none>
[10:23:17.214] {
[10:23:17.214]     {
[10:23:17.214]         {
[10:23:17.214]             ...future.startTime <- base::Sys.time()
[10:23:17.214]             {
[10:23:17.214]                 {
[10:23:17.214]                   {
[10:23:17.214]                     {
[10:23:17.214]                       {
[10:23:17.214]                         base::local({
[10:23:17.214]                           has_future <- base::requireNamespace("future", 
[10:23:17.214]                             quietly = TRUE)
[10:23:17.214]                           if (has_future) {
[10:23:17.214]                             ns <- base::getNamespace("future")
[10:23:17.214]                             version <- ns[[".package"]][["version"]]
[10:23:17.214]                             if (is.null(version)) 
[10:23:17.214]                               version <- utils::packageVersion("future")
[10:23:17.214]                           }
[10:23:17.214]                           else {
[10:23:17.214]                             version <- NULL
[10:23:17.214]                           }
[10:23:17.214]                           if (!has_future || version < "1.8.0") {
[10:23:17.214]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.214]                               "", base::R.version$version.string), 
[10:23:17.214]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:17.214]                                 base::R.version$platform, 8 * 
[10:23:17.214]                                   base::.Machine$sizeof.pointer), 
[10:23:17.214]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.214]                                 "release", "version")], collapse = " "), 
[10:23:17.214]                               hostname = base::Sys.info()[["nodename"]])
[10:23:17.214]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.214]                               info)
[10:23:17.214]                             info <- base::paste(info, collapse = "; ")
[10:23:17.214]                             if (!has_future) {
[10:23:17.214]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.214]                                 info)
[10:23:17.214]                             }
[10:23:17.214]                             else {
[10:23:17.214]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.214]                                 info, version)
[10:23:17.214]                             }
[10:23:17.214]                             base::stop(msg)
[10:23:17.214]                           }
[10:23:17.214]                         })
[10:23:17.214]                       }
[10:23:17.214]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.214]                       base::options(mc.cores = 1L)
[10:23:17.214]                     }
[10:23:17.214]                     base::local({
[10:23:17.214]                       for (pkg in "utils") {
[10:23:17.214]                         base::loadNamespace(pkg)
[10:23:17.214]                         base::library(pkg, character.only = TRUE)
[10:23:17.214]                       }
[10:23:17.214]                     })
[10:23:17.214]                   }
[10:23:17.214]                   ...future.strategy.old <- future::plan("list")
[10:23:17.214]                   options(future.plan = NULL)
[10:23:17.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.214]                 }
[10:23:17.214]                 ...future.workdir <- getwd()
[10:23:17.214]             }
[10:23:17.214]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.214]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.214]         }
[10:23:17.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.214]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.214]             base::names(...future.oldOptions))
[10:23:17.214]     }
[10:23:17.214]     if (FALSE) {
[10:23:17.214]     }
[10:23:17.214]     else {
[10:23:17.214]         if (TRUE) {
[10:23:17.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.214]                 open = "w")
[10:23:17.214]         }
[10:23:17.214]         else {
[10:23:17.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.214]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.214]         }
[10:23:17.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.214]             base::sink(type = "output", split = FALSE)
[10:23:17.214]             base::close(...future.stdout)
[10:23:17.214]         }, add = TRUE)
[10:23:17.214]     }
[10:23:17.214]     ...future.frame <- base::sys.nframe()
[10:23:17.214]     ...future.conditions <- base::list()
[10:23:17.214]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.214]     if (FALSE) {
[10:23:17.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.214]     }
[10:23:17.214]     ...future.result <- base::tryCatch({
[10:23:17.214]         base::withCallingHandlers({
[10:23:17.214]             ...future.value <- base::withVisible(base::local({
[10:23:17.214]                 withCallingHandlers({
[10:23:17.214]                   {
[10:23:17.214]                     print(1:50)
[10:23:17.214]                     str(1:50)
[10:23:17.214]                     cat(letters, sep = "-")
[10:23:17.214]                     cat(1:6, collapse = "\n")
[10:23:17.214]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.214]                     42L
[10:23:17.214]                   }
[10:23:17.214]                 }, immediateCondition = function(cond) {
[10:23:17.214]                   save_rds <- function (object, pathname, ...) 
[10:23:17.214]                   {
[10:23:17.214]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:23:17.214]                     if (file_test("-f", pathname_tmp)) {
[10:23:17.214]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.214]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:23:17.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.214]                         fi_tmp[["mtime"]])
[10:23:17.214]                     }
[10:23:17.214]                     tryCatch({
[10:23:17.214]                       saveRDS(object, file = pathname_tmp, ...)
[10:23:17.214]                     }, error = function(ex) {
[10:23:17.214]                       msg <- conditionMessage(ex)
[10:23:17.214]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.214]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:23:17.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.214]                         fi_tmp[["mtime"]], msg)
[10:23:17.214]                       ex$message <- msg
[10:23:17.214]                       stop(ex)
[10:23:17.214]                     })
[10:23:17.214]                     stopifnot(file_test("-f", pathname_tmp))
[10:23:17.214]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:23:17.214]                     if (!res || file_test("-f", pathname_tmp)) {
[10:23:17.214]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.214]                       fi <- file.info(pathname)
[10:23:17.214]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:23:17.214]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.214]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:23:17.214]                         fi[["size"]], fi[["mtime"]])
[10:23:17.214]                       stop(msg)
[10:23:17.214]                     }
[10:23:17.214]                     invisible(pathname)
[10:23:17.214]                   }
[10:23:17.214]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:23:17.214]                     rootPath = tempdir()) 
[10:23:17.214]                   {
[10:23:17.214]                     obj <- list(time = Sys.time(), condition = cond)
[10:23:17.214]                     file <- tempfile(pattern = class(cond)[1], 
[10:23:17.214]                       tmpdir = path, fileext = ".rds")
[10:23:17.214]                     save_rds(obj, file)
[10:23:17.214]                   }
[10:23:17.214]                   saveImmediateCondition(cond, path = "/tmp/RtmpQSLptV/.future/immediateConditions")
[10:23:17.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.214]                   {
[10:23:17.214]                     inherits <- base::inherits
[10:23:17.214]                     invokeRestart <- base::invokeRestart
[10:23:17.214]                     is.null <- base::is.null
[10:23:17.214]                     muffled <- FALSE
[10:23:17.214]                     if (inherits(cond, "message")) {
[10:23:17.214]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.214]                       if (muffled) 
[10:23:17.214]                         invokeRestart("muffleMessage")
[10:23:17.214]                     }
[10:23:17.214]                     else if (inherits(cond, "warning")) {
[10:23:17.214]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.214]                       if (muffled) 
[10:23:17.214]                         invokeRestart("muffleWarning")
[10:23:17.214]                     }
[10:23:17.214]                     else if (inherits(cond, "condition")) {
[10:23:17.214]                       if (!is.null(pattern)) {
[10:23:17.214]                         computeRestarts <- base::computeRestarts
[10:23:17.214]                         grepl <- base::grepl
[10:23:17.214]                         restarts <- computeRestarts(cond)
[10:23:17.214]                         for (restart in restarts) {
[10:23:17.214]                           name <- restart$name
[10:23:17.214]                           if (is.null(name)) 
[10:23:17.214]                             next
[10:23:17.214]                           if (!grepl(pattern, name)) 
[10:23:17.214]                             next
[10:23:17.214]                           invokeRestart(restart)
[10:23:17.214]                           muffled <- TRUE
[10:23:17.214]                           break
[10:23:17.214]                         }
[10:23:17.214]                       }
[10:23:17.214]                     }
[10:23:17.214]                     invisible(muffled)
[10:23:17.214]                   }
[10:23:17.214]                   muffleCondition(cond)
[10:23:17.214]                 })
[10:23:17.214]             }))
[10:23:17.214]             future::FutureResult(value = ...future.value$value, 
[10:23:17.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.214]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.214]                     ...future.globalenv.names))
[10:23:17.214]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.214]         }, condition = base::local({
[10:23:17.214]             c <- base::c
[10:23:17.214]             inherits <- base::inherits
[10:23:17.214]             invokeRestart <- base::invokeRestart
[10:23:17.214]             length <- base::length
[10:23:17.214]             list <- base::list
[10:23:17.214]             seq.int <- base::seq.int
[10:23:17.214]             signalCondition <- base::signalCondition
[10:23:17.214]             sys.calls <- base::sys.calls
[10:23:17.214]             `[[` <- base::`[[`
[10:23:17.214]             `+` <- base::`+`
[10:23:17.214]             `<<-` <- base::`<<-`
[10:23:17.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.214]                   3L)]
[10:23:17.214]             }
[10:23:17.214]             function(cond) {
[10:23:17.214]                 is_error <- inherits(cond, "error")
[10:23:17.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.214]                   NULL)
[10:23:17.214]                 if (is_error) {
[10:23:17.214]                   sessionInformation <- function() {
[10:23:17.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.214]                       search = base::search(), system = base::Sys.info())
[10:23:17.214]                   }
[10:23:17.214]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.214]                     cond$call), session = sessionInformation(), 
[10:23:17.214]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.214]                   signalCondition(cond)
[10:23:17.214]                 }
[10:23:17.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.214]                 "immediateCondition"))) {
[10:23:17.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.214]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.214]                   if (TRUE && !signal) {
[10:23:17.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.214]                     {
[10:23:17.214]                       inherits <- base::inherits
[10:23:17.214]                       invokeRestart <- base::invokeRestart
[10:23:17.214]                       is.null <- base::is.null
[10:23:17.214]                       muffled <- FALSE
[10:23:17.214]                       if (inherits(cond, "message")) {
[10:23:17.214]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.214]                         if (muffled) 
[10:23:17.214]                           invokeRestart("muffleMessage")
[10:23:17.214]                       }
[10:23:17.214]                       else if (inherits(cond, "warning")) {
[10:23:17.214]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.214]                         if (muffled) 
[10:23:17.214]                           invokeRestart("muffleWarning")
[10:23:17.214]                       }
[10:23:17.214]                       else if (inherits(cond, "condition")) {
[10:23:17.214]                         if (!is.null(pattern)) {
[10:23:17.214]                           computeRestarts <- base::computeRestarts
[10:23:17.214]                           grepl <- base::grepl
[10:23:17.214]                           restarts <- computeRestarts(cond)
[10:23:17.214]                           for (restart in restarts) {
[10:23:17.214]                             name <- restart$name
[10:23:17.214]                             if (is.null(name)) 
[10:23:17.214]                               next
[10:23:17.214]                             if (!grepl(pattern, name)) 
[10:23:17.214]                               next
[10:23:17.214]                             invokeRestart(restart)
[10:23:17.214]                             muffled <- TRUE
[10:23:17.214]                             break
[10:23:17.214]                           }
[10:23:17.214]                         }
[10:23:17.214]                       }
[10:23:17.214]                       invisible(muffled)
[10:23:17.214]                     }
[10:23:17.214]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.214]                   }
[10:23:17.214]                 }
[10:23:17.214]                 else {
[10:23:17.214]                   if (TRUE) {
[10:23:17.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.214]                     {
[10:23:17.214]                       inherits <- base::inherits
[10:23:17.214]                       invokeRestart <- base::invokeRestart
[10:23:17.214]                       is.null <- base::is.null
[10:23:17.214]                       muffled <- FALSE
[10:23:17.214]                       if (inherits(cond, "message")) {
[10:23:17.214]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.214]                         if (muffled) 
[10:23:17.214]                           invokeRestart("muffleMessage")
[10:23:17.214]                       }
[10:23:17.214]                       else if (inherits(cond, "warning")) {
[10:23:17.214]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.214]                         if (muffled) 
[10:23:17.214]                           invokeRestart("muffleWarning")
[10:23:17.214]                       }
[10:23:17.214]                       else if (inherits(cond, "condition")) {
[10:23:17.214]                         if (!is.null(pattern)) {
[10:23:17.214]                           computeRestarts <- base::computeRestarts
[10:23:17.214]                           grepl <- base::grepl
[10:23:17.214]                           restarts <- computeRestarts(cond)
[10:23:17.214]                           for (restart in restarts) {
[10:23:17.214]                             name <- restart$name
[10:23:17.214]                             if (is.null(name)) 
[10:23:17.214]                               next
[10:23:17.214]                             if (!grepl(pattern, name)) 
[10:23:17.214]                               next
[10:23:17.214]                             invokeRestart(restart)
[10:23:17.214]                             muffled <- TRUE
[10:23:17.214]                             break
[10:23:17.214]                           }
[10:23:17.214]                         }
[10:23:17.214]                       }
[10:23:17.214]                       invisible(muffled)
[10:23:17.214]                     }
[10:23:17.214]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.214]                   }
[10:23:17.214]                 }
[10:23:17.214]             }
[10:23:17.214]         }))
[10:23:17.214]     }, error = function(ex) {
[10:23:17.214]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.214]                 ...future.rng), started = ...future.startTime, 
[10:23:17.214]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.214]             version = "1.8"), class = "FutureResult")
[10:23:17.214]     }, finally = {
[10:23:17.214]         if (!identical(...future.workdir, getwd())) 
[10:23:17.214]             setwd(...future.workdir)
[10:23:17.214]         {
[10:23:17.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.214]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.214]             }
[10:23:17.214]             base::options(...future.oldOptions)
[10:23:17.214]             if (.Platform$OS.type == "windows") {
[10:23:17.214]                 old_names <- names(...future.oldEnvVars)
[10:23:17.214]                 envs <- base::Sys.getenv()
[10:23:17.214]                 names <- names(envs)
[10:23:17.214]                 common <- intersect(names, old_names)
[10:23:17.214]                 added <- setdiff(names, old_names)
[10:23:17.214]                 removed <- setdiff(old_names, names)
[10:23:17.214]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.214]                   envs[common]]
[10:23:17.214]                 NAMES <- toupper(changed)
[10:23:17.214]                 args <- list()
[10:23:17.214]                 for (kk in seq_along(NAMES)) {
[10:23:17.214]                   name <- changed[[kk]]
[10:23:17.214]                   NAME <- NAMES[[kk]]
[10:23:17.214]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.214]                     next
[10:23:17.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.214]                 }
[10:23:17.214]                 NAMES <- toupper(added)
[10:23:17.214]                 for (kk in seq_along(NAMES)) {
[10:23:17.214]                   name <- added[[kk]]
[10:23:17.214]                   NAME <- NAMES[[kk]]
[10:23:17.214]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.214]                     next
[10:23:17.214]                   args[[name]] <- ""
[10:23:17.214]                 }
[10:23:17.214]                 NAMES <- toupper(removed)
[10:23:17.214]                 for (kk in seq_along(NAMES)) {
[10:23:17.214]                   name <- removed[[kk]]
[10:23:17.214]                   NAME <- NAMES[[kk]]
[10:23:17.214]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.214]                     next
[10:23:17.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.214]                 }
[10:23:17.214]                 if (length(args) > 0) 
[10:23:17.214]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.214]             }
[10:23:17.214]             else {
[10:23:17.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.214]             }
[10:23:17.214]             {
[10:23:17.214]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.214]                   0L) {
[10:23:17.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.214]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.214]                   base::options(opts)
[10:23:17.214]                 }
[10:23:17.214]                 {
[10:23:17.214]                   {
[10:23:17.214]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.214]                     NULL
[10:23:17.214]                   }
[10:23:17.214]                   options(future.plan = NULL)
[10:23:17.214]                   if (is.na(NA_character_)) 
[10:23:17.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.214]                     .init = FALSE)
[10:23:17.214]                 }
[10:23:17.214]             }
[10:23:17.214]         }
[10:23:17.214]     })
[10:23:17.214]     if (TRUE) {
[10:23:17.214]         base::sink(type = "output", split = FALSE)
[10:23:17.214]         if (TRUE) {
[10:23:17.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.214]         }
[10:23:17.214]         else {
[10:23:17.214]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.214]         }
[10:23:17.214]         base::close(...future.stdout)
[10:23:17.214]         ...future.stdout <- NULL
[10:23:17.214]     }
[10:23:17.214]     ...future.result$conditions <- ...future.conditions
[10:23:17.214]     ...future.result$finished <- base::Sys.time()
[10:23:17.214]     ...future.result
[10:23:17.214] }
[10:23:17.216] requestCore(): workers = 2
[10:23:17.219] MulticoreFuture started
[10:23:17.219] - Launch lazy future ... done
[10:23:17.220] run() for ‘MulticoreFuture’ ... done
[10:23:17.220] plan(): Setting new future strategy stack:
[10:23:17.221] result() for MulticoreFuture ...
[10:23:17.221] List of future strategies:
[10:23:17.221] 1. sequential:
[10:23:17.221]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.221]    - tweaked: FALSE
[10:23:17.221]    - call: NULL
[10:23:17.222] plan(): nbrOfWorkers() = 1
[10:23:17.225] plan(): Setting new future strategy stack:
[10:23:17.225] List of future strategies:
[10:23:17.225] 1. multicore:
[10:23:17.225]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.225]    - tweaked: FALSE
[10:23:17.225]    - call: plan(strategy)
[10:23:17.229] plan(): nbrOfWorkers() = 2
[10:23:17.230] result() for MulticoreFuture ...
[10:23:17.230] result() for MulticoreFuture ... done
[10:23:17.230] result() for MulticoreFuture ... done
[10:23:17.230] result() for MulticoreFuture ...
[10:23:17.230] result() for MulticoreFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[10:23:17.231] getGlobalsAndPackages() ...
[10:23:17.231] Searching for globals...
[10:23:17.232] - globals found: [1] ‘print’
[10:23:17.232] Searching for globals ... DONE
[10:23:17.232] Resolving globals: FALSE
[10:23:17.233] 
[10:23:17.233] 
[10:23:17.233] getGlobalsAndPackages() ... DONE
[10:23:17.233] run() for ‘Future’ ...
[10:23:17.234] - state: ‘created’
[10:23:17.234] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:23:17.236] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:17.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:23:17.236]   - Field: ‘label’
[10:23:17.236]   - Field: ‘local’
[10:23:17.236]   - Field: ‘owner’
[10:23:17.237]   - Field: ‘envir’
[10:23:17.237]   - Field: ‘workers’
[10:23:17.237]   - Field: ‘packages’
[10:23:17.237]   - Field: ‘gc’
[10:23:17.237]   - Field: ‘job’
[10:23:17.237]   - Field: ‘conditions’
[10:23:17.237]   - Field: ‘expr’
[10:23:17.237]   - Field: ‘uuid’
[10:23:17.237]   - Field: ‘seed’
[10:23:17.238]   - Field: ‘version’
[10:23:17.238]   - Field: ‘result’
[10:23:17.238]   - Field: ‘asynchronous’
[10:23:17.238]   - Field: ‘calls’
[10:23:17.238]   - Field: ‘globals’
[10:23:17.238]   - Field: ‘stdout’
[10:23:17.238]   - Field: ‘earlySignal’
[10:23:17.238]   - Field: ‘lazy’
[10:23:17.238]   - Field: ‘state’
[10:23:17.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:23:17.239] - Launch lazy future ...
[10:23:17.239] Packages needed by the future expression (n = 0): <none>
[10:23:17.239] Packages needed by future strategies (n = 0): <none>
[10:23:17.240] {
[10:23:17.240]     {
[10:23:17.240]         {
[10:23:17.240]             ...future.startTime <- base::Sys.time()
[10:23:17.240]             {
[10:23:17.240]                 {
[10:23:17.240]                   {
[10:23:17.240]                     {
[10:23:17.240]                       base::local({
[10:23:17.240]                         has_future <- base::requireNamespace("future", 
[10:23:17.240]                           quietly = TRUE)
[10:23:17.240]                         if (has_future) {
[10:23:17.240]                           ns <- base::getNamespace("future")
[10:23:17.240]                           version <- ns[[".package"]][["version"]]
[10:23:17.240]                           if (is.null(version)) 
[10:23:17.240]                             version <- utils::packageVersion("future")
[10:23:17.240]                         }
[10:23:17.240]                         else {
[10:23:17.240]                           version <- NULL
[10:23:17.240]                         }
[10:23:17.240]                         if (!has_future || version < "1.8.0") {
[10:23:17.240]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.240]                             "", base::R.version$version.string), 
[10:23:17.240]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.240]                               "release", "version")], collapse = " "), 
[10:23:17.240]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.240]                             info)
[10:23:17.240]                           info <- base::paste(info, collapse = "; ")
[10:23:17.240]                           if (!has_future) {
[10:23:17.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.240]                               info)
[10:23:17.240]                           }
[10:23:17.240]                           else {
[10:23:17.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.240]                               info, version)
[10:23:17.240]                           }
[10:23:17.240]                           base::stop(msg)
[10:23:17.240]                         }
[10:23:17.240]                       })
[10:23:17.240]                     }
[10:23:17.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.240]                     base::options(mc.cores = 1L)
[10:23:17.240]                   }
[10:23:17.240]                   ...future.strategy.old <- future::plan("list")
[10:23:17.240]                   options(future.plan = NULL)
[10:23:17.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.240]                 }
[10:23:17.240]                 ...future.workdir <- getwd()
[10:23:17.240]             }
[10:23:17.240]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.240]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.240]         }
[10:23:17.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.240]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.240]             base::names(...future.oldOptions))
[10:23:17.240]     }
[10:23:17.240]     if (FALSE) {
[10:23:17.240]     }
[10:23:17.240]     else {
[10:23:17.240]         if (TRUE) {
[10:23:17.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.240]                 open = "w")
[10:23:17.240]         }
[10:23:17.240]         else {
[10:23:17.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.240]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.240]         }
[10:23:17.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.240]             base::sink(type = "output", split = FALSE)
[10:23:17.240]             base::close(...future.stdout)
[10:23:17.240]         }, add = TRUE)
[10:23:17.240]     }
[10:23:17.240]     ...future.frame <- base::sys.nframe()
[10:23:17.240]     ...future.conditions <- base::list()
[10:23:17.240]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.240]     if (FALSE) {
[10:23:17.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.240]     }
[10:23:17.240]     ...future.result <- base::tryCatch({
[10:23:17.240]         base::withCallingHandlers({
[10:23:17.240]             ...future.value <- base::withVisible(base::local({
[10:23:17.240]                 withCallingHandlers({
[10:23:17.240]                   print(42)
[10:23:17.240]                 }, immediateCondition = function(cond) {
[10:23:17.240]                   save_rds <- function (object, pathname, ...) 
[10:23:17.240]                   {
[10:23:17.240]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:23:17.240]                     if (file_test("-f", pathname_tmp)) {
[10:23:17.240]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.240]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:23:17.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.240]                         fi_tmp[["mtime"]])
[10:23:17.240]                     }
[10:23:17.240]                     tryCatch({
[10:23:17.240]                       saveRDS(object, file = pathname_tmp, ...)
[10:23:17.240]                     }, error = function(ex) {
[10:23:17.240]                       msg <- conditionMessage(ex)
[10:23:17.240]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.240]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:23:17.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.240]                         fi_tmp[["mtime"]], msg)
[10:23:17.240]                       ex$message <- msg
[10:23:17.240]                       stop(ex)
[10:23:17.240]                     })
[10:23:17.240]                     stopifnot(file_test("-f", pathname_tmp))
[10:23:17.240]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:23:17.240]                     if (!res || file_test("-f", pathname_tmp)) {
[10:23:17.240]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.240]                       fi <- file.info(pathname)
[10:23:17.240]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:23:17.240]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.240]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:23:17.240]                         fi[["size"]], fi[["mtime"]])
[10:23:17.240]                       stop(msg)
[10:23:17.240]                     }
[10:23:17.240]                     invisible(pathname)
[10:23:17.240]                   }
[10:23:17.240]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:23:17.240]                     rootPath = tempdir()) 
[10:23:17.240]                   {
[10:23:17.240]                     obj <- list(time = Sys.time(), condition = cond)
[10:23:17.240]                     file <- tempfile(pattern = class(cond)[1], 
[10:23:17.240]                       tmpdir = path, fileext = ".rds")
[10:23:17.240]                     save_rds(obj, file)
[10:23:17.240]                   }
[10:23:17.240]                   saveImmediateCondition(cond, path = "/tmp/RtmpQSLptV/.future/immediateConditions")
[10:23:17.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.240]                   {
[10:23:17.240]                     inherits <- base::inherits
[10:23:17.240]                     invokeRestart <- base::invokeRestart
[10:23:17.240]                     is.null <- base::is.null
[10:23:17.240]                     muffled <- FALSE
[10:23:17.240]                     if (inherits(cond, "message")) {
[10:23:17.240]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.240]                       if (muffled) 
[10:23:17.240]                         invokeRestart("muffleMessage")
[10:23:17.240]                     }
[10:23:17.240]                     else if (inherits(cond, "warning")) {
[10:23:17.240]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.240]                       if (muffled) 
[10:23:17.240]                         invokeRestart("muffleWarning")
[10:23:17.240]                     }
[10:23:17.240]                     else if (inherits(cond, "condition")) {
[10:23:17.240]                       if (!is.null(pattern)) {
[10:23:17.240]                         computeRestarts <- base::computeRestarts
[10:23:17.240]                         grepl <- base::grepl
[10:23:17.240]                         restarts <- computeRestarts(cond)
[10:23:17.240]                         for (restart in restarts) {
[10:23:17.240]                           name <- restart$name
[10:23:17.240]                           if (is.null(name)) 
[10:23:17.240]                             next
[10:23:17.240]                           if (!grepl(pattern, name)) 
[10:23:17.240]                             next
[10:23:17.240]                           invokeRestart(restart)
[10:23:17.240]                           muffled <- TRUE
[10:23:17.240]                           break
[10:23:17.240]                         }
[10:23:17.240]                       }
[10:23:17.240]                     }
[10:23:17.240]                     invisible(muffled)
[10:23:17.240]                   }
[10:23:17.240]                   muffleCondition(cond)
[10:23:17.240]                 })
[10:23:17.240]             }))
[10:23:17.240]             future::FutureResult(value = ...future.value$value, 
[10:23:17.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.240]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.240]                     ...future.globalenv.names))
[10:23:17.240]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.240]         }, condition = base::local({
[10:23:17.240]             c <- base::c
[10:23:17.240]             inherits <- base::inherits
[10:23:17.240]             invokeRestart <- base::invokeRestart
[10:23:17.240]             length <- base::length
[10:23:17.240]             list <- base::list
[10:23:17.240]             seq.int <- base::seq.int
[10:23:17.240]             signalCondition <- base::signalCondition
[10:23:17.240]             sys.calls <- base::sys.calls
[10:23:17.240]             `[[` <- base::`[[`
[10:23:17.240]             `+` <- base::`+`
[10:23:17.240]             `<<-` <- base::`<<-`
[10:23:17.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.240]                   3L)]
[10:23:17.240]             }
[10:23:17.240]             function(cond) {
[10:23:17.240]                 is_error <- inherits(cond, "error")
[10:23:17.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.240]                   NULL)
[10:23:17.240]                 if (is_error) {
[10:23:17.240]                   sessionInformation <- function() {
[10:23:17.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.240]                       search = base::search(), system = base::Sys.info())
[10:23:17.240]                   }
[10:23:17.240]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.240]                     cond$call), session = sessionInformation(), 
[10:23:17.240]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.240]                   signalCondition(cond)
[10:23:17.240]                 }
[10:23:17.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.240]                 "immediateCondition"))) {
[10:23:17.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.240]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.240]                   if (TRUE && !signal) {
[10:23:17.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.240]                     {
[10:23:17.240]                       inherits <- base::inherits
[10:23:17.240]                       invokeRestart <- base::invokeRestart
[10:23:17.240]                       is.null <- base::is.null
[10:23:17.240]                       muffled <- FALSE
[10:23:17.240]                       if (inherits(cond, "message")) {
[10:23:17.240]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.240]                         if (muffled) 
[10:23:17.240]                           invokeRestart("muffleMessage")
[10:23:17.240]                       }
[10:23:17.240]                       else if (inherits(cond, "warning")) {
[10:23:17.240]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.240]                         if (muffled) 
[10:23:17.240]                           invokeRestart("muffleWarning")
[10:23:17.240]                       }
[10:23:17.240]                       else if (inherits(cond, "condition")) {
[10:23:17.240]                         if (!is.null(pattern)) {
[10:23:17.240]                           computeRestarts <- base::computeRestarts
[10:23:17.240]                           grepl <- base::grepl
[10:23:17.240]                           restarts <- computeRestarts(cond)
[10:23:17.240]                           for (restart in restarts) {
[10:23:17.240]                             name <- restart$name
[10:23:17.240]                             if (is.null(name)) 
[10:23:17.240]                               next
[10:23:17.240]                             if (!grepl(pattern, name)) 
[10:23:17.240]                               next
[10:23:17.240]                             invokeRestart(restart)
[10:23:17.240]                             muffled <- TRUE
[10:23:17.240]                             break
[10:23:17.240]                           }
[10:23:17.240]                         }
[10:23:17.240]                       }
[10:23:17.240]                       invisible(muffled)
[10:23:17.240]                     }
[10:23:17.240]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.240]                   }
[10:23:17.240]                 }
[10:23:17.240]                 else {
[10:23:17.240]                   if (TRUE) {
[10:23:17.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.240]                     {
[10:23:17.240]                       inherits <- base::inherits
[10:23:17.240]                       invokeRestart <- base::invokeRestart
[10:23:17.240]                       is.null <- base::is.null
[10:23:17.240]                       muffled <- FALSE
[10:23:17.240]                       if (inherits(cond, "message")) {
[10:23:17.240]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.240]                         if (muffled) 
[10:23:17.240]                           invokeRestart("muffleMessage")
[10:23:17.240]                       }
[10:23:17.240]                       else if (inherits(cond, "warning")) {
[10:23:17.240]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.240]                         if (muffled) 
[10:23:17.240]                           invokeRestart("muffleWarning")
[10:23:17.240]                       }
[10:23:17.240]                       else if (inherits(cond, "condition")) {
[10:23:17.240]                         if (!is.null(pattern)) {
[10:23:17.240]                           computeRestarts <- base::computeRestarts
[10:23:17.240]                           grepl <- base::grepl
[10:23:17.240]                           restarts <- computeRestarts(cond)
[10:23:17.240]                           for (restart in restarts) {
[10:23:17.240]                             name <- restart$name
[10:23:17.240]                             if (is.null(name)) 
[10:23:17.240]                               next
[10:23:17.240]                             if (!grepl(pattern, name)) 
[10:23:17.240]                               next
[10:23:17.240]                             invokeRestart(restart)
[10:23:17.240]                             muffled <- TRUE
[10:23:17.240]                             break
[10:23:17.240]                           }
[10:23:17.240]                         }
[10:23:17.240]                       }
[10:23:17.240]                       invisible(muffled)
[10:23:17.240]                     }
[10:23:17.240]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.240]                   }
[10:23:17.240]                 }
[10:23:17.240]             }
[10:23:17.240]         }))
[10:23:17.240]     }, error = function(ex) {
[10:23:17.240]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.240]                 ...future.rng), started = ...future.startTime, 
[10:23:17.240]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.240]             version = "1.8"), class = "FutureResult")
[10:23:17.240]     }, finally = {
[10:23:17.240]         if (!identical(...future.workdir, getwd())) 
[10:23:17.240]             setwd(...future.workdir)
[10:23:17.240]         {
[10:23:17.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.240]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.240]             }
[10:23:17.240]             base::options(...future.oldOptions)
[10:23:17.240]             if (.Platform$OS.type == "windows") {
[10:23:17.240]                 old_names <- names(...future.oldEnvVars)
[10:23:17.240]                 envs <- base::Sys.getenv()
[10:23:17.240]                 names <- names(envs)
[10:23:17.240]                 common <- intersect(names, old_names)
[10:23:17.240]                 added <- setdiff(names, old_names)
[10:23:17.240]                 removed <- setdiff(old_names, names)
[10:23:17.240]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.240]                   envs[common]]
[10:23:17.240]                 NAMES <- toupper(changed)
[10:23:17.240]                 args <- list()
[10:23:17.240]                 for (kk in seq_along(NAMES)) {
[10:23:17.240]                   name <- changed[[kk]]
[10:23:17.240]                   NAME <- NAMES[[kk]]
[10:23:17.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.240]                     next
[10:23:17.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.240]                 }
[10:23:17.240]                 NAMES <- toupper(added)
[10:23:17.240]                 for (kk in seq_along(NAMES)) {
[10:23:17.240]                   name <- added[[kk]]
[10:23:17.240]                   NAME <- NAMES[[kk]]
[10:23:17.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.240]                     next
[10:23:17.240]                   args[[name]] <- ""
[10:23:17.240]                 }
[10:23:17.240]                 NAMES <- toupper(removed)
[10:23:17.240]                 for (kk in seq_along(NAMES)) {
[10:23:17.240]                   name <- removed[[kk]]
[10:23:17.240]                   NAME <- NAMES[[kk]]
[10:23:17.240]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.240]                     next
[10:23:17.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.240]                 }
[10:23:17.240]                 if (length(args) > 0) 
[10:23:17.240]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.240]             }
[10:23:17.240]             else {
[10:23:17.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.240]             }
[10:23:17.240]             {
[10:23:17.240]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.240]                   0L) {
[10:23:17.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.240]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.240]                   base::options(opts)
[10:23:17.240]                 }
[10:23:17.240]                 {
[10:23:17.240]                   {
[10:23:17.240]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.240]                     NULL
[10:23:17.240]                   }
[10:23:17.240]                   options(future.plan = NULL)
[10:23:17.240]                   if (is.na(NA_character_)) 
[10:23:17.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.240]                     .init = FALSE)
[10:23:17.240]                 }
[10:23:17.240]             }
[10:23:17.240]         }
[10:23:17.240]     })
[10:23:17.240]     if (TRUE) {
[10:23:17.240]         base::sink(type = "output", split = FALSE)
[10:23:17.240]         if (TRUE) {
[10:23:17.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.240]         }
[10:23:17.240]         else {
[10:23:17.240]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.240]         }
[10:23:17.240]         base::close(...future.stdout)
[10:23:17.240]         ...future.stdout <- NULL
[10:23:17.240]     }
[10:23:17.240]     ...future.result$conditions <- ...future.conditions
[10:23:17.240]     ...future.result$finished <- base::Sys.time()
[10:23:17.240]     ...future.result
[10:23:17.240] }
[10:23:17.243] requestCore(): workers = 2
[10:23:17.244] MulticoreFuture started
[10:23:17.245] - Launch lazy future ... done
[10:23:17.245] run() for ‘MulticoreFuture’ ... done
[10:23:17.245] result() for MulticoreFuture ...
[10:23:17.245] plan(): Setting new future strategy stack:
[10:23:17.246] List of future strategies:
[10:23:17.246] 1. sequential:
[10:23:17.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.246]    - tweaked: FALSE
[10:23:17.246]    - call: NULL
[10:23:17.247] plan(): nbrOfWorkers() = 1
[10:23:17.249] plan(): Setting new future strategy stack:
[10:23:17.249] List of future strategies:
[10:23:17.249] 1. multicore:
[10:23:17.249]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.249]    - tweaked: FALSE
[10:23:17.249]    - call: plan(strategy)
[10:23:17.252] plan(): nbrOfWorkers() = 2
[10:23:17.253] result() for MulticoreFuture ...
[10:23:17.253] result() for MulticoreFuture ... done
[10:23:17.253] result() for MulticoreFuture ... done
[10:23:17.253] result() for MulticoreFuture ...
[10:23:17.253] result() for MulticoreFuture ... done
[10:23:17.253] result() for MulticoreFuture ...
[10:23:17.253] result() for MulticoreFuture ... done
[1] 42
[10:23:17.254] result() for MulticoreFuture ...
[10:23:17.254] result() for MulticoreFuture ... done
- stdout = FALSE
[10:23:17.254] getGlobalsAndPackages() ...
[10:23:17.254] Searching for globals...
[10:23:17.261] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.261] Searching for globals ... DONE
[10:23:17.262] Resolving globals: FALSE
[10:23:17.262] 
[10:23:17.262] - packages: [1] ‘utils’
[10:23:17.263] getGlobalsAndPackages() ... DONE
[10:23:17.263] run() for ‘Future’ ...
[10:23:17.263] - state: ‘created’
[10:23:17.263] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:23:17.265] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:17.265] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:23:17.265]   - Field: ‘label’
[10:23:17.266]   - Field: ‘local’
[10:23:17.266]   - Field: ‘owner’
[10:23:17.266]   - Field: ‘envir’
[10:23:17.266]   - Field: ‘workers’
[10:23:17.266]   - Field: ‘packages’
[10:23:17.266]   - Field: ‘gc’
[10:23:17.266]   - Field: ‘job’
[10:23:17.266]   - Field: ‘conditions’
[10:23:17.266]   - Field: ‘expr’
[10:23:17.267]   - Field: ‘uuid’
[10:23:17.267]   - Field: ‘seed’
[10:23:17.267]   - Field: ‘version’
[10:23:17.267]   - Field: ‘result’
[10:23:17.267]   - Field: ‘asynchronous’
[10:23:17.267]   - Field: ‘calls’
[10:23:17.267]   - Field: ‘globals’
[10:23:17.267]   - Field: ‘stdout’
[10:23:17.267]   - Field: ‘earlySignal’
[10:23:17.268]   - Field: ‘lazy’
[10:23:17.268]   - Field: ‘state’
[10:23:17.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:23:17.268] - Launch lazy future ...
[10:23:17.268] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.268] Packages needed by future strategies (n = 0): <none>
[10:23:17.269] {
[10:23:17.269]     {
[10:23:17.269]         {
[10:23:17.269]             ...future.startTime <- base::Sys.time()
[10:23:17.269]             {
[10:23:17.269]                 {
[10:23:17.269]                   {
[10:23:17.269]                     {
[10:23:17.269]                       {
[10:23:17.269]                         base::local({
[10:23:17.269]                           has_future <- base::requireNamespace("future", 
[10:23:17.269]                             quietly = TRUE)
[10:23:17.269]                           if (has_future) {
[10:23:17.269]                             ns <- base::getNamespace("future")
[10:23:17.269]                             version <- ns[[".package"]][["version"]]
[10:23:17.269]                             if (is.null(version)) 
[10:23:17.269]                               version <- utils::packageVersion("future")
[10:23:17.269]                           }
[10:23:17.269]                           else {
[10:23:17.269]                             version <- NULL
[10:23:17.269]                           }
[10:23:17.269]                           if (!has_future || version < "1.8.0") {
[10:23:17.269]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.269]                               "", base::R.version$version.string), 
[10:23:17.269]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:17.269]                                 base::R.version$platform, 8 * 
[10:23:17.269]                                   base::.Machine$sizeof.pointer), 
[10:23:17.269]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.269]                                 "release", "version")], collapse = " "), 
[10:23:17.269]                               hostname = base::Sys.info()[["nodename"]])
[10:23:17.269]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.269]                               info)
[10:23:17.269]                             info <- base::paste(info, collapse = "; ")
[10:23:17.269]                             if (!has_future) {
[10:23:17.269]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.269]                                 info)
[10:23:17.269]                             }
[10:23:17.269]                             else {
[10:23:17.269]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.269]                                 info, version)
[10:23:17.269]                             }
[10:23:17.269]                             base::stop(msg)
[10:23:17.269]                           }
[10:23:17.269]                         })
[10:23:17.269]                       }
[10:23:17.269]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.269]                       base::options(mc.cores = 1L)
[10:23:17.269]                     }
[10:23:17.269]                     base::local({
[10:23:17.269]                       for (pkg in "utils") {
[10:23:17.269]                         base::loadNamespace(pkg)
[10:23:17.269]                         base::library(pkg, character.only = TRUE)
[10:23:17.269]                       }
[10:23:17.269]                     })
[10:23:17.269]                   }
[10:23:17.269]                   ...future.strategy.old <- future::plan("list")
[10:23:17.269]                   options(future.plan = NULL)
[10:23:17.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.269]                 }
[10:23:17.269]                 ...future.workdir <- getwd()
[10:23:17.269]             }
[10:23:17.269]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.269]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.269]         }
[10:23:17.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.269]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.269]             base::names(...future.oldOptions))
[10:23:17.269]     }
[10:23:17.269]     if (FALSE) {
[10:23:17.269]     }
[10:23:17.269]     else {
[10:23:17.269]         if (FALSE) {
[10:23:17.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.269]                 open = "w")
[10:23:17.269]         }
[10:23:17.269]         else {
[10:23:17.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.269]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.269]         }
[10:23:17.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.269]             base::sink(type = "output", split = FALSE)
[10:23:17.269]             base::close(...future.stdout)
[10:23:17.269]         }, add = TRUE)
[10:23:17.269]     }
[10:23:17.269]     ...future.frame <- base::sys.nframe()
[10:23:17.269]     ...future.conditions <- base::list()
[10:23:17.269]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.269]     if (FALSE) {
[10:23:17.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.269]     }
[10:23:17.269]     ...future.result <- base::tryCatch({
[10:23:17.269]         base::withCallingHandlers({
[10:23:17.269]             ...future.value <- base::withVisible(base::local({
[10:23:17.269]                 withCallingHandlers({
[10:23:17.269]                   {
[10:23:17.269]                     print(1:50)
[10:23:17.269]                     str(1:50)
[10:23:17.269]                     cat(letters, sep = "-")
[10:23:17.269]                     cat(1:6, collapse = "\n")
[10:23:17.269]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.269]                     42L
[10:23:17.269]                   }
[10:23:17.269]                 }, immediateCondition = function(cond) {
[10:23:17.269]                   save_rds <- function (object, pathname, ...) 
[10:23:17.269]                   {
[10:23:17.269]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:23:17.269]                     if (file_test("-f", pathname_tmp)) {
[10:23:17.269]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.269]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:23:17.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.269]                         fi_tmp[["mtime"]])
[10:23:17.269]                     }
[10:23:17.269]                     tryCatch({
[10:23:17.269]                       saveRDS(object, file = pathname_tmp, ...)
[10:23:17.269]                     }, error = function(ex) {
[10:23:17.269]                       msg <- conditionMessage(ex)
[10:23:17.269]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.269]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:23:17.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.269]                         fi_tmp[["mtime"]], msg)
[10:23:17.269]                       ex$message <- msg
[10:23:17.269]                       stop(ex)
[10:23:17.269]                     })
[10:23:17.269]                     stopifnot(file_test("-f", pathname_tmp))
[10:23:17.269]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:23:17.269]                     if (!res || file_test("-f", pathname_tmp)) {
[10:23:17.269]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.269]                       fi <- file.info(pathname)
[10:23:17.269]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:23:17.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.269]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:23:17.269]                         fi[["size"]], fi[["mtime"]])
[10:23:17.269]                       stop(msg)
[10:23:17.269]                     }
[10:23:17.269]                     invisible(pathname)
[10:23:17.269]                   }
[10:23:17.269]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:23:17.269]                     rootPath = tempdir()) 
[10:23:17.269]                   {
[10:23:17.269]                     obj <- list(time = Sys.time(), condition = cond)
[10:23:17.269]                     file <- tempfile(pattern = class(cond)[1], 
[10:23:17.269]                       tmpdir = path, fileext = ".rds")
[10:23:17.269]                     save_rds(obj, file)
[10:23:17.269]                   }
[10:23:17.269]                   saveImmediateCondition(cond, path = "/tmp/RtmpQSLptV/.future/immediateConditions")
[10:23:17.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.269]                   {
[10:23:17.269]                     inherits <- base::inherits
[10:23:17.269]                     invokeRestart <- base::invokeRestart
[10:23:17.269]                     is.null <- base::is.null
[10:23:17.269]                     muffled <- FALSE
[10:23:17.269]                     if (inherits(cond, "message")) {
[10:23:17.269]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.269]                       if (muffled) 
[10:23:17.269]                         invokeRestart("muffleMessage")
[10:23:17.269]                     }
[10:23:17.269]                     else if (inherits(cond, "warning")) {
[10:23:17.269]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.269]                       if (muffled) 
[10:23:17.269]                         invokeRestart("muffleWarning")
[10:23:17.269]                     }
[10:23:17.269]                     else if (inherits(cond, "condition")) {
[10:23:17.269]                       if (!is.null(pattern)) {
[10:23:17.269]                         computeRestarts <- base::computeRestarts
[10:23:17.269]                         grepl <- base::grepl
[10:23:17.269]                         restarts <- computeRestarts(cond)
[10:23:17.269]                         for (restart in restarts) {
[10:23:17.269]                           name <- restart$name
[10:23:17.269]                           if (is.null(name)) 
[10:23:17.269]                             next
[10:23:17.269]                           if (!grepl(pattern, name)) 
[10:23:17.269]                             next
[10:23:17.269]                           invokeRestart(restart)
[10:23:17.269]                           muffled <- TRUE
[10:23:17.269]                           break
[10:23:17.269]                         }
[10:23:17.269]                       }
[10:23:17.269]                     }
[10:23:17.269]                     invisible(muffled)
[10:23:17.269]                   }
[10:23:17.269]                   muffleCondition(cond)
[10:23:17.269]                 })
[10:23:17.269]             }))
[10:23:17.269]             future::FutureResult(value = ...future.value$value, 
[10:23:17.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.269]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.269]                     ...future.globalenv.names))
[10:23:17.269]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.269]         }, condition = base::local({
[10:23:17.269]             c <- base::c
[10:23:17.269]             inherits <- base::inherits
[10:23:17.269]             invokeRestart <- base::invokeRestart
[10:23:17.269]             length <- base::length
[10:23:17.269]             list <- base::list
[10:23:17.269]             seq.int <- base::seq.int
[10:23:17.269]             signalCondition <- base::signalCondition
[10:23:17.269]             sys.calls <- base::sys.calls
[10:23:17.269]             `[[` <- base::`[[`
[10:23:17.269]             `+` <- base::`+`
[10:23:17.269]             `<<-` <- base::`<<-`
[10:23:17.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.269]                   3L)]
[10:23:17.269]             }
[10:23:17.269]             function(cond) {
[10:23:17.269]                 is_error <- inherits(cond, "error")
[10:23:17.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.269]                   NULL)
[10:23:17.269]                 if (is_error) {
[10:23:17.269]                   sessionInformation <- function() {
[10:23:17.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.269]                       search = base::search(), system = base::Sys.info())
[10:23:17.269]                   }
[10:23:17.269]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.269]                     cond$call), session = sessionInformation(), 
[10:23:17.269]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.269]                   signalCondition(cond)
[10:23:17.269]                 }
[10:23:17.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.269]                 "immediateCondition"))) {
[10:23:17.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.269]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.269]                   if (TRUE && !signal) {
[10:23:17.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.269]                     {
[10:23:17.269]                       inherits <- base::inherits
[10:23:17.269]                       invokeRestart <- base::invokeRestart
[10:23:17.269]                       is.null <- base::is.null
[10:23:17.269]                       muffled <- FALSE
[10:23:17.269]                       if (inherits(cond, "message")) {
[10:23:17.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.269]                         if (muffled) 
[10:23:17.269]                           invokeRestart("muffleMessage")
[10:23:17.269]                       }
[10:23:17.269]                       else if (inherits(cond, "warning")) {
[10:23:17.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.269]                         if (muffled) 
[10:23:17.269]                           invokeRestart("muffleWarning")
[10:23:17.269]                       }
[10:23:17.269]                       else if (inherits(cond, "condition")) {
[10:23:17.269]                         if (!is.null(pattern)) {
[10:23:17.269]                           computeRestarts <- base::computeRestarts
[10:23:17.269]                           grepl <- base::grepl
[10:23:17.269]                           restarts <- computeRestarts(cond)
[10:23:17.269]                           for (restart in restarts) {
[10:23:17.269]                             name <- restart$name
[10:23:17.269]                             if (is.null(name)) 
[10:23:17.269]                               next
[10:23:17.269]                             if (!grepl(pattern, name)) 
[10:23:17.269]                               next
[10:23:17.269]                             invokeRestart(restart)
[10:23:17.269]                             muffled <- TRUE
[10:23:17.269]                             break
[10:23:17.269]                           }
[10:23:17.269]                         }
[10:23:17.269]                       }
[10:23:17.269]                       invisible(muffled)
[10:23:17.269]                     }
[10:23:17.269]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.269]                   }
[10:23:17.269]                 }
[10:23:17.269]                 else {
[10:23:17.269]                   if (TRUE) {
[10:23:17.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.269]                     {
[10:23:17.269]                       inherits <- base::inherits
[10:23:17.269]                       invokeRestart <- base::invokeRestart
[10:23:17.269]                       is.null <- base::is.null
[10:23:17.269]                       muffled <- FALSE
[10:23:17.269]                       if (inherits(cond, "message")) {
[10:23:17.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.269]                         if (muffled) 
[10:23:17.269]                           invokeRestart("muffleMessage")
[10:23:17.269]                       }
[10:23:17.269]                       else if (inherits(cond, "warning")) {
[10:23:17.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.269]                         if (muffled) 
[10:23:17.269]                           invokeRestart("muffleWarning")
[10:23:17.269]                       }
[10:23:17.269]                       else if (inherits(cond, "condition")) {
[10:23:17.269]                         if (!is.null(pattern)) {
[10:23:17.269]                           computeRestarts <- base::computeRestarts
[10:23:17.269]                           grepl <- base::grepl
[10:23:17.269]                           restarts <- computeRestarts(cond)
[10:23:17.269]                           for (restart in restarts) {
[10:23:17.269]                             name <- restart$name
[10:23:17.269]                             if (is.null(name)) 
[10:23:17.269]                               next
[10:23:17.269]                             if (!grepl(pattern, name)) 
[10:23:17.269]                               next
[10:23:17.269]                             invokeRestart(restart)
[10:23:17.269]                             muffled <- TRUE
[10:23:17.269]                             break
[10:23:17.269]                           }
[10:23:17.269]                         }
[10:23:17.269]                       }
[10:23:17.269]                       invisible(muffled)
[10:23:17.269]                     }
[10:23:17.269]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.269]                   }
[10:23:17.269]                 }
[10:23:17.269]             }
[10:23:17.269]         }))
[10:23:17.269]     }, error = function(ex) {
[10:23:17.269]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.269]                 ...future.rng), started = ...future.startTime, 
[10:23:17.269]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.269]             version = "1.8"), class = "FutureResult")
[10:23:17.269]     }, finally = {
[10:23:17.269]         if (!identical(...future.workdir, getwd())) 
[10:23:17.269]             setwd(...future.workdir)
[10:23:17.269]         {
[10:23:17.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.269]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.269]             }
[10:23:17.269]             base::options(...future.oldOptions)
[10:23:17.269]             if (.Platform$OS.type == "windows") {
[10:23:17.269]                 old_names <- names(...future.oldEnvVars)
[10:23:17.269]                 envs <- base::Sys.getenv()
[10:23:17.269]                 names <- names(envs)
[10:23:17.269]                 common <- intersect(names, old_names)
[10:23:17.269]                 added <- setdiff(names, old_names)
[10:23:17.269]                 removed <- setdiff(old_names, names)
[10:23:17.269]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.269]                   envs[common]]
[10:23:17.269]                 NAMES <- toupper(changed)
[10:23:17.269]                 args <- list()
[10:23:17.269]                 for (kk in seq_along(NAMES)) {
[10:23:17.269]                   name <- changed[[kk]]
[10:23:17.269]                   NAME <- NAMES[[kk]]
[10:23:17.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.269]                     next
[10:23:17.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.269]                 }
[10:23:17.269]                 NAMES <- toupper(added)
[10:23:17.269]                 for (kk in seq_along(NAMES)) {
[10:23:17.269]                   name <- added[[kk]]
[10:23:17.269]                   NAME <- NAMES[[kk]]
[10:23:17.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.269]                     next
[10:23:17.269]                   args[[name]] <- ""
[10:23:17.269]                 }
[10:23:17.269]                 NAMES <- toupper(removed)
[10:23:17.269]                 for (kk in seq_along(NAMES)) {
[10:23:17.269]                   name <- removed[[kk]]
[10:23:17.269]                   NAME <- NAMES[[kk]]
[10:23:17.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.269]                     next
[10:23:17.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.269]                 }
[10:23:17.269]                 if (length(args) > 0) 
[10:23:17.269]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.269]             }
[10:23:17.269]             else {
[10:23:17.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.269]             }
[10:23:17.269]             {
[10:23:17.269]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.269]                   0L) {
[10:23:17.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.269]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.269]                   base::options(opts)
[10:23:17.269]                 }
[10:23:17.269]                 {
[10:23:17.269]                   {
[10:23:17.269]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.269]                     NULL
[10:23:17.269]                   }
[10:23:17.269]                   options(future.plan = NULL)
[10:23:17.269]                   if (is.na(NA_character_)) 
[10:23:17.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.269]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.269]                     .init = FALSE)
[10:23:17.269]                 }
[10:23:17.269]             }
[10:23:17.269]         }
[10:23:17.269]     })
[10:23:17.269]     if (TRUE) {
[10:23:17.269]         base::sink(type = "output", split = FALSE)
[10:23:17.269]         if (FALSE) {
[10:23:17.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.269]         }
[10:23:17.269]         else {
[10:23:17.269]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.269]         }
[10:23:17.269]         base::close(...future.stdout)
[10:23:17.269]         ...future.stdout <- NULL
[10:23:17.269]     }
[10:23:17.269]     ...future.result$conditions <- ...future.conditions
[10:23:17.269]     ...future.result$finished <- base::Sys.time()
[10:23:17.269]     ...future.result
[10:23:17.269] }
[10:23:17.272] requestCore(): workers = 2
[10:23:17.273] MulticoreFuture started
[10:23:17.274] - Launch lazy future ... done
[10:23:17.274] run() for ‘MulticoreFuture’ ... done
[10:23:17.274] result() for MulticoreFuture ...
[10:23:17.275] plan(): Setting new future strategy stack:
[10:23:17.275] List of future strategies:
[10:23:17.275] 1. sequential:
[10:23:17.275]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.275]    - tweaked: FALSE
[10:23:17.275]    - call: NULL
[10:23:17.276] plan(): nbrOfWorkers() = 1
[10:23:17.279] plan(): Setting new future strategy stack:
[10:23:17.279] List of future strategies:
[10:23:17.279] 1. multicore:
[10:23:17.279]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.279]    - tweaked: FALSE
[10:23:17.279]    - call: plan(strategy)
[10:23:17.282] plan(): nbrOfWorkers() = 2
[10:23:17.283] result() for MulticoreFuture ...
[10:23:17.283] result() for MulticoreFuture ... done
[10:23:17.284] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ finished    : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ session_uuid: chr "103504a4-20fa-d2d2-6adc-2ed26651d739"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "eec1919a6b51"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 86306
  .. ..$ time  : POSIXct[1:1], format: "2025-11-19 10:23:17"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:23:17.293] result() for MulticoreFuture ...
[10:23:17.293] result() for MulticoreFuture ... done
[10:23:17.293] result() for MulticoreFuture ...
[10:23:17.293] result() for MulticoreFuture ... done
[10:23:17.294] getGlobalsAndPackages() ...
[10:23:17.294] Searching for globals...
[10:23:17.297] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.298] Searching for globals ... DONE
[10:23:17.298] Resolving globals: FALSE
[10:23:17.298] 
[10:23:17.301] - packages: [1] ‘utils’
[10:23:17.301] getGlobalsAndPackages() ... DONE
[10:23:17.301] run() for ‘Future’ ...
[10:23:17.301] - state: ‘created’
[10:23:17.301] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:23:17.304] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:17.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:23:17.304]   - Field: ‘label’
[10:23:17.304]   - Field: ‘local’
[10:23:17.304]   - Field: ‘owner’
[10:23:17.304]   - Field: ‘envir’
[10:23:17.304]   - Field: ‘workers’
[10:23:17.305]   - Field: ‘packages’
[10:23:17.305]   - Field: ‘gc’
[10:23:17.305]   - Field: ‘job’
[10:23:17.305]   - Field: ‘conditions’
[10:23:17.305]   - Field: ‘expr’
[10:23:17.305]   - Field: ‘uuid’
[10:23:17.305]   - Field: ‘seed’
[10:23:17.305]   - Field: ‘version’
[10:23:17.305]   - Field: ‘result’
[10:23:17.306]   - Field: ‘asynchronous’
[10:23:17.306]   - Field: ‘calls’
[10:23:17.306]   - Field: ‘globals’
[10:23:17.306]   - Field: ‘stdout’
[10:23:17.306]   - Field: ‘earlySignal’
[10:23:17.306]   - Field: ‘lazy’
[10:23:17.306]   - Field: ‘state’
[10:23:17.306] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:23:17.306] - Launch lazy future ...
[10:23:17.307] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.307] Packages needed by future strategies (n = 0): <none>
[10:23:17.307] {
[10:23:17.307]     {
[10:23:17.307]         {
[10:23:17.307]             ...future.startTime <- base::Sys.time()
[10:23:17.307]             {
[10:23:17.307]                 {
[10:23:17.307]                   {
[10:23:17.307]                     {
[10:23:17.307]                       {
[10:23:17.307]                         base::local({
[10:23:17.307]                           has_future <- base::requireNamespace("future", 
[10:23:17.307]                             quietly = TRUE)
[10:23:17.307]                           if (has_future) {
[10:23:17.307]                             ns <- base::getNamespace("future")
[10:23:17.307]                             version <- ns[[".package"]][["version"]]
[10:23:17.307]                             if (is.null(version)) 
[10:23:17.307]                               version <- utils::packageVersion("future")
[10:23:17.307]                           }
[10:23:17.307]                           else {
[10:23:17.307]                             version <- NULL
[10:23:17.307]                           }
[10:23:17.307]                           if (!has_future || version < "1.8.0") {
[10:23:17.307]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.307]                               "", base::R.version$version.string), 
[10:23:17.307]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:17.307]                                 base::R.version$platform, 8 * 
[10:23:17.307]                                   base::.Machine$sizeof.pointer), 
[10:23:17.307]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.307]                                 "release", "version")], collapse = " "), 
[10:23:17.307]                               hostname = base::Sys.info()[["nodename"]])
[10:23:17.307]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.307]                               info)
[10:23:17.307]                             info <- base::paste(info, collapse = "; ")
[10:23:17.307]                             if (!has_future) {
[10:23:17.307]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.307]                                 info)
[10:23:17.307]                             }
[10:23:17.307]                             else {
[10:23:17.307]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.307]                                 info, version)
[10:23:17.307]                             }
[10:23:17.307]                             base::stop(msg)
[10:23:17.307]                           }
[10:23:17.307]                         })
[10:23:17.307]                       }
[10:23:17.307]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.307]                       base::options(mc.cores = 1L)
[10:23:17.307]                     }
[10:23:17.307]                     base::local({
[10:23:17.307]                       for (pkg in "utils") {
[10:23:17.307]                         base::loadNamespace(pkg)
[10:23:17.307]                         base::library(pkg, character.only = TRUE)
[10:23:17.307]                       }
[10:23:17.307]                     })
[10:23:17.307]                   }
[10:23:17.307]                   ...future.strategy.old <- future::plan("list")
[10:23:17.307]                   options(future.plan = NULL)
[10:23:17.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.307]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.307]                 }
[10:23:17.307]                 ...future.workdir <- getwd()
[10:23:17.307]             }
[10:23:17.307]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.307]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.307]         }
[10:23:17.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.307]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.307]             base::names(...future.oldOptions))
[10:23:17.307]     }
[10:23:17.307]     if (FALSE) {
[10:23:17.307]     }
[10:23:17.307]     else {
[10:23:17.307]         if (FALSE) {
[10:23:17.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.307]                 open = "w")
[10:23:17.307]         }
[10:23:17.307]         else {
[10:23:17.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.307]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.307]         }
[10:23:17.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.307]             base::sink(type = "output", split = FALSE)
[10:23:17.307]             base::close(...future.stdout)
[10:23:17.307]         }, add = TRUE)
[10:23:17.307]     }
[10:23:17.307]     ...future.frame <- base::sys.nframe()
[10:23:17.307]     ...future.conditions <- base::list()
[10:23:17.307]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.307]     if (FALSE) {
[10:23:17.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.307]     }
[10:23:17.307]     ...future.result <- base::tryCatch({
[10:23:17.307]         base::withCallingHandlers({
[10:23:17.307]             ...future.value <- base::withVisible(base::local({
[10:23:17.307]                 withCallingHandlers({
[10:23:17.307]                   {
[10:23:17.307]                     print(1:50)
[10:23:17.307]                     str(1:50)
[10:23:17.307]                     cat(letters, sep = "-")
[10:23:17.307]                     cat(1:6, collapse = "\n")
[10:23:17.307]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.307]                     42L
[10:23:17.307]                   }
[10:23:17.307]                 }, immediateCondition = function(cond) {
[10:23:17.307]                   save_rds <- function (object, pathname, ...) 
[10:23:17.307]                   {
[10:23:17.307]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:23:17.307]                     if (file_test("-f", pathname_tmp)) {
[10:23:17.307]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.307]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:23:17.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.307]                         fi_tmp[["mtime"]])
[10:23:17.307]                     }
[10:23:17.307]                     tryCatch({
[10:23:17.307]                       saveRDS(object, file = pathname_tmp, ...)
[10:23:17.307]                     }, error = function(ex) {
[10:23:17.307]                       msg <- conditionMessage(ex)
[10:23:17.307]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.307]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:23:17.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.307]                         fi_tmp[["mtime"]], msg)
[10:23:17.307]                       ex$message <- msg
[10:23:17.307]                       stop(ex)
[10:23:17.307]                     })
[10:23:17.307]                     stopifnot(file_test("-f", pathname_tmp))
[10:23:17.307]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:23:17.307]                     if (!res || file_test("-f", pathname_tmp)) {
[10:23:17.307]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.307]                       fi <- file.info(pathname)
[10:23:17.307]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:23:17.307]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.307]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:23:17.307]                         fi[["size"]], fi[["mtime"]])
[10:23:17.307]                       stop(msg)
[10:23:17.307]                     }
[10:23:17.307]                     invisible(pathname)
[10:23:17.307]                   }
[10:23:17.307]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:23:17.307]                     rootPath = tempdir()) 
[10:23:17.307]                   {
[10:23:17.307]                     obj <- list(time = Sys.time(), condition = cond)
[10:23:17.307]                     file <- tempfile(pattern = class(cond)[1], 
[10:23:17.307]                       tmpdir = path, fileext = ".rds")
[10:23:17.307]                     save_rds(obj, file)
[10:23:17.307]                   }
[10:23:17.307]                   saveImmediateCondition(cond, path = "/tmp/RtmpQSLptV/.future/immediateConditions")
[10:23:17.307]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.307]                   {
[10:23:17.307]                     inherits <- base::inherits
[10:23:17.307]                     invokeRestart <- base::invokeRestart
[10:23:17.307]                     is.null <- base::is.null
[10:23:17.307]                     muffled <- FALSE
[10:23:17.307]                     if (inherits(cond, "message")) {
[10:23:17.307]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.307]                       if (muffled) 
[10:23:17.307]                         invokeRestart("muffleMessage")
[10:23:17.307]                     }
[10:23:17.307]                     else if (inherits(cond, "warning")) {
[10:23:17.307]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.307]                       if (muffled) 
[10:23:17.307]                         invokeRestart("muffleWarning")
[10:23:17.307]                     }
[10:23:17.307]                     else if (inherits(cond, "condition")) {
[10:23:17.307]                       if (!is.null(pattern)) {
[10:23:17.307]                         computeRestarts <- base::computeRestarts
[10:23:17.307]                         grepl <- base::grepl
[10:23:17.307]                         restarts <- computeRestarts(cond)
[10:23:17.307]                         for (restart in restarts) {
[10:23:17.307]                           name <- restart$name
[10:23:17.307]                           if (is.null(name)) 
[10:23:17.307]                             next
[10:23:17.307]                           if (!grepl(pattern, name)) 
[10:23:17.307]                             next
[10:23:17.307]                           invokeRestart(restart)
[10:23:17.307]                           muffled <- TRUE
[10:23:17.307]                           break
[10:23:17.307]                         }
[10:23:17.307]                       }
[10:23:17.307]                     }
[10:23:17.307]                     invisible(muffled)
[10:23:17.307]                   }
[10:23:17.307]                   muffleCondition(cond)
[10:23:17.307]                 })
[10:23:17.307]             }))
[10:23:17.307]             future::FutureResult(value = ...future.value$value, 
[10:23:17.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.307]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.307]                     ...future.globalenv.names))
[10:23:17.307]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.307]         }, condition = base::local({
[10:23:17.307]             c <- base::c
[10:23:17.307]             inherits <- base::inherits
[10:23:17.307]             invokeRestart <- base::invokeRestart
[10:23:17.307]             length <- base::length
[10:23:17.307]             list <- base::list
[10:23:17.307]             seq.int <- base::seq.int
[10:23:17.307]             signalCondition <- base::signalCondition
[10:23:17.307]             sys.calls <- base::sys.calls
[10:23:17.307]             `[[` <- base::`[[`
[10:23:17.307]             `+` <- base::`+`
[10:23:17.307]             `<<-` <- base::`<<-`
[10:23:17.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.307]                   3L)]
[10:23:17.307]             }
[10:23:17.307]             function(cond) {
[10:23:17.307]                 is_error <- inherits(cond, "error")
[10:23:17.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.307]                   NULL)
[10:23:17.307]                 if (is_error) {
[10:23:17.307]                   sessionInformation <- function() {
[10:23:17.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.307]                       search = base::search(), system = base::Sys.info())
[10:23:17.307]                   }
[10:23:17.307]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.307]                     cond$call), session = sessionInformation(), 
[10:23:17.307]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.307]                   signalCondition(cond)
[10:23:17.307]                 }
[10:23:17.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.307]                 "immediateCondition"))) {
[10:23:17.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.307]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.307]                   if (TRUE && !signal) {
[10:23:17.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.307]                     {
[10:23:17.307]                       inherits <- base::inherits
[10:23:17.307]                       invokeRestart <- base::invokeRestart
[10:23:17.307]                       is.null <- base::is.null
[10:23:17.307]                       muffled <- FALSE
[10:23:17.307]                       if (inherits(cond, "message")) {
[10:23:17.307]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.307]                         if (muffled) 
[10:23:17.307]                           invokeRestart("muffleMessage")
[10:23:17.307]                       }
[10:23:17.307]                       else if (inherits(cond, "warning")) {
[10:23:17.307]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.307]                         if (muffled) 
[10:23:17.307]                           invokeRestart("muffleWarning")
[10:23:17.307]                       }
[10:23:17.307]                       else if (inherits(cond, "condition")) {
[10:23:17.307]                         if (!is.null(pattern)) {
[10:23:17.307]                           computeRestarts <- base::computeRestarts
[10:23:17.307]                           grepl <- base::grepl
[10:23:17.307]                           restarts <- computeRestarts(cond)
[10:23:17.307]                           for (restart in restarts) {
[10:23:17.307]                             name <- restart$name
[10:23:17.307]                             if (is.null(name)) 
[10:23:17.307]                               next
[10:23:17.307]                             if (!grepl(pattern, name)) 
[10:23:17.307]                               next
[10:23:17.307]                             invokeRestart(restart)
[10:23:17.307]                             muffled <- TRUE
[10:23:17.307]                             break
[10:23:17.307]                           }
[10:23:17.307]                         }
[10:23:17.307]                       }
[10:23:17.307]                       invisible(muffled)
[10:23:17.307]                     }
[10:23:17.307]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.307]                   }
[10:23:17.307]                 }
[10:23:17.307]                 else {
[10:23:17.307]                   if (TRUE) {
[10:23:17.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.307]                     {
[10:23:17.307]                       inherits <- base::inherits
[10:23:17.307]                       invokeRestart <- base::invokeRestart
[10:23:17.307]                       is.null <- base::is.null
[10:23:17.307]                       muffled <- FALSE
[10:23:17.307]                       if (inherits(cond, "message")) {
[10:23:17.307]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.307]                         if (muffled) 
[10:23:17.307]                           invokeRestart("muffleMessage")
[10:23:17.307]                       }
[10:23:17.307]                       else if (inherits(cond, "warning")) {
[10:23:17.307]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.307]                         if (muffled) 
[10:23:17.307]                           invokeRestart("muffleWarning")
[10:23:17.307]                       }
[10:23:17.307]                       else if (inherits(cond, "condition")) {
[10:23:17.307]                         if (!is.null(pattern)) {
[10:23:17.307]                           computeRestarts <- base::computeRestarts
[10:23:17.307]                           grepl <- base::grepl
[10:23:17.307]                           restarts <- computeRestarts(cond)
[10:23:17.307]                           for (restart in restarts) {
[10:23:17.307]                             name <- restart$name
[10:23:17.307]                             if (is.null(name)) 
[10:23:17.307]                               next
[10:23:17.307]                             if (!grepl(pattern, name)) 
[10:23:17.307]                               next
[10:23:17.307]                             invokeRestart(restart)
[10:23:17.307]                             muffled <- TRUE
[10:23:17.307]                             break
[10:23:17.307]                           }
[10:23:17.307]                         }
[10:23:17.307]                       }
[10:23:17.307]                       invisible(muffled)
[10:23:17.307]                     }
[10:23:17.307]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.307]                   }
[10:23:17.307]                 }
[10:23:17.307]             }
[10:23:17.307]         }))
[10:23:17.307]     }, error = function(ex) {
[10:23:17.307]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.307]                 ...future.rng), started = ...future.startTime, 
[10:23:17.307]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.307]             version = "1.8"), class = "FutureResult")
[10:23:17.307]     }, finally = {
[10:23:17.307]         if (!identical(...future.workdir, getwd())) 
[10:23:17.307]             setwd(...future.workdir)
[10:23:17.307]         {
[10:23:17.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.307]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.307]             }
[10:23:17.307]             base::options(...future.oldOptions)
[10:23:17.307]             if (.Platform$OS.type == "windows") {
[10:23:17.307]                 old_names <- names(...future.oldEnvVars)
[10:23:17.307]                 envs <- base::Sys.getenv()
[10:23:17.307]                 names <- names(envs)
[10:23:17.307]                 common <- intersect(names, old_names)
[10:23:17.307]                 added <- setdiff(names, old_names)
[10:23:17.307]                 removed <- setdiff(old_names, names)
[10:23:17.307]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.307]                   envs[common]]
[10:23:17.307]                 NAMES <- toupper(changed)
[10:23:17.307]                 args <- list()
[10:23:17.307]                 for (kk in seq_along(NAMES)) {
[10:23:17.307]                   name <- changed[[kk]]
[10:23:17.307]                   NAME <- NAMES[[kk]]
[10:23:17.307]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.307]                     next
[10:23:17.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.307]                 }
[10:23:17.307]                 NAMES <- toupper(added)
[10:23:17.307]                 for (kk in seq_along(NAMES)) {
[10:23:17.307]                   name <- added[[kk]]
[10:23:17.307]                   NAME <- NAMES[[kk]]
[10:23:17.307]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.307]                     next
[10:23:17.307]                   args[[name]] <- ""
[10:23:17.307]                 }
[10:23:17.307]                 NAMES <- toupper(removed)
[10:23:17.307]                 for (kk in seq_along(NAMES)) {
[10:23:17.307]                   name <- removed[[kk]]
[10:23:17.307]                   NAME <- NAMES[[kk]]
[10:23:17.307]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.307]                     next
[10:23:17.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.307]                 }
[10:23:17.307]                 if (length(args) > 0) 
[10:23:17.307]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.307]             }
[10:23:17.307]             else {
[10:23:17.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.307]             }
[10:23:17.307]             {
[10:23:17.307]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.307]                   0L) {
[10:23:17.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.307]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.307]                   base::options(opts)
[10:23:17.307]                 }
[10:23:17.307]                 {
[10:23:17.307]                   {
[10:23:17.307]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.307]                     NULL
[10:23:17.307]                   }
[10:23:17.307]                   options(future.plan = NULL)
[10:23:17.307]                   if (is.na(NA_character_)) 
[10:23:17.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.307]                     .init = FALSE)
[10:23:17.307]                 }
[10:23:17.307]             }
[10:23:17.307]         }
[10:23:17.307]     })
[10:23:17.307]     if (TRUE) {
[10:23:17.307]         base::sink(type = "output", split = FALSE)
[10:23:17.307]         if (FALSE) {
[10:23:17.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.307]         }
[10:23:17.307]         else {
[10:23:17.307]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.307]         }
[10:23:17.307]         base::close(...future.stdout)
[10:23:17.307]         ...future.stdout <- NULL
[10:23:17.307]     }
[10:23:17.307]     ...future.result$conditions <- ...future.conditions
[10:23:17.307]     ...future.result$finished <- base::Sys.time()
[10:23:17.307]     ...future.result
[10:23:17.307] }
[10:23:17.310] requestCore(): workers = 2
[10:23:17.312] MulticoreFuture started
[10:23:17.312] - Launch lazy future ... done
[10:23:17.312] run() for ‘MulticoreFuture’ ... done
[10:23:17.313] result() for MulticoreFuture ...
[10:23:17.313] plan(): Setting new future strategy stack:
[10:23:17.313] List of future strategies:
[10:23:17.313] 1. sequential:
[10:23:17.313]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.313]    - tweaked: FALSE
[10:23:17.313]    - call: NULL
[10:23:17.314] plan(): nbrOfWorkers() = 1
[10:23:17.318] plan(): Setting new future strategy stack:
[10:23:17.318] List of future strategies:
[10:23:17.318] 1. multicore:
[10:23:17.318]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.318]    - tweaked: FALSE
[10:23:17.318]    - call: plan(strategy)
[10:23:17.321] plan(): nbrOfWorkers() = 2
[10:23:17.322] result() for MulticoreFuture ...
[10:23:17.322] result() for MulticoreFuture ... done
[10:23:17.322] result() for MulticoreFuture ... done
[10:23:17.322] result() for MulticoreFuture ...
[10:23:17.322] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[10:23:17.323] getGlobalsAndPackages() ...
[10:23:17.323] Searching for globals...
[10:23:17.324] - globals found: [1] ‘print’
[10:23:17.324] Searching for globals ... DONE
[10:23:17.324] Resolving globals: FALSE
[10:23:17.324] 
[10:23:17.325] 
[10:23:17.325] getGlobalsAndPackages() ... DONE
[10:23:17.325] run() for ‘Future’ ...
[10:23:17.325] - state: ‘created’
[10:23:17.325] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:23:17.327] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:17.328] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:23:17.328]   - Field: ‘label’
[10:23:17.328]   - Field: ‘local’
[10:23:17.328]   - Field: ‘owner’
[10:23:17.328]   - Field: ‘envir’
[10:23:17.328]   - Field: ‘workers’
[10:23:17.328]   - Field: ‘packages’
[10:23:17.328]   - Field: ‘gc’
[10:23:17.329]   - Field: ‘job’
[10:23:17.329]   - Field: ‘conditions’
[10:23:17.329]   - Field: ‘expr’
[10:23:17.329]   - Field: ‘uuid’
[10:23:17.329]   - Field: ‘seed’
[10:23:17.329]   - Field: ‘version’
[10:23:17.329]   - Field: ‘result’
[10:23:17.329]   - Field: ‘asynchronous’
[10:23:17.329]   - Field: ‘calls’
[10:23:17.330]   - Field: ‘globals’
[10:23:17.330]   - Field: ‘stdout’
[10:23:17.330]   - Field: ‘earlySignal’
[10:23:17.330]   - Field: ‘lazy’
[10:23:17.330]   - Field: ‘state’
[10:23:17.330] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:23:17.330] - Launch lazy future ...
[10:23:17.331] Packages needed by the future expression (n = 0): <none>
[10:23:17.331] Packages needed by future strategies (n = 0): <none>
[10:23:17.331] {
[10:23:17.331]     {
[10:23:17.331]         {
[10:23:17.331]             ...future.startTime <- base::Sys.time()
[10:23:17.331]             {
[10:23:17.331]                 {
[10:23:17.331]                   {
[10:23:17.331]                     {
[10:23:17.331]                       base::local({
[10:23:17.331]                         has_future <- base::requireNamespace("future", 
[10:23:17.331]                           quietly = TRUE)
[10:23:17.331]                         if (has_future) {
[10:23:17.331]                           ns <- base::getNamespace("future")
[10:23:17.331]                           version <- ns[[".package"]][["version"]]
[10:23:17.331]                           if (is.null(version)) 
[10:23:17.331]                             version <- utils::packageVersion("future")
[10:23:17.331]                         }
[10:23:17.331]                         else {
[10:23:17.331]                           version <- NULL
[10:23:17.331]                         }
[10:23:17.331]                         if (!has_future || version < "1.8.0") {
[10:23:17.331]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.331]                             "", base::R.version$version.string), 
[10:23:17.331]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.331]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.331]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.331]                               "release", "version")], collapse = " "), 
[10:23:17.331]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.331]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.331]                             info)
[10:23:17.331]                           info <- base::paste(info, collapse = "; ")
[10:23:17.331]                           if (!has_future) {
[10:23:17.331]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.331]                               info)
[10:23:17.331]                           }
[10:23:17.331]                           else {
[10:23:17.331]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.331]                               info, version)
[10:23:17.331]                           }
[10:23:17.331]                           base::stop(msg)
[10:23:17.331]                         }
[10:23:17.331]                       })
[10:23:17.331]                     }
[10:23:17.331]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.331]                     base::options(mc.cores = 1L)
[10:23:17.331]                   }
[10:23:17.331]                   ...future.strategy.old <- future::plan("list")
[10:23:17.331]                   options(future.plan = NULL)
[10:23:17.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.331]                 }
[10:23:17.331]                 ...future.workdir <- getwd()
[10:23:17.331]             }
[10:23:17.331]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.331]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.331]         }
[10:23:17.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.331]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.331]             base::names(...future.oldOptions))
[10:23:17.331]     }
[10:23:17.331]     if (FALSE) {
[10:23:17.331]     }
[10:23:17.331]     else {
[10:23:17.331]         if (TRUE) {
[10:23:17.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.331]                 open = "w")
[10:23:17.331]         }
[10:23:17.331]         else {
[10:23:17.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.331]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.331]         }
[10:23:17.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.331]             base::sink(type = "output", split = FALSE)
[10:23:17.331]             base::close(...future.stdout)
[10:23:17.331]         }, add = TRUE)
[10:23:17.331]     }
[10:23:17.331]     ...future.frame <- base::sys.nframe()
[10:23:17.331]     ...future.conditions <- base::list()
[10:23:17.331]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.331]     if (FALSE) {
[10:23:17.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.331]     }
[10:23:17.331]     ...future.result <- base::tryCatch({
[10:23:17.331]         base::withCallingHandlers({
[10:23:17.331]             ...future.value <- base::withVisible(base::local({
[10:23:17.331]                 withCallingHandlers({
[10:23:17.331]                   print(42)
[10:23:17.331]                 }, immediateCondition = function(cond) {
[10:23:17.331]                   save_rds <- function (object, pathname, ...) 
[10:23:17.331]                   {
[10:23:17.331]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:23:17.331]                     if (file_test("-f", pathname_tmp)) {
[10:23:17.331]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.331]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:23:17.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.331]                         fi_tmp[["mtime"]])
[10:23:17.331]                     }
[10:23:17.331]                     tryCatch({
[10:23:17.331]                       saveRDS(object, file = pathname_tmp, ...)
[10:23:17.331]                     }, error = function(ex) {
[10:23:17.331]                       msg <- conditionMessage(ex)
[10:23:17.331]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.331]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:23:17.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.331]                         fi_tmp[["mtime"]], msg)
[10:23:17.331]                       ex$message <- msg
[10:23:17.331]                       stop(ex)
[10:23:17.331]                     })
[10:23:17.331]                     stopifnot(file_test("-f", pathname_tmp))
[10:23:17.331]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:23:17.331]                     if (!res || file_test("-f", pathname_tmp)) {
[10:23:17.331]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.331]                       fi <- file.info(pathname)
[10:23:17.331]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:23:17.331]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.331]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:23:17.331]                         fi[["size"]], fi[["mtime"]])
[10:23:17.331]                       stop(msg)
[10:23:17.331]                     }
[10:23:17.331]                     invisible(pathname)
[10:23:17.331]                   }
[10:23:17.331]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:23:17.331]                     rootPath = tempdir()) 
[10:23:17.331]                   {
[10:23:17.331]                     obj <- list(time = Sys.time(), condition = cond)
[10:23:17.331]                     file <- tempfile(pattern = class(cond)[1], 
[10:23:17.331]                       tmpdir = path, fileext = ".rds")
[10:23:17.331]                     save_rds(obj, file)
[10:23:17.331]                   }
[10:23:17.331]                   saveImmediateCondition(cond, path = "/tmp/RtmpQSLptV/.future/immediateConditions")
[10:23:17.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.331]                   {
[10:23:17.331]                     inherits <- base::inherits
[10:23:17.331]                     invokeRestart <- base::invokeRestart
[10:23:17.331]                     is.null <- base::is.null
[10:23:17.331]                     muffled <- FALSE
[10:23:17.331]                     if (inherits(cond, "message")) {
[10:23:17.331]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.331]                       if (muffled) 
[10:23:17.331]                         invokeRestart("muffleMessage")
[10:23:17.331]                     }
[10:23:17.331]                     else if (inherits(cond, "warning")) {
[10:23:17.331]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.331]                       if (muffled) 
[10:23:17.331]                         invokeRestart("muffleWarning")
[10:23:17.331]                     }
[10:23:17.331]                     else if (inherits(cond, "condition")) {
[10:23:17.331]                       if (!is.null(pattern)) {
[10:23:17.331]                         computeRestarts <- base::computeRestarts
[10:23:17.331]                         grepl <- base::grepl
[10:23:17.331]                         restarts <- computeRestarts(cond)
[10:23:17.331]                         for (restart in restarts) {
[10:23:17.331]                           name <- restart$name
[10:23:17.331]                           if (is.null(name)) 
[10:23:17.331]                             next
[10:23:17.331]                           if (!grepl(pattern, name)) 
[10:23:17.331]                             next
[10:23:17.331]                           invokeRestart(restart)
[10:23:17.331]                           muffled <- TRUE
[10:23:17.331]                           break
[10:23:17.331]                         }
[10:23:17.331]                       }
[10:23:17.331]                     }
[10:23:17.331]                     invisible(muffled)
[10:23:17.331]                   }
[10:23:17.331]                   muffleCondition(cond)
[10:23:17.331]                 })
[10:23:17.331]             }))
[10:23:17.331]             future::FutureResult(value = ...future.value$value, 
[10:23:17.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.331]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.331]                     ...future.globalenv.names))
[10:23:17.331]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.331]         }, condition = base::local({
[10:23:17.331]             c <- base::c
[10:23:17.331]             inherits <- base::inherits
[10:23:17.331]             invokeRestart <- base::invokeRestart
[10:23:17.331]             length <- base::length
[10:23:17.331]             list <- base::list
[10:23:17.331]             seq.int <- base::seq.int
[10:23:17.331]             signalCondition <- base::signalCondition
[10:23:17.331]             sys.calls <- base::sys.calls
[10:23:17.331]             `[[` <- base::`[[`
[10:23:17.331]             `+` <- base::`+`
[10:23:17.331]             `<<-` <- base::`<<-`
[10:23:17.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.331]                   3L)]
[10:23:17.331]             }
[10:23:17.331]             function(cond) {
[10:23:17.331]                 is_error <- inherits(cond, "error")
[10:23:17.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.331]                   NULL)
[10:23:17.331]                 if (is_error) {
[10:23:17.331]                   sessionInformation <- function() {
[10:23:17.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.331]                       search = base::search(), system = base::Sys.info())
[10:23:17.331]                   }
[10:23:17.331]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.331]                     cond$call), session = sessionInformation(), 
[10:23:17.331]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.331]                   signalCondition(cond)
[10:23:17.331]                 }
[10:23:17.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.331]                 "immediateCondition"))) {
[10:23:17.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.331]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.331]                   if (TRUE && !signal) {
[10:23:17.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.331]                     {
[10:23:17.331]                       inherits <- base::inherits
[10:23:17.331]                       invokeRestart <- base::invokeRestart
[10:23:17.331]                       is.null <- base::is.null
[10:23:17.331]                       muffled <- FALSE
[10:23:17.331]                       if (inherits(cond, "message")) {
[10:23:17.331]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.331]                         if (muffled) 
[10:23:17.331]                           invokeRestart("muffleMessage")
[10:23:17.331]                       }
[10:23:17.331]                       else if (inherits(cond, "warning")) {
[10:23:17.331]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.331]                         if (muffled) 
[10:23:17.331]                           invokeRestart("muffleWarning")
[10:23:17.331]                       }
[10:23:17.331]                       else if (inherits(cond, "condition")) {
[10:23:17.331]                         if (!is.null(pattern)) {
[10:23:17.331]                           computeRestarts <- base::computeRestarts
[10:23:17.331]                           grepl <- base::grepl
[10:23:17.331]                           restarts <- computeRestarts(cond)
[10:23:17.331]                           for (restart in restarts) {
[10:23:17.331]                             name <- restart$name
[10:23:17.331]                             if (is.null(name)) 
[10:23:17.331]                               next
[10:23:17.331]                             if (!grepl(pattern, name)) 
[10:23:17.331]                               next
[10:23:17.331]                             invokeRestart(restart)
[10:23:17.331]                             muffled <- TRUE
[10:23:17.331]                             break
[10:23:17.331]                           }
[10:23:17.331]                         }
[10:23:17.331]                       }
[10:23:17.331]                       invisible(muffled)
[10:23:17.331]                     }
[10:23:17.331]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.331]                   }
[10:23:17.331]                 }
[10:23:17.331]                 else {
[10:23:17.331]                   if (TRUE) {
[10:23:17.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.331]                     {
[10:23:17.331]                       inherits <- base::inherits
[10:23:17.331]                       invokeRestart <- base::invokeRestart
[10:23:17.331]                       is.null <- base::is.null
[10:23:17.331]                       muffled <- FALSE
[10:23:17.331]                       if (inherits(cond, "message")) {
[10:23:17.331]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.331]                         if (muffled) 
[10:23:17.331]                           invokeRestart("muffleMessage")
[10:23:17.331]                       }
[10:23:17.331]                       else if (inherits(cond, "warning")) {
[10:23:17.331]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.331]                         if (muffled) 
[10:23:17.331]                           invokeRestart("muffleWarning")
[10:23:17.331]                       }
[10:23:17.331]                       else if (inherits(cond, "condition")) {
[10:23:17.331]                         if (!is.null(pattern)) {
[10:23:17.331]                           computeRestarts <- base::computeRestarts
[10:23:17.331]                           grepl <- base::grepl
[10:23:17.331]                           restarts <- computeRestarts(cond)
[10:23:17.331]                           for (restart in restarts) {
[10:23:17.331]                             name <- restart$name
[10:23:17.331]                             if (is.null(name)) 
[10:23:17.331]                               next
[10:23:17.331]                             if (!grepl(pattern, name)) 
[10:23:17.331]                               next
[10:23:17.331]                             invokeRestart(restart)
[10:23:17.331]                             muffled <- TRUE
[10:23:17.331]                             break
[10:23:17.331]                           }
[10:23:17.331]                         }
[10:23:17.331]                       }
[10:23:17.331]                       invisible(muffled)
[10:23:17.331]                     }
[10:23:17.331]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.331]                   }
[10:23:17.331]                 }
[10:23:17.331]             }
[10:23:17.331]         }))
[10:23:17.331]     }, error = function(ex) {
[10:23:17.331]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.331]                 ...future.rng), started = ...future.startTime, 
[10:23:17.331]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.331]             version = "1.8"), class = "FutureResult")
[10:23:17.331]     }, finally = {
[10:23:17.331]         if (!identical(...future.workdir, getwd())) 
[10:23:17.331]             setwd(...future.workdir)
[10:23:17.331]         {
[10:23:17.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.331]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.331]             }
[10:23:17.331]             base::options(...future.oldOptions)
[10:23:17.331]             if (.Platform$OS.type == "windows") {
[10:23:17.331]                 old_names <- names(...future.oldEnvVars)
[10:23:17.331]                 envs <- base::Sys.getenv()
[10:23:17.331]                 names <- names(envs)
[10:23:17.331]                 common <- intersect(names, old_names)
[10:23:17.331]                 added <- setdiff(names, old_names)
[10:23:17.331]                 removed <- setdiff(old_names, names)
[10:23:17.331]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.331]                   envs[common]]
[10:23:17.331]                 NAMES <- toupper(changed)
[10:23:17.331]                 args <- list()
[10:23:17.331]                 for (kk in seq_along(NAMES)) {
[10:23:17.331]                   name <- changed[[kk]]
[10:23:17.331]                   NAME <- NAMES[[kk]]
[10:23:17.331]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.331]                     next
[10:23:17.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.331]                 }
[10:23:17.331]                 NAMES <- toupper(added)
[10:23:17.331]                 for (kk in seq_along(NAMES)) {
[10:23:17.331]                   name <- added[[kk]]
[10:23:17.331]                   NAME <- NAMES[[kk]]
[10:23:17.331]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.331]                     next
[10:23:17.331]                   args[[name]] <- ""
[10:23:17.331]                 }
[10:23:17.331]                 NAMES <- toupper(removed)
[10:23:17.331]                 for (kk in seq_along(NAMES)) {
[10:23:17.331]                   name <- removed[[kk]]
[10:23:17.331]                   NAME <- NAMES[[kk]]
[10:23:17.331]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.331]                     next
[10:23:17.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.331]                 }
[10:23:17.331]                 if (length(args) > 0) 
[10:23:17.331]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.331]             }
[10:23:17.331]             else {
[10:23:17.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.331]             }
[10:23:17.331]             {
[10:23:17.331]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.331]                   0L) {
[10:23:17.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.331]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.331]                   base::options(opts)
[10:23:17.331]                 }
[10:23:17.331]                 {
[10:23:17.331]                   {
[10:23:17.331]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.331]                     NULL
[10:23:17.331]                   }
[10:23:17.331]                   options(future.plan = NULL)
[10:23:17.331]                   if (is.na(NA_character_)) 
[10:23:17.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.331]                     .init = FALSE)
[10:23:17.331]                 }
[10:23:17.331]             }
[10:23:17.331]         }
[10:23:17.331]     })
[10:23:17.331]     if (TRUE) {
[10:23:17.331]         base::sink(type = "output", split = FALSE)
[10:23:17.331]         if (TRUE) {
[10:23:17.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.331]         }
[10:23:17.331]         else {
[10:23:17.331]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.331]         }
[10:23:17.331]         base::close(...future.stdout)
[10:23:17.331]         ...future.stdout <- NULL
[10:23:17.331]     }
[10:23:17.331]     ...future.result$conditions <- ...future.conditions
[10:23:17.331]     ...future.result$finished <- base::Sys.time()
[10:23:17.331]     ...future.result
[10:23:17.331] }
[10:23:17.334] requestCore(): workers = 2
[10:23:17.336] MulticoreFuture started
[10:23:17.336] - Launch lazy future ... done
[10:23:17.336] run() for ‘MulticoreFuture’ ... done
[10:23:17.337] result() for MulticoreFuture ...
[10:23:17.337] plan(): Setting new future strategy stack:
[10:23:17.337] List of future strategies:
[10:23:17.337] 1. sequential:
[10:23:17.337]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.337]    - tweaked: FALSE
[10:23:17.337]    - call: NULL
[10:23:17.338] plan(): nbrOfWorkers() = 1
[10:23:17.340] plan(): Setting new future strategy stack:
[10:23:17.340] List of future strategies:
[10:23:17.340] 1. multicore:
[10:23:17.340]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.340]    - tweaked: FALSE
[10:23:17.340]    - call: plan(strategy)
[10:23:17.343] plan(): nbrOfWorkers() = 2
[10:23:17.344] result() for MulticoreFuture ...
[10:23:17.344] result() for MulticoreFuture ... done
[10:23:17.344] result() for MulticoreFuture ... done
[10:23:17.345] result() for MulticoreFuture ...
[10:23:17.345] result() for MulticoreFuture ... done
[10:23:17.345] result() for MulticoreFuture ...
[10:23:17.345] result() for MulticoreFuture ... done
[1] 42
[10:23:17.345] result() for MulticoreFuture ...
[10:23:17.345] result() for MulticoreFuture ... done
- stdout = NA
[10:23:17.346] getGlobalsAndPackages() ...
[10:23:17.346] Searching for globals...
[10:23:17.350] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.350] Searching for globals ... DONE
[10:23:17.350] Resolving globals: FALSE
[10:23:17.351] 
[10:23:17.351] - packages: [1] ‘utils’
[10:23:17.351] getGlobalsAndPackages() ... DONE
[10:23:17.351] run() for ‘Future’ ...
[10:23:17.351] - state: ‘created’
[10:23:17.352] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:23:17.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:17.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:23:17.354]   - Field: ‘label’
[10:23:17.354]   - Field: ‘local’
[10:23:17.354]   - Field: ‘owner’
[10:23:17.354]   - Field: ‘envir’
[10:23:17.355]   - Field: ‘workers’
[10:23:17.355]   - Field: ‘packages’
[10:23:17.355]   - Field: ‘gc’
[10:23:17.355]   - Field: ‘job’
[10:23:17.355]   - Field: ‘conditions’
[10:23:17.355]   - Field: ‘expr’
[10:23:17.355]   - Field: ‘uuid’
[10:23:17.355]   - Field: ‘seed’
[10:23:17.355]   - Field: ‘version’
[10:23:17.355]   - Field: ‘result’
[10:23:17.358]   - Field: ‘asynchronous’
[10:23:17.358]   - Field: ‘calls’
[10:23:17.359]   - Field: ‘globals’
[10:23:17.359]   - Field: ‘stdout’
[10:23:17.359]   - Field: ‘earlySignal’
[10:23:17.359]   - Field: ‘lazy’
[10:23:17.359]   - Field: ‘state’
[10:23:17.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:23:17.359] - Launch lazy future ...
[10:23:17.360] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.360] Packages needed by future strategies (n = 0): <none>
[10:23:17.361] {
[10:23:17.361]     {
[10:23:17.361]         {
[10:23:17.361]             ...future.startTime <- base::Sys.time()
[10:23:17.361]             {
[10:23:17.361]                 {
[10:23:17.361]                   {
[10:23:17.361]                     {
[10:23:17.361]                       {
[10:23:17.361]                         base::local({
[10:23:17.361]                           has_future <- base::requireNamespace("future", 
[10:23:17.361]                             quietly = TRUE)
[10:23:17.361]                           if (has_future) {
[10:23:17.361]                             ns <- base::getNamespace("future")
[10:23:17.361]                             version <- ns[[".package"]][["version"]]
[10:23:17.361]                             if (is.null(version)) 
[10:23:17.361]                               version <- utils::packageVersion("future")
[10:23:17.361]                           }
[10:23:17.361]                           else {
[10:23:17.361]                             version <- NULL
[10:23:17.361]                           }
[10:23:17.361]                           if (!has_future || version < "1.8.0") {
[10:23:17.361]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.361]                               "", base::R.version$version.string), 
[10:23:17.361]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:17.361]                                 base::R.version$platform, 8 * 
[10:23:17.361]                                   base::.Machine$sizeof.pointer), 
[10:23:17.361]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.361]                                 "release", "version")], collapse = " "), 
[10:23:17.361]                               hostname = base::Sys.info()[["nodename"]])
[10:23:17.361]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.361]                               info)
[10:23:17.361]                             info <- base::paste(info, collapse = "; ")
[10:23:17.361]                             if (!has_future) {
[10:23:17.361]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.361]                                 info)
[10:23:17.361]                             }
[10:23:17.361]                             else {
[10:23:17.361]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.361]                                 info, version)
[10:23:17.361]                             }
[10:23:17.361]                             base::stop(msg)
[10:23:17.361]                           }
[10:23:17.361]                         })
[10:23:17.361]                       }
[10:23:17.361]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.361]                       base::options(mc.cores = 1L)
[10:23:17.361]                     }
[10:23:17.361]                     base::local({
[10:23:17.361]                       for (pkg in "utils") {
[10:23:17.361]                         base::loadNamespace(pkg)
[10:23:17.361]                         base::library(pkg, character.only = TRUE)
[10:23:17.361]                       }
[10:23:17.361]                     })
[10:23:17.361]                   }
[10:23:17.361]                   ...future.strategy.old <- future::plan("list")
[10:23:17.361]                   options(future.plan = NULL)
[10:23:17.361]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.361]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.361]                 }
[10:23:17.361]                 ...future.workdir <- getwd()
[10:23:17.361]             }
[10:23:17.361]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.361]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.361]         }
[10:23:17.361]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.361]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.361]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.361]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.361]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.361]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.361]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.361]             base::names(...future.oldOptions))
[10:23:17.361]     }
[10:23:17.361]     if (TRUE) {
[10:23:17.361]     }
[10:23:17.361]     else {
[10:23:17.361]         if (NA) {
[10:23:17.361]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.361]                 open = "w")
[10:23:17.361]         }
[10:23:17.361]         else {
[10:23:17.361]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.361]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.361]         }
[10:23:17.361]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.361]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.361]             base::sink(type = "output", split = FALSE)
[10:23:17.361]             base::close(...future.stdout)
[10:23:17.361]         }, add = TRUE)
[10:23:17.361]     }
[10:23:17.361]     ...future.frame <- base::sys.nframe()
[10:23:17.361]     ...future.conditions <- base::list()
[10:23:17.361]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.361]     if (FALSE) {
[10:23:17.361]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.361]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.361]     }
[10:23:17.361]     ...future.result <- base::tryCatch({
[10:23:17.361]         base::withCallingHandlers({
[10:23:17.361]             ...future.value <- base::withVisible(base::local({
[10:23:17.361]                 withCallingHandlers({
[10:23:17.361]                   {
[10:23:17.361]                     print(1:50)
[10:23:17.361]                     str(1:50)
[10:23:17.361]                     cat(letters, sep = "-")
[10:23:17.361]                     cat(1:6, collapse = "\n")
[10:23:17.361]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.361]                     42L
[10:23:17.361]                   }
[10:23:17.361]                 }, immediateCondition = function(cond) {
[10:23:17.361]                   save_rds <- function (object, pathname, ...) 
[10:23:17.361]                   {
[10:23:17.361]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:23:17.361]                     if (file_test("-f", pathname_tmp)) {
[10:23:17.361]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.361]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:23:17.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.361]                         fi_tmp[["mtime"]])
[10:23:17.361]                     }
[10:23:17.361]                     tryCatch({
[10:23:17.361]                       saveRDS(object, file = pathname_tmp, ...)
[10:23:17.361]                     }, error = function(ex) {
[10:23:17.361]                       msg <- conditionMessage(ex)
[10:23:17.361]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.361]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:23:17.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.361]                         fi_tmp[["mtime"]], msg)
[10:23:17.361]                       ex$message <- msg
[10:23:17.361]                       stop(ex)
[10:23:17.361]                     })
[10:23:17.361]                     stopifnot(file_test("-f", pathname_tmp))
[10:23:17.361]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:23:17.361]                     if (!res || file_test("-f", pathname_tmp)) {
[10:23:17.361]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.361]                       fi <- file.info(pathname)
[10:23:17.361]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:23:17.361]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.361]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:23:17.361]                         fi[["size"]], fi[["mtime"]])
[10:23:17.361]                       stop(msg)
[10:23:17.361]                     }
[10:23:17.361]                     invisible(pathname)
[10:23:17.361]                   }
[10:23:17.361]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:23:17.361]                     rootPath = tempdir()) 
[10:23:17.361]                   {
[10:23:17.361]                     obj <- list(time = Sys.time(), condition = cond)
[10:23:17.361]                     file <- tempfile(pattern = class(cond)[1], 
[10:23:17.361]                       tmpdir = path, fileext = ".rds")
[10:23:17.361]                     save_rds(obj, file)
[10:23:17.361]                   }
[10:23:17.361]                   saveImmediateCondition(cond, path = "/tmp/RtmpQSLptV/.future/immediateConditions")
[10:23:17.361]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.361]                   {
[10:23:17.361]                     inherits <- base::inherits
[10:23:17.361]                     invokeRestart <- base::invokeRestart
[10:23:17.361]                     is.null <- base::is.null
[10:23:17.361]                     muffled <- FALSE
[10:23:17.361]                     if (inherits(cond, "message")) {
[10:23:17.361]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.361]                       if (muffled) 
[10:23:17.361]                         invokeRestart("muffleMessage")
[10:23:17.361]                     }
[10:23:17.361]                     else if (inherits(cond, "warning")) {
[10:23:17.361]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.361]                       if (muffled) 
[10:23:17.361]                         invokeRestart("muffleWarning")
[10:23:17.361]                     }
[10:23:17.361]                     else if (inherits(cond, "condition")) {
[10:23:17.361]                       if (!is.null(pattern)) {
[10:23:17.361]                         computeRestarts <- base::computeRestarts
[10:23:17.361]                         grepl <- base::grepl
[10:23:17.361]                         restarts <- computeRestarts(cond)
[10:23:17.361]                         for (restart in restarts) {
[10:23:17.361]                           name <- restart$name
[10:23:17.361]                           if (is.null(name)) 
[10:23:17.361]                             next
[10:23:17.361]                           if (!grepl(pattern, name)) 
[10:23:17.361]                             next
[10:23:17.361]                           invokeRestart(restart)
[10:23:17.361]                           muffled <- TRUE
[10:23:17.361]                           break
[10:23:17.361]                         }
[10:23:17.361]                       }
[10:23:17.361]                     }
[10:23:17.361]                     invisible(muffled)
[10:23:17.361]                   }
[10:23:17.361]                   muffleCondition(cond)
[10:23:17.361]                 })
[10:23:17.361]             }))
[10:23:17.361]             future::FutureResult(value = ...future.value$value, 
[10:23:17.361]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.361]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.361]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.361]                     ...future.globalenv.names))
[10:23:17.361]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.361]         }, condition = base::local({
[10:23:17.361]             c <- base::c
[10:23:17.361]             inherits <- base::inherits
[10:23:17.361]             invokeRestart <- base::invokeRestart
[10:23:17.361]             length <- base::length
[10:23:17.361]             list <- base::list
[10:23:17.361]             seq.int <- base::seq.int
[10:23:17.361]             signalCondition <- base::signalCondition
[10:23:17.361]             sys.calls <- base::sys.calls
[10:23:17.361]             `[[` <- base::`[[`
[10:23:17.361]             `+` <- base::`+`
[10:23:17.361]             `<<-` <- base::`<<-`
[10:23:17.361]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.361]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.361]                   3L)]
[10:23:17.361]             }
[10:23:17.361]             function(cond) {
[10:23:17.361]                 is_error <- inherits(cond, "error")
[10:23:17.361]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.361]                   NULL)
[10:23:17.361]                 if (is_error) {
[10:23:17.361]                   sessionInformation <- function() {
[10:23:17.361]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.361]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.361]                       search = base::search(), system = base::Sys.info())
[10:23:17.361]                   }
[10:23:17.361]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.361]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.361]                     cond$call), session = sessionInformation(), 
[10:23:17.361]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.361]                   signalCondition(cond)
[10:23:17.361]                 }
[10:23:17.361]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.361]                 "immediateCondition"))) {
[10:23:17.361]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.361]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.361]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.361]                   if (TRUE && !signal) {
[10:23:17.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.361]                     {
[10:23:17.361]                       inherits <- base::inherits
[10:23:17.361]                       invokeRestart <- base::invokeRestart
[10:23:17.361]                       is.null <- base::is.null
[10:23:17.361]                       muffled <- FALSE
[10:23:17.361]                       if (inherits(cond, "message")) {
[10:23:17.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.361]                         if (muffled) 
[10:23:17.361]                           invokeRestart("muffleMessage")
[10:23:17.361]                       }
[10:23:17.361]                       else if (inherits(cond, "warning")) {
[10:23:17.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.361]                         if (muffled) 
[10:23:17.361]                           invokeRestart("muffleWarning")
[10:23:17.361]                       }
[10:23:17.361]                       else if (inherits(cond, "condition")) {
[10:23:17.361]                         if (!is.null(pattern)) {
[10:23:17.361]                           computeRestarts <- base::computeRestarts
[10:23:17.361]                           grepl <- base::grepl
[10:23:17.361]                           restarts <- computeRestarts(cond)
[10:23:17.361]                           for (restart in restarts) {
[10:23:17.361]                             name <- restart$name
[10:23:17.361]                             if (is.null(name)) 
[10:23:17.361]                               next
[10:23:17.361]                             if (!grepl(pattern, name)) 
[10:23:17.361]                               next
[10:23:17.361]                             invokeRestart(restart)
[10:23:17.361]                             muffled <- TRUE
[10:23:17.361]                             break
[10:23:17.361]                           }
[10:23:17.361]                         }
[10:23:17.361]                       }
[10:23:17.361]                       invisible(muffled)
[10:23:17.361]                     }
[10:23:17.361]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.361]                   }
[10:23:17.361]                 }
[10:23:17.361]                 else {
[10:23:17.361]                   if (TRUE) {
[10:23:17.361]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.361]                     {
[10:23:17.361]                       inherits <- base::inherits
[10:23:17.361]                       invokeRestart <- base::invokeRestart
[10:23:17.361]                       is.null <- base::is.null
[10:23:17.361]                       muffled <- FALSE
[10:23:17.361]                       if (inherits(cond, "message")) {
[10:23:17.361]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.361]                         if (muffled) 
[10:23:17.361]                           invokeRestart("muffleMessage")
[10:23:17.361]                       }
[10:23:17.361]                       else if (inherits(cond, "warning")) {
[10:23:17.361]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.361]                         if (muffled) 
[10:23:17.361]                           invokeRestart("muffleWarning")
[10:23:17.361]                       }
[10:23:17.361]                       else if (inherits(cond, "condition")) {
[10:23:17.361]                         if (!is.null(pattern)) {
[10:23:17.361]                           computeRestarts <- base::computeRestarts
[10:23:17.361]                           grepl <- base::grepl
[10:23:17.361]                           restarts <- computeRestarts(cond)
[10:23:17.361]                           for (restart in restarts) {
[10:23:17.361]                             name <- restart$name
[10:23:17.361]                             if (is.null(name)) 
[10:23:17.361]                               next
[10:23:17.361]                             if (!grepl(pattern, name)) 
[10:23:17.361]                               next
[10:23:17.361]                             invokeRestart(restart)
[10:23:17.361]                             muffled <- TRUE
[10:23:17.361]                             break
[10:23:17.361]                           }
[10:23:17.361]                         }
[10:23:17.361]                       }
[10:23:17.361]                       invisible(muffled)
[10:23:17.361]                     }
[10:23:17.361]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.361]                   }
[10:23:17.361]                 }
[10:23:17.361]             }
[10:23:17.361]         }))
[10:23:17.361]     }, error = function(ex) {
[10:23:17.361]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.361]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.361]                 ...future.rng), started = ...future.startTime, 
[10:23:17.361]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.361]             version = "1.8"), class = "FutureResult")
[10:23:17.361]     }, finally = {
[10:23:17.361]         if (!identical(...future.workdir, getwd())) 
[10:23:17.361]             setwd(...future.workdir)
[10:23:17.361]         {
[10:23:17.361]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.361]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.361]             }
[10:23:17.361]             base::options(...future.oldOptions)
[10:23:17.361]             if (.Platform$OS.type == "windows") {
[10:23:17.361]                 old_names <- names(...future.oldEnvVars)
[10:23:17.361]                 envs <- base::Sys.getenv()
[10:23:17.361]                 names <- names(envs)
[10:23:17.361]                 common <- intersect(names, old_names)
[10:23:17.361]                 added <- setdiff(names, old_names)
[10:23:17.361]                 removed <- setdiff(old_names, names)
[10:23:17.361]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.361]                   envs[common]]
[10:23:17.361]                 NAMES <- toupper(changed)
[10:23:17.361]                 args <- list()
[10:23:17.361]                 for (kk in seq_along(NAMES)) {
[10:23:17.361]                   name <- changed[[kk]]
[10:23:17.361]                   NAME <- NAMES[[kk]]
[10:23:17.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.361]                     next
[10:23:17.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.361]                 }
[10:23:17.361]                 NAMES <- toupper(added)
[10:23:17.361]                 for (kk in seq_along(NAMES)) {
[10:23:17.361]                   name <- added[[kk]]
[10:23:17.361]                   NAME <- NAMES[[kk]]
[10:23:17.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.361]                     next
[10:23:17.361]                   args[[name]] <- ""
[10:23:17.361]                 }
[10:23:17.361]                 NAMES <- toupper(removed)
[10:23:17.361]                 for (kk in seq_along(NAMES)) {
[10:23:17.361]                   name <- removed[[kk]]
[10:23:17.361]                   NAME <- NAMES[[kk]]
[10:23:17.361]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.361]                     next
[10:23:17.361]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.361]                 }
[10:23:17.361]                 if (length(args) > 0) 
[10:23:17.361]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.361]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.361]             }
[10:23:17.361]             else {
[10:23:17.361]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.361]             }
[10:23:17.361]             {
[10:23:17.361]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.361]                   0L) {
[10:23:17.361]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.361]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.361]                   base::options(opts)
[10:23:17.361]                 }
[10:23:17.361]                 {
[10:23:17.361]                   {
[10:23:17.361]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.361]                     NULL
[10:23:17.361]                   }
[10:23:17.361]                   options(future.plan = NULL)
[10:23:17.361]                   if (is.na(NA_character_)) 
[10:23:17.361]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.361]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.361]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.361]                     .init = FALSE)
[10:23:17.361]                 }
[10:23:17.361]             }
[10:23:17.361]         }
[10:23:17.361]     })
[10:23:17.361]     if (FALSE) {
[10:23:17.361]         base::sink(type = "output", split = FALSE)
[10:23:17.361]         if (NA) {
[10:23:17.361]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.361]         }
[10:23:17.361]         else {
[10:23:17.361]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.361]         }
[10:23:17.361]         base::close(...future.stdout)
[10:23:17.361]         ...future.stdout <- NULL
[10:23:17.361]     }
[10:23:17.361]     ...future.result$conditions <- ...future.conditions
[10:23:17.361]     ...future.result$finished <- base::Sys.time()
[10:23:17.361]     ...future.result
[10:23:17.361] }
[10:23:17.363] requestCore(): workers = 2
[10:23:17.365] MulticoreFuture started
[10:23:17.366] - Launch lazy future ... done
[10:23:17.366] run() for ‘MulticoreFuture’ ... done
[10:23:17.366] result() for MulticoreFuture ...
[10:23:17.367] plan(): Setting new future strategy stack:
[10:23:17.367] List of future strategies:
[10:23:17.367] 1. sequential:
[10:23:17.367]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.367]    - tweaked: FALSE
[10:23:17.367]    - call: NULL
[10:23:17.368] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[10:23:17.371] plan(): Setting new future strategy stack:
[10:23:17.372] List of future strategies:
[10:23:17.372] 1. multicore:
[10:23:17.372]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.372]    - tweaked: FALSE
[10:23:17.372]    - call: plan(strategy)
[10:23:17.375] plan(): nbrOfWorkers() = 2
[10:23:17.376] result() for MulticoreFuture ...
[10:23:17.376] result() for MulticoreFuture ... done
[10:23:17.376] result() for MulticoreFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ finished    : POSIXct[1:1], format: "2025-11-19 10:23:17"
 $ session_uuid: chr "499ab7a4-c28f-1d55-4a58-7a8981c5fb48"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "eec1919a6b51"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 86309
  .. ..$ time  : POSIXct[1:1], format: "2025-11-19 10:23:17"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:23:17.386] result() for MulticoreFuture ...
[10:23:17.386] result() for MulticoreFuture ... done
[10:23:17.386] result() for MulticoreFuture ...
[10:23:17.386] result() for MulticoreFuture ... done
[10:23:17.387] getGlobalsAndPackages() ...
[10:23:17.387] Searching for globals...
[10:23:17.391] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:17.391] Searching for globals ... DONE
[10:23:17.391] Resolving globals: FALSE
[10:23:17.392] 
[10:23:17.392] - packages: [1] ‘utils’
[10:23:17.392] getGlobalsAndPackages() ... DONE
[10:23:17.392] run() for ‘Future’ ...
[10:23:17.393] - state: ‘created’
[10:23:17.393] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:23:17.395] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:17.395] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:23:17.395]   - Field: ‘label’
[10:23:17.395]   - Field: ‘local’
[10:23:17.395]   - Field: ‘owner’
[10:23:17.395]   - Field: ‘envir’
[10:23:17.396]   - Field: ‘workers’
[10:23:17.396]   - Field: ‘packages’
[10:23:17.396]   - Field: ‘gc’
[10:23:17.396]   - Field: ‘job’
[10:23:17.396]   - Field: ‘conditions’
[10:23:17.396]   - Field: ‘expr’
[10:23:17.396]   - Field: ‘uuid’
[10:23:17.396]   - Field: ‘seed’
[10:23:17.396]   - Field: ‘version’
[10:23:17.397]   - Field: ‘result’
[10:23:17.397]   - Field: ‘asynchronous’
[10:23:17.397]   - Field: ‘calls’
[10:23:17.397]   - Field: ‘globals’
[10:23:17.397]   - Field: ‘stdout’
[10:23:17.397]   - Field: ‘earlySignal’
[10:23:17.397]   - Field: ‘lazy’
[10:23:17.397]   - Field: ‘state’
[10:23:17.397] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:23:17.398] - Launch lazy future ...
[10:23:17.398] Packages needed by the future expression (n = 1): ‘utils’
[10:23:17.398] Packages needed by future strategies (n = 0): <none>
[10:23:17.399] {
[10:23:17.399]     {
[10:23:17.399]         {
[10:23:17.399]             ...future.startTime <- base::Sys.time()
[10:23:17.399]             {
[10:23:17.399]                 {
[10:23:17.399]                   {
[10:23:17.399]                     {
[10:23:17.399]                       {
[10:23:17.399]                         base::local({
[10:23:17.399]                           has_future <- base::requireNamespace("future", 
[10:23:17.399]                             quietly = TRUE)
[10:23:17.399]                           if (has_future) {
[10:23:17.399]                             ns <- base::getNamespace("future")
[10:23:17.399]                             version <- ns[[".package"]][["version"]]
[10:23:17.399]                             if (is.null(version)) 
[10:23:17.399]                               version <- utils::packageVersion("future")
[10:23:17.399]                           }
[10:23:17.399]                           else {
[10:23:17.399]                             version <- NULL
[10:23:17.399]                           }
[10:23:17.399]                           if (!has_future || version < "1.8.0") {
[10:23:17.399]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.399]                               "", base::R.version$version.string), 
[10:23:17.399]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:17.399]                                 base::R.version$platform, 8 * 
[10:23:17.399]                                   base::.Machine$sizeof.pointer), 
[10:23:17.399]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.399]                                 "release", "version")], collapse = " "), 
[10:23:17.399]                               hostname = base::Sys.info()[["nodename"]])
[10:23:17.399]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.399]                               info)
[10:23:17.399]                             info <- base::paste(info, collapse = "; ")
[10:23:17.399]                             if (!has_future) {
[10:23:17.399]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.399]                                 info)
[10:23:17.399]                             }
[10:23:17.399]                             else {
[10:23:17.399]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.399]                                 info, version)
[10:23:17.399]                             }
[10:23:17.399]                             base::stop(msg)
[10:23:17.399]                           }
[10:23:17.399]                         })
[10:23:17.399]                       }
[10:23:17.399]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.399]                       base::options(mc.cores = 1L)
[10:23:17.399]                     }
[10:23:17.399]                     base::local({
[10:23:17.399]                       for (pkg in "utils") {
[10:23:17.399]                         base::loadNamespace(pkg)
[10:23:17.399]                         base::library(pkg, character.only = TRUE)
[10:23:17.399]                       }
[10:23:17.399]                     })
[10:23:17.399]                   }
[10:23:17.399]                   ...future.strategy.old <- future::plan("list")
[10:23:17.399]                   options(future.plan = NULL)
[10:23:17.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.399]                 }
[10:23:17.399]                 ...future.workdir <- getwd()
[10:23:17.399]             }
[10:23:17.399]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.399]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.399]         }
[10:23:17.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.399]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.399]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.399]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.399]             base::names(...future.oldOptions))
[10:23:17.399]     }
[10:23:17.399]     if (TRUE) {
[10:23:17.399]     }
[10:23:17.399]     else {
[10:23:17.399]         if (NA) {
[10:23:17.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.399]                 open = "w")
[10:23:17.399]         }
[10:23:17.399]         else {
[10:23:17.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.399]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.399]         }
[10:23:17.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.399]             base::sink(type = "output", split = FALSE)
[10:23:17.399]             base::close(...future.stdout)
[10:23:17.399]         }, add = TRUE)
[10:23:17.399]     }
[10:23:17.399]     ...future.frame <- base::sys.nframe()
[10:23:17.399]     ...future.conditions <- base::list()
[10:23:17.399]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.399]     if (FALSE) {
[10:23:17.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.399]     }
[10:23:17.399]     ...future.result <- base::tryCatch({
[10:23:17.399]         base::withCallingHandlers({
[10:23:17.399]             ...future.value <- base::withVisible(base::local({
[10:23:17.399]                 withCallingHandlers({
[10:23:17.399]                   {
[10:23:17.399]                     print(1:50)
[10:23:17.399]                     str(1:50)
[10:23:17.399]                     cat(letters, sep = "-")
[10:23:17.399]                     cat(1:6, collapse = "\n")
[10:23:17.399]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:17.399]                     42L
[10:23:17.399]                   }
[10:23:17.399]                 }, immediateCondition = function(cond) {
[10:23:17.399]                   save_rds <- function (object, pathname, ...) 
[10:23:17.399]                   {
[10:23:17.399]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:23:17.399]                     if (file_test("-f", pathname_tmp)) {
[10:23:17.399]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.399]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:23:17.399]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.399]                         fi_tmp[["mtime"]])
[10:23:17.399]                     }
[10:23:17.399]                     tryCatch({
[10:23:17.399]                       saveRDS(object, file = pathname_tmp, ...)
[10:23:17.399]                     }, error = function(ex) {
[10:23:17.399]                       msg <- conditionMessage(ex)
[10:23:17.399]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.399]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:23:17.399]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.399]                         fi_tmp[["mtime"]], msg)
[10:23:17.399]                       ex$message <- msg
[10:23:17.399]                       stop(ex)
[10:23:17.399]                     })
[10:23:17.399]                     stopifnot(file_test("-f", pathname_tmp))
[10:23:17.399]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:23:17.399]                     if (!res || file_test("-f", pathname_tmp)) {
[10:23:17.399]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.399]                       fi <- file.info(pathname)
[10:23:17.399]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:23:17.399]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.399]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:23:17.399]                         fi[["size"]], fi[["mtime"]])
[10:23:17.399]                       stop(msg)
[10:23:17.399]                     }
[10:23:17.399]                     invisible(pathname)
[10:23:17.399]                   }
[10:23:17.399]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:23:17.399]                     rootPath = tempdir()) 
[10:23:17.399]                   {
[10:23:17.399]                     obj <- list(time = Sys.time(), condition = cond)
[10:23:17.399]                     file <- tempfile(pattern = class(cond)[1], 
[10:23:17.399]                       tmpdir = path, fileext = ".rds")
[10:23:17.399]                     save_rds(obj, file)
[10:23:17.399]                   }
[10:23:17.399]                   saveImmediateCondition(cond, path = "/tmp/RtmpQSLptV/.future/immediateConditions")
[10:23:17.399]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.399]                   {
[10:23:17.399]                     inherits <- base::inherits
[10:23:17.399]                     invokeRestart <- base::invokeRestart
[10:23:17.399]                     is.null <- base::is.null
[10:23:17.399]                     muffled <- FALSE
[10:23:17.399]                     if (inherits(cond, "message")) {
[10:23:17.399]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.399]                       if (muffled) 
[10:23:17.399]                         invokeRestart("muffleMessage")
[10:23:17.399]                     }
[10:23:17.399]                     else if (inherits(cond, "warning")) {
[10:23:17.399]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.399]                       if (muffled) 
[10:23:17.399]                         invokeRestart("muffleWarning")
[10:23:17.399]                     }
[10:23:17.399]                     else if (inherits(cond, "condition")) {
[10:23:17.399]                       if (!is.null(pattern)) {
[10:23:17.399]                         computeRestarts <- base::computeRestarts
[10:23:17.399]                         grepl <- base::grepl
[10:23:17.399]                         restarts <- computeRestarts(cond)
[10:23:17.399]                         for (restart in restarts) {
[10:23:17.399]                           name <- restart$name
[10:23:17.399]                           if (is.null(name)) 
[10:23:17.399]                             next
[10:23:17.399]                           if (!grepl(pattern, name)) 
[10:23:17.399]                             next
[10:23:17.399]                           invokeRestart(restart)
[10:23:17.399]                           muffled <- TRUE
[10:23:17.399]                           break
[10:23:17.399]                         }
[10:23:17.399]                       }
[10:23:17.399]                     }
[10:23:17.399]                     invisible(muffled)
[10:23:17.399]                   }
[10:23:17.399]                   muffleCondition(cond)
[10:23:17.399]                 })
[10:23:17.399]             }))
[10:23:17.399]             future::FutureResult(value = ...future.value$value, 
[10:23:17.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.399]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.399]                     ...future.globalenv.names))
[10:23:17.399]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.399]         }, condition = base::local({
[10:23:17.399]             c <- base::c
[10:23:17.399]             inherits <- base::inherits
[10:23:17.399]             invokeRestart <- base::invokeRestart
[10:23:17.399]             length <- base::length
[10:23:17.399]             list <- base::list
[10:23:17.399]             seq.int <- base::seq.int
[10:23:17.399]             signalCondition <- base::signalCondition
[10:23:17.399]             sys.calls <- base::sys.calls
[10:23:17.399]             `[[` <- base::`[[`
[10:23:17.399]             `+` <- base::`+`
[10:23:17.399]             `<<-` <- base::`<<-`
[10:23:17.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.399]                   3L)]
[10:23:17.399]             }
[10:23:17.399]             function(cond) {
[10:23:17.399]                 is_error <- inherits(cond, "error")
[10:23:17.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.399]                   NULL)
[10:23:17.399]                 if (is_error) {
[10:23:17.399]                   sessionInformation <- function() {
[10:23:17.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.399]                       search = base::search(), system = base::Sys.info())
[10:23:17.399]                   }
[10:23:17.399]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.399]                     cond$call), session = sessionInformation(), 
[10:23:17.399]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.399]                   signalCondition(cond)
[10:23:17.399]                 }
[10:23:17.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.399]                 "immediateCondition"))) {
[10:23:17.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.399]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.399]                   if (TRUE && !signal) {
[10:23:17.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.399]                     {
[10:23:17.399]                       inherits <- base::inherits
[10:23:17.399]                       invokeRestart <- base::invokeRestart
[10:23:17.399]                       is.null <- base::is.null
[10:23:17.399]                       muffled <- FALSE
[10:23:17.399]                       if (inherits(cond, "message")) {
[10:23:17.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.399]                         if (muffled) 
[10:23:17.399]                           invokeRestart("muffleMessage")
[10:23:17.399]                       }
[10:23:17.399]                       else if (inherits(cond, "warning")) {
[10:23:17.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.399]                         if (muffled) 
[10:23:17.399]                           invokeRestart("muffleWarning")
[10:23:17.399]                       }
[10:23:17.399]                       else if (inherits(cond, "condition")) {
[10:23:17.399]                         if (!is.null(pattern)) {
[10:23:17.399]                           computeRestarts <- base::computeRestarts
[10:23:17.399]                           grepl <- base::grepl
[10:23:17.399]                           restarts <- computeRestarts(cond)
[10:23:17.399]                           for (restart in restarts) {
[10:23:17.399]                             name <- restart$name
[10:23:17.399]                             if (is.null(name)) 
[10:23:17.399]                               next
[10:23:17.399]                             if (!grepl(pattern, name)) 
[10:23:17.399]                               next
[10:23:17.399]                             invokeRestart(restart)
[10:23:17.399]                             muffled <- TRUE
[10:23:17.399]                             break
[10:23:17.399]                           }
[10:23:17.399]                         }
[10:23:17.399]                       }
[10:23:17.399]                       invisible(muffled)
[10:23:17.399]                     }
[10:23:17.399]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.399]                   }
[10:23:17.399]                 }
[10:23:17.399]                 else {
[10:23:17.399]                   if (TRUE) {
[10:23:17.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.399]                     {
[10:23:17.399]                       inherits <- base::inherits
[10:23:17.399]                       invokeRestart <- base::invokeRestart
[10:23:17.399]                       is.null <- base::is.null
[10:23:17.399]                       muffled <- FALSE
[10:23:17.399]                       if (inherits(cond, "message")) {
[10:23:17.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.399]                         if (muffled) 
[10:23:17.399]                           invokeRestart("muffleMessage")
[10:23:17.399]                       }
[10:23:17.399]                       else if (inherits(cond, "warning")) {
[10:23:17.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.399]                         if (muffled) 
[10:23:17.399]                           invokeRestart("muffleWarning")
[10:23:17.399]                       }
[10:23:17.399]                       else if (inherits(cond, "condition")) {
[10:23:17.399]                         if (!is.null(pattern)) {
[10:23:17.399]                           computeRestarts <- base::computeRestarts
[10:23:17.399]                           grepl <- base::grepl
[10:23:17.399]                           restarts <- computeRestarts(cond)
[10:23:17.399]                           for (restart in restarts) {
[10:23:17.399]                             name <- restart$name
[10:23:17.399]                             if (is.null(name)) 
[10:23:17.399]                               next
[10:23:17.399]                             if (!grepl(pattern, name)) 
[10:23:17.399]                               next
[10:23:17.399]                             invokeRestart(restart)
[10:23:17.399]                             muffled <- TRUE
[10:23:17.399]                             break
[10:23:17.399]                           }
[10:23:17.399]                         }
[10:23:17.399]                       }
[10:23:17.399]                       invisible(muffled)
[10:23:17.399]                     }
[10:23:17.399]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.399]                   }
[10:23:17.399]                 }
[10:23:17.399]             }
[10:23:17.399]         }))
[10:23:17.399]     }, error = function(ex) {
[10:23:17.399]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.399]                 ...future.rng), started = ...future.startTime, 
[10:23:17.399]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.399]             version = "1.8"), class = "FutureResult")
[10:23:17.399]     }, finally = {
[10:23:17.399]         if (!identical(...future.workdir, getwd())) 
[10:23:17.399]             setwd(...future.workdir)
[10:23:17.399]         {
[10:23:17.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.399]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.399]             }
[10:23:17.399]             base::options(...future.oldOptions)
[10:23:17.399]             if (.Platform$OS.type == "windows") {
[10:23:17.399]                 old_names <- names(...future.oldEnvVars)
[10:23:17.399]                 envs <- base::Sys.getenv()
[10:23:17.399]                 names <- names(envs)
[10:23:17.399]                 common <- intersect(names, old_names)
[10:23:17.399]                 added <- setdiff(names, old_names)
[10:23:17.399]                 removed <- setdiff(old_names, names)
[10:23:17.399]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.399]                   envs[common]]
[10:23:17.399]                 NAMES <- toupper(changed)
[10:23:17.399]                 args <- list()
[10:23:17.399]                 for (kk in seq_along(NAMES)) {
[10:23:17.399]                   name <- changed[[kk]]
[10:23:17.399]                   NAME <- NAMES[[kk]]
[10:23:17.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.399]                     next
[10:23:17.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.399]                 }
[10:23:17.399]                 NAMES <- toupper(added)
[10:23:17.399]                 for (kk in seq_along(NAMES)) {
[10:23:17.399]                   name <- added[[kk]]
[10:23:17.399]                   NAME <- NAMES[[kk]]
[10:23:17.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.399]                     next
[10:23:17.399]                   args[[name]] <- ""
[10:23:17.399]                 }
[10:23:17.399]                 NAMES <- toupper(removed)
[10:23:17.399]                 for (kk in seq_along(NAMES)) {
[10:23:17.399]                   name <- removed[[kk]]
[10:23:17.399]                   NAME <- NAMES[[kk]]
[10:23:17.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.399]                     next
[10:23:17.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.399]                 }
[10:23:17.399]                 if (length(args) > 0) 
[10:23:17.399]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.399]             }
[10:23:17.399]             else {
[10:23:17.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.399]             }
[10:23:17.399]             {
[10:23:17.399]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.399]                   0L) {
[10:23:17.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.399]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.399]                   base::options(opts)
[10:23:17.399]                 }
[10:23:17.399]                 {
[10:23:17.399]                   {
[10:23:17.399]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.399]                     NULL
[10:23:17.399]                   }
[10:23:17.399]                   options(future.plan = NULL)
[10:23:17.399]                   if (is.na(NA_character_)) 
[10:23:17.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.399]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.399]                     .init = FALSE)
[10:23:17.399]                 }
[10:23:17.399]             }
[10:23:17.399]         }
[10:23:17.399]     })
[10:23:17.399]     if (FALSE) {
[10:23:17.399]         base::sink(type = "output", split = FALSE)
[10:23:17.399]         if (NA) {
[10:23:17.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.399]         }
[10:23:17.399]         else {
[10:23:17.399]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.399]         }
[10:23:17.399]         base::close(...future.stdout)
[10:23:17.399]         ...future.stdout <- NULL
[10:23:17.399]     }
[10:23:17.399]     ...future.result$conditions <- ...future.conditions
[10:23:17.399]     ...future.result$finished <- base::Sys.time()
[10:23:17.399]     ...future.result
[10:23:17.399] }
[10:23:17.402] requestCore(): workers = 2
[10:23:17.403] MulticoreFuture started
[10:23:17.404] - Launch lazy future ... done
[10:23:17.404] run() for ‘MulticoreFuture’ ... done
[10:23:17.405] result() for MulticoreFuture ...
[10:23:17.405] plan(): Setting new future strategy stack:
[10:23:17.405] List of future strategies:
[10:23:17.405] 1. sequential:
[10:23:17.405]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.405]    - tweaked: FALSE
[10:23:17.405]    - call: NULL
[10:23:17.406] plan(): nbrOfWorkers() = 1
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
[10:23:17.415] plan(): Setting new future strategy stack:
[10:23:17.415] List of future strategies:
[10:23:17.415] 1. multicore:
[10:23:17.415]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.415]    - tweaked: FALSE
[10:23:17.415]    - call: plan(strategy)
[10:23:17.418] plan(): nbrOfWorkers() = 2
[10:23:17.419] result() for MulticoreFuture ...
[10:23:17.419] result() for MulticoreFuture ... done
[10:23:17.419] result() for MulticoreFuture ... done
[10:23:17.419] result() for MulticoreFuture ...
[10:23:17.420] result() for MulticoreFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[10:23:17.423] getGlobalsAndPackages() ...
[10:23:17.423] Searching for globals...
[10:23:17.424] - globals found: [1] ‘print’
[10:23:17.424] Searching for globals ... DONE
[10:23:17.424] Resolving globals: FALSE
[10:23:17.425] 
[10:23:17.425] 
[10:23:17.425] getGlobalsAndPackages() ... DONE
[10:23:17.425] run() for ‘Future’ ...
[10:23:17.425] - state: ‘created’
[10:23:17.426] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:23:17.428] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:17.428] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:23:17.428]   - Field: ‘label’
[10:23:17.428]   - Field: ‘local’
[10:23:17.428]   - Field: ‘owner’
[10:23:17.428]   - Field: ‘envir’
[10:23:17.429]   - Field: ‘workers’
[10:23:17.429]   - Field: ‘packages’
[10:23:17.429]   - Field: ‘gc’
[10:23:17.429]   - Field: ‘job’
[10:23:17.429]   - Field: ‘conditions’
[10:23:17.429]   - Field: ‘expr’
[10:23:17.429]   - Field: ‘uuid’
[10:23:17.429]   - Field: ‘seed’
[10:23:17.429]   - Field: ‘version’
[10:23:17.430]   - Field: ‘result’
[10:23:17.430]   - Field: ‘asynchronous’
[10:23:17.430]   - Field: ‘calls’
[10:23:17.430]   - Field: ‘globals’
[10:23:17.430]   - Field: ‘stdout’
[10:23:17.430]   - Field: ‘earlySignal’
[10:23:17.430]   - Field: ‘lazy’
[10:23:17.430]   - Field: ‘state’
[10:23:17.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:23:17.431] - Launch lazy future ...
[10:23:17.431] Packages needed by the future expression (n = 0): <none>
[10:23:17.431] Packages needed by future strategies (n = 0): <none>
[10:23:17.432] {
[10:23:17.432]     {
[10:23:17.432]         {
[10:23:17.432]             ...future.startTime <- base::Sys.time()
[10:23:17.432]             {
[10:23:17.432]                 {
[10:23:17.432]                   {
[10:23:17.432]                     {
[10:23:17.432]                       base::local({
[10:23:17.432]                         has_future <- base::requireNamespace("future", 
[10:23:17.432]                           quietly = TRUE)
[10:23:17.432]                         if (has_future) {
[10:23:17.432]                           ns <- base::getNamespace("future")
[10:23:17.432]                           version <- ns[[".package"]][["version"]]
[10:23:17.432]                           if (is.null(version)) 
[10:23:17.432]                             version <- utils::packageVersion("future")
[10:23:17.432]                         }
[10:23:17.432]                         else {
[10:23:17.432]                           version <- NULL
[10:23:17.432]                         }
[10:23:17.432]                         if (!has_future || version < "1.8.0") {
[10:23:17.432]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.432]                             "", base::R.version$version.string), 
[10:23:17.432]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.432]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.432]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.432]                               "release", "version")], collapse = " "), 
[10:23:17.432]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.432]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.432]                             info)
[10:23:17.432]                           info <- base::paste(info, collapse = "; ")
[10:23:17.432]                           if (!has_future) {
[10:23:17.432]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.432]                               info)
[10:23:17.432]                           }
[10:23:17.432]                           else {
[10:23:17.432]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.432]                               info, version)
[10:23:17.432]                           }
[10:23:17.432]                           base::stop(msg)
[10:23:17.432]                         }
[10:23:17.432]                       })
[10:23:17.432]                     }
[10:23:17.432]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.432]                     base::options(mc.cores = 1L)
[10:23:17.432]                   }
[10:23:17.432]                   ...future.strategy.old <- future::plan("list")
[10:23:17.432]                   options(future.plan = NULL)
[10:23:17.432]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.432]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.432]                 }
[10:23:17.432]                 ...future.workdir <- getwd()
[10:23:17.432]             }
[10:23:17.432]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.432]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.432]         }
[10:23:17.432]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.432]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.432]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.432]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.432]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.432]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.432]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.432]             base::names(...future.oldOptions))
[10:23:17.432]     }
[10:23:17.432]     if (FALSE) {
[10:23:17.432]     }
[10:23:17.432]     else {
[10:23:17.432]         if (TRUE) {
[10:23:17.432]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.432]                 open = "w")
[10:23:17.432]         }
[10:23:17.432]         else {
[10:23:17.432]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.432]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.432]         }
[10:23:17.432]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.432]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.432]             base::sink(type = "output", split = FALSE)
[10:23:17.432]             base::close(...future.stdout)
[10:23:17.432]         }, add = TRUE)
[10:23:17.432]     }
[10:23:17.432]     ...future.frame <- base::sys.nframe()
[10:23:17.432]     ...future.conditions <- base::list()
[10:23:17.432]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.432]     if (FALSE) {
[10:23:17.432]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.432]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.432]     }
[10:23:17.432]     ...future.result <- base::tryCatch({
[10:23:17.432]         base::withCallingHandlers({
[10:23:17.432]             ...future.value <- base::withVisible(base::local({
[10:23:17.432]                 withCallingHandlers({
[10:23:17.432]                   print(42)
[10:23:17.432]                 }, immediateCondition = function(cond) {
[10:23:17.432]                   save_rds <- function (object, pathname, ...) 
[10:23:17.432]                   {
[10:23:17.432]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:23:17.432]                     if (file_test("-f", pathname_tmp)) {
[10:23:17.432]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.432]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:23:17.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.432]                         fi_tmp[["mtime"]])
[10:23:17.432]                     }
[10:23:17.432]                     tryCatch({
[10:23:17.432]                       saveRDS(object, file = pathname_tmp, ...)
[10:23:17.432]                     }, error = function(ex) {
[10:23:17.432]                       msg <- conditionMessage(ex)
[10:23:17.432]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.432]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:23:17.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.432]                         fi_tmp[["mtime"]], msg)
[10:23:17.432]                       ex$message <- msg
[10:23:17.432]                       stop(ex)
[10:23:17.432]                     })
[10:23:17.432]                     stopifnot(file_test("-f", pathname_tmp))
[10:23:17.432]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:23:17.432]                     if (!res || file_test("-f", pathname_tmp)) {
[10:23:17.432]                       fi_tmp <- file.info(pathname_tmp)
[10:23:17.432]                       fi <- file.info(pathname)
[10:23:17.432]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:23:17.432]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:23:17.432]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:23:17.432]                         fi[["size"]], fi[["mtime"]])
[10:23:17.432]                       stop(msg)
[10:23:17.432]                     }
[10:23:17.432]                     invisible(pathname)
[10:23:17.432]                   }
[10:23:17.432]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:23:17.432]                     rootPath = tempdir()) 
[10:23:17.432]                   {
[10:23:17.432]                     obj <- list(time = Sys.time(), condition = cond)
[10:23:17.432]                     file <- tempfile(pattern = class(cond)[1], 
[10:23:17.432]                       tmpdir = path, fileext = ".rds")
[10:23:17.432]                     save_rds(obj, file)
[10:23:17.432]                   }
[10:23:17.432]                   saveImmediateCondition(cond, path = "/tmp/RtmpQSLptV/.future/immediateConditions")
[10:23:17.432]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.432]                   {
[10:23:17.432]                     inherits <- base::inherits
[10:23:17.432]                     invokeRestart <- base::invokeRestart
[10:23:17.432]                     is.null <- base::is.null
[10:23:17.432]                     muffled <- FALSE
[10:23:17.432]                     if (inherits(cond, "message")) {
[10:23:17.432]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.432]                       if (muffled) 
[10:23:17.432]                         invokeRestart("muffleMessage")
[10:23:17.432]                     }
[10:23:17.432]                     else if (inherits(cond, "warning")) {
[10:23:17.432]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.432]                       if (muffled) 
[10:23:17.432]                         invokeRestart("muffleWarning")
[10:23:17.432]                     }
[10:23:17.432]                     else if (inherits(cond, "condition")) {
[10:23:17.432]                       if (!is.null(pattern)) {
[10:23:17.432]                         computeRestarts <- base::computeRestarts
[10:23:17.432]                         grepl <- base::grepl
[10:23:17.432]                         restarts <- computeRestarts(cond)
[10:23:17.432]                         for (restart in restarts) {
[10:23:17.432]                           name <- restart$name
[10:23:17.432]                           if (is.null(name)) 
[10:23:17.432]                             next
[10:23:17.432]                           if (!grepl(pattern, name)) 
[10:23:17.432]                             next
[10:23:17.432]                           invokeRestart(restart)
[10:23:17.432]                           muffled <- TRUE
[10:23:17.432]                           break
[10:23:17.432]                         }
[10:23:17.432]                       }
[10:23:17.432]                     }
[10:23:17.432]                     invisible(muffled)
[10:23:17.432]                   }
[10:23:17.432]                   muffleCondition(cond)
[10:23:17.432]                 })
[10:23:17.432]             }))
[10:23:17.432]             future::FutureResult(value = ...future.value$value, 
[10:23:17.432]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.432]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.432]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.432]                     ...future.globalenv.names))
[10:23:17.432]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.432]         }, condition = base::local({
[10:23:17.432]             c <- base::c
[10:23:17.432]             inherits <- base::inherits
[10:23:17.432]             invokeRestart <- base::invokeRestart
[10:23:17.432]             length <- base::length
[10:23:17.432]             list <- base::list
[10:23:17.432]             seq.int <- base::seq.int
[10:23:17.432]             signalCondition <- base::signalCondition
[10:23:17.432]             sys.calls <- base::sys.calls
[10:23:17.432]             `[[` <- base::`[[`
[10:23:17.432]             `+` <- base::`+`
[10:23:17.432]             `<<-` <- base::`<<-`
[10:23:17.432]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.432]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.432]                   3L)]
[10:23:17.432]             }
[10:23:17.432]             function(cond) {
[10:23:17.432]                 is_error <- inherits(cond, "error")
[10:23:17.432]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.432]                   NULL)
[10:23:17.432]                 if (is_error) {
[10:23:17.432]                   sessionInformation <- function() {
[10:23:17.432]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.432]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.432]                       search = base::search(), system = base::Sys.info())
[10:23:17.432]                   }
[10:23:17.432]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.432]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.432]                     cond$call), session = sessionInformation(), 
[10:23:17.432]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.432]                   signalCondition(cond)
[10:23:17.432]                 }
[10:23:17.432]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.432]                 "immediateCondition"))) {
[10:23:17.432]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.432]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.432]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.432]                   if (TRUE && !signal) {
[10:23:17.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.432]                     {
[10:23:17.432]                       inherits <- base::inherits
[10:23:17.432]                       invokeRestart <- base::invokeRestart
[10:23:17.432]                       is.null <- base::is.null
[10:23:17.432]                       muffled <- FALSE
[10:23:17.432]                       if (inherits(cond, "message")) {
[10:23:17.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.432]                         if (muffled) 
[10:23:17.432]                           invokeRestart("muffleMessage")
[10:23:17.432]                       }
[10:23:17.432]                       else if (inherits(cond, "warning")) {
[10:23:17.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.432]                         if (muffled) 
[10:23:17.432]                           invokeRestart("muffleWarning")
[10:23:17.432]                       }
[10:23:17.432]                       else if (inherits(cond, "condition")) {
[10:23:17.432]                         if (!is.null(pattern)) {
[10:23:17.432]                           computeRestarts <- base::computeRestarts
[10:23:17.432]                           grepl <- base::grepl
[10:23:17.432]                           restarts <- computeRestarts(cond)
[10:23:17.432]                           for (restart in restarts) {
[10:23:17.432]                             name <- restart$name
[10:23:17.432]                             if (is.null(name)) 
[10:23:17.432]                               next
[10:23:17.432]                             if (!grepl(pattern, name)) 
[10:23:17.432]                               next
[10:23:17.432]                             invokeRestart(restart)
[10:23:17.432]                             muffled <- TRUE
[10:23:17.432]                             break
[10:23:17.432]                           }
[10:23:17.432]                         }
[10:23:17.432]                       }
[10:23:17.432]                       invisible(muffled)
[10:23:17.432]                     }
[10:23:17.432]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.432]                   }
[10:23:17.432]                 }
[10:23:17.432]                 else {
[10:23:17.432]                   if (TRUE) {
[10:23:17.432]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.432]                     {
[10:23:17.432]                       inherits <- base::inherits
[10:23:17.432]                       invokeRestart <- base::invokeRestart
[10:23:17.432]                       is.null <- base::is.null
[10:23:17.432]                       muffled <- FALSE
[10:23:17.432]                       if (inherits(cond, "message")) {
[10:23:17.432]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.432]                         if (muffled) 
[10:23:17.432]                           invokeRestart("muffleMessage")
[10:23:17.432]                       }
[10:23:17.432]                       else if (inherits(cond, "warning")) {
[10:23:17.432]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.432]                         if (muffled) 
[10:23:17.432]                           invokeRestart("muffleWarning")
[10:23:17.432]                       }
[10:23:17.432]                       else if (inherits(cond, "condition")) {
[10:23:17.432]                         if (!is.null(pattern)) {
[10:23:17.432]                           computeRestarts <- base::computeRestarts
[10:23:17.432]                           grepl <- base::grepl
[10:23:17.432]                           restarts <- computeRestarts(cond)
[10:23:17.432]                           for (restart in restarts) {
[10:23:17.432]                             name <- restart$name
[10:23:17.432]                             if (is.null(name)) 
[10:23:17.432]                               next
[10:23:17.432]                             if (!grepl(pattern, name)) 
[10:23:17.432]                               next
[10:23:17.432]                             invokeRestart(restart)
[10:23:17.432]                             muffled <- TRUE
[10:23:17.432]                             break
[10:23:17.432]                           }
[10:23:17.432]                         }
[10:23:17.432]                       }
[10:23:17.432]                       invisible(muffled)
[10:23:17.432]                     }
[10:23:17.432]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.432]                   }
[10:23:17.432]                 }
[10:23:17.432]             }
[10:23:17.432]         }))
[10:23:17.432]     }, error = function(ex) {
[10:23:17.432]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.432]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.432]                 ...future.rng), started = ...future.startTime, 
[10:23:17.432]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.432]             version = "1.8"), class = "FutureResult")
[10:23:17.432]     }, finally = {
[10:23:17.432]         if (!identical(...future.workdir, getwd())) 
[10:23:17.432]             setwd(...future.workdir)
[10:23:17.432]         {
[10:23:17.432]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.432]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.432]             }
[10:23:17.432]             base::options(...future.oldOptions)
[10:23:17.432]             if (.Platform$OS.type == "windows") {
[10:23:17.432]                 old_names <- names(...future.oldEnvVars)
[10:23:17.432]                 envs <- base::Sys.getenv()
[10:23:17.432]                 names <- names(envs)
[10:23:17.432]                 common <- intersect(names, old_names)
[10:23:17.432]                 added <- setdiff(names, old_names)
[10:23:17.432]                 removed <- setdiff(old_names, names)
[10:23:17.432]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.432]                   envs[common]]
[10:23:17.432]                 NAMES <- toupper(changed)
[10:23:17.432]                 args <- list()
[10:23:17.432]                 for (kk in seq_along(NAMES)) {
[10:23:17.432]                   name <- changed[[kk]]
[10:23:17.432]                   NAME <- NAMES[[kk]]
[10:23:17.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.432]                     next
[10:23:17.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.432]                 }
[10:23:17.432]                 NAMES <- toupper(added)
[10:23:17.432]                 for (kk in seq_along(NAMES)) {
[10:23:17.432]                   name <- added[[kk]]
[10:23:17.432]                   NAME <- NAMES[[kk]]
[10:23:17.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.432]                     next
[10:23:17.432]                   args[[name]] <- ""
[10:23:17.432]                 }
[10:23:17.432]                 NAMES <- toupper(removed)
[10:23:17.432]                 for (kk in seq_along(NAMES)) {
[10:23:17.432]                   name <- removed[[kk]]
[10:23:17.432]                   NAME <- NAMES[[kk]]
[10:23:17.432]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.432]                     next
[10:23:17.432]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.432]                 }
[10:23:17.432]                 if (length(args) > 0) 
[10:23:17.432]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.432]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.432]             }
[10:23:17.432]             else {
[10:23:17.432]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.432]             }
[10:23:17.432]             {
[10:23:17.432]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.432]                   0L) {
[10:23:17.432]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.432]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.432]                   base::options(opts)
[10:23:17.432]                 }
[10:23:17.432]                 {
[10:23:17.432]                   {
[10:23:17.432]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.432]                     NULL
[10:23:17.432]                   }
[10:23:17.432]                   options(future.plan = NULL)
[10:23:17.432]                   if (is.na(NA_character_)) 
[10:23:17.432]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.432]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.432]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.432]                     .init = FALSE)
[10:23:17.432]                 }
[10:23:17.432]             }
[10:23:17.432]         }
[10:23:17.432]     })
[10:23:17.432]     if (TRUE) {
[10:23:17.432]         base::sink(type = "output", split = FALSE)
[10:23:17.432]         if (TRUE) {
[10:23:17.432]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.432]         }
[10:23:17.432]         else {
[10:23:17.432]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.432]         }
[10:23:17.432]         base::close(...future.stdout)
[10:23:17.432]         ...future.stdout <- NULL
[10:23:17.432]     }
[10:23:17.432]     ...future.result$conditions <- ...future.conditions
[10:23:17.432]     ...future.result$finished <- base::Sys.time()
[10:23:17.432]     ...future.result
[10:23:17.432] }
[10:23:17.434] requestCore(): workers = 2
[10:23:17.436] MulticoreFuture started
[10:23:17.436] - Launch lazy future ... done
[10:23:17.437] run() for ‘MulticoreFuture’ ... done
[10:23:17.437] result() for MulticoreFuture ...
[10:23:17.437] plan(): Setting new future strategy stack:
[10:23:17.437] List of future strategies:
[10:23:17.437] 1. sequential:
[10:23:17.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:17.437]    - tweaked: FALSE
[10:23:17.437]    - call: NULL
[10:23:17.438] plan(): nbrOfWorkers() = 1
[10:23:17.440] plan(): Setting new future strategy stack:
[10:23:17.441] List of future strategies:
[10:23:17.441] 1. multicore:
[10:23:17.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:23:17.441]    - tweaked: FALSE
[10:23:17.441]    - call: plan(strategy)
[10:23:17.444] plan(): nbrOfWorkers() = 2
[10:23:17.445] result() for MulticoreFuture ...
[10:23:17.445] result() for MulticoreFuture ... done
[10:23:17.445] result() for MulticoreFuture ... done
[10:23:17.445] result() for MulticoreFuture ...
[10:23:17.445] result() for MulticoreFuture ... done
[10:23:17.445] result() for MulticoreFuture ...
[10:23:17.446] result() for MulticoreFuture ... done
[1] 42
[10:23:17.446] result() for MulticoreFuture ...
[10:23:17.446] result() for MulticoreFuture ... done
multicore ... done
multisession ...
[10:23:17.446] plan(): Setting new future strategy stack:
[10:23:17.447] List of future strategies:
[10:23:17.447] 1. multisession:
[10:23:17.447]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:23:17.447]    - tweaked: FALSE
[10:23:17.447]    - call: plan(strategy)
[10:23:17.447] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:23:17.447] multisession:
[10:23:17.447] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:23:17.447] - tweaked: FALSE
[10:23:17.447] - call: plan(strategy)
[10:23:17.452] getGlobalsAndPackages() ...
[10:23:17.452] Not searching for globals
[10:23:17.452] - globals: [0] <none>
[10:23:17.453] getGlobalsAndPackages() ... DONE
[10:23:17.978] Packages needed by the future expression (n = 0): <none>
[10:23:17.978] Packages needed by future strategies (n = 0): <none>
[10:23:17.978] {
[10:23:17.978]     {
[10:23:17.978]         {
[10:23:17.978]             ...future.startTime <- base::Sys.time()
[10:23:17.978]             {
[10:23:17.978]                 {
[10:23:17.978]                   {
[10:23:17.978]                     {
[10:23:17.978]                       base::local({
[10:23:17.978]                         has_future <- base::requireNamespace("future", 
[10:23:17.978]                           quietly = TRUE)
[10:23:17.978]                         if (has_future) {
[10:23:17.978]                           ns <- base::getNamespace("future")
[10:23:17.978]                           version <- ns[[".package"]][["version"]]
[10:23:17.978]                           if (is.null(version)) 
[10:23:17.978]                             version <- utils::packageVersion("future")
[10:23:17.978]                         }
[10:23:17.978]                         else {
[10:23:17.978]                           version <- NULL
[10:23:17.978]                         }
[10:23:17.978]                         if (!has_future || version < "1.8.0") {
[10:23:17.978]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:17.978]                             "", base::R.version$version.string), 
[10:23:17.978]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:17.978]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:17.978]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:17.978]                               "release", "version")], collapse = " "), 
[10:23:17.978]                             hostname = base::Sys.info()[["nodename"]])
[10:23:17.978]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:17.978]                             info)
[10:23:17.978]                           info <- base::paste(info, collapse = "; ")
[10:23:17.978]                           if (!has_future) {
[10:23:17.978]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:17.978]                               info)
[10:23:17.978]                           }
[10:23:17.978]                           else {
[10:23:17.978]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:17.978]                               info, version)
[10:23:17.978]                           }
[10:23:17.978]                           base::stop(msg)
[10:23:17.978]                         }
[10:23:17.978]                       })
[10:23:17.978]                     }
[10:23:17.978]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:17.978]                     base::options(mc.cores = 1L)
[10:23:17.978]                   }
[10:23:17.978]                   ...future.strategy.old <- future::plan("list")
[10:23:17.978]                   options(future.plan = NULL)
[10:23:17.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:17.978]                 }
[10:23:17.978]                 ...future.workdir <- getwd()
[10:23:17.978]             }
[10:23:17.978]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:17.978]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:17.978]         }
[10:23:17.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:17.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:17.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:17.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:17.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:17.978]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:17.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:17.978]             base::names(...future.oldOptions))
[10:23:17.978]     }
[10:23:17.978]     if (FALSE) {
[10:23:17.978]     }
[10:23:17.978]     else {
[10:23:17.978]         if (TRUE) {
[10:23:17.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:17.978]                 open = "w")
[10:23:17.978]         }
[10:23:17.978]         else {
[10:23:17.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:17.978]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:17.978]         }
[10:23:17.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:17.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:17.978]             base::sink(type = "output", split = FALSE)
[10:23:17.978]             base::close(...future.stdout)
[10:23:17.978]         }, add = TRUE)
[10:23:17.978]     }
[10:23:17.978]     ...future.frame <- base::sys.nframe()
[10:23:17.978]     ...future.conditions <- base::list()
[10:23:17.978]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:17.978]     if (FALSE) {
[10:23:17.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:17.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:17.978]     }
[10:23:17.978]     ...future.result <- base::tryCatch({
[10:23:17.978]         base::withCallingHandlers({
[10:23:17.978]             ...future.value <- base::withVisible(base::local({
[10:23:17.978]                 ...future.makeSendCondition <- base::local({
[10:23:17.978]                   sendCondition <- NULL
[10:23:17.978]                   function(frame = 1L) {
[10:23:17.978]                     if (is.function(sendCondition)) 
[10:23:17.978]                       return(sendCondition)
[10:23:17.978]                     ns <- getNamespace("parallel")
[10:23:17.978]                     if (exists("sendData", mode = "function", 
[10:23:17.978]                       envir = ns)) {
[10:23:17.978]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:17.978]                         envir = ns)
[10:23:17.978]                       envir <- sys.frame(frame)
[10:23:17.978]                       master <- NULL
[10:23:17.978]                       while (!identical(envir, .GlobalEnv) && 
[10:23:17.978]                         !identical(envir, emptyenv())) {
[10:23:17.978]                         if (exists("master", mode = "list", envir = envir, 
[10:23:17.978]                           inherits = FALSE)) {
[10:23:17.978]                           master <- get("master", mode = "list", 
[10:23:17.978]                             envir = envir, inherits = FALSE)
[10:23:17.978]                           if (inherits(master, c("SOCKnode", 
[10:23:17.978]                             "SOCK0node"))) {
[10:23:17.978]                             sendCondition <<- function(cond) {
[10:23:17.978]                               data <- list(type = "VALUE", value = cond, 
[10:23:17.978]                                 success = TRUE)
[10:23:17.978]                               parallel_sendData(master, data)
[10:23:17.978]                             }
[10:23:17.978]                             return(sendCondition)
[10:23:17.978]                           }
[10:23:17.978]                         }
[10:23:17.978]                         frame <- frame + 1L
[10:23:17.978]                         envir <- sys.frame(frame)
[10:23:17.978]                       }
[10:23:17.978]                     }
[10:23:17.978]                     sendCondition <<- function(cond) NULL
[10:23:17.978]                   }
[10:23:17.978]                 })
[10:23:17.978]                 withCallingHandlers({
[10:23:17.978]                   NA
[10:23:17.978]                 }, immediateCondition = function(cond) {
[10:23:17.978]                   sendCondition <- ...future.makeSendCondition()
[10:23:17.978]                   sendCondition(cond)
[10:23:17.978]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.978]                   {
[10:23:17.978]                     inherits <- base::inherits
[10:23:17.978]                     invokeRestart <- base::invokeRestart
[10:23:17.978]                     is.null <- base::is.null
[10:23:17.978]                     muffled <- FALSE
[10:23:17.978]                     if (inherits(cond, "message")) {
[10:23:17.978]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:17.978]                       if (muffled) 
[10:23:17.978]                         invokeRestart("muffleMessage")
[10:23:17.978]                     }
[10:23:17.978]                     else if (inherits(cond, "warning")) {
[10:23:17.978]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:17.978]                       if (muffled) 
[10:23:17.978]                         invokeRestart("muffleWarning")
[10:23:17.978]                     }
[10:23:17.978]                     else if (inherits(cond, "condition")) {
[10:23:17.978]                       if (!is.null(pattern)) {
[10:23:17.978]                         computeRestarts <- base::computeRestarts
[10:23:17.978]                         grepl <- base::grepl
[10:23:17.978]                         restarts <- computeRestarts(cond)
[10:23:17.978]                         for (restart in restarts) {
[10:23:17.978]                           name <- restart$name
[10:23:17.978]                           if (is.null(name)) 
[10:23:17.978]                             next
[10:23:17.978]                           if (!grepl(pattern, name)) 
[10:23:17.978]                             next
[10:23:17.978]                           invokeRestart(restart)
[10:23:17.978]                           muffled <- TRUE
[10:23:17.978]                           break
[10:23:17.978]                         }
[10:23:17.978]                       }
[10:23:17.978]                     }
[10:23:17.978]                     invisible(muffled)
[10:23:17.978]                   }
[10:23:17.978]                   muffleCondition(cond)
[10:23:17.978]                 })
[10:23:17.978]             }))
[10:23:17.978]             future::FutureResult(value = ...future.value$value, 
[10:23:17.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.978]                   ...future.rng), globalenv = if (FALSE) 
[10:23:17.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:17.978]                     ...future.globalenv.names))
[10:23:17.978]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:17.978]         }, condition = base::local({
[10:23:17.978]             c <- base::c
[10:23:17.978]             inherits <- base::inherits
[10:23:17.978]             invokeRestart <- base::invokeRestart
[10:23:17.978]             length <- base::length
[10:23:17.978]             list <- base::list
[10:23:17.978]             seq.int <- base::seq.int
[10:23:17.978]             signalCondition <- base::signalCondition
[10:23:17.978]             sys.calls <- base::sys.calls
[10:23:17.978]             `[[` <- base::`[[`
[10:23:17.978]             `+` <- base::`+`
[10:23:17.978]             `<<-` <- base::`<<-`
[10:23:17.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:17.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:17.978]                   3L)]
[10:23:17.978]             }
[10:23:17.978]             function(cond) {
[10:23:17.978]                 is_error <- inherits(cond, "error")
[10:23:17.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:17.978]                   NULL)
[10:23:17.978]                 if (is_error) {
[10:23:17.978]                   sessionInformation <- function() {
[10:23:17.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:17.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:17.978]                       search = base::search(), system = base::Sys.info())
[10:23:17.978]                   }
[10:23:17.978]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:17.978]                     cond$call), session = sessionInformation(), 
[10:23:17.978]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:17.978]                   signalCondition(cond)
[10:23:17.978]                 }
[10:23:17.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:17.978]                 "immediateCondition"))) {
[10:23:17.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:17.978]                   ...future.conditions[[length(...future.conditions) + 
[10:23:17.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:17.978]                   if (TRUE && !signal) {
[10:23:17.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.978]                     {
[10:23:17.978]                       inherits <- base::inherits
[10:23:17.978]                       invokeRestart <- base::invokeRestart
[10:23:17.978]                       is.null <- base::is.null
[10:23:17.978]                       muffled <- FALSE
[10:23:17.978]                       if (inherits(cond, "message")) {
[10:23:17.978]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.978]                         if (muffled) 
[10:23:17.978]                           invokeRestart("muffleMessage")
[10:23:17.978]                       }
[10:23:17.978]                       else if (inherits(cond, "warning")) {
[10:23:17.978]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.978]                         if (muffled) 
[10:23:17.978]                           invokeRestart("muffleWarning")
[10:23:17.978]                       }
[10:23:17.978]                       else if (inherits(cond, "condition")) {
[10:23:17.978]                         if (!is.null(pattern)) {
[10:23:17.978]                           computeRestarts <- base::computeRestarts
[10:23:17.978]                           grepl <- base::grepl
[10:23:17.978]                           restarts <- computeRestarts(cond)
[10:23:17.978]                           for (restart in restarts) {
[10:23:17.978]                             name <- restart$name
[10:23:17.978]                             if (is.null(name)) 
[10:23:17.978]                               next
[10:23:17.978]                             if (!grepl(pattern, name)) 
[10:23:17.978]                               next
[10:23:17.978]                             invokeRestart(restart)
[10:23:17.978]                             muffled <- TRUE
[10:23:17.978]                             break
[10:23:17.978]                           }
[10:23:17.978]                         }
[10:23:17.978]                       }
[10:23:17.978]                       invisible(muffled)
[10:23:17.978]                     }
[10:23:17.978]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.978]                   }
[10:23:17.978]                 }
[10:23:17.978]                 else {
[10:23:17.978]                   if (TRUE) {
[10:23:17.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:17.978]                     {
[10:23:17.978]                       inherits <- base::inherits
[10:23:17.978]                       invokeRestart <- base::invokeRestart
[10:23:17.978]                       is.null <- base::is.null
[10:23:17.978]                       muffled <- FALSE
[10:23:17.978]                       if (inherits(cond, "message")) {
[10:23:17.978]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:17.978]                         if (muffled) 
[10:23:17.978]                           invokeRestart("muffleMessage")
[10:23:17.978]                       }
[10:23:17.978]                       else if (inherits(cond, "warning")) {
[10:23:17.978]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:17.978]                         if (muffled) 
[10:23:17.978]                           invokeRestart("muffleWarning")
[10:23:17.978]                       }
[10:23:17.978]                       else if (inherits(cond, "condition")) {
[10:23:17.978]                         if (!is.null(pattern)) {
[10:23:17.978]                           computeRestarts <- base::computeRestarts
[10:23:17.978]                           grepl <- base::grepl
[10:23:17.978]                           restarts <- computeRestarts(cond)
[10:23:17.978]                           for (restart in restarts) {
[10:23:17.978]                             name <- restart$name
[10:23:17.978]                             if (is.null(name)) 
[10:23:17.978]                               next
[10:23:17.978]                             if (!grepl(pattern, name)) 
[10:23:17.978]                               next
[10:23:17.978]                             invokeRestart(restart)
[10:23:17.978]                             muffled <- TRUE
[10:23:17.978]                             break
[10:23:17.978]                           }
[10:23:17.978]                         }
[10:23:17.978]                       }
[10:23:17.978]                       invisible(muffled)
[10:23:17.978]                     }
[10:23:17.978]                     muffleCondition(cond, pattern = "^muffle")
[10:23:17.978]                   }
[10:23:17.978]                 }
[10:23:17.978]             }
[10:23:17.978]         }))
[10:23:17.978]     }, error = function(ex) {
[10:23:17.978]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:17.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:17.978]                 ...future.rng), started = ...future.startTime, 
[10:23:17.978]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:17.978]             version = "1.8"), class = "FutureResult")
[10:23:17.978]     }, finally = {
[10:23:17.978]         if (!identical(...future.workdir, getwd())) 
[10:23:17.978]             setwd(...future.workdir)
[10:23:17.978]         {
[10:23:17.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:17.978]                 ...future.oldOptions$nwarnings <- NULL
[10:23:17.978]             }
[10:23:17.978]             base::options(...future.oldOptions)
[10:23:17.978]             if (.Platform$OS.type == "windows") {
[10:23:17.978]                 old_names <- names(...future.oldEnvVars)
[10:23:17.978]                 envs <- base::Sys.getenv()
[10:23:17.978]                 names <- names(envs)
[10:23:17.978]                 common <- intersect(names, old_names)
[10:23:17.978]                 added <- setdiff(names, old_names)
[10:23:17.978]                 removed <- setdiff(old_names, names)
[10:23:17.978]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:17.978]                   envs[common]]
[10:23:17.978]                 NAMES <- toupper(changed)
[10:23:17.978]                 args <- list()
[10:23:17.978]                 for (kk in seq_along(NAMES)) {
[10:23:17.978]                   name <- changed[[kk]]
[10:23:17.978]                   NAME <- NAMES[[kk]]
[10:23:17.978]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.978]                     next
[10:23:17.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.978]                 }
[10:23:17.978]                 NAMES <- toupper(added)
[10:23:17.978]                 for (kk in seq_along(NAMES)) {
[10:23:17.978]                   name <- added[[kk]]
[10:23:17.978]                   NAME <- NAMES[[kk]]
[10:23:17.978]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.978]                     next
[10:23:17.978]                   args[[name]] <- ""
[10:23:17.978]                 }
[10:23:17.978]                 NAMES <- toupper(removed)
[10:23:17.978]                 for (kk in seq_along(NAMES)) {
[10:23:17.978]                   name <- removed[[kk]]
[10:23:17.978]                   NAME <- NAMES[[kk]]
[10:23:17.978]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:17.978]                     next
[10:23:17.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:17.978]                 }
[10:23:17.978]                 if (length(args) > 0) 
[10:23:17.978]                   base::do.call(base::Sys.setenv, args = args)
[10:23:17.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:17.978]             }
[10:23:17.978]             else {
[10:23:17.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:17.978]             }
[10:23:17.978]             {
[10:23:17.978]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:17.978]                   0L) {
[10:23:17.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:17.978]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:17.978]                   base::options(opts)
[10:23:17.978]                 }
[10:23:17.978]                 {
[10:23:17.978]                   {
[10:23:17.978]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:17.978]                     NULL
[10:23:17.978]                   }
[10:23:17.978]                   options(future.plan = NULL)
[10:23:17.978]                   if (is.na(NA_character_)) 
[10:23:17.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:17.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:17.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:17.978]                     .init = FALSE)
[10:23:17.978]                 }
[10:23:17.978]             }
[10:23:17.978]         }
[10:23:17.978]     })
[10:23:17.978]     if (TRUE) {
[10:23:17.978]         base::sink(type = "output", split = FALSE)
[10:23:17.978]         if (TRUE) {
[10:23:17.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:17.978]         }
[10:23:17.978]         else {
[10:23:17.978]             ...future.result["stdout"] <- base::list(NULL)
[10:23:17.978]         }
[10:23:17.978]         base::close(...future.stdout)
[10:23:17.978]         ...future.stdout <- NULL
[10:23:17.978]     }
[10:23:17.978]     ...future.result$conditions <- ...future.conditions
[10:23:17.978]     ...future.result$finished <- base::Sys.time()
[10:23:17.978]     ...future.result
[10:23:17.978] }
[10:23:18.030] MultisessionFuture started
[10:23:18.031] result() for ClusterFuture ...
[10:23:18.031] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.031] - Validating connection of MultisessionFuture
[10:23:18.062] - received message: FutureResult
[10:23:18.062] - Received FutureResult
[10:23:18.062] - Erased future from FutureRegistry
[10:23:18.062] result() for ClusterFuture ...
[10:23:18.062] - result already collected: FutureResult
[10:23:18.063] result() for ClusterFuture ... done
[10:23:18.063] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.063] result() for ClusterFuture ... done
[10:23:18.063] result() for ClusterFuture ...
[10:23:18.063] - result already collected: FutureResult
[10:23:18.063] result() for ClusterFuture ... done
[10:23:18.063] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:23:18.065] plan(): nbrOfWorkers() = 2
- stdout = TRUE
[10:23:18.065] getGlobalsAndPackages() ...
[10:23:18.065] Searching for globals...
[10:23:18.068] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:18.068] Searching for globals ... DONE
[10:23:18.068] Resolving globals: FALSE
[10:23:18.069] 
[10:23:18.069] - packages: [1] ‘utils’
[10:23:18.069] getGlobalsAndPackages() ... DONE
[10:23:18.069] run() for ‘Future’ ...
[10:23:18.069] - state: ‘created’
[10:23:18.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:23:18.083] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:18.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:23:18.083]   - Field: ‘node’
[10:23:18.084]   - Field: ‘label’
[10:23:18.084]   - Field: ‘local’
[10:23:18.084]   - Field: ‘owner’
[10:23:18.084]   - Field: ‘envir’
[10:23:18.084]   - Field: ‘workers’
[10:23:18.084]   - Field: ‘packages’
[10:23:18.084]   - Field: ‘gc’
[10:23:18.084]   - Field: ‘conditions’
[10:23:18.084]   - Field: ‘persistent’
[10:23:18.084]   - Field: ‘expr’
[10:23:18.084]   - Field: ‘uuid’
[10:23:18.084]   - Field: ‘seed’
[10:23:18.085]   - Field: ‘version’
[10:23:18.085]   - Field: ‘result’
[10:23:18.085]   - Field: ‘asynchronous’
[10:23:18.085]   - Field: ‘calls’
[10:23:18.085]   - Field: ‘globals’
[10:23:18.085]   - Field: ‘stdout’
[10:23:18.085]   - Field: ‘earlySignal’
[10:23:18.085]   - Field: ‘lazy’
[10:23:18.085]   - Field: ‘state’
[10:23:18.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:23:18.085] - Launch lazy future ...
[10:23:18.086] Packages needed by the future expression (n = 1): ‘utils’
[10:23:18.086] Packages needed by future strategies (n = 0): <none>
[10:23:18.086] {
[10:23:18.086]     {
[10:23:18.086]         {
[10:23:18.086]             ...future.startTime <- base::Sys.time()
[10:23:18.086]             {
[10:23:18.086]                 {
[10:23:18.086]                   {
[10:23:18.086]                     {
[10:23:18.086]                       {
[10:23:18.086]                         base::local({
[10:23:18.086]                           has_future <- base::requireNamespace("future", 
[10:23:18.086]                             quietly = TRUE)
[10:23:18.086]                           if (has_future) {
[10:23:18.086]                             ns <- base::getNamespace("future")
[10:23:18.086]                             version <- ns[[".package"]][["version"]]
[10:23:18.086]                             if (is.null(version)) 
[10:23:18.086]                               version <- utils::packageVersion("future")
[10:23:18.086]                           }
[10:23:18.086]                           else {
[10:23:18.086]                             version <- NULL
[10:23:18.086]                           }
[10:23:18.086]                           if (!has_future || version < "1.8.0") {
[10:23:18.086]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:18.086]                               "", base::R.version$version.string), 
[10:23:18.086]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:18.086]                                 base::R.version$platform, 8 * 
[10:23:18.086]                                   base::.Machine$sizeof.pointer), 
[10:23:18.086]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:18.086]                                 "release", "version")], collapse = " "), 
[10:23:18.086]                               hostname = base::Sys.info()[["nodename"]])
[10:23:18.086]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:18.086]                               info)
[10:23:18.086]                             info <- base::paste(info, collapse = "; ")
[10:23:18.086]                             if (!has_future) {
[10:23:18.086]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:18.086]                                 info)
[10:23:18.086]                             }
[10:23:18.086]                             else {
[10:23:18.086]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:18.086]                                 info, version)
[10:23:18.086]                             }
[10:23:18.086]                             base::stop(msg)
[10:23:18.086]                           }
[10:23:18.086]                         })
[10:23:18.086]                       }
[10:23:18.086]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:18.086]                       base::options(mc.cores = 1L)
[10:23:18.086]                     }
[10:23:18.086]                     base::local({
[10:23:18.086]                       for (pkg in "utils") {
[10:23:18.086]                         base::loadNamespace(pkg)
[10:23:18.086]                         base::library(pkg, character.only = TRUE)
[10:23:18.086]                       }
[10:23:18.086]                     })
[10:23:18.086]                   }
[10:23:18.086]                   ...future.strategy.old <- future::plan("list")
[10:23:18.086]                   options(future.plan = NULL)
[10:23:18.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:18.086]                 }
[10:23:18.086]                 ...future.workdir <- getwd()
[10:23:18.086]             }
[10:23:18.086]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:18.086]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:18.086]         }
[10:23:18.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:18.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:18.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:18.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:18.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:18.086]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:18.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:18.086]             base::names(...future.oldOptions))
[10:23:18.086]     }
[10:23:18.086]     if (FALSE) {
[10:23:18.086]     }
[10:23:18.086]     else {
[10:23:18.086]         if (TRUE) {
[10:23:18.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:18.086]                 open = "w")
[10:23:18.086]         }
[10:23:18.086]         else {
[10:23:18.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:18.086]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:18.086]         }
[10:23:18.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:18.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:18.086]             base::sink(type = "output", split = FALSE)
[10:23:18.086]             base::close(...future.stdout)
[10:23:18.086]         }, add = TRUE)
[10:23:18.086]     }
[10:23:18.086]     ...future.frame <- base::sys.nframe()
[10:23:18.086]     ...future.conditions <- base::list()
[10:23:18.086]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:18.086]     if (FALSE) {
[10:23:18.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:18.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:18.086]     }
[10:23:18.086]     ...future.result <- base::tryCatch({
[10:23:18.086]         base::withCallingHandlers({
[10:23:18.086]             ...future.value <- base::withVisible(base::local({
[10:23:18.086]                 ...future.makeSendCondition <- base::local({
[10:23:18.086]                   sendCondition <- NULL
[10:23:18.086]                   function(frame = 1L) {
[10:23:18.086]                     if (is.function(sendCondition)) 
[10:23:18.086]                       return(sendCondition)
[10:23:18.086]                     ns <- getNamespace("parallel")
[10:23:18.086]                     if (exists("sendData", mode = "function", 
[10:23:18.086]                       envir = ns)) {
[10:23:18.086]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:18.086]                         envir = ns)
[10:23:18.086]                       envir <- sys.frame(frame)
[10:23:18.086]                       master <- NULL
[10:23:18.086]                       while (!identical(envir, .GlobalEnv) && 
[10:23:18.086]                         !identical(envir, emptyenv())) {
[10:23:18.086]                         if (exists("master", mode = "list", envir = envir, 
[10:23:18.086]                           inherits = FALSE)) {
[10:23:18.086]                           master <- get("master", mode = "list", 
[10:23:18.086]                             envir = envir, inherits = FALSE)
[10:23:18.086]                           if (inherits(master, c("SOCKnode", 
[10:23:18.086]                             "SOCK0node"))) {
[10:23:18.086]                             sendCondition <<- function(cond) {
[10:23:18.086]                               data <- list(type = "VALUE", value = cond, 
[10:23:18.086]                                 success = TRUE)
[10:23:18.086]                               parallel_sendData(master, data)
[10:23:18.086]                             }
[10:23:18.086]                             return(sendCondition)
[10:23:18.086]                           }
[10:23:18.086]                         }
[10:23:18.086]                         frame <- frame + 1L
[10:23:18.086]                         envir <- sys.frame(frame)
[10:23:18.086]                       }
[10:23:18.086]                     }
[10:23:18.086]                     sendCondition <<- function(cond) NULL
[10:23:18.086]                   }
[10:23:18.086]                 })
[10:23:18.086]                 withCallingHandlers({
[10:23:18.086]                   {
[10:23:18.086]                     print(1:50)
[10:23:18.086]                     str(1:50)
[10:23:18.086]                     cat(letters, sep = "-")
[10:23:18.086]                     cat(1:6, collapse = "\n")
[10:23:18.086]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:18.086]                     42L
[10:23:18.086]                   }
[10:23:18.086]                 }, immediateCondition = function(cond) {
[10:23:18.086]                   sendCondition <- ...future.makeSendCondition()
[10:23:18.086]                   sendCondition(cond)
[10:23:18.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.086]                   {
[10:23:18.086]                     inherits <- base::inherits
[10:23:18.086]                     invokeRestart <- base::invokeRestart
[10:23:18.086]                     is.null <- base::is.null
[10:23:18.086]                     muffled <- FALSE
[10:23:18.086]                     if (inherits(cond, "message")) {
[10:23:18.086]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:18.086]                       if (muffled) 
[10:23:18.086]                         invokeRestart("muffleMessage")
[10:23:18.086]                     }
[10:23:18.086]                     else if (inherits(cond, "warning")) {
[10:23:18.086]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:18.086]                       if (muffled) 
[10:23:18.086]                         invokeRestart("muffleWarning")
[10:23:18.086]                     }
[10:23:18.086]                     else if (inherits(cond, "condition")) {
[10:23:18.086]                       if (!is.null(pattern)) {
[10:23:18.086]                         computeRestarts <- base::computeRestarts
[10:23:18.086]                         grepl <- base::grepl
[10:23:18.086]                         restarts <- computeRestarts(cond)
[10:23:18.086]                         for (restart in restarts) {
[10:23:18.086]                           name <- restart$name
[10:23:18.086]                           if (is.null(name)) 
[10:23:18.086]                             next
[10:23:18.086]                           if (!grepl(pattern, name)) 
[10:23:18.086]                             next
[10:23:18.086]                           invokeRestart(restart)
[10:23:18.086]                           muffled <- TRUE
[10:23:18.086]                           break
[10:23:18.086]                         }
[10:23:18.086]                       }
[10:23:18.086]                     }
[10:23:18.086]                     invisible(muffled)
[10:23:18.086]                   }
[10:23:18.086]                   muffleCondition(cond)
[10:23:18.086]                 })
[10:23:18.086]             }))
[10:23:18.086]             future::FutureResult(value = ...future.value$value, 
[10:23:18.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.086]                   ...future.rng), globalenv = if (FALSE) 
[10:23:18.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:18.086]                     ...future.globalenv.names))
[10:23:18.086]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:18.086]         }, condition = base::local({
[10:23:18.086]             c <- base::c
[10:23:18.086]             inherits <- base::inherits
[10:23:18.086]             invokeRestart <- base::invokeRestart
[10:23:18.086]             length <- base::length
[10:23:18.086]             list <- base::list
[10:23:18.086]             seq.int <- base::seq.int
[10:23:18.086]             signalCondition <- base::signalCondition
[10:23:18.086]             sys.calls <- base::sys.calls
[10:23:18.086]             `[[` <- base::`[[`
[10:23:18.086]             `+` <- base::`+`
[10:23:18.086]             `<<-` <- base::`<<-`
[10:23:18.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:18.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:18.086]                   3L)]
[10:23:18.086]             }
[10:23:18.086]             function(cond) {
[10:23:18.086]                 is_error <- inherits(cond, "error")
[10:23:18.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:18.086]                   NULL)
[10:23:18.086]                 if (is_error) {
[10:23:18.086]                   sessionInformation <- function() {
[10:23:18.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:18.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:18.086]                       search = base::search(), system = base::Sys.info())
[10:23:18.086]                   }
[10:23:18.086]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:18.086]                     cond$call), session = sessionInformation(), 
[10:23:18.086]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:18.086]                   signalCondition(cond)
[10:23:18.086]                 }
[10:23:18.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:18.086]                 "immediateCondition"))) {
[10:23:18.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:18.086]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:18.086]                   if (TRUE && !signal) {
[10:23:18.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.086]                     {
[10:23:18.086]                       inherits <- base::inherits
[10:23:18.086]                       invokeRestart <- base::invokeRestart
[10:23:18.086]                       is.null <- base::is.null
[10:23:18.086]                       muffled <- FALSE
[10:23:18.086]                       if (inherits(cond, "message")) {
[10:23:18.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.086]                         if (muffled) 
[10:23:18.086]                           invokeRestart("muffleMessage")
[10:23:18.086]                       }
[10:23:18.086]                       else if (inherits(cond, "warning")) {
[10:23:18.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.086]                         if (muffled) 
[10:23:18.086]                           invokeRestart("muffleWarning")
[10:23:18.086]                       }
[10:23:18.086]                       else if (inherits(cond, "condition")) {
[10:23:18.086]                         if (!is.null(pattern)) {
[10:23:18.086]                           computeRestarts <- base::computeRestarts
[10:23:18.086]                           grepl <- base::grepl
[10:23:18.086]                           restarts <- computeRestarts(cond)
[10:23:18.086]                           for (restart in restarts) {
[10:23:18.086]                             name <- restart$name
[10:23:18.086]                             if (is.null(name)) 
[10:23:18.086]                               next
[10:23:18.086]                             if (!grepl(pattern, name)) 
[10:23:18.086]                               next
[10:23:18.086]                             invokeRestart(restart)
[10:23:18.086]                             muffled <- TRUE
[10:23:18.086]                             break
[10:23:18.086]                           }
[10:23:18.086]                         }
[10:23:18.086]                       }
[10:23:18.086]                       invisible(muffled)
[10:23:18.086]                     }
[10:23:18.086]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.086]                   }
[10:23:18.086]                 }
[10:23:18.086]                 else {
[10:23:18.086]                   if (TRUE) {
[10:23:18.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.086]                     {
[10:23:18.086]                       inherits <- base::inherits
[10:23:18.086]                       invokeRestart <- base::invokeRestart
[10:23:18.086]                       is.null <- base::is.null
[10:23:18.086]                       muffled <- FALSE
[10:23:18.086]                       if (inherits(cond, "message")) {
[10:23:18.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.086]                         if (muffled) 
[10:23:18.086]                           invokeRestart("muffleMessage")
[10:23:18.086]                       }
[10:23:18.086]                       else if (inherits(cond, "warning")) {
[10:23:18.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.086]                         if (muffled) 
[10:23:18.086]                           invokeRestart("muffleWarning")
[10:23:18.086]                       }
[10:23:18.086]                       else if (inherits(cond, "condition")) {
[10:23:18.086]                         if (!is.null(pattern)) {
[10:23:18.086]                           computeRestarts <- base::computeRestarts
[10:23:18.086]                           grepl <- base::grepl
[10:23:18.086]                           restarts <- computeRestarts(cond)
[10:23:18.086]                           for (restart in restarts) {
[10:23:18.086]                             name <- restart$name
[10:23:18.086]                             if (is.null(name)) 
[10:23:18.086]                               next
[10:23:18.086]                             if (!grepl(pattern, name)) 
[10:23:18.086]                               next
[10:23:18.086]                             invokeRestart(restart)
[10:23:18.086]                             muffled <- TRUE
[10:23:18.086]                             break
[10:23:18.086]                           }
[10:23:18.086]                         }
[10:23:18.086]                       }
[10:23:18.086]                       invisible(muffled)
[10:23:18.086]                     }
[10:23:18.086]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.086]                   }
[10:23:18.086]                 }
[10:23:18.086]             }
[10:23:18.086]         }))
[10:23:18.086]     }, error = function(ex) {
[10:23:18.086]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:18.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.086]                 ...future.rng), started = ...future.startTime, 
[10:23:18.086]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:18.086]             version = "1.8"), class = "FutureResult")
[10:23:18.086]     }, finally = {
[10:23:18.086]         if (!identical(...future.workdir, getwd())) 
[10:23:18.086]             setwd(...future.workdir)
[10:23:18.086]         {
[10:23:18.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:18.086]                 ...future.oldOptions$nwarnings <- NULL
[10:23:18.086]             }
[10:23:18.086]             base::options(...future.oldOptions)
[10:23:18.086]             if (.Platform$OS.type == "windows") {
[10:23:18.086]                 old_names <- names(...future.oldEnvVars)
[10:23:18.086]                 envs <- base::Sys.getenv()
[10:23:18.086]                 names <- names(envs)
[10:23:18.086]                 common <- intersect(names, old_names)
[10:23:18.086]                 added <- setdiff(names, old_names)
[10:23:18.086]                 removed <- setdiff(old_names, names)
[10:23:18.086]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:18.086]                   envs[common]]
[10:23:18.086]                 NAMES <- toupper(changed)
[10:23:18.086]                 args <- list()
[10:23:18.086]                 for (kk in seq_along(NAMES)) {
[10:23:18.086]                   name <- changed[[kk]]
[10:23:18.086]                   NAME <- NAMES[[kk]]
[10:23:18.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.086]                     next
[10:23:18.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.086]                 }
[10:23:18.086]                 NAMES <- toupper(added)
[10:23:18.086]                 for (kk in seq_along(NAMES)) {
[10:23:18.086]                   name <- added[[kk]]
[10:23:18.086]                   NAME <- NAMES[[kk]]
[10:23:18.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.086]                     next
[10:23:18.086]                   args[[name]] <- ""
[10:23:18.086]                 }
[10:23:18.086]                 NAMES <- toupper(removed)
[10:23:18.086]                 for (kk in seq_along(NAMES)) {
[10:23:18.086]                   name <- removed[[kk]]
[10:23:18.086]                   NAME <- NAMES[[kk]]
[10:23:18.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.086]                     next
[10:23:18.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.086]                 }
[10:23:18.086]                 if (length(args) > 0) 
[10:23:18.086]                   base::do.call(base::Sys.setenv, args = args)
[10:23:18.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:18.086]             }
[10:23:18.086]             else {
[10:23:18.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:18.086]             }
[10:23:18.086]             {
[10:23:18.086]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:18.086]                   0L) {
[10:23:18.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:18.086]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:18.086]                   base::options(opts)
[10:23:18.086]                 }
[10:23:18.086]                 {
[10:23:18.086]                   {
[10:23:18.086]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:18.086]                     NULL
[10:23:18.086]                   }
[10:23:18.086]                   options(future.plan = NULL)
[10:23:18.086]                   if (is.na(NA_character_)) 
[10:23:18.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:18.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:18.086]                     .init = FALSE)
[10:23:18.086]                 }
[10:23:18.086]             }
[10:23:18.086]         }
[10:23:18.086]     })
[10:23:18.086]     if (TRUE) {
[10:23:18.086]         base::sink(type = "output", split = FALSE)
[10:23:18.086]         if (TRUE) {
[10:23:18.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:18.086]         }
[10:23:18.086]         else {
[10:23:18.086]             ...future.result["stdout"] <- base::list(NULL)
[10:23:18.086]         }
[10:23:18.086]         base::close(...future.stdout)
[10:23:18.086]         ...future.stdout <- NULL
[10:23:18.086]     }
[10:23:18.086]     ...future.result$conditions <- ...future.conditions
[10:23:18.086]     ...future.result$finished <- base::Sys.time()
[10:23:18.086]     ...future.result
[10:23:18.086] }
[10:23:18.089] MultisessionFuture started
[10:23:18.090] - Launch lazy future ... done
[10:23:18.090] run() for ‘MultisessionFuture’ ... done
[10:23:18.090] result() for ClusterFuture ...
[10:23:18.090] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.090] - Validating connection of MultisessionFuture
[10:23:18.139] - received message: FutureResult
[10:23:18.140] - Received FutureResult
[10:23:18.140] - Erased future from FutureRegistry
[10:23:18.140] result() for ClusterFuture ...
[10:23:18.140] - result already collected: FutureResult
[10:23:18.140] result() for ClusterFuture ... done
[10:23:18.140] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.140] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : chr " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n[26] 26 27 28 29 30 31 32 33 3"| __truncated__
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-11-19 10:23:18"
 $ finished    : POSIXct[1:1], format: "2025-11-19 10:23:18"
 $ session_uuid: chr "f8c77005-6a78-0e78-343a-dff4abaa6280"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "eec1919a6b51"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 86343
  .. ..$ time  : POSIXct[1:1], format: "2025-11-19 10:23:18"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:23:18.149] result() for ClusterFuture ...
[10:23:18.149] - result already collected: FutureResult
[10:23:18.149] result() for ClusterFuture ... done
[10:23:18.149] result() for ClusterFuture ...
[10:23:18.149] - result already collected: FutureResult
[10:23:18.149] result() for ClusterFuture ... done
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
 int [1:50] 1 2 3 4 5 6 7 8 9 10 ...
a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 
"Sepal.Length"	"Sepal.Width"	"Petal.Length"	"Petal.Width"	"Species"
"1"	5.1	3.5	1.4	0.2	"setosa"
"2"	4.9	3	1.4	0.2	"setosa"
"3"	4.7	3.2	1.3	0.2	"setosa"
"4"	4.6	3.1	1.5	0.2	"setosa"
"5"	5	3.6	1.4	0.2	"setosa"
"6"	5.4	3.9	1.7	0.4	"setosa"
"7"	4.6	3.4	1.4	0.3	"setosa"
"8"	5	3.4	1.5	0.2	"setosa"
"9"	4.4	2.9	1.4	0.2	"setosa"
"10"	4.9	3.1	1.5	0.1	"setosa"
FutureResult:
value: ‘integer’
visible: TRUE
stdout: character
conditions: [n = 0] 
RNG used: FALSE
duration: 0.008666515 secs (started 2025-11-19 10:23:18.131019)
version: 1.8
[10:23:18.150] getGlobalsAndPackages() ...
[10:23:18.150] Searching for globals...
[10:23:18.154] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:18.154] Searching for globals ... DONE
[10:23:18.155] Resolving globals: FALSE
[10:23:18.155] 
[10:23:18.155] - packages: [1] ‘utils’
[10:23:18.155] getGlobalsAndPackages() ... DONE
[10:23:18.156] run() for ‘Future’ ...
[10:23:18.156] - state: ‘created’
[10:23:18.156] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:23:18.171] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:18.171] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:23:18.171]   - Field: ‘node’
[10:23:18.171]   - Field: ‘label’
[10:23:18.171]   - Field: ‘local’
[10:23:18.171]   - Field: ‘owner’
[10:23:18.172]   - Field: ‘envir’
[10:23:18.172]   - Field: ‘workers’
[10:23:18.172]   - Field: ‘packages’
[10:23:18.172]   - Field: ‘gc’
[10:23:18.172]   - Field: ‘conditions’
[10:23:18.172]   - Field: ‘persistent’
[10:23:18.172]   - Field: ‘expr’
[10:23:18.172]   - Field: ‘uuid’
[10:23:18.172]   - Field: ‘seed’
[10:23:18.173]   - Field: ‘version’
[10:23:18.173]   - Field: ‘result’
[10:23:18.173]   - Field: ‘asynchronous’
[10:23:18.173]   - Field: ‘calls’
[10:23:18.173]   - Field: ‘globals’
[10:23:18.173]   - Field: ‘stdout’
[10:23:18.173]   - Field: ‘earlySignal’
[10:23:18.173]   - Field: ‘lazy’
[10:23:18.173]   - Field: ‘state’
[10:23:18.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:23:18.174] - Launch lazy future ...
[10:23:18.174] Packages needed by the future expression (n = 1): ‘utils’
[10:23:18.174] Packages needed by future strategies (n = 0): <none>
[10:23:18.175] {
[10:23:18.175]     {
[10:23:18.175]         {
[10:23:18.175]             ...future.startTime <- base::Sys.time()
[10:23:18.175]             {
[10:23:18.175]                 {
[10:23:18.175]                   {
[10:23:18.175]                     {
[10:23:18.175]                       {
[10:23:18.175]                         base::local({
[10:23:18.175]                           has_future <- base::requireNamespace("future", 
[10:23:18.175]                             quietly = TRUE)
[10:23:18.175]                           if (has_future) {
[10:23:18.175]                             ns <- base::getNamespace("future")
[10:23:18.175]                             version <- ns[[".package"]][["version"]]
[10:23:18.175]                             if (is.null(version)) 
[10:23:18.175]                               version <- utils::packageVersion("future")
[10:23:18.175]                           }
[10:23:18.175]                           else {
[10:23:18.175]                             version <- NULL
[10:23:18.175]                           }
[10:23:18.175]                           if (!has_future || version < "1.8.0") {
[10:23:18.175]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:18.175]                               "", base::R.version$version.string), 
[10:23:18.175]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:18.175]                                 base::R.version$platform, 8 * 
[10:23:18.175]                                   base::.Machine$sizeof.pointer), 
[10:23:18.175]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:18.175]                                 "release", "version")], collapse = " "), 
[10:23:18.175]                               hostname = base::Sys.info()[["nodename"]])
[10:23:18.175]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:18.175]                               info)
[10:23:18.175]                             info <- base::paste(info, collapse = "; ")
[10:23:18.175]                             if (!has_future) {
[10:23:18.175]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:18.175]                                 info)
[10:23:18.175]                             }
[10:23:18.175]                             else {
[10:23:18.175]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:18.175]                                 info, version)
[10:23:18.175]                             }
[10:23:18.175]                             base::stop(msg)
[10:23:18.175]                           }
[10:23:18.175]                         })
[10:23:18.175]                       }
[10:23:18.175]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:18.175]                       base::options(mc.cores = 1L)
[10:23:18.175]                     }
[10:23:18.175]                     base::local({
[10:23:18.175]                       for (pkg in "utils") {
[10:23:18.175]                         base::loadNamespace(pkg)
[10:23:18.175]                         base::library(pkg, character.only = TRUE)
[10:23:18.175]                       }
[10:23:18.175]                     })
[10:23:18.175]                   }
[10:23:18.175]                   ...future.strategy.old <- future::plan("list")
[10:23:18.175]                   options(future.plan = NULL)
[10:23:18.175]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.175]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:18.175]                 }
[10:23:18.175]                 ...future.workdir <- getwd()
[10:23:18.175]             }
[10:23:18.175]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:18.175]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:18.175]         }
[10:23:18.175]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:18.175]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:18.175]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:18.175]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:18.175]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:18.175]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:18.175]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:18.175]             base::names(...future.oldOptions))
[10:23:18.175]     }
[10:23:18.175]     if (FALSE) {
[10:23:18.175]     }
[10:23:18.175]     else {
[10:23:18.175]         if (TRUE) {
[10:23:18.175]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:18.175]                 open = "w")
[10:23:18.175]         }
[10:23:18.175]         else {
[10:23:18.175]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:18.175]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:18.175]         }
[10:23:18.175]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:18.175]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:18.175]             base::sink(type = "output", split = FALSE)
[10:23:18.175]             base::close(...future.stdout)
[10:23:18.175]         }, add = TRUE)
[10:23:18.175]     }
[10:23:18.175]     ...future.frame <- base::sys.nframe()
[10:23:18.175]     ...future.conditions <- base::list()
[10:23:18.175]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:18.175]     if (FALSE) {
[10:23:18.175]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:18.175]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:18.175]     }
[10:23:18.175]     ...future.result <- base::tryCatch({
[10:23:18.175]         base::withCallingHandlers({
[10:23:18.175]             ...future.value <- base::withVisible(base::local({
[10:23:18.175]                 ...future.makeSendCondition <- base::local({
[10:23:18.175]                   sendCondition <- NULL
[10:23:18.175]                   function(frame = 1L) {
[10:23:18.175]                     if (is.function(sendCondition)) 
[10:23:18.175]                       return(sendCondition)
[10:23:18.175]                     ns <- getNamespace("parallel")
[10:23:18.175]                     if (exists("sendData", mode = "function", 
[10:23:18.175]                       envir = ns)) {
[10:23:18.175]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:18.175]                         envir = ns)
[10:23:18.175]                       envir <- sys.frame(frame)
[10:23:18.175]                       master <- NULL
[10:23:18.175]                       while (!identical(envir, .GlobalEnv) && 
[10:23:18.175]                         !identical(envir, emptyenv())) {
[10:23:18.175]                         if (exists("master", mode = "list", envir = envir, 
[10:23:18.175]                           inherits = FALSE)) {
[10:23:18.175]                           master <- get("master", mode = "list", 
[10:23:18.175]                             envir = envir, inherits = FALSE)
[10:23:18.175]                           if (inherits(master, c("SOCKnode", 
[10:23:18.175]                             "SOCK0node"))) {
[10:23:18.175]                             sendCondition <<- function(cond) {
[10:23:18.175]                               data <- list(type = "VALUE", value = cond, 
[10:23:18.175]                                 success = TRUE)
[10:23:18.175]                               parallel_sendData(master, data)
[10:23:18.175]                             }
[10:23:18.175]                             return(sendCondition)
[10:23:18.175]                           }
[10:23:18.175]                         }
[10:23:18.175]                         frame <- frame + 1L
[10:23:18.175]                         envir <- sys.frame(frame)
[10:23:18.175]                       }
[10:23:18.175]                     }
[10:23:18.175]                     sendCondition <<- function(cond) NULL
[10:23:18.175]                   }
[10:23:18.175]                 })
[10:23:18.175]                 withCallingHandlers({
[10:23:18.175]                   {
[10:23:18.175]                     print(1:50)
[10:23:18.175]                     str(1:50)
[10:23:18.175]                     cat(letters, sep = "-")
[10:23:18.175]                     cat(1:6, collapse = "\n")
[10:23:18.175]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:18.175]                     42L
[10:23:18.175]                   }
[10:23:18.175]                 }, immediateCondition = function(cond) {
[10:23:18.175]                   sendCondition <- ...future.makeSendCondition()
[10:23:18.175]                   sendCondition(cond)
[10:23:18.175]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.175]                   {
[10:23:18.175]                     inherits <- base::inherits
[10:23:18.175]                     invokeRestart <- base::invokeRestart
[10:23:18.175]                     is.null <- base::is.null
[10:23:18.175]                     muffled <- FALSE
[10:23:18.175]                     if (inherits(cond, "message")) {
[10:23:18.175]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:18.175]                       if (muffled) 
[10:23:18.175]                         invokeRestart("muffleMessage")
[10:23:18.175]                     }
[10:23:18.175]                     else if (inherits(cond, "warning")) {
[10:23:18.175]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:18.175]                       if (muffled) 
[10:23:18.175]                         invokeRestart("muffleWarning")
[10:23:18.175]                     }
[10:23:18.175]                     else if (inherits(cond, "condition")) {
[10:23:18.175]                       if (!is.null(pattern)) {
[10:23:18.175]                         computeRestarts <- base::computeRestarts
[10:23:18.175]                         grepl <- base::grepl
[10:23:18.175]                         restarts <- computeRestarts(cond)
[10:23:18.175]                         for (restart in restarts) {
[10:23:18.175]                           name <- restart$name
[10:23:18.175]                           if (is.null(name)) 
[10:23:18.175]                             next
[10:23:18.175]                           if (!grepl(pattern, name)) 
[10:23:18.175]                             next
[10:23:18.175]                           invokeRestart(restart)
[10:23:18.175]                           muffled <- TRUE
[10:23:18.175]                           break
[10:23:18.175]                         }
[10:23:18.175]                       }
[10:23:18.175]                     }
[10:23:18.175]                     invisible(muffled)
[10:23:18.175]                   }
[10:23:18.175]                   muffleCondition(cond)
[10:23:18.175]                 })
[10:23:18.175]             }))
[10:23:18.175]             future::FutureResult(value = ...future.value$value, 
[10:23:18.175]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.175]                   ...future.rng), globalenv = if (FALSE) 
[10:23:18.175]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:18.175]                     ...future.globalenv.names))
[10:23:18.175]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:18.175]         }, condition = base::local({
[10:23:18.175]             c <- base::c
[10:23:18.175]             inherits <- base::inherits
[10:23:18.175]             invokeRestart <- base::invokeRestart
[10:23:18.175]             length <- base::length
[10:23:18.175]             list <- base::list
[10:23:18.175]             seq.int <- base::seq.int
[10:23:18.175]             signalCondition <- base::signalCondition
[10:23:18.175]             sys.calls <- base::sys.calls
[10:23:18.175]             `[[` <- base::`[[`
[10:23:18.175]             `+` <- base::`+`
[10:23:18.175]             `<<-` <- base::`<<-`
[10:23:18.175]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:18.175]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:18.175]                   3L)]
[10:23:18.175]             }
[10:23:18.175]             function(cond) {
[10:23:18.175]                 is_error <- inherits(cond, "error")
[10:23:18.175]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:18.175]                   NULL)
[10:23:18.175]                 if (is_error) {
[10:23:18.175]                   sessionInformation <- function() {
[10:23:18.175]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:18.175]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:18.175]                       search = base::search(), system = base::Sys.info())
[10:23:18.175]                   }
[10:23:18.175]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.175]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:18.175]                     cond$call), session = sessionInformation(), 
[10:23:18.175]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:18.175]                   signalCondition(cond)
[10:23:18.175]                 }
[10:23:18.175]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:18.175]                 "immediateCondition"))) {
[10:23:18.175]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:18.175]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.175]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:18.175]                   if (TRUE && !signal) {
[10:23:18.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.175]                     {
[10:23:18.175]                       inherits <- base::inherits
[10:23:18.175]                       invokeRestart <- base::invokeRestart
[10:23:18.175]                       is.null <- base::is.null
[10:23:18.175]                       muffled <- FALSE
[10:23:18.175]                       if (inherits(cond, "message")) {
[10:23:18.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.175]                         if (muffled) 
[10:23:18.175]                           invokeRestart("muffleMessage")
[10:23:18.175]                       }
[10:23:18.175]                       else if (inherits(cond, "warning")) {
[10:23:18.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.175]                         if (muffled) 
[10:23:18.175]                           invokeRestart("muffleWarning")
[10:23:18.175]                       }
[10:23:18.175]                       else if (inherits(cond, "condition")) {
[10:23:18.175]                         if (!is.null(pattern)) {
[10:23:18.175]                           computeRestarts <- base::computeRestarts
[10:23:18.175]                           grepl <- base::grepl
[10:23:18.175]                           restarts <- computeRestarts(cond)
[10:23:18.175]                           for (restart in restarts) {
[10:23:18.175]                             name <- restart$name
[10:23:18.175]                             if (is.null(name)) 
[10:23:18.175]                               next
[10:23:18.175]                             if (!grepl(pattern, name)) 
[10:23:18.175]                               next
[10:23:18.175]                             invokeRestart(restart)
[10:23:18.175]                             muffled <- TRUE
[10:23:18.175]                             break
[10:23:18.175]                           }
[10:23:18.175]                         }
[10:23:18.175]                       }
[10:23:18.175]                       invisible(muffled)
[10:23:18.175]                     }
[10:23:18.175]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.175]                   }
[10:23:18.175]                 }
[10:23:18.175]                 else {
[10:23:18.175]                   if (TRUE) {
[10:23:18.175]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.175]                     {
[10:23:18.175]                       inherits <- base::inherits
[10:23:18.175]                       invokeRestart <- base::invokeRestart
[10:23:18.175]                       is.null <- base::is.null
[10:23:18.175]                       muffled <- FALSE
[10:23:18.175]                       if (inherits(cond, "message")) {
[10:23:18.175]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.175]                         if (muffled) 
[10:23:18.175]                           invokeRestart("muffleMessage")
[10:23:18.175]                       }
[10:23:18.175]                       else if (inherits(cond, "warning")) {
[10:23:18.175]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.175]                         if (muffled) 
[10:23:18.175]                           invokeRestart("muffleWarning")
[10:23:18.175]                       }
[10:23:18.175]                       else if (inherits(cond, "condition")) {
[10:23:18.175]                         if (!is.null(pattern)) {
[10:23:18.175]                           computeRestarts <- base::computeRestarts
[10:23:18.175]                           grepl <- base::grepl
[10:23:18.175]                           restarts <- computeRestarts(cond)
[10:23:18.175]                           for (restart in restarts) {
[10:23:18.175]                             name <- restart$name
[10:23:18.175]                             if (is.null(name)) 
[10:23:18.175]                               next
[10:23:18.175]                             if (!grepl(pattern, name)) 
[10:23:18.175]                               next
[10:23:18.175]                             invokeRestart(restart)
[10:23:18.175]                             muffled <- TRUE
[10:23:18.175]                             break
[10:23:18.175]                           }
[10:23:18.175]                         }
[10:23:18.175]                       }
[10:23:18.175]                       invisible(muffled)
[10:23:18.175]                     }
[10:23:18.175]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.175]                   }
[10:23:18.175]                 }
[10:23:18.175]             }
[10:23:18.175]         }))
[10:23:18.175]     }, error = function(ex) {
[10:23:18.175]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:18.175]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.175]                 ...future.rng), started = ...future.startTime, 
[10:23:18.175]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:18.175]             version = "1.8"), class = "FutureResult")
[10:23:18.175]     }, finally = {
[10:23:18.175]         if (!identical(...future.workdir, getwd())) 
[10:23:18.175]             setwd(...future.workdir)
[10:23:18.175]         {
[10:23:18.175]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:18.175]                 ...future.oldOptions$nwarnings <- NULL
[10:23:18.175]             }
[10:23:18.175]             base::options(...future.oldOptions)
[10:23:18.175]             if (.Platform$OS.type == "windows") {
[10:23:18.175]                 old_names <- names(...future.oldEnvVars)
[10:23:18.175]                 envs <- base::Sys.getenv()
[10:23:18.175]                 names <- names(envs)
[10:23:18.175]                 common <- intersect(names, old_names)
[10:23:18.175]                 added <- setdiff(names, old_names)
[10:23:18.175]                 removed <- setdiff(old_names, names)
[10:23:18.175]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:18.175]                   envs[common]]
[10:23:18.175]                 NAMES <- toupper(changed)
[10:23:18.175]                 args <- list()
[10:23:18.175]                 for (kk in seq_along(NAMES)) {
[10:23:18.175]                   name <- changed[[kk]]
[10:23:18.175]                   NAME <- NAMES[[kk]]
[10:23:18.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.175]                     next
[10:23:18.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.175]                 }
[10:23:18.175]                 NAMES <- toupper(added)
[10:23:18.175]                 for (kk in seq_along(NAMES)) {
[10:23:18.175]                   name <- added[[kk]]
[10:23:18.175]                   NAME <- NAMES[[kk]]
[10:23:18.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.175]                     next
[10:23:18.175]                   args[[name]] <- ""
[10:23:18.175]                 }
[10:23:18.175]                 NAMES <- toupper(removed)
[10:23:18.175]                 for (kk in seq_along(NAMES)) {
[10:23:18.175]                   name <- removed[[kk]]
[10:23:18.175]                   NAME <- NAMES[[kk]]
[10:23:18.175]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.175]                     next
[10:23:18.175]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.175]                 }
[10:23:18.175]                 if (length(args) > 0) 
[10:23:18.175]                   base::do.call(base::Sys.setenv, args = args)
[10:23:18.175]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:18.175]             }
[10:23:18.175]             else {
[10:23:18.175]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:18.175]             }
[10:23:18.175]             {
[10:23:18.175]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:18.175]                   0L) {
[10:23:18.175]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:18.175]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:18.175]                   base::options(opts)
[10:23:18.175]                 }
[10:23:18.175]                 {
[10:23:18.175]                   {
[10:23:18.175]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:18.175]                     NULL
[10:23:18.175]                   }
[10:23:18.175]                   options(future.plan = NULL)
[10:23:18.175]                   if (is.na(NA_character_)) 
[10:23:18.175]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.175]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:18.175]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:18.175]                     .init = FALSE)
[10:23:18.175]                 }
[10:23:18.175]             }
[10:23:18.175]         }
[10:23:18.175]     })
[10:23:18.175]     if (TRUE) {
[10:23:18.175]         base::sink(type = "output", split = FALSE)
[10:23:18.175]         if (TRUE) {
[10:23:18.175]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:18.175]         }
[10:23:18.175]         else {
[10:23:18.175]             ...future.result["stdout"] <- base::list(NULL)
[10:23:18.175]         }
[10:23:18.175]         base::close(...future.stdout)
[10:23:18.175]         ...future.stdout <- NULL
[10:23:18.175]     }
[10:23:18.175]     ...future.result$conditions <- ...future.conditions
[10:23:18.175]     ...future.result$finished <- base::Sys.time()
[10:23:18.175]     ...future.result
[10:23:18.175] }
[10:23:18.178] MultisessionFuture started
[10:23:18.178] - Launch lazy future ... done
[10:23:18.179] run() for ‘MultisessionFuture’ ... done
[10:23:18.179] result() for ClusterFuture ...
[10:23:18.179] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.179] - Validating connection of MultisessionFuture
[10:23:18.221] - received message: FutureResult
[10:23:18.221] - Received FutureResult
[10:23:18.221] - Erased future from FutureRegistry
[10:23:18.222] result() for ClusterFuture ...
[10:23:18.222] - result already collected: FutureResult
[10:23:18.222] result() for ClusterFuture ... done
[10:23:18.222] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.222] result() for ClusterFuture ... done
[10:23:18.222] result() for ClusterFuture ...
[10:23:18.222] - result already collected: FutureResult
[10:23:18.222] result() for ClusterFuture ... done
 [1] " [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25"  
 [2] "[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"  
 [3] " int [1:50] 1 2 3 4 5 6 7 8 9 10 ..."                                             
 [4] "a-b-c-d-e-f-g-h-i-j-k-l-m-n-o-p-q-r-s-t-u-v-w-x-y-z1 2 3 4 5 6 "                  
 [5] "\"Sepal.Length\"\t\"Sepal.Width\"\t\"Petal.Length\"\t\"Petal.Width\"\t\"Species\""
 [6] "\"1\"\t5.1\t3.5\t1.4\t0.2\t\"setosa\""                                            
 [7] "\"2\"\t4.9\t3\t1.4\t0.2\t\"setosa\""                                              
 [8] "\"3\"\t4.7\t3.2\t1.3\t0.2\t\"setosa\""                                            
 [9] "\"4\"\t4.6\t3.1\t1.5\t0.2\t\"setosa\""                                            
[10] "\"5\"\t5\t3.6\t1.4\t0.2\t\"setosa\""                                              
[11] "\"6\"\t5.4\t3.9\t1.7\t0.4\t\"setosa\""                                            
[12] "\"7\"\t4.6\t3.4\t1.4\t0.3\t\"setosa\""                                            
[13] "\"8\"\t5\t3.4\t1.5\t0.2\t\"setosa\""                                              
[14] "\"9\"\t4.4\t2.9\t1.4\t0.2\t\"setosa\""                                            
[15] "\"10\"\t4.9\t3.1\t1.5\t0.1\t\"setosa\""                                           
- stdout = structure(TRUE, drop = TRUE)
[10:23:18.223] getGlobalsAndPackages() ...
[10:23:18.223] Searching for globals...
[10:23:18.224] - globals found: [1] ‘print’
[10:23:18.224] Searching for globals ... DONE
[10:23:18.224] Resolving globals: FALSE
[10:23:18.224] 
[10:23:18.224] 
[10:23:18.225] getGlobalsAndPackages() ... DONE
[10:23:18.225] run() for ‘Future’ ...
[10:23:18.225] - state: ‘created’
[10:23:18.225] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:23:18.240] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:18.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:23:18.240]   - Field: ‘node’
[10:23:18.240]   - Field: ‘label’
[10:23:18.241]   - Field: ‘local’
[10:23:18.241]   - Field: ‘owner’
[10:23:18.241]   - Field: ‘envir’
[10:23:18.241]   - Field: ‘workers’
[10:23:18.241]   - Field: ‘packages’
[10:23:18.241]   - Field: ‘gc’
[10:23:18.241]   - Field: ‘conditions’
[10:23:18.241]   - Field: ‘persistent’
[10:23:18.241]   - Field: ‘expr’
[10:23:18.242]   - Field: ‘uuid’
[10:23:18.242]   - Field: ‘seed’
[10:23:18.242]   - Field: ‘version’
[10:23:18.242]   - Field: ‘result’
[10:23:18.242]   - Field: ‘asynchronous’
[10:23:18.242]   - Field: ‘calls’
[10:23:18.242]   - Field: ‘globals’
[10:23:18.242]   - Field: ‘stdout’
[10:23:18.242]   - Field: ‘earlySignal’
[10:23:18.243]   - Field: ‘lazy’
[10:23:18.243]   - Field: ‘state’
[10:23:18.243] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:23:18.243] - Launch lazy future ...
[10:23:18.243] Packages needed by the future expression (n = 0): <none>
[10:23:18.243] Packages needed by future strategies (n = 0): <none>
[10:23:18.244] {
[10:23:18.244]     {
[10:23:18.244]         {
[10:23:18.244]             ...future.startTime <- base::Sys.time()
[10:23:18.244]             {
[10:23:18.244]                 {
[10:23:18.244]                   {
[10:23:18.244]                     {
[10:23:18.244]                       base::local({
[10:23:18.244]                         has_future <- base::requireNamespace("future", 
[10:23:18.244]                           quietly = TRUE)
[10:23:18.244]                         if (has_future) {
[10:23:18.244]                           ns <- base::getNamespace("future")
[10:23:18.244]                           version <- ns[[".package"]][["version"]]
[10:23:18.244]                           if (is.null(version)) 
[10:23:18.244]                             version <- utils::packageVersion("future")
[10:23:18.244]                         }
[10:23:18.244]                         else {
[10:23:18.244]                           version <- NULL
[10:23:18.244]                         }
[10:23:18.244]                         if (!has_future || version < "1.8.0") {
[10:23:18.244]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:18.244]                             "", base::R.version$version.string), 
[10:23:18.244]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:18.244]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:18.244]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:18.244]                               "release", "version")], collapse = " "), 
[10:23:18.244]                             hostname = base::Sys.info()[["nodename"]])
[10:23:18.244]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:18.244]                             info)
[10:23:18.244]                           info <- base::paste(info, collapse = "; ")
[10:23:18.244]                           if (!has_future) {
[10:23:18.244]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:18.244]                               info)
[10:23:18.244]                           }
[10:23:18.244]                           else {
[10:23:18.244]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:18.244]                               info, version)
[10:23:18.244]                           }
[10:23:18.244]                           base::stop(msg)
[10:23:18.244]                         }
[10:23:18.244]                       })
[10:23:18.244]                     }
[10:23:18.244]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:18.244]                     base::options(mc.cores = 1L)
[10:23:18.244]                   }
[10:23:18.244]                   ...future.strategy.old <- future::plan("list")
[10:23:18.244]                   options(future.plan = NULL)
[10:23:18.244]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.244]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:18.244]                 }
[10:23:18.244]                 ...future.workdir <- getwd()
[10:23:18.244]             }
[10:23:18.244]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:18.244]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:18.244]         }
[10:23:18.244]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:18.244]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:18.244]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:18.244]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:18.244]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:18.244]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:18.244]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:18.244]             base::names(...future.oldOptions))
[10:23:18.244]     }
[10:23:18.244]     if (FALSE) {
[10:23:18.244]     }
[10:23:18.244]     else {
[10:23:18.244]         if (TRUE) {
[10:23:18.244]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:18.244]                 open = "w")
[10:23:18.244]         }
[10:23:18.244]         else {
[10:23:18.244]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:18.244]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:18.244]         }
[10:23:18.244]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:18.244]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:18.244]             base::sink(type = "output", split = FALSE)
[10:23:18.244]             base::close(...future.stdout)
[10:23:18.244]         }, add = TRUE)
[10:23:18.244]     }
[10:23:18.244]     ...future.frame <- base::sys.nframe()
[10:23:18.244]     ...future.conditions <- base::list()
[10:23:18.244]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:18.244]     if (FALSE) {
[10:23:18.244]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:18.244]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:18.244]     }
[10:23:18.244]     ...future.result <- base::tryCatch({
[10:23:18.244]         base::withCallingHandlers({
[10:23:18.244]             ...future.value <- base::withVisible(base::local({
[10:23:18.244]                 ...future.makeSendCondition <- base::local({
[10:23:18.244]                   sendCondition <- NULL
[10:23:18.244]                   function(frame = 1L) {
[10:23:18.244]                     if (is.function(sendCondition)) 
[10:23:18.244]                       return(sendCondition)
[10:23:18.244]                     ns <- getNamespace("parallel")
[10:23:18.244]                     if (exists("sendData", mode = "function", 
[10:23:18.244]                       envir = ns)) {
[10:23:18.244]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:18.244]                         envir = ns)
[10:23:18.244]                       envir <- sys.frame(frame)
[10:23:18.244]                       master <- NULL
[10:23:18.244]                       while (!identical(envir, .GlobalEnv) && 
[10:23:18.244]                         !identical(envir, emptyenv())) {
[10:23:18.244]                         if (exists("master", mode = "list", envir = envir, 
[10:23:18.244]                           inherits = FALSE)) {
[10:23:18.244]                           master <- get("master", mode = "list", 
[10:23:18.244]                             envir = envir, inherits = FALSE)
[10:23:18.244]                           if (inherits(master, c("SOCKnode", 
[10:23:18.244]                             "SOCK0node"))) {
[10:23:18.244]                             sendCondition <<- function(cond) {
[10:23:18.244]                               data <- list(type = "VALUE", value = cond, 
[10:23:18.244]                                 success = TRUE)
[10:23:18.244]                               parallel_sendData(master, data)
[10:23:18.244]                             }
[10:23:18.244]                             return(sendCondition)
[10:23:18.244]                           }
[10:23:18.244]                         }
[10:23:18.244]                         frame <- frame + 1L
[10:23:18.244]                         envir <- sys.frame(frame)
[10:23:18.244]                       }
[10:23:18.244]                     }
[10:23:18.244]                     sendCondition <<- function(cond) NULL
[10:23:18.244]                   }
[10:23:18.244]                 })
[10:23:18.244]                 withCallingHandlers({
[10:23:18.244]                   print(42)
[10:23:18.244]                 }, immediateCondition = function(cond) {
[10:23:18.244]                   sendCondition <- ...future.makeSendCondition()
[10:23:18.244]                   sendCondition(cond)
[10:23:18.244]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.244]                   {
[10:23:18.244]                     inherits <- base::inherits
[10:23:18.244]                     invokeRestart <- base::invokeRestart
[10:23:18.244]                     is.null <- base::is.null
[10:23:18.244]                     muffled <- FALSE
[10:23:18.244]                     if (inherits(cond, "message")) {
[10:23:18.244]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:18.244]                       if (muffled) 
[10:23:18.244]                         invokeRestart("muffleMessage")
[10:23:18.244]                     }
[10:23:18.244]                     else if (inherits(cond, "warning")) {
[10:23:18.244]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:18.244]                       if (muffled) 
[10:23:18.244]                         invokeRestart("muffleWarning")
[10:23:18.244]                     }
[10:23:18.244]                     else if (inherits(cond, "condition")) {
[10:23:18.244]                       if (!is.null(pattern)) {
[10:23:18.244]                         computeRestarts <- base::computeRestarts
[10:23:18.244]                         grepl <- base::grepl
[10:23:18.244]                         restarts <- computeRestarts(cond)
[10:23:18.244]                         for (restart in restarts) {
[10:23:18.244]                           name <- restart$name
[10:23:18.244]                           if (is.null(name)) 
[10:23:18.244]                             next
[10:23:18.244]                           if (!grepl(pattern, name)) 
[10:23:18.244]                             next
[10:23:18.244]                           invokeRestart(restart)
[10:23:18.244]                           muffled <- TRUE
[10:23:18.244]                           break
[10:23:18.244]                         }
[10:23:18.244]                       }
[10:23:18.244]                     }
[10:23:18.244]                     invisible(muffled)
[10:23:18.244]                   }
[10:23:18.244]                   muffleCondition(cond)
[10:23:18.244]                 })
[10:23:18.244]             }))
[10:23:18.244]             future::FutureResult(value = ...future.value$value, 
[10:23:18.244]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.244]                   ...future.rng), globalenv = if (FALSE) 
[10:23:18.244]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:18.244]                     ...future.globalenv.names))
[10:23:18.244]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:18.244]         }, condition = base::local({
[10:23:18.244]             c <- base::c
[10:23:18.244]             inherits <- base::inherits
[10:23:18.244]             invokeRestart <- base::invokeRestart
[10:23:18.244]             length <- base::length
[10:23:18.244]             list <- base::list
[10:23:18.244]             seq.int <- base::seq.int
[10:23:18.244]             signalCondition <- base::signalCondition
[10:23:18.244]             sys.calls <- base::sys.calls
[10:23:18.244]             `[[` <- base::`[[`
[10:23:18.244]             `+` <- base::`+`
[10:23:18.244]             `<<-` <- base::`<<-`
[10:23:18.244]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:18.244]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:18.244]                   3L)]
[10:23:18.244]             }
[10:23:18.244]             function(cond) {
[10:23:18.244]                 is_error <- inherits(cond, "error")
[10:23:18.244]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:18.244]                   NULL)
[10:23:18.244]                 if (is_error) {
[10:23:18.244]                   sessionInformation <- function() {
[10:23:18.244]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:18.244]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:18.244]                       search = base::search(), system = base::Sys.info())
[10:23:18.244]                   }
[10:23:18.244]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.244]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:18.244]                     cond$call), session = sessionInformation(), 
[10:23:18.244]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:18.244]                   signalCondition(cond)
[10:23:18.244]                 }
[10:23:18.244]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:18.244]                 "immediateCondition"))) {
[10:23:18.244]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:18.244]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.244]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:18.244]                   if (TRUE && !signal) {
[10:23:18.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.244]                     {
[10:23:18.244]                       inherits <- base::inherits
[10:23:18.244]                       invokeRestart <- base::invokeRestart
[10:23:18.244]                       is.null <- base::is.null
[10:23:18.244]                       muffled <- FALSE
[10:23:18.244]                       if (inherits(cond, "message")) {
[10:23:18.244]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.244]                         if (muffled) 
[10:23:18.244]                           invokeRestart("muffleMessage")
[10:23:18.244]                       }
[10:23:18.244]                       else if (inherits(cond, "warning")) {
[10:23:18.244]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.244]                         if (muffled) 
[10:23:18.244]                           invokeRestart("muffleWarning")
[10:23:18.244]                       }
[10:23:18.244]                       else if (inherits(cond, "condition")) {
[10:23:18.244]                         if (!is.null(pattern)) {
[10:23:18.244]                           computeRestarts <- base::computeRestarts
[10:23:18.244]                           grepl <- base::grepl
[10:23:18.244]                           restarts <- computeRestarts(cond)
[10:23:18.244]                           for (restart in restarts) {
[10:23:18.244]                             name <- restart$name
[10:23:18.244]                             if (is.null(name)) 
[10:23:18.244]                               next
[10:23:18.244]                             if (!grepl(pattern, name)) 
[10:23:18.244]                               next
[10:23:18.244]                             invokeRestart(restart)
[10:23:18.244]                             muffled <- TRUE
[10:23:18.244]                             break
[10:23:18.244]                           }
[10:23:18.244]                         }
[10:23:18.244]                       }
[10:23:18.244]                       invisible(muffled)
[10:23:18.244]                     }
[10:23:18.244]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.244]                   }
[10:23:18.244]                 }
[10:23:18.244]                 else {
[10:23:18.244]                   if (TRUE) {
[10:23:18.244]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.244]                     {
[10:23:18.244]                       inherits <- base::inherits
[10:23:18.244]                       invokeRestart <- base::invokeRestart
[10:23:18.244]                       is.null <- base::is.null
[10:23:18.244]                       muffled <- FALSE
[10:23:18.244]                       if (inherits(cond, "message")) {
[10:23:18.244]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.244]                         if (muffled) 
[10:23:18.244]                           invokeRestart("muffleMessage")
[10:23:18.244]                       }
[10:23:18.244]                       else if (inherits(cond, "warning")) {
[10:23:18.244]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.244]                         if (muffled) 
[10:23:18.244]                           invokeRestart("muffleWarning")
[10:23:18.244]                       }
[10:23:18.244]                       else if (inherits(cond, "condition")) {
[10:23:18.244]                         if (!is.null(pattern)) {
[10:23:18.244]                           computeRestarts <- base::computeRestarts
[10:23:18.244]                           grepl <- base::grepl
[10:23:18.244]                           restarts <- computeRestarts(cond)
[10:23:18.244]                           for (restart in restarts) {
[10:23:18.244]                             name <- restart$name
[10:23:18.244]                             if (is.null(name)) 
[10:23:18.244]                               next
[10:23:18.244]                             if (!grepl(pattern, name)) 
[10:23:18.244]                               next
[10:23:18.244]                             invokeRestart(restart)
[10:23:18.244]                             muffled <- TRUE
[10:23:18.244]                             break
[10:23:18.244]                           }
[10:23:18.244]                         }
[10:23:18.244]                       }
[10:23:18.244]                       invisible(muffled)
[10:23:18.244]                     }
[10:23:18.244]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.244]                   }
[10:23:18.244]                 }
[10:23:18.244]             }
[10:23:18.244]         }))
[10:23:18.244]     }, error = function(ex) {
[10:23:18.244]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:18.244]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.244]                 ...future.rng), started = ...future.startTime, 
[10:23:18.244]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:18.244]             version = "1.8"), class = "FutureResult")
[10:23:18.244]     }, finally = {
[10:23:18.244]         if (!identical(...future.workdir, getwd())) 
[10:23:18.244]             setwd(...future.workdir)
[10:23:18.244]         {
[10:23:18.244]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:18.244]                 ...future.oldOptions$nwarnings <- NULL
[10:23:18.244]             }
[10:23:18.244]             base::options(...future.oldOptions)
[10:23:18.244]             if (.Platform$OS.type == "windows") {
[10:23:18.244]                 old_names <- names(...future.oldEnvVars)
[10:23:18.244]                 envs <- base::Sys.getenv()
[10:23:18.244]                 names <- names(envs)
[10:23:18.244]                 common <- intersect(names, old_names)
[10:23:18.244]                 added <- setdiff(names, old_names)
[10:23:18.244]                 removed <- setdiff(old_names, names)
[10:23:18.244]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:18.244]                   envs[common]]
[10:23:18.244]                 NAMES <- toupper(changed)
[10:23:18.244]                 args <- list()
[10:23:18.244]                 for (kk in seq_along(NAMES)) {
[10:23:18.244]                   name <- changed[[kk]]
[10:23:18.244]                   NAME <- NAMES[[kk]]
[10:23:18.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.244]                     next
[10:23:18.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.244]                 }
[10:23:18.244]                 NAMES <- toupper(added)
[10:23:18.244]                 for (kk in seq_along(NAMES)) {
[10:23:18.244]                   name <- added[[kk]]
[10:23:18.244]                   NAME <- NAMES[[kk]]
[10:23:18.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.244]                     next
[10:23:18.244]                   args[[name]] <- ""
[10:23:18.244]                 }
[10:23:18.244]                 NAMES <- toupper(removed)
[10:23:18.244]                 for (kk in seq_along(NAMES)) {
[10:23:18.244]                   name <- removed[[kk]]
[10:23:18.244]                   NAME <- NAMES[[kk]]
[10:23:18.244]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.244]                     next
[10:23:18.244]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.244]                 }
[10:23:18.244]                 if (length(args) > 0) 
[10:23:18.244]                   base::do.call(base::Sys.setenv, args = args)
[10:23:18.244]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:18.244]             }
[10:23:18.244]             else {
[10:23:18.244]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:18.244]             }
[10:23:18.244]             {
[10:23:18.244]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:18.244]                   0L) {
[10:23:18.244]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:18.244]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:18.244]                   base::options(opts)
[10:23:18.244]                 }
[10:23:18.244]                 {
[10:23:18.244]                   {
[10:23:18.244]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:18.244]                     NULL
[10:23:18.244]                   }
[10:23:18.244]                   options(future.plan = NULL)
[10:23:18.244]                   if (is.na(NA_character_)) 
[10:23:18.244]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.244]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:18.244]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:18.244]                     .init = FALSE)
[10:23:18.244]                 }
[10:23:18.244]             }
[10:23:18.244]         }
[10:23:18.244]     })
[10:23:18.244]     if (TRUE) {
[10:23:18.244]         base::sink(type = "output", split = FALSE)
[10:23:18.244]         if (TRUE) {
[10:23:18.244]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:18.244]         }
[10:23:18.244]         else {
[10:23:18.244]             ...future.result["stdout"] <- base::list(NULL)
[10:23:18.244]         }
[10:23:18.244]         base::close(...future.stdout)
[10:23:18.244]         ...future.stdout <- NULL
[10:23:18.244]     }
[10:23:18.244]     ...future.result$conditions <- ...future.conditions
[10:23:18.244]     ...future.result$finished <- base::Sys.time()
[10:23:18.244]     ...future.result
[10:23:18.244] }
[10:23:18.247] MultisessionFuture started
[10:23:18.248] - Launch lazy future ... done
[10:23:18.248] run() for ‘MultisessionFuture’ ... done
[10:23:18.248] result() for ClusterFuture ...
[10:23:18.248] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.248] - Validating connection of MultisessionFuture
[10:23:18.290] - received message: FutureResult
[10:23:18.290] - Received FutureResult
[10:23:18.290] - Erased future from FutureRegistry
[10:23:18.291] result() for ClusterFuture ...
[10:23:18.291] - result already collected: FutureResult
[10:23:18.291] result() for ClusterFuture ... done
[10:23:18.291] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.291] result() for ClusterFuture ... done
[10:23:18.291] result() for ClusterFuture ...
[10:23:18.291] - result already collected: FutureResult
[10:23:18.291] result() for ClusterFuture ... done
[10:23:18.292] result() for ClusterFuture ...
[10:23:18.292] - result already collected: FutureResult
[10:23:18.292] result() for ClusterFuture ... done
[1] 42
[10:23:18.292] result() for ClusterFuture ...
[10:23:18.292] - result already collected: FutureResult
[10:23:18.292] result() for ClusterFuture ... done
- stdout = FALSE
[10:23:18.292] getGlobalsAndPackages() ...
[10:23:18.292] Searching for globals...
[10:23:18.296] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:18.297] Searching for globals ... DONE
[10:23:18.297] Resolving globals: FALSE
[10:23:18.297] 
[10:23:18.297] - packages: [1] ‘utils’
[10:23:18.298] getGlobalsAndPackages() ... DONE
[10:23:18.298] run() for ‘Future’ ...
[10:23:18.298] - state: ‘created’
[10:23:18.298] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:23:18.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:18.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:23:18.313]   - Field: ‘node’
[10:23:18.313]   - Field: ‘label’
[10:23:18.313]   - Field: ‘local’
[10:23:18.314]   - Field: ‘owner’
[10:23:18.314]   - Field: ‘envir’
[10:23:18.314]   - Field: ‘workers’
[10:23:18.314]   - Field: ‘packages’
[10:23:18.314]   - Field: ‘gc’
[10:23:18.314]   - Field: ‘conditions’
[10:23:18.314]   - Field: ‘persistent’
[10:23:18.314]   - Field: ‘expr’
[10:23:18.314]   - Field: ‘uuid’
[10:23:18.314]   - Field: ‘seed’
[10:23:18.315]   - Field: ‘version’
[10:23:18.315]   - Field: ‘result’
[10:23:18.315]   - Field: ‘asynchronous’
[10:23:18.315]   - Field: ‘calls’
[10:23:18.315]   - Field: ‘globals’
[10:23:18.315]   - Field: ‘stdout’
[10:23:18.315]   - Field: ‘earlySignal’
[10:23:18.315]   - Field: ‘lazy’
[10:23:18.315]   - Field: ‘state’
[10:23:18.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:23:18.316] - Launch lazy future ...
[10:23:18.316] Packages needed by the future expression (n = 1): ‘utils’
[10:23:18.316] Packages needed by future strategies (n = 0): <none>
[10:23:18.317] {
[10:23:18.317]     {
[10:23:18.317]         {
[10:23:18.317]             ...future.startTime <- base::Sys.time()
[10:23:18.317]             {
[10:23:18.317]                 {
[10:23:18.317]                   {
[10:23:18.317]                     {
[10:23:18.317]                       {
[10:23:18.317]                         base::local({
[10:23:18.317]                           has_future <- base::requireNamespace("future", 
[10:23:18.317]                             quietly = TRUE)
[10:23:18.317]                           if (has_future) {
[10:23:18.317]                             ns <- base::getNamespace("future")
[10:23:18.317]                             version <- ns[[".package"]][["version"]]
[10:23:18.317]                             if (is.null(version)) 
[10:23:18.317]                               version <- utils::packageVersion("future")
[10:23:18.317]                           }
[10:23:18.317]                           else {
[10:23:18.317]                             version <- NULL
[10:23:18.317]                           }
[10:23:18.317]                           if (!has_future || version < "1.8.0") {
[10:23:18.317]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:18.317]                               "", base::R.version$version.string), 
[10:23:18.317]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:18.317]                                 base::R.version$platform, 8 * 
[10:23:18.317]                                   base::.Machine$sizeof.pointer), 
[10:23:18.317]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:18.317]                                 "release", "version")], collapse = " "), 
[10:23:18.317]                               hostname = base::Sys.info()[["nodename"]])
[10:23:18.317]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:18.317]                               info)
[10:23:18.317]                             info <- base::paste(info, collapse = "; ")
[10:23:18.317]                             if (!has_future) {
[10:23:18.317]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:18.317]                                 info)
[10:23:18.317]                             }
[10:23:18.317]                             else {
[10:23:18.317]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:18.317]                                 info, version)
[10:23:18.317]                             }
[10:23:18.317]                             base::stop(msg)
[10:23:18.317]                           }
[10:23:18.317]                         })
[10:23:18.317]                       }
[10:23:18.317]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:18.317]                       base::options(mc.cores = 1L)
[10:23:18.317]                     }
[10:23:18.317]                     base::local({
[10:23:18.317]                       for (pkg in "utils") {
[10:23:18.317]                         base::loadNamespace(pkg)
[10:23:18.317]                         base::library(pkg, character.only = TRUE)
[10:23:18.317]                       }
[10:23:18.317]                     })
[10:23:18.317]                   }
[10:23:18.317]                   ...future.strategy.old <- future::plan("list")
[10:23:18.317]                   options(future.plan = NULL)
[10:23:18.317]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.317]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:18.317]                 }
[10:23:18.317]                 ...future.workdir <- getwd()
[10:23:18.317]             }
[10:23:18.317]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:18.317]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:18.317]         }
[10:23:18.317]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:18.317]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:18.317]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:18.317]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:18.317]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:18.317]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:18.317]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:18.317]             base::names(...future.oldOptions))
[10:23:18.317]     }
[10:23:18.317]     if (FALSE) {
[10:23:18.317]     }
[10:23:18.317]     else {
[10:23:18.317]         if (FALSE) {
[10:23:18.317]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:18.317]                 open = "w")
[10:23:18.317]         }
[10:23:18.317]         else {
[10:23:18.317]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:18.317]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:18.317]         }
[10:23:18.317]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:18.317]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:18.317]             base::sink(type = "output", split = FALSE)
[10:23:18.317]             base::close(...future.stdout)
[10:23:18.317]         }, add = TRUE)
[10:23:18.317]     }
[10:23:18.317]     ...future.frame <- base::sys.nframe()
[10:23:18.317]     ...future.conditions <- base::list()
[10:23:18.317]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:18.317]     if (FALSE) {
[10:23:18.317]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:18.317]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:18.317]     }
[10:23:18.317]     ...future.result <- base::tryCatch({
[10:23:18.317]         base::withCallingHandlers({
[10:23:18.317]             ...future.value <- base::withVisible(base::local({
[10:23:18.317]                 ...future.makeSendCondition <- base::local({
[10:23:18.317]                   sendCondition <- NULL
[10:23:18.317]                   function(frame = 1L) {
[10:23:18.317]                     if (is.function(sendCondition)) 
[10:23:18.317]                       return(sendCondition)
[10:23:18.317]                     ns <- getNamespace("parallel")
[10:23:18.317]                     if (exists("sendData", mode = "function", 
[10:23:18.317]                       envir = ns)) {
[10:23:18.317]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:18.317]                         envir = ns)
[10:23:18.317]                       envir <- sys.frame(frame)
[10:23:18.317]                       master <- NULL
[10:23:18.317]                       while (!identical(envir, .GlobalEnv) && 
[10:23:18.317]                         !identical(envir, emptyenv())) {
[10:23:18.317]                         if (exists("master", mode = "list", envir = envir, 
[10:23:18.317]                           inherits = FALSE)) {
[10:23:18.317]                           master <- get("master", mode = "list", 
[10:23:18.317]                             envir = envir, inherits = FALSE)
[10:23:18.317]                           if (inherits(master, c("SOCKnode", 
[10:23:18.317]                             "SOCK0node"))) {
[10:23:18.317]                             sendCondition <<- function(cond) {
[10:23:18.317]                               data <- list(type = "VALUE", value = cond, 
[10:23:18.317]                                 success = TRUE)
[10:23:18.317]                               parallel_sendData(master, data)
[10:23:18.317]                             }
[10:23:18.317]                             return(sendCondition)
[10:23:18.317]                           }
[10:23:18.317]                         }
[10:23:18.317]                         frame <- frame + 1L
[10:23:18.317]                         envir <- sys.frame(frame)
[10:23:18.317]                       }
[10:23:18.317]                     }
[10:23:18.317]                     sendCondition <<- function(cond) NULL
[10:23:18.317]                   }
[10:23:18.317]                 })
[10:23:18.317]                 withCallingHandlers({
[10:23:18.317]                   {
[10:23:18.317]                     print(1:50)
[10:23:18.317]                     str(1:50)
[10:23:18.317]                     cat(letters, sep = "-")
[10:23:18.317]                     cat(1:6, collapse = "\n")
[10:23:18.317]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:18.317]                     42L
[10:23:18.317]                   }
[10:23:18.317]                 }, immediateCondition = function(cond) {
[10:23:18.317]                   sendCondition <- ...future.makeSendCondition()
[10:23:18.317]                   sendCondition(cond)
[10:23:18.317]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.317]                   {
[10:23:18.317]                     inherits <- base::inherits
[10:23:18.317]                     invokeRestart <- base::invokeRestart
[10:23:18.317]                     is.null <- base::is.null
[10:23:18.317]                     muffled <- FALSE
[10:23:18.317]                     if (inherits(cond, "message")) {
[10:23:18.317]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:18.317]                       if (muffled) 
[10:23:18.317]                         invokeRestart("muffleMessage")
[10:23:18.317]                     }
[10:23:18.317]                     else if (inherits(cond, "warning")) {
[10:23:18.317]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:18.317]                       if (muffled) 
[10:23:18.317]                         invokeRestart("muffleWarning")
[10:23:18.317]                     }
[10:23:18.317]                     else if (inherits(cond, "condition")) {
[10:23:18.317]                       if (!is.null(pattern)) {
[10:23:18.317]                         computeRestarts <- base::computeRestarts
[10:23:18.317]                         grepl <- base::grepl
[10:23:18.317]                         restarts <- computeRestarts(cond)
[10:23:18.317]                         for (restart in restarts) {
[10:23:18.317]                           name <- restart$name
[10:23:18.317]                           if (is.null(name)) 
[10:23:18.317]                             next
[10:23:18.317]                           if (!grepl(pattern, name)) 
[10:23:18.317]                             next
[10:23:18.317]                           invokeRestart(restart)
[10:23:18.317]                           muffled <- TRUE
[10:23:18.317]                           break
[10:23:18.317]                         }
[10:23:18.317]                       }
[10:23:18.317]                     }
[10:23:18.317]                     invisible(muffled)
[10:23:18.317]                   }
[10:23:18.317]                   muffleCondition(cond)
[10:23:18.317]                 })
[10:23:18.317]             }))
[10:23:18.317]             future::FutureResult(value = ...future.value$value, 
[10:23:18.317]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.317]                   ...future.rng), globalenv = if (FALSE) 
[10:23:18.317]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:18.317]                     ...future.globalenv.names))
[10:23:18.317]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:18.317]         }, condition = base::local({
[10:23:18.317]             c <- base::c
[10:23:18.317]             inherits <- base::inherits
[10:23:18.317]             invokeRestart <- base::invokeRestart
[10:23:18.317]             length <- base::length
[10:23:18.317]             list <- base::list
[10:23:18.317]             seq.int <- base::seq.int
[10:23:18.317]             signalCondition <- base::signalCondition
[10:23:18.317]             sys.calls <- base::sys.calls
[10:23:18.317]             `[[` <- base::`[[`
[10:23:18.317]             `+` <- base::`+`
[10:23:18.317]             `<<-` <- base::`<<-`
[10:23:18.317]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:18.317]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:18.317]                   3L)]
[10:23:18.317]             }
[10:23:18.317]             function(cond) {
[10:23:18.317]                 is_error <- inherits(cond, "error")
[10:23:18.317]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:18.317]                   NULL)
[10:23:18.317]                 if (is_error) {
[10:23:18.317]                   sessionInformation <- function() {
[10:23:18.317]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:18.317]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:18.317]                       search = base::search(), system = base::Sys.info())
[10:23:18.317]                   }
[10:23:18.317]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.317]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:18.317]                     cond$call), session = sessionInformation(), 
[10:23:18.317]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:18.317]                   signalCondition(cond)
[10:23:18.317]                 }
[10:23:18.317]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:18.317]                 "immediateCondition"))) {
[10:23:18.317]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:18.317]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.317]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:18.317]                   if (TRUE && !signal) {
[10:23:18.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.317]                     {
[10:23:18.317]                       inherits <- base::inherits
[10:23:18.317]                       invokeRestart <- base::invokeRestart
[10:23:18.317]                       is.null <- base::is.null
[10:23:18.317]                       muffled <- FALSE
[10:23:18.317]                       if (inherits(cond, "message")) {
[10:23:18.317]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.317]                         if (muffled) 
[10:23:18.317]                           invokeRestart("muffleMessage")
[10:23:18.317]                       }
[10:23:18.317]                       else if (inherits(cond, "warning")) {
[10:23:18.317]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.317]                         if (muffled) 
[10:23:18.317]                           invokeRestart("muffleWarning")
[10:23:18.317]                       }
[10:23:18.317]                       else if (inherits(cond, "condition")) {
[10:23:18.317]                         if (!is.null(pattern)) {
[10:23:18.317]                           computeRestarts <- base::computeRestarts
[10:23:18.317]                           grepl <- base::grepl
[10:23:18.317]                           restarts <- computeRestarts(cond)
[10:23:18.317]                           for (restart in restarts) {
[10:23:18.317]                             name <- restart$name
[10:23:18.317]                             if (is.null(name)) 
[10:23:18.317]                               next
[10:23:18.317]                             if (!grepl(pattern, name)) 
[10:23:18.317]                               next
[10:23:18.317]                             invokeRestart(restart)
[10:23:18.317]                             muffled <- TRUE
[10:23:18.317]                             break
[10:23:18.317]                           }
[10:23:18.317]                         }
[10:23:18.317]                       }
[10:23:18.317]                       invisible(muffled)
[10:23:18.317]                     }
[10:23:18.317]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.317]                   }
[10:23:18.317]                 }
[10:23:18.317]                 else {
[10:23:18.317]                   if (TRUE) {
[10:23:18.317]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.317]                     {
[10:23:18.317]                       inherits <- base::inherits
[10:23:18.317]                       invokeRestart <- base::invokeRestart
[10:23:18.317]                       is.null <- base::is.null
[10:23:18.317]                       muffled <- FALSE
[10:23:18.317]                       if (inherits(cond, "message")) {
[10:23:18.317]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.317]                         if (muffled) 
[10:23:18.317]                           invokeRestart("muffleMessage")
[10:23:18.317]                       }
[10:23:18.317]                       else if (inherits(cond, "warning")) {
[10:23:18.317]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.317]                         if (muffled) 
[10:23:18.317]                           invokeRestart("muffleWarning")
[10:23:18.317]                       }
[10:23:18.317]                       else if (inherits(cond, "condition")) {
[10:23:18.317]                         if (!is.null(pattern)) {
[10:23:18.317]                           computeRestarts <- base::computeRestarts
[10:23:18.317]                           grepl <- base::grepl
[10:23:18.317]                           restarts <- computeRestarts(cond)
[10:23:18.317]                           for (restart in restarts) {
[10:23:18.317]                             name <- restart$name
[10:23:18.317]                             if (is.null(name)) 
[10:23:18.317]                               next
[10:23:18.317]                             if (!grepl(pattern, name)) 
[10:23:18.317]                               next
[10:23:18.317]                             invokeRestart(restart)
[10:23:18.317]                             muffled <- TRUE
[10:23:18.317]                             break
[10:23:18.317]                           }
[10:23:18.317]                         }
[10:23:18.317]                       }
[10:23:18.317]                       invisible(muffled)
[10:23:18.317]                     }
[10:23:18.317]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.317]                   }
[10:23:18.317]                 }
[10:23:18.317]             }
[10:23:18.317]         }))
[10:23:18.317]     }, error = function(ex) {
[10:23:18.317]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:18.317]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.317]                 ...future.rng), started = ...future.startTime, 
[10:23:18.317]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:18.317]             version = "1.8"), class = "FutureResult")
[10:23:18.317]     }, finally = {
[10:23:18.317]         if (!identical(...future.workdir, getwd())) 
[10:23:18.317]             setwd(...future.workdir)
[10:23:18.317]         {
[10:23:18.317]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:18.317]                 ...future.oldOptions$nwarnings <- NULL
[10:23:18.317]             }
[10:23:18.317]             base::options(...future.oldOptions)
[10:23:18.317]             if (.Platform$OS.type == "windows") {
[10:23:18.317]                 old_names <- names(...future.oldEnvVars)
[10:23:18.317]                 envs <- base::Sys.getenv()
[10:23:18.317]                 names <- names(envs)
[10:23:18.317]                 common <- intersect(names, old_names)
[10:23:18.317]                 added <- setdiff(names, old_names)
[10:23:18.317]                 removed <- setdiff(old_names, names)
[10:23:18.317]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:18.317]                   envs[common]]
[10:23:18.317]                 NAMES <- toupper(changed)
[10:23:18.317]                 args <- list()
[10:23:18.317]                 for (kk in seq_along(NAMES)) {
[10:23:18.317]                   name <- changed[[kk]]
[10:23:18.317]                   NAME <- NAMES[[kk]]
[10:23:18.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.317]                     next
[10:23:18.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.317]                 }
[10:23:18.317]                 NAMES <- toupper(added)
[10:23:18.317]                 for (kk in seq_along(NAMES)) {
[10:23:18.317]                   name <- added[[kk]]
[10:23:18.317]                   NAME <- NAMES[[kk]]
[10:23:18.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.317]                     next
[10:23:18.317]                   args[[name]] <- ""
[10:23:18.317]                 }
[10:23:18.317]                 NAMES <- toupper(removed)
[10:23:18.317]                 for (kk in seq_along(NAMES)) {
[10:23:18.317]                   name <- removed[[kk]]
[10:23:18.317]                   NAME <- NAMES[[kk]]
[10:23:18.317]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.317]                     next
[10:23:18.317]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.317]                 }
[10:23:18.317]                 if (length(args) > 0) 
[10:23:18.317]                   base::do.call(base::Sys.setenv, args = args)
[10:23:18.317]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:18.317]             }
[10:23:18.317]             else {
[10:23:18.317]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:18.317]             }
[10:23:18.317]             {
[10:23:18.317]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:18.317]                   0L) {
[10:23:18.317]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:18.317]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:18.317]                   base::options(opts)
[10:23:18.317]                 }
[10:23:18.317]                 {
[10:23:18.317]                   {
[10:23:18.317]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:18.317]                     NULL
[10:23:18.317]                   }
[10:23:18.317]                   options(future.plan = NULL)
[10:23:18.317]                   if (is.na(NA_character_)) 
[10:23:18.317]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.317]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:18.317]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:18.317]                     .init = FALSE)
[10:23:18.317]                 }
[10:23:18.317]             }
[10:23:18.317]         }
[10:23:18.317]     })
[10:23:18.317]     if (TRUE) {
[10:23:18.317]         base::sink(type = "output", split = FALSE)
[10:23:18.317]         if (FALSE) {
[10:23:18.317]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:18.317]         }
[10:23:18.317]         else {
[10:23:18.317]             ...future.result["stdout"] <- base::list(NULL)
[10:23:18.317]         }
[10:23:18.317]         base::close(...future.stdout)
[10:23:18.317]         ...future.stdout <- NULL
[10:23:18.317]     }
[10:23:18.317]     ...future.result$conditions <- ...future.conditions
[10:23:18.317]     ...future.result$finished <- base::Sys.time()
[10:23:18.317]     ...future.result
[10:23:18.317] }
[10:23:18.320] MultisessionFuture started
[10:23:18.321] - Launch lazy future ... done
[10:23:18.321] run() for ‘MultisessionFuture’ ... done
[10:23:18.321] result() for ClusterFuture ...
[10:23:18.321] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.321] - Validating connection of MultisessionFuture
[10:23:18.364] - received message: FutureResult
[10:23:18.364] - Received FutureResult
[10:23:18.364] - Erased future from FutureRegistry
[10:23:18.365] result() for ClusterFuture ...
[10:23:18.365] - result already collected: FutureResult
[10:23:18.365] result() for ClusterFuture ... done
[10:23:18.367] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.368] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-11-19 10:23:18"
 $ finished    : POSIXct[1:1], format: "2025-11-19 10:23:18"
 $ session_uuid: chr "f8c77005-6a78-0e78-343a-dff4abaa6280"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "eec1919a6b51"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 86343
  .. ..$ time  : POSIXct[1:1], format: "2025-11-19 10:23:18"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:23:18.375] result() for ClusterFuture ...
[10:23:18.375] - result already collected: FutureResult
[10:23:18.375] result() for ClusterFuture ... done
[10:23:18.375] result() for ClusterFuture ...
[10:23:18.375] - result already collected: FutureResult
[10:23:18.375] result() for ClusterFuture ... done
[10:23:18.376] getGlobalsAndPackages() ...
[10:23:18.376] Searching for globals...
[10:23:18.379] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:18.379] Searching for globals ... DONE
[10:23:18.379] Resolving globals: FALSE
[10:23:18.379] 
[10:23:18.379] - packages: [1] ‘utils’
[10:23:18.379] getGlobalsAndPackages() ... DONE
[10:23:18.380] run() for ‘Future’ ...
[10:23:18.380] - state: ‘created’
[10:23:18.380] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:23:18.394] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:18.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:23:18.394]   - Field: ‘node’
[10:23:18.394]   - Field: ‘label’
[10:23:18.394]   - Field: ‘local’
[10:23:18.394]   - Field: ‘owner’
[10:23:18.394]   - Field: ‘envir’
[10:23:18.395]   - Field: ‘workers’
[10:23:18.395]   - Field: ‘packages’
[10:23:18.395]   - Field: ‘gc’
[10:23:18.395]   - Field: ‘conditions’
[10:23:18.395]   - Field: ‘persistent’
[10:23:18.395]   - Field: ‘expr’
[10:23:18.395]   - Field: ‘uuid’
[10:23:18.395]   - Field: ‘seed’
[10:23:18.395]   - Field: ‘version’
[10:23:18.395]   - Field: ‘result’
[10:23:18.395]   - Field: ‘asynchronous’
[10:23:18.396]   - Field: ‘calls’
[10:23:18.396]   - Field: ‘globals’
[10:23:18.396]   - Field: ‘stdout’
[10:23:18.396]   - Field: ‘earlySignal’
[10:23:18.396]   - Field: ‘lazy’
[10:23:18.396]   - Field: ‘state’
[10:23:18.396] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:23:18.396] - Launch lazy future ...
[10:23:18.396] Packages needed by the future expression (n = 1): ‘utils’
[10:23:18.397] Packages needed by future strategies (n = 0): <none>
[10:23:18.397] {
[10:23:18.397]     {
[10:23:18.397]         {
[10:23:18.397]             ...future.startTime <- base::Sys.time()
[10:23:18.397]             {
[10:23:18.397]                 {
[10:23:18.397]                   {
[10:23:18.397]                     {
[10:23:18.397]                       {
[10:23:18.397]                         base::local({
[10:23:18.397]                           has_future <- base::requireNamespace("future", 
[10:23:18.397]                             quietly = TRUE)
[10:23:18.397]                           if (has_future) {
[10:23:18.397]                             ns <- base::getNamespace("future")
[10:23:18.397]                             version <- ns[[".package"]][["version"]]
[10:23:18.397]                             if (is.null(version)) 
[10:23:18.397]                               version <- utils::packageVersion("future")
[10:23:18.397]                           }
[10:23:18.397]                           else {
[10:23:18.397]                             version <- NULL
[10:23:18.397]                           }
[10:23:18.397]                           if (!has_future || version < "1.8.0") {
[10:23:18.397]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:18.397]                               "", base::R.version$version.string), 
[10:23:18.397]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:18.397]                                 base::R.version$platform, 8 * 
[10:23:18.397]                                   base::.Machine$sizeof.pointer), 
[10:23:18.397]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:18.397]                                 "release", "version")], collapse = " "), 
[10:23:18.397]                               hostname = base::Sys.info()[["nodename"]])
[10:23:18.397]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:18.397]                               info)
[10:23:18.397]                             info <- base::paste(info, collapse = "; ")
[10:23:18.397]                             if (!has_future) {
[10:23:18.397]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:18.397]                                 info)
[10:23:18.397]                             }
[10:23:18.397]                             else {
[10:23:18.397]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:18.397]                                 info, version)
[10:23:18.397]                             }
[10:23:18.397]                             base::stop(msg)
[10:23:18.397]                           }
[10:23:18.397]                         })
[10:23:18.397]                       }
[10:23:18.397]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:18.397]                       base::options(mc.cores = 1L)
[10:23:18.397]                     }
[10:23:18.397]                     base::local({
[10:23:18.397]                       for (pkg in "utils") {
[10:23:18.397]                         base::loadNamespace(pkg)
[10:23:18.397]                         base::library(pkg, character.only = TRUE)
[10:23:18.397]                       }
[10:23:18.397]                     })
[10:23:18.397]                   }
[10:23:18.397]                   ...future.strategy.old <- future::plan("list")
[10:23:18.397]                   options(future.plan = NULL)
[10:23:18.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:18.397]                 }
[10:23:18.397]                 ...future.workdir <- getwd()
[10:23:18.397]             }
[10:23:18.397]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:18.397]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:18.397]         }
[10:23:18.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:18.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:18.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:18.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:18.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:18.397]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:18.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:18.397]             base::names(...future.oldOptions))
[10:23:18.397]     }
[10:23:18.397]     if (FALSE) {
[10:23:18.397]     }
[10:23:18.397]     else {
[10:23:18.397]         if (FALSE) {
[10:23:18.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:18.397]                 open = "w")
[10:23:18.397]         }
[10:23:18.397]         else {
[10:23:18.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:18.397]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:18.397]         }
[10:23:18.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:18.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:18.397]             base::sink(type = "output", split = FALSE)
[10:23:18.397]             base::close(...future.stdout)
[10:23:18.397]         }, add = TRUE)
[10:23:18.397]     }
[10:23:18.397]     ...future.frame <- base::sys.nframe()
[10:23:18.397]     ...future.conditions <- base::list()
[10:23:18.397]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:18.397]     if (FALSE) {
[10:23:18.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:18.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:18.397]     }
[10:23:18.397]     ...future.result <- base::tryCatch({
[10:23:18.397]         base::withCallingHandlers({
[10:23:18.397]             ...future.value <- base::withVisible(base::local({
[10:23:18.397]                 ...future.makeSendCondition <- base::local({
[10:23:18.397]                   sendCondition <- NULL
[10:23:18.397]                   function(frame = 1L) {
[10:23:18.397]                     if (is.function(sendCondition)) 
[10:23:18.397]                       return(sendCondition)
[10:23:18.397]                     ns <- getNamespace("parallel")
[10:23:18.397]                     if (exists("sendData", mode = "function", 
[10:23:18.397]                       envir = ns)) {
[10:23:18.397]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:18.397]                         envir = ns)
[10:23:18.397]                       envir <- sys.frame(frame)
[10:23:18.397]                       master <- NULL
[10:23:18.397]                       while (!identical(envir, .GlobalEnv) && 
[10:23:18.397]                         !identical(envir, emptyenv())) {
[10:23:18.397]                         if (exists("master", mode = "list", envir = envir, 
[10:23:18.397]                           inherits = FALSE)) {
[10:23:18.397]                           master <- get("master", mode = "list", 
[10:23:18.397]                             envir = envir, inherits = FALSE)
[10:23:18.397]                           if (inherits(master, c("SOCKnode", 
[10:23:18.397]                             "SOCK0node"))) {
[10:23:18.397]                             sendCondition <<- function(cond) {
[10:23:18.397]                               data <- list(type = "VALUE", value = cond, 
[10:23:18.397]                                 success = TRUE)
[10:23:18.397]                               parallel_sendData(master, data)
[10:23:18.397]                             }
[10:23:18.397]                             return(sendCondition)
[10:23:18.397]                           }
[10:23:18.397]                         }
[10:23:18.397]                         frame <- frame + 1L
[10:23:18.397]                         envir <- sys.frame(frame)
[10:23:18.397]                       }
[10:23:18.397]                     }
[10:23:18.397]                     sendCondition <<- function(cond) NULL
[10:23:18.397]                   }
[10:23:18.397]                 })
[10:23:18.397]                 withCallingHandlers({
[10:23:18.397]                   {
[10:23:18.397]                     print(1:50)
[10:23:18.397]                     str(1:50)
[10:23:18.397]                     cat(letters, sep = "-")
[10:23:18.397]                     cat(1:6, collapse = "\n")
[10:23:18.397]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:18.397]                     42L
[10:23:18.397]                   }
[10:23:18.397]                 }, immediateCondition = function(cond) {
[10:23:18.397]                   sendCondition <- ...future.makeSendCondition()
[10:23:18.397]                   sendCondition(cond)
[10:23:18.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.397]                   {
[10:23:18.397]                     inherits <- base::inherits
[10:23:18.397]                     invokeRestart <- base::invokeRestart
[10:23:18.397]                     is.null <- base::is.null
[10:23:18.397]                     muffled <- FALSE
[10:23:18.397]                     if (inherits(cond, "message")) {
[10:23:18.397]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:18.397]                       if (muffled) 
[10:23:18.397]                         invokeRestart("muffleMessage")
[10:23:18.397]                     }
[10:23:18.397]                     else if (inherits(cond, "warning")) {
[10:23:18.397]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:18.397]                       if (muffled) 
[10:23:18.397]                         invokeRestart("muffleWarning")
[10:23:18.397]                     }
[10:23:18.397]                     else if (inherits(cond, "condition")) {
[10:23:18.397]                       if (!is.null(pattern)) {
[10:23:18.397]                         computeRestarts <- base::computeRestarts
[10:23:18.397]                         grepl <- base::grepl
[10:23:18.397]                         restarts <- computeRestarts(cond)
[10:23:18.397]                         for (restart in restarts) {
[10:23:18.397]                           name <- restart$name
[10:23:18.397]                           if (is.null(name)) 
[10:23:18.397]                             next
[10:23:18.397]                           if (!grepl(pattern, name)) 
[10:23:18.397]                             next
[10:23:18.397]                           invokeRestart(restart)
[10:23:18.397]                           muffled <- TRUE
[10:23:18.397]                           break
[10:23:18.397]                         }
[10:23:18.397]                       }
[10:23:18.397]                     }
[10:23:18.397]                     invisible(muffled)
[10:23:18.397]                   }
[10:23:18.397]                   muffleCondition(cond)
[10:23:18.397]                 })
[10:23:18.397]             }))
[10:23:18.397]             future::FutureResult(value = ...future.value$value, 
[10:23:18.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.397]                   ...future.rng), globalenv = if (FALSE) 
[10:23:18.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:18.397]                     ...future.globalenv.names))
[10:23:18.397]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:18.397]         }, condition = base::local({
[10:23:18.397]             c <- base::c
[10:23:18.397]             inherits <- base::inherits
[10:23:18.397]             invokeRestart <- base::invokeRestart
[10:23:18.397]             length <- base::length
[10:23:18.397]             list <- base::list
[10:23:18.397]             seq.int <- base::seq.int
[10:23:18.397]             signalCondition <- base::signalCondition
[10:23:18.397]             sys.calls <- base::sys.calls
[10:23:18.397]             `[[` <- base::`[[`
[10:23:18.397]             `+` <- base::`+`
[10:23:18.397]             `<<-` <- base::`<<-`
[10:23:18.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:18.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:18.397]                   3L)]
[10:23:18.397]             }
[10:23:18.397]             function(cond) {
[10:23:18.397]                 is_error <- inherits(cond, "error")
[10:23:18.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:18.397]                   NULL)
[10:23:18.397]                 if (is_error) {
[10:23:18.397]                   sessionInformation <- function() {
[10:23:18.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:18.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:18.397]                       search = base::search(), system = base::Sys.info())
[10:23:18.397]                   }
[10:23:18.397]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:18.397]                     cond$call), session = sessionInformation(), 
[10:23:18.397]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:18.397]                   signalCondition(cond)
[10:23:18.397]                 }
[10:23:18.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:18.397]                 "immediateCondition"))) {
[10:23:18.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:18.397]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:18.397]                   if (TRUE && !signal) {
[10:23:18.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.397]                     {
[10:23:18.397]                       inherits <- base::inherits
[10:23:18.397]                       invokeRestart <- base::invokeRestart
[10:23:18.397]                       is.null <- base::is.null
[10:23:18.397]                       muffled <- FALSE
[10:23:18.397]                       if (inherits(cond, "message")) {
[10:23:18.397]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.397]                         if (muffled) 
[10:23:18.397]                           invokeRestart("muffleMessage")
[10:23:18.397]                       }
[10:23:18.397]                       else if (inherits(cond, "warning")) {
[10:23:18.397]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.397]                         if (muffled) 
[10:23:18.397]                           invokeRestart("muffleWarning")
[10:23:18.397]                       }
[10:23:18.397]                       else if (inherits(cond, "condition")) {
[10:23:18.397]                         if (!is.null(pattern)) {
[10:23:18.397]                           computeRestarts <- base::computeRestarts
[10:23:18.397]                           grepl <- base::grepl
[10:23:18.397]                           restarts <- computeRestarts(cond)
[10:23:18.397]                           for (restart in restarts) {
[10:23:18.397]                             name <- restart$name
[10:23:18.397]                             if (is.null(name)) 
[10:23:18.397]                               next
[10:23:18.397]                             if (!grepl(pattern, name)) 
[10:23:18.397]                               next
[10:23:18.397]                             invokeRestart(restart)
[10:23:18.397]                             muffled <- TRUE
[10:23:18.397]                             break
[10:23:18.397]                           }
[10:23:18.397]                         }
[10:23:18.397]                       }
[10:23:18.397]                       invisible(muffled)
[10:23:18.397]                     }
[10:23:18.397]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.397]                   }
[10:23:18.397]                 }
[10:23:18.397]                 else {
[10:23:18.397]                   if (TRUE) {
[10:23:18.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.397]                     {
[10:23:18.397]                       inherits <- base::inherits
[10:23:18.397]                       invokeRestart <- base::invokeRestart
[10:23:18.397]                       is.null <- base::is.null
[10:23:18.397]                       muffled <- FALSE
[10:23:18.397]                       if (inherits(cond, "message")) {
[10:23:18.397]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.397]                         if (muffled) 
[10:23:18.397]                           invokeRestart("muffleMessage")
[10:23:18.397]                       }
[10:23:18.397]                       else if (inherits(cond, "warning")) {
[10:23:18.397]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.397]                         if (muffled) 
[10:23:18.397]                           invokeRestart("muffleWarning")
[10:23:18.397]                       }
[10:23:18.397]                       else if (inherits(cond, "condition")) {
[10:23:18.397]                         if (!is.null(pattern)) {
[10:23:18.397]                           computeRestarts <- base::computeRestarts
[10:23:18.397]                           grepl <- base::grepl
[10:23:18.397]                           restarts <- computeRestarts(cond)
[10:23:18.397]                           for (restart in restarts) {
[10:23:18.397]                             name <- restart$name
[10:23:18.397]                             if (is.null(name)) 
[10:23:18.397]                               next
[10:23:18.397]                             if (!grepl(pattern, name)) 
[10:23:18.397]                               next
[10:23:18.397]                             invokeRestart(restart)
[10:23:18.397]                             muffled <- TRUE
[10:23:18.397]                             break
[10:23:18.397]                           }
[10:23:18.397]                         }
[10:23:18.397]                       }
[10:23:18.397]                       invisible(muffled)
[10:23:18.397]                     }
[10:23:18.397]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.397]                   }
[10:23:18.397]                 }
[10:23:18.397]             }
[10:23:18.397]         }))
[10:23:18.397]     }, error = function(ex) {
[10:23:18.397]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:18.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.397]                 ...future.rng), started = ...future.startTime, 
[10:23:18.397]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:18.397]             version = "1.8"), class = "FutureResult")
[10:23:18.397]     }, finally = {
[10:23:18.397]         if (!identical(...future.workdir, getwd())) 
[10:23:18.397]             setwd(...future.workdir)
[10:23:18.397]         {
[10:23:18.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:18.397]                 ...future.oldOptions$nwarnings <- NULL
[10:23:18.397]             }
[10:23:18.397]             base::options(...future.oldOptions)
[10:23:18.397]             if (.Platform$OS.type == "windows") {
[10:23:18.397]                 old_names <- names(...future.oldEnvVars)
[10:23:18.397]                 envs <- base::Sys.getenv()
[10:23:18.397]                 names <- names(envs)
[10:23:18.397]                 common <- intersect(names, old_names)
[10:23:18.397]                 added <- setdiff(names, old_names)
[10:23:18.397]                 removed <- setdiff(old_names, names)
[10:23:18.397]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:18.397]                   envs[common]]
[10:23:18.397]                 NAMES <- toupper(changed)
[10:23:18.397]                 args <- list()
[10:23:18.397]                 for (kk in seq_along(NAMES)) {
[10:23:18.397]                   name <- changed[[kk]]
[10:23:18.397]                   NAME <- NAMES[[kk]]
[10:23:18.397]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.397]                     next
[10:23:18.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.397]                 }
[10:23:18.397]                 NAMES <- toupper(added)
[10:23:18.397]                 for (kk in seq_along(NAMES)) {
[10:23:18.397]                   name <- added[[kk]]
[10:23:18.397]                   NAME <- NAMES[[kk]]
[10:23:18.397]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.397]                     next
[10:23:18.397]                   args[[name]] <- ""
[10:23:18.397]                 }
[10:23:18.397]                 NAMES <- toupper(removed)
[10:23:18.397]                 for (kk in seq_along(NAMES)) {
[10:23:18.397]                   name <- removed[[kk]]
[10:23:18.397]                   NAME <- NAMES[[kk]]
[10:23:18.397]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.397]                     next
[10:23:18.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.397]                 }
[10:23:18.397]                 if (length(args) > 0) 
[10:23:18.397]                   base::do.call(base::Sys.setenv, args = args)
[10:23:18.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:18.397]             }
[10:23:18.397]             else {
[10:23:18.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:18.397]             }
[10:23:18.397]             {
[10:23:18.397]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:18.397]                   0L) {
[10:23:18.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:18.397]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:18.397]                   base::options(opts)
[10:23:18.397]                 }
[10:23:18.397]                 {
[10:23:18.397]                   {
[10:23:18.397]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:18.397]                     NULL
[10:23:18.397]                   }
[10:23:18.397]                   options(future.plan = NULL)
[10:23:18.397]                   if (is.na(NA_character_)) 
[10:23:18.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:18.397]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:18.397]                     .init = FALSE)
[10:23:18.397]                 }
[10:23:18.397]             }
[10:23:18.397]         }
[10:23:18.397]     })
[10:23:18.397]     if (TRUE) {
[10:23:18.397]         base::sink(type = "output", split = FALSE)
[10:23:18.397]         if (FALSE) {
[10:23:18.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:18.397]         }
[10:23:18.397]         else {
[10:23:18.397]             ...future.result["stdout"] <- base::list(NULL)
[10:23:18.397]         }
[10:23:18.397]         base::close(...future.stdout)
[10:23:18.397]         ...future.stdout <- NULL
[10:23:18.397]     }
[10:23:18.397]     ...future.result$conditions <- ...future.conditions
[10:23:18.397]     ...future.result$finished <- base::Sys.time()
[10:23:18.397]     ...future.result
[10:23:18.397] }
[10:23:18.400] MultisessionFuture started
[10:23:18.401] - Launch lazy future ... done
[10:23:18.401] run() for ‘MultisessionFuture’ ... done
[10:23:18.401] result() for ClusterFuture ...
[10:23:18.401] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.401] - Validating connection of MultisessionFuture
[10:23:18.444] - received message: FutureResult
[10:23:18.445] - Received FutureResult
[10:23:18.445] - Erased future from FutureRegistry
[10:23:18.445] result() for ClusterFuture ...
[10:23:18.445] - result already collected: FutureResult
[10:23:18.445] result() for ClusterFuture ... done
[10:23:18.445] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.445] result() for ClusterFuture ... done
[10:23:18.445] result() for ClusterFuture ...
[10:23:18.446] - result already collected: FutureResult
[10:23:18.446] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[10:23:18.446] getGlobalsAndPackages() ...
[10:23:18.446] Searching for globals...
[10:23:18.447] - globals found: [1] ‘print’
[10:23:18.447] Searching for globals ... DONE
[10:23:18.447] Resolving globals: FALSE
[10:23:18.447] 
[10:23:18.447] 
[10:23:18.447] getGlobalsAndPackages() ... DONE
[10:23:18.448] run() for ‘Future’ ...
[10:23:18.448] - state: ‘created’
[10:23:18.448] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:23:18.463] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:18.463] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:23:18.463]   - Field: ‘node’
[10:23:18.463]   - Field: ‘label’
[10:23:18.463]   - Field: ‘local’
[10:23:18.463]   - Field: ‘owner’
[10:23:18.463]   - Field: ‘envir’
[10:23:18.463]   - Field: ‘workers’
[10:23:18.464]   - Field: ‘packages’
[10:23:18.464]   - Field: ‘gc’
[10:23:18.464]   - Field: ‘conditions’
[10:23:18.464]   - Field: ‘persistent’
[10:23:18.464]   - Field: ‘expr’
[10:23:18.464]   - Field: ‘uuid’
[10:23:18.464]   - Field: ‘seed’
[10:23:18.464]   - Field: ‘version’
[10:23:18.464]   - Field: ‘result’
[10:23:18.464]   - Field: ‘asynchronous’
[10:23:18.464]   - Field: ‘calls’
[10:23:18.465]   - Field: ‘globals’
[10:23:18.465]   - Field: ‘stdout’
[10:23:18.465]   - Field: ‘earlySignal’
[10:23:18.465]   - Field: ‘lazy’
[10:23:18.465]   - Field: ‘state’
[10:23:18.465] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:23:18.465] - Launch lazy future ...
[10:23:18.465] Packages needed by the future expression (n = 0): <none>
[10:23:18.466] Packages needed by future strategies (n = 0): <none>
[10:23:18.466] {
[10:23:18.466]     {
[10:23:18.466]         {
[10:23:18.466]             ...future.startTime <- base::Sys.time()
[10:23:18.466]             {
[10:23:18.466]                 {
[10:23:18.466]                   {
[10:23:18.466]                     {
[10:23:18.466]                       base::local({
[10:23:18.466]                         has_future <- base::requireNamespace("future", 
[10:23:18.466]                           quietly = TRUE)
[10:23:18.466]                         if (has_future) {
[10:23:18.466]                           ns <- base::getNamespace("future")
[10:23:18.466]                           version <- ns[[".package"]][["version"]]
[10:23:18.466]                           if (is.null(version)) 
[10:23:18.466]                             version <- utils::packageVersion("future")
[10:23:18.466]                         }
[10:23:18.466]                         else {
[10:23:18.466]                           version <- NULL
[10:23:18.466]                         }
[10:23:18.466]                         if (!has_future || version < "1.8.0") {
[10:23:18.466]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:18.466]                             "", base::R.version$version.string), 
[10:23:18.466]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:18.466]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:18.466]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:18.466]                               "release", "version")], collapse = " "), 
[10:23:18.466]                             hostname = base::Sys.info()[["nodename"]])
[10:23:18.466]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:18.466]                             info)
[10:23:18.466]                           info <- base::paste(info, collapse = "; ")
[10:23:18.466]                           if (!has_future) {
[10:23:18.466]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:18.466]                               info)
[10:23:18.466]                           }
[10:23:18.466]                           else {
[10:23:18.466]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:18.466]                               info, version)
[10:23:18.466]                           }
[10:23:18.466]                           base::stop(msg)
[10:23:18.466]                         }
[10:23:18.466]                       })
[10:23:18.466]                     }
[10:23:18.466]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:18.466]                     base::options(mc.cores = 1L)
[10:23:18.466]                   }
[10:23:18.466]                   ...future.strategy.old <- future::plan("list")
[10:23:18.466]                   options(future.plan = NULL)
[10:23:18.466]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.466]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:18.466]                 }
[10:23:18.466]                 ...future.workdir <- getwd()
[10:23:18.466]             }
[10:23:18.466]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:18.466]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:18.466]         }
[10:23:18.466]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:18.466]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:18.466]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:18.466]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:18.466]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:18.466]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:18.466]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:18.466]             base::names(...future.oldOptions))
[10:23:18.466]     }
[10:23:18.466]     if (FALSE) {
[10:23:18.466]     }
[10:23:18.466]     else {
[10:23:18.466]         if (TRUE) {
[10:23:18.466]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:18.466]                 open = "w")
[10:23:18.466]         }
[10:23:18.466]         else {
[10:23:18.466]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:18.466]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:18.466]         }
[10:23:18.466]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:18.466]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:18.466]             base::sink(type = "output", split = FALSE)
[10:23:18.466]             base::close(...future.stdout)
[10:23:18.466]         }, add = TRUE)
[10:23:18.466]     }
[10:23:18.466]     ...future.frame <- base::sys.nframe()
[10:23:18.466]     ...future.conditions <- base::list()
[10:23:18.466]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:18.466]     if (FALSE) {
[10:23:18.466]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:18.466]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:18.466]     }
[10:23:18.466]     ...future.result <- base::tryCatch({
[10:23:18.466]         base::withCallingHandlers({
[10:23:18.466]             ...future.value <- base::withVisible(base::local({
[10:23:18.466]                 ...future.makeSendCondition <- base::local({
[10:23:18.466]                   sendCondition <- NULL
[10:23:18.466]                   function(frame = 1L) {
[10:23:18.466]                     if (is.function(sendCondition)) 
[10:23:18.466]                       return(sendCondition)
[10:23:18.466]                     ns <- getNamespace("parallel")
[10:23:18.466]                     if (exists("sendData", mode = "function", 
[10:23:18.466]                       envir = ns)) {
[10:23:18.466]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:18.466]                         envir = ns)
[10:23:18.466]                       envir <- sys.frame(frame)
[10:23:18.466]                       master <- NULL
[10:23:18.466]                       while (!identical(envir, .GlobalEnv) && 
[10:23:18.466]                         !identical(envir, emptyenv())) {
[10:23:18.466]                         if (exists("master", mode = "list", envir = envir, 
[10:23:18.466]                           inherits = FALSE)) {
[10:23:18.466]                           master <- get("master", mode = "list", 
[10:23:18.466]                             envir = envir, inherits = FALSE)
[10:23:18.466]                           if (inherits(master, c("SOCKnode", 
[10:23:18.466]                             "SOCK0node"))) {
[10:23:18.466]                             sendCondition <<- function(cond) {
[10:23:18.466]                               data <- list(type = "VALUE", value = cond, 
[10:23:18.466]                                 success = TRUE)
[10:23:18.466]                               parallel_sendData(master, data)
[10:23:18.466]                             }
[10:23:18.466]                             return(sendCondition)
[10:23:18.466]                           }
[10:23:18.466]                         }
[10:23:18.466]                         frame <- frame + 1L
[10:23:18.466]                         envir <- sys.frame(frame)
[10:23:18.466]                       }
[10:23:18.466]                     }
[10:23:18.466]                     sendCondition <<- function(cond) NULL
[10:23:18.466]                   }
[10:23:18.466]                 })
[10:23:18.466]                 withCallingHandlers({
[10:23:18.466]                   print(42)
[10:23:18.466]                 }, immediateCondition = function(cond) {
[10:23:18.466]                   sendCondition <- ...future.makeSendCondition()
[10:23:18.466]                   sendCondition(cond)
[10:23:18.466]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.466]                   {
[10:23:18.466]                     inherits <- base::inherits
[10:23:18.466]                     invokeRestart <- base::invokeRestart
[10:23:18.466]                     is.null <- base::is.null
[10:23:18.466]                     muffled <- FALSE
[10:23:18.466]                     if (inherits(cond, "message")) {
[10:23:18.466]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:18.466]                       if (muffled) 
[10:23:18.466]                         invokeRestart("muffleMessage")
[10:23:18.466]                     }
[10:23:18.466]                     else if (inherits(cond, "warning")) {
[10:23:18.466]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:18.466]                       if (muffled) 
[10:23:18.466]                         invokeRestart("muffleWarning")
[10:23:18.466]                     }
[10:23:18.466]                     else if (inherits(cond, "condition")) {
[10:23:18.466]                       if (!is.null(pattern)) {
[10:23:18.466]                         computeRestarts <- base::computeRestarts
[10:23:18.466]                         grepl <- base::grepl
[10:23:18.466]                         restarts <- computeRestarts(cond)
[10:23:18.466]                         for (restart in restarts) {
[10:23:18.466]                           name <- restart$name
[10:23:18.466]                           if (is.null(name)) 
[10:23:18.466]                             next
[10:23:18.466]                           if (!grepl(pattern, name)) 
[10:23:18.466]                             next
[10:23:18.466]                           invokeRestart(restart)
[10:23:18.466]                           muffled <- TRUE
[10:23:18.466]                           break
[10:23:18.466]                         }
[10:23:18.466]                       }
[10:23:18.466]                     }
[10:23:18.466]                     invisible(muffled)
[10:23:18.466]                   }
[10:23:18.466]                   muffleCondition(cond)
[10:23:18.466]                 })
[10:23:18.466]             }))
[10:23:18.466]             future::FutureResult(value = ...future.value$value, 
[10:23:18.466]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.466]                   ...future.rng), globalenv = if (FALSE) 
[10:23:18.466]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:18.466]                     ...future.globalenv.names))
[10:23:18.466]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:18.466]         }, condition = base::local({
[10:23:18.466]             c <- base::c
[10:23:18.466]             inherits <- base::inherits
[10:23:18.466]             invokeRestart <- base::invokeRestart
[10:23:18.466]             length <- base::length
[10:23:18.466]             list <- base::list
[10:23:18.466]             seq.int <- base::seq.int
[10:23:18.466]             signalCondition <- base::signalCondition
[10:23:18.466]             sys.calls <- base::sys.calls
[10:23:18.466]             `[[` <- base::`[[`
[10:23:18.466]             `+` <- base::`+`
[10:23:18.466]             `<<-` <- base::`<<-`
[10:23:18.466]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:18.466]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:18.466]                   3L)]
[10:23:18.466]             }
[10:23:18.466]             function(cond) {
[10:23:18.466]                 is_error <- inherits(cond, "error")
[10:23:18.466]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:18.466]                   NULL)
[10:23:18.466]                 if (is_error) {
[10:23:18.466]                   sessionInformation <- function() {
[10:23:18.466]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:18.466]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:18.466]                       search = base::search(), system = base::Sys.info())
[10:23:18.466]                   }
[10:23:18.466]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.466]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:18.466]                     cond$call), session = sessionInformation(), 
[10:23:18.466]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:18.466]                   signalCondition(cond)
[10:23:18.466]                 }
[10:23:18.466]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:18.466]                 "immediateCondition"))) {
[10:23:18.466]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:18.466]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.466]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:18.466]                   if (TRUE && !signal) {
[10:23:18.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.466]                     {
[10:23:18.466]                       inherits <- base::inherits
[10:23:18.466]                       invokeRestart <- base::invokeRestart
[10:23:18.466]                       is.null <- base::is.null
[10:23:18.466]                       muffled <- FALSE
[10:23:18.466]                       if (inherits(cond, "message")) {
[10:23:18.466]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.466]                         if (muffled) 
[10:23:18.466]                           invokeRestart("muffleMessage")
[10:23:18.466]                       }
[10:23:18.466]                       else if (inherits(cond, "warning")) {
[10:23:18.466]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.466]                         if (muffled) 
[10:23:18.466]                           invokeRestart("muffleWarning")
[10:23:18.466]                       }
[10:23:18.466]                       else if (inherits(cond, "condition")) {
[10:23:18.466]                         if (!is.null(pattern)) {
[10:23:18.466]                           computeRestarts <- base::computeRestarts
[10:23:18.466]                           grepl <- base::grepl
[10:23:18.466]                           restarts <- computeRestarts(cond)
[10:23:18.466]                           for (restart in restarts) {
[10:23:18.466]                             name <- restart$name
[10:23:18.466]                             if (is.null(name)) 
[10:23:18.466]                               next
[10:23:18.466]                             if (!grepl(pattern, name)) 
[10:23:18.466]                               next
[10:23:18.466]                             invokeRestart(restart)
[10:23:18.466]                             muffled <- TRUE
[10:23:18.466]                             break
[10:23:18.466]                           }
[10:23:18.466]                         }
[10:23:18.466]                       }
[10:23:18.466]                       invisible(muffled)
[10:23:18.466]                     }
[10:23:18.466]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.466]                   }
[10:23:18.466]                 }
[10:23:18.466]                 else {
[10:23:18.466]                   if (TRUE) {
[10:23:18.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.466]                     {
[10:23:18.466]                       inherits <- base::inherits
[10:23:18.466]                       invokeRestart <- base::invokeRestart
[10:23:18.466]                       is.null <- base::is.null
[10:23:18.466]                       muffled <- FALSE
[10:23:18.466]                       if (inherits(cond, "message")) {
[10:23:18.466]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.466]                         if (muffled) 
[10:23:18.466]                           invokeRestart("muffleMessage")
[10:23:18.466]                       }
[10:23:18.466]                       else if (inherits(cond, "warning")) {
[10:23:18.466]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.466]                         if (muffled) 
[10:23:18.466]                           invokeRestart("muffleWarning")
[10:23:18.466]                       }
[10:23:18.466]                       else if (inherits(cond, "condition")) {
[10:23:18.466]                         if (!is.null(pattern)) {
[10:23:18.466]                           computeRestarts <- base::computeRestarts
[10:23:18.466]                           grepl <- base::grepl
[10:23:18.466]                           restarts <- computeRestarts(cond)
[10:23:18.466]                           for (restart in restarts) {
[10:23:18.466]                             name <- restart$name
[10:23:18.466]                             if (is.null(name)) 
[10:23:18.466]                               next
[10:23:18.466]                             if (!grepl(pattern, name)) 
[10:23:18.466]                               next
[10:23:18.466]                             invokeRestart(restart)
[10:23:18.466]                             muffled <- TRUE
[10:23:18.466]                             break
[10:23:18.466]                           }
[10:23:18.466]                         }
[10:23:18.466]                       }
[10:23:18.466]                       invisible(muffled)
[10:23:18.466]                     }
[10:23:18.466]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.466]                   }
[10:23:18.466]                 }
[10:23:18.466]             }
[10:23:18.466]         }))
[10:23:18.466]     }, error = function(ex) {
[10:23:18.466]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:18.466]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.466]                 ...future.rng), started = ...future.startTime, 
[10:23:18.466]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:18.466]             version = "1.8"), class = "FutureResult")
[10:23:18.466]     }, finally = {
[10:23:18.466]         if (!identical(...future.workdir, getwd())) 
[10:23:18.466]             setwd(...future.workdir)
[10:23:18.466]         {
[10:23:18.466]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:18.466]                 ...future.oldOptions$nwarnings <- NULL
[10:23:18.466]             }
[10:23:18.466]             base::options(...future.oldOptions)
[10:23:18.466]             if (.Platform$OS.type == "windows") {
[10:23:18.466]                 old_names <- names(...future.oldEnvVars)
[10:23:18.466]                 envs <- base::Sys.getenv()
[10:23:18.466]                 names <- names(envs)
[10:23:18.466]                 common <- intersect(names, old_names)
[10:23:18.466]                 added <- setdiff(names, old_names)
[10:23:18.466]                 removed <- setdiff(old_names, names)
[10:23:18.466]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:18.466]                   envs[common]]
[10:23:18.466]                 NAMES <- toupper(changed)
[10:23:18.466]                 args <- list()
[10:23:18.466]                 for (kk in seq_along(NAMES)) {
[10:23:18.466]                   name <- changed[[kk]]
[10:23:18.466]                   NAME <- NAMES[[kk]]
[10:23:18.466]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.466]                     next
[10:23:18.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.466]                 }
[10:23:18.466]                 NAMES <- toupper(added)
[10:23:18.466]                 for (kk in seq_along(NAMES)) {
[10:23:18.466]                   name <- added[[kk]]
[10:23:18.466]                   NAME <- NAMES[[kk]]
[10:23:18.466]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.466]                     next
[10:23:18.466]                   args[[name]] <- ""
[10:23:18.466]                 }
[10:23:18.466]                 NAMES <- toupper(removed)
[10:23:18.466]                 for (kk in seq_along(NAMES)) {
[10:23:18.466]                   name <- removed[[kk]]
[10:23:18.466]                   NAME <- NAMES[[kk]]
[10:23:18.466]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.466]                     next
[10:23:18.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.466]                 }
[10:23:18.466]                 if (length(args) > 0) 
[10:23:18.466]                   base::do.call(base::Sys.setenv, args = args)
[10:23:18.466]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:18.466]             }
[10:23:18.466]             else {
[10:23:18.466]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:18.466]             }
[10:23:18.466]             {
[10:23:18.466]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:18.466]                   0L) {
[10:23:18.466]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:18.466]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:18.466]                   base::options(opts)
[10:23:18.466]                 }
[10:23:18.466]                 {
[10:23:18.466]                   {
[10:23:18.466]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:18.466]                     NULL
[10:23:18.466]                   }
[10:23:18.466]                   options(future.plan = NULL)
[10:23:18.466]                   if (is.na(NA_character_)) 
[10:23:18.466]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.466]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:18.466]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:18.466]                     .init = FALSE)
[10:23:18.466]                 }
[10:23:18.466]             }
[10:23:18.466]         }
[10:23:18.466]     })
[10:23:18.466]     if (TRUE) {
[10:23:18.466]         base::sink(type = "output", split = FALSE)
[10:23:18.466]         if (TRUE) {
[10:23:18.466]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:18.466]         }
[10:23:18.466]         else {
[10:23:18.466]             ...future.result["stdout"] <- base::list(NULL)
[10:23:18.466]         }
[10:23:18.466]         base::close(...future.stdout)
[10:23:18.466]         ...future.stdout <- NULL
[10:23:18.466]     }
[10:23:18.466]     ...future.result$conditions <- ...future.conditions
[10:23:18.466]     ...future.result$finished <- base::Sys.time()
[10:23:18.466]     ...future.result
[10:23:18.466] }
[10:23:18.469] MultisessionFuture started
[10:23:18.469] - Launch lazy future ... done
[10:23:18.469] run() for ‘MultisessionFuture’ ... done
[10:23:18.470] result() for ClusterFuture ...
[10:23:18.470] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.470] - Validating connection of MultisessionFuture
[10:23:18.511] - received message: FutureResult
[10:23:18.511] - Received FutureResult
[10:23:18.512] - Erased future from FutureRegistry
[10:23:18.512] result() for ClusterFuture ...
[10:23:18.512] - result already collected: FutureResult
[10:23:18.512] result() for ClusterFuture ... done
[10:23:18.512] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.512] result() for ClusterFuture ... done
[10:23:18.512] result() for ClusterFuture ...
[10:23:18.512] - result already collected: FutureResult
[10:23:18.512] result() for ClusterFuture ... done
[10:23:18.512] result() for ClusterFuture ...
[10:23:18.512] - result already collected: FutureResult
[10:23:18.513] result() for ClusterFuture ... done
[1] 42
[10:23:18.513] result() for ClusterFuture ...
[10:23:18.513] - result already collected: FutureResult
[10:23:18.513] result() for ClusterFuture ... done
- stdout = NA
[10:23:18.513] getGlobalsAndPackages() ...
[10:23:18.513] Searching for globals...
[10:23:18.516] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:18.516] Searching for globals ... DONE
[10:23:18.516] Resolving globals: FALSE
[10:23:18.517] 
[10:23:18.517] - packages: [1] ‘utils’
[10:23:18.517] getGlobalsAndPackages() ... DONE
[10:23:18.517] run() for ‘Future’ ...
[10:23:18.518] - state: ‘created’
[10:23:18.518] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:23:18.532] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:18.532] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:23:18.532]   - Field: ‘node’
[10:23:18.532]   - Field: ‘label’
[10:23:18.532]   - Field: ‘local’
[10:23:18.532]   - Field: ‘owner’
[10:23:18.532]   - Field: ‘envir’
[10:23:18.532]   - Field: ‘workers’
[10:23:18.533]   - Field: ‘packages’
[10:23:18.533]   - Field: ‘gc’
[10:23:18.533]   - Field: ‘conditions’
[10:23:18.533]   - Field: ‘persistent’
[10:23:18.533]   - Field: ‘expr’
[10:23:18.533]   - Field: ‘uuid’
[10:23:18.533]   - Field: ‘seed’
[10:23:18.533]   - Field: ‘version’
[10:23:18.533]   - Field: ‘result’
[10:23:18.533]   - Field: ‘asynchronous’
[10:23:18.533]   - Field: ‘calls’
[10:23:18.534]   - Field: ‘globals’
[10:23:18.534]   - Field: ‘stdout’
[10:23:18.534]   - Field: ‘earlySignal’
[10:23:18.534]   - Field: ‘lazy’
[10:23:18.534]   - Field: ‘state’
[10:23:18.534] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:23:18.534] - Launch lazy future ...
[10:23:18.534] Packages needed by the future expression (n = 1): ‘utils’
[10:23:18.534] Packages needed by future strategies (n = 0): <none>
[10:23:18.535] {
[10:23:18.535]     {
[10:23:18.535]         {
[10:23:18.535]             ...future.startTime <- base::Sys.time()
[10:23:18.535]             {
[10:23:18.535]                 {
[10:23:18.535]                   {
[10:23:18.535]                     {
[10:23:18.535]                       {
[10:23:18.535]                         base::local({
[10:23:18.535]                           has_future <- base::requireNamespace("future", 
[10:23:18.535]                             quietly = TRUE)
[10:23:18.535]                           if (has_future) {
[10:23:18.535]                             ns <- base::getNamespace("future")
[10:23:18.535]                             version <- ns[[".package"]][["version"]]
[10:23:18.535]                             if (is.null(version)) 
[10:23:18.535]                               version <- utils::packageVersion("future")
[10:23:18.535]                           }
[10:23:18.535]                           else {
[10:23:18.535]                             version <- NULL
[10:23:18.535]                           }
[10:23:18.535]                           if (!has_future || version < "1.8.0") {
[10:23:18.535]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:18.535]                               "", base::R.version$version.string), 
[10:23:18.535]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:18.535]                                 base::R.version$platform, 8 * 
[10:23:18.535]                                   base::.Machine$sizeof.pointer), 
[10:23:18.535]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:18.535]                                 "release", "version")], collapse = " "), 
[10:23:18.535]                               hostname = base::Sys.info()[["nodename"]])
[10:23:18.535]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:18.535]                               info)
[10:23:18.535]                             info <- base::paste(info, collapse = "; ")
[10:23:18.535]                             if (!has_future) {
[10:23:18.535]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:18.535]                                 info)
[10:23:18.535]                             }
[10:23:18.535]                             else {
[10:23:18.535]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:18.535]                                 info, version)
[10:23:18.535]                             }
[10:23:18.535]                             base::stop(msg)
[10:23:18.535]                           }
[10:23:18.535]                         })
[10:23:18.535]                       }
[10:23:18.535]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:18.535]                       base::options(mc.cores = 1L)
[10:23:18.535]                     }
[10:23:18.535]                     base::local({
[10:23:18.535]                       for (pkg in "utils") {
[10:23:18.535]                         base::loadNamespace(pkg)
[10:23:18.535]                         base::library(pkg, character.only = TRUE)
[10:23:18.535]                       }
[10:23:18.535]                     })
[10:23:18.535]                   }
[10:23:18.535]                   ...future.strategy.old <- future::plan("list")
[10:23:18.535]                   options(future.plan = NULL)
[10:23:18.535]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.535]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:18.535]                 }
[10:23:18.535]                 ...future.workdir <- getwd()
[10:23:18.535]             }
[10:23:18.535]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:18.535]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:18.535]         }
[10:23:18.535]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:18.535]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:18.535]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:18.535]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:18.535]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:18.535]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:18.535]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:18.535]             base::names(...future.oldOptions))
[10:23:18.535]     }
[10:23:18.535]     if (TRUE) {
[10:23:18.535]     }
[10:23:18.535]     else {
[10:23:18.535]         if (NA) {
[10:23:18.535]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:18.535]                 open = "w")
[10:23:18.535]         }
[10:23:18.535]         else {
[10:23:18.535]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:18.535]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:18.535]         }
[10:23:18.535]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:18.535]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:18.535]             base::sink(type = "output", split = FALSE)
[10:23:18.535]             base::close(...future.stdout)
[10:23:18.535]         }, add = TRUE)
[10:23:18.535]     }
[10:23:18.535]     ...future.frame <- base::sys.nframe()
[10:23:18.535]     ...future.conditions <- base::list()
[10:23:18.535]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:18.535]     if (FALSE) {
[10:23:18.535]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:18.535]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:18.535]     }
[10:23:18.535]     ...future.result <- base::tryCatch({
[10:23:18.535]         base::withCallingHandlers({
[10:23:18.535]             ...future.value <- base::withVisible(base::local({
[10:23:18.535]                 ...future.makeSendCondition <- base::local({
[10:23:18.535]                   sendCondition <- NULL
[10:23:18.535]                   function(frame = 1L) {
[10:23:18.535]                     if (is.function(sendCondition)) 
[10:23:18.535]                       return(sendCondition)
[10:23:18.535]                     ns <- getNamespace("parallel")
[10:23:18.535]                     if (exists("sendData", mode = "function", 
[10:23:18.535]                       envir = ns)) {
[10:23:18.535]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:18.535]                         envir = ns)
[10:23:18.535]                       envir <- sys.frame(frame)
[10:23:18.535]                       master <- NULL
[10:23:18.535]                       while (!identical(envir, .GlobalEnv) && 
[10:23:18.535]                         !identical(envir, emptyenv())) {
[10:23:18.535]                         if (exists("master", mode = "list", envir = envir, 
[10:23:18.535]                           inherits = FALSE)) {
[10:23:18.535]                           master <- get("master", mode = "list", 
[10:23:18.535]                             envir = envir, inherits = FALSE)
[10:23:18.535]                           if (inherits(master, c("SOCKnode", 
[10:23:18.535]                             "SOCK0node"))) {
[10:23:18.535]                             sendCondition <<- function(cond) {
[10:23:18.535]                               data <- list(type = "VALUE", value = cond, 
[10:23:18.535]                                 success = TRUE)
[10:23:18.535]                               parallel_sendData(master, data)
[10:23:18.535]                             }
[10:23:18.535]                             return(sendCondition)
[10:23:18.535]                           }
[10:23:18.535]                         }
[10:23:18.535]                         frame <- frame + 1L
[10:23:18.535]                         envir <- sys.frame(frame)
[10:23:18.535]                       }
[10:23:18.535]                     }
[10:23:18.535]                     sendCondition <<- function(cond) NULL
[10:23:18.535]                   }
[10:23:18.535]                 })
[10:23:18.535]                 withCallingHandlers({
[10:23:18.535]                   {
[10:23:18.535]                     print(1:50)
[10:23:18.535]                     str(1:50)
[10:23:18.535]                     cat(letters, sep = "-")
[10:23:18.535]                     cat(1:6, collapse = "\n")
[10:23:18.535]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:18.535]                     42L
[10:23:18.535]                   }
[10:23:18.535]                 }, immediateCondition = function(cond) {
[10:23:18.535]                   sendCondition <- ...future.makeSendCondition()
[10:23:18.535]                   sendCondition(cond)
[10:23:18.535]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.535]                   {
[10:23:18.535]                     inherits <- base::inherits
[10:23:18.535]                     invokeRestart <- base::invokeRestart
[10:23:18.535]                     is.null <- base::is.null
[10:23:18.535]                     muffled <- FALSE
[10:23:18.535]                     if (inherits(cond, "message")) {
[10:23:18.535]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:18.535]                       if (muffled) 
[10:23:18.535]                         invokeRestart("muffleMessage")
[10:23:18.535]                     }
[10:23:18.535]                     else if (inherits(cond, "warning")) {
[10:23:18.535]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:18.535]                       if (muffled) 
[10:23:18.535]                         invokeRestart("muffleWarning")
[10:23:18.535]                     }
[10:23:18.535]                     else if (inherits(cond, "condition")) {
[10:23:18.535]                       if (!is.null(pattern)) {
[10:23:18.535]                         computeRestarts <- base::computeRestarts
[10:23:18.535]                         grepl <- base::grepl
[10:23:18.535]                         restarts <- computeRestarts(cond)
[10:23:18.535]                         for (restart in restarts) {
[10:23:18.535]                           name <- restart$name
[10:23:18.535]                           if (is.null(name)) 
[10:23:18.535]                             next
[10:23:18.535]                           if (!grepl(pattern, name)) 
[10:23:18.535]                             next
[10:23:18.535]                           invokeRestart(restart)
[10:23:18.535]                           muffled <- TRUE
[10:23:18.535]                           break
[10:23:18.535]                         }
[10:23:18.535]                       }
[10:23:18.535]                     }
[10:23:18.535]                     invisible(muffled)
[10:23:18.535]                   }
[10:23:18.535]                   muffleCondition(cond)
[10:23:18.535]                 })
[10:23:18.535]             }))
[10:23:18.535]             future::FutureResult(value = ...future.value$value, 
[10:23:18.535]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.535]                   ...future.rng), globalenv = if (FALSE) 
[10:23:18.535]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:18.535]                     ...future.globalenv.names))
[10:23:18.535]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:18.535]         }, condition = base::local({
[10:23:18.535]             c <- base::c
[10:23:18.535]             inherits <- base::inherits
[10:23:18.535]             invokeRestart <- base::invokeRestart
[10:23:18.535]             length <- base::length
[10:23:18.535]             list <- base::list
[10:23:18.535]             seq.int <- base::seq.int
[10:23:18.535]             signalCondition <- base::signalCondition
[10:23:18.535]             sys.calls <- base::sys.calls
[10:23:18.535]             `[[` <- base::`[[`
[10:23:18.535]             `+` <- base::`+`
[10:23:18.535]             `<<-` <- base::`<<-`
[10:23:18.535]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:18.535]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:18.535]                   3L)]
[10:23:18.535]             }
[10:23:18.535]             function(cond) {
[10:23:18.535]                 is_error <- inherits(cond, "error")
[10:23:18.535]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:18.535]                   NULL)
[10:23:18.535]                 if (is_error) {
[10:23:18.535]                   sessionInformation <- function() {
[10:23:18.535]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:18.535]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:18.535]                       search = base::search(), system = base::Sys.info())
[10:23:18.535]                   }
[10:23:18.535]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.535]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:18.535]                     cond$call), session = sessionInformation(), 
[10:23:18.535]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:18.535]                   signalCondition(cond)
[10:23:18.535]                 }
[10:23:18.535]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:18.535]                 "immediateCondition"))) {
[10:23:18.535]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:18.535]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.535]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:18.535]                   if (TRUE && !signal) {
[10:23:18.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.535]                     {
[10:23:18.535]                       inherits <- base::inherits
[10:23:18.535]                       invokeRestart <- base::invokeRestart
[10:23:18.535]                       is.null <- base::is.null
[10:23:18.535]                       muffled <- FALSE
[10:23:18.535]                       if (inherits(cond, "message")) {
[10:23:18.535]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.535]                         if (muffled) 
[10:23:18.535]                           invokeRestart("muffleMessage")
[10:23:18.535]                       }
[10:23:18.535]                       else if (inherits(cond, "warning")) {
[10:23:18.535]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.535]                         if (muffled) 
[10:23:18.535]                           invokeRestart("muffleWarning")
[10:23:18.535]                       }
[10:23:18.535]                       else if (inherits(cond, "condition")) {
[10:23:18.535]                         if (!is.null(pattern)) {
[10:23:18.535]                           computeRestarts <- base::computeRestarts
[10:23:18.535]                           grepl <- base::grepl
[10:23:18.535]                           restarts <- computeRestarts(cond)
[10:23:18.535]                           for (restart in restarts) {
[10:23:18.535]                             name <- restart$name
[10:23:18.535]                             if (is.null(name)) 
[10:23:18.535]                               next
[10:23:18.535]                             if (!grepl(pattern, name)) 
[10:23:18.535]                               next
[10:23:18.535]                             invokeRestart(restart)
[10:23:18.535]                             muffled <- TRUE
[10:23:18.535]                             break
[10:23:18.535]                           }
[10:23:18.535]                         }
[10:23:18.535]                       }
[10:23:18.535]                       invisible(muffled)
[10:23:18.535]                     }
[10:23:18.535]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.535]                   }
[10:23:18.535]                 }
[10:23:18.535]                 else {
[10:23:18.535]                   if (TRUE) {
[10:23:18.535]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.535]                     {
[10:23:18.535]                       inherits <- base::inherits
[10:23:18.535]                       invokeRestart <- base::invokeRestart
[10:23:18.535]                       is.null <- base::is.null
[10:23:18.535]                       muffled <- FALSE
[10:23:18.535]                       if (inherits(cond, "message")) {
[10:23:18.535]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.535]                         if (muffled) 
[10:23:18.535]                           invokeRestart("muffleMessage")
[10:23:18.535]                       }
[10:23:18.535]                       else if (inherits(cond, "warning")) {
[10:23:18.535]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.535]                         if (muffled) 
[10:23:18.535]                           invokeRestart("muffleWarning")
[10:23:18.535]                       }
[10:23:18.535]                       else if (inherits(cond, "condition")) {
[10:23:18.535]                         if (!is.null(pattern)) {
[10:23:18.535]                           computeRestarts <- base::computeRestarts
[10:23:18.535]                           grepl <- base::grepl
[10:23:18.535]                           restarts <- computeRestarts(cond)
[10:23:18.535]                           for (restart in restarts) {
[10:23:18.535]                             name <- restart$name
[10:23:18.535]                             if (is.null(name)) 
[10:23:18.535]                               next
[10:23:18.535]                             if (!grepl(pattern, name)) 
[10:23:18.535]                               next
[10:23:18.535]                             invokeRestart(restart)
[10:23:18.535]                             muffled <- TRUE
[10:23:18.535]                             break
[10:23:18.535]                           }
[10:23:18.535]                         }
[10:23:18.535]                       }
[10:23:18.535]                       invisible(muffled)
[10:23:18.535]                     }
[10:23:18.535]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.535]                   }
[10:23:18.535]                 }
[10:23:18.535]             }
[10:23:18.535]         }))
[10:23:18.535]     }, error = function(ex) {
[10:23:18.535]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:18.535]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.535]                 ...future.rng), started = ...future.startTime, 
[10:23:18.535]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:18.535]             version = "1.8"), class = "FutureResult")
[10:23:18.535]     }, finally = {
[10:23:18.535]         if (!identical(...future.workdir, getwd())) 
[10:23:18.535]             setwd(...future.workdir)
[10:23:18.535]         {
[10:23:18.535]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:18.535]                 ...future.oldOptions$nwarnings <- NULL
[10:23:18.535]             }
[10:23:18.535]             base::options(...future.oldOptions)
[10:23:18.535]             if (.Platform$OS.type == "windows") {
[10:23:18.535]                 old_names <- names(...future.oldEnvVars)
[10:23:18.535]                 envs <- base::Sys.getenv()
[10:23:18.535]                 names <- names(envs)
[10:23:18.535]                 common <- intersect(names, old_names)
[10:23:18.535]                 added <- setdiff(names, old_names)
[10:23:18.535]                 removed <- setdiff(old_names, names)
[10:23:18.535]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:18.535]                   envs[common]]
[10:23:18.535]                 NAMES <- toupper(changed)
[10:23:18.535]                 args <- list()
[10:23:18.535]                 for (kk in seq_along(NAMES)) {
[10:23:18.535]                   name <- changed[[kk]]
[10:23:18.535]                   NAME <- NAMES[[kk]]
[10:23:18.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.535]                     next
[10:23:18.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.535]                 }
[10:23:18.535]                 NAMES <- toupper(added)
[10:23:18.535]                 for (kk in seq_along(NAMES)) {
[10:23:18.535]                   name <- added[[kk]]
[10:23:18.535]                   NAME <- NAMES[[kk]]
[10:23:18.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.535]                     next
[10:23:18.535]                   args[[name]] <- ""
[10:23:18.535]                 }
[10:23:18.535]                 NAMES <- toupper(removed)
[10:23:18.535]                 for (kk in seq_along(NAMES)) {
[10:23:18.535]                   name <- removed[[kk]]
[10:23:18.535]                   NAME <- NAMES[[kk]]
[10:23:18.535]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.535]                     next
[10:23:18.535]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.535]                 }
[10:23:18.535]                 if (length(args) > 0) 
[10:23:18.535]                   base::do.call(base::Sys.setenv, args = args)
[10:23:18.535]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:18.535]             }
[10:23:18.535]             else {
[10:23:18.535]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:18.535]             }
[10:23:18.535]             {
[10:23:18.535]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:18.535]                   0L) {
[10:23:18.535]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:18.535]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:18.535]                   base::options(opts)
[10:23:18.535]                 }
[10:23:18.535]                 {
[10:23:18.535]                   {
[10:23:18.535]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:18.535]                     NULL
[10:23:18.535]                   }
[10:23:18.535]                   options(future.plan = NULL)
[10:23:18.535]                   if (is.na(NA_character_)) 
[10:23:18.535]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.535]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:18.535]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:18.535]                     .init = FALSE)
[10:23:18.535]                 }
[10:23:18.535]             }
[10:23:18.535]         }
[10:23:18.535]     })
[10:23:18.535]     if (FALSE) {
[10:23:18.535]         base::sink(type = "output", split = FALSE)
[10:23:18.535]         if (NA) {
[10:23:18.535]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:18.535]         }
[10:23:18.535]         else {
[10:23:18.535]             ...future.result["stdout"] <- base::list(NULL)
[10:23:18.535]         }
[10:23:18.535]         base::close(...future.stdout)
[10:23:18.535]         ...future.stdout <- NULL
[10:23:18.535]     }
[10:23:18.535]     ...future.result$conditions <- ...future.conditions
[10:23:18.535]     ...future.result$finished <- base::Sys.time()
[10:23:18.535]     ...future.result
[10:23:18.535] }
[10:23:18.538] MultisessionFuture started
[10:23:18.538] - Launch lazy future ... done
[10:23:18.538] run() for ‘MultisessionFuture’ ... done
[10:23:18.538] result() for ClusterFuture ...
[10:23:18.539] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.539] - Validating connection of MultisessionFuture
[10:23:18.581] - received message: FutureResult
[10:23:18.581] - Received FutureResult
[10:23:18.581] - Erased future from FutureRegistry
[10:23:18.581] result() for ClusterFuture ...
[10:23:18.582] - result already collected: FutureResult
[10:23:18.582] result() for ClusterFuture ... done
[10:23:18.582] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.582] result() for ClusterFuture ... done
List of 11
 $ value       : int 42
 $ visible     : logi TRUE
 $ stdout      : NULL
 $ conditions  : list()
 $ rng         : logi FALSE
 $ globalenv   : NULL
 $ started     : POSIXct[1:1], format: "2025-11-19 10:23:18"
 $ finished    : POSIXct[1:1], format: "2025-11-19 10:23:18"
 $ session_uuid: chr "f8c77005-6a78-0e78-343a-dff4abaa6280"
  ..- attr(*, "source")=List of 5
  .. ..$ host  : Named chr "eec1919a6b51"
  .. .. ..- attr(*, "names")= chr "HOSTNAME"
  .. ..$ info  : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. ..$ pid   : int 86343
  .. ..$ time  : POSIXct[1:1], format: "2025-11-19 10:23:18"
  .. ..$ random: int 2147483647
 $ r_info      :List of 4
  ..$ version      :Classes 'R_system_version', 'package_version', 'numeric_version'  hidden list of 1
  .. ..$ : int [1:3] 4 4 3
  ..$ os           : chr "unix"
  ..$ os_name      : chr "Linux"
  ..$ captures_utf8: logi TRUE
 $ version     : chr "1.8"
 - attr(*, "class")= chr "FutureResult"
[10:23:18.589] result() for ClusterFuture ...
[10:23:18.590] - result already collected: FutureResult
[10:23:18.590] result() for ClusterFuture ... done
[10:23:18.590] result() for ClusterFuture ...
[10:23:18.590] - result already collected: FutureResult
[10:23:18.590] result() for ClusterFuture ... done
[10:23:18.590] getGlobalsAndPackages() ...
[10:23:18.590] Searching for globals...
[10:23:18.593] - globals found: [9] ‘{’, ‘print’, ‘:’, ‘str’, ‘cat’, ‘letters’, ‘write.table’, ‘[’, ‘::’
[10:23:18.593] Searching for globals ... DONE
[10:23:18.594] Resolving globals: FALSE
[10:23:18.594] 
[10:23:18.594] - packages: [1] ‘utils’
[10:23:18.594] getGlobalsAndPackages() ... DONE
[10:23:18.595] run() for ‘Future’ ...
[10:23:18.595] - state: ‘created’
[10:23:18.595] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:23:18.609] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:18.609] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:23:18.609]   - Field: ‘node’
[10:23:18.609]   - Field: ‘label’
[10:23:18.609]   - Field: ‘local’
[10:23:18.609]   - Field: ‘owner’
[10:23:18.610]   - Field: ‘envir’
[10:23:18.610]   - Field: ‘workers’
[10:23:18.610]   - Field: ‘packages’
[10:23:18.610]   - Field: ‘gc’
[10:23:18.610]   - Field: ‘conditions’
[10:23:18.610]   - Field: ‘persistent’
[10:23:18.610]   - Field: ‘expr’
[10:23:18.610]   - Field: ‘uuid’
[10:23:18.610]   - Field: ‘seed’
[10:23:18.610]   - Field: ‘version’
[10:23:18.610]   - Field: ‘result’
[10:23:18.610]   - Field: ‘asynchronous’
[10:23:18.611]   - Field: ‘calls’
[10:23:18.611]   - Field: ‘globals’
[10:23:18.611]   - Field: ‘stdout’
[10:23:18.611]   - Field: ‘earlySignal’
[10:23:18.611]   - Field: ‘lazy’
[10:23:18.611]   - Field: ‘state’
[10:23:18.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:23:18.611] - Launch lazy future ...
[10:23:18.611] Packages needed by the future expression (n = 1): ‘utils’
[10:23:18.612] Packages needed by future strategies (n = 0): <none>
[10:23:18.612] {
[10:23:18.612]     {
[10:23:18.612]         {
[10:23:18.612]             ...future.startTime <- base::Sys.time()
[10:23:18.612]             {
[10:23:18.612]                 {
[10:23:18.612]                   {
[10:23:18.612]                     {
[10:23:18.612]                       {
[10:23:18.612]                         base::local({
[10:23:18.612]                           has_future <- base::requireNamespace("future", 
[10:23:18.612]                             quietly = TRUE)
[10:23:18.612]                           if (has_future) {
[10:23:18.612]                             ns <- base::getNamespace("future")
[10:23:18.612]                             version <- ns[[".package"]][["version"]]
[10:23:18.612]                             if (is.null(version)) 
[10:23:18.612]                               version <- utils::packageVersion("future")
[10:23:18.612]                           }
[10:23:18.612]                           else {
[10:23:18.612]                             version <- NULL
[10:23:18.612]                           }
[10:23:18.612]                           if (!has_future || version < "1.8.0") {
[10:23:18.612]                             info <- base::c(r_version = base::gsub("R version ", 
[10:23:18.612]                               "", base::R.version$version.string), 
[10:23:18.612]                               platform = base::sprintf("%s (%s-bit)", 
[10:23:18.612]                                 base::R.version$platform, 8 * 
[10:23:18.612]                                   base::.Machine$sizeof.pointer), 
[10:23:18.612]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:18.612]                                 "release", "version")], collapse = " "), 
[10:23:18.612]                               hostname = base::Sys.info()[["nodename"]])
[10:23:18.612]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:23:18.612]                               info)
[10:23:18.612]                             info <- base::paste(info, collapse = "; ")
[10:23:18.612]                             if (!has_future) {
[10:23:18.612]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:18.612]                                 info)
[10:23:18.612]                             }
[10:23:18.612]                             else {
[10:23:18.612]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:18.612]                                 info, version)
[10:23:18.612]                             }
[10:23:18.612]                             base::stop(msg)
[10:23:18.612]                           }
[10:23:18.612]                         })
[10:23:18.612]                       }
[10:23:18.612]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:18.612]                       base::options(mc.cores = 1L)
[10:23:18.612]                     }
[10:23:18.612]                     base::local({
[10:23:18.612]                       for (pkg in "utils") {
[10:23:18.612]                         base::loadNamespace(pkg)
[10:23:18.612]                         base::library(pkg, character.only = TRUE)
[10:23:18.612]                       }
[10:23:18.612]                     })
[10:23:18.612]                   }
[10:23:18.612]                   ...future.strategy.old <- future::plan("list")
[10:23:18.612]                   options(future.plan = NULL)
[10:23:18.612]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.612]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:18.612]                 }
[10:23:18.612]                 ...future.workdir <- getwd()
[10:23:18.612]             }
[10:23:18.612]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:18.612]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:18.612]         }
[10:23:18.612]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:18.612]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:18.612]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:18.612]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:18.612]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:18.612]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:18.612]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:18.612]             base::names(...future.oldOptions))
[10:23:18.612]     }
[10:23:18.612]     if (TRUE) {
[10:23:18.612]     }
[10:23:18.612]     else {
[10:23:18.612]         if (NA) {
[10:23:18.612]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:18.612]                 open = "w")
[10:23:18.612]         }
[10:23:18.612]         else {
[10:23:18.612]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:18.612]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:18.612]         }
[10:23:18.612]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:18.612]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:18.612]             base::sink(type = "output", split = FALSE)
[10:23:18.612]             base::close(...future.stdout)
[10:23:18.612]         }, add = TRUE)
[10:23:18.612]     }
[10:23:18.612]     ...future.frame <- base::sys.nframe()
[10:23:18.612]     ...future.conditions <- base::list()
[10:23:18.612]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:18.612]     if (FALSE) {
[10:23:18.612]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:18.612]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:18.612]     }
[10:23:18.612]     ...future.result <- base::tryCatch({
[10:23:18.612]         base::withCallingHandlers({
[10:23:18.612]             ...future.value <- base::withVisible(base::local({
[10:23:18.612]                 ...future.makeSendCondition <- base::local({
[10:23:18.612]                   sendCondition <- NULL
[10:23:18.612]                   function(frame = 1L) {
[10:23:18.612]                     if (is.function(sendCondition)) 
[10:23:18.612]                       return(sendCondition)
[10:23:18.612]                     ns <- getNamespace("parallel")
[10:23:18.612]                     if (exists("sendData", mode = "function", 
[10:23:18.612]                       envir = ns)) {
[10:23:18.612]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:18.612]                         envir = ns)
[10:23:18.612]                       envir <- sys.frame(frame)
[10:23:18.612]                       master <- NULL
[10:23:18.612]                       while (!identical(envir, .GlobalEnv) && 
[10:23:18.612]                         !identical(envir, emptyenv())) {
[10:23:18.612]                         if (exists("master", mode = "list", envir = envir, 
[10:23:18.612]                           inherits = FALSE)) {
[10:23:18.612]                           master <- get("master", mode = "list", 
[10:23:18.612]                             envir = envir, inherits = FALSE)
[10:23:18.612]                           if (inherits(master, c("SOCKnode", 
[10:23:18.612]                             "SOCK0node"))) {
[10:23:18.612]                             sendCondition <<- function(cond) {
[10:23:18.612]                               data <- list(type = "VALUE", value = cond, 
[10:23:18.612]                                 success = TRUE)
[10:23:18.612]                               parallel_sendData(master, data)
[10:23:18.612]                             }
[10:23:18.612]                             return(sendCondition)
[10:23:18.612]                           }
[10:23:18.612]                         }
[10:23:18.612]                         frame <- frame + 1L
[10:23:18.612]                         envir <- sys.frame(frame)
[10:23:18.612]                       }
[10:23:18.612]                     }
[10:23:18.612]                     sendCondition <<- function(cond) NULL
[10:23:18.612]                   }
[10:23:18.612]                 })
[10:23:18.612]                 withCallingHandlers({
[10:23:18.612]                   {
[10:23:18.612]                     print(1:50)
[10:23:18.612]                     str(1:50)
[10:23:18.612]                     cat(letters, sep = "-")
[10:23:18.612]                     cat(1:6, collapse = "\n")
[10:23:18.612]                     write.table(datasets::iris[1:10, ], sep = "\t")
[10:23:18.612]                     42L
[10:23:18.612]                   }
[10:23:18.612]                 }, immediateCondition = function(cond) {
[10:23:18.612]                   sendCondition <- ...future.makeSendCondition()
[10:23:18.612]                   sendCondition(cond)
[10:23:18.612]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.612]                   {
[10:23:18.612]                     inherits <- base::inherits
[10:23:18.612]                     invokeRestart <- base::invokeRestart
[10:23:18.612]                     is.null <- base::is.null
[10:23:18.612]                     muffled <- FALSE
[10:23:18.612]                     if (inherits(cond, "message")) {
[10:23:18.612]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:18.612]                       if (muffled) 
[10:23:18.612]                         invokeRestart("muffleMessage")
[10:23:18.612]                     }
[10:23:18.612]                     else if (inherits(cond, "warning")) {
[10:23:18.612]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:18.612]                       if (muffled) 
[10:23:18.612]                         invokeRestart("muffleWarning")
[10:23:18.612]                     }
[10:23:18.612]                     else if (inherits(cond, "condition")) {
[10:23:18.612]                       if (!is.null(pattern)) {
[10:23:18.612]                         computeRestarts <- base::computeRestarts
[10:23:18.612]                         grepl <- base::grepl
[10:23:18.612]                         restarts <- computeRestarts(cond)
[10:23:18.612]                         for (restart in restarts) {
[10:23:18.612]                           name <- restart$name
[10:23:18.612]                           if (is.null(name)) 
[10:23:18.612]                             next
[10:23:18.612]                           if (!grepl(pattern, name)) 
[10:23:18.612]                             next
[10:23:18.612]                           invokeRestart(restart)
[10:23:18.612]                           muffled <- TRUE
[10:23:18.612]                           break
[10:23:18.612]                         }
[10:23:18.612]                       }
[10:23:18.612]                     }
[10:23:18.612]                     invisible(muffled)
[10:23:18.612]                   }
[10:23:18.612]                   muffleCondition(cond)
[10:23:18.612]                 })
[10:23:18.612]             }))
[10:23:18.612]             future::FutureResult(value = ...future.value$value, 
[10:23:18.612]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.612]                   ...future.rng), globalenv = if (FALSE) 
[10:23:18.612]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:18.612]                     ...future.globalenv.names))
[10:23:18.612]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:18.612]         }, condition = base::local({
[10:23:18.612]             c <- base::c
[10:23:18.612]             inherits <- base::inherits
[10:23:18.612]             invokeRestart <- base::invokeRestart
[10:23:18.612]             length <- base::length
[10:23:18.612]             list <- base::list
[10:23:18.612]             seq.int <- base::seq.int
[10:23:18.612]             signalCondition <- base::signalCondition
[10:23:18.612]             sys.calls <- base::sys.calls
[10:23:18.612]             `[[` <- base::`[[`
[10:23:18.612]             `+` <- base::`+`
[10:23:18.612]             `<<-` <- base::`<<-`
[10:23:18.612]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:18.612]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:18.612]                   3L)]
[10:23:18.612]             }
[10:23:18.612]             function(cond) {
[10:23:18.612]                 is_error <- inherits(cond, "error")
[10:23:18.612]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:18.612]                   NULL)
[10:23:18.612]                 if (is_error) {
[10:23:18.612]                   sessionInformation <- function() {
[10:23:18.612]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:18.612]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:18.612]                       search = base::search(), system = base::Sys.info())
[10:23:18.612]                   }
[10:23:18.612]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.612]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:18.612]                     cond$call), session = sessionInformation(), 
[10:23:18.612]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:18.612]                   signalCondition(cond)
[10:23:18.612]                 }
[10:23:18.612]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:18.612]                 "immediateCondition"))) {
[10:23:18.612]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:18.612]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.612]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:18.612]                   if (TRUE && !signal) {
[10:23:18.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.612]                     {
[10:23:18.612]                       inherits <- base::inherits
[10:23:18.612]                       invokeRestart <- base::invokeRestart
[10:23:18.612]                       is.null <- base::is.null
[10:23:18.612]                       muffled <- FALSE
[10:23:18.612]                       if (inherits(cond, "message")) {
[10:23:18.612]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.612]                         if (muffled) 
[10:23:18.612]                           invokeRestart("muffleMessage")
[10:23:18.612]                       }
[10:23:18.612]                       else if (inherits(cond, "warning")) {
[10:23:18.612]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.612]                         if (muffled) 
[10:23:18.612]                           invokeRestart("muffleWarning")
[10:23:18.612]                       }
[10:23:18.612]                       else if (inherits(cond, "condition")) {
[10:23:18.612]                         if (!is.null(pattern)) {
[10:23:18.612]                           computeRestarts <- base::computeRestarts
[10:23:18.612]                           grepl <- base::grepl
[10:23:18.612]                           restarts <- computeRestarts(cond)
[10:23:18.612]                           for (restart in restarts) {
[10:23:18.612]                             name <- restart$name
[10:23:18.612]                             if (is.null(name)) 
[10:23:18.612]                               next
[10:23:18.612]                             if (!grepl(pattern, name)) 
[10:23:18.612]                               next
[10:23:18.612]                             invokeRestart(restart)
[10:23:18.612]                             muffled <- TRUE
[10:23:18.612]                             break
[10:23:18.612]                           }
[10:23:18.612]                         }
[10:23:18.612]                       }
[10:23:18.612]                       invisible(muffled)
[10:23:18.612]                     }
[10:23:18.612]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.612]                   }
[10:23:18.612]                 }
[10:23:18.612]                 else {
[10:23:18.612]                   if (TRUE) {
[10:23:18.612]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.612]                     {
[10:23:18.612]                       inherits <- base::inherits
[10:23:18.612]                       invokeRestart <- base::invokeRestart
[10:23:18.612]                       is.null <- base::is.null
[10:23:18.612]                       muffled <- FALSE
[10:23:18.612]                       if (inherits(cond, "message")) {
[10:23:18.612]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.612]                         if (muffled) 
[10:23:18.612]                           invokeRestart("muffleMessage")
[10:23:18.612]                       }
[10:23:18.612]                       else if (inherits(cond, "warning")) {
[10:23:18.612]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.612]                         if (muffled) 
[10:23:18.612]                           invokeRestart("muffleWarning")
[10:23:18.612]                       }
[10:23:18.612]                       else if (inherits(cond, "condition")) {
[10:23:18.612]                         if (!is.null(pattern)) {
[10:23:18.612]                           computeRestarts <- base::computeRestarts
[10:23:18.612]                           grepl <- base::grepl
[10:23:18.612]                           restarts <- computeRestarts(cond)
[10:23:18.612]                           for (restart in restarts) {
[10:23:18.612]                             name <- restart$name
[10:23:18.612]                             if (is.null(name)) 
[10:23:18.612]                               next
[10:23:18.612]                             if (!grepl(pattern, name)) 
[10:23:18.612]                               next
[10:23:18.612]                             invokeRestart(restart)
[10:23:18.612]                             muffled <- TRUE
[10:23:18.612]                             break
[10:23:18.612]                           }
[10:23:18.612]                         }
[10:23:18.612]                       }
[10:23:18.612]                       invisible(muffled)
[10:23:18.612]                     }
[10:23:18.612]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.612]                   }
[10:23:18.612]                 }
[10:23:18.612]             }
[10:23:18.612]         }))
[10:23:18.612]     }, error = function(ex) {
[10:23:18.612]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:18.612]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.612]                 ...future.rng), started = ...future.startTime, 
[10:23:18.612]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:18.612]             version = "1.8"), class = "FutureResult")
[10:23:18.612]     }, finally = {
[10:23:18.612]         if (!identical(...future.workdir, getwd())) 
[10:23:18.612]             setwd(...future.workdir)
[10:23:18.612]         {
[10:23:18.612]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:18.612]                 ...future.oldOptions$nwarnings <- NULL
[10:23:18.612]             }
[10:23:18.612]             base::options(...future.oldOptions)
[10:23:18.612]             if (.Platform$OS.type == "windows") {
[10:23:18.612]                 old_names <- names(...future.oldEnvVars)
[10:23:18.612]                 envs <- base::Sys.getenv()
[10:23:18.612]                 names <- names(envs)
[10:23:18.612]                 common <- intersect(names, old_names)
[10:23:18.612]                 added <- setdiff(names, old_names)
[10:23:18.612]                 removed <- setdiff(old_names, names)
[10:23:18.612]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:18.612]                   envs[common]]
[10:23:18.612]                 NAMES <- toupper(changed)
[10:23:18.612]                 args <- list()
[10:23:18.612]                 for (kk in seq_along(NAMES)) {
[10:23:18.612]                   name <- changed[[kk]]
[10:23:18.612]                   NAME <- NAMES[[kk]]
[10:23:18.612]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.612]                     next
[10:23:18.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.612]                 }
[10:23:18.612]                 NAMES <- toupper(added)
[10:23:18.612]                 for (kk in seq_along(NAMES)) {
[10:23:18.612]                   name <- added[[kk]]
[10:23:18.612]                   NAME <- NAMES[[kk]]
[10:23:18.612]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.612]                     next
[10:23:18.612]                   args[[name]] <- ""
[10:23:18.612]                 }
[10:23:18.612]                 NAMES <- toupper(removed)
[10:23:18.612]                 for (kk in seq_along(NAMES)) {
[10:23:18.612]                   name <- removed[[kk]]
[10:23:18.612]                   NAME <- NAMES[[kk]]
[10:23:18.612]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.612]                     next
[10:23:18.612]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.612]                 }
[10:23:18.612]                 if (length(args) > 0) 
[10:23:18.612]                   base::do.call(base::Sys.setenv, args = args)
[10:23:18.612]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:18.612]             }
[10:23:18.612]             else {
[10:23:18.612]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:18.612]             }
[10:23:18.612]             {
[10:23:18.612]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:18.612]                   0L) {
[10:23:18.612]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:18.612]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:18.612]                   base::options(opts)
[10:23:18.612]                 }
[10:23:18.612]                 {
[10:23:18.612]                   {
[10:23:18.612]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:18.612]                     NULL
[10:23:18.612]                   }
[10:23:18.612]                   options(future.plan = NULL)
[10:23:18.612]                   if (is.na(NA_character_)) 
[10:23:18.612]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.612]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:18.612]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:18.612]                     .init = FALSE)
[10:23:18.612]                 }
[10:23:18.612]             }
[10:23:18.612]         }
[10:23:18.612]     })
[10:23:18.612]     if (FALSE) {
[10:23:18.612]         base::sink(type = "output", split = FALSE)
[10:23:18.612]         if (NA) {
[10:23:18.612]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:18.612]         }
[10:23:18.612]         else {
[10:23:18.612]             ...future.result["stdout"] <- base::list(NULL)
[10:23:18.612]         }
[10:23:18.612]         base::close(...future.stdout)
[10:23:18.612]         ...future.stdout <- NULL
[10:23:18.612]     }
[10:23:18.612]     ...future.result$conditions <- ...future.conditions
[10:23:18.612]     ...future.result$finished <- base::Sys.time()
[10:23:18.612]     ...future.result
[10:23:18.612] }
[10:23:18.615] MultisessionFuture started
[10:23:18.615] - Launch lazy future ... done
[10:23:18.616] run() for ‘MultisessionFuture’ ... done
[10:23:18.616] result() for ClusterFuture ...
[10:23:18.616] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.616] - Validating connection of MultisessionFuture
[10:23:18.659] - received message: FutureResult
[10:23:18.659] - Received FutureResult
[10:23:18.659] - Erased future from FutureRegistry
[10:23:18.659] result() for ClusterFuture ...
[10:23:18.659] - result already collected: FutureResult
[10:23:18.659] result() for ClusterFuture ... done
[10:23:18.660] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.660] result() for ClusterFuture ... done
[10:23:18.660] result() for ClusterFuture ...
[10:23:18.660] - result already collected: FutureResult
[10:23:18.660] result() for ClusterFuture ... done
- stdout = structure(TRUE, drop = TRUE)
[10:23:18.660] getGlobalsAndPackages() ...
[10:23:18.660] Searching for globals...
[10:23:18.661] - globals found: [1] ‘print’
[10:23:18.661] Searching for globals ... DONE
[10:23:18.661] Resolving globals: FALSE
[10:23:18.661] 
[10:23:18.664] 
[10:23:18.664] getGlobalsAndPackages() ... DONE
[10:23:18.664] run() for ‘Future’ ...
[10:23:18.664] - state: ‘created’
[10:23:18.664] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:23:18.678] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:23:18.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:23:18.679]   - Field: ‘node’
[10:23:18.679]   - Field: ‘label’
[10:23:18.679]   - Field: ‘local’
[10:23:18.679]   - Field: ‘owner’
[10:23:18.680]   - Field: ‘envir’
[10:23:18.680]   - Field: ‘workers’
[10:23:18.680]   - Field: ‘packages’
[10:23:18.680]   - Field: ‘gc’
[10:23:18.680]   - Field: ‘conditions’
[10:23:18.680]   - Field: ‘persistent’
[10:23:18.681]   - Field: ‘expr’
[10:23:18.681]   - Field: ‘uuid’
[10:23:18.681]   - Field: ‘seed’
[10:23:18.681]   - Field: ‘version’
[10:23:18.681]   - Field: ‘result’
[10:23:18.681]   - Field: ‘asynchronous’
[10:23:18.681]   - Field: ‘calls’
[10:23:18.681]   - Field: ‘globals’
[10:23:18.681]   - Field: ‘stdout’
[10:23:18.681]   - Field: ‘earlySignal’
[10:23:18.681]   - Field: ‘lazy’
[10:23:18.682]   - Field: ‘state’
[10:23:18.682] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:23:18.682] - Launch lazy future ...
[10:23:18.682] Packages needed by the future expression (n = 0): <none>
[10:23:18.682] Packages needed by future strategies (n = 0): <none>
[10:23:18.683] {
[10:23:18.683]     {
[10:23:18.683]         {
[10:23:18.683]             ...future.startTime <- base::Sys.time()
[10:23:18.683]             {
[10:23:18.683]                 {
[10:23:18.683]                   {
[10:23:18.683]                     {
[10:23:18.683]                       base::local({
[10:23:18.683]                         has_future <- base::requireNamespace("future", 
[10:23:18.683]                           quietly = TRUE)
[10:23:18.683]                         if (has_future) {
[10:23:18.683]                           ns <- base::getNamespace("future")
[10:23:18.683]                           version <- ns[[".package"]][["version"]]
[10:23:18.683]                           if (is.null(version)) 
[10:23:18.683]                             version <- utils::packageVersion("future")
[10:23:18.683]                         }
[10:23:18.683]                         else {
[10:23:18.683]                           version <- NULL
[10:23:18.683]                         }
[10:23:18.683]                         if (!has_future || version < "1.8.0") {
[10:23:18.683]                           info <- base::c(r_version = base::gsub("R version ", 
[10:23:18.683]                             "", base::R.version$version.string), 
[10:23:18.683]                             platform = base::sprintf("%s (%s-bit)", 
[10:23:18.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:23:18.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:23:18.683]                               "release", "version")], collapse = " "), 
[10:23:18.683]                             hostname = base::Sys.info()[["nodename"]])
[10:23:18.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:23:18.683]                             info)
[10:23:18.683]                           info <- base::paste(info, collapse = "; ")
[10:23:18.683]                           if (!has_future) {
[10:23:18.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:23:18.683]                               info)
[10:23:18.683]                           }
[10:23:18.683]                           else {
[10:23:18.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:23:18.683]                               info, version)
[10:23:18.683]                           }
[10:23:18.683]                           base::stop(msg)
[10:23:18.683]                         }
[10:23:18.683]                       })
[10:23:18.683]                     }
[10:23:18.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:23:18.683]                     base::options(mc.cores = 1L)
[10:23:18.683]                   }
[10:23:18.683]                   ...future.strategy.old <- future::plan("list")
[10:23:18.683]                   options(future.plan = NULL)
[10:23:18.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:23:18.683]                 }
[10:23:18.683]                 ...future.workdir <- getwd()
[10:23:18.683]             }
[10:23:18.683]             ...future.oldOptions <- base::as.list(base::.Options)
[10:23:18.683]             ...future.oldEnvVars <- base::Sys.getenv()
[10:23:18.683]         }
[10:23:18.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:23:18.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:23:18.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:23:18.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:23:18.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:23:18.683]             future.stdout.windows.reencode = NULL, width = 80L)
[10:23:18.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:23:18.683]             base::names(...future.oldOptions))
[10:23:18.683]     }
[10:23:18.683]     if (FALSE) {
[10:23:18.683]     }
[10:23:18.683]     else {
[10:23:18.683]         if (TRUE) {
[10:23:18.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:23:18.683]                 open = "w")
[10:23:18.683]         }
[10:23:18.683]         else {
[10:23:18.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:23:18.683]                 windows = "NUL", "/dev/null"), open = "w")
[10:23:18.683]         }
[10:23:18.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:23:18.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:23:18.683]             base::sink(type = "output", split = FALSE)
[10:23:18.683]             base::close(...future.stdout)
[10:23:18.683]         }, add = TRUE)
[10:23:18.683]     }
[10:23:18.683]     ...future.frame <- base::sys.nframe()
[10:23:18.683]     ...future.conditions <- base::list()
[10:23:18.683]     ...future.rng <- base::globalenv()$.Random.seed
[10:23:18.683]     if (FALSE) {
[10:23:18.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:23:18.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:23:18.683]     }
[10:23:18.683]     ...future.result <- base::tryCatch({
[10:23:18.683]         base::withCallingHandlers({
[10:23:18.683]             ...future.value <- base::withVisible(base::local({
[10:23:18.683]                 ...future.makeSendCondition <- base::local({
[10:23:18.683]                   sendCondition <- NULL
[10:23:18.683]                   function(frame = 1L) {
[10:23:18.683]                     if (is.function(sendCondition)) 
[10:23:18.683]                       return(sendCondition)
[10:23:18.683]                     ns <- getNamespace("parallel")
[10:23:18.683]                     if (exists("sendData", mode = "function", 
[10:23:18.683]                       envir = ns)) {
[10:23:18.683]                       parallel_sendData <- get("sendData", mode = "function", 
[10:23:18.683]                         envir = ns)
[10:23:18.683]                       envir <- sys.frame(frame)
[10:23:18.683]                       master <- NULL
[10:23:18.683]                       while (!identical(envir, .GlobalEnv) && 
[10:23:18.683]                         !identical(envir, emptyenv())) {
[10:23:18.683]                         if (exists("master", mode = "list", envir = envir, 
[10:23:18.683]                           inherits = FALSE)) {
[10:23:18.683]                           master <- get("master", mode = "list", 
[10:23:18.683]                             envir = envir, inherits = FALSE)
[10:23:18.683]                           if (inherits(master, c("SOCKnode", 
[10:23:18.683]                             "SOCK0node"))) {
[10:23:18.683]                             sendCondition <<- function(cond) {
[10:23:18.683]                               data <- list(type = "VALUE", value = cond, 
[10:23:18.683]                                 success = TRUE)
[10:23:18.683]                               parallel_sendData(master, data)
[10:23:18.683]                             }
[10:23:18.683]                             return(sendCondition)
[10:23:18.683]                           }
[10:23:18.683]                         }
[10:23:18.683]                         frame <- frame + 1L
[10:23:18.683]                         envir <- sys.frame(frame)
[10:23:18.683]                       }
[10:23:18.683]                     }
[10:23:18.683]                     sendCondition <<- function(cond) NULL
[10:23:18.683]                   }
[10:23:18.683]                 })
[10:23:18.683]                 withCallingHandlers({
[10:23:18.683]                   print(42)
[10:23:18.683]                 }, immediateCondition = function(cond) {
[10:23:18.683]                   sendCondition <- ...future.makeSendCondition()
[10:23:18.683]                   sendCondition(cond)
[10:23:18.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.683]                   {
[10:23:18.683]                     inherits <- base::inherits
[10:23:18.683]                     invokeRestart <- base::invokeRestart
[10:23:18.683]                     is.null <- base::is.null
[10:23:18.683]                     muffled <- FALSE
[10:23:18.683]                     if (inherits(cond, "message")) {
[10:23:18.683]                       muffled <- grepl(pattern, "muffleMessage")
[10:23:18.683]                       if (muffled) 
[10:23:18.683]                         invokeRestart("muffleMessage")
[10:23:18.683]                     }
[10:23:18.683]                     else if (inherits(cond, "warning")) {
[10:23:18.683]                       muffled <- grepl(pattern, "muffleWarning")
[10:23:18.683]                       if (muffled) 
[10:23:18.683]                         invokeRestart("muffleWarning")
[10:23:18.683]                     }
[10:23:18.683]                     else if (inherits(cond, "condition")) {
[10:23:18.683]                       if (!is.null(pattern)) {
[10:23:18.683]                         computeRestarts <- base::computeRestarts
[10:23:18.683]                         grepl <- base::grepl
[10:23:18.683]                         restarts <- computeRestarts(cond)
[10:23:18.683]                         for (restart in restarts) {
[10:23:18.683]                           name <- restart$name
[10:23:18.683]                           if (is.null(name)) 
[10:23:18.683]                             next
[10:23:18.683]                           if (!grepl(pattern, name)) 
[10:23:18.683]                             next
[10:23:18.683]                           invokeRestart(restart)
[10:23:18.683]                           muffled <- TRUE
[10:23:18.683]                           break
[10:23:18.683]                         }
[10:23:18.683]                       }
[10:23:18.683]                     }
[10:23:18.683]                     invisible(muffled)
[10:23:18.683]                   }
[10:23:18.683]                   muffleCondition(cond)
[10:23:18.683]                 })
[10:23:18.683]             }))
[10:23:18.683]             future::FutureResult(value = ...future.value$value, 
[10:23:18.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.683]                   ...future.rng), globalenv = if (FALSE) 
[10:23:18.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:23:18.683]                     ...future.globalenv.names))
[10:23:18.683]                 else NULL, started = ...future.startTime, version = "1.8")
[10:23:18.683]         }, condition = base::local({
[10:23:18.683]             c <- base::c
[10:23:18.683]             inherits <- base::inherits
[10:23:18.683]             invokeRestart <- base::invokeRestart
[10:23:18.683]             length <- base::length
[10:23:18.683]             list <- base::list
[10:23:18.683]             seq.int <- base::seq.int
[10:23:18.683]             signalCondition <- base::signalCondition
[10:23:18.683]             sys.calls <- base::sys.calls
[10:23:18.683]             `[[` <- base::`[[`
[10:23:18.683]             `+` <- base::`+`
[10:23:18.683]             `<<-` <- base::`<<-`
[10:23:18.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:23:18.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:23:18.683]                   3L)]
[10:23:18.683]             }
[10:23:18.683]             function(cond) {
[10:23:18.683]                 is_error <- inherits(cond, "error")
[10:23:18.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:23:18.683]                   NULL)
[10:23:18.683]                 if (is_error) {
[10:23:18.683]                   sessionInformation <- function() {
[10:23:18.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:23:18.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:23:18.683]                       search = base::search(), system = base::Sys.info())
[10:23:18.683]                   }
[10:23:18.683]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:23:18.683]                     cond$call), session = sessionInformation(), 
[10:23:18.683]                     timestamp = base::Sys.time(), signaled = 0L)
[10:23:18.683]                   signalCondition(cond)
[10:23:18.683]                 }
[10:23:18.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:23:18.683]                 "immediateCondition"))) {
[10:23:18.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:23:18.683]                   ...future.conditions[[length(...future.conditions) + 
[10:23:18.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:23:18.683]                   if (TRUE && !signal) {
[10:23:18.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.683]                     {
[10:23:18.683]                       inherits <- base::inherits
[10:23:18.683]                       invokeRestart <- base::invokeRestart
[10:23:18.683]                       is.null <- base::is.null
[10:23:18.683]                       muffled <- FALSE
[10:23:18.683]                       if (inherits(cond, "message")) {
[10:23:18.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.683]                         if (muffled) 
[10:23:18.683]                           invokeRestart("muffleMessage")
[10:23:18.683]                       }
[10:23:18.683]                       else if (inherits(cond, "warning")) {
[10:23:18.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.683]                         if (muffled) 
[10:23:18.683]                           invokeRestart("muffleWarning")
[10:23:18.683]                       }
[10:23:18.683]                       else if (inherits(cond, "condition")) {
[10:23:18.683]                         if (!is.null(pattern)) {
[10:23:18.683]                           computeRestarts <- base::computeRestarts
[10:23:18.683]                           grepl <- base::grepl
[10:23:18.683]                           restarts <- computeRestarts(cond)
[10:23:18.683]                           for (restart in restarts) {
[10:23:18.683]                             name <- restart$name
[10:23:18.683]                             if (is.null(name)) 
[10:23:18.683]                               next
[10:23:18.683]                             if (!grepl(pattern, name)) 
[10:23:18.683]                               next
[10:23:18.683]                             invokeRestart(restart)
[10:23:18.683]                             muffled <- TRUE
[10:23:18.683]                             break
[10:23:18.683]                           }
[10:23:18.683]                         }
[10:23:18.683]                       }
[10:23:18.683]                       invisible(muffled)
[10:23:18.683]                     }
[10:23:18.683]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.683]                   }
[10:23:18.683]                 }
[10:23:18.683]                 else {
[10:23:18.683]                   if (TRUE) {
[10:23:18.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:23:18.683]                     {
[10:23:18.683]                       inherits <- base::inherits
[10:23:18.683]                       invokeRestart <- base::invokeRestart
[10:23:18.683]                       is.null <- base::is.null
[10:23:18.683]                       muffled <- FALSE
[10:23:18.683]                       if (inherits(cond, "message")) {
[10:23:18.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:23:18.683]                         if (muffled) 
[10:23:18.683]                           invokeRestart("muffleMessage")
[10:23:18.683]                       }
[10:23:18.683]                       else if (inherits(cond, "warning")) {
[10:23:18.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:23:18.683]                         if (muffled) 
[10:23:18.683]                           invokeRestart("muffleWarning")
[10:23:18.683]                       }
[10:23:18.683]                       else if (inherits(cond, "condition")) {
[10:23:18.683]                         if (!is.null(pattern)) {
[10:23:18.683]                           computeRestarts <- base::computeRestarts
[10:23:18.683]                           grepl <- base::grepl
[10:23:18.683]                           restarts <- computeRestarts(cond)
[10:23:18.683]                           for (restart in restarts) {
[10:23:18.683]                             name <- restart$name
[10:23:18.683]                             if (is.null(name)) 
[10:23:18.683]                               next
[10:23:18.683]                             if (!grepl(pattern, name)) 
[10:23:18.683]                               next
[10:23:18.683]                             invokeRestart(restart)
[10:23:18.683]                             muffled <- TRUE
[10:23:18.683]                             break
[10:23:18.683]                           }
[10:23:18.683]                         }
[10:23:18.683]                       }
[10:23:18.683]                       invisible(muffled)
[10:23:18.683]                     }
[10:23:18.683]                     muffleCondition(cond, pattern = "^muffle")
[10:23:18.683]                   }
[10:23:18.683]                 }
[10:23:18.683]             }
[10:23:18.683]         }))
[10:23:18.683]     }, error = function(ex) {
[10:23:18.683]         base::structure(base::list(value = NULL, visible = NULL, 
[10:23:18.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:23:18.683]                 ...future.rng), started = ...future.startTime, 
[10:23:18.683]             finished = Sys.time(), session_uuid = NA_character_, 
[10:23:18.683]             version = "1.8"), class = "FutureResult")
[10:23:18.683]     }, finally = {
[10:23:18.683]         if (!identical(...future.workdir, getwd())) 
[10:23:18.683]             setwd(...future.workdir)
[10:23:18.683]         {
[10:23:18.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:23:18.683]                 ...future.oldOptions$nwarnings <- NULL
[10:23:18.683]             }
[10:23:18.683]             base::options(...future.oldOptions)
[10:23:18.683]             if (.Platform$OS.type == "windows") {
[10:23:18.683]                 old_names <- names(...future.oldEnvVars)
[10:23:18.683]                 envs <- base::Sys.getenv()
[10:23:18.683]                 names <- names(envs)
[10:23:18.683]                 common <- intersect(names, old_names)
[10:23:18.683]                 added <- setdiff(names, old_names)
[10:23:18.683]                 removed <- setdiff(old_names, names)
[10:23:18.683]                 changed <- common[...future.oldEnvVars[common] != 
[10:23:18.683]                   envs[common]]
[10:23:18.683]                 NAMES <- toupper(changed)
[10:23:18.683]                 args <- list()
[10:23:18.683]                 for (kk in seq_along(NAMES)) {
[10:23:18.683]                   name <- changed[[kk]]
[10:23:18.683]                   NAME <- NAMES[[kk]]
[10:23:18.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.683]                     next
[10:23:18.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.683]                 }
[10:23:18.683]                 NAMES <- toupper(added)
[10:23:18.683]                 for (kk in seq_along(NAMES)) {
[10:23:18.683]                   name <- added[[kk]]
[10:23:18.683]                   NAME <- NAMES[[kk]]
[10:23:18.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.683]                     next
[10:23:18.683]                   args[[name]] <- ""
[10:23:18.683]                 }
[10:23:18.683]                 NAMES <- toupper(removed)
[10:23:18.683]                 for (kk in seq_along(NAMES)) {
[10:23:18.683]                   name <- removed[[kk]]
[10:23:18.683]                   NAME <- NAMES[[kk]]
[10:23:18.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:23:18.683]                     next
[10:23:18.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:23:18.683]                 }
[10:23:18.683]                 if (length(args) > 0) 
[10:23:18.683]                   base::do.call(base::Sys.setenv, args = args)
[10:23:18.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:23:18.683]             }
[10:23:18.683]             else {
[10:23:18.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:23:18.683]             }
[10:23:18.683]             {
[10:23:18.683]                 if (base::length(...future.futureOptionsAdded) > 
[10:23:18.683]                   0L) {
[10:23:18.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:23:18.683]                   base::names(opts) <- ...future.futureOptionsAdded
[10:23:18.683]                   base::options(opts)
[10:23:18.683]                 }
[10:23:18.683]                 {
[10:23:18.683]                   {
[10:23:18.683]                     base::options(mc.cores = ...future.mc.cores.old)
[10:23:18.683]                     NULL
[10:23:18.683]                   }
[10:23:18.683]                   options(future.plan = NULL)
[10:23:18.683]                   if (is.na(NA_character_)) 
[10:23:18.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:23:18.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:23:18.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:23:18.683]                     .init = FALSE)
[10:23:18.683]                 }
[10:23:18.683]             }
[10:23:18.683]         }
[10:23:18.683]     })
[10:23:18.683]     if (TRUE) {
[10:23:18.683]         base::sink(type = "output", split = FALSE)
[10:23:18.683]         if (TRUE) {
[10:23:18.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:23:18.683]         }
[10:23:18.683]         else {
[10:23:18.683]             ...future.result["stdout"] <- base::list(NULL)
[10:23:18.683]         }
[10:23:18.683]         base::close(...future.stdout)
[10:23:18.683]         ...future.stdout <- NULL
[10:23:18.683]     }
[10:23:18.683]     ...future.result$conditions <- ...future.conditions
[10:23:18.683]     ...future.result$finished <- base::Sys.time()
[10:23:18.683]     ...future.result
[10:23:18.683] }
[10:23:18.685] MultisessionFuture started
[10:23:18.686] - Launch lazy future ... done
[10:23:18.686] run() for ‘MultisessionFuture’ ... done
[10:23:18.686] result() for ClusterFuture ...
[10:23:18.686] receiveMessageFromWorker() for ClusterFuture ...
[10:23:18.686] - Validating connection of MultisessionFuture
[10:23:18.728] - received message: FutureResult
[10:23:18.728] - Received FutureResult
[10:23:18.728] - Erased future from FutureRegistry
[10:23:18.729] result() for ClusterFuture ...
[10:23:18.729] - result already collected: FutureResult
[10:23:18.729] result() for ClusterFuture ... done
[10:23:18.729] receiveMessageFromWorker() for ClusterFuture ... done
[10:23:18.729] result() for ClusterFuture ... done
[10:23:18.729] result() for ClusterFuture ...
[10:23:18.729] - result already collected: FutureResult
[10:23:18.729] result() for ClusterFuture ... done
[10:23:18.729] result() for ClusterFuture ...
[10:23:18.729] - result already collected: FutureResult
[10:23:18.729] result() for ClusterFuture ... done
[1] 42
[10:23:18.730] result() for ClusterFuture ...
[10:23:18.730] - result already collected: FutureResult
[10:23:18.730] result() for ClusterFuture ... done
multisession ... done
Testing with 2 cores ... done
> 
> message("*** Standard output ... DONE")
*** Standard output ... DONE
> 
> source("incl/end.R")
[10:23:18.731] plan(): Setting new future strategy stack:
[10:23:18.731] List of future strategies:
[10:23:18.731] 1. FutureStrategy:
[10:23:18.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:23:18.731]    - tweaked: FALSE
[10:23:18.731]    - call: future::plan(oplan)
[10:23:18.732] plan(): nbrOfWorkers() = 1
> 
